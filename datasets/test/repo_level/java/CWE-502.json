[
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "/*\n * Copyright (C) 2003, 2004, 2005, 2006 Joe Walnes.\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 XStream Committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n * Created on 26. September 2003 by Joe Walnes\n */\npackage com.thoughtworks.xstream;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.NotActiveException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectInputValidation;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.text.DecimalFormatSymbols;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TimeZone;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.ConverterLookup;\nimport com.thoughtworks.xstream.converters.ConverterRegistry;\nimport com.thoughtworks.xstream.converters.DataHolder;\nimport com.thoughtworks.xstream.converters.MarshallingContext;\nimport com.thoughtworks.xstream.converters.SingleValueConverter;\nimport com.thoughtworks.xstream.converters.SingleValueConverterWrapper;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport com.thoughtworks.xstream.converters.basic.BigDecimalConverter;\nimport com.thoughtworks.xstream.converters.basic.BigIntegerConverter;\nimport com.thoughtworks.xstream.converters.basic.BooleanConverter;\nimport com.thoughtworks.xstream.converters.basic.ByteConverter;\nimport com.thoughtworks.xstream.converters.basic.CharConverter;\nimport com.thoughtworks.xstream.converters.basic.DateConverter;\nimport com.thoughtworks.xstream.converters.basic.DoubleConverter;\nimport com.thoughtworks.xstream.converters.basic.FloatConverter;\nimport com.thoughtworks.xstream.converters.basic.IntConverter;\nimport com.thoughtworks.xstream.converters.basic.LongConverter;\nimport com.thoughtworks.xstream.converters.basic.NullConverter;\nimport com.thoughtworks.xstream.converters.basic.ShortConverter;\nimport com.thoughtworks.xstream.converters.basic.StringBufferConverter;\nimport com.thoughtworks.xstream.converters.basic.StringConverter;\nimport com.thoughtworks.xstream.converters.basic.URIConverter;\nimport com.thoughtworks.xstream.converters.basic.URLConverter;\nimport com.thoughtworks.xstream.converters.collections.ArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.BitSetConverter;\nimport com.thoughtworks.xstream.converters.collections.CharArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.CollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.MapConverter;\nimport com.thoughtworks.xstream.converters.collections.PropertiesConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonCollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeSetConverter;\nimport com.thoughtworks.xstream.converters.extended.ColorConverter;\nimport com.thoughtworks.xstream.converters.extended.DynamicProxyConverter;\nimport com.thoughtworks.xstream.converters.extended.EncodedByteArrayConverter;\nimport com.thoughtworks.xstream.converters.extended.FileConverter;\nimport com.thoughtworks.xstream.converters.extended.FontConverter;\nimport com.thoughtworks.xstream.converters.extended.GregorianCalendarConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaClassConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaFieldConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaMethodConverter;\nimport com.thoughtworks.xstream.converters.extended.LocaleConverter;\nimport com.thoughtworks.xstream.converters.extended.LookAndFeelConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlDateConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimeConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimestampConverter;\nimport com.thoughtworks.xstream.converters.extended.TextAttributeConverter;\nimport com.thoughtworks.xstream.converters.reflection.ExternalizableConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionProvider;\nimport com.thoughtworks.xstream.converters.reflection.SerializableConverter;\nimport com.thoughtworks.xstream.core.ClassLoaderReference;\nimport com.thoughtworks.xstream.core.DefaultConverterLookup;\nimport com.thoughtworks.xstream.core.JVM;\nimport com.thoughtworks.xstream.core.MapBackedDataHolder;\nimport com.thoughtworks.xstream.core.ReferenceByIdMarshallingStrategy;\nimport com.thoughtworks.xstream.core.ReferenceByXPathMarshallingStrategy;\nimport com.thoughtworks.xstream.core.TreeMarshallingStrategy;\nimport com.thoughtworks.xstream.core.util.CompositeClassLoader;\nimport com.thoughtworks.xstream.core.util.CustomObjectInputStream;\nimport com.thoughtworks.xstream.core.util.CustomObjectOutputStream;\nimport com.thoughtworks.xstream.core.util.SelfStreamingInstanceChecker;\nimport com.thoughtworks.xstream.io.HierarchicalStreamDriver;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.thoughtworks.xstream.io.StatefulWriter;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\nimport com.thoughtworks.xstream.mapper.AnnotationConfiguration;\nimport com.thoughtworks.xstream.mapper.ArrayMapper;\nimport com.thoughtworks.xstream.mapper.AttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.AttributeMapper;\nimport com.thoughtworks.xstream.mapper.CachingMapper;\nimport com.thoughtworks.xstream.mapper.ClassAliasingMapper;\nimport com.thoughtworks.xstream.mapper.DefaultImplementationsMapper;\nimport com.thoughtworks.xstream.mapper.DefaultMapper;\nimport com.thoughtworks.xstream.mapper.DynamicProxyMapper;\nimport com.thoughtworks.xstream.mapper.ElementIgnoringMapper;\nimport com.thoughtworks.xstream.mapper.FieldAliasingMapper;\nimport com.thoughtworks.xstream.mapper.ImmutableTypesMapper;\nimport com.thoughtworks.xstream.mapper.ImplicitCollectionMapper;\nimport com.thoughtworks.xstream.mapper.LocalConversionMapper;\nimport com.thoughtworks.xstream.mapper.Mapper;\nimport com.thoughtworks.xstream.mapper.MapperWrapper;\nimport com.thoughtworks.xstream.mapper.OuterClassMapper;\nimport com.thoughtworks.xstream.mapper.PackageAliasingMapper;\nimport com.thoughtworks.xstream.mapper.SecurityMapper;\nimport com.thoughtworks.xstream.mapper.SystemAttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.XStream11XmlFriendlyMapper;\nimport com.thoughtworks.xstream.security.AnyTypePermission;\nimport com.thoughtworks.xstream.security.ArrayTypePermission;\nimport com.thoughtworks.xstream.security.ExplicitTypePermission;\nimport com.thoughtworks.xstream.security.InterfaceTypePermission;\nimport com.thoughtworks.xstream.security.NoPermission;\nimport com.thoughtworks.xstream.security.NoTypePermission;\nimport com.thoughtworks.xstream.security.NullPermission;\nimport com.thoughtworks.xstream.security.PrimitiveTypePermission;\nimport com.thoughtworks.xstream.security.RegExpTypePermission;\nimport com.thoughtworks.xstream.security.TypeHierarchyPermission;\nimport com.thoughtworks.xstream.security.TypePermission;\nimport com.thoughtworks.xstream.security.WildcardTypePermission;\n\n\n/**\n * Simple facade to XStream library, a Java-XML serialization tool.\n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * XStream xstream = new XStream();\n * String xml = xstream.toXML(myObject); // serialize to XML\n * Object myObject2 = xstream.fromXML(xml); // deserialize from XML\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Aliasing classes</h3>\n * \n * <p>\n * To create shorter XML, you can specify aliases for classes using the <code>alias()</code>\n * method. For example, you can shorten all occurrences of element\n * <code>&lt;com.blah.MyThing&gt;</code> to <code>&lt;my-thing&gt;</code> by registering an\n * alias for the class.\n * <p>\n * <hr>\n * <blockquote>\n *\n * <pre>\n * xstream.alias(&quot;my-thing&quot;, MyThing.class);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Converters</h3>\n * \n * <p>\n * XStream contains a map of {@link com.thoughtworks.xstream.converters.Converter} instances, each\n * of which acts as a strategy for converting a particular type of class to XML and back again. Out\n * of the box, XStream contains converters for most basic types (String, Date, int, boolean, etc)\n * and collections (Map, List, Set, Properties, etc). For other objects reflection is used to\n * serialize each field recursively.\n * </p>\n * \n * <p>\n * Extra converters can be registered using the <code>registerConverter()</code> method. Some\n * non-standard converters are supplied in the {@link com.thoughtworks.xstream.converters.extended}\n * package and you can create your own by implementing the\n * {@link com.thoughtworks.xstream.converters.Converter} interface.\n * </p>\n * \n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new SqlTimestampConverter());\n * xstream.registerConverter(new DynamicProxyConverter());\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <p>\n * The converters can be registered with an explicit priority. By default they are registered with \n * XStream.PRIORITY_NORMAL. Converters of same priority will be used in the reverse sequence\n * they have been registered. The default converter, i.e. the converter which will be used if\n * no other registered converter is suitable, can be registered with priority\n * XStream.PRIORITY_VERY_LOW. XStream uses by default the\n * {@link com.thoughtworks.xstream.converters.reflection.ReflectionConverter} as the fallback\n * converter.\n * </p>\n * \n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new CustomDefaultConverter(), XStream.PRIORITY_VERY_LOW);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Object graphs</h3>\n * \n * <p>\n * XStream has support for object graphs; a deserialized object graph will keep references intact,\n * including circular references.\n * </p>\n * \n * <p>\n * XStream can signify references in XML using either relative/absolute XPath or IDs. The mode can be changed using\n * <code>setMode()</code>:\n * </p>\n * \n * <table border='1'>\n * <caption></caption>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_RELATIVE_REFERENCES);</code></td>\n * <td><i>(Default)</i> Uses XPath relative references to signify duplicate references. This produces XML\n * with the least clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate\n * references. This produces XML with the least clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_RELATIVE_REFERENCES);</code></td>\n * <td>Uses XPath relative references to signify duplicate references. The XPath expression ensures that\n * a single node only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate references.  The XPath expression ensures that\n * a single node only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.ID_REFERENCES);</code></td>\n * <td>Uses ID references to signify duplicate references. In some scenarios, such as when using\n * hand-written XML, this is easier to work with.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.NO_REFERENCES);</code></td>\n * <td>This disables object graph support and treats the object structure like a tree. Duplicate\n * references are treated as two separate objects and circular references cause an exception. This\n * is slightly faster and uses less memory than the other two modes.</td>\n * </tr>\n * </table>\n * <h3>Thread safety</h3>\n * <p>\n * The XStream instance is thread-safe. That is, once the XStream instance has been created and\n * configured, it may be shared across multiple threads allowing objects to be\n * serialized/deserialized concurrently. <em>Note, that this only applies if annotations are not \n * auto-detected on-the-fly.</em>\n * </p>\n * <h3>Implicit collections</h3>\n * \n * <p>\n * To avoid the need for special tags for collections, you can define implicit collections using one\n * of the <code>addImplicitCollection</code> methods.\n * </p>\n *\n * @author Joe Walnes\n * @author J&ouml;rg Schaible\n * @author Mauro Talevi\n * @author Guilherme Silveira\n */\npublic class XStream {\n\n    // CAUTION: The sequence of the fields is intentional for an optimal XML output of a\n    // self-serialization!\n    private ReflectionProvider reflectionProvider;\n    private HierarchicalStreamDriver hierarchicalStreamDriver;\n    private ClassLoaderReference classLoaderReference;\n    private MarshallingStrategy marshallingStrategy;\n    private ConverterLookup converterLookup;\n    private ConverterRegistry converterRegistry;\n    private Mapper mapper;\n\n    private PackageAliasingMapper packageAliasingMapper;\n    private ClassAliasingMapper classAliasingMapper;\n    private FieldAliasingMapper fieldAliasingMapper;\n    private ElementIgnoringMapper elementIgnoringMapper;\n    private AttributeAliasingMapper attributeAliasingMapper;\n    private SystemAttributeAliasingMapper systemAttributeAliasingMapper;\n    private AttributeMapper attributeMapper;\n    private DefaultImplementationsMapper defaultImplementationsMapper;\n    private ImmutableTypesMapper immutableTypesMapper;\n    private ImplicitCollectionMapper implicitCollectionMapper;\n    private LocalConversionMapper localConversionMapper;\n    private SecurityMapper securityMapper;\n    private AnnotationConfiguration annotationConfiguration;\n\n    private transient boolean insecureWarning;\n\n    public static final int NO_REFERENCES = 1001;\n    public static final int ID_REFERENCES = 1002;\n    public static final int XPATH_RELATIVE_REFERENCES = 1003;\n    public static final int XPATH_ABSOLUTE_REFERENCES = 1004;\n    public static final int SINGLE_NODE_XPATH_RELATIVE_REFERENCES = 1005;\n    public static final int SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES = 1006;\n\n    public static final int PRIORITY_VERY_HIGH = 10000;\n    public static final int PRIORITY_NORMAL = 0;\n    public static final int PRIORITY_LOW = -10;\n    public static final int PRIORITY_VERY_LOW = -20;\n\n    private static final String ANNOTATION_MAPPER_TYPE = \"com.thoughtworks.xstream.mapper.AnnotationMapper\";\n    private static final Pattern IGNORE_ALL = Pattern.compile(\".*\");\n\n    /**\n     * Constructs a default XStream.\n     * <p>\n     * The instance will use the {@link XppDriver} as default and tries to determine the best\n     * match for the {@link ReflectionProvider} on its own.\n     * </p>\n     *\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream() {\n        this(null, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link ReflectionProvider}.\n     * <p>\n     * The instance will use the {@link XppDriver} as default.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching reflection provider\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(ReflectionProvider reflectionProvider) {\n        this(reflectionProvider, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}.\n     * <p>\n     * The instance will tries to determine the best match for the {@link ReflectionProvider} on\n     * its own.\n     * </p>\n     *\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(null, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver} and\n     * {@link ReflectionProvider}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(reflectionProvider, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and a prepared {@link Mapper} chain.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param driver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     * @deprecated As of 1.3, use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoader, Mapper)}\n     *             instead\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {\n        this(reflectionProvider, driver, new CompositeClassLoader(), mapper);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and a {@link ClassLoaderReference}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference) {\n        this(reflectionProvider, driver, classLoaderReference, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and the {@link ClassLoader} to use.\n     * \n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader) {\n        this(reflectionProvider, driver, classLoader, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain and the {@link ClassLoader}\n     * to use.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader, Mapper mapper) {\n        this(\n            reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, new DefaultConverterLookup());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain and the\n     * {@link ClassLoaderReference}.\n     * <p>\n     * The {@link ClassLoaderReference} should also be used for the {@link Mapper} chain.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference, Mapper mapper) {\n        this(\n            reflectionProvider, driver, classLoaderReference, mapper, new DefaultConverterLookup());\n    }\n    \n    private XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoaderReference classLoader,\n            Mapper mapper, final DefaultConverterLookup defaultConverterLookup) {\n        this(reflectionProvider, driver, classLoader, mapper, new ConverterLookup() {\n            public Converter lookupConverterForType(Class type) {\n                return defaultConverterLookup.lookupConverterForType(type);\n            }\n        }, new ConverterRegistry() {\n            public void registerConverter(Converter converter, int priority) {\n                defaultConverterLookup.registerConverter(converter, priority);\n            }\n        });\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain, the\n     * {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper, ConverterLookup, ConverterRegistry)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader, Mapper mapper, ConverterLookup converterLookup,\n        ConverterRegistry converterRegistry) {\n        this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, converterLookup, converterRegistry);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain, the\n     * {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * <p>\n     * The ClassLoaderReference should also be used for the Mapper chain. The ConverterLookup\n     * should access the ConverterRegistry if you intent to register {@link Converter} instances\n     * with XStream facade or you are using annotations.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances or <em>null</em>\n     *            to prevent any further registry (including annotations)\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference, Mapper mapper, ConverterLookup converterLookup,\n        ConverterRegistry converterRegistry) {\n        if (reflectionProvider == null) {\n            reflectionProvider = JVM.newReflectionProvider();\n        }\n        this.reflectionProvider = reflectionProvider;\n        this.hierarchicalStreamDriver = driver;\n        this.classLoaderReference = classLoaderReference;\n        this.converterLookup = converterLookup;\n        this.converterRegistry = converterRegistry;\n        this.mapper = mapper == null ? buildMapper() : mapper;\n\n        setupMappers();\n        setupSecurity();\n        setupAliases();\n        setupDefaultImplementations();\n        setupConverters();\n        setupImmutableTypes();\n        setMode(XPATH_RELATIVE_REFERENCES);\n    }\n\n    private Mapper buildMapper() {\n        Mapper mapper = new DefaultMapper(classLoaderReference);\n        if (useXStream11XmlFriendlyMapper()) {\n            mapper = new XStream11XmlFriendlyMapper(mapper);\n        }\n        mapper = new DynamicProxyMapper(mapper);\n        mapper = new PackageAliasingMapper(mapper);\n        mapper = new ClassAliasingMapper(mapper);\n        mapper = new ElementIgnoringMapper(mapper);\n        mapper = new FieldAliasingMapper(mapper);\n        mapper = new AttributeAliasingMapper(mapper);\n        mapper = new SystemAttributeAliasingMapper(mapper);\n        mapper = new ImplicitCollectionMapper(mapper, reflectionProvider);\n        mapper = new OuterClassMapper(mapper);\n        mapper = new ArrayMapper(mapper);\n        mapper = new DefaultImplementationsMapper(mapper);\n        mapper = new AttributeMapper(mapper, converterLookup, reflectionProvider);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(\n                \"com.thoughtworks.xstream.mapper.EnumMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new LocalConversionMapper(mapper);\n        mapper = new ImmutableTypesMapper(mapper);\n        if (JVM.isVersion(8)) {\n            mapper = buildMapperDynamically(\"com.thoughtworks.xstream.mapper.LambdaMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new SecurityMapper(mapper);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(ANNOTATION_MAPPER_TYPE, new Class[]{\n                Mapper.class, ConverterRegistry.class, ConverterLookup.class,\n                ClassLoaderReference.class, ReflectionProvider.class}, new Object[]{\n                mapper, converterRegistry, converterLookup, classLoaderReference,\n                reflectionProvider});\n        }\n        mapper = wrapMapper((MapperWrapper)mapper);\n        mapper = new CachingMapper(mapper);\n        return mapper;\n    }\n\n    private Mapper buildMapperDynamically(String className, Class[] constructorParamTypes,\n        Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            return (Mapper)constructor.newInstance(constructorParamValues);\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        }\n    }\n\n    protected MapperWrapper wrapMapper(MapperWrapper next) {\n        return next;\n    }\n\n    /**\n     * @deprecated As of 1.4.8\n     */\n    protected boolean useXStream11XmlFriendlyMapper() {\n        return false;\n    }\n\n    private void setupMappers() {\n        packageAliasingMapper = (PackageAliasingMapper)this.mapper\n            .lookupMapperOfType(PackageAliasingMapper.class);\n        classAliasingMapper = (ClassAliasingMapper)this.mapper\n            .lookupMapperOfType(ClassAliasingMapper.class);\n        elementIgnoringMapper = (ElementIgnoringMapper)this.mapper\n            .lookupMapperOfType(ElementIgnoringMapper.class);\n        fieldAliasingMapper = (FieldAliasingMapper)this.mapper\n            .lookupMapperOfType(FieldAliasingMapper.class);\n        attributeMapper = (AttributeMapper)this.mapper\n            .lookupMapperOfType(AttributeMapper.class);\n        attributeAliasingMapper = (AttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(AttributeAliasingMapper.class);\n        systemAttributeAliasingMapper = (SystemAttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(SystemAttributeAliasingMapper.class);\n        implicitCollectionMapper = (ImplicitCollectionMapper)this.mapper\n            .lookupMapperOfType(ImplicitCollectionMapper.class);\n        defaultImplementationsMapper = (DefaultImplementationsMapper)this.mapper\n            .lookupMapperOfType(DefaultImplementationsMapper.class);\n        immutableTypesMapper = (ImmutableTypesMapper)this.mapper\n            .lookupMapperOfType(ImmutableTypesMapper.class);\n        localConversionMapper = (LocalConversionMapper)this.mapper\n            .lookupMapperOfType(LocalConversionMapper.class);\n        securityMapper = (SecurityMapper)this.mapper\n            .lookupMapperOfType(SecurityMapper.class);\n        annotationConfiguration = (AnnotationConfiguration)this.mapper\n            .lookupMapperOfType(AnnotationConfiguration.class);\n    }\n    \n    protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n        \n        addPermission(AnyTypePermission.ANY);\n        insecureWarning = true;\n    }\n\n    /**\n     * Setup the security framework of a XStream instance.\n     * <p>\n     * This method is a pure helper method for XStream 1.4.x. It initializes an XStream instance with a white list of\n     * well-known and simply types of the Java runtime as it is done in XStream 1.5.x by default. This method will do\n     * therefore nothing in XStream 1.5.\n     * </p>\n     * \n     * @param xstream\n     * @since 1.4.10\n     */\n    public static void setupDefaultSecurity(final XStream xstream) {\n        if (xstream.insecureWarning) {\n            xstream.addPermission(NoTypePermission.NONE);\n            xstream.addPermission(NullPermission.NULL);\n            xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);\n            xstream.addPermission(ArrayTypePermission.ARRAYS);\n            xstream.addPermission(InterfaceTypePermission.INTERFACES);\n            xstream.allowTypeHierarchy(Calendar.class);\n            xstream.allowTypeHierarchy(Collection.class);\n            xstream.allowTypeHierarchy(Map.class);\n            xstream.allowTypeHierarchy(Map.Entry.class);\n            xstream.allowTypeHierarchy(Member.class);\n            xstream.allowTypeHierarchy(Number.class);\n            xstream.allowTypeHierarchy(Throwable.class);\n            xstream.allowTypeHierarchy(TimeZone.class);\n\n            Class type = JVM.loadClassForName(\"java.lang.Enum\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n            type = JVM.loadClassForName(\"java.nio.file.Path\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n\n            final Set types = new HashSet();\n            types.add(BitSet.class);\n            types.add(Charset.class);\n            types.add(Class.class);\n            types.add(Currency.class);\n            types.add(Date.class);\n            types.add(DecimalFormatSymbols.class);\n            types.add(File.class);\n            types.add(Locale.class);\n            types.add(Object.class);\n            types.add(Pattern.class);\n            types.add(StackTraceElement.class);\n            types.add(String.class);\n            types.add(StringBuffer.class);\n            types.add(JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            types.add(URL.class);\n            types.add(URI.class);\n            types.add(JVM.loadClassForName(\"java.util.UUID\"));\n            if (JVM.isSQLAvailable()) {\n                types.add(JVM.loadClassForName(\"java.sql.Timestamp\"));\n                types.add(JVM.loadClassForName(\"java.sql.Time\"));\n                types.add(JVM.loadClassForName(\"java.sql.Date\"));\n            }\n            if (JVM.isVersion(8)) {\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.Clock\"));\n                types.add(JVM.loadClassForName(\"java.time.Duration\"));\n                types.add(JVM.loadClassForName(\"java.time.Instant\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDate\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalTime\"));\n                types.add(JVM.loadClassForName(\"java.time.MonthDay\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetTime\"));\n                types.add(JVM.loadClassForName(\"java.time.Period\"));\n                types.add(JVM.loadClassForName(\"java.time.Ser\"));\n                types.add(JVM.loadClassForName(\"java.time.Year\"));\n                types.add(JVM.loadClassForName(\"java.time.YearMonth\"));\n                types.add(JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.ZoneId\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.Ser\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n            }\n            types.remove(null);\n\n            final Iterator iter = types.iterator();\n            final Class[] classes = new Class[types.size()];\n            for (int i = 0; i < classes.length; ++i) {\n                classes[i] = (Class)iter.next();\n            }\n            xstream.allowTypes(classes);\n        } else {\n            throw new IllegalArgumentException(\"Security framework of XStream instance already initialized\");\n        }\n    }\n\n    protected void setupAliases() {\n        if (classAliasingMapper == null) {\n            return;\n        }\n\n        alias(\"null\", Mapper.Null.class);\n        alias(\"int\", Integer.class);\n        alias(\"float\", Float.class);\n        alias(\"double\", Double.class);\n        alias(\"long\", Long.class);\n        alias(\"short\", Short.class);\n        alias(\"char\", Character.class);\n        alias(\"byte\", Byte.class);\n        alias(\"boolean\", Boolean.class);\n        alias(\"number\", Number.class);\n        alias(\"object\", Object.class);\n        alias(\"big-int\", BigInteger.class);\n        alias(\"big-decimal\", BigDecimal.class);\n\n        alias(\"string-buffer\", StringBuffer.class);\n        alias(\"string\", String.class);\n        alias(\"java-class\", Class.class);\n        alias(\"method\", Method.class);\n        alias(\"constructor\", Constructor.class);\n        alias(\"field\", Field.class);\n        alias(\"date\", Date.class);\n        alias(\"uri\", URI.class);\n        alias(\"url\", URL.class);\n        alias(\"bit-set\", BitSet.class);\n\n        alias(\"map\", Map.class);\n        alias(\"entry\", Map.Entry.class);\n        alias(\"properties\", Properties.class);\n        alias(\"list\", List.class);\n        alias(\"set\", Set.class);\n        alias(\"sorted-set\", SortedSet.class);\n\n        alias(\"linked-list\", LinkedList.class);\n        alias(\"vector\", Vector.class);\n        alias(\"tree-map\", TreeMap.class);\n        alias(\"tree-set\", TreeSet.class);\n        alias(\"hashtable\", Hashtable.class);\n        \n        alias(\"empty-list\", Collections.EMPTY_LIST.getClass());\n        alias(\"empty-map\", Collections.EMPTY_MAP.getClass());\n        alias(\"empty-set\", Collections.EMPTY_SET.getClass());\n        alias(\"singleton-list\", Collections.singletonList(this).getClass());\n        alias(\"singleton-map\", Collections.singletonMap(this, null).getClass());\n        alias(\"singleton-set\", Collections.singleton(this).getClass());\n\n        if (JVM.isAWTAvailable()) {\n            // Instantiating these two classes starts the AWT system, which is undesirable.\n            // Calling loadClass ensures a reference to the class is found but they are not\n            // instantiated.\n            alias(\"awt-color\", JVM.loadClassForName(\"java.awt.Color\", false));\n            alias(\"awt-font\", JVM.loadClassForName(\"java.awt.Font\", false));\n            alias(\"awt-text-attribute\", JVM.loadClassForName(\"java.awt.font.TextAttribute\"));\n        }\n\n        Class type = JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\");\n        if (type != null) {\n            alias(\"activation-data-flavor\", type);\n        }\n\n        if (JVM.isSQLAvailable()) {\n            alias(\"sql-timestamp\", JVM.loadClassForName(\"java.sql.Timestamp\"));\n            alias(\"sql-time\", JVM.loadClassForName(\"java.sql.Time\"));\n            alias(\"sql-date\", JVM.loadClassForName(\"java.sql.Date\"));\n        }\n\n        alias(\"file\", File.class);\n        alias(\"locale\", Locale.class);\n        alias(\"gregorian-calendar\", Calendar.class);\n\n        if (JVM.isVersion(4)) {\n            aliasDynamically(\"auth-subject\", \"javax.security.auth.Subject\");\n            alias(\"linked-hash-map\", JVM.loadClassForName(\"java.util.LinkedHashMap\"));\n            alias(\"linked-hash-set\", JVM.loadClassForName(\"java.util.LinkedHashSet\"));\n            alias(\"trace\", JVM.loadClassForName(\"java.lang.StackTraceElement\"));\n            alias(\"currency\", JVM.loadClassForName(\"java.util.Currency\"));\n            aliasType(\"charset\", JVM.loadClassForName(\"java.nio.charset.Charset\"));\n        }\n\n        if (JVM.isVersion(5)) {\n            aliasDynamically(\"xml-duration\", \"javax.xml.datatype.Duration\");\n            alias(\"concurrent-hash-map\", JVM.loadClassForName(\"java.util.concurrent.ConcurrentHashMap\"));\n            alias(\"enum-set\", JVM.loadClassForName(\"java.util.EnumSet\"));\n            alias(\"enum-map\", JVM.loadClassForName(\"java.util.EnumMap\"));\n            alias(\"string-builder\", JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            alias(\"uuid\", JVM.loadClassForName(\"java.util.UUID\"));\n        }\n        \n        if (JVM.isVersion(7)) {\n            aliasType(\"path\", JVM.loadClassForName(\"java.nio.file.Path\"));\n        }\n\n        if (JVM.isVersion(8)) {\n            alias(\"fixed-clock\", JVM.loadClassForName(\"java.time.Clock$FixedClock\"));\n            alias(\"offset-clock\", JVM.loadClassForName(\"java.time.Clock$OffsetClock\"));\n            alias(\"system-clock\", JVM.loadClassForName(\"java.time.Clock$SystemClock\"));\n            alias(\"tick-clock\", JVM.loadClassForName(\"java.time.Clock$TickClock\"));\n            alias(\"day-of-week\", JVM.loadClassForName(\"java.time.DayOfWeek\"));\n            alias(\"duration\", JVM.loadClassForName(\"java.time.Duration\"));\n            alias(\"instant\", JVM.loadClassForName(\"java.time.Instant\"));\n            alias(\"local-date\", JVM.loadClassForName(\"java.time.LocalDate\"));\n            alias(\"local-date-time\", JVM.loadClassForName(\"java.time.LocalDateTime\"));\n            alias(\"local-time\", JVM.loadClassForName(\"java.time.LocalTime\"));\n            alias(\"month\", JVM.loadClassForName(\"java.time.Month\"));\n            alias(\"month-day\", JVM.loadClassForName(\"java.time.MonthDay\"));\n            alias(\"offset-date-time\", JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n            alias(\"offset-time\", JVM.loadClassForName(\"java.time.OffsetTime\"));\n            alias(\"period\", JVM.loadClassForName(\"java.time.Period\"));\n            alias(\"year\", JVM.loadClassForName(\"java.time.Year\"));\n            alias(\"year-month\", JVM.loadClassForName(\"java.time.YearMonth\"));\n            alias(\"zoned-date-time\", JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n            aliasType(\"zone-id\", JVM.loadClassForName(\"java.time.ZoneId\"));\n            aliasType(\"chronology\", JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n            alias(\"hijrah-date\", JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n            alias(\"hijrah-era\", JVM.loadClassForName(\"java.time.chrono.HijrahEra\"));\n            alias(\"japanese-date\", JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n            alias(\"japanese-era\", JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n            alias(\"minguo-date\", JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n            alias(\"minguo-era\", JVM.loadClassForName(\"java.time.chrono.MinguoEra\"));\n            alias(\"thai-buddhist-date\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n            alias(\"thai-buddhist-era\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistEra\"));\n            alias(\"chrono-field\", JVM.loadClassForName(\"java.time.temporal.ChronoField\"));\n            alias(\"chrono-unit\", JVM.loadClassForName(\"java.time.temporal.ChronoUnit\"));\n            alias(\"iso-field\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Field\"));\n            alias(\"iso-unit\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Unit\"));\n            alias(\"julian-field\", JVM.loadClassForName(\"java.time.temporal.JulianFields$Field\"));\n            alias(\"temporal-value-range\", JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n            alias(\"week-fields\", JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n        }\n\n        if (JVM.loadClassForName(\"java.lang.invoke.SerializedLambda\") != null) {\n            aliasDynamically(\"serialized-lambda\", \"java.lang.invoke.SerializedLambda\");\n        }\n    }\n\n    private void aliasDynamically(String alias, String className) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            alias(alias, type);\n        }\n    }\n\n    protected void setupDefaultImplementations() {\n        if (defaultImplementationsMapper == null) {\n            return;\n        }\n        addDefaultImplementation(HashMap.class, Map.class);\n        addDefaultImplementation(ArrayList.class, List.class);\n        addDefaultImplementation(HashSet.class, Set.class);\n        addDefaultImplementation(TreeSet.class, SortedSet.class);\n        addDefaultImplementation(GregorianCalendar.class, Calendar.class);\n    }\n\n    protected void setupConverters() {\n        registerConverter(\n            new ReflectionConverter(mapper, reflectionProvider), PRIORITY_VERY_LOW);\n\n        registerConverter(\n            new SerializableConverter(mapper, reflectionProvider, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new ExternalizableConverter(mapper, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new InternalBlackList(), PRIORITY_LOW);\n\n        registerConverter(new NullConverter(), PRIORITY_VERY_HIGH);\n        registerConverter(new IntConverter(), PRIORITY_NORMAL);\n        registerConverter(new FloatConverter(), PRIORITY_NORMAL);\n        registerConverter(new DoubleConverter(), PRIORITY_NORMAL);\n        registerConverter(new LongConverter(), PRIORITY_NORMAL);\n        registerConverter(new ShortConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new CharConverter(), PRIORITY_NORMAL);\n        registerConverter(new BooleanConverter(), PRIORITY_NORMAL);\n        registerConverter(new ByteConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new StringConverter(), PRIORITY_NORMAL);\n        registerConverter(new StringBufferConverter(), PRIORITY_NORMAL);\n        registerConverter(new DateConverter(), PRIORITY_NORMAL);\n        registerConverter(new BitSetConverter(), PRIORITY_NORMAL);\n        registerConverter(new URIConverter(), PRIORITY_NORMAL);\n        registerConverter(new URLConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigIntegerConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigDecimalConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new ArrayConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new CharArrayConverter(), PRIORITY_NORMAL);\n        registerConverter(new CollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new MapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeSetConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonCollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new PropertiesConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new EncodedByteArrayConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new FileConverter(), PRIORITY_NORMAL);\n        if (JVM.isSQLAvailable()) {\n            registerConverter(new SqlTimestampConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlTimeConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlDateConverter(), PRIORITY_NORMAL);\n        }\n        registerConverter(new DynamicProxyConverter(mapper, classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaClassConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaMethodConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaFieldConverter(classLoaderReference), PRIORITY_NORMAL);\n\n        if (JVM.isAWTAvailable()) {\n            registerConverter(new FontConverter(mapper), PRIORITY_NORMAL);\n            registerConverter(new ColorConverter(), PRIORITY_NORMAL);\n            registerConverter(new TextAttributeConverter(), PRIORITY_NORMAL);\n        }\n        if (JVM.isSwingAvailable()) {\n            registerConverter(\n                new LookAndFeelConverter(mapper, reflectionProvider), PRIORITY_NORMAL);\n        }\n        registerConverter(new LocaleConverter(), PRIORITY_NORMAL);\n        registerConverter(new GregorianCalendarConverter(), PRIORITY_NORMAL);\n\n        if (JVM.isVersion(4)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.SubjectConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.ThrowableConverter\",\n                PRIORITY_NORMAL, new Class[]{ConverterLookup.class},\n                new Object[]{converterLookup});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.StackTraceElementConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.CurrencyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.RegexPatternConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.CharsetConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n\n        if (JVM.isVersion(5)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            if (JVM.loadClassForName(\"javax.xml.datatype.Duration\") != null) {\n                registerConverterDynamically(\n                    \"com.thoughtworks.xstream.converters.extended.DurationConverter\",\n                    PRIORITY_NORMAL, null, null);\n            }\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumSetConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumMapConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.basic.StringBuilderConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.basic.UUIDConverter\", PRIORITY_NORMAL,\n                null, null);\n        }\n        if (JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\") != null) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ActivationDataFlavorConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(7)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.PathConverter\",\n                    PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(8)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ChronologyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.DurationConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.HijrahDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseEraConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.InstantConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalTimeConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MinguoDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MonthDayConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.PeriodConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.SystemClockConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ThaiBuddhistDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ValueRangeConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.WeekFieldsConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearMonthConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZonedDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZoneIdConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.reflection.LambdaConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class, ReflectionProvider.class, ClassLoaderReference.class},\n                new Object[]{mapper, reflectionProvider, classLoaderReference});\n        }\n\n        registerConverter(\n            new SelfStreamingInstanceChecker(converterLookup, this), PRIORITY_NORMAL);\n    }\n\n    private void registerConverterDynamically(String className, int priority,\n        Class[] constructorParamTypes, Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            Object instance = constructor.newInstance(constructorParamValues);\n            if (instance instanceof Converter) {\n                registerConverter((Converter)instance, priority);\n            } else if (instance instanceof SingleValueConverter) {\n                registerConverter((SingleValueConverter)instance, priority);\n            }\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate converter : \" + className, e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate converter : \" + className, e);\n        }\n    }\n\n    protected void setupImmutableTypes() {\n        if (immutableTypesMapper == null) {\n            return;\n        }\n\n        // primitives are always immutable\n        addImmutableType(boolean.class, false);\n        addImmutableType(Boolean.class, false);\n        addImmutableType(byte.class, false);\n        addImmutableType(Byte.class, false);\n        addImmutableType(char.class, false);\n        addImmutableType(Character.class, false);\n        addImmutableType(double.class, false);\n        addImmutableType(Double.class, false);\n        addImmutableType(float.class, false);\n        addImmutableType(Float.class, false);\n        addImmutableType(int.class, false);\n        addImmutableType(Integer.class, false);\n        addImmutableType(long.class, false);\n        addImmutableType(Long.class, false);\n        addImmutableType(short.class, false);\n        addImmutableType(Short.class, false);\n\n        // additional types\n        addImmutableType(Mapper.Null.class, false);\n        addImmutableType(BigDecimal.class, false);\n        addImmutableType(BigInteger.class, false);\n        addImmutableType(String.class, false);\n        addImmutableType(URL.class, false);\n        addImmutableType(File.class, false);\n        addImmutableType(Class.class, false);\n\n        if (JVM.isVersion(7)) {\n            Class type = JVM.loadClassForName(\"java.nio.file.Paths\");\n            if (type != null) {\n                Method methodGet;\n                try {\n                    methodGet = type.getDeclaredMethod(\"get\", new Class[] {String.class, String[].class});\n                    if (methodGet != null) {\n                        Object path = methodGet.invoke(null, new Object[]{\".\", new String[0]});\n                        if (path != null) {\n                            addImmutableType(path.getClass(), false);\n                        }\n                    }\n                } catch (NoSuchMethodException e) {\n                } catch (SecurityException e) {\n                } catch (IllegalAccessException e) {\n                } catch (InvocationTargetException e) {\n                }\n            }\n        }\n\n        if (JVM.isAWTAvailable()) {\n            addImmutableTypeDynamically(\"java.awt.font.TextAttribute\", false);\n        }\n\n        if (JVM.isVersion(4)) {\n            // late bound types - allows XStream to be compiled on earlier JDKs\n            addImmutableTypeDynamically(\"java.nio.charset.Charset\", true);\n            addImmutableTypeDynamically(\"java.util.Currency\", true);\n        }\n        \n        if (JVM.isVersion(5)) {\n            addImmutableTypeDynamically(\"java.util.UUID\", true);\n        }\n\n        addImmutableType(URI.class, true);\n        addImmutableType(Collections.EMPTY_LIST.getClass(), true);\n        addImmutableType(Collections.EMPTY_SET.getClass(), true);\n        addImmutableType(Collections.EMPTY_MAP.getClass(), true);\n\n        if (JVM.isVersion(8)) {\n            addImmutableTypeDynamically(\"java.time.Duration\", false);\n            addImmutableTypeDynamically(\"java.time.Instant\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDate\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.LocalTime\", false);\n            addImmutableTypeDynamically(\"java.time.MonthDay\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetTime\", false);\n            addImmutableTypeDynamically(\"java.time.Period\", false);\n            addImmutableTypeDynamically(\"java.time.Year\", false);\n            addImmutableTypeDynamically(\"java.time.YearMonth\", false);\n            addImmutableTypeDynamically(\"java.time.ZonedDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneId\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneOffset\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneRegion\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.IsoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseEra\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistDate\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Field\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Unit\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.JulianFields$Field\", false);\n        }\n    }\n\n    private void addImmutableTypeDynamically(String className, boolean isReferenceable) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            addImmutableType(type, isReferenceable);\n        }\n    }\n\n    public void setMarshallingStrategy(MarshallingStrategy marshallingStrategy) {\n        this.marshallingStrategy = marshallingStrategy;\n    }\n\n    /**\n     * Serialize an object to a pretty-printed XML String.\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public String toXML(Object obj) {\n        Writer writer = new StringWriter();\n        toXML(obj, writer);\n        return writer.toString();\n    }\n\n    /**\n     * Serialize an object to the given Writer as pretty-printed XML. The Writer will be flushed\n     * afterwards and in case of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, Writer out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize an object to the given OutputStream as pretty-printed XML. The OutputStream\n     * will be flushed afterwards and in case of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, OutputStream out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer) {\n        marshal(obj, writer, null);\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     * \n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you\n     *            want. If not present, XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer, DataHolder dataHolder) {\n        marshallingStrategy.marshal(writer, obj, converterLookup, mapper, dataHolder);\n    }\n\n    /**\n     * Deserialize an object from an XML String.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml) {\n        return fromXML(new StringReader(xml));\n    }\n\n    /**\n     * Deserialize an object from an XML Reader.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader reader) {\n        return unmarshal(hierarchicalStreamDriver.createReader(reader), null);\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), null);\n    }\n\n    /**\n     * Deserialize an object from a URL.\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url) {\n        return fromXML(url, null);\n    }\n\n    /**\n     * Deserialize an object from a file.\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file) {\n        return fromXML(file, null);\n    }\n\n    /**\n     * Deserialize an object from an XML String, populating the fields of the given root object\n     * instead of instantiating a new one. Note, that this is a special use case! With the\n     * ReflectionConverter XStream will write directly into the raw memory area of the existing\n     * object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml, Object root) {\n        return fromXML(new StringReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from an XML Reader, populating the fields of the given root object\n     * instead of instantiating a new one. Note, that this is a special use case! With the\n     * ReflectionConverter XStream will write directly into the raw memory area of the existing\n     * object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader xml, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from a URL, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(url), root);\n    }\n\n    /**\n     * Deserialize an object from a file, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file, Object root) {\n        HierarchicalStreamReader reader = hierarchicalStreamDriver.createReader(file);\n        try {\n            return unmarshal(reader, root);\n        } finally {\n            reader.close();\n        }\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), root);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader) {\n        return unmarshal(reader, null, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML), populating the\n     * fields of the given root object instead of instantiating a new one. Note, that this is a\n     * special use case! With the ReflectionConverter XStream will write directly into the raw\n     * memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root) {\n        return unmarshal(reader, root, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     * \n     * @param root If present, the passed in object will have its fields populated, as opposed\n     *            to XStream creating a new instance. Note, that this is a special use case!\n     *            With the ReflectionConverter XStream will write directly into the raw memory\n     *            area of the existing object. Use with care!\n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you\n     *            want. If not present, XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root, DataHolder dataHolder) {\n        try {\n            if (insecureWarning) {\n                insecureWarning = false;\n                System.err.println(\"Security framework of XStream not initialized, XStream is probably vulnerable.\");\n            }\n            return marshallingStrategy.unmarshal(\n                root, reader, dataHolder, converterLookup, mapper);\n\n        } catch (ConversionException e) {\n            Package pkg = getClass().getPackage();\n            String version = pkg != null ? pkg.getImplementationVersion() : null;\n            e.add(\"version\", version != null ? version : \"not available\");\n            throw e;\n        }\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void alias(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addClassAlias(name, type);\n    }\n\n    /**\n     * Alias a type to a shorter name to be used in XML elements. Any class that is assignable\n     * to this type will be aliased to the same name.\n     * \n     * @param name Short name\n     * @param type Type to be aliased\n     * @since 1.2\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void aliasType(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addTypeAlias(name, type);\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @param defaultImplementation Default implementation of type to use if no other specified.\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no\n     *             {@link ClassAliasingMapper} is available\n     */\n    public void alias(String name, Class type, Class defaultImplementation) {\n        alias(name, type);\n        addDefaultImplementation(defaultImplementation, type);\n    }\n\n    /**\n     * Alias a package to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param pkgName package to be aliased\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no\n     *             {@link PackageAliasingMapper} is available\n     * @since 1.3.1\n     */\n    public void aliasPackage(String name, String pkgName) {\n        if (packageAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + PackageAliasingMapper.class.getName()\n                + \" available\");\n        }\n        packageAliasingMapper.addPackageAlias(name, pkgName);\n    }\n\n    /**\n     * Create an alias for a field name.\n     *\n     * @param alias the alias itself\n     * @param definedIn the type that declares the field\n     * @param fieldName the name of the field\n     * @throws InitializationException if no {@link FieldAliasingMapper} is available\n     */\n    public void aliasField(String alias, Class definedIn, String fieldName) {\n        if (fieldAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + FieldAliasingMapper.class.getName()\n                + \" available\");\n        }\n        fieldAliasingMapper.addFieldAlias(alias, definedIn, fieldName);\n    }\n\n    /**\n     * Create an alias for an attribute\n     *\n     * @param alias the alias itself\n     * @param attributeName the name of the attribute\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     */\n    public void aliasAttribute(String alias, String attributeName) {\n        if (attributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        attributeAliasingMapper.addAliasFor(attributeName, alias);\n    }\n\n    /**\n     * Create an alias for a system attribute. XStream will not write a system attribute if its\n     * alias is set to <code>null</code>. However, this is not reversible, i.e. deserialization\n     * of the result is likely to fail afterwards and will not produce an object equal to the\n     * originally written one.\n     * \n     * @param alias the alias itself (may be <code>null</code>)\n     * @param systemAttributeName the name of the system attribute\n     * @throws InitializationException if no {@link SystemAttributeAliasingMapper} is available\n     * @since 1.3.1\n     */\n    public void aliasSystemAttribute(String alias, String systemAttributeName) {\n        if (systemAttributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + SystemAttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        systemAttributeAliasingMapper.addAliasFor(systemAttributeName, alias);\n    }\n\n    /**\n     * Create an alias for an attribute.\n     *\n     * @param definedIn the type where the attribute is defined\n     * @param attributeName the name of the attribute\n     * @param alias the alias itself\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     * @since 1.2.2\n     */\n    public void aliasAttribute(Class definedIn, String attributeName, String alias) {\n        aliasField(alias, definedIn, attributeName);\n        useAttributeFor(definedIn, attributeName);\n    }\n\n    /**\n     * Use an attribute for a field or a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(String fieldName, Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(fieldName, type);\n    }\n\n    /**\n     * Use an attribute for a field declared in a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param definedIn the Class containing such field\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2.2\n     */\n    public void useAttributeFor(Class definedIn, String fieldName) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(definedIn, fieldName);\n    }\n\n    /**\n     * Use an attribute for an arbitrary type.\n     *\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(type);\n    }\n\n    /**\n     * Associate a default implementation of a class with an object. Whenever XStream encounters\n     * an instance of this type, it will use the default implementation instead. For example,\n     * java.util.ArrayList is the default implementation of java.util.List.\n     * \n     * @param defaultImplementation\n     * @param ofType\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} is available\n     */\n    public void addDefaultImplementation(Class defaultImplementation, Class ofType) {\n        if (defaultImplementationsMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + DefaultImplementationsMapper.class.getName()\n                + \" available\");\n        }\n        defaultImplementationsMapper.addDefaultImplementation(defaultImplementation, ofType);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times. However, references are still supported at deserialization time.\n     *\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @deprecated As of 1.4.9 use {@link #addImmutableType(Class, boolean)}\n     */\n    public void addImmutableType(Class type) {\n        addImmutableType(type, true);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times.\n     * <p>\n     * Note, while a reference-keeping marshaller will not write references for immutable types into the stream, a\n     * reference-keeping unmarshaller can still support such references in the stream for compatibility reasons at the\n     * expense of memory consumption. Therefore declare these types only as referenceable if your already persisted\n     * streams do contain such references. Otherwise you may waste a lot of memory during deserialization.\n     * </p>\n     *\n     * @param isReferenceable <code>true</code> if support at deserialization time is required for compatibility at the\n     *            cost of a higher memory footprint, <code>false</code> otherwise\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @since 1.4.9\n     */\n    public void addImmutableType(final Class type, final boolean isReferenceable) {\n        if (immutableTypesMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImmutableTypesMapper.class.getName()\n                + \" available\");\n        }\n        immutableTypesMapper.addImmutableType(type, isReferenceable);\n    }\n\n    public void registerConverter(Converter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(Converter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(converter, priority);\n        }\n    }\n\n    public void registerConverter(SingleValueConverter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(SingleValueConverter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(\n                new SingleValueConverterWrapper(converter), priority);\n        }\n    }\n\n    /**\n     * Register a local {@link Converter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName, Converter converter) {\n        if (localConversionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + LocalConversionMapper.class.getName()\n                + \" available\");\n        }\n        localConversionMapper.registerLocalConverter(definedIn, fieldName, converter);\n    }\n\n    /**\n     * Register a local {@link SingleValueConverter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName,\n        SingleValueConverter converter) {\n        registerLocalConverter(\n            definedIn, fieldName, (Converter)new SingleValueConverterWrapper(converter));\n    }\n\n    /**\n     * Retrieve the {@link Mapper}. This is by default a chain of {@link MapperWrapper\n     * MapperWrappers}.\n     * \n     * @return the mapper\n     * @since 1.2\n     */\n    public Mapper getMapper() {\n        return mapper;\n    }\n\n    /**\n     * Retrieve the {@link ReflectionProvider} in use.\n     *\n     * @return the mapper\n     * @since 1.2.1\n     */\n    public ReflectionProvider getReflectionProvider() {\n        return reflectionProvider;\n    }\n\n    public ConverterLookup getConverterLookup() {\n        return converterLookup;\n    }\n\n    /**\n     * Change mode for dealing with duplicate references. Valid values are\n     * <code>XPATH_ABSOLUTE_REFERENCES</code>, <code>XPATH_RELATIVE_REFERENCES</code>,\n     * <code>XStream.ID_REFERENCES</code> and <code>XStream.NO_REFERENCES</code>.\n     * \n     * @throws IllegalArgumentException if the mode is not one of the declared types\n     * @see #XPATH_ABSOLUTE_REFERENCES\n     * @see #XPATH_RELATIVE_REFERENCES\n     * @see #ID_REFERENCES\n     * @see #NO_REFERENCES\n     */\n    public void setMode(int mode) {\n        switch (mode) {\n        case NO_REFERENCES:\n            setMarshallingStrategy(new TreeMarshallingStrategy());\n            break;\n        case ID_REFERENCES:\n            setMarshallingStrategy(new ReferenceByIdMarshallingStrategy());\n            break;\n        case XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.RELATIVE));\n            break;\n        case XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.ABSOLUTE));\n            break;\n        case SINGLE_NODE_XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                  ReferenceByXPathMarshallingStrategy.RELATIVE \n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        case SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                  ReferenceByXPathMarshallingStrategy.ABSOLUTE \n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown mode : \" + mode);\n        }\n    }\n\n    /**\n     * Adds a default implicit collection which is used for any unmapped XML tag.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName, null, null);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given itemType.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     * @param itemType type of the items to be part of this collection\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, null, itemType);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given element name defined by\n     * itemFieldName.\n     * \n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     * @param itemFieldName element name of the implicit collection\n     * @param itemType item type to be aliases be the itemFieldName\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, String itemFieldName,\n        Class itemType) {\n        addImplicitMap(ownerType, fieldName, itemFieldName, itemType, null);\n    }\n\n    /**\n     * Adds an implicit array.\n     *\n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given itemType when the array\n     * type matches.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemType type of the items to be part of this array\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available or the\n     * array type does not match the itemType\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, itemType);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given element name defined by\n     * itemName.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemName alias name of the items\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName, String itemName) {\n        addImplicitCollection(ownerType, fieldName, itemName, null);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            map type or matching the default implementation type of the map\n     *            type.\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4 \n     */\n    public void addImplicitMap(Class ownerType, String fieldName, Class itemType, String keyFieldName) {\n        addImplicitMap(ownerType, fieldName, null, itemType, keyFieldName);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            map type or matching the default implementation type of the map\n     *            type.\n     * @param itemName alias name of the items\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4 \n     */\n    public void addImplicitMap(Class ownerType, String fieldName, String itemName, \n        Class itemType, String keyFieldName) {\n        if (implicitCollectionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImplicitCollectionMapper.class.getName()\n                + \" available\");\n        }\n        implicitCollectionMapper.add(ownerType, fieldName, itemName, itemType, keyFieldName);\n    }\n\n    /**\n     * Create a DataHolder that can be used to pass data to the converters. The DataHolder is provided with a call to\n     * {@link #marshal(Object, HierarchicalStreamWriter, DataHolder)},\n     * {@link #unmarshal(HierarchicalStreamReader, Object, DataHolder)},\n     * {@link #createObjectInputStream(HierarchicalStreamReader, DataHolder)} or\n     * {@link #createObjectOutputStream(HierarchicalStreamWriter, String, DataHolder)}.\n     *\n     * @return a new {@link DataHolder}\n     */\n    public DataHolder newDataHolder() {\n        return new MapBackedDataHolder();\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer) throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(writer), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(HierarchicalStreamWriter writer)\n        throws IOException {\n        return createObjectOutputStream(writer, \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer, String rootNodeName)\n        throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(writer), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream\n     * using XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out) throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(out), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream\n     * using XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out, String rootNodeName)\n        throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(out), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * Because an ObjectOutputStream can contain multiple items and XML only allows a single\n     * root node, the stream must be written inside an enclosing node.\n     * </p>\n     * <p>\n     * It is necessary to call ObjectOutputStream.close() when done, otherwise the stream will\n     * be incomplete.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     *  ObjectOutputStream out = xstream.createObjectOutputStream(aWriter, &quot;things&quot;);\n     *   out.writeInt(123);\n     *   out.writeObject(&quot;Hello&quot;);\n     *   out.writeObject(someObject)\n     *   out.close();\n     * </pre>\n     *\n     * @param writer The writer to serialize the objects to.\n     * @param rootNodeName The name of the root node enclosing the stream of objects.\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName)\n            throws IOException {\n        return createObjectOutputStream(writer, rootNodeName, null);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName,\n            final DataHolder dataHolder) throws IOException {\n        final StatefulWriter statefulWriter = new StatefulWriter(writer);\n        statefulWriter.startNode(rootNodeName, null);\n        return new CustomObjectOutputStream(new CustomObjectOutputStream.StreamCallback() {\n            public void writeToStream(final Object object) {\n                marshal(object, statefulWriter, dataHolder);\n            }\n\n            public void writeFieldsToStream(Map fields) throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void defaultWriteObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void flush() {\n                statefulWriter.flush();\n            }\n\n            public void close() {\n                if (statefulWriter.state() != StatefulWriter.STATE_CLOSED) {\n                    statefulWriter.endNode();\n                    statefulWriter.close();\n                }\n            }\n        });\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using\n     * XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(Reader xmlReader) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(xmlReader));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from an InputStream\n     * using XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.3\n     */\n    public ObjectInputStream createObjectInputStream(InputStream in) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(in));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     * <p>\n     * It is necessary to call ObjectInputStream.close() when done, otherwise the stream might keep system resources.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     * ObjectInputStream in = xstream.createObjectOutputStream(aReader);\n     * int a = out.readInt();\n     * Object b = out.readObject();\n     * Object c = out.readObject();\n     * </pre>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader) throws IOException {\n        return createObjectInputStream(reader, null);\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader, final DataHolder dataHolder)\n            throws IOException {\n        return new CustomObjectInputStream(new CustomObjectInputStream.StreamCallback() {\n            public Object readFromStream() throws EOFException {\n                if (!reader.hasMoreChildren()) {\n                    throw new EOFException();\n                }\n                reader.moveDown();\n                final Object result = unmarshal(reader, dataHolder);\n                reader.moveUp();\n                return result;\n            }\n\n            public Map readFieldsFromStream() throws IOException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void defaultReadObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void registerValidation(ObjectInputValidation validation, int priority)\n                throws NotActiveException {\n                throw new NotActiveException(\"stream inactive\");\n            }\n\n            public void close() {\n                reader.close();\n            }\n        }, classLoaderReference);\n    }\n\n    /**\n     * Change the ClassLoader XStream uses to load classes. Creating an XStream instance it will\n     * register for all kind of classes and types of the current JDK, but not for any 3rd party\n     * type. To ensure that all other types are loaded with your class loader, you should call\n     * this method as early as possible - or consider to provide the class loader directly in\n     * the constructor.\n     * \n     * @since 1.1.1\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        classLoaderReference.setReference(classLoader);\n    }\n\n    /**\n     * Retrieve the ClassLoader XStream uses to load classes.\n     *\n     * @since 1.1.1\n     */\n    public ClassLoader getClassLoader() {\n        return classLoaderReference.getReference();\n    }\n    \n    /**\n     * Retrieve the reference to this instance' ClassLoader. Use this reference for other\n     * XStream components (like converters) to ensure that they will use a changed ClassLoader\n     * instance automatically.\n     * \n     * @return the reference\n     * @since 1.4.5\n     */\n    public ClassLoaderReference getClassLoaderReference() {\n        return classLoaderReference;\n    }\n\n    /**\n     * Prevents a field from being serialized. To omit a field you must always provide the\n     * declaring type and not necessarily the type that is converted.\n     * \n     * @since 1.1.3\n     * @throws InitializationException if no {@link ElementIgnoringMapper} is available\n     */\n    public void omitField(Class definedIn, String fieldName) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.omitField(definedIn, fieldName);\n    }\n    \n    /**\n     * Ignore all unknown elements.\n     *\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements() {\n        ignoreUnknownElements(IGNORE_ALL);\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(String pattern) {\n        ignoreUnknownElements(Pattern.compile(pattern));\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(final Pattern pattern) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.addElementsToIgnore(pattern);\n    }\n\n    /**\n     * Process the annotations of the given types and configure the XStream.\n     *\n     * @param types the types with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class[] types) {\n        if (annotationConfiguration == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ANNOTATION_MAPPER_TYPE\n                + \" available\");\n        }\n        annotationConfiguration.processAnnotations(types);\n    }\n\n    /**\n     * Process the annotations of the given type and configure the XStream. A call of this\n     * method will automatically turn the auto-detection mode for annotations off.\n     * \n     * @param type the type with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class type) {\n        processAnnotations(new Class[]{type});\n    }\n\n    /**\n     * Set the auto-detection mode of the AnnotationMapper. Note that auto-detection implies\n     * that the XStream is configured while it is processing the XML steams. This is a potential\n     * concurrency problem. Also is it technically not possible to detect all class aliases at\n     * deserialization. You have been warned!\n     * \n     * @param mode <code>true</code> if annotations are auto-detected\n     * @since 1.3\n     */\n    public void autodetectAnnotations(boolean mode) {\n        if (annotationConfiguration != null) {\n            annotationConfiguration.autodetectAnnotations(mode);\n        }\n    }\n    \n    /**\n     * Add a new security permission.\n     * \n     * <p>\n     * Permissions are evaluated in the added sequence. An instance of {@link NoTypePermission} or\n     * {@link AnyTypePermission} will implicitly wipe any existing permission.\n     * </p>\n     *\n     * @param permission the permission to add\n     * @since 1.4.7\n     */\n    public void addPermission(TypePermission permission) {\n        if (securityMapper != null) {\n            insecureWarning &= permission != NoTypePermission.NONE;\n            securityMapper.addPermission(permission);\n        }\n    }\n    \n    /**\n     * Add security permission for explicit types by name.\n     *\n     * @param names the type names to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(String[] names) {\n        addPermission(new ExplicitTypePermission(names));\n    }\n    \n    /**\n     * Add security permission for explicit types.\n     *\n     * @param types the types to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(Class[] types) {\n        addPermission(new ExplicitTypePermission(types));\n    }\n    \n    /**\n     * Add security permission for a type hierarchy.\n     *\n     * @param type the base type to allow\n     * @since 1.4.7\n     */\n    public void allowTypeHierarchy(Class type) {\n        addPermission(new TypeHierarchyPermission(type));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(String[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(Pattern[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByWildcard(String[] patterns) {\n        addPermission(new WildcardTypePermission(patterns));\n    }\n    \n    /**\n     * Add security permission denying another one.\n     *\n     * @param permission the permission to deny\n     * @since 1.4.7\n     */\n    public void denyPermission(TypePermission permission) {\n        addPermission(new NoPermission(permission));\n    }\n    \n    /**\n     * Add security permission forbidding explicit types by name.\n     *\n     * @param names the type names to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(String[] names) {\n        denyPermission(new ExplicitTypePermission(names));\n    }\n    \n    /**\n     * Add security permission forbidding explicit types.\n     *\n     * @param types the types to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(Class[] types) {\n        denyPermission(new ExplicitTypePermission(types));\n    }\n    \n    /**\n     * Add security permission forbidding a type hierarchy.\n     *\n     * @param type the base type to forbid\n     * @since 1.4.7\n     */\n    public void denyTypeHierarchy(Class type) {\n        denyPermission(new TypeHierarchyPermission(type));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(String[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(Pattern[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to forbid names\n     * @since 1.4.7\n     */\n    public void denyTypesByWildcard(String[] patterns) {\n        denyPermission(new WildcardTypePermission(patterns));\n    }\n\n    /**\n     * @deprecated As of 1.3, use {@link com.thoughtworks.xstream.InitializationException}\n     *             instead\n     */\n    public static class InitializationException extends XStreamException {\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String, Throwable)}\n         *             instead\n         */\n        public InitializationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String)}\n         *             instead\n         */\n        public InitializationException(String message) {\n            super(message);\n        }\n    }\n\n    private class InternalBlackList implements Converter {\n\n        public boolean canConvert(final Class type) {\n            return (type == void.class || type == Void.class)\n                || (insecureWarning\n                    && type != null\n                    && (type.getName().equals(\"java.beans.EventHandler\")\n                        || type.getName().endsWith(\"$LazyIterator\")\n                        || type.getName().startsWith(\"javax.crypto.\")));\n        }\n\n        public void marshal(final Object source, final HierarchicalStreamWriter writer,\n                final MarshallingContext context) {\n            throw new ConversionException(\"Security alert. Marshalling rejected.\");\n        }\n\n        public Object unmarshal(final HierarchicalStreamReader reader, final UnmarshallingContext context) {\n            throw new ConversionException(\"Security alert. Unmarshalling rejected.\");\n        }\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200196,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "/*\n * Copyright (C) 2003, 2004, 2005, 2006 Joe Walnes.\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 XStream Committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n * Created on 26. September 2003 by Joe Walnes\n */\npackage com.thoughtworks.xstream;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.NotActiveException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectInputValidation;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.text.DecimalFormatSymbols;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TimeZone;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.ConverterLookup;\nimport com.thoughtworks.xstream.converters.ConverterRegistry;\nimport com.thoughtworks.xstream.converters.DataHolder;\nimport com.thoughtworks.xstream.converters.MarshallingContext;\nimport com.thoughtworks.xstream.converters.SingleValueConverter;\nimport com.thoughtworks.xstream.converters.SingleValueConverterWrapper;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport com.thoughtworks.xstream.converters.basic.BigDecimalConverter;\nimport com.thoughtworks.xstream.converters.basic.BigIntegerConverter;\nimport com.thoughtworks.xstream.converters.basic.BooleanConverter;\nimport com.thoughtworks.xstream.converters.basic.ByteConverter;\nimport com.thoughtworks.xstream.converters.basic.CharConverter;\nimport com.thoughtworks.xstream.converters.basic.DateConverter;\nimport com.thoughtworks.xstream.converters.basic.DoubleConverter;\nimport com.thoughtworks.xstream.converters.basic.FloatConverter;\nimport com.thoughtworks.xstream.converters.basic.IntConverter;\nimport com.thoughtworks.xstream.converters.basic.LongConverter;\nimport com.thoughtworks.xstream.converters.basic.NullConverter;\nimport com.thoughtworks.xstream.converters.basic.ShortConverter;\nimport com.thoughtworks.xstream.converters.basic.StringBufferConverter;\nimport com.thoughtworks.xstream.converters.basic.StringConverter;\nimport com.thoughtworks.xstream.converters.basic.URIConverter;\nimport com.thoughtworks.xstream.converters.basic.URLConverter;\nimport com.thoughtworks.xstream.converters.collections.ArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.BitSetConverter;\nimport com.thoughtworks.xstream.converters.collections.CharArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.CollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.MapConverter;\nimport com.thoughtworks.xstream.converters.collections.PropertiesConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonCollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeSetConverter;\nimport com.thoughtworks.xstream.converters.extended.ColorConverter;\nimport com.thoughtworks.xstream.converters.extended.DynamicProxyConverter;\nimport com.thoughtworks.xstream.converters.extended.EncodedByteArrayConverter;\nimport com.thoughtworks.xstream.converters.extended.FileConverter;\nimport com.thoughtworks.xstream.converters.extended.FontConverter;\nimport com.thoughtworks.xstream.converters.extended.GregorianCalendarConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaClassConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaFieldConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaMethodConverter;\nimport com.thoughtworks.xstream.converters.extended.LocaleConverter;\nimport com.thoughtworks.xstream.converters.extended.LookAndFeelConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlDateConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimeConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimestampConverter;\nimport com.thoughtworks.xstream.converters.extended.TextAttributeConverter;\nimport com.thoughtworks.xstream.converters.reflection.ExternalizableConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionProvider;\nimport com.thoughtworks.xstream.converters.reflection.SerializableConverter;\nimport com.thoughtworks.xstream.core.ClassLoaderReference;\nimport com.thoughtworks.xstream.core.DefaultConverterLookup;\nimport com.thoughtworks.xstream.core.JVM;\nimport com.thoughtworks.xstream.core.MapBackedDataHolder;\nimport com.thoughtworks.xstream.core.ReferenceByIdMarshallingStrategy;\nimport com.thoughtworks.xstream.core.ReferenceByXPathMarshallingStrategy;\nimport com.thoughtworks.xstream.core.TreeMarshallingStrategy;\nimport com.thoughtworks.xstream.core.util.CompositeClassLoader;\nimport com.thoughtworks.xstream.core.util.CustomObjectInputStream;\nimport com.thoughtworks.xstream.core.util.CustomObjectOutputStream;\nimport com.thoughtworks.xstream.core.util.SelfStreamingInstanceChecker;\nimport com.thoughtworks.xstream.io.HierarchicalStreamDriver;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.thoughtworks.xstream.io.StatefulWriter;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\nimport com.thoughtworks.xstream.mapper.AnnotationConfiguration;\nimport com.thoughtworks.xstream.mapper.ArrayMapper;\nimport com.thoughtworks.xstream.mapper.AttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.AttributeMapper;\nimport com.thoughtworks.xstream.mapper.CachingMapper;\nimport com.thoughtworks.xstream.mapper.ClassAliasingMapper;\nimport com.thoughtworks.xstream.mapper.DefaultImplementationsMapper;\nimport com.thoughtworks.xstream.mapper.DefaultMapper;\nimport com.thoughtworks.xstream.mapper.DynamicProxyMapper;\nimport com.thoughtworks.xstream.mapper.ElementIgnoringMapper;\nimport com.thoughtworks.xstream.mapper.FieldAliasingMapper;\nimport com.thoughtworks.xstream.mapper.ImmutableTypesMapper;\nimport com.thoughtworks.xstream.mapper.ImplicitCollectionMapper;\nimport com.thoughtworks.xstream.mapper.LocalConversionMapper;\nimport com.thoughtworks.xstream.mapper.Mapper;\nimport com.thoughtworks.xstream.mapper.MapperWrapper;\nimport com.thoughtworks.xstream.mapper.OuterClassMapper;\nimport com.thoughtworks.xstream.mapper.PackageAliasingMapper;\nimport com.thoughtworks.xstream.mapper.SecurityMapper;\nimport com.thoughtworks.xstream.mapper.SystemAttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.XStream11XmlFriendlyMapper;\nimport com.thoughtworks.xstream.security.AnyTypePermission;\nimport com.thoughtworks.xstream.security.ArrayTypePermission;\nimport com.thoughtworks.xstream.security.ExplicitTypePermission;\nimport com.thoughtworks.xstream.security.InterfaceTypePermission;\nimport com.thoughtworks.xstream.security.NoPermission;\nimport com.thoughtworks.xstream.security.NoTypePermission;\nimport com.thoughtworks.xstream.security.NullPermission;\nimport com.thoughtworks.xstream.security.PrimitiveTypePermission;\nimport com.thoughtworks.xstream.security.RegExpTypePermission;\nimport com.thoughtworks.xstream.security.TypeHierarchyPermission;\nimport com.thoughtworks.xstream.security.TypePermission;\nimport com.thoughtworks.xstream.security.WildcardTypePermission;\n\n\n/**\n * Simple facade to XStream library, a Java-XML serialization tool.\n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * XStream xstream = new XStream();\n * String xml = xstream.toXML(myObject); // serialize to XML\n * Object myObject2 = xstream.fromXML(xml); // deserialize from XML\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Aliasing classes</h3>\n * \n * <p>\n * To create shorter XML, you can specify aliases for classes using the <code>alias()</code>\n * method. For example, you can shorten all occurrences of element\n * <code>&lt;com.blah.MyThing&gt;</code> to <code>&lt;my-thing&gt;</code> by registering an\n * alias for the class.\n * <p>\n * <hr>\n * <blockquote>\n *\n * <pre>\n * xstream.alias(&quot;my-thing&quot;, MyThing.class);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Converters</h3>\n * \n * <p>\n * XStream contains a map of {@link com.thoughtworks.xstream.converters.Converter} instances, each\n * of which acts as a strategy for converting a particular type of class to XML and back again. Out\n * of the box, XStream contains converters for most basic types (String, Date, int, boolean, etc)\n * and collections (Map, List, Set, Properties, etc). For other objects reflection is used to\n * serialize each field recursively.\n * </p>\n * \n * <p>\n * Extra converters can be registered using the <code>registerConverter()</code> method. Some\n * non-standard converters are supplied in the {@link com.thoughtworks.xstream.converters.extended}\n * package and you can create your own by implementing the\n * {@link com.thoughtworks.xstream.converters.Converter} interface.\n * </p>\n * \n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new SqlTimestampConverter());\n * xstream.registerConverter(new DynamicProxyConverter());\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <p>\n * The converters can be registered with an explicit priority. By default they are registered with \n * XStream.PRIORITY_NORMAL. Converters of same priority will be used in the reverse sequence\n * they have been registered. The default converter, i.e. the converter which will be used if\n * no other registered converter is suitable, can be registered with priority\n * XStream.PRIORITY_VERY_LOW. XStream uses by default the\n * {@link com.thoughtworks.xstream.converters.reflection.ReflectionConverter} as the fallback\n * converter.\n * </p>\n * \n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new CustomDefaultConverter(), XStream.PRIORITY_VERY_LOW);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Object graphs</h3>\n * \n * <p>\n * XStream has support for object graphs; a deserialized object graph will keep references intact,\n * including circular references.\n * </p>\n * \n * <p>\n * XStream can signify references in XML using either relative/absolute XPath or IDs. The mode can be changed using\n * <code>setMode()</code>:\n * </p>\n * \n * <table border='1'>\n * <caption></caption>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_RELATIVE_REFERENCES);</code></td>\n * <td><i>(Default)</i> Uses XPath relative references to signify duplicate references. This produces XML\n * with the least clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate\n * references. This produces XML with the least clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_RELATIVE_REFERENCES);</code></td>\n * <td>Uses XPath relative references to signify duplicate references. The XPath expression ensures that\n * a single node only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate references.  The XPath expression ensures that\n * a single node only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.ID_REFERENCES);</code></td>\n * <td>Uses ID references to signify duplicate references. In some scenarios, such as when using\n * hand-written XML, this is easier to work with.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.NO_REFERENCES);</code></td>\n * <td>This disables object graph support and treats the object structure like a tree. Duplicate\n * references are treated as two separate objects and circular references cause an exception. This\n * is slightly faster and uses less memory than the other two modes.</td>\n * </tr>\n * </table>\n * <h3>Thread safety</h3>\n * <p>\n * The XStream instance is thread-safe. That is, once the XStream instance has been created and\n * configured, it may be shared across multiple threads allowing objects to be\n * serialized/deserialized concurrently. <em>Note, that this only applies if annotations are not \n * auto-detected on-the-fly.</em>\n * </p>\n * <h3>Implicit collections</h3>\n * \n * <p>\n * To avoid the need for special tags for collections, you can define implicit collections using one\n * of the <code>addImplicitCollection</code> methods.\n * </p>\n *\n * @author Joe Walnes\n * @author J&ouml;rg Schaible\n * @author Mauro Talevi\n * @author Guilherme Silveira\n */\npublic class XStream {\n\n    // CAUTION: The sequence of the fields is intentional for an optimal XML output of a\n    // self-serialization!\n    private ReflectionProvider reflectionProvider;\n    private HierarchicalStreamDriver hierarchicalStreamDriver;\n    private ClassLoaderReference classLoaderReference;\n    private MarshallingStrategy marshallingStrategy;\n    private ConverterLookup converterLookup;\n    private ConverterRegistry converterRegistry;\n    private Mapper mapper;\n\n    private PackageAliasingMapper packageAliasingMapper;\n    private ClassAliasingMapper classAliasingMapper;\n    private FieldAliasingMapper fieldAliasingMapper;\n    private ElementIgnoringMapper elementIgnoringMapper;\n    private AttributeAliasingMapper attributeAliasingMapper;\n    private SystemAttributeAliasingMapper systemAttributeAliasingMapper;\n    private AttributeMapper attributeMapper;\n    private DefaultImplementationsMapper defaultImplementationsMapper;\n    private ImmutableTypesMapper immutableTypesMapper;\n    private ImplicitCollectionMapper implicitCollectionMapper;\n    private LocalConversionMapper localConversionMapper;\n    private SecurityMapper securityMapper;\n    private AnnotationConfiguration annotationConfiguration;\n\n    private transient boolean securityInitialized;\n    private transient boolean securityWarningGiven;\n\n    public static final int NO_REFERENCES = 1001;\n    public static final int ID_REFERENCES = 1002;\n    public static final int XPATH_RELATIVE_REFERENCES = 1003;\n    public static final int XPATH_ABSOLUTE_REFERENCES = 1004;\n    public static final int SINGLE_NODE_XPATH_RELATIVE_REFERENCES = 1005;\n    public static final int SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES = 1006;\n\n    public static final int PRIORITY_VERY_HIGH = 10000;\n    public static final int PRIORITY_NORMAL = 0;\n    public static final int PRIORITY_LOW = -10;\n    public static final int PRIORITY_VERY_LOW = -20;\n\n    private static final String ANNOTATION_MAPPER_TYPE = \"com.thoughtworks.xstream.mapper.AnnotationMapper\";\n    private static final Pattern IGNORE_ALL = Pattern.compile(\".*\");\n\n    /**\n     * Constructs a default XStream.\n     * <p>\n     * The instance will use the {@link XppDriver} as default and tries to determine the best\n     * match for the {@link ReflectionProvider} on its own.\n     * </p>\n     *\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream() {\n        this(null, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link ReflectionProvider}.\n     * <p>\n     * The instance will use the {@link XppDriver} as default.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching reflection provider\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(ReflectionProvider reflectionProvider) {\n        this(reflectionProvider, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}.\n     * <p>\n     * The instance will tries to determine the best match for the {@link ReflectionProvider} on\n     * its own.\n     * </p>\n     *\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(null, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver} and\n     * {@link ReflectionProvider}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(reflectionProvider, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and a prepared {@link Mapper} chain.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param driver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     * @deprecated As of 1.3, use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoader, Mapper)}\n     *             instead\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {\n        this(reflectionProvider, driver, new CompositeClassLoader(), mapper);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and a {@link ClassLoaderReference}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference) {\n        this(reflectionProvider, driver, classLoaderReference, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and the {@link ClassLoader} to use.\n     * \n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader) {\n        this(reflectionProvider, driver, classLoader, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain and the {@link ClassLoader}\n     * to use.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader, Mapper mapper) {\n        this(\n            reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, new DefaultConverterLookup());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain and the\n     * {@link ClassLoaderReference}.\n     * <p>\n     * The {@link ClassLoaderReference} should also be used for the {@link Mapper} chain.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference, Mapper mapper) {\n        this(\n            reflectionProvider, driver, classLoaderReference, mapper, new DefaultConverterLookup());\n    }\n    \n    private XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoaderReference classLoader,\n            Mapper mapper, final DefaultConverterLookup defaultConverterLookup) {\n        this(reflectionProvider, driver, classLoader, mapper, new ConverterLookup() {\n            public Converter lookupConverterForType(Class type) {\n                return defaultConverterLookup.lookupConverterForType(type);\n            }\n        }, new ConverterRegistry() {\n            public void registerConverter(Converter converter, int priority) {\n                defaultConverterLookup.registerConverter(converter, priority);\n            }\n        });\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain, the\n     * {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper, ConverterLookup, ConverterRegistry)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader, Mapper mapper, ConverterLookup converterLookup,\n        ConverterRegistry converterRegistry) {\n        this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, converterLookup, converterRegistry);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain, the\n     * {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * <p>\n     * The ClassLoaderReference should also be used for the Mapper chain. The ConverterLookup\n     * should access the ConverterRegistry if you intent to register {@link Converter} instances\n     * with XStream facade or you are using annotations.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances or <em>null</em>\n     *            to prevent any further registry (including annotations)\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference, Mapper mapper, ConverterLookup converterLookup,\n        ConverterRegistry converterRegistry) {\n        if (reflectionProvider == null) {\n            reflectionProvider = JVM.newReflectionProvider();\n        }\n        this.reflectionProvider = reflectionProvider;\n        this.hierarchicalStreamDriver = driver;\n        this.classLoaderReference = classLoaderReference;\n        this.converterLookup = converterLookup;\n        this.converterRegistry = converterRegistry;\n        this.mapper = mapper == null ? buildMapper() : mapper;\n\n        setupMappers();\n        setupSecurity();\n        setupAliases();\n        setupDefaultImplementations();\n        setupConverters();\n        setupImmutableTypes();\n        setMode(XPATH_RELATIVE_REFERENCES);\n    }\n\n    private Mapper buildMapper() {\n        Mapper mapper = new DefaultMapper(classLoaderReference);\n        if (useXStream11XmlFriendlyMapper()) {\n            mapper = new XStream11XmlFriendlyMapper(mapper);\n        }\n        mapper = new DynamicProxyMapper(mapper);\n        mapper = new PackageAliasingMapper(mapper);\n        mapper = new ClassAliasingMapper(mapper);\n        mapper = new ElementIgnoringMapper(mapper);\n        mapper = new FieldAliasingMapper(mapper);\n        mapper = new AttributeAliasingMapper(mapper);\n        mapper = new SystemAttributeAliasingMapper(mapper);\n        mapper = new ImplicitCollectionMapper(mapper, reflectionProvider);\n        mapper = new OuterClassMapper(mapper);\n        mapper = new ArrayMapper(mapper);\n        mapper = new DefaultImplementationsMapper(mapper);\n        mapper = new AttributeMapper(mapper, converterLookup, reflectionProvider);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(\n                \"com.thoughtworks.xstream.mapper.EnumMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new LocalConversionMapper(mapper);\n        mapper = new ImmutableTypesMapper(mapper);\n        if (JVM.isVersion(8)) {\n            mapper = buildMapperDynamically(\"com.thoughtworks.xstream.mapper.LambdaMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new SecurityMapper(mapper);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(ANNOTATION_MAPPER_TYPE, new Class[]{\n                Mapper.class, ConverterRegistry.class, ConverterLookup.class,\n                ClassLoaderReference.class, ReflectionProvider.class}, new Object[]{\n                mapper, converterRegistry, converterLookup, classLoaderReference,\n                reflectionProvider});\n        }\n        mapper = wrapMapper((MapperWrapper)mapper);\n        mapper = new CachingMapper(mapper);\n        return mapper;\n    }\n\n    private Mapper buildMapperDynamically(String className, Class[] constructorParamTypes,\n        Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            return (Mapper)constructor.newInstance(constructorParamValues);\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        }\n    }\n\n    protected MapperWrapper wrapMapper(MapperWrapper next) {\n        return next;\n    }\n\n    /**\n     * @deprecated As of 1.4.8\n     */\n    protected boolean useXStream11XmlFriendlyMapper() {\n        return false;\n    }\n\n    private void setupMappers() {\n        packageAliasingMapper = (PackageAliasingMapper)this.mapper\n            .lookupMapperOfType(PackageAliasingMapper.class);\n        classAliasingMapper = (ClassAliasingMapper)this.mapper\n            .lookupMapperOfType(ClassAliasingMapper.class);\n        elementIgnoringMapper = (ElementIgnoringMapper)this.mapper\n            .lookupMapperOfType(ElementIgnoringMapper.class);\n        fieldAliasingMapper = (FieldAliasingMapper)this.mapper\n            .lookupMapperOfType(FieldAliasingMapper.class);\n        attributeMapper = (AttributeMapper)this.mapper\n            .lookupMapperOfType(AttributeMapper.class);\n        attributeAliasingMapper = (AttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(AttributeAliasingMapper.class);\n        systemAttributeAliasingMapper = (SystemAttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(SystemAttributeAliasingMapper.class);\n        implicitCollectionMapper = (ImplicitCollectionMapper)this.mapper\n            .lookupMapperOfType(ImplicitCollectionMapper.class);\n        defaultImplementationsMapper = (DefaultImplementationsMapper)this.mapper\n            .lookupMapperOfType(DefaultImplementationsMapper.class);\n        immutableTypesMapper = (ImmutableTypesMapper)this.mapper\n            .lookupMapperOfType(ImmutableTypesMapper.class);\n        localConversionMapper = (LocalConversionMapper)this.mapper\n            .lookupMapperOfType(LocalConversionMapper.class);\n        securityMapper = (SecurityMapper)this.mapper\n            .lookupMapperOfType(SecurityMapper.class);\n        annotationConfiguration = (AnnotationConfiguration)this.mapper\n            .lookupMapperOfType(AnnotationConfiguration.class);\n    }\n    \n    protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n        \n        addPermission(AnyTypePermission.ANY);\n        securityInitialized = false;\n    }\n\n    /**\n     * Setup the security framework of a XStream instance.\n     * <p>\n     * This method is a pure helper method for XStream 1.4.x. It initializes an XStream instance with a white list of\n     * well-known and simply types of the Java runtime as it is done in XStream 1.5.x by default. This method will do\n     * therefore nothing in XStream 1.5.\n     * </p>\n     * \n     * @param xstream\n     * @since 1.4.10\n     */\n    public static void setupDefaultSecurity(final XStream xstream) {\n        if (!xstream.securityInitialized) {\n            xstream.addPermission(NoTypePermission.NONE);\n            xstream.addPermission(NullPermission.NULL);\n            xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);\n            xstream.addPermission(ArrayTypePermission.ARRAYS);\n            xstream.addPermission(InterfaceTypePermission.INTERFACES);\n            xstream.allowTypeHierarchy(Calendar.class);\n            xstream.allowTypeHierarchy(Collection.class);\n            xstream.allowTypeHierarchy(Map.class);\n            xstream.allowTypeHierarchy(Map.Entry.class);\n            xstream.allowTypeHierarchy(Member.class);\n            xstream.allowTypeHierarchy(Number.class);\n            xstream.allowTypeHierarchy(Throwable.class);\n            xstream.allowTypeHierarchy(TimeZone.class);\n\n            Class type = JVM.loadClassForName(\"java.lang.Enum\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n            type = JVM.loadClassForName(\"java.nio.file.Path\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n\n            final Set types = new HashSet();\n            types.add(BitSet.class);\n            types.add(Charset.class);\n            types.add(Class.class);\n            types.add(Currency.class);\n            types.add(Date.class);\n            types.add(DecimalFormatSymbols.class);\n            types.add(File.class);\n            types.add(Locale.class);\n            types.add(Object.class);\n            types.add(Pattern.class);\n            types.add(StackTraceElement.class);\n            types.add(String.class);\n            types.add(StringBuffer.class);\n            types.add(JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            types.add(URL.class);\n            types.add(URI.class);\n            types.add(JVM.loadClassForName(\"java.util.UUID\"));\n            if (JVM.isSQLAvailable()) {\n                types.add(JVM.loadClassForName(\"java.sql.Timestamp\"));\n                types.add(JVM.loadClassForName(\"java.sql.Time\"));\n                types.add(JVM.loadClassForName(\"java.sql.Date\"));\n            }\n            if (JVM.isVersion(8)) {\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.Clock\"));\n                types.add(JVM.loadClassForName(\"java.time.Duration\"));\n                types.add(JVM.loadClassForName(\"java.time.Instant\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDate\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalTime\"));\n                types.add(JVM.loadClassForName(\"java.time.MonthDay\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetTime\"));\n                types.add(JVM.loadClassForName(\"java.time.Period\"));\n                types.add(JVM.loadClassForName(\"java.time.Ser\"));\n                types.add(JVM.loadClassForName(\"java.time.Year\"));\n                types.add(JVM.loadClassForName(\"java.time.YearMonth\"));\n                types.add(JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.ZoneId\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.Ser\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n            }\n            types.remove(null);\n\n            final Iterator iter = types.iterator();\n            final Class[] classes = new Class[types.size()];\n            for (int i = 0; i < classes.length; ++i) {\n                classes[i] = (Class)iter.next();\n            }\n            xstream.allowTypes(classes);\n        } else {\n            throw new IllegalArgumentException(\"Security framework of XStream instance already initialized\");\n        }\n    }\n\n    protected void setupAliases() {\n        if (classAliasingMapper == null) {\n            return;\n        }\n\n        alias(\"null\", Mapper.Null.class);\n        alias(\"int\", Integer.class);\n        alias(\"float\", Float.class);\n        alias(\"double\", Double.class);\n        alias(\"long\", Long.class);\n        alias(\"short\", Short.class);\n        alias(\"char\", Character.class);\n        alias(\"byte\", Byte.class);\n        alias(\"boolean\", Boolean.class);\n        alias(\"number\", Number.class);\n        alias(\"object\", Object.class);\n        alias(\"big-int\", BigInteger.class);\n        alias(\"big-decimal\", BigDecimal.class);\n\n        alias(\"string-buffer\", StringBuffer.class);\n        alias(\"string\", String.class);\n        alias(\"java-class\", Class.class);\n        alias(\"method\", Method.class);\n        alias(\"constructor\", Constructor.class);\n        alias(\"field\", Field.class);\n        alias(\"date\", Date.class);\n        alias(\"uri\", URI.class);\n        alias(\"url\", URL.class);\n        alias(\"bit-set\", BitSet.class);\n\n        alias(\"map\", Map.class);\n        alias(\"entry\", Map.Entry.class);\n        alias(\"properties\", Properties.class);\n        alias(\"list\", List.class);\n        alias(\"set\", Set.class);\n        alias(\"sorted-set\", SortedSet.class);\n\n        alias(\"linked-list\", LinkedList.class);\n        alias(\"vector\", Vector.class);\n        alias(\"tree-map\", TreeMap.class);\n        alias(\"tree-set\", TreeSet.class);\n        alias(\"hashtable\", Hashtable.class);\n        \n        alias(\"empty-list\", Collections.EMPTY_LIST.getClass());\n        alias(\"empty-map\", Collections.EMPTY_MAP.getClass());\n        alias(\"empty-set\", Collections.EMPTY_SET.getClass());\n        alias(\"singleton-list\", Collections.singletonList(this).getClass());\n        alias(\"singleton-map\", Collections.singletonMap(this, null).getClass());\n        alias(\"singleton-set\", Collections.singleton(this).getClass());\n\n        if (JVM.isAWTAvailable()) {\n            // Instantiating these two classes starts the AWT system, which is undesirable.\n            // Calling loadClass ensures a reference to the class is found but they are not\n            // instantiated.\n            alias(\"awt-color\", JVM.loadClassForName(\"java.awt.Color\", false));\n            alias(\"awt-font\", JVM.loadClassForName(\"java.awt.Font\", false));\n            alias(\"awt-text-attribute\", JVM.loadClassForName(\"java.awt.font.TextAttribute\"));\n        }\n\n        Class type = JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\");\n        if (type != null) {\n            alias(\"activation-data-flavor\", type);\n        }\n\n        if (JVM.isSQLAvailable()) {\n            alias(\"sql-timestamp\", JVM.loadClassForName(\"java.sql.Timestamp\"));\n            alias(\"sql-time\", JVM.loadClassForName(\"java.sql.Time\"));\n            alias(\"sql-date\", JVM.loadClassForName(\"java.sql.Date\"));\n        }\n\n        alias(\"file\", File.class);\n        alias(\"locale\", Locale.class);\n        alias(\"gregorian-calendar\", Calendar.class);\n\n        if (JVM.isVersion(4)) {\n            aliasDynamically(\"auth-subject\", \"javax.security.auth.Subject\");\n            alias(\"linked-hash-map\", JVM.loadClassForName(\"java.util.LinkedHashMap\"));\n            alias(\"linked-hash-set\", JVM.loadClassForName(\"java.util.LinkedHashSet\"));\n            alias(\"trace\", JVM.loadClassForName(\"java.lang.StackTraceElement\"));\n            alias(\"currency\", JVM.loadClassForName(\"java.util.Currency\"));\n            aliasType(\"charset\", JVM.loadClassForName(\"java.nio.charset.Charset\"));\n        }\n\n        if (JVM.isVersion(5)) {\n            aliasDynamically(\"xml-duration\", \"javax.xml.datatype.Duration\");\n            alias(\"concurrent-hash-map\", JVM.loadClassForName(\"java.util.concurrent.ConcurrentHashMap\"));\n            alias(\"enum-set\", JVM.loadClassForName(\"java.util.EnumSet\"));\n            alias(\"enum-map\", JVM.loadClassForName(\"java.util.EnumMap\"));\n            alias(\"string-builder\", JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            alias(\"uuid\", JVM.loadClassForName(\"java.util.UUID\"));\n        }\n        \n        if (JVM.isVersion(7)) {\n            aliasType(\"path\", JVM.loadClassForName(\"java.nio.file.Path\"));\n        }\n\n        if (JVM.isVersion(8)) {\n            alias(\"fixed-clock\", JVM.loadClassForName(\"java.time.Clock$FixedClock\"));\n            alias(\"offset-clock\", JVM.loadClassForName(\"java.time.Clock$OffsetClock\"));\n            alias(\"system-clock\", JVM.loadClassForName(\"java.time.Clock$SystemClock\"));\n            alias(\"tick-clock\", JVM.loadClassForName(\"java.time.Clock$TickClock\"));\n            alias(\"day-of-week\", JVM.loadClassForName(\"java.time.DayOfWeek\"));\n            alias(\"duration\", JVM.loadClassForName(\"java.time.Duration\"));\n            alias(\"instant\", JVM.loadClassForName(\"java.time.Instant\"));\n            alias(\"local-date\", JVM.loadClassForName(\"java.time.LocalDate\"));\n            alias(\"local-date-time\", JVM.loadClassForName(\"java.time.LocalDateTime\"));\n            alias(\"local-time\", JVM.loadClassForName(\"java.time.LocalTime\"));\n            alias(\"month\", JVM.loadClassForName(\"java.time.Month\"));\n            alias(\"month-day\", JVM.loadClassForName(\"java.time.MonthDay\"));\n            alias(\"offset-date-time\", JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n            alias(\"offset-time\", JVM.loadClassForName(\"java.time.OffsetTime\"));\n            alias(\"period\", JVM.loadClassForName(\"java.time.Period\"));\n            alias(\"year\", JVM.loadClassForName(\"java.time.Year\"));\n            alias(\"year-month\", JVM.loadClassForName(\"java.time.YearMonth\"));\n            alias(\"zoned-date-time\", JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n            aliasType(\"zone-id\", JVM.loadClassForName(\"java.time.ZoneId\"));\n            aliasType(\"chronology\", JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n            alias(\"hijrah-date\", JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n            alias(\"hijrah-era\", JVM.loadClassForName(\"java.time.chrono.HijrahEra\"));\n            alias(\"japanese-date\", JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n            alias(\"japanese-era\", JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n            alias(\"minguo-date\", JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n            alias(\"minguo-era\", JVM.loadClassForName(\"java.time.chrono.MinguoEra\"));\n            alias(\"thai-buddhist-date\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n            alias(\"thai-buddhist-era\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistEra\"));\n            alias(\"chrono-field\", JVM.loadClassForName(\"java.time.temporal.ChronoField\"));\n            alias(\"chrono-unit\", JVM.loadClassForName(\"java.time.temporal.ChronoUnit\"));\n            alias(\"iso-field\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Field\"));\n            alias(\"iso-unit\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Unit\"));\n            alias(\"julian-field\", JVM.loadClassForName(\"java.time.temporal.JulianFields$Field\"));\n            alias(\"temporal-value-range\", JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n            alias(\"week-fields\", JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n        }\n\n        if (JVM.loadClassForName(\"java.lang.invoke.SerializedLambda\") != null) {\n            aliasDynamically(\"serialized-lambda\", \"java.lang.invoke.SerializedLambda\");\n        }\n    }\n\n    private void aliasDynamically(String alias, String className) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            alias(alias, type);\n        }\n    }\n\n    protected void setupDefaultImplementations() {\n        if (defaultImplementationsMapper == null) {\n            return;\n        }\n        addDefaultImplementation(HashMap.class, Map.class);\n        addDefaultImplementation(ArrayList.class, List.class);\n        addDefaultImplementation(HashSet.class, Set.class);\n        addDefaultImplementation(TreeSet.class, SortedSet.class);\n        addDefaultImplementation(GregorianCalendar.class, Calendar.class);\n    }\n\n    protected void setupConverters() {\n        registerConverter(\n            new ReflectionConverter(mapper, reflectionProvider), PRIORITY_VERY_LOW);\n\n        registerConverter(\n            new SerializableConverter(mapper, reflectionProvider, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new ExternalizableConverter(mapper, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new InternalBlackList(), PRIORITY_LOW);\n\n        registerConverter(new NullConverter(), PRIORITY_VERY_HIGH);\n        registerConverter(new IntConverter(), PRIORITY_NORMAL);\n        registerConverter(new FloatConverter(), PRIORITY_NORMAL);\n        registerConverter(new DoubleConverter(), PRIORITY_NORMAL);\n        registerConverter(new LongConverter(), PRIORITY_NORMAL);\n        registerConverter(new ShortConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new CharConverter(), PRIORITY_NORMAL);\n        registerConverter(new BooleanConverter(), PRIORITY_NORMAL);\n        registerConverter(new ByteConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new StringConverter(), PRIORITY_NORMAL);\n        registerConverter(new StringBufferConverter(), PRIORITY_NORMAL);\n        registerConverter(new DateConverter(), PRIORITY_NORMAL);\n        registerConverter(new BitSetConverter(), PRIORITY_NORMAL);\n        registerConverter(new URIConverter(), PRIORITY_NORMAL);\n        registerConverter(new URLConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigIntegerConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigDecimalConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new ArrayConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new CharArrayConverter(), PRIORITY_NORMAL);\n        registerConverter(new CollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new MapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeSetConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonCollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new PropertiesConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new EncodedByteArrayConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new FileConverter(), PRIORITY_NORMAL);\n        if (JVM.isSQLAvailable()) {\n            registerConverter(new SqlTimestampConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlTimeConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlDateConverter(), PRIORITY_NORMAL);\n        }\n        registerConverter(new DynamicProxyConverter(mapper, classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaClassConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaMethodConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaFieldConverter(classLoaderReference), PRIORITY_NORMAL);\n\n        if (JVM.isAWTAvailable()) {\n            registerConverter(new FontConverter(mapper), PRIORITY_NORMAL);\n            registerConverter(new ColorConverter(), PRIORITY_NORMAL);\n            registerConverter(new TextAttributeConverter(), PRIORITY_NORMAL);\n        }\n        if (JVM.isSwingAvailable()) {\n            registerConverter(\n                new LookAndFeelConverter(mapper, reflectionProvider), PRIORITY_NORMAL);\n        }\n        registerConverter(new LocaleConverter(), PRIORITY_NORMAL);\n        registerConverter(new GregorianCalendarConverter(), PRIORITY_NORMAL);\n\n        if (JVM.isVersion(4)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.SubjectConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.ThrowableConverter\",\n                PRIORITY_NORMAL, new Class[]{ConverterLookup.class},\n                new Object[]{converterLookup});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.StackTraceElementConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.CurrencyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.RegexPatternConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.CharsetConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n\n        if (JVM.isVersion(5)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            if (JVM.loadClassForName(\"javax.xml.datatype.Duration\") != null) {\n                registerConverterDynamically(\n                    \"com.thoughtworks.xstream.converters.extended.DurationConverter\",\n                    PRIORITY_NORMAL, null, null);\n            }\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumSetConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumMapConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.basic.StringBuilderConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.basic.UUIDConverter\", PRIORITY_NORMAL,\n                null, null);\n        }\n        if (JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\") != null) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ActivationDataFlavorConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(7)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.PathConverter\",\n                    PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(8)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ChronologyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.DurationConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.HijrahDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseEraConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.InstantConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalTimeConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MinguoDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MonthDayConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.PeriodConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.SystemClockConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ThaiBuddhistDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ValueRangeConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.WeekFieldsConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearMonthConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZonedDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZoneIdConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.reflection.LambdaConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class, ReflectionProvider.class, ClassLoaderReference.class},\n                new Object[]{mapper, reflectionProvider, classLoaderReference});\n        }\n\n        registerConverter(\n            new SelfStreamingInstanceChecker(converterLookup, this), PRIORITY_NORMAL);\n    }\n\n    private void registerConverterDynamically(String className, int priority,\n        Class[] constructorParamTypes, Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            Object instance = constructor.newInstance(constructorParamValues);\n            if (instance instanceof Converter) {\n                registerConverter((Converter)instance, priority);\n            } else if (instance instanceof SingleValueConverter) {\n                registerConverter((SingleValueConverter)instance, priority);\n            }\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate converter : \" + className, e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate converter : \" + className, e);\n        }\n    }\n\n    protected void setupImmutableTypes() {\n        if (immutableTypesMapper == null) {\n            return;\n        }\n\n        // primitives are always immutable\n        addImmutableType(boolean.class, false);\n        addImmutableType(Boolean.class, false);\n        addImmutableType(byte.class, false);\n        addImmutableType(Byte.class, false);\n        addImmutableType(char.class, false);\n        addImmutableType(Character.class, false);\n        addImmutableType(double.class, false);\n        addImmutableType(Double.class, false);\n        addImmutableType(float.class, false);\n        addImmutableType(Float.class, false);\n        addImmutableType(int.class, false);\n        addImmutableType(Integer.class, false);\n        addImmutableType(long.class, false);\n        addImmutableType(Long.class, false);\n        addImmutableType(short.class, false);\n        addImmutableType(Short.class, false);\n\n        // additional types\n        addImmutableType(Mapper.Null.class, false);\n        addImmutableType(BigDecimal.class, false);\n        addImmutableType(BigInteger.class, false);\n        addImmutableType(String.class, false);\n        addImmutableType(URL.class, false);\n        addImmutableType(File.class, false);\n        addImmutableType(Class.class, false);\n\n        if (JVM.isVersion(7)) {\n            Class type = JVM.loadClassForName(\"java.nio.file.Paths\");\n            if (type != null) {\n                Method methodGet;\n                try {\n                    methodGet = type.getDeclaredMethod(\"get\", new Class[] {String.class, String[].class});\n                    if (methodGet != null) {\n                        Object path = methodGet.invoke(null, new Object[]{\".\", new String[0]});\n                        if (path != null) {\n                            addImmutableType(path.getClass(), false);\n                        }\n                    }\n                } catch (NoSuchMethodException e) {\n                } catch (SecurityException e) {\n                } catch (IllegalAccessException e) {\n                } catch (InvocationTargetException e) {\n                }\n            }\n        }\n\n        if (JVM.isAWTAvailable()) {\n            addImmutableTypeDynamically(\"java.awt.font.TextAttribute\", false);\n        }\n\n        if (JVM.isVersion(4)) {\n            // late bound types - allows XStream to be compiled on earlier JDKs\n            addImmutableTypeDynamically(\"java.nio.charset.Charset\", true);\n            addImmutableTypeDynamically(\"java.util.Currency\", true);\n        }\n        \n        if (JVM.isVersion(5)) {\n            addImmutableTypeDynamically(\"java.util.UUID\", true);\n        }\n\n        addImmutableType(URI.class, true);\n        addImmutableType(Collections.EMPTY_LIST.getClass(), true);\n        addImmutableType(Collections.EMPTY_SET.getClass(), true);\n        addImmutableType(Collections.EMPTY_MAP.getClass(), true);\n\n        if (JVM.isVersion(8)) {\n            addImmutableTypeDynamically(\"java.time.Duration\", false);\n            addImmutableTypeDynamically(\"java.time.Instant\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDate\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.LocalTime\", false);\n            addImmutableTypeDynamically(\"java.time.MonthDay\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetTime\", false);\n            addImmutableTypeDynamically(\"java.time.Period\", false);\n            addImmutableTypeDynamically(\"java.time.Year\", false);\n            addImmutableTypeDynamically(\"java.time.YearMonth\", false);\n            addImmutableTypeDynamically(\"java.time.ZonedDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneId\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneOffset\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneRegion\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.IsoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseEra\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistDate\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Field\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Unit\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.JulianFields$Field\", false);\n        }\n    }\n\n    private void addImmutableTypeDynamically(String className, boolean isReferenceable) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            addImmutableType(type, isReferenceable);\n        }\n    }\n\n    public void setMarshallingStrategy(MarshallingStrategy marshallingStrategy) {\n        this.marshallingStrategy = marshallingStrategy;\n    }\n\n    /**\n     * Serialize an object to a pretty-printed XML String.\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public String toXML(Object obj) {\n        Writer writer = new StringWriter();\n        toXML(obj, writer);\n        return writer.toString();\n    }\n\n    /**\n     * Serialize an object to the given Writer as pretty-printed XML. The Writer will be flushed\n     * afterwards and in case of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, Writer out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize an object to the given OutputStream as pretty-printed XML. The OutputStream\n     * will be flushed afterwards and in case of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, OutputStream out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer) {\n        marshal(obj, writer, null);\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     * \n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you\n     *            want. If not present, XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer, DataHolder dataHolder) {\n        marshallingStrategy.marshal(writer, obj, converterLookup, mapper, dataHolder);\n    }\n\n    /**\n     * Deserialize an object from an XML String.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml) {\n        return fromXML(new StringReader(xml));\n    }\n\n    /**\n     * Deserialize an object from an XML Reader.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader reader) {\n        return unmarshal(hierarchicalStreamDriver.createReader(reader), null);\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), null);\n    }\n\n    /**\n     * Deserialize an object from a URL.\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url) {\n        return fromXML(url, null);\n    }\n\n    /**\n     * Deserialize an object from a file.\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file) {\n        return fromXML(file, null);\n    }\n\n    /**\n     * Deserialize an object from an XML String, populating the fields of the given root object\n     * instead of instantiating a new one. Note, that this is a special use case! With the\n     * ReflectionConverter XStream will write directly into the raw memory area of the existing\n     * object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml, Object root) {\n        return fromXML(new StringReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from an XML Reader, populating the fields of the given root object\n     * instead of instantiating a new one. Note, that this is a special use case! With the\n     * ReflectionConverter XStream will write directly into the raw memory area of the existing\n     * object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader xml, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from a URL, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(url), root);\n    }\n\n    /**\n     * Deserialize an object from a file, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file, Object root) {\n        HierarchicalStreamReader reader = hierarchicalStreamDriver.createReader(file);\n        try {\n            return unmarshal(reader, root);\n        } finally {\n            reader.close();\n        }\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), root);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader) {\n        return unmarshal(reader, null, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML), populating the\n     * fields of the given root object instead of instantiating a new one. Note, that this is a\n     * special use case! With the ReflectionConverter XStream will write directly into the raw\n     * memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root) {\n        return unmarshal(reader, root, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     * \n     * @param root If present, the passed in object will have its fields populated, as opposed\n     *            to XStream creating a new instance. Note, that this is a special use case!\n     *            With the ReflectionConverter XStream will write directly into the raw memory\n     *            area of the existing object. Use with care!\n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you\n     *            want. If not present, XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root, DataHolder dataHolder) {\n        try {\n            if (!securityInitialized && !securityWarningGiven) {\n                securityWarningGiven = true;\n                System.err.println(\"Security framework of XStream not initialized, XStream is probably vulnerable.\");\n            }\n            return marshallingStrategy.unmarshal(\n                root, reader, dataHolder, converterLookup, mapper);\n\n        } catch (ConversionException e) {\n            Package pkg = getClass().getPackage();\n            String version = pkg != null ? pkg.getImplementationVersion() : null;\n            e.add(\"version\", version != null ? version : \"not available\");\n            throw e;\n        }\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void alias(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addClassAlias(name, type);\n    }\n\n    /**\n     * Alias a type to a shorter name to be used in XML elements. Any class that is assignable\n     * to this type will be aliased to the same name.\n     * \n     * @param name Short name\n     * @param type Type to be aliased\n     * @since 1.2\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void aliasType(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addTypeAlias(name, type);\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @param defaultImplementation Default implementation of type to use if no other specified.\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no\n     *             {@link ClassAliasingMapper} is available\n     */\n    public void alias(String name, Class type, Class defaultImplementation) {\n        alias(name, type);\n        addDefaultImplementation(defaultImplementation, type);\n    }\n\n    /**\n     * Alias a package to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param pkgName package to be aliased\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no\n     *             {@link PackageAliasingMapper} is available\n     * @since 1.3.1\n     */\n    public void aliasPackage(String name, String pkgName) {\n        if (packageAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + PackageAliasingMapper.class.getName()\n                + \" available\");\n        }\n        packageAliasingMapper.addPackageAlias(name, pkgName);\n    }\n\n    /**\n     * Create an alias for a field name.\n     *\n     * @param alias the alias itself\n     * @param definedIn the type that declares the field\n     * @param fieldName the name of the field\n     * @throws InitializationException if no {@link FieldAliasingMapper} is available\n     */\n    public void aliasField(String alias, Class definedIn, String fieldName) {\n        if (fieldAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + FieldAliasingMapper.class.getName()\n                + \" available\");\n        }\n        fieldAliasingMapper.addFieldAlias(alias, definedIn, fieldName);\n    }\n\n    /**\n     * Create an alias for an attribute\n     *\n     * @param alias the alias itself\n     * @param attributeName the name of the attribute\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     */\n    public void aliasAttribute(String alias, String attributeName) {\n        if (attributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        attributeAliasingMapper.addAliasFor(attributeName, alias);\n    }\n\n    /**\n     * Create an alias for a system attribute. XStream will not write a system attribute if its\n     * alias is set to <code>null</code>. However, this is not reversible, i.e. deserialization\n     * of the result is likely to fail afterwards and will not produce an object equal to the\n     * originally written one.\n     * \n     * @param alias the alias itself (may be <code>null</code>)\n     * @param systemAttributeName the name of the system attribute\n     * @throws InitializationException if no {@link SystemAttributeAliasingMapper} is available\n     * @since 1.3.1\n     */\n    public void aliasSystemAttribute(String alias, String systemAttributeName) {\n        if (systemAttributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + SystemAttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        systemAttributeAliasingMapper.addAliasFor(systemAttributeName, alias);\n    }\n\n    /**\n     * Create an alias for an attribute.\n     *\n     * @param definedIn the type where the attribute is defined\n     * @param attributeName the name of the attribute\n     * @param alias the alias itself\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     * @since 1.2.2\n     */\n    public void aliasAttribute(Class definedIn, String attributeName, String alias) {\n        aliasField(alias, definedIn, attributeName);\n        useAttributeFor(definedIn, attributeName);\n    }\n\n    /**\n     * Use an attribute for a field or a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(String fieldName, Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(fieldName, type);\n    }\n\n    /**\n     * Use an attribute for a field declared in a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param definedIn the Class containing such field\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2.2\n     */\n    public void useAttributeFor(Class definedIn, String fieldName) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(definedIn, fieldName);\n    }\n\n    /**\n     * Use an attribute for an arbitrary type.\n     *\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(type);\n    }\n\n    /**\n     * Associate a default implementation of a class with an object. Whenever XStream encounters\n     * an instance of this type, it will use the default implementation instead. For example,\n     * java.util.ArrayList is the default implementation of java.util.List.\n     * \n     * @param defaultImplementation\n     * @param ofType\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} is available\n     */\n    public void addDefaultImplementation(Class defaultImplementation, Class ofType) {\n        if (defaultImplementationsMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + DefaultImplementationsMapper.class.getName()\n                + \" available\");\n        }\n        defaultImplementationsMapper.addDefaultImplementation(defaultImplementation, ofType);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times. However, references are still supported at deserialization time.\n     *\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @deprecated As of 1.4.9 use {@link #addImmutableType(Class, boolean)}\n     */\n    public void addImmutableType(Class type) {\n        addImmutableType(type, true);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times.\n     * <p>\n     * Note, while a reference-keeping marshaller will not write references for immutable types into the stream, a\n     * reference-keeping unmarshaller can still support such references in the stream for compatibility reasons at the\n     * expense of memory consumption. Therefore declare these types only as referenceable if your already persisted\n     * streams do contain such references. Otherwise you may waste a lot of memory during deserialization.\n     * </p>\n     *\n     * @param isReferenceable <code>true</code> if support at deserialization time is required for compatibility at the\n     *            cost of a higher memory footprint, <code>false</code> otherwise\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @since 1.4.9\n     */\n    public void addImmutableType(final Class type, final boolean isReferenceable) {\n        if (immutableTypesMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImmutableTypesMapper.class.getName()\n                + \" available\");\n        }\n        immutableTypesMapper.addImmutableType(type, isReferenceable);\n    }\n\n    public void registerConverter(Converter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(Converter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(converter, priority);\n        }\n    }\n\n    public void registerConverter(SingleValueConverter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(SingleValueConverter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(\n                new SingleValueConverterWrapper(converter), priority);\n        }\n    }\n\n    /**\n     * Register a local {@link Converter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName, Converter converter) {\n        if (localConversionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + LocalConversionMapper.class.getName()\n                + \" available\");\n        }\n        localConversionMapper.registerLocalConverter(definedIn, fieldName, converter);\n    }\n\n    /**\n     * Register a local {@link SingleValueConverter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName,\n        SingleValueConverter converter) {\n        registerLocalConverter(\n            definedIn, fieldName, (Converter)new SingleValueConverterWrapper(converter));\n    }\n\n    /**\n     * Retrieve the {@link Mapper}. This is by default a chain of {@link MapperWrapper\n     * MapperWrappers}.\n     * \n     * @return the mapper\n     * @since 1.2\n     */\n    public Mapper getMapper() {\n        return mapper;\n    }\n\n    /**\n     * Retrieve the {@link ReflectionProvider} in use.\n     *\n     * @return the mapper\n     * @since 1.2.1\n     */\n    public ReflectionProvider getReflectionProvider() {\n        return reflectionProvider;\n    }\n\n    public ConverterLookup getConverterLookup() {\n        return converterLookup;\n    }\n\n    /**\n     * Change mode for dealing with duplicate references. Valid values are\n     * <code>XPATH_ABSOLUTE_REFERENCES</code>, <code>XPATH_RELATIVE_REFERENCES</code>,\n     * <code>XStream.ID_REFERENCES</code> and <code>XStream.NO_REFERENCES</code>.\n     * \n     * @throws IllegalArgumentException if the mode is not one of the declared types\n     * @see #XPATH_ABSOLUTE_REFERENCES\n     * @see #XPATH_RELATIVE_REFERENCES\n     * @see #ID_REFERENCES\n     * @see #NO_REFERENCES\n     */\n    public void setMode(int mode) {\n        switch (mode) {\n        case NO_REFERENCES:\n            setMarshallingStrategy(new TreeMarshallingStrategy());\n            break;\n        case ID_REFERENCES:\n            setMarshallingStrategy(new ReferenceByIdMarshallingStrategy());\n            break;\n        case XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.RELATIVE));\n            break;\n        case XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.ABSOLUTE));\n            break;\n        case SINGLE_NODE_XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                  ReferenceByXPathMarshallingStrategy.RELATIVE \n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        case SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                  ReferenceByXPathMarshallingStrategy.ABSOLUTE \n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown mode : \" + mode);\n        }\n    }\n\n    /**\n     * Adds a default implicit collection which is used for any unmapped XML tag.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName, null, null);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given itemType.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     * @param itemType type of the items to be part of this collection\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, null, itemType);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given element name defined by\n     * itemFieldName.\n     * \n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     * @param itemFieldName element name of the implicit collection\n     * @param itemType item type to be aliases be the itemFieldName\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, String itemFieldName,\n        Class itemType) {\n        addImplicitMap(ownerType, fieldName, itemFieldName, itemType, null);\n    }\n\n    /**\n     * Adds an implicit array.\n     *\n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given itemType when the array\n     * type matches.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemType type of the items to be part of this array\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available or the\n     * array type does not match the itemType\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, itemType);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given element name defined by\n     * itemName.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemName alias name of the items\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName, String itemName) {\n        addImplicitCollection(ownerType, fieldName, itemName, null);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            map type or matching the default implementation type of the map\n     *            type.\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4 \n     */\n    public void addImplicitMap(Class ownerType, String fieldName, Class itemType, String keyFieldName) {\n        addImplicitMap(ownerType, fieldName, null, itemType, keyFieldName);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            map type or matching the default implementation type of the map\n     *            type.\n     * @param itemName alias name of the items\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4 \n     */\n    public void addImplicitMap(Class ownerType, String fieldName, String itemName, \n        Class itemType, String keyFieldName) {\n        if (implicitCollectionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImplicitCollectionMapper.class.getName()\n                + \" available\");\n        }\n        implicitCollectionMapper.add(ownerType, fieldName, itemName, itemType, keyFieldName);\n    }\n\n    /**\n     * Create a DataHolder that can be used to pass data to the converters. The DataHolder is provided with a call to\n     * {@link #marshal(Object, HierarchicalStreamWriter, DataHolder)},\n     * {@link #unmarshal(HierarchicalStreamReader, Object, DataHolder)},\n     * {@link #createObjectInputStream(HierarchicalStreamReader, DataHolder)} or\n     * {@link #createObjectOutputStream(HierarchicalStreamWriter, String, DataHolder)}.\n     *\n     * @return a new {@link DataHolder}\n     */\n    public DataHolder newDataHolder() {\n        return new MapBackedDataHolder();\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer) throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(writer), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(HierarchicalStreamWriter writer)\n        throws IOException {\n        return createObjectOutputStream(writer, \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer, String rootNodeName)\n        throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(writer), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream\n     * using XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out) throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(out), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream\n     * using XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out, String rootNodeName)\n        throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(out), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * Because an ObjectOutputStream can contain multiple items and XML only allows a single\n     * root node, the stream must be written inside an enclosing node.\n     * </p>\n     * <p>\n     * It is necessary to call ObjectOutputStream.close() when done, otherwise the stream will\n     * be incomplete.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     *  ObjectOutputStream out = xstream.createObjectOutputStream(aWriter, &quot;things&quot;);\n     *   out.writeInt(123);\n     *   out.writeObject(&quot;Hello&quot;);\n     *   out.writeObject(someObject)\n     *   out.close();\n     * </pre>\n     *\n     * @param writer The writer to serialize the objects to.\n     * @param rootNodeName The name of the root node enclosing the stream of objects.\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName)\n            throws IOException {\n        return createObjectOutputStream(writer, rootNodeName, null);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName,\n            final DataHolder dataHolder) throws IOException {\n        final StatefulWriter statefulWriter = new StatefulWriter(writer);\n        statefulWriter.startNode(rootNodeName, null);\n        return new CustomObjectOutputStream(new CustomObjectOutputStream.StreamCallback() {\n            public void writeToStream(final Object object) {\n                marshal(object, statefulWriter, dataHolder);\n            }\n\n            public void writeFieldsToStream(Map fields) throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void defaultWriteObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void flush() {\n                statefulWriter.flush();\n            }\n\n            public void close() {\n                if (statefulWriter.state() != StatefulWriter.STATE_CLOSED) {\n                    statefulWriter.endNode();\n                    statefulWriter.close();\n                }\n            }\n        });\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using\n     * XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(Reader xmlReader) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(xmlReader));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from an InputStream\n     * using XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.3\n     */\n    public ObjectInputStream createObjectInputStream(InputStream in) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(in));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     * <p>\n     * It is necessary to call ObjectInputStream.close() when done, otherwise the stream might keep system resources.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     * ObjectInputStream in = xstream.createObjectOutputStream(aReader);\n     * int a = out.readInt();\n     * Object b = out.readObject();\n     * Object c = out.readObject();\n     * </pre>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader) throws IOException {\n        return createObjectInputStream(reader, null);\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader, final DataHolder dataHolder)\n            throws IOException {\n        return new CustomObjectInputStream(new CustomObjectInputStream.StreamCallback() {\n            public Object readFromStream() throws EOFException {\n                if (!reader.hasMoreChildren()) {\n                    throw new EOFException();\n                }\n                reader.moveDown();\n                final Object result = unmarshal(reader, dataHolder);\n                reader.moveUp();\n                return result;\n            }\n\n            public Map readFieldsFromStream() throws IOException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void defaultReadObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void registerValidation(ObjectInputValidation validation, int priority)\n                throws NotActiveException {\n                throw new NotActiveException(\"stream inactive\");\n            }\n\n            public void close() {\n                reader.close();\n            }\n        }, classLoaderReference);\n    }\n\n    /**\n     * Change the ClassLoader XStream uses to load classes. Creating an XStream instance it will\n     * register for all kind of classes and types of the current JDK, but not for any 3rd party\n     * type. To ensure that all other types are loaded with your class loader, you should call\n     * this method as early as possible - or consider to provide the class loader directly in\n     * the constructor.\n     * \n     * @since 1.1.1\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        classLoaderReference.setReference(classLoader);\n    }\n\n    /**\n     * Retrieve the ClassLoader XStream uses to load classes.\n     *\n     * @since 1.1.1\n     */\n    public ClassLoader getClassLoader() {\n        return classLoaderReference.getReference();\n    }\n    \n    /**\n     * Retrieve the reference to this instance' ClassLoader. Use this reference for other\n     * XStream components (like converters) to ensure that they will use a changed ClassLoader\n     * instance automatically.\n     * \n     * @return the reference\n     * @since 1.4.5\n     */\n    public ClassLoaderReference getClassLoaderReference() {\n        return classLoaderReference;\n    }\n\n    /**\n     * Prevents a field from being serialized. To omit a field you must always provide the\n     * declaring type and not necessarily the type that is converted.\n     * \n     * @since 1.1.3\n     * @throws InitializationException if no {@link ElementIgnoringMapper} is available\n     */\n    public void omitField(Class definedIn, String fieldName) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.omitField(definedIn, fieldName);\n    }\n    \n    /**\n     * Ignore all unknown elements.\n     *\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements() {\n        ignoreUnknownElements(IGNORE_ALL);\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(String pattern) {\n        ignoreUnknownElements(Pattern.compile(pattern));\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(final Pattern pattern) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.addElementsToIgnore(pattern);\n    }\n\n    /**\n     * Process the annotations of the given types and configure the XStream.\n     *\n     * @param types the types with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class[] types) {\n        if (annotationConfiguration == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ANNOTATION_MAPPER_TYPE\n                + \" available\");\n        }\n        annotationConfiguration.processAnnotations(types);\n    }\n\n    /**\n     * Process the annotations of the given type and configure the XStream. A call of this\n     * method will automatically turn the auto-detection mode for annotations off.\n     * \n     * @param type the type with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class type) {\n        processAnnotations(new Class[]{type});\n    }\n\n    /**\n     * Set the auto-detection mode of the AnnotationMapper. Note that auto-detection implies\n     * that the XStream is configured while it is processing the XML steams. This is a potential\n     * concurrency problem. Also is it technically not possible to detect all class aliases at\n     * deserialization. You have been warned!\n     * \n     * @param mode <code>true</code> if annotations are auto-detected\n     * @since 1.3\n     */\n    public void autodetectAnnotations(boolean mode) {\n        if (annotationConfiguration != null) {\n            annotationConfiguration.autodetectAnnotations(mode);\n        }\n    }\n    \n    /**\n     * Add a new security permission.\n     * \n     * <p>\n     * Permissions are evaluated in the added sequence. An instance of {@link NoTypePermission} or\n     * {@link AnyTypePermission} will implicitly wipe any existing permission.\n     * </p>\n     *\n     * @param permission the permission to add\n     * @since 1.4.7\n     */\n    public void addPermission(TypePermission permission) {\n        if (securityMapper != null) {\n            if (permission == AnyTypePermission.ANY)\n                securityInitialized = false;\n            else if (permission == NoTypePermission.NONE) {\n                securityInitialized = true;\n            }\n            securityInitialized = true;\n            securityMapper.addPermission(permission);\n        }\n    }\n    \n    /**\n     * Add security permission for explicit types by name.\n     *\n     * @param names the type names to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(String[] names) {\n        addPermission(new ExplicitTypePermission(names));\n    }\n    \n    /**\n     * Add security permission for explicit types.\n     *\n     * @param types the types to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(Class[] types) {\n        addPermission(new ExplicitTypePermission(types));\n    }\n    \n    /**\n     * Add security permission for a type hierarchy.\n     *\n     * @param type the base type to allow\n     * @since 1.4.7\n     */\n    public void allowTypeHierarchy(Class type) {\n        addPermission(new TypeHierarchyPermission(type));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(String[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(Pattern[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByWildcard(String[] patterns) {\n        addPermission(new WildcardTypePermission(patterns));\n    }\n    \n    /**\n     * Add security permission denying another one.\n     *\n     * @param permission the permission to deny\n     * @since 1.4.7\n     */\n    public void denyPermission(TypePermission permission) {\n        addPermission(new NoPermission(permission));\n    }\n    \n    /**\n     * Add security permission forbidding explicit types by name.\n     *\n     * @param names the type names to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(String[] names) {\n        denyPermission(new ExplicitTypePermission(names));\n    }\n    \n    /**\n     * Add security permission forbidding explicit types.\n     *\n     * @param types the types to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(Class[] types) {\n        denyPermission(new ExplicitTypePermission(types));\n    }\n    \n    /**\n     * Add security permission forbidding a type hierarchy.\n     *\n     * @param type the base type to forbid\n     * @since 1.4.7\n     */\n    public void denyTypeHierarchy(Class type) {\n        denyPermission(new TypeHierarchyPermission(type));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(String[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(Pattern[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to forbid names\n     * @since 1.4.7\n     */\n    public void denyTypesByWildcard(String[] patterns) {\n        denyPermission(new WildcardTypePermission(patterns));\n    }\n\n    private Object readResolve() {\n        securityWarningGiven = true;\n        return this;\n    }\n\n    /**\n     * @deprecated As of 1.3, use {@link com.thoughtworks.xstream.InitializationException}\n     *             instead\n     */\n    public static class InitializationException extends XStreamException {\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String, Throwable)}\n         *             instead\n         */\n        public InitializationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String)}\n         *             instead\n         */\n        public InitializationException(String message) {\n            super(message);\n        }\n    }\n\n    private class InternalBlackList implements Converter {\n\n        public boolean canConvert(final Class type) {\n            return (type == void.class || type == Void.class)\n                || (!securityInitialized\n                    && type != null\n                    && (type.getName().equals(\"java.beans.EventHandler\")\n                        || type.getName().endsWith(\"$LazyIterator\")\n                        || type.getName().startsWith(\"javax.crypto.\")));\n        }\n\n        public void marshal(final Object source, final HierarchicalStreamWriter writer,\n                final MarshallingContext context) {\n            throw new ConversionException(\"Security alert. Marshalling rejected.\");\n        }\n\n        public Object unmarshal(final HierarchicalStreamReader reader, final UnmarshallingContext context) {\n            throw new ConversionException(\"Security alert. Unmarshalling rejected.\");\n        }\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200197,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package io.swagger.parser.util;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport io.swagger.util.Json;\nimport io.swagger.util.Yaml;\n\nimport java.io.IOException;\n\n/**\n * Created by russellb337 on 7/14/15.\n */\npublic class DeserializationUtils {\n    public static JsonNode deserializeIntoTree(String contents, String fileOrHost) {\n        JsonNode result;\n\n        try {\n            if (fileOrHost.endsWith(\".yaml\")) {\n                result = readYamlTree(contents);\n            } else {\n                result = Json.mapper().readTree(contents);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"An exception was thrown while trying to deserialize the contents of \" + fileOrHost + \" into a JsonNode tree\", e);\n        }\n\n        return result;\n    }\n\n    public static <T> T deserialize(Object contents, String fileOrHost, Class<T> expectedType) {\n        T result;\n\n        ObjectMapper mapper;\n        boolean isYaml = false;\n\n        if(fileOrHost.endsWith(\".yaml\")) {\n            mapper = Yaml.mapper();\n            isYaml = true;\n        } else {\n            mapper = Json.mapper();\n        }\n\n        try {\n            if (contents instanceof String) {\n                if (isYaml) {\n                    result = readYamlValue((String) contents, expectedType);\n                } else {\n                    result = mapper.readValue((String) contents, expectedType);\n                }\n            } else {\n                result = mapper.convertValue(contents, expectedType);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"An exception was thrown while trying to deserialize the contents of \" + fileOrHost + \" into type \" + expectedType, e);\n        }\n\n        return result;\n    }\n\n    public static JsonNode readYamlTree(String contents) {\n        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();\n        return Json.mapper().convertValue(yaml.load(contents), JsonNode.class);\n    }\n\n    public static <T> T readYamlValue(String contents, Class<T> expectedType) {\n        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();\n        return Json.mapper().convertValue(yaml.load(contents), expectedType);\n    }\n}",
    "target": 1,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800076,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package io.swagger.parser.util;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport io.swagger.util.Json;\nimport io.swagger.util.Yaml;\nimport org.yaml.snakeyaml.constructor.SafeConstructor;\n\nimport java.io.IOException;\n\n/**\n * Created by russellb337 on 7/14/15.\n */\npublic class DeserializationUtils {\n    public static JsonNode deserializeIntoTree(String contents, String fileOrHost) {\n        JsonNode result;\n\n        try {\n            if (isJson(contents)) {\n                result = Json.mapper().readTree(contents);\n            } else {\n                result = readYamlTree(contents);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"An exception was thrown while trying to deserialize the contents of \" + fileOrHost + \" into a JsonNode tree\", e);\n        }\n\n        return result;\n    }\n\n    public static <T> T deserialize(Object contents, String fileOrHost, Class<T> expectedType) {\n        T result;\n\n        boolean isJson = false;\n\n        if(contents instanceof String && isJson((String)contents)) {\n            isJson = true;\n        }\n\n        try {\n            if (contents instanceof String) {\n                if (isJson) {\n                    result = Json.mapper().readValue((String) contents, expectedType);\n                } else {\n                    result = Yaml.mapper().readValue((String) contents, expectedType);\n                }\n            } else {\n                result = Json.mapper().convertValue(contents, expectedType);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"An exception was thrown while trying to deserialize the contents of \" + fileOrHost + \" into type \" + expectedType, e);\n        }\n\n        return result;\n    }\n\n    private static boolean isJson(String contents) {\n        return contents.toString().trim().startsWith(\"{\");\n    }\n\n    public static JsonNode readYamlTree(String contents) {\n        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml(new SafeConstructor());\n        return Json.mapper().convertValue(yaml.load(contents), JsonNode.class);\n    }\n\n    public static <T> T readYamlValue(String contents, Class<T> expectedType) {\n        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml(new SafeConstructor());\n        return Json.mapper().convertValue(yaml.load(contents), expectedType);\n    }\n}",
    "target": 0,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800077,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFactory</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        // [databind#2680]\n        s.add(\"org.springframework.aop.config.MethodLocatingFactoryBean\");\n        s.add(\"org.springframework.beans.factory.config.BeanReferenceFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186], [databind#2670]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.WASRegistryManagedRuntime\"); // [#2670] addition\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        // [databind#2704]: xalan2\n        s.add(\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core/-dbcp\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n        // [databind#2814]: anteros-dbcp\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPDataSource\");\n\n        // [databind#2642][databind#2854]: javax.swing (jdk)\n        s.add(\"javax.swing.JEditorPane\");\n        s.add(\"javax.swing.JTextPane\");\n\n        // [databind#2648], [databind#2653]: shire-core\n        s.add(\"org.apache.shiro.realm.jndi.JndiRealmFactory\");\n        s.add(\"org.apache.shiro.jndi.JndiObjectFactory\");\n\n        // [databind#2658]: ignite-jta (, quartz-core)\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\");\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory\");\n        s.add(\"org.quartz.utils.JNDIConnectionProvider\");\n\n        // [databind#2659]: aries.transaction.jms\n        s.add(\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\");\n        s.add(\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\");\n\n        // [databind#2660]: caucho-quercus\n        s.add(\"com.caucho.config.types.ResourceRef\");\n\n        // [databind#2662]: aoju/bus-proxy\n        s.add(\"org.aoju.bus.proxy.provider.RmiProvider\");\n        s.add(\"org.aoju.bus.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms\n\n        s.add(\"org.apache.activemq.ActiveMQConnectionFactory\"); // core\n        s.add(\"org.apache.activemq.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.JcaPooledConnectionFactory\"); // pool\n        s.add(\"org.apache.activemq.pool.PooledConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.XaPooledConnectionFactory\");\n        s.add(\"org.apache.activemq.jms.pool.XaPooledConnectionFactory\"); // pool-jms\n        s.add(\"org.apache.activemq.jms.pool.JcaPooledConnectionFactory\");\n        \n        // [databind#2666]: apache/commons-jms\n        s.add(\"org.apache.commons.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2682]: commons-jelly\n        s.add(\"org.apache.commons.jelly.impl.Embedded\");\n\n        // [databind#2688]: apache/drill\n        s.add(\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2698]: weblogic w/ oracle/aq-jms\n        // (note: dependency not available via Maven Central, but as part of\n        // weblogic installation, possibly fairly old version(s))\n        s.add(\"oracle.jms.AQjmsQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXATopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsTopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAConnectionFactory\");\n\n        // [databind#2764]: org.jsecurity:\n        s.add(\"org.jsecurity.realm.jndi.JndiRealmFactory\");\n\n        // [databind#2798]: com.pastdev.httpcomponents:\n        s.add(\"com.pastdev.httpcomponents.configuration.JndiConfiguration\");\n\n        // [databind#2826], [databind#2827]\n        s.add(\"com.nqadmin.rowset.JdbcRowSetImpl\");\n        s.add(\"org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl\");\n\n        // [databind#2986]: dbcp2\n        s.add(\"org.apache.commons.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2996]: newrelic-agent + embedded-logback-core\n        // (derivative of #2334 and #2389)\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource\");\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2997]: tomcat/naming-factory-dbcp (embedded dbcp 1.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2998]: org.apache.tomcat/tomcat-dbcp (embedded dbcp 2.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.SharedPoolDataSource\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700212,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFactory</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        // [databind#2680]\n        s.add(\"org.springframework.aop.config.MethodLocatingFactoryBean\");\n        s.add(\"org.springframework.beans.factory.config.BeanReferenceFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186], [databind#2670]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.WASRegistryManagedRuntime\"); // [#2670] addition\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        // [databind#2704]: xalan2\n        s.add(\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core/-dbcp\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n        // [databind#2814]: anteros-dbcp\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPDataSource\");\n\n        // [databind#2642][databind#2854]: javax.swing (jdk)\n        s.add(\"javax.swing.JEditorPane\");\n        s.add(\"javax.swing.JTextPane\");\n\n        // [databind#2648], [databind#2653]: shire-core\n        s.add(\"org.apache.shiro.realm.jndi.JndiRealmFactory\");\n        s.add(\"org.apache.shiro.jndi.JndiObjectFactory\");\n\n        // [databind#2658]: ignite-jta (, quartz-core)\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\");\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory\");\n        s.add(\"org.quartz.utils.JNDIConnectionProvider\");\n\n        // [databind#2659]: aries.transaction.jms\n        s.add(\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\");\n        s.add(\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\");\n\n        // [databind#2660]: caucho-quercus\n        s.add(\"com.caucho.config.types.ResourceRef\");\n\n        // [databind#2662]: aoju/bus-proxy\n        s.add(\"org.aoju.bus.proxy.provider.RmiProvider\");\n        s.add(\"org.aoju.bus.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms\n\n        s.add(\"org.apache.activemq.ActiveMQConnectionFactory\"); // core\n        s.add(\"org.apache.activemq.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.JcaPooledConnectionFactory\"); // pool\n        s.add(\"org.apache.activemq.pool.PooledConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.XaPooledConnectionFactory\");\n        s.add(\"org.apache.activemq.jms.pool.XaPooledConnectionFactory\"); // pool-jms\n        s.add(\"org.apache.activemq.jms.pool.JcaPooledConnectionFactory\");\n        \n        // [databind#2666]: apache/commons-jms\n        s.add(\"org.apache.commons.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2682]: commons-jelly\n        s.add(\"org.apache.commons.jelly.impl.Embedded\");\n\n        // [databind#2688]: apache/drill\n        s.add(\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2698]: weblogic w/ oracle/aq-jms\n        // (note: dependency not available via Maven Central, but as part of\n        // weblogic installation, possibly fairly old version(s))\n        s.add(\"oracle.jms.AQjmsQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXATopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsTopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAConnectionFactory\");\n\n        // [databind#2764]: org.jsecurity:\n        s.add(\"org.jsecurity.realm.jndi.JndiRealmFactory\");\n\n        // [databind#2798]: com.pastdev.httpcomponents:\n        s.add(\"com.pastdev.httpcomponents.configuration.JndiConfiguration\");\n\n        // [databind#2826], [databind#2827]\n        s.add(\"com.nqadmin.rowset.JdbcRowSetImpl\");\n        s.add(\"org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl\");\n\n        // [databind#2986]: dbcp2\n        s.add(\"org.apache.commons.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2996]: newrelic-agent + embedded-logback-core\n        // (derivative of #2334 and #2389)\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource\");\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2997]: tomcat/naming-factory-dbcp (embedded dbcp 1.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2998]: org.apache.tomcat/tomcat-dbcp (embedded dbcp 2.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2999]: org.glassfish.web/javax.servlet.jsp.jstl (embedded Xalan)\n        // (derivative of #2469)\n        s.add(\"com.oracle.wls.shaded.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700213,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFactory</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        // [databind#2680]\n        s.add(\"org.springframework.aop.config.MethodLocatingFactoryBean\");\n        s.add(\"org.springframework.beans.factory.config.BeanReferenceFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186], [databind#2670]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.WASRegistryManagedRuntime\"); // [#2670] addition\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        // [databind#2704]: xalan2\n        s.add(\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core/-dbcp\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n        // [databind#2814]: anteros-dbcp\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPDataSource\");\n\n        // [databind#2642][databind#2854]: javax.swing (jdk)\n        s.add(\"javax.swing.JEditorPane\");\n        s.add(\"javax.swing.JTextPane\");\n\n        // [databind#2648], [databind#2653]: shire-core\n        s.add(\"org.apache.shiro.realm.jndi.JndiRealmFactory\");\n        s.add(\"org.apache.shiro.jndi.JndiObjectFactory\");\n\n        // [databind#2658]: ignite-jta (, quartz-core)\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\");\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory\");\n        s.add(\"org.quartz.utils.JNDIConnectionProvider\");\n\n        // [databind#2659]: aries.transaction.jms\n        s.add(\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\");\n        s.add(\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\");\n\n        // [databind#2660]: caucho-quercus\n        s.add(\"com.caucho.config.types.ResourceRef\");\n\n        // [databind#2662]: aoju/bus-proxy\n        s.add(\"org.aoju.bus.proxy.provider.RmiProvider\");\n        s.add(\"org.aoju.bus.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms\n\n        s.add(\"org.apache.activemq.ActiveMQConnectionFactory\"); // core\n        s.add(\"org.apache.activemq.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.JcaPooledConnectionFactory\"); // pool\n        s.add(\"org.apache.activemq.pool.PooledConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.XaPooledConnectionFactory\");\n        s.add(\"org.apache.activemq.jms.pool.XaPooledConnectionFactory\"); // pool-jms\n        s.add(\"org.apache.activemq.jms.pool.JcaPooledConnectionFactory\");\n        \n        // [databind#2666]: apache/commons-jms\n        s.add(\"org.apache.commons.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2682]: commons-jelly\n        s.add(\"org.apache.commons.jelly.impl.Embedded\");\n\n        // [databind#2688]: apache/drill\n        s.add(\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        s.add(\"oadd.org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"oadd.org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2698]: weblogic w/ oracle/aq-jms\n        // (note: dependency not available via Maven Central, but as part of\n        // weblogic installation, possibly fairly old version(s))\n        s.add(\"oracle.jms.AQjmsQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXATopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsTopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAConnectionFactory\");\n\n        // [databind#2764]: org.jsecurity:\n        s.add(\"org.jsecurity.realm.jndi.JndiRealmFactory\");\n\n        // [databind#2798]: com.pastdev.httpcomponents:\n        s.add(\"com.pastdev.httpcomponents.configuration.JndiConfiguration\");\n\n        // [databind#2826], [databind#2827]\n        s.add(\"com.nqadmin.rowset.JdbcRowSetImpl\");\n        s.add(\"org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl\");\n\n        // [databind#2986]: dbcp2\n        s.add(\"org.apache.commons.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2996]: newrelic-agent + embedded-logback-core\n        // (derivative of #2334 and #2389)\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource\");\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2997]: tomcat/naming-factory-dbcp (embedded dbcp 1.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2998]: org.apache.tomcat/tomcat-dbcp (embedded dbcp 2.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2999]: org.glassfish.web/javax.servlet.jsp.jstl (embedded Xalan)\n        // (derivative of #2469)\n        s.add(\"com.oracle.wls.shaded.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#303]: another case of embedded Xalan (derivative of #2469)\n        s.add(\"org.docx4j.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700214,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFactory</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        // [databind#2680]\n        s.add(\"org.springframework.aop.config.MethodLocatingFactoryBean\");\n        s.add(\"org.springframework.beans.factory.config.BeanReferenceFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186], [databind#2670]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.WASRegistryManagedRuntime\"); // [#2670] addition\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        // [databind#2704]: xalan2\n        s.add(\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: commons-dbcp 1.x, p6spy\n        // [databind#3004]: commons-dbcp 1.x\n        s.add(\"org.apache.commons.dbcp.cpdsadapter.DriverAdapterCPDS\");\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core/-dbcp\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n        // [databind#2814]: anteros-dbcp\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPDataSource\");\n\n        // [databind#2642][databind#2854]: javax.swing (jdk)\n        s.add(\"javax.swing.JEditorPane\");\n        s.add(\"javax.swing.JTextPane\");\n\n        // [databind#2648], [databind#2653]: shire-core\n        s.add(\"org.apache.shiro.realm.jndi.JndiRealmFactory\");\n        s.add(\"org.apache.shiro.jndi.JndiObjectFactory\");\n\n        // [databind#2658]: ignite-jta (, quartz-core)\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\");\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory\");\n        s.add(\"org.quartz.utils.JNDIConnectionProvider\");\n\n        // [databind#2659]: aries.transaction.jms\n        s.add(\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\");\n        s.add(\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\");\n\n        // [databind#2660]: caucho-quercus\n        s.add(\"com.caucho.config.types.ResourceRef\");\n\n        // [databind#2662]: aoju/bus-proxy\n        s.add(\"org.aoju.bus.proxy.provider.RmiProvider\");\n        s.add(\"org.aoju.bus.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms\n\n        s.add(\"org.apache.activemq.ActiveMQConnectionFactory\"); // core\n        s.add(\"org.apache.activemq.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.JcaPooledConnectionFactory\"); // pool\n        s.add(\"org.apache.activemq.pool.PooledConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.XaPooledConnectionFactory\");\n        s.add(\"org.apache.activemq.jms.pool.XaPooledConnectionFactory\"); // pool-jms\n        s.add(\"org.apache.activemq.jms.pool.JcaPooledConnectionFactory\");\n        \n        // [databind#2666]: apache/commons-jms\n        s.add(\"org.apache.commons.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2682]: commons-jelly\n        s.add(\"org.apache.commons.jelly.impl.Embedded\");\n\n        // [databind#2688], [databind#3004]: apache/drill\n        s.add(\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        s.add(\"oadd.org.apache.commons.dbcp.cpdsadapter.DriverAdapterCPDS\");\n        s.add(\"oadd.org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"oadd.org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2698]: weblogic w/ oracle/aq-jms\n        // (note: dependency not available via Maven Central, but as part of\n        // weblogic installation, possibly fairly old version(s))\n        s.add(\"oracle.jms.AQjmsQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXATopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsTopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAConnectionFactory\");\n\n        // [databind#2764]: org.jsecurity:\n        s.add(\"org.jsecurity.realm.jndi.JndiRealmFactory\");\n\n        // [databind#2798]: com.pastdev.httpcomponents:\n        s.add(\"com.pastdev.httpcomponents.configuration.JndiConfiguration\");\n\n        // [databind#2826], [databind#2827]\n        s.add(\"com.nqadmin.rowset.JdbcRowSetImpl\");\n        s.add(\"org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl\");\n\n        // [databind#2986], [databind#3004]: dbcp2\n        s.add(\"org.apache.commons.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp2.datasources.SharedPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp2.cpdsadapter.DriverAdapterCPDS\");\n\n        // [databind#2996]: newrelic-agent + embedded-logback-core\n        // (derivative of #2334 and #2389)\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource\");\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2997]/[databind#3004]: tomcat/naming-factory-dbcp (embedded dbcp 1.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp.cpdsadapter.DriverAdapterCPDS\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2998]/[databind#3004]: org.apache.tomcat/tomcat-dbcp (embedded dbcp 2.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.cpdsadapter.DriverAdapterCPDS\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2999]: org.glassfish.web/javax.servlet.jsp.jstl (embedded Xalan)\n        // (derivative of #2469)\n        s.add(\"com.oracle.wls.shaded.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#3003]: another case of embedded Xalan (derivative of #2469)\n        s.add(\"org.docx4j.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        \n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700215,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFactory</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        // [databind#2680]\n        s.add(\"org.springframework.aop.config.MethodLocatingFactoryBean\");\n        s.add(\"org.springframework.beans.factory.config.BeanReferenceFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186], [databind#2670]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.WASRegistryManagedRuntime\"); // [#2670] addition\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        // [databind#2704]: xalan2\n        s.add(\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core/-dbcp\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n        // [databind#2814]: anteros-dbcp\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPDataSource\");\n\n        // [databind#2642][databind#2854]: javax.swing (jdk)\n        s.add(\"javax.swing.JEditorPane\");\n        s.add(\"javax.swing.JTextPane\");\n\n        // [databind#2648], [databind#2653]: shire-core\n        s.add(\"org.apache.shiro.realm.jndi.JndiRealmFactory\");\n        s.add(\"org.apache.shiro.jndi.JndiObjectFactory\");\n\n        // [databind#2658]: ignite-jta (, quartz-core)\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\");\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory\");\n        s.add(\"org.quartz.utils.JNDIConnectionProvider\");\n\n        // [databind#2659]: aries.transaction.jms\n        s.add(\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\");\n        s.add(\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\");\n\n        // [databind#2660]: caucho-quercus\n        s.add(\"com.caucho.config.types.ResourceRef\");\n\n        // [databind#2662]: aoju/bus-proxy\n        s.add(\"org.aoju.bus.proxy.provider.RmiProvider\");\n        s.add(\"org.aoju.bus.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms\n\n        s.add(\"org.apache.activemq.ActiveMQConnectionFactory\"); // core\n        s.add(\"org.apache.activemq.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.JcaPooledConnectionFactory\"); // pool\n        s.add(\"org.apache.activemq.pool.PooledConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.XaPooledConnectionFactory\");\n        s.add(\"org.apache.activemq.jms.pool.XaPooledConnectionFactory\"); // pool-jms\n        s.add(\"org.apache.activemq.jms.pool.JcaPooledConnectionFactory\");\n        \n        // [databind#2666]: apache/commons-jms\n        s.add(\"org.apache.commons.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2682]: commons-jelly\n        s.add(\"org.apache.commons.jelly.impl.Embedded\");\n\n        // [databind#2688]: apache/drill\n        s.add(\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        s.add(\"oadd.org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"oadd.org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2698]: weblogic w/ oracle/aq-jms\n        // (note: dependency not available via Maven Central, but as part of\n        // weblogic installation, possibly fairly old version(s))\n        s.add(\"oracle.jms.AQjmsQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXATopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsTopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAConnectionFactory\");\n\n        // [databind#2764]: org.jsecurity:\n        s.add(\"org.jsecurity.realm.jndi.JndiRealmFactory\");\n\n        // [databind#2798]: com.pastdev.httpcomponents:\n        s.add(\"com.pastdev.httpcomponents.configuration.JndiConfiguration\");\n\n        // [databind#2826], [databind#2827]\n        s.add(\"com.nqadmin.rowset.JdbcRowSetImpl\");\n        s.add(\"org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl\");\n\n        // [databind#2986]: dbcp2\n        s.add(\"org.apache.commons.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2996]: newrelic-agent + embedded-logback-core\n        // (derivative of #2334 and #2389)\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource\");\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2997]: tomcat/naming-factory-dbcp (embedded dbcp 1.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2998]: org.apache.tomcat/tomcat-dbcp (embedded dbcp 2.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2999]: org.glassfish.web/javax.servlet.jsp.jstl (embedded Xalan)\n        // (derivative of #2469)\n        s.add(\"com.oracle.wls.shaded.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700216,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFactory</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        // [databind#2680]\n        s.add(\"org.springframework.aop.config.MethodLocatingFactoryBean\");\n        s.add(\"org.springframework.beans.factory.config.BeanReferenceFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186], [databind#2670]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.WASRegistryManagedRuntime\"); // [#2670] addition\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        // [databind#2704]: xalan2\n        s.add(\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core/-dbcp\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n        // [databind#2814]: anteros-dbcp\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPDataSource\");\n\n        // [databind#2642][databind#2854]: javax.swing (jdk)\n        s.add(\"javax.swing.JEditorPane\");\n        s.add(\"javax.swing.JTextPane\");\n\n        // [databind#2648], [databind#2653]: shire-core\n        s.add(\"org.apache.shiro.realm.jndi.JndiRealmFactory\");\n        s.add(\"org.apache.shiro.jndi.JndiObjectFactory\");\n\n        // [databind#2658]: ignite-jta (, quartz-core)\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\");\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory\");\n        s.add(\"org.quartz.utils.JNDIConnectionProvider\");\n\n        // [databind#2659]: aries.transaction.jms\n        s.add(\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\");\n        s.add(\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\");\n\n        // [databind#2660]: caucho-quercus\n        s.add(\"com.caucho.config.types.ResourceRef\");\n\n        // [databind#2662]: aoju/bus-proxy\n        s.add(\"org.aoju.bus.proxy.provider.RmiProvider\");\n        s.add(\"org.aoju.bus.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms\n\n        s.add(\"org.apache.activemq.ActiveMQConnectionFactory\"); // core\n        s.add(\"org.apache.activemq.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.JcaPooledConnectionFactory\"); // pool\n        s.add(\"org.apache.activemq.pool.PooledConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.XaPooledConnectionFactory\");\n        s.add(\"org.apache.activemq.jms.pool.XaPooledConnectionFactory\"); // pool-jms\n        s.add(\"org.apache.activemq.jms.pool.JcaPooledConnectionFactory\");\n        \n        // [databind#2666]: apache/commons-jms\n        s.add(\"org.apache.commons.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2682]: commons-jelly\n        s.add(\"org.apache.commons.jelly.impl.Embedded\");\n\n        // [databind#2688]: apache/drill\n        s.add(\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        s.add(\"oadd.org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"oadd.org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2698]: weblogic w/ oracle/aq-jms\n        // (note: dependency not available via Maven Central, but as part of\n        // weblogic installation, possibly fairly old version(s))\n        s.add(\"oracle.jms.AQjmsQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXATopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsTopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAConnectionFactory\");\n\n        // [databind#2764]: org.jsecurity:\n        s.add(\"org.jsecurity.realm.jndi.JndiRealmFactory\");\n\n        // [databind#2798]: com.pastdev.httpcomponents:\n        s.add(\"com.pastdev.httpcomponents.configuration.JndiConfiguration\");\n\n        // [databind#2826], [databind#2827]\n        s.add(\"com.nqadmin.rowset.JdbcRowSetImpl\");\n        s.add(\"org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl\");\n\n        // [databind#2986]: dbcp2\n        s.add(\"org.apache.commons.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2996]: newrelic-agent + embedded-logback-core\n        // (derivative of #2334 and #2389)\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource\");\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2997]: tomcat/naming-factory-dbcp (embedded dbcp 1.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2998]: org.apache.tomcat/tomcat-dbcp (embedded dbcp 2.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2999]: org.glassfish.web/javax.servlet.jsp.jstl (embedded Xalan)\n        // (derivative of #2469)\n        s.add(\"com.oracle.wls.shaded.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#303]: another case of embedded Xalan (derivative of #2469)\n        s.add(\"org.docx4j.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700217,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.node;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.type.WritableTypeId;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n\n/**\n * This intermediate base class is used for all leaf nodes, that is,\n * all non-container (array or object) nodes, except for the\n * \"missing node\".\n */\npublic abstract class ValueNode\n    extends BaseJsonNode\n{\n    private static final long serialVersionUID = 1L;\n\n    protected ValueNode() { }\n\n    @Override\n    protected JsonNode _at(JsonPointer ptr) {\n        // 02-Jan-2020, tatu: As per [databind#3003] must return `null` and NOT\n        //    \"missing node\"\n        return null;\n    }\n\n    /**\n     * All current value nodes are immutable, so we can just return\n     * them as is.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends JsonNode> T deepCopy() { return (T) this; }\n    \n    @Override public abstract JsonToken asToken();\n\n    @Override\n    public void serializeWithType(JsonGenerator g, SerializerProvider provider,\n            TypeSerializer typeSer)\n        throws IOException\n    {\n        WritableTypeId typeIdDef = typeSer.writeTypePrefix(g,\n                typeSer.typeId(this, asToken()));\n        serialize(g, provider);\n        typeSer.writeTypeSuffix(g, typeIdDef);\n    }\n\n    /*\n    /**********************************************************************\n    /* Basic property access\n    /**********************************************************************\n     */\n\n    @Override\n    public boolean isEmpty() { return true; }\n    \n    /*\n    /**********************************************************************\n    /* Navigation methods\n    /**********************************************************************\n     */\n\n    @Override\n    public final JsonNode get(int index) { return null; }\n\n    @Override\n    public final JsonNode path(int index) { return MissingNode.getInstance(); }\n\n    @Override\n    public final boolean has(int index) { return false; }\n\n    @Override\n    public final boolean hasNonNull(int index) { return false; }\n\n    @Override\n    public final JsonNode get(String fieldName) { return null; }\n\n    @Override\n    public final JsonNode path(String fieldName) { return MissingNode.getInstance(); }\n\n    @Override\n    public final boolean has(String fieldName) { return false; }\n\n    @Override\n    public final boolean hasNonNull(String fieldName) { return false; }\n\n    /*\n     **********************************************************************\n     * Find methods: all \"leaf\" nodes return the same for these\n     **********************************************************************\n     */\n\n    @Override\n    public final JsonNode findValue(String fieldName) {\n        return null;\n    }\n\n    // note: co-variant return type\n    @Override\n    public final ObjectNode findParent(String fieldName) {\n        return null;\n    }\n\n    @Override\n    public final List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) {\n        return foundSoFar;\n    }\n\n    @Override\n    public final List<String> findValuesAsText(String fieldName, List<String> foundSoFar) {\n        return foundSoFar;\n    }\n\n    @Override\n    public final List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) {\n        return foundSoFar;\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700218,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.node;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.type.WritableTypeId;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n\n/**\n * This intermediate base class is used for all leaf nodes, that is,\n * all non-container (array or object) nodes, except for the\n * \"missing node\".\n */\npublic abstract class ValueNode\n    extends BaseJsonNode\n{\n    private static final long serialVersionUID = 1L;\n\n    protected ValueNode() { }\n\n    @Override\n    protected JsonNode _at(JsonPointer ptr) {\n        // 02-Jan-2020, tatu: As per [databind#3005] must return `null` and NOT\n        //    \"missing node\"\n        return null;\n    }\n\n    /**\n     * All current value nodes are immutable, so we can just return\n     * them as is.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends JsonNode> T deepCopy() { return (T) this; }\n    \n    @Override public abstract JsonToken asToken();\n\n    @Override\n    public void serializeWithType(JsonGenerator g, SerializerProvider provider,\n            TypeSerializer typeSer)\n        throws IOException\n    {\n        WritableTypeId typeIdDef = typeSer.writeTypePrefix(g,\n                typeSer.typeId(this, asToken()));\n        serialize(g, provider);\n        typeSer.writeTypeSuffix(g, typeIdDef);\n    }\n\n    /*\n    /**********************************************************************\n    /* Basic property access\n    /**********************************************************************\n     */\n\n    @Override\n    public boolean isEmpty() { return true; }\n    \n    /*\n    /**********************************************************************\n    /* Navigation methods\n    /**********************************************************************\n     */\n\n    @Override\n    public final JsonNode get(int index) { return null; }\n\n    @Override\n    public final JsonNode path(int index) { return MissingNode.getInstance(); }\n\n    @Override\n    public final boolean has(int index) { return false; }\n\n    @Override\n    public final boolean hasNonNull(int index) { return false; }\n\n    @Override\n    public final JsonNode get(String fieldName) { return null; }\n\n    @Override\n    public final JsonNode path(String fieldName) { return MissingNode.getInstance(); }\n\n    @Override\n    public final boolean has(String fieldName) { return false; }\n\n    @Override\n    public final boolean hasNonNull(String fieldName) { return false; }\n\n    /*\n     **********************************************************************\n     * Find methods: all \"leaf\" nodes return the same for these\n     **********************************************************************\n     */\n\n    @Override\n    public final JsonNode findValue(String fieldName) {\n        return null;\n    }\n\n    // note: co-variant return type\n    @Override\n    public final ObjectNode findParent(String fieldName) {\n        return null;\n    }\n\n    @Override\n    public final List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) {\n        return foundSoFar;\n    }\n\n    @Override\n    public final List<String> findValuesAsText(String fieldName, List<String> foundSoFar) {\n        return foundSoFar;\n    }\n\n    @Override\n    public final List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) {\n        return foundSoFar;\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700219,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFactory</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        // [databind#2680]\n        s.add(\"org.springframework.aop.config.MethodLocatingFactoryBean\");\n        s.add(\"org.springframework.beans.factory.config.BeanReferenceFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186], [databind#2670]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.WASRegistryManagedRuntime\"); // [#2670] addition\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        // [databind#2704]: xalan2\n        s.add(\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core/-dbcp\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n        // [databind#2814]: anteros-dbcp\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPDataSource\");\n\n        // [databind#2642][databind#2854]: javax.swing (jdk)\n        s.add(\"javax.swing.JEditorPane\");\n        s.add(\"javax.swing.JTextPane\");\n\n        // [databind#2648], [databind#2653]: shire-core\n        s.add(\"org.apache.shiro.realm.jndi.JndiRealmFactory\");\n        s.add(\"org.apache.shiro.jndi.JndiObjectFactory\");\n\n        // [databind#2658]: ignite-jta (, quartz-core)\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\");\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory\");\n        s.add(\"org.quartz.utils.JNDIConnectionProvider\");\n\n        // [databind#2659]: aries.transaction.jms\n        s.add(\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\");\n        s.add(\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\");\n\n        // [databind#2660]: caucho-quercus\n        s.add(\"com.caucho.config.types.ResourceRef\");\n\n        // [databind#2662]: aoju/bus-proxy\n        s.add(\"org.aoju.bus.proxy.provider.RmiProvider\");\n        s.add(\"org.aoju.bus.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms\n\n        s.add(\"org.apache.activemq.ActiveMQConnectionFactory\"); // core\n        s.add(\"org.apache.activemq.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.JcaPooledConnectionFactory\"); // pool\n        s.add(\"org.apache.activemq.pool.PooledConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.XaPooledConnectionFactory\");\n        s.add(\"org.apache.activemq.jms.pool.XaPooledConnectionFactory\"); // pool-jms\n        s.add(\"org.apache.activemq.jms.pool.JcaPooledConnectionFactory\");\n        \n        // [databind#2666]: apache/commons-jms\n        s.add(\"org.apache.commons.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2682]: commons-jelly\n        s.add(\"org.apache.commons.jelly.impl.Embedded\");\n\n        // [databind#2688]: apache/drill\n        s.add(\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2698]: weblogic w/ oracle/aq-jms\n        // (note: dependency not available via Maven Central, but as part of\n        // weblogic installation, possibly fairly old version(s))\n        s.add(\"oracle.jms.AQjmsQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXATopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsTopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAConnectionFactory\");\n\n        // [databind#2764]: org.jsecurity:\n        s.add(\"org.jsecurity.realm.jndi.JndiRealmFactory\");\n\n        // [databind#2798]: com.pastdev.httpcomponents:\n        s.add(\"com.pastdev.httpcomponents.configuration.JndiConfiguration\");\n\n        // [databind#2826], [databind#2827]\n        s.add(\"com.nqadmin.rowset.JdbcRowSetImpl\");\n        s.add(\"org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl\");\n\n        // [databind#2986]: dbcp2\n        s.add(\"org.apache.commons.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2996]: newrelic-agent + embedded-logback-core\n        // (derivative of #2334 and #2389)\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource\");\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2997]: tomcat/naming-factory-dbcp (embedded dbcp 1.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.SharedPoolDataSource\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700220,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFactory</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        // [databind#2680]\n        s.add(\"org.springframework.aop.config.MethodLocatingFactoryBean\");\n        s.add(\"org.springframework.beans.factory.config.BeanReferenceFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186], [databind#2670]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.WASRegistryManagedRuntime\"); // [#2670] addition\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        // [databind#2704]: xalan2\n        s.add(\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core/-dbcp\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n        // [databind#2814]: anteros-dbcp\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPDataSource\");\n\n        // [databind#2642][databind#2854]: javax.swing (jdk)\n        s.add(\"javax.swing.JEditorPane\");\n        s.add(\"javax.swing.JTextPane\");\n\n        // [databind#2648], [databind#2653]: shire-core\n        s.add(\"org.apache.shiro.realm.jndi.JndiRealmFactory\");\n        s.add(\"org.apache.shiro.jndi.JndiObjectFactory\");\n\n        // [databind#2658]: ignite-jta (, quartz-core)\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\");\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory\");\n        s.add(\"org.quartz.utils.JNDIConnectionProvider\");\n\n        // [databind#2659]: aries.transaction.jms\n        s.add(\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\");\n        s.add(\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\");\n\n        // [databind#2660]: caucho-quercus\n        s.add(\"com.caucho.config.types.ResourceRef\");\n\n        // [databind#2662]: aoju/bus-proxy\n        s.add(\"org.aoju.bus.proxy.provider.RmiProvider\");\n        s.add(\"org.aoju.bus.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms\n\n        s.add(\"org.apache.activemq.ActiveMQConnectionFactory\"); // core\n        s.add(\"org.apache.activemq.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.JcaPooledConnectionFactory\"); // pool\n        s.add(\"org.apache.activemq.pool.PooledConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.XaPooledConnectionFactory\");\n        s.add(\"org.apache.activemq.jms.pool.XaPooledConnectionFactory\"); // pool-jms\n        s.add(\"org.apache.activemq.jms.pool.JcaPooledConnectionFactory\");\n        \n        // [databind#2666]: apache/commons-jms\n        s.add(\"org.apache.commons.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2682]: commons-jelly\n        s.add(\"org.apache.commons.jelly.impl.Embedded\");\n\n        // [databind#2688]: apache/drill\n        s.add(\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2698]: weblogic w/ oracle/aq-jms\n        // (note: dependency not available via Maven Central, but as part of\n        // weblogic installation, possibly fairly old version(s))\n        s.add(\"oracle.jms.AQjmsQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXATopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsTopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAConnectionFactory\");\n\n        // [databind#2764]: org.jsecurity:\n        s.add(\"org.jsecurity.realm.jndi.JndiRealmFactory\");\n\n        // [databind#2798]: com.pastdev.httpcomponents:\n        s.add(\"com.pastdev.httpcomponents.configuration.JndiConfiguration\");\n\n        // [databind#2826], [databind#2827]\n        s.add(\"com.nqadmin.rowset.JdbcRowSetImpl\");\n        s.add(\"org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl\");\n\n        // [databind#2986]: dbcp2\n        s.add(\"org.apache.commons.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp2.datasources.SharedPoolDataSource\");\n\n        // [databind#2996]: newrelic-agent + embedded-logback-core\n        // (derivative of #2334 and #2389)\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource\");\n        s.add(\"com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2997]: tomcat/naming-factory-dbcp (embedded dbcp 1.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp.datasources.SharedPoolDataSource\");\n\n        // [databind#2998]: org.apache.tomcat/tomcat-dbcp (embedded dbcp 2.x)\n        // (derivative of #2478)\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.datasources.SharedPoolDataSource\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700221,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");   \n        \n        // [databind#2326] (2.7.9.6): one more 3rd party gadget\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan2\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n        \n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700232,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");   \n        \n        // [databind#2326] (2.7.9.6): one more 3rd party gadget\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan2\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700233,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan2\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700234,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan2\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700235,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFactory</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        // [databind#2680]\n        s.add(\"org.springframework.aop.config.MethodLocatingFactoryBean\");\n        s.add(\"org.springframework.beans.factory.config.BeanReferenceFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186], [databind#2670]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.WASRegistryManagedRuntime\"); // [#2670] addition\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        // [databind#2704]: xalan2\n        s.add(\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core/-dbcp\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n        // [databind#2814]: anteros-dbcp\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPDataSource\");\n\n        // [databind#2642]: javax.swing (jdk)\n        s.add(\"javax.swing.JEditorPane\");\n\n        // [databind#2648], [databind#2653]: shire-core\n        s.add(\"org.apache.shiro.realm.jndi.JndiRealmFactory\");\n        s.add(\"org.apache.shiro.jndi.JndiObjectFactory\");\n\n        // [databind#2658]: ignite-jta (, quartz-core)\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\");\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory\");\n        s.add(\"org.quartz.utils.JNDIConnectionProvider\");\n\n        // [databind#2659]: aries.transaction.jms\n        s.add(\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\");\n        s.add(\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\");\n\n        // [databind#2660]: caucho-quercus\n        s.add(\"com.caucho.config.types.ResourceRef\");\n\n        // [databind#2662]: aoju/bus-proxy\n        s.add(\"org.aoju.bus.proxy.provider.RmiProvider\");\n        s.add(\"org.aoju.bus.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms\n\n        s.add(\"org.apache.activemq.ActiveMQConnectionFactory\"); // core\n        s.add(\"org.apache.activemq.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.JcaPooledConnectionFactory\"); // pool\n        s.add(\"org.apache.activemq.pool.PooledConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.XaPooledConnectionFactory\");\n        s.add(\"org.apache.activemq.jms.pool.XaPooledConnectionFactory\"); // pool-jms\n        s.add(\"org.apache.activemq.jms.pool.JcaPooledConnectionFactory\");\n        \n        // [databind#2666]: apache/commons-jms\n        s.add(\"org.apache.commons.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2682]: commons-jelly\n        s.add(\"org.apache.commons.jelly.impl.Embedded\");\n\n        // [databind#2688]: apache/drill\n        s.add(\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2698]: weblogic w/ oracle/aq-jms\n        // (note: dependency not available via Maven Central, but as part of\n        // weblogic installation, possibly fairly old version(s))\n        s.add(\"oracle.jms.AQjmsQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXATopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsTopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAConnectionFactory\");\n\n        // [databind#2764]: org.jsecurity:\n        s.add(\"org.jsecurity.realm.jndi.JndiRealmFactory\");\n\n        // [databind#2798]: com.pastdev.httpcomponents:\n        s.add(\"com.pastdev.httpcomponents.configuration.JndiConfiguration\");\n\n        // [databind#2826], [databind#2827]\n        s.add(\"com.nqadmin.rowset.JdbcRowSetImpl\");\n        s.add(\"org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700236,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFactory</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n        // [databind#2680]\n        s.add(\"org.springframework.aop.config.MethodLocatingFactoryBean\");\n        s.add(\"org.springframework.beans.factory.config.BeanReferenceFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186], [databind#2670]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.WASRegistryManagedRuntime\"); // [#2670] addition\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");\n\n        // [databind#2326] (2.9.9)\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core (2.9.9.1)\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2 (2.9.9.1)\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387], [databind#2460]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n        s.add(\"net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        // [databind#2410]: HikariCP/metricRegistry config\n        s.add(\"com.zaxxer.hikari.HikariConfig\");\n        // [databind#2449]: and sub-class thereof\n        s.add(\"com.zaxxer.hikari.HikariDataSource\");\n\n        // [databind#2420]: CXF/JAX-RS provider/XSLT\n        s.add(\"org.apache.cxf.jaxrs.provider.XSLTJaxbProvider\");\n\n        // [databind#2462]: commons-configuration / -2\n        s.add(\"org.apache.commons.configuration.JNDIConfiguration\");\n        s.add(\"org.apache.commons.configuration2.JNDIConfiguration\");\n\n        // [databind#2469]: xalan\n        s.add(\"org.apache.xalan.lib.sql.JNDIConnectionPool\");\n        // [databind#2704]: xalan2\n        s.add(\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2478]: comons-dbcp, p6spy\n        s.add(\"org.apache.commons.dbcp.datasources.PerUserPoolDataSource\");\n        s.add(\"org.apache.commons.dbcp.datasources.SharedPoolDataSource\");\n        s.add(\"com.p6spy.engine.spy.P6DataSource\");\n\n        // [databind#2498]: log4j-extras (1.2)\n        s.add(\"org.apache.log4j.receivers.db.DriverManagerConnectionSource\");\n        s.add(\"org.apache.log4j.receivers.db.JNDIConnectionSource\");\n\n        // [databind#2526]: some more ehcache\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GenericJndiSelector\");\n        s.add(\"net.sf.ehcache.transaction.manager.selector.GlassfishSelector\");\n\n        // [databind#2620]: xbean-reflect\n        s.add(\"org.apache.xbean.propertyeditor.JndiConverter\");\n\n        // [databind#2631]: shaded hikari-config\n        s.add(\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\");\n\n        // [databind#2634]: ibatis-sqlmap, anteros-core/-dbcp\n        s.add(\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\");\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPConfig\");\n        // [databind#2814]: anteros-dbcp\n        s.add(\"br.com.anteros.dbcp.AnterosDBCPDataSource\");\n\n        // [databind#2642][databind#2854]: javax.swing (jdk)\n        s.add(\"javax.swing.JEditorPane\");\n        s.add(\"javax.swing.JTextPane\");\n\n        // [databind#2648], [databind#2653]: shire-core\n        s.add(\"org.apache.shiro.realm.jndi.JndiRealmFactory\");\n        s.add(\"org.apache.shiro.jndi.JndiObjectFactory\");\n\n        // [databind#2658]: ignite-jta (, quartz-core)\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\");\n        s.add(\"org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory\");\n        s.add(\"org.quartz.utils.JNDIConnectionProvider\");\n\n        // [databind#2659]: aries.transaction.jms\n        s.add(\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\");\n        s.add(\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\");\n\n        // [databind#2660]: caucho-quercus\n        s.add(\"com.caucho.config.types.ResourceRef\");\n\n        // [databind#2662]: aoju/bus-proxy\n        s.add(\"org.aoju.bus.proxy.provider.RmiProvider\");\n        s.add(\"org.aoju.bus.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms\n\n        s.add(\"org.apache.activemq.ActiveMQConnectionFactory\"); // core\n        s.add(\"org.apache.activemq.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQConnectionFactory\");\n        s.add(\"org.apache.activemq.spring.ActiveMQXAConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.JcaPooledConnectionFactory\"); // pool\n        s.add(\"org.apache.activemq.pool.PooledConnectionFactory\");\n        s.add(\"org.apache.activemq.pool.XaPooledConnectionFactory\");\n        s.add(\"org.apache.activemq.jms.pool.XaPooledConnectionFactory\"); // pool-jms\n        s.add(\"org.apache.activemq.jms.pool.JcaPooledConnectionFactory\");\n        \n        // [databind#2666]: apache/commons-jms\n        s.add(\"org.apache.commons.proxy.provider.remoting.RmiProvider\");\n\n        // [databind#2682]: commons-jelly\n        s.add(\"org.apache.commons.jelly.impl.Embedded\");\n\n        // [databind#2688]: apache/drill\n        s.add(\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\");\n\n        // [databind#2698]: weblogic w/ oracle/aq-jms\n        // (note: dependency not available via Maven Central, but as part of\n        // weblogic installation, possibly fairly old version(s))\n        s.add(\"oracle.jms.AQjmsQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXATopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsTopicConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAQueueConnectionFactory\");\n        s.add(\"oracle.jms.AQjmsXAConnectionFactory\");\n\n        // [databind#2764]: org.jsecurity:\n        s.add(\"org.jsecurity.realm.jndi.JndiRealmFactory\");\n\n        // [databind#2798]: com.pastdev.httpcomponents:\n        s.add(\"com.pastdev.httpcomponents.configuration.JndiConfiguration\");\n\n        // [databind#2826], [databind#2827]\n        s.add(\"com.nqadmin.rowset.JdbcRowSetImpl\");\n        s.add(\"org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        ctxt.reportBadTypeDefinition(beanDesc,\n                \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700237,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package io.onedev.server.plugin.executor.kubernetes;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.Context;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.StreamingOutput;\n\nimport org.apache.commons.lang.SerializationUtils;\n\nimport com.google.common.collect.Lists;\n\nimport io.onedev.commons.utils.TarUtils;\nimport io.onedev.k8shelper.CacheAllocationRequest;\nimport io.onedev.k8shelper.CacheInstance;\nimport io.onedev.server.GeneralException;\nimport io.onedev.server.buildspec.job.Job;\nimport io.onedev.server.buildspec.job.JobContext;\nimport io.onedev.server.buildspec.job.JobManager;\n\n@Path(\"/k8s\")\n@Consumes(MediaType.WILDCARD)\n@Singleton\npublic class KubernetesResource {\n\n\tpublic static final String TEST_JOB_TOKEN = UUID.randomUUID().toString();\n\t\n\tprivate final JobManager jobManager;\n\t\n    @Context\n    private HttpServletRequest request;\n    \n    @Inject\n    public KubernetesResource(JobManager jobManager) {\n    \tthis.jobManager = jobManager;\n\t}\n    \n\t@Path(\"/job-context\")\n\t@Produces(MediaType.APPLICATION_OCTET_STREAM)\n    @GET\n    public byte[] getJobContext() {\n\t\tJobContext context = jobManager.getJobContext(getJobToken(), true);\n\t\tMap<String, Object> contextMap = new HashMap<>();\n\t\tcontextMap.put(\"commands\", context.getCommands());\n\t\tcontextMap.put(\"retrieveSource\", context.isRetrieveSource());\n\t\tcontextMap.put(\"cloneDepth\", context.getCloneDepth());\n\t\tcontextMap.put(\"projectName\", context.getProjectName());\n\t\tcontextMap.put(\"cloneInfo\", context.getCloneInfo());\n\t\tcontextMap.put(\"commitHash\", context.getCommitId().name());\n\t\tcontextMap.put(\"collectFiles.includes\", context.getCollectFiles().getIncludes());\n\t\tcontextMap.put(\"collectFiles.excludes\", context.getCollectFiles().getExcludes());\n\t\treturn SerializationUtils.serialize((Serializable) contextMap);\n    }\n\t\n\t@Path(\"/allocate-job-caches\")\n\t@Consumes(MediaType.APPLICATION_OCTET_STREAM)\n\t@Produces(MediaType.APPLICATION_OCTET_STREAM)\n    @POST\n    public byte[] allocateJobCaches(byte[] cacheAllocationRequestBytes) {\n\t\tCacheAllocationRequest allocationRequest = (CacheAllocationRequest) SerializationUtils\n\t\t\t\t.deserialize(cacheAllocationRequestBytes);\n\t\treturn SerializationUtils.serialize((Serializable) jobManager.allocateJobCaches(\n\t\t\t\tgetJobToken(), allocationRequest.getCurrentTime(), allocationRequest.getInstances()));\n    }\n\t\n\t@Path(\"/report-job-caches\")\n\t@Consumes(MediaType.APPLICATION_OCTET_STREAM)\n\t@POST\n\tpublic void reportJobCaches(byte[] cacheInstanceBytes) {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tCollection<CacheInstance> cacheInstances = (Collection<CacheInstance>) SerializationUtils\n\t\t\t\t.deserialize(cacheInstanceBytes);\n\t\tjobManager.reportJobCaches(getJobToken(), cacheInstances);\n\t}\n\t\n\t@Path(\"/download-dependencies\")\n\t@Produces(MediaType.APPLICATION_OCTET_STREAM)\n\t@GET\n\tpublic Response downloadDependencies() {\n\t\tStreamingOutput os = new StreamingOutput() {\n\n\t\t\t@Override\n\t\t   public void write(OutputStream output) throws IOException {\n\t\t\t\tJobContext context = jobManager.getJobContext(getJobToken(), true);\n\t\t\t\tTarUtils.tar(context.getServerWorkspace(), Lists.newArrayList(\"**\"), \n\t\t\t\t\t\tnew ArrayList<>(), output);\n\t\t\t\toutput.flush();\n\t\t   }\t\t\t\t   \n\t\t   \n\t\t};\n\t\treturn Response.ok(os).build();\n\t}\n\t\n\t@POST\n\t@Path(\"/upload-outcomes\")\n\t@Consumes(MediaType.APPLICATION_OCTET_STREAM)\t\n\tpublic Response uploadOutcomes(InputStream is) {\n\t\tJobContext context = jobManager.getJobContext(getJobToken(), true);\n\t\tTarUtils.untar(is, context.getServerWorkspace());\n\t\treturn Response.ok().build();\n\t}\n\t\n\t@GET\n\t@Path(\"/test\")\n\tpublic Response test() {\n\t\tString jobToken = Job.getToken(request);\n\t\tif (TEST_JOB_TOKEN.equals(jobToken))\n\t\t\treturn Response.ok().build();\n\t\telse \n\t\t\treturn Response.status(400).entity(\"Invalid or missing job token\").build();\n\t}\n\t\n\tprivate String getJobToken() {\n\t\tString jobToken = Job.getToken(request);\n\t\tif (jobToken != null)\n\t\t\treturn jobToken;\n\t\telse\n\t\t\tthrow new GeneralException(\"Job token is expected\");\n\t}\n\t\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700238,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "package io.onedev.server.plugin.executor.kubernetes;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.Context;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.StreamingOutput;\n\nimport org.apache.commons.lang.SerializationUtils;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Lists;\n\nimport io.onedev.commons.utils.TarUtils;\nimport io.onedev.k8shelper.CacheAllocationRequest;\nimport io.onedev.k8shelper.CacheInstance;\nimport io.onedev.server.GeneralException;\nimport io.onedev.server.buildspec.job.Job;\nimport io.onedev.server.buildspec.job.JobContext;\nimport io.onedev.server.buildspec.job.JobManager;\n\n@Path(\"/k8s\")\n@Consumes(MediaType.WILDCARD)\n@Singleton\npublic class KubernetesResource {\n\n\tpublic static final String TEST_JOB_TOKEN = UUID.randomUUID().toString();\n\t\n\tprivate final JobManager jobManager;\n\t\n    @Context\n    private HttpServletRequest request;\n    \n    @Inject\n    public KubernetesResource(JobManager jobManager) {\n    \tthis.jobManager = jobManager;\n\t}\n    \n\t@Path(\"/job-context\")\n\t@Produces(MediaType.APPLICATION_OCTET_STREAM)\n    @GET\n    public byte[] getJobContext() {\n\t\tJobContext context = jobManager.getJobContext(getJobToken(), true);\n\t\tMap<String, Object> contextMap = new HashMap<>();\n\t\tcontextMap.put(\"commands\", context.getCommands());\n\t\tcontextMap.put(\"retrieveSource\", context.isRetrieveSource());\n\t\tcontextMap.put(\"cloneDepth\", context.getCloneDepth());\n\t\tcontextMap.put(\"projectName\", context.getProjectName());\n\t\tcontextMap.put(\"cloneInfo\", context.getCloneInfo());\n\t\tcontextMap.put(\"commitHash\", context.getCommitId().name());\n\t\tcontextMap.put(\"collectFiles.includes\", context.getCollectFiles().getIncludes());\n\t\tcontextMap.put(\"collectFiles.excludes\", context.getCollectFiles().getExcludes());\n\t\treturn SerializationUtils.serialize((Serializable) contextMap);\n    }\n\t\n\t@Path(\"/allocate-job-caches\")\n\t@Consumes(MediaType.APPLICATION_OCTET_STREAM)\n\t@Produces(MediaType.APPLICATION_OCTET_STREAM)\n    @POST\n    public byte[] allocateJobCaches(String cacheAllocationRequestString) {\n\t\tCacheAllocationRequest cacheAllocationRequest = CacheAllocationRequest.fromString(cacheAllocationRequestString);\n\t\treturn SerializationUtils.serialize((Serializable) jobManager.allocateJobCaches(\n\t\t\t\tgetJobToken(), cacheAllocationRequest.getCurrentTime(), cacheAllocationRequest.getInstances()));\n    }\n\t\n\t@Path(\"/report-job-caches\")\n\t@Consumes(MediaType.APPLICATION_OCTET_STREAM)\n\t@POST\n\tpublic void reportJobCaches(String cacheInstancesString) {\n\t\tCollection<CacheInstance> cacheInstances = new ArrayList<>();\n\t\tfor (String field: Splitter.on(';').omitEmptyStrings().split(cacheInstancesString))\n\t\t\tcacheInstances.add(CacheInstance.fromString(field));\n\t\tjobManager.reportJobCaches(getJobToken(), cacheInstances);\n\t}\n\t\n\t@Path(\"/download-dependencies\")\n\t@Produces(MediaType.APPLICATION_OCTET_STREAM)\n\t@GET\n\tpublic Response downloadDependencies() {\n\t\tStreamingOutput os = new StreamingOutput() {\n\n\t\t\t@Override\n\t\t   public void write(OutputStream output) throws IOException {\n\t\t\t\tJobContext context = jobManager.getJobContext(getJobToken(), true);\n\t\t\t\tTarUtils.tar(context.getServerWorkspace(), Lists.newArrayList(\"**\"), \n\t\t\t\t\t\tnew ArrayList<>(), output);\n\t\t\t\toutput.flush();\n\t\t   }\t\t\t\t   \n\t\t   \n\t\t};\n\t\treturn Response.ok(os).build();\n\t}\n\t\n\t@POST\n\t@Path(\"/upload-outcomes\")\n\t@Consumes(MediaType.APPLICATION_OCTET_STREAM)\t\n\tpublic Response uploadOutcomes(InputStream is) {\n\t\tJobContext context = jobManager.getJobContext(getJobToken(), true);\n\t\tTarUtils.untar(is, context.getServerWorkspace());\n\t\treturn Response.ok().build();\n\t}\n\t\n\t@GET\n\t@Path(\"/test\")\n\tpublic Response test() {\n\t\tString jobToken = Job.getToken(request);\n\t\tif (TEST_JOB_TOKEN.equals(jobToken))\n\t\t\treturn Response.ok().build();\n\t\telse \n\t\t\treturn Response.status(400).entity(\"Invalid or missing job token\").build();\n\t}\n\t\n\tprivate String getJobToken() {\n\t\tString jobToken = Job.getToken(request);\n\t\tif (jobToken != null)\n\t\t\treturn jobToken;\n\t\telse\n\t\t\tthrow new GeneralException(\"Job token is expected\");\n\t}\n\t\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700239,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "/*\n * Copyright 2016 SimplifyOps, Inc. (http://simplifyops.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n* ScriptFileProviderLoader.java\n* \n* User: Greg Schueler <a href=\"mailto:greg@dtosolutions.com\">greg@dtosolutions.com</a>\n* Created: 4/13/11 10:07 AM\n* \n*/\npackage com.dtolabs.rundeck.core.plugins;\n\nimport com.dtolabs.rundeck.core.common.FrameworkSupportService;\nimport com.dtolabs.rundeck.core.execution.script.ScriptfileUtils;\nimport com.dtolabs.rundeck.core.execution.service.ProviderLoaderException;\nimport com.dtolabs.rundeck.core.plugins.metadata.ProviderDef;\nimport com.dtolabs.rundeck.core.plugins.metadata.PluginMeta;\nimport com.dtolabs.rundeck.core.utils.FileUtils;\nimport com.dtolabs.rundeck.core.utils.ZipUtil;\nimport com.dtolabs.rundeck.core.utils.cache.FileCache;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.yaml.snakeyaml.Yaml;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.dtolabs.rundeck.core.plugins.JarPluginProviderLoader.RESOURCES_DIR_DEFAULT;\n\n/**\n * ScriptPluginProviderLoader can load a provider instance for a service from a script plugin zip file.\n *\n * Services that want to use this loader need to implement {@link ScriptPluginProviderLoadable}\n *\n * @author Greg Schueler <a href=\"mailto:greg@dtosolutions.com\">greg@dtosolutions.com</a>\n */\npublic class ScriptPluginProviderLoader implements ProviderLoader, FileCache.Expireable, PluginResourceLoader, PluginMetadata {\n\n    private static final Logger         log                               = LoggerFactory.getLogger(ScriptPluginProviderLoader.class.getName());\n    public static final  String         VERSION_1_0                       = \"1.0\";\n    public static final  String         VERSION_1_1                       = \"1.1\";\n    public static final  String         VERSION_1_2                       = \"1.2\";\n    public static final  VersionCompare SUPPORTS_RESOURCES_PLUGIN_VERSION = VersionCompare.forString(VERSION_1_2);\n    public static final  String         VERSION_2_0                       = \"2.0\";\n    public static final  List<String>   SUPPORTED_PLUGIN_VERSIONS;\n    static {\n        SUPPORTED_PLUGIN_VERSIONS = Collections.unmodifiableList(Arrays.asList(\n                VERSION_1_0,\n                VERSION_1_1,\n                VERSION_1_2,\n                VERSION_2_0\n        ));\n    }\n    private final File file;\n    final File cachedir;\n    /**\n     * Dir of expanded zip contents\n     */\n    private File fileExpandedDir;\n    /**\n     * Metadata from the plugin.yaml file\n     */\n    private PluginMeta metadata;\n    /**\n     * Metadata from the plugin.yaml file\n     */\n    private PluginResourceLoader resourceLoader;\n    /**\n     * cache of ident to scriptplugin def mapping\n     */\n    private Map<ProviderIdent, ScriptPluginProvider> pluginProviderDefs =\n        new HashMap<ProviderIdent, ScriptPluginProvider>();\n    private List<String> pluginResourcesList;\n\n    public ScriptPluginProviderLoader(final File file, final File cachedir) {\n        this.file = file;\n        this.cachedir = cachedir;\n    }\n\n    @Override\n    public boolean canLoadForService(final FrameworkSupportService service) {\n        return service instanceof ScriptPluginProviderLoadable;\n    }\n\n    private PluginResourceLoader getResourceLoader() throws PluginException {\n        if (null == resourceLoader) {\n            synchronized (this) {\n                if (null == resourceLoader) {\n                    try {\n                        ZipResourceLoader loader = new ZipResourceLoader(\n                                new File(getFileCacheDir(), \"resources\"),\n                                file,\n                                getPluginResourcesList(),\n                                getFileBasename() + \"/\" + getResourcesBasePath()\n                        );\n                        loader.extractResources();\n                        this.resourceLoader = loader;\n                    } catch (IOException e) {\n                        throw new PluginException(\"Unable to expand plugin libs: \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        return resourceLoader;\n    }\n\n    @Override\n    public List<String> listResources() throws PluginException, IOException {\n        if (supportsResources(getPluginMeta())) {\n            return getResourceLoader().listResources();\n        }\n        return null;\n    }\n\n    @Override\n    public InputStream openResourceStreamFor(final String name) throws PluginException, IOException {\n        if (supportsResources(getPluginMeta())) {\n            return getResourceLoader().openResourceStreamFor(name);\n        }\n        return null;\n    }\n\n    /**\n     * Load a provider instance for the service by name\n     */\n    public synchronized <T> T load(final PluggableService<T> service, final String providerName) throws\n        ProviderLoaderException {\n        if (!(service instanceof ScriptPluginProviderLoadable)) {\n            return null;\n        }\n        ScriptPluginProviderLoadable<T> loader =(ScriptPluginProviderLoadable<T>) service;\n        final ProviderIdent ident = new ProviderIdent(service.getName(), providerName);\n\n        if (null == pluginProviderDefs.get(ident)) {\n            //look for plugin def\n            final PluginMeta pluginMeta;\n            try {\n                pluginMeta = getPluginMeta();\n            } catch (IOException e) {\n                throw new ProviderLoaderException(e, service.getName(), providerName);\n            }\n            if (null == pluginMeta) {\n                throw new ProviderLoaderException(\"Unable to load plugin metadata for file: \" + file, service.getName(),\n                    providerName);\n            }\n            for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n                if (matchesProvider(ident, pluginDef)) {\n                    final ScriptPluginProvider provider;\n                    try {\n                        provider = getPlugin(pluginMeta, file, pluginDef, ident);\n                    } catch (PluginException e) {\n                        throw new ProviderLoaderException(e, service.getName(), providerName);\n                    }\n                    pluginProviderDefs.put(ident, provider);\n                    break;\n                }\n            }\n        }\n        final ScriptPluginProvider scriptPluginProvider = pluginProviderDefs.get(ident);\n\n        try {\n            getResourceLoader().listResources();\n        } catch(IOException iex) {\n            throw new ProviderLoaderException(iex,service.getName(),providerName);\n        }\n        catch (PluginException e) {\n            throw new ProviderLoaderException(e, service.getName(), providerName);\n        }\n        if (null != scriptPluginProvider) {\n            try {\n                return loader.createScriptProviderInstance(scriptPluginProvider);\n            } catch (PluginException e) {\n                throw new ProviderLoaderException(e, service.getName(), providerName);\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public <T> CloseableProvider<T> loadCloseable(final PluggableService<T> service, final String providerName)\n            throws ProviderLoaderException\n    {\n        final T load = load(service, providerName);\n        if (null == load) {\n            return null;\n        }\n        return Closeables.closeableProvider(load);\n    }\n\n    private Date dateLoaded = null;\n\n    /**\n     * Get the plugin metadata, loading from the file if necessary\n     *\n     * @return loaded metadata or null if not found\n     *\n     * @throws IOException if an error occurs trying to load from the file\n     */\n    private PluginMeta getPluginMeta() throws IOException {\n        if (null != metadata) {\n            return metadata;\n        }\n        metadata = loadMeta(file);\n        metadata.setId(PluginUtils.generateShaIdFromName(metadata.getName()));\n        dateLoaded = new Date();\n        return metadata;\n    }\n\n    /**\n     * Get the ScriptPluginProvider definition from the file for the given provider def and ident\n     */\n    private ScriptPluginProvider getPlugin(\n            final PluginMeta pluginMeta,\n            final File file,\n            final ProviderDef pluginDef,\n            final ProviderIdent ident\n    ) throws\n            ProviderLoaderException, PluginException\n    {\n        if (null == fileExpandedDir) {\n            final File dir;\n            try {\n                dir = expandScriptPlugin(file);\n            } catch (IOException e) {\n                throw new ProviderLoaderException(e, ident.getService(), ident.getProviderName());\n            }\n            fileExpandedDir = dir;\n            if (pluginDef.getPluginType().equals(\"script\")) {\n\n                final File script = new File(fileExpandedDir, pluginDef.getScriptFile());\n                //set executable bit for script-file of the provider\n                try {\n                    ScriptfileUtils.setExecutePermissions(script);\n                } catch (IOException e) {\n                    log.warn(\"Unable to set executable bit for script file: \" + script + \": \" + e.getMessage());\n                }\n            }\n            debug(\"expanded plugin dir! \" + fileExpandedDir);\n        } else {\n            debug(\"expanded plugin dir: \" + fileExpandedDir);\n        }\n        if (pluginDef.getPluginType().equals(\"script\")) {\n            final File script = new File(fileExpandedDir, pluginDef.getScriptFile());\n            if (!script.exists() || !script.isFile()) {\n                throw new PluginException(\"Script file was not found: \" + script.getAbsolutePath());\n            }\n        }\n        return new ScriptPluginProviderImpl(pluginMeta, pluginDef, file, fileExpandedDir);\n    }\n\n    /**\n     * Return true if the ident matches the provider def metadata\n     */\n    private boolean matchesProvider(final ProviderIdent ident, final ProviderDef pluginDef) {\n        return ident.getService().equals(pluginDef.getService()) && ident.getProviderName().equals(pluginDef.getName());\n    }\n\n    /**\n     * Return true if the plugin file can loade a provider for the ident\n     */\n    public synchronized boolean isLoaderFor(final ProviderIdent ident) {\n\n        final PluginMeta pluginMeta;\n        try {\n            pluginMeta = getPluginMeta();\n        } catch (IOException e) {\n            log.warn(\"Unable to load file meta: \" + e.getMessage());\n            return false;\n        }\n        if (null == pluginMeta) {\n            return false;\n        }\n        for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n            if (matchesProvider(ident, pluginDef)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public List<ProviderIdent> listProviders() {\n        final ArrayList<ProviderIdent> providerIdents = new ArrayList<ProviderIdent>();\n        PluginMeta pluginMeta=null;\n        try {\n            pluginMeta = getPluginMeta();\n        } catch (IOException e) {\n            debug(\"Unable to load file meta: \" + e.getMessage());\n        }\n        if (null == pluginMeta) {\n            return providerIdents;\n        }\n        for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n            providerIdents.add(new ProviderIdent(pluginDef.getService(), pluginDef.getName()));\n        }\n        return providerIdents;\n    }\n\n\n    /**\n     * Get plugin metadatat from a zip file\n     */\n    static PluginMeta loadMeta(final File jar) throws IOException {\n        FileInputStream fileInputStream = new FileInputStream(jar);\n        try{\n            final ZipInputStream zipinput = new ZipInputStream(fileInputStream);\n            final PluginMeta metadata = ScriptPluginProviderLoader.loadMeta(jar, zipinput);\n            return metadata;\n        }finally {\n            fileInputStream.close();\n        }\n    }\n\n    /**\n     * Load plugin metadata for a file and zip inputstream\n     * @param jar the file\n     * @param zipinput zip input stream\n     * @return loaded metadata, or null if it is invalid or not found\n     */\n    static PluginMeta loadMeta(final File jar, final ZipInputStream zipinput) throws IOException {\n        final String basename = basename(jar);\n        PluginMeta metadata = null;\n        boolean topfound = false;\n        boolean found = false;\n        boolean dirfound = false;\n        boolean resfound = false;\n        ZipEntry nextEntry = zipinput.getNextEntry();\n        Set<String> paths = new HashSet<>();\n        while (null != nextEntry) {\n            paths.add(nextEntry.getName());\n\n            if (!found && !nextEntry.isDirectory() && nextEntry.getName().equals(basename + \"/plugin.yaml\")) {\n//                debug(\"Found metadata: \" + nextEntry.getName());\n                try {\n                    metadata = loadMetadataYaml(zipinput);\n                    found = true;\n                } catch (Throwable e) {\n                    log.error(\"Error parsing metadata file plugin.yaml: \" + e.getMessage(), e);\n                }\n            }\n            nextEntry = zipinput.getNextEntry();\n        }\n        if (!found || metadata == null) {\n            log.error(\"Plugin not loaded: Found no \" + basename + \"/plugin.yaml within: \" + jar.getAbsolutePath());\n        }\n        String resdir = null != metadata ? getResourcesBasePath(metadata) : null;\n\n        for (String path : paths) {\n            if (!topfound && path.startsWith(basename + \"/\")) {\n                topfound = true;\n            }\n            if (!dirfound && (path.startsWith(basename + \"/contents/\") || path.equals(basename + \"/contents\"))) {\n                dirfound = true;\n            }\n            if (!resfound\n                && resdir != null\n                && (path.startsWith(basename + \"/\" + resdir + \"/\") || path.equals(basename + \"/\" + resdir))) {\n                resfound = true;\n            }\n        }\n        if (!topfound) {\n            log.error(\"Plugin not loaded: Found no \" + basename + \"/ dir within file: \" + jar.getAbsolutePath());\n        }\n        if (!dirfound && !resfound) {\n            log.error(\"Plugin not loaded: Found no \" +\n                      basename +\n                      \"/contents or \" +\n                      basename +\n                      \"/\" + resdir + \" dir within: \" +\n                      jar.getAbsolutePath());\n        }\n        if (found && (dirfound || resfound)) {\n            return metadata;\n        }\n        return null;\n    }\n\n    /**\n     * return loaded yaml plugin metadata from the stream\n     */\n    static PluginMeta loadMetadataYaml(final InputStream stream) {\n        final Yaml yaml = new Yaml();\n\n        return yaml.loadAs(stream, PluginMeta.class);\n    }\n\n    /**\n     * Return true if loaded metadata about the plugin file is valid.\n     */\n    static PluginValidation validatePluginMeta(final PluginMeta pluginList, final File file) {\n        PluginValidation.State state = PluginValidation.State.VALID;\n        if (pluginList == null) {\n            return PluginValidation.builder()\n                                   .message(\"No metadata\")\n                                   .state(PluginValidation.State.INVALID)\n                                   .build();\n        }\n        List<String> messages = new ArrayList<>();\n        if (null == pluginList.getName()) {\n            messages.add(\"'name' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        }\n        if (null == pluginList.getVersion()) {\n            messages.add(\"'version' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        }\n        if (null == pluginList.getRundeckPluginVersion()) {\n            messages.add(\"'rundeckPluginVersion' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        } else if (!SUPPORTED_PLUGIN_VERSIONS.contains(pluginList.getRundeckPluginVersion())) {\n            messages.add(\"'rundeckPluginVersion': \\\"\" + pluginList.getRundeckPluginVersion() + \"\\\" is not supported\");\n            state = PluginValidation.State.INVALID;\n        }\n        if(pluginList.getRundeckPluginVersion().equals(VERSION_2_0)) {\n            List<String> validationErrors = new ArrayList<>();\n\n            PluginValidation.State\n                hostCompatState =\n                PluginMetadataValidator.validateTargetHostCompatibility(\n                    validationErrors,\n                    pluginList.getTargetHostCompatibility()\n                );\n            PluginValidation.State\n                versCompatState = PluginMetadataValidator.validateRundeckCompatibility(\n                validationErrors,\n                pluginList.getRundeckCompatibilityVersion()\n            );\n\n            messages.addAll(validationErrors);\n            state = state.or(hostCompatState)\n                         .or(versCompatState);\n\n        }\n        final List<ProviderDef> pluginDefs = pluginList.getPluginDefs();\n        for (final ProviderDef pluginDef : pluginDefs) {\n            try {\n                validateProviderDef(pluginDef);\n            } catch (PluginException e) {\n                messages.add(e.getMessage());\n                state = PluginValidation.State.INVALID;\n            }\n        }\n        return PluginValidation.builder()\n                               .state(state)\n                               .messages(messages)\n                               .build();\n    }\n\n    /**\n     * Expand zip file into plugin cache dir\n     *\n     * @param file zip file\n     *\n     * @return cache dir for the contents of the plugin zip\n     */\n    private File expandScriptPlugin(final File file) throws IOException {\n        if (!cachedir.exists()) {\n            if (!cachedir.mkdirs()) {\n                log.warn(\"Unable to create cache dir: \" + cachedir.getAbsolutePath());\n            }\n        }\n        final File jardir = getFileCacheDir();\n        if (!jardir.exists()) {\n            if (!jardir.mkdir()) {\n                log.warn(\"Unable to create cache dir for plugin: \" + jardir.getAbsolutePath());\n            }\n        }\n        final String prefix = getFileBasename() + \"/contents\";\n\n        debug(\"Expand zip \" + file.getAbsolutePath() + \" to dir: \" + jardir + \", prefix: \" + prefix);\n        ZipUtil.extractZip(file.getAbsolutePath(), jardir, prefix, prefix + \"/\");\n\n        return jardir;\n    }\n\n    /**\n     * Remove any cache dir for the file\n     */\n    private synchronized boolean removeScriptPluginCache() {\n        if (null != fileExpandedDir && fileExpandedDir.exists()) {\n            debug(\"removeScriptPluginCache: \" + fileExpandedDir);\n            return FileUtils.deleteDir(fileExpandedDir);\n        }\n        return true;\n    }\n\n    /**\n     * Basename of the file\n     */\n    String getFileBasename() {\n        return basename(file);\n    }\n\n    /**\n     * Get basename of a file\n     */\n    private static String basename(final File file) {\n        final String name = file.getName();\n        if(name.contains(\".\")) {\n            return name.substring(0, name.lastIndexOf(\".\"));\n        }\n        return name;\n    }\n\n    /**\n     * Get the cache dir for use for this file\n     */\n    File getFileCacheDir() {\n        return new File(cachedir, getFileBasename());\n    }\n\n\n    /**\n     * Validate provider def\n     */\n    private static void validateProviderDef(final ProviderDef pluginDef) throws PluginException {\n\n        if (null == pluginDef.getPluginType() || \"\".equals(pluginDef.getPluginType())) {\n            throw new PluginException(\"Script plugin missing plugin-type\");\n        }\n        if (\"script\".equals(pluginDef.getPluginType())) {\n            validateScriptProviderDef(pluginDef);\n        } else if (\"ui\".equals(pluginDef.getPluginType())) {\n            validateUIProviderDef(pluginDef);\n        } else {\n            throw new PluginException(\"Script plugin has invalid plugin-type: \" + pluginDef.getPluginType());\n        }\n    }\n\n    /**\n     * Validate script provider def\n     */\n    private static void validateScriptProviderDef(final ProviderDef pluginDef) throws PluginException {\n        if (null == pluginDef.getName() || \"\".equals(pluginDef.getName())) {\n            throw new PluginException(\"Script plugin missing name\");\n        }\n        if (null == pluginDef.getService() || \"\".equals(pluginDef.getService())) {\n            throw new PluginException(\"Script plugin missing service\");\n        }\n        if (null == pluginDef.getScriptFile() || \"\".equals(pluginDef.getScriptFile())) {\n            throw new PluginException(\"Script plugin missing script-file\");\n        }\n\n        //make sure service is pluggable service and is script pluggable\n        /* final FrameworkSupportService service = framework.getService(pluginDef.getService());\n        if (!(service instanceof PluggableService)) {\n            throw new PluginException(\n                \"Service '\" + pluginDef.getService() + \"' specified for script plugin '\" + pluginDef.getName()\n                + \"' is not valid: unsupported\");\n        }\n        final PluggableService pservice = (PluggableService) service;\n        if (!pservice.isScriptPluggable()) {\n            throw new PluginException(\n                \"Service '\" + pluginDef.getService() + \"' specified for script plugin '\" + pluginDef.getName()\n                + \"' is not valid: unsupported\");\n        }*/\n    }\n\n    /**\n     * Validate script provider def\n     */\n    private static void validateUIProviderDef(final ProviderDef pluginDef) throws PluginException {\n        if (null == pluginDef.getName() || \"\".equals(pluginDef.getName())) {\n            throw new PluginException(\"UI plugin missing name\");\n        }\n        if (null == pluginDef.getService() || \"\".equals(pluginDef.getService())) {\n            throw new PluginException(\"UI plugin missing service\");\n        }\n        if (null == pluginDef.getPluginData() || null == pluginDef.getPluginData().get(\"ui\")) {\n            throw new PluginException(\"UI plugin missing ui: definition\");\n        }\n\n    }\n\n    private static void debug(final String msg) {\n        if (log.isDebugEnabled()) {\n            log.debug(msg);\n        }\n    }\n\n    /**\n     * Expire the loader cache item\n     */\n    public void expire() {\n        removeScriptPluginCache();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        ScriptPluginProviderLoader that = (ScriptPluginProviderLoader) o;\n\n        if (cachedir != null ? !cachedir.equals(that.cachedir) : that.cachedir != null) {\n            return false;\n        }\n        if (file != null ? !file.equals(that.file) : that.file != null) {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = file != null ? file.hashCode() : 0;\n        result = 31 * result + (cachedir != null ? cachedir.hashCode() : 0);\n        return result;\n    }\n\n\n    /**\n     * Return the version string metadata value for the plugin file, or null if it is not available or could not\n     * loaded\n     * @param file file\n     * @return version string\n     */\n    static String getVersionForFile(final File file)  {\n        try {\n            final PluginMeta pluginMeta = loadMeta(file);\n            return pluginMeta.getVersion();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return default value for \"mergeEnvironment\" based on plugin type version\n     * @param pluginMeta\n     * @return\n     */\n    public static boolean getDefaultMergeEnvVars(final PluginMeta pluginMeta) {\n        if (VERSION_1_0.equals(pluginMeta.getRundeckPluginVersion())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Return true if the plugin version supports resources\n     *\n     * @param pluginMeta\n     *\n     * @return\n     */\n    public static boolean supportsResources(final PluginMeta pluginMeta) {\n        return VersionCompare.forString(pluginMeta.getRundeckPluginVersion()).atLeast(SUPPORTS_RESOURCES_PLUGIN_VERSION);\n    }\n\n    public List<String> getPluginResourcesList() throws IOException {\n        return getPluginMeta().getResourcesList();\n    }\n\n    public String getResourcesBasePath() throws IOException {\n        return getResourcesBasePath(getPluginMeta());\n    }\n\n    public static String getResourcesBasePath(PluginMeta metadata) throws IOException {\n        String resourcesDir = metadata.getResourcesDir();\n        return null != resourcesDir ? resourcesDir : RESOURCES_DIR_DEFAULT;\n    }\n\n    @Override\n    public String getFilename() {\n        return file.getName();\n    }\n\n    @Override\n    public File getFile() {\n        return file;\n    }\n\n    @Override\n    public String getPluginArtifactName() {\n        try {\n            return getPluginMeta().getName();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginAuthor() {\n        try {\n            return getPluginMeta().getAuthor();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginFileVersion() {\n        try {\n            return getPluginMeta().getVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginVersion() {\n        try {\n            return getPluginMeta().getRundeckPluginVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginUrl() {\n        try {\n            return getPluginMeta().getUrl();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public Date getPluginDate() {\n        try {\n            String date = getPluginMeta().getDate();\n            return new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssX\").parse(date);\n        } catch (IOException | NullPointerException | ParseException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public Date getDateLoaded() {\n        return dateLoaded;\n    }\n\n    @Override\n    public String getPluginName() {\n        try {\n            return getPluginMeta().getName();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginDescription() {\n        try {\n            return getPluginMeta().getDescription();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginId() {\n        try {\n            return getPluginMeta().getId();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getRundeckCompatibilityVersion() {\n        try {\n            return getPluginMeta().getRundeckCompatibilityVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getTargetHostCompatibility() {\n        try {\n            return getPluginMeta().getTargetHostCompatibility();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public List<String> getTags() {\n        try {\n            return getPluginMeta().getTags();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginLicense() {\n        try {\n            return getPluginMeta().getLicense();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginThirdPartyDependencies() {\n        try {\n            return getPluginMeta().getThirdPartyDependencies();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginSourceLink() {\n        try {\n            return getPluginMeta().getSourceLink();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginDocsLink() {\n        try {\n            return getPluginMeta().getDocsLink();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginType() {\n        return \"script\";\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700292,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "/*\n * Copyright 2016 SimplifyOps, Inc. (http://simplifyops.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n* ScriptFileProviderLoader.java\n*\n* User: Greg Schueler <a href=\"mailto:greg@dtosolutions.com\">greg@dtosolutions.com</a>\n* Created: 4/13/11 10:07 AM\n*\n*/\npackage com.dtolabs.rundeck.core.plugins;\n\nimport com.dtolabs.rundeck.core.common.FrameworkSupportService;\nimport com.dtolabs.rundeck.core.execution.script.ScriptfileUtils;\nimport com.dtolabs.rundeck.core.execution.service.ProviderLoaderException;\nimport com.dtolabs.rundeck.core.plugins.metadata.ProviderDef;\nimport com.dtolabs.rundeck.core.plugins.metadata.PluginMeta;\nimport com.dtolabs.rundeck.core.utils.FileUtils;\nimport com.dtolabs.rundeck.core.utils.ZipUtil;\nimport com.dtolabs.rundeck.core.utils.cache.FileCache;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.yaml.snakeyaml.Yaml;\nimport org.yaml.snakeyaml.constructor.Constructor;\nimport org.yaml.snakeyaml.nodes.Tag;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.dtolabs.rundeck.core.plugins.JarPluginProviderLoader.RESOURCES_DIR_DEFAULT;\n\n/**\n * ScriptPluginProviderLoader can load a provider instance for a service from a script plugin zip file.\n *\n * Services that want to use this loader need to implement {@link ScriptPluginProviderLoadable}\n *\n * @author Greg Schueler <a href=\"mailto:greg@dtosolutions.com\">greg@dtosolutions.com</a>\n */\npublic class ScriptPluginProviderLoader implements ProviderLoader, FileCache.Expireable, PluginResourceLoader, PluginMetadata {\n\n    private static final Logger         log                               = LoggerFactory.getLogger(ScriptPluginProviderLoader.class.getName());\n    public static final  String         VERSION_1_0                       = \"1.0\";\n    public static final  String         VERSION_1_1                       = \"1.1\";\n    public static final  String         VERSION_1_2                       = \"1.2\";\n    public static final  VersionCompare SUPPORTS_RESOURCES_PLUGIN_VERSION = VersionCompare.forString(VERSION_1_2);\n    public static final  String         VERSION_2_0                       = \"2.0\";\n    public static final  List<String>   SUPPORTED_PLUGIN_VERSIONS;\n    static {\n        SUPPORTED_PLUGIN_VERSIONS = Collections.unmodifiableList(Arrays.asList(\n                VERSION_1_0,\n                VERSION_1_1,\n                VERSION_1_2,\n                VERSION_2_0\n        ));\n    }\n    private final File file;\n    final File cachedir;\n    /**\n     * Dir of expanded zip contents\n     */\n    private File fileExpandedDir;\n    /**\n     * Metadata from the plugin.yaml file\n     */\n    private PluginMeta metadata;\n    /**\n     * Metadata from the plugin.yaml file\n     */\n    private PluginResourceLoader resourceLoader;\n    /**\n     * cache of ident to scriptplugin def mapping\n     */\n    private Map<ProviderIdent, ScriptPluginProvider> pluginProviderDefs =\n        new HashMap<ProviderIdent, ScriptPluginProvider>();\n    private List<String> pluginResourcesList;\n\n    public ScriptPluginProviderLoader(final File file, final File cachedir) {\n        this.file = file;\n        this.cachedir = cachedir;\n    }\n\n    @Override\n    public boolean canLoadForService(final FrameworkSupportService service) {\n        return service instanceof ScriptPluginProviderLoadable;\n    }\n\n    private PluginResourceLoader getResourceLoader() throws PluginException {\n        if (null == resourceLoader) {\n            synchronized (this) {\n                if (null == resourceLoader) {\n                    try {\n                        ZipResourceLoader loader = new ZipResourceLoader(\n                                new File(getFileCacheDir(), \"resources\"),\n                                file,\n                                getPluginResourcesList(),\n                                getFileBasename() + \"/\" + getResourcesBasePath()\n                        );\n                        loader.extractResources();\n                        this.resourceLoader = loader;\n                    } catch (IOException e) {\n                        throw new PluginException(\"Unable to expand plugin libs: \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        return resourceLoader;\n    }\n\n    @Override\n    public List<String> listResources() throws PluginException, IOException {\n        if (supportsResources(getPluginMeta())) {\n            return getResourceLoader().listResources();\n        }\n        return null;\n    }\n\n    @Override\n    public InputStream openResourceStreamFor(final String name) throws PluginException, IOException {\n        if (supportsResources(getPluginMeta())) {\n            return getResourceLoader().openResourceStreamFor(name);\n        }\n        return null;\n    }\n\n    /**\n     * Load a provider instance for the service by name\n     */\n    public synchronized <T> T load(final PluggableService<T> service, final String providerName) throws\n        ProviderLoaderException {\n        if (!(service instanceof ScriptPluginProviderLoadable)) {\n            return null;\n        }\n        ScriptPluginProviderLoadable<T> loader =(ScriptPluginProviderLoadable<T>) service;\n        final ProviderIdent ident = new ProviderIdent(service.getName(), providerName);\n\n        if (null == pluginProviderDefs.get(ident)) {\n            //look for plugin def\n            final PluginMeta pluginMeta;\n            try {\n                pluginMeta = getPluginMeta();\n            } catch (IOException e) {\n                throw new ProviderLoaderException(e, service.getName(), providerName);\n            }\n            if (null == pluginMeta) {\n                throw new ProviderLoaderException(\"Unable to load plugin metadata for file: \" + file, service.getName(),\n                    providerName);\n            }\n            for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n                if (matchesProvider(ident, pluginDef)) {\n                    final ScriptPluginProvider provider;\n                    try {\n                        provider = getPlugin(pluginMeta, file, pluginDef, ident);\n                    } catch (PluginException e) {\n                        throw new ProviderLoaderException(e, service.getName(), providerName);\n                    }\n                    pluginProviderDefs.put(ident, provider);\n                    break;\n                }\n            }\n        }\n        final ScriptPluginProvider scriptPluginProvider = pluginProviderDefs.get(ident);\n\n        try {\n            getResourceLoader().listResources();\n        } catch(IOException iex) {\n            throw new ProviderLoaderException(iex,service.getName(),providerName);\n        }\n        catch (PluginException e) {\n            throw new ProviderLoaderException(e, service.getName(), providerName);\n        }\n        if (null != scriptPluginProvider) {\n            try {\n                return loader.createScriptProviderInstance(scriptPluginProvider);\n            } catch (PluginException e) {\n                throw new ProviderLoaderException(e, service.getName(), providerName);\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public <T> CloseableProvider<T> loadCloseable(final PluggableService<T> service, final String providerName)\n            throws ProviderLoaderException\n    {\n        final T load = load(service, providerName);\n        if (null == load) {\n            return null;\n        }\n        return Closeables.closeableProvider(load);\n    }\n\n    private Date dateLoaded = null;\n\n    /**\n     * Get the plugin metadata, loading from the file if necessary\n     *\n     * @return loaded metadata or null if not found\n     *\n     * @throws IOException if an error occurs trying to load from the file\n     */\n    private PluginMeta getPluginMeta() throws IOException {\n        if (null != metadata) {\n            return metadata;\n        }\n        metadata = loadMeta(file);\n        metadata.setId(PluginUtils.generateShaIdFromName(metadata.getName()));\n        dateLoaded = new Date();\n        return metadata;\n    }\n\n    /**\n     * Get the ScriptPluginProvider definition from the file for the given provider def and ident\n     */\n    private ScriptPluginProvider getPlugin(\n            final PluginMeta pluginMeta,\n            final File file,\n            final ProviderDef pluginDef,\n            final ProviderIdent ident\n    ) throws\n            ProviderLoaderException, PluginException\n    {\n        if (null == fileExpandedDir) {\n            final File dir;\n            try {\n                dir = expandScriptPlugin(file);\n            } catch (IOException e) {\n                throw new ProviderLoaderException(e, ident.getService(), ident.getProviderName());\n            }\n            fileExpandedDir = dir;\n            if (pluginDef.getPluginType().equals(\"script\")) {\n\n                final File script = new File(fileExpandedDir, pluginDef.getScriptFile());\n                //set executable bit for script-file of the provider\n                try {\n                    ScriptfileUtils.setExecutePermissions(script);\n                } catch (IOException e) {\n                    log.warn(\"Unable to set executable bit for script file: \" + script + \": \" + e.getMessage());\n                }\n            }\n            debug(\"expanded plugin dir! \" + fileExpandedDir);\n        } else {\n            debug(\"expanded plugin dir: \" + fileExpandedDir);\n        }\n        if (pluginDef.getPluginType().equals(\"script\")) {\n            final File script = new File(fileExpandedDir, pluginDef.getScriptFile());\n            if (!script.exists() || !script.isFile()) {\n                throw new PluginException(\"Script file was not found: \" + script.getAbsolutePath());\n            }\n        }\n        return new ScriptPluginProviderImpl(pluginMeta, pluginDef, file, fileExpandedDir);\n    }\n\n    /**\n     * Return true if the ident matches the provider def metadata\n     */\n    private boolean matchesProvider(final ProviderIdent ident, final ProviderDef pluginDef) {\n        return ident.getService().equals(pluginDef.getService()) && ident.getProviderName().equals(pluginDef.getName());\n    }\n\n    /**\n     * Return true if the plugin file can loade a provider for the ident\n     */\n    public synchronized boolean isLoaderFor(final ProviderIdent ident) {\n\n        final PluginMeta pluginMeta;\n        try {\n            pluginMeta = getPluginMeta();\n        } catch (IOException e) {\n            log.warn(\"Unable to load file meta: \" + e.getMessage());\n            return false;\n        }\n        if (null == pluginMeta) {\n            return false;\n        }\n        for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n            if (matchesProvider(ident, pluginDef)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public List<ProviderIdent> listProviders() {\n        final ArrayList<ProviderIdent> providerIdents = new ArrayList<ProviderIdent>();\n        PluginMeta pluginMeta=null;\n        try {\n            pluginMeta = getPluginMeta();\n        } catch (IOException e) {\n            debug(\"Unable to load file meta: \" + e.getMessage());\n        }\n        if (null == pluginMeta) {\n            return providerIdents;\n        }\n        for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n            providerIdents.add(new ProviderIdent(pluginDef.getService(), pluginDef.getName()));\n        }\n        return providerIdents;\n    }\n\n\n    /**\n     * Get plugin metadatat from a zip file\n     */\n    static PluginMeta loadMeta(final File jar) throws IOException {\n        FileInputStream fileInputStream = new FileInputStream(jar);\n        try{\n            final ZipInputStream zipinput = new ZipInputStream(fileInputStream);\n            final PluginMeta metadata = ScriptPluginProviderLoader.loadMeta(jar, zipinput);\n            return metadata;\n        }finally {\n            fileInputStream.close();\n        }\n    }\n\n    /**\n     * Load plugin metadata for a file and zip inputstream\n     * @param jar the file\n     * @param zipinput zip input stream\n     * @return loaded metadata, or null if it is invalid or not found\n     */\n    static PluginMeta loadMeta(final File jar, final ZipInputStream zipinput) throws IOException {\n        final String basename = basename(jar);\n        PluginMeta metadata = null;\n        boolean topfound = false;\n        boolean found = false;\n        boolean dirfound = false;\n        boolean resfound = false;\n        ZipEntry nextEntry = zipinput.getNextEntry();\n        Set<String> paths = new HashSet<>();\n        while (null != nextEntry) {\n            paths.add(nextEntry.getName());\n\n            if (!found && !nextEntry.isDirectory() && nextEntry.getName().equals(basename + \"/plugin.yaml\")) {\n//                debug(\"Found metadata: \" + nextEntry.getName());\n                try {\n                    metadata = loadMetadataYaml(zipinput);\n                    found = true;\n                } catch (Throwable e) {\n                    log.error(\"Error parsing metadata file plugin.yaml: \" + e.getMessage(), e);\n                }\n            }\n            nextEntry = zipinput.getNextEntry();\n        }\n        if (!found || metadata == null) {\n            log.error(\"Plugin not loaded: Found no \" + basename + \"/plugin.yaml within: \" + jar.getAbsolutePath());\n        }\n        String resdir = null != metadata ? getResourcesBasePath(metadata) : null;\n\n        for (String path : paths) {\n            if (!topfound && path.startsWith(basename + \"/\")) {\n                topfound = true;\n            }\n            if (!dirfound && (path.startsWith(basename + \"/contents/\") || path.equals(basename + \"/contents\"))) {\n                dirfound = true;\n            }\n            if (!resfound\n                && resdir != null\n                && (path.startsWith(basename + \"/\" + resdir + \"/\") || path.equals(basename + \"/\" + resdir))) {\n                resfound = true;\n            }\n        }\n        if (!topfound) {\n            log.error(\"Plugin not loaded: Found no \" + basename + \"/ dir within file: \" + jar.getAbsolutePath());\n        }\n        if (!dirfound && !resfound) {\n            log.error(\"Plugin not loaded: Found no \" +\n                      basename +\n                      \"/contents or \" +\n                      basename +\n                      \"/\" + resdir + \" dir within: \" +\n                      jar.getAbsolutePath());\n        }\n        if (found && (dirfound || resfound)) {\n            return metadata;\n        }\n        return null;\n    }\n\n    /**\n     * define only constructor for single type\n     */\n    static class SingleTypeConstructor extends Constructor{\n        public SingleTypeConstructor(Class<?> clazz) {\n            super(clazz);\n            this.yamlConstructors.put(null, undefinedConstructor);\n            this.yamlConstructors.put(new Tag(clazz), new SubtypeConstructYamlObject());\n        }\n        //required because ConstructYamlObject is protected\n        class SubtypeConstructYamlObject extends ConstructYamlObject{\n\n        }\n    }\n    /**\n     * return loaded yaml plugin metadata from the stream\n     */\n    static PluginMeta loadMetadataYaml(final InputStream stream) {\n        final Yaml yaml = new Yaml(new SingleTypeConstructor(PluginMeta.class));\n        return yaml.loadAs(stream, PluginMeta.class);\n    }\n\n    /**\n     * Return true if loaded metadata about the plugin file is valid.\n     */\n    static PluginValidation validatePluginMeta(final PluginMeta pluginList, final File file) {\n        PluginValidation.State state = PluginValidation.State.VALID;\n        if (pluginList == null) {\n            return PluginValidation.builder()\n                                   .message(\"No metadata\")\n                                   .state(PluginValidation.State.INVALID)\n                                   .build();\n        }\n        List<String> messages = new ArrayList<>();\n        if (null == pluginList.getName()) {\n            messages.add(\"'name' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        }\n        if (null == pluginList.getVersion()) {\n            messages.add(\"'version' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        }\n        if (null == pluginList.getRundeckPluginVersion()) {\n            messages.add(\"'rundeckPluginVersion' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        } else if (!SUPPORTED_PLUGIN_VERSIONS.contains(pluginList.getRundeckPluginVersion())) {\n            messages.add(\"'rundeckPluginVersion': \\\"\" + pluginList.getRundeckPluginVersion() + \"\\\" is not supported\");\n            state = PluginValidation.State.INVALID;\n        }\n        if(pluginList.getRundeckPluginVersion().equals(VERSION_2_0)) {\n            List<String> validationErrors = new ArrayList<>();\n\n            PluginValidation.State\n                hostCompatState =\n                PluginMetadataValidator.validateTargetHostCompatibility(\n                    validationErrors,\n                    pluginList.getTargetHostCompatibility()\n                );\n            PluginValidation.State\n                versCompatState = PluginMetadataValidator.validateRundeckCompatibility(\n                validationErrors,\n                pluginList.getRundeckCompatibilityVersion()\n            );\n\n            messages.addAll(validationErrors);\n            state = state.or(hostCompatState)\n                         .or(versCompatState);\n\n        }\n        final List<ProviderDef> pluginDefs = pluginList.getPluginDefs();\n        for (final ProviderDef pluginDef : pluginDefs) {\n            try {\n                validateProviderDef(pluginDef);\n            } catch (PluginException e) {\n                messages.add(e.getMessage());\n                state = PluginValidation.State.INVALID;\n            }\n        }\n        return PluginValidation.builder()\n                               .state(state)\n                               .messages(messages)\n                               .build();\n    }\n\n    /**\n     * Expand zip file into plugin cache dir\n     *\n     * @param file zip file\n     *\n     * @return cache dir for the contents of the plugin zip\n     */\n    private File expandScriptPlugin(final File file) throws IOException {\n        if (!cachedir.exists()) {\n            if (!cachedir.mkdirs()) {\n                log.warn(\"Unable to create cache dir: \" + cachedir.getAbsolutePath());\n            }\n        }\n        final File jardir = getFileCacheDir();\n        if (!jardir.exists()) {\n            if (!jardir.mkdir()) {\n                log.warn(\"Unable to create cache dir for plugin: \" + jardir.getAbsolutePath());\n            }\n        }\n        final String prefix = getFileBasename() + \"/contents\";\n\n        debug(\"Expand zip \" + file.getAbsolutePath() + \" to dir: \" + jardir + \", prefix: \" + prefix);\n        ZipUtil.extractZip(file.getAbsolutePath(), jardir, prefix, prefix + \"/\");\n\n        return jardir;\n    }\n\n    /**\n     * Remove any cache dir for the file\n     */\n    private synchronized boolean removeScriptPluginCache() {\n        if (null != fileExpandedDir && fileExpandedDir.exists()) {\n            debug(\"removeScriptPluginCache: \" + fileExpandedDir);\n            return FileUtils.deleteDir(fileExpandedDir);\n        }\n        return true;\n    }\n\n    /**\n     * Basename of the file\n     */\n    String getFileBasename() {\n        return basename(file);\n    }\n\n    /**\n     * Get basename of a file\n     */\n    private static String basename(final File file) {\n        final String name = file.getName();\n        if(name.contains(\".\")) {\n            return name.substring(0, name.lastIndexOf(\".\"));\n        }\n        return name;\n    }\n\n    /**\n     * Get the cache dir for use for this file\n     */\n    File getFileCacheDir() {\n        return new File(cachedir, getFileBasename());\n    }\n\n\n    /**\n     * Validate provider def\n     */\n    private static void validateProviderDef(final ProviderDef pluginDef) throws PluginException {\n\n        if (null == pluginDef.getPluginType() || \"\".equals(pluginDef.getPluginType())) {\n            throw new PluginException(\"Script plugin missing plugin-type\");\n        }\n        if (\"script\".equals(pluginDef.getPluginType())) {\n            validateScriptProviderDef(pluginDef);\n        } else if (\"ui\".equals(pluginDef.getPluginType())) {\n            validateUIProviderDef(pluginDef);\n        } else {\n            throw new PluginException(\"Script plugin has invalid plugin-type: \" + pluginDef.getPluginType());\n        }\n    }\n\n    /**\n     * Validate script provider def\n     */\n    private static void validateScriptProviderDef(final ProviderDef pluginDef) throws PluginException {\n        if (null == pluginDef.getName() || \"\".equals(pluginDef.getName())) {\n            throw new PluginException(\"Script plugin missing name\");\n        }\n        if (null == pluginDef.getService() || \"\".equals(pluginDef.getService())) {\n            throw new PluginException(\"Script plugin missing service\");\n        }\n        if (null == pluginDef.getScriptFile() || \"\".equals(pluginDef.getScriptFile())) {\n            throw new PluginException(\"Script plugin missing script-file\");\n        }\n\n        //make sure service is pluggable service and is script pluggable\n        /* final FrameworkSupportService service = framework.getService(pluginDef.getService());\n        if (!(service instanceof PluggableService)) {\n            throw new PluginException(\n                \"Service '\" + pluginDef.getService() + \"' specified for script plugin '\" + pluginDef.getName()\n                + \"' is not valid: unsupported\");\n        }\n        final PluggableService pservice = (PluggableService) service;\n        if (!pservice.isScriptPluggable()) {\n            throw new PluginException(\n                \"Service '\" + pluginDef.getService() + \"' specified for script plugin '\" + pluginDef.getName()\n                + \"' is not valid: unsupported\");\n        }*/\n    }\n\n    /**\n     * Validate script provider def\n     */\n    private static void validateUIProviderDef(final ProviderDef pluginDef) throws PluginException {\n        if (null == pluginDef.getName() || \"\".equals(pluginDef.getName())) {\n            throw new PluginException(\"UI plugin missing name\");\n        }\n        if (null == pluginDef.getService() || \"\".equals(pluginDef.getService())) {\n            throw new PluginException(\"UI plugin missing service\");\n        }\n        if (null == pluginDef.getPluginData() || null == pluginDef.getPluginData().get(\"ui\")) {\n            throw new PluginException(\"UI plugin missing ui: definition\");\n        }\n\n    }\n\n    private static void debug(final String msg) {\n        if (log.isDebugEnabled()) {\n            log.debug(msg);\n        }\n    }\n\n    /**\n     * Expire the loader cache item\n     */\n    public void expire() {\n        removeScriptPluginCache();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        ScriptPluginProviderLoader that = (ScriptPluginProviderLoader) o;\n\n        if (cachedir != null ? !cachedir.equals(that.cachedir) : that.cachedir != null) {\n            return false;\n        }\n        if (file != null ? !file.equals(that.file) : that.file != null) {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = file != null ? file.hashCode() : 0;\n        result = 31 * result + (cachedir != null ? cachedir.hashCode() : 0);\n        return result;\n    }\n\n\n    /**\n     * Return the version string metadata value for the plugin file, or null if it is not available or could not\n     * loaded\n     * @param file file\n     * @return version string\n     */\n    static String getVersionForFile(final File file)  {\n        try {\n            final PluginMeta pluginMeta = loadMeta(file);\n            return pluginMeta.getVersion();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return default value for \"mergeEnvironment\" based on plugin type version\n     * @param pluginMeta\n     * @return\n     */\n    public static boolean getDefaultMergeEnvVars(final PluginMeta pluginMeta) {\n        if (VERSION_1_0.equals(pluginMeta.getRundeckPluginVersion())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Return true if the plugin version supports resources\n     *\n     * @param pluginMeta\n     *\n     * @return\n     */\n    public static boolean supportsResources(final PluginMeta pluginMeta) {\n        return VersionCompare.forString(pluginMeta.getRundeckPluginVersion()).atLeast(SUPPORTS_RESOURCES_PLUGIN_VERSION);\n    }\n\n    public List<String> getPluginResourcesList() throws IOException {\n        return getPluginMeta().getResourcesList();\n    }\n\n    public String getResourcesBasePath() throws IOException {\n        return getResourcesBasePath(getPluginMeta());\n    }\n\n    public static String getResourcesBasePath(PluginMeta metadata) throws IOException {\n        String resourcesDir = metadata.getResourcesDir();\n        return null != resourcesDir ? resourcesDir : RESOURCES_DIR_DEFAULT;\n    }\n\n    @Override\n    public String getFilename() {\n        return file.getName();\n    }\n\n    @Override\n    public File getFile() {\n        return file;\n    }\n\n    @Override\n    public String getPluginArtifactName() {\n        try {\n            return getPluginMeta().getName();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginAuthor() {\n        try {\n            return getPluginMeta().getAuthor();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginFileVersion() {\n        try {\n            return getPluginMeta().getVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginVersion() {\n        try {\n            return getPluginMeta().getRundeckPluginVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginUrl() {\n        try {\n            return getPluginMeta().getUrl();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public Date getPluginDate() {\n        try {\n            String date = getPluginMeta().getDate();\n            return new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssX\").parse(date);\n        } catch (IOException | NullPointerException | ParseException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public Date getDateLoaded() {\n        return dateLoaded;\n    }\n\n    @Override\n    public String getPluginName() {\n        try {\n            return getPluginMeta().getName();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginDescription() {\n        try {\n            return getPluginMeta().getDescription();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginId() {\n        try {\n            return getPluginMeta().getId();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getRundeckCompatibilityVersion() {\n        try {\n            return getPluginMeta().getRundeckCompatibilityVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getTargetHostCompatibility() {\n        try {\n            return getPluginMeta().getTargetHostCompatibility();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public List<String> getTags() {\n        try {\n            return getPluginMeta().getTags();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginLicense() {\n        try {\n            return getPluginMeta().getLicense();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginThirdPartyDependencies() {\n        try {\n            return getPluginMeta().getThirdPartyDependencies();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginSourceLink() {\n        try {\n            return getPluginMeta().getSourceLink();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginDocsLink() {\n        try {\n            return getPluginMeta().getDocsLink();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginType() {\n        return \"script\";\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700293,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.commonwl.view.cwl;\n\nimport static org.apache.commons.io.FileUtils.readFileToString;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.jena.iri.IRI;\nimport org.apache.jena.iri.IRIFactory;\nimport org.apache.jena.ontology.OntModelSpec;\nimport org.apache.jena.query.QuerySolution;\nimport org.apache.jena.query.ResultSet;\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.rdf.model.ModelFactory;\nimport org.apache.jena.riot.RiotException;\nimport org.commonwl.view.docker.DockerService;\nimport org.commonwl.view.git.GitDetails;\nimport org.commonwl.view.graphviz.ModelDotWriter;\nimport org.commonwl.view.graphviz.RDFDotWriter;\nimport org.commonwl.view.workflow.Workflow;\nimport org.commonwl.view.workflow.WorkflowNotFoundException;\nimport org.commonwl.view.workflow.WorkflowOverview;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\nimport org.yaml.snakeyaml.Yaml;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.node.TextNode;\n\n/**\n * Provides CWL parsing for workflows to gather an overview\n * for display and visualisation\n */\n@Service\npublic class CWLService {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n    private final IRIFactory iriFactory = IRIFactory.iriImplementation();\n\n    // Autowired properties/services\n    private final RDFService rdfService;\n    private final CWLTool cwlTool;\n    private final int singleFileSizeLimit;\n\n    // CWL specific strings\n    private final String DOC_GRAPH = \"$graph\";\n    private final String CLASS = \"class\";\n    private final String WORKFLOW = \"Workflow\";\n    private final String COMMANDLINETOOL = \"CommandLineTool\";\n    private final String EXPRESSIONTOOL = \"ExpressionTool\";\n    private final String STEPS = \"steps\";\n    private final String INPUTS = \"inputs\";\n    private final String IN = \"in\";\n    private final String OUTPUTS = \"outputs\";\n    private final String OUT = \"out\";\n    private final String ID = \"id\";\n    private final String TYPE = \"type\";\n    private final String LABEL = \"label\";\n    private final String DEFAULT = \"default\";\n    private final String OUTPUT_SOURCE = \"outputSource\";\n    private final String SOURCE = \"source\";\n    private final String DOC = \"doc\";\n    private final String DESCRIPTION = \"description\";\n    private final String ARRAY = \"array\";\n    private final String ARRAY_ITEMS = \"items\";\n    private final String LOCATION = \"location\";\n    private final String RUN = \"run\";\n\n    /**\n     * Constructor for the Common Workflow Language service\n     * @param rdfService A service for handling RDF queries\n     * @param cwlTool Handles cwltool integration\n     * @param singleFileSizeLimit The file size limit for single files\n     */\n    @Autowired\n    public CWLService(RDFService rdfService,\n                      CWLTool cwlTool,\n                      @Value(\"${singleFileSizeLimit}\") int singleFileSizeLimit) {\n        this.rdfService = rdfService;\n        this.cwlTool = cwlTool;\n        this.singleFileSizeLimit = singleFileSizeLimit;\n    }\n\n    /**\n     * Gets whether a file is packed using schema salad\n     * @param workflowFile The file to be parsed\n     * @return Whether the file is packed\n     */\n    public boolean isPacked(File workflowFile) throws IOException {\n        if (workflowFile.length() > singleFileSizeLimit) {\n            return false;\n        }\n        String fileContent = readFileToString(workflowFile);\n        return fileContent.contains(\"$graph\");\n    }\n\n    /**\n     * Gets a list of workflows from a packed CWL file\n     * @param packedFile The packed CWL file\n     * @return The list of workflow overviews\n     */\n    public List<WorkflowOverview> getWorkflowOverviewsFromPacked(File packedFile) throws IOException {\n        if (packedFile.length() <= singleFileSizeLimit) {\n            List<WorkflowOverview> overviews = new ArrayList<>();\n\n            JsonNode packedJson = yamlPathToJson(packedFile.toPath());\n\n            if (packedJson.has(DOC_GRAPH)) {\n                for (JsonNode jsonNode : packedJson.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        WorkflowOverview overview = new WorkflowOverview(jsonNode.get(ID).asText(),\n                                extractLabel(jsonNode), extractDoc(jsonNode));\n                        overviews.add(overview);\n                    }\n                }\n            } else {\n                throw new IOException(\"The file given was not recognised as a packed CWL file\");\n            }\n\n            return overviews;\n\n        } else {\n            throw new IOException(\"File '\" + packedFile.getName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(packedFile.length()) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n    }\n\n    /**\n     * Gets the Workflow object from internal parsing. \n     * Note, the length of the stream is not checked.\n     *  \n     * @param workflowStream The workflow stream to be parsed\n     * @param packedWorkflowId The ID of the workflow object if the file is packed. <code>null</code> means the workflow is not expected to be packed, while \"\" means the first workflow found is used, packed or non-packed.\n     * @param defaultLabel Label to give workflow if not set\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowNative(InputStream workflowStream, String packedWorkflowId, String defaultLabel) throws IOException {\n        // Parse file as yaml\n        JsonNode cwlFile = yamlStreamToJson(workflowStream);\n\n        // Check packed workflow occurs\n        boolean found = false;\n        if (packedWorkflowId != null) {\n            if (cwlFile.has(DOC_GRAPH)) {\n                for (JsonNode jsonNode : cwlFile.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        String currentId = jsonNode.get(ID).asText();\n                        if (currentId.startsWith(\"#\")) {\n                            currentId = currentId.substring(1);\n                        }\n                        if (packedWorkflowId.isEmpty() || currentId.equals(packedWorkflowId)) {\n                            cwlFile = jsonNode;\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!found && ! packedWorkflowId.isEmpty()) throw new WorkflowNotFoundException();\n        }\n        if (! found && extractProcess(cwlFile) == CWLProcess.WORKFLOW) {\n        \t// Check the current json node is a workflow\n        \tfound = true;\n        }\n        if (! found) {\n            throw new WorkflowNotFoundException();\n        }\n\n        // Use filename for label if there is no defined one\n        String label = extractLabel(cwlFile);\n        if (label == null) {\n            label = defaultLabel;\n        }\n\n        // Construct the rest of the workflow model\n        Workflow workflowModel = new Workflow(label, extractDoc(cwlFile), getInputs(cwlFile),\n                getOutputs(cwlFile), getSteps(cwlFile));\n\n        workflowModel.setCwltoolVersion(cwlTool.getVersion());\n\n        // Generate DOT graph\n        StringWriter graphWriter = new StringWriter();\n        ModelDotWriter dotWriter = new ModelDotWriter(graphWriter);\n        try {\n            dotWriter.writeGraph(workflowModel);\n            workflowModel.setVisualisationDot(graphWriter.toString());\n        } catch (IOException ex) {\n            logger.error(\"Failed to create DOT graph for workflow: \" + ex.getMessage());\n        }\n\n        return workflowModel;\n\n\n    }\n\n    \n    /**\n     * Gets the Workflow object from internal parsing.\n     * The size of the workflow file must be below the configured \n     * singleFileSizeLimit in the constructor/spring config.\n     * \n     * @param workflowFile The workflow file to be parsed\n     * @param packedWorkflowId The ID of the workflow object if the file is packed\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowNative(Path workflowFile, String packedWorkflowId) throws IOException {\n\n        // Check file size limit before parsing\n        long fileSizeBytes = Files.size(workflowFile);\n        if (fileSizeBytes <= singleFileSizeLimit) {\n        \ttry (InputStream in = Files.newInputStream(workflowFile)) {\n        \t\treturn parseWorkflowNative(in, packedWorkflowId, \n        \t\t\t\tworkflowFile.getName(workflowFile.getNameCount()-1).toString());\n        \t}\n        } else {\n            throw new IOException(\"File '\" + workflowFile.getFileName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(fileSizeBytes) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n\n    }\n\n    /**\n     * Create a workflow model using cwltool rdf output\n     * @param basicModel The basic workflow object created thus far\n     * @param workflowFile The workflow file to run cwltool on\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowWithCwltool(Workflow basicModel,\n                                             Path workflowFile,\n                                             Path workTree) throws CWLValidationException {\n        GitDetails gitDetails = basicModel.getRetrievedFrom();\n        String latestCommit = basicModel.getLastCommit();\n        String packedWorkflowID = gitDetails.getPackedId();\n\n        // Get paths to workflow\n        String url = basicModel.getIdentifier();\n        String workflowFileURI = workflowFile.toAbsolutePath().toUri().toString();\n        URI workTreeUri = workTree.toAbsolutePath().toUri();\n\t\tString localPath = workflowFileURI;\n        String gitPath = gitDetails.getPath();\n        if (packedWorkflowID != null) {\n            if (packedWorkflowID.charAt(0) != '#') {\n                localPath += \"#\";\n                gitPath += \"#\";\n            }\n            localPath += packedWorkflowID;\n            gitPath += packedWorkflowID;\n        }\n\n        // Get RDF representation from cwltool\n        if (!rdfService.graphExists(url)) {\n            String rdf = cwlTool.getRDF(localPath);\n            // Replace /tmp/123123 with permalink base \n            // NOTE: We do not just replace workflowFileURI, all referenced files will also get rewritten\n\t\t\trdf = rdf.replace(workTreeUri.toString(),\n                    \"https://w3id.org/cwl/view/git/\" + latestCommit + \"/\");\n            // Workaround for common-workflow-language/cwltool#427\n            rdf = rdf.replace(\"<rdfs:>\", \"<http://www.w3.org/2000/01/rdf-schema#>\");\n\n            // Create a workflow model from RDF representation\n            Model model = ModelFactory.createDefaultModel();\n            model.read(new ByteArrayInputStream(rdf.getBytes()), null, \"TURTLE\");\n\n            // Store the model\n            rdfService.storeModel(url, model);\n        }\n\n        // Base workflow details\n        String label = FilenameUtils.getName(url);\n        String doc = null;\n        ResultSet labelAndDoc = rdfService.getLabelAndDoc(url);\n        if (labelAndDoc.hasNext()) {\n            QuerySolution labelAndDocSoln = labelAndDoc.nextSolution();\n            if (labelAndDocSoln.contains(\"label\")) {\n                label = labelAndDocSoln.get(\"label\").toString();\n            }\n            if (labelAndDocSoln.contains(\"doc\")) {\n                doc = labelAndDocSoln.get(\"doc\").toString();\n            }\n        }\n\n        // Inputs\n        Map<String, CWLElement> wfInputs = new HashMap<>();\n        ResultSet inputs = rdfService.getInputs(url);\n        while (inputs.hasNext()) {\n            QuerySolution input = inputs.nextSolution();\n            String inputName = rdfService.stepNameFromURI(gitPath, input.get(\"name\").toString());\n\n            CWLElement wfInput = new CWLElement();\n            if (input.contains(\"type\")) {\n                String type;\n                if (input.get(\"type\").toString().equals(\"https://w3id.org/cwl/salad#array\")) {\n                    type = typeURIToString(input.get(\"items\").toString()) + \"[]\";\n                } else {\n                    type = typeURIToString(input.get(\"type\").toString());\n                }\n                if (input.contains(\"null\")) {\n                    type += \" (Optional)\";\n                }\n                wfInput.setType(type);\n            }\n            if (input.contains(\"format\")) {\n                String format = input.get(\"format\").toString();\n                setFormat(wfInput, format);\n            }\n            if (input.contains(\"label\")) {\n                wfInput.setLabel(input.get(\"label\").toString());\n            }\n            if (input.contains(\"doc\")) {\n                wfInput.setDoc(input.get(\"doc\").toString());\n            }\n            wfInputs.put(rdfService.labelFromName(inputName), wfInput);\n        }\n\n        // Outputs\n        Map<String, CWLElement> wfOutputs = new HashMap<>();\n        ResultSet outputs = rdfService.getOutputs(url);\n        while (outputs.hasNext()) {\n            QuerySolution output = outputs.nextSolution();\n            CWLElement wfOutput = new CWLElement();\n\n            String outputName = rdfService.stepNameFromURI(gitPath, output.get(\"name\").toString());\n            if (output.contains(\"type\")) {\n                String type;\n                if (output.get(\"type\").toString().equals(\"https://w3id.org/cwl/salad#array\")) {\n                    type = typeURIToString(output.get(\"items\").toString()) + \"[]\";\n                } else {\n                    type = typeURIToString(output.get(\"type\").toString());\n                }\n                if (output.contains(\"null\")) {\n                    type += \" (Optional)\";\n                }\n                wfOutput.setType(type);\n            }\n\n            if (output.contains(\"src\")) {\n                wfOutput.addSourceID(rdfService.stepNameFromURI(gitPath,\n                        output.get(\"src\").toString()));\n            }\n            if (output.contains(\"format\")) {\n                String format = output.get(\"format\").toString();\n                setFormat(wfOutput, format);\n            }\n            if (output.contains(\"label\")) {\n                wfOutput.setLabel(output.get(\"label\").toString());\n            }\n            if (output.contains(\"doc\")) {\n                wfOutput.setDoc(output.get(\"doc\").toString());\n            }\n            wfOutputs.put(rdfService.labelFromName(outputName), wfOutput);\n        }\n\n\n        // Steps\n        Map<String, CWLStep> wfSteps = new HashMap<>();\n        ResultSet steps = rdfService.getSteps(url);\n        while (steps.hasNext()) {\n            QuerySolution step = steps.nextSolution();\n            String uri = rdfService.stepNameFromURI(gitPath, step.get(\"step\").toString());\n            if (wfSteps.containsKey(uri)) {\n                // Already got step details, add extra source ID\n                if (step.contains(\"src\")) {\n                    CWLElement src = new CWLElement();\n                    src.addSourceID(rdfService.stepNameFromURI(gitPath, step.get(\"src\").toString()));\n                    wfSteps.get(uri).getSources().put(\n                            step.get(\"stepinput\").toString(), src);\n                } else if (step.contains(\"default\")) {\n                    CWLElement src = new CWLElement();\n                    src.setDefaultVal(rdfService.formatDefault(step.get(\"default\").toString()));\n                    wfSteps.get(uri).getSources().put(\n                            step.get(\"stepinput\").toString(), src);\n                }\n            } else {\n                // Add new step\n                CWLStep wfStep = new CWLStep();\n\n                IRI workflowPath = iriFactory.construct(url).resolve(\"./\");\n                IRI runPath = iriFactory.construct(step.get(\"run\").asResource().getURI());\n                wfStep.setRun(workflowPath.relativize(runPath).toString());\n                wfStep.setRunType(rdfService.strToRuntype(step.get(\"runtype\").toString()));\n\n                if (step.contains(\"src\")) {\n                    CWLElement src = new CWLElement();\n                    src.addSourceID(rdfService.stepNameFromURI(gitPath, step.get(\"src\").toString()));\n                    Map<String, CWLElement> srcList = new HashMap<>();\n                    srcList.put(rdfService.stepNameFromURI(gitPath,\n                            step.get(\"stepinput\").toString()), src);\n                    wfStep.setSources(srcList);\n                } else if (step.contains(\"default\")) {\n                    CWLElement src = new CWLElement();\n                    src.setDefaultVal(rdfService.formatDefault(step.get(\"default\").toString()));\n                    Map<String, CWLElement> srcList = new HashMap<>();\n                    srcList.put(rdfService.stepNameFromURI(gitPath,\n                            step.get(\"stepinput\").toString()), src);\n                    wfStep.setSources(srcList);\n                }\n                if (step.contains(\"label\")) {\n                    wfStep.setLabel(step.get(\"label\").toString());\n                }\n                if (step.contains(\"doc\")) {\n                    wfStep.setDoc(step.get(\"doc\").toString());\n                }\n                wfSteps.put(rdfService.labelFromName(uri), wfStep);\n            }\n        }\n        // Try to determine license\n        ResultSet licenseResult = rdfService.getLicense(url);\n        String licenseLink = null;\n        if (licenseResult.hasNext()) {\n        \tlicenseLink = licenseResult.next().get(\"license\").toString();\n        } else {\n        \t// Check for \"LICENSE\"-like files in root of git repo\n        \tfor (String licenseCandidate : new String[]{\"LICENSE\", \"LICENSE.txt\", \"LICENSE.md\"}) {\n        \t\t// FIXME: This might wrongly match lower-case \"license.txt\" in case-insensitive file systems\n        \t\t// but the URL would not work\n        \t\tif (Files.isRegularFile(workTree.resolve(licenseCandidate))) {\n        \t\t\t// Link to it by raw URL\n        \t\t\tlicenseLink = basicModel.getRetrievedFrom().getRawUrl(null, licenseCandidate);\n        \t\t}\n\t\t\t}\n        }\n\n        // Docker link\n        ResultSet dockerResult = rdfService.getDockerLink(url);\n        String dockerLink = null;\n        if (dockerResult.hasNext()) {\n            QuerySolution docker = dockerResult.nextSolution();\n            if (docker.contains(\"pull\")) {\n                dockerLink = DockerService.getDockerHubURL(docker.get(\"pull\").toString());\n            } else {\n                dockerLink = \"true\";\n            }\n        }\n\n        // Create workflow model\n        Workflow workflowModel = new Workflow(label, doc,\n                wfInputs, wfOutputs, wfSteps, \n                dockerLink, licenseLink);\n\n        // Generate DOT graph\n        StringWriter graphWriter = new StringWriter();\n        RDFDotWriter RDFDotWriter = new RDFDotWriter(graphWriter, rdfService, gitPath);\n        try {\n            RDFDotWriter.writeGraph(url);\n            workflowModel.setVisualisationDot(graphWriter.toString());\n        } catch (IOException ex) {\n            logger.error(\"Failed to create DOT graph for workflow: \" + ex.getMessage());\n        }\n\n\n        return workflowModel;\n\n    }\n\n    /**\n     * Get an overview of a workflow\n     * @param file A file, potentially a workflow\n     * @return A constructed WorkflowOverview of the workflow\n     * @throws IOException Any API errors which may have occurred\n     */\n    public WorkflowOverview getWorkflowOverview(File file) throws IOException {\n\n        // Get the content of this file from Github\n        long fileSizeBytes = file.length();\n\n        // Check file size limit before parsing\n        if (fileSizeBytes <= singleFileSizeLimit) {\n\n            // Parse file as yaml\n            JsonNode cwlFile = yamlPathToJson(file.toPath());\n\n            // If the CWL file is packed there can be multiple workflows in a file\n            int packedCount = 0;\n            if (cwlFile.has(DOC_GRAPH)) {\n                // Packed CWL, find the first subelement which is a workflow and take it\n                for (JsonNode jsonNode : cwlFile.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        cwlFile = jsonNode;\n                        packedCount++;\n                    }\n                }\n                if (packedCount > 1) {\n                    return new WorkflowOverview(\"/\" + file.getName(), \"Packed file\",\n                            \"contains \" + packedCount + \" workflows\");\n                }\n            }\n\n            // Can only make an overview if this is a workflow\n            if (extractProcess(cwlFile) == CWLProcess.WORKFLOW) {\n                // Use filename for label if there is no defined one\n                String label = extractLabel(cwlFile);\n                if (label == null) {\n                    label = file.getName();\n                }\n\n                // Return the constructed overview\n                return new WorkflowOverview(\"/\" + file.getName(), label, extractDoc(cwlFile));\n            } else {\n                // Return null if not a workflow file\n                return null;\n            }\n        } else {\n            throw new IOException(\"File '\" + file.getName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(fileSizeBytes) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n\n    }\n\n    /**\n     * Set the format for an input or output, handling ontologies\n     * @param inputOutput The input or output CWL Element\n     * @param format The format URI\n     */\n    private void setFormat(CWLElement inputOutput, String format) {\n        inputOutput.setFormat(format);\n        try {\n            if (!rdfService.ontPropertyExists(format)) {\n                Model ontModel = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM);\n                ontModel.read(format, null, \"RDF/XML\");\n                rdfService.addToOntologies(ontModel);\n            }\n            String formatLabel = rdfService.getOntLabel(format);\n            inputOutput.setType(inputOutput.getType() + \" [\" + formatLabel + \"]\");\n        } catch (RiotException ex) {\n            inputOutput.setType(inputOutput.getType() + \" [format]\");\n        }\n    }\n\n    /**\n     * Convert RDF URI for a type to a name\n     * @param uri The URI for the type\n     * @return The human readable name for that type\n     */\n    private String typeURIToString(String uri) {\n        switch (uri) {\n            case \"http://www.w3.org/2001/XMLSchema#string\":\n                return \"String\";\n            case \"https://w3id.org/cwl/cwl#File\":\n                return \"File\";\n            case \"http://www.w3.org/2001/XMLSchema#boolean\":\n                return \"Boolean\";\n            case \"http://www.w3.org/2001/XMLSchema#int\":\n                return \"Integer\";\n            case \"http://www.w3.org/2001/XMLSchema#double\":\n                return \"Double\";\n            case \"http://www.w3.org/2001/XMLSchema#float\":\n                return \"Float\";\n            case \"http://www.w3.org/2001/XMLSchema#long\":\n                return \"Long\";\n            case \"https://w3id.org/cwl/cwl#Directory\":\n                return \"Directory\";\n            default:\n                return uri;\n        }\n    }\n\n    /**\n     * Converts a yaml String to JsonNode\n     * @param path A Path to a file containing the yaml content\n     * @return A JsonNode with the content of the document\n     * @throws IOException \n     */\n    private JsonNode yamlPathToJson(Path path) throws IOException {\n        Yaml reader = new Yaml();\n        ObjectMapper mapper = new ObjectMapper();\n        Path p;\n        \n        try (InputStream in = Files.newInputStream(path)) {\n        \treturn mapper.valueToTree(reader.load(in));\n        }\n    }\n\n    \n    /**\n     * Converts a yaml String to JsonNode\n     * @param yamlStream An InputStream containing the yaml content\n     * @return A JsonNode with the content of the document\n     */\n    private JsonNode yamlStreamToJson(InputStream yamlStream) {\n        Yaml reader = new Yaml();\n        ObjectMapper mapper = new ObjectMapper();\n\t\treturn mapper.valueToTree(reader.load(yamlStream));\n    }\n\n    /**\n     * Extract the label from a node\n     * @param node The node to have the label extracted from\n     * @return The string for the label of the node\n     */\n    private String extractLabel(JsonNode node) {\n        if (node != null && node.has(LABEL)) {\n            return node.get(LABEL).asText();\n        }\n        return null;\n    }\n\n    /**\n     * Extract the class parameter from a node representing a document\n     * @param rootNode The root node of a cwl document\n     * @return Which process this document represents\n     */\n    private CWLProcess extractProcess(JsonNode rootNode) {\n        if (rootNode != null) {\n            if (rootNode.has(CLASS)) {\n                switch(rootNode.get(CLASS).asText()) {\n                    case WORKFLOW:\n                        return CWLProcess.WORKFLOW;\n                    case COMMANDLINETOOL:\n                        return CWLProcess.COMMANDLINETOOL;\n                    case EXPRESSIONTOOL:\n                        return CWLProcess.EXPRESSIONTOOL;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the steps for a particular document\n     * @param cwlDoc The document to get steps for\n     * @return A map of step IDs and details related to them\n     */\n    private Map<String, CWLStep> getSteps(JsonNode cwlDoc) {\n        if (cwlDoc != null && cwlDoc.has(STEPS)) {\n            Map<String, CWLStep> returnMap = new HashMap<>();\n\n            JsonNode steps = cwlDoc.get(STEPS);\n            if (steps.getClass() == ArrayNode.class) {\n                // Explicit ID and other fields within each input list\n                for (JsonNode step : steps) {\n                    CWLStep stepObject = new CWLStep(extractLabel(step), extractDoc(step),\n                            extractRun(step), getInputs(step));\n                    returnMap.put(extractID(step), stepObject);\n                }\n            } else if (steps.getClass() == ObjectNode.class) {\n                // ID is the key of each object\n                Iterator<Map.Entry<String, JsonNode>> iterator = steps.fields();\n                while (iterator.hasNext()) {\n                    Map.Entry<String, JsonNode> stepNode = iterator.next();\n                    JsonNode stepJson = stepNode.getValue();\n                    CWLStep stepObject = new CWLStep(extractLabel(stepJson), extractDoc(stepJson),\n                            extractRun(stepJson), getInputs(stepJson));\n                    returnMap.put(stepNode.getKey(), stepObject);\n                }\n            }\n\n            return returnMap;\n        }\n        return null;\n    }\n\n    /**\n     * Get a the inputs for a particular document\n     * @param cwlDoc The document to get inputs for\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getInputs(JsonNode cwlDoc) {\n        if (cwlDoc != null) {\n            if (cwlDoc.has(INPUTS)) {\n                // For all version workflow inputs/outputs and draft steps\n                return getInputsOutputs(cwlDoc.get(INPUTS));\n            } else if (cwlDoc.has(IN)) {\n                // For V1.0 steps\n                return getStepInputsOutputs(cwlDoc.get(IN));\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the outputs for a particular document\n     * @param cwlDoc The document to get outputs for\n     * @return A map of output IDs and details related to them\n     */\n    private Map<String, CWLElement> getOutputs(JsonNode cwlDoc) {\n        if (cwlDoc != null) {\n            // For all version workflow inputs/outputs and draft steps\n            if (cwlDoc.has(OUTPUTS)) {\n                return getInputsOutputs(cwlDoc.get(OUTPUTS));\n            }\n            // Outputs are not gathered for v1 steps\n        }\n        return null;\n    }\n\n    /**\n     * Get inputs or outputs from an in or out node\n     * @param inOut The in or out node\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getStepInputsOutputs(JsonNode inOut) {\n        Map<String, CWLElement> returnMap = new HashMap<>();\n\n        if (inOut.getClass() == ArrayNode.class) {\n            // array<WorkflowStepInput>\n            for (JsonNode inOutNode : inOut) {\n                if (inOutNode.getClass() == ObjectNode.class) {\n                    CWLElement inputOutput = new CWLElement();\n                    List<String> sources = extractSource(inOutNode);\n                    if (sources.size() > 0) {\n                        for (String source : sources) {\n                            inputOutput.addSourceID(stepIDFromSource(source));\n                        }\n                    } else {\n                        inputOutput.setDefaultVal(extractDefault(inOutNode));\n                    }\n                    returnMap.put(extractID(inOutNode), inputOutput);\n                }\n            }\n        } else if (inOut.getClass() == ObjectNode.class) {\n            // map<WorkflowStepInput.id, WorkflowStepInput.source>\n            Iterator<Map.Entry<String, JsonNode>> iterator = inOut.fields();\n            while (iterator.hasNext()) {\n                Map.Entry<String, JsonNode> inOutNode = iterator.next();\n                CWLElement inputOutput = new CWLElement();\n                if (inOutNode.getValue().getClass() == ObjectNode.class) {\n                    JsonNode properties = inOutNode.getValue();\n                    if (properties.has(SOURCE)) {\n                        inputOutput.addSourceID(stepIDFromSource(properties.get(SOURCE).asText()));\n                    } else {\n                        inputOutput.setDefaultVal(extractDefault(properties));\n                    }\n                } else if (inOutNode.getValue().getClass() == ArrayNode.class) {\n                    for (JsonNode key : inOutNode.getValue()) {\n                        inputOutput.addSourceID(stepIDFromSource(key.asText()));\n                    }\n                } else {\n                    inputOutput.addSourceID(stepIDFromSource(inOutNode.getValue().asText()));\n                }\n                returnMap.put(inOutNode.getKey(), inputOutput);\n            }\n        }\n\n        return returnMap;\n    }\n\n    /**\n     * Get inputs or outputs from an inputs or outputs node\n     * @param inputsOutputs The inputs or outputs node\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getInputsOutputs(JsonNode inputsOutputs) {\n        Map<String, CWLElement> returnMap = new HashMap<>();\n\n        if (inputsOutputs.getClass() == ArrayNode.class) {\n            // Explicit ID and other fields within each list\n            for (JsonNode inputOutput : inputsOutputs) {\n                String id = inputOutput.get(ID).asText();\n                if (id.charAt(0) == '#') {\n                    id = id.substring(1);\n                }\n                returnMap.put(id, getDetails(inputOutput));\n            }\n        } else if (inputsOutputs.getClass() == ObjectNode.class) {\n            // ID is the key of each object\n            Iterator<Map.Entry<String, JsonNode>> iterator = inputsOutputs.fields();\n            while (iterator.hasNext()) {\n                Map.Entry<String, JsonNode> inputOutputNode = iterator.next();\n                returnMap.put(inputOutputNode.getKey(), getDetails(inputOutputNode.getValue()));\n            }\n        }\n\n        return returnMap;\n    }\n\n    /**\n     * Gets the details of an input or output\n     * @param inputOutput The node of the particular input or output\n     * @return An CWLElement object with the label, doc and type extracted\n     */\n    private CWLElement getDetails(JsonNode inputOutput) {\n        if (inputOutput != null) {\n            CWLElement details = new CWLElement();\n\n            // Shorthand notation \"id: type\" - no label/doc/other params\n            if (inputOutput.getClass() == TextNode.class) {\n                details.setType(inputOutput.asText());\n            } else {\n                details.setLabel(extractLabel(inputOutput));\n                details.setDoc(extractDoc(inputOutput));\n                extractSource(inputOutput).forEach(details::addSourceID);\n                details.setDefaultVal(extractDefault(inputOutput));\n\n                // Type is only for inputs\n                if (inputOutput.has(TYPE)) {\n                    details.setType(extractTypes(inputOutput.get(TYPE)));\n                }\n            }\n\n            return details;\n        }\n        return null;\n    }\n\n    /**\n     * Extract the id from a node\n     * @param node The node to have the id extracted from\n     * @return The string for the id of the node\n     */\n    private String extractID(JsonNode node) {\n        if (node != null && node.has(ID)) {\n            String id = node.get(ID).asText();\n            if (id.startsWith(\"#\")) {\n                return id.substring(1);\n            }\n            return id;\n        }\n        return null;\n    }\n\n    /**\n     * Extract the default value from a node\n     * @param node The node to have the label extracted from\n     * @return The string for the default value of the node\n     */\n    private String extractDefault(JsonNode node) {\n        if (node != null && node.has(DEFAULT)) {\n            if (node.get(DEFAULT).has(LOCATION)) {\n                return node.get(DEFAULT).get(LOCATION).asText();\n            } else {\n                return \"\\\\\\\"\" + node.get(DEFAULT).asText() + \"\\\\\\\"\";\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the source or outputSource from a node\n     * @param node The node to have the sources extracted from\n     * @return A list of strings for the sources\n     */\n    private List<String> extractSource(JsonNode node) {\n        if (node != null) {\n            List<String> sources = new ArrayList<String>();\n            JsonNode sourceNode = null;\n\n            // outputSource and source treated the same\n            if (node.has(OUTPUT_SOURCE)) {\n                sourceNode = node.get(OUTPUT_SOURCE);\n            } else if (node.has(SOURCE)) {\n                sourceNode = node.get(SOURCE);\n            }\n\n            if (sourceNode != null) {\n                // Single source\n                if (sourceNode.getClass() == TextNode.class) {\n                    sources.add(stepIDFromSource(sourceNode.asText()));\n                }\n                // Can be an array of multiple sources\n                if (sourceNode.getClass() == ArrayNode.class) {\n                    for (JsonNode source : sourceNode) {\n                        sources.add(stepIDFromSource(source.asText()));\n                    }\n                }\n            }\n\n            return sources;\n        }\n        return null;\n    }\n\n    /**\n     * Gets just the step ID from source of format 'stepID</ or .>outputID'\n     * @param source The source\n     * @return The step ID\n     */\n    private String stepIDFromSource(String source) {\n        if (source != null && source.length() > 0) {\n            // Strip leading # if it exists\n            if (source.charAt(0) == '#') {\n                source = source.substring(1);\n            }\n\n            // Draft 3/V1 notation is 'stepID/outputID'\n            int slashSplit = source.indexOf(\"/\");\n            if (slashSplit != -1) {\n                source = source.substring(0, slashSplit);\n            } else {\n                // Draft 2 notation was 'stepID.outputID'\n                int dotSplit = source.indexOf(\".\");\n                if (dotSplit != -1) {\n                    source = source.substring(0, dotSplit);\n                }\n            }\n        }\n        return source;\n    }\n\n    /**\n     * Extract the doc or description from a node\n     * @param node The node to have the doc/description extracted from\n     * @return The string for the doc/description of the node\n     */\n    private String extractDoc(JsonNode node) {\n        if (node != null) {\n            if (node.has(DOC)) {\n                return node.get(DOC).asText();\n            } else if (node.has(DESCRIPTION)) {\n                // This is to support older standards of cwl which use description instead of doc\n                return node.get(DESCRIPTION).asText();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the types from a node representing inputs or outputs\n     * @param typeNode The root node representing an input or output\n     * @return A string with the types listed\n     */\n    private String extractTypes(JsonNode typeNode) {\n        if (typeNode != null) {\n            if (typeNode.getClass() == TextNode.class) {\n                // Single type\n                return typeNode.asText();\n            } else if (typeNode.getClass() == ArrayNode.class) {\n                // Multiple types, build a string to represent them\n                StringBuilder typeDetails = new StringBuilder();\n                boolean optional = false;\n                for (JsonNode type : typeNode) {\n                    if (type.getClass() == TextNode.class) {\n                        // This is a simple type\n                        if (type.asText().equals(\"null\")) {\n                            // null as a type means this field is optional\n                            optional = true;\n                        } else {\n                            // Add a simple type to the string\n                            typeDetails.append(type.asText());\n                            typeDetails.append(\", \");\n                        }\n                    } else if (typeNode.getClass() == ArrayNode.class) {\n                        // This is a verbose type with sub-fields broken down into type: and other params\n                        if (type.get(TYPE).asText().equals(ARRAY)) {\n                            typeDetails.append(type.get(ARRAY_ITEMS).asText());\n                            typeDetails.append(\"[], \");\n                        } else {\n                            typeDetails.append(type.get(TYPE).asText());\n                        }\n                    }\n                }\n\n                // Trim off excessive separators\n                if (typeDetails.length() > 1) {\n                    typeDetails.setLength(typeDetails.length() - 2);\n                }\n\n                // Add optional if null was included in the multiple types\n                if (optional) typeDetails.append(\"?\");\n\n                // Set the type to the constructed string\n                return typeDetails.toString();\n\n            } else if (typeNode.getClass() == ObjectNode.class) {\n                // Type: array and items:\n                if (typeNode.has(ARRAY_ITEMS)) {\n                    return typeNode.get(ARRAY_ITEMS).asText() + \"[]\";\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the run parameter from a node representing a step\n     * @param stepNode The root node of a step\n     * @return A string with the run parameter if it exists\n     */\n    private String extractRun(JsonNode stepNode) {\n        if (stepNode != null) {\n            if (stepNode.has(RUN)) {\n                return stepNode.get(RUN).asText();\n            }\n        }\n        return null;\n    }\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700298,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  },
  {
    "CWE_ID": [
      "CWE-502"
    ],
    "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.commonwl.view.cwl;\n\nimport static org.apache.commons.io.FileUtils.readFileToString;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.jena.iri.IRI;\nimport org.apache.jena.iri.IRIFactory;\nimport org.apache.jena.ontology.OntModelSpec;\nimport org.apache.jena.query.QuerySolution;\nimport org.apache.jena.query.ResultSet;\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.rdf.model.ModelFactory;\nimport org.apache.jena.riot.RiotException;\nimport org.commonwl.view.docker.DockerService;\nimport org.commonwl.view.git.GitDetails;\nimport org.commonwl.view.graphviz.ModelDotWriter;\nimport org.commonwl.view.graphviz.RDFDotWriter;\nimport org.commonwl.view.workflow.Workflow;\nimport org.commonwl.view.workflow.WorkflowNotFoundException;\nimport org.commonwl.view.workflow.WorkflowOverview;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\nimport org.yaml.snakeyaml.Yaml;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.node.TextNode;\nimport org.yaml.snakeyaml.constructor.SafeConstructor;\n\n/**\n * Provides CWL parsing for workflows to gather an overview\n * for display and visualisation\n */\n@Service\npublic class CWLService {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n    private final IRIFactory iriFactory = IRIFactory.iriImplementation();\n\n    // Autowired properties/services\n    private final RDFService rdfService;\n    private final CWLTool cwlTool;\n    private final int singleFileSizeLimit;\n\n    // CWL specific strings\n    private final String DOC_GRAPH = \"$graph\";\n    private final String CLASS = \"class\";\n    private final String WORKFLOW = \"Workflow\";\n    private final String COMMANDLINETOOL = \"CommandLineTool\";\n    private final String EXPRESSIONTOOL = \"ExpressionTool\";\n    private final String STEPS = \"steps\";\n    private final String INPUTS = \"inputs\";\n    private final String IN = \"in\";\n    private final String OUTPUTS = \"outputs\";\n    private final String OUT = \"out\";\n    private final String ID = \"id\";\n    private final String TYPE = \"type\";\n    private final String LABEL = \"label\";\n    private final String DEFAULT = \"default\";\n    private final String OUTPUT_SOURCE = \"outputSource\";\n    private final String SOURCE = \"source\";\n    private final String DOC = \"doc\";\n    private final String DESCRIPTION = \"description\";\n    private final String ARRAY = \"array\";\n    private final String ARRAY_ITEMS = \"items\";\n    private final String LOCATION = \"location\";\n    private final String RUN = \"run\";\n\n    /**\n     * Constructor for the Common Workflow Language service\n     * @param rdfService A service for handling RDF queries\n     * @param cwlTool Handles cwltool integration\n     * @param singleFileSizeLimit The file size limit for single files\n     */\n    @Autowired\n    public CWLService(RDFService rdfService,\n                      CWLTool cwlTool,\n                      @Value(\"${singleFileSizeLimit}\") int singleFileSizeLimit) {\n        this.rdfService = rdfService;\n        this.cwlTool = cwlTool;\n        this.singleFileSizeLimit = singleFileSizeLimit;\n    }\n\n    /**\n     * Gets whether a file is packed using schema salad\n     * @param workflowFile The file to be parsed\n     * @return Whether the file is packed\n     */\n    public boolean isPacked(File workflowFile) throws IOException {\n        if (workflowFile.length() > singleFileSizeLimit) {\n            return false;\n        }\n        String fileContent = readFileToString(workflowFile);\n        return fileContent.contains(\"$graph\");\n    }\n\n    /**\n     * Gets a list of workflows from a packed CWL file\n     * @param packedFile The packed CWL file\n     * @return The list of workflow overviews\n     */\n    public List<WorkflowOverview> getWorkflowOverviewsFromPacked(File packedFile) throws IOException {\n        if (packedFile.length() <= singleFileSizeLimit) {\n            List<WorkflowOverview> overviews = new ArrayList<>();\n\n            JsonNode packedJson = yamlPathToJson(packedFile.toPath());\n\n            if (packedJson.has(DOC_GRAPH)) {\n                for (JsonNode jsonNode : packedJson.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        WorkflowOverview overview = new WorkflowOverview(jsonNode.get(ID).asText(),\n                                extractLabel(jsonNode), extractDoc(jsonNode));\n                        overviews.add(overview);\n                    }\n                }\n            } else {\n                throw new IOException(\"The file given was not recognised as a packed CWL file\");\n            }\n\n            return overviews;\n\n        } else {\n            throw new IOException(\"File '\" + packedFile.getName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(packedFile.length()) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n    }\n\n    /**\n     * Gets the Workflow object from internal parsing. \n     * Note, the length of the stream is not checked.\n     *  \n     * @param workflowStream The workflow stream to be parsed\n     * @param packedWorkflowId The ID of the workflow object if the file is packed. <code>null</code> means the workflow is not expected to be packed, while \"\" means the first workflow found is used, packed or non-packed.\n     * @param defaultLabel Label to give workflow if not set\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowNative(InputStream workflowStream, String packedWorkflowId, String defaultLabel) throws IOException {\n        // Parse file as yaml\n        JsonNode cwlFile = yamlStreamToJson(workflowStream);\n\n        // Check packed workflow occurs\n        boolean found = false;\n        if (packedWorkflowId != null) {\n            if (cwlFile.has(DOC_GRAPH)) {\n                for (JsonNode jsonNode : cwlFile.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        String currentId = jsonNode.get(ID).asText();\n                        if (currentId.startsWith(\"#\")) {\n                            currentId = currentId.substring(1);\n                        }\n                        if (packedWorkflowId.isEmpty() || currentId.equals(packedWorkflowId)) {\n                            cwlFile = jsonNode;\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!found && ! packedWorkflowId.isEmpty()) throw new WorkflowNotFoundException();\n        }\n        if (! found && extractProcess(cwlFile) == CWLProcess.WORKFLOW) {\n        \t// Check the current json node is a workflow\n        \tfound = true;\n        }\n        if (! found) {\n            throw new WorkflowNotFoundException();\n        }\n\n        // Use filename for label if there is no defined one\n        String label = extractLabel(cwlFile);\n        if (label == null) {\n            label = defaultLabel;\n        }\n\n        // Construct the rest of the workflow model\n        Workflow workflowModel = new Workflow(label, extractDoc(cwlFile), getInputs(cwlFile),\n                getOutputs(cwlFile), getSteps(cwlFile));\n\n        workflowModel.setCwltoolVersion(cwlTool.getVersion());\n\n        // Generate DOT graph\n        StringWriter graphWriter = new StringWriter();\n        ModelDotWriter dotWriter = new ModelDotWriter(graphWriter);\n        try {\n            dotWriter.writeGraph(workflowModel);\n            workflowModel.setVisualisationDot(graphWriter.toString());\n        } catch (IOException ex) {\n            logger.error(\"Failed to create DOT graph for workflow: \" + ex.getMessage());\n        }\n\n        return workflowModel;\n\n\n    }\n\n    \n    /**\n     * Gets the Workflow object from internal parsing.\n     * The size of the workflow file must be below the configured \n     * singleFileSizeLimit in the constructor/spring config.\n     * \n     * @param workflowFile The workflow file to be parsed\n     * @param packedWorkflowId The ID of the workflow object if the file is packed\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowNative(Path workflowFile, String packedWorkflowId) throws IOException {\n\n        // Check file size limit before parsing\n        long fileSizeBytes = Files.size(workflowFile);\n        if (fileSizeBytes <= singleFileSizeLimit) {\n        \ttry (InputStream in = Files.newInputStream(workflowFile)) {\n        \t\treturn parseWorkflowNative(in, packedWorkflowId, \n        \t\t\t\tworkflowFile.getName(workflowFile.getNameCount()-1).toString());\n        \t}\n        } else {\n            throw new IOException(\"File '\" + workflowFile.getFileName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(fileSizeBytes) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n\n    }\n\n    /**\n     * Create a workflow model using cwltool rdf output\n     * @param basicModel The basic workflow object created thus far\n     * @param workflowFile The workflow file to run cwltool on\n     * @return The constructed workflow object\n     */\n    public Workflow parseWorkflowWithCwltool(Workflow basicModel,\n                                             Path workflowFile,\n                                             Path workTree) throws CWLValidationException {\n        GitDetails gitDetails = basicModel.getRetrievedFrom();\n        String latestCommit = basicModel.getLastCommit();\n        String packedWorkflowID = gitDetails.getPackedId();\n\n        // Get paths to workflow\n        String url = basicModel.getIdentifier();\n        String workflowFileURI = workflowFile.toAbsolutePath().toUri().toString();\n        URI workTreeUri = workTree.toAbsolutePath().toUri();\n\t\tString localPath = workflowFileURI;\n        String gitPath = gitDetails.getPath();\n        if (packedWorkflowID != null) {\n            if (packedWorkflowID.charAt(0) != '#') {\n                localPath += \"#\";\n                gitPath += \"#\";\n            }\n            localPath += packedWorkflowID;\n            gitPath += packedWorkflowID;\n        }\n\n        // Get RDF representation from cwltool\n        if (!rdfService.graphExists(url)) {\n            String rdf = cwlTool.getRDF(localPath);\n            // Replace /tmp/123123 with permalink base \n            // NOTE: We do not just replace workflowFileURI, all referenced files will also get rewritten\n\t\t\trdf = rdf.replace(workTreeUri.toString(),\n                    \"https://w3id.org/cwl/view/git/\" + latestCommit + \"/\");\n            // Workaround for common-workflow-language/cwltool#427\n            rdf = rdf.replace(\"<rdfs:>\", \"<http://www.w3.org/2000/01/rdf-schema#>\");\n\n            // Create a workflow model from RDF representation\n            Model model = ModelFactory.createDefaultModel();\n            model.read(new ByteArrayInputStream(rdf.getBytes()), null, \"TURTLE\");\n\n            // Store the model\n            rdfService.storeModel(url, model);\n        }\n\n        // Base workflow details\n        String label = FilenameUtils.getName(url);\n        String doc = null;\n        ResultSet labelAndDoc = rdfService.getLabelAndDoc(url);\n        if (labelAndDoc.hasNext()) {\n            QuerySolution labelAndDocSoln = labelAndDoc.nextSolution();\n            if (labelAndDocSoln.contains(\"label\")) {\n                label = labelAndDocSoln.get(\"label\").toString();\n            }\n            if (labelAndDocSoln.contains(\"doc\")) {\n                doc = labelAndDocSoln.get(\"doc\").toString();\n            }\n        }\n\n        // Inputs\n        Map<String, CWLElement> wfInputs = new HashMap<>();\n        ResultSet inputs = rdfService.getInputs(url);\n        while (inputs.hasNext()) {\n            QuerySolution input = inputs.nextSolution();\n            String inputName = rdfService.stepNameFromURI(gitPath, input.get(\"name\").toString());\n\n            CWLElement wfInput = new CWLElement();\n            if (input.contains(\"type\")) {\n                String type;\n                if (input.get(\"type\").toString().equals(\"https://w3id.org/cwl/salad#array\")) {\n                    type = typeURIToString(input.get(\"items\").toString()) + \"[]\";\n                } else {\n                    type = typeURIToString(input.get(\"type\").toString());\n                }\n                if (input.contains(\"null\")) {\n                    type += \" (Optional)\";\n                }\n                wfInput.setType(type);\n            }\n            if (input.contains(\"format\")) {\n                String format = input.get(\"format\").toString();\n                setFormat(wfInput, format);\n            }\n            if (input.contains(\"label\")) {\n                wfInput.setLabel(input.get(\"label\").toString());\n            }\n            if (input.contains(\"doc\")) {\n                wfInput.setDoc(input.get(\"doc\").toString());\n            }\n            wfInputs.put(rdfService.labelFromName(inputName), wfInput);\n        }\n\n        // Outputs\n        Map<String, CWLElement> wfOutputs = new HashMap<>();\n        ResultSet outputs = rdfService.getOutputs(url);\n        while (outputs.hasNext()) {\n            QuerySolution output = outputs.nextSolution();\n            CWLElement wfOutput = new CWLElement();\n\n            String outputName = rdfService.stepNameFromURI(gitPath, output.get(\"name\").toString());\n            if (output.contains(\"type\")) {\n                String type;\n                if (output.get(\"type\").toString().equals(\"https://w3id.org/cwl/salad#array\")) {\n                    type = typeURIToString(output.get(\"items\").toString()) + \"[]\";\n                } else {\n                    type = typeURIToString(output.get(\"type\").toString());\n                }\n                if (output.contains(\"null\")) {\n                    type += \" (Optional)\";\n                }\n                wfOutput.setType(type);\n            }\n\n            if (output.contains(\"src\")) {\n                wfOutput.addSourceID(rdfService.stepNameFromURI(gitPath,\n                        output.get(\"src\").toString()));\n            }\n            if (output.contains(\"format\")) {\n                String format = output.get(\"format\").toString();\n                setFormat(wfOutput, format);\n            }\n            if (output.contains(\"label\")) {\n                wfOutput.setLabel(output.get(\"label\").toString());\n            }\n            if (output.contains(\"doc\")) {\n                wfOutput.setDoc(output.get(\"doc\").toString());\n            }\n            wfOutputs.put(rdfService.labelFromName(outputName), wfOutput);\n        }\n\n\n        // Steps\n        Map<String, CWLStep> wfSteps = new HashMap<>();\n        ResultSet steps = rdfService.getSteps(url);\n        while (steps.hasNext()) {\n            QuerySolution step = steps.nextSolution();\n            String uri = rdfService.stepNameFromURI(gitPath, step.get(\"step\").toString());\n            if (wfSteps.containsKey(uri)) {\n                // Already got step details, add extra source ID\n                if (step.contains(\"src\")) {\n                    CWLElement src = new CWLElement();\n                    src.addSourceID(rdfService.stepNameFromURI(gitPath, step.get(\"src\").toString()));\n                    wfSteps.get(uri).getSources().put(\n                            step.get(\"stepinput\").toString(), src);\n                } else if (step.contains(\"default\")) {\n                    CWLElement src = new CWLElement();\n                    src.setDefaultVal(rdfService.formatDefault(step.get(\"default\").toString()));\n                    wfSteps.get(uri).getSources().put(\n                            step.get(\"stepinput\").toString(), src);\n                }\n            } else {\n                // Add new step\n                CWLStep wfStep = new CWLStep();\n\n                IRI workflowPath = iriFactory.construct(url).resolve(\"./\");\n                IRI runPath = iriFactory.construct(step.get(\"run\").asResource().getURI());\n                wfStep.setRun(workflowPath.relativize(runPath).toString());\n                wfStep.setRunType(rdfService.strToRuntype(step.get(\"runtype\").toString()));\n\n                if (step.contains(\"src\")) {\n                    CWLElement src = new CWLElement();\n                    src.addSourceID(rdfService.stepNameFromURI(gitPath, step.get(\"src\").toString()));\n                    Map<String, CWLElement> srcList = new HashMap<>();\n                    srcList.put(rdfService.stepNameFromURI(gitPath,\n                            step.get(\"stepinput\").toString()), src);\n                    wfStep.setSources(srcList);\n                } else if (step.contains(\"default\")) {\n                    CWLElement src = new CWLElement();\n                    src.setDefaultVal(rdfService.formatDefault(step.get(\"default\").toString()));\n                    Map<String, CWLElement> srcList = new HashMap<>();\n                    srcList.put(rdfService.stepNameFromURI(gitPath,\n                            step.get(\"stepinput\").toString()), src);\n                    wfStep.setSources(srcList);\n                }\n                if (step.contains(\"label\")) {\n                    wfStep.setLabel(step.get(\"label\").toString());\n                }\n                if (step.contains(\"doc\")) {\n                    wfStep.setDoc(step.get(\"doc\").toString());\n                }\n                wfSteps.put(rdfService.labelFromName(uri), wfStep);\n            }\n        }\n        // Try to determine license\n        ResultSet licenseResult = rdfService.getLicense(url);\n        String licenseLink = null;\n        if (licenseResult.hasNext()) {\n        \tlicenseLink = licenseResult.next().get(\"license\").toString();\n        } else {\n        \t// Check for \"LICENSE\"-like files in root of git repo\n        \tfor (String licenseCandidate : new String[]{\"LICENSE\", \"LICENSE.txt\", \"LICENSE.md\"}) {\n        \t\t// FIXME: This might wrongly match lower-case \"license.txt\" in case-insensitive file systems\n        \t\t// but the URL would not work\n        \t\tif (Files.isRegularFile(workTree.resolve(licenseCandidate))) {\n        \t\t\t// Link to it by raw URL\n        \t\t\tlicenseLink = basicModel.getRetrievedFrom().getRawUrl(null, licenseCandidate);\n        \t\t}\n\t\t\t}\n        }\n\n        // Docker link\n        ResultSet dockerResult = rdfService.getDockerLink(url);\n        String dockerLink = null;\n        if (dockerResult.hasNext()) {\n            QuerySolution docker = dockerResult.nextSolution();\n            if (docker.contains(\"pull\")) {\n                dockerLink = DockerService.getDockerHubURL(docker.get(\"pull\").toString());\n            } else {\n                dockerLink = \"true\";\n            }\n        }\n\n        // Create workflow model\n        Workflow workflowModel = new Workflow(label, doc,\n                wfInputs, wfOutputs, wfSteps, \n                dockerLink, licenseLink);\n\n        // Generate DOT graph\n        StringWriter graphWriter = new StringWriter();\n        RDFDotWriter RDFDotWriter = new RDFDotWriter(graphWriter, rdfService, gitPath);\n        try {\n            RDFDotWriter.writeGraph(url);\n            workflowModel.setVisualisationDot(graphWriter.toString());\n        } catch (IOException ex) {\n            logger.error(\"Failed to create DOT graph for workflow: \" + ex.getMessage());\n        }\n\n\n        return workflowModel;\n\n    }\n\n    /**\n     * Get an overview of a workflow\n     * @param file A file, potentially a workflow\n     * @return A constructed WorkflowOverview of the workflow\n     * @throws IOException Any API errors which may have occurred\n     */\n    public WorkflowOverview getWorkflowOverview(File file) throws IOException {\n\n        // Get the content of this file from Github\n        long fileSizeBytes = file.length();\n\n        // Check file size limit before parsing\n        if (fileSizeBytes <= singleFileSizeLimit) {\n\n            // Parse file as yaml\n            JsonNode cwlFile = yamlPathToJson(file.toPath());\n\n            // If the CWL file is packed there can be multiple workflows in a file\n            int packedCount = 0;\n            if (cwlFile.has(DOC_GRAPH)) {\n                // Packed CWL, find the first subelement which is a workflow and take it\n                for (JsonNode jsonNode : cwlFile.get(DOC_GRAPH)) {\n                    if (extractProcess(jsonNode) == CWLProcess.WORKFLOW) {\n                        cwlFile = jsonNode;\n                        packedCount++;\n                    }\n                }\n                if (packedCount > 1) {\n                    return new WorkflowOverview(\"/\" + file.getName(), \"Packed file\",\n                            \"contains \" + packedCount + \" workflows\");\n                }\n            }\n\n            // Can only make an overview if this is a workflow\n            if (extractProcess(cwlFile) == CWLProcess.WORKFLOW) {\n                // Use filename for label if there is no defined one\n                String label = extractLabel(cwlFile);\n                if (label == null) {\n                    label = file.getName();\n                }\n\n                // Return the constructed overview\n                return new WorkflowOverview(\"/\" + file.getName(), label, extractDoc(cwlFile));\n            } else {\n                // Return null if not a workflow file\n                return null;\n            }\n        } else {\n            throw new IOException(\"File '\" + file.getName() +  \"' is over singleFileSizeLimit - \" +\n                    FileUtils.byteCountToDisplaySize(fileSizeBytes) + \"/\" +\n                    FileUtils.byteCountToDisplaySize(singleFileSizeLimit));\n        }\n\n    }\n\n    /**\n     * Set the format for an input or output, handling ontologies\n     * @param inputOutput The input or output CWL Element\n     * @param format The format URI\n     */\n    private void setFormat(CWLElement inputOutput, String format) {\n        inputOutput.setFormat(format);\n        try {\n            if (!rdfService.ontPropertyExists(format)) {\n                Model ontModel = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM);\n                ontModel.read(format, null, \"RDF/XML\");\n                rdfService.addToOntologies(ontModel);\n            }\n            String formatLabel = rdfService.getOntLabel(format);\n            inputOutput.setType(inputOutput.getType() + \" [\" + formatLabel + \"]\");\n        } catch (RiotException ex) {\n            inputOutput.setType(inputOutput.getType() + \" [format]\");\n        }\n    }\n\n    /**\n     * Convert RDF URI for a type to a name\n     * @param uri The URI for the type\n     * @return The human readable name for that type\n     */\n    private String typeURIToString(String uri) {\n        switch (uri) {\n            case \"http://www.w3.org/2001/XMLSchema#string\":\n                return \"String\";\n            case \"https://w3id.org/cwl/cwl#File\":\n                return \"File\";\n            case \"http://www.w3.org/2001/XMLSchema#boolean\":\n                return \"Boolean\";\n            case \"http://www.w3.org/2001/XMLSchema#int\":\n                return \"Integer\";\n            case \"http://www.w3.org/2001/XMLSchema#double\":\n                return \"Double\";\n            case \"http://www.w3.org/2001/XMLSchema#float\":\n                return \"Float\";\n            case \"http://www.w3.org/2001/XMLSchema#long\":\n                return \"Long\";\n            case \"https://w3id.org/cwl/cwl#Directory\":\n                return \"Directory\";\n            default:\n                return uri;\n        }\n    }\n\n    /**\n     * Converts a yaml String to JsonNode\n     * @param path A Path to a file containing the yaml content\n     * @return A JsonNode with the content of the document\n     * @throws IOException \n     */\n    private JsonNode yamlPathToJson(Path path) throws IOException {\n        Yaml reader = new Yaml(new SafeConstructor());\n        ObjectMapper mapper = new ObjectMapper();\n        try (InputStream in = Files.newInputStream(path)) {\n        \treturn mapper.valueToTree(reader.load(in));\n        }\n    }\n\n    \n    /**\n     * Converts a yaml String to JsonNode\n     * @param yamlStream An InputStream containing the yaml content\n     * @return A JsonNode with the content of the document\n     */\n    private JsonNode yamlStreamToJson(InputStream yamlStream) {\n        Yaml reader = new Yaml(new SafeConstructor());\n        ObjectMapper mapper = new ObjectMapper();\n\t\treturn mapper.valueToTree(reader.load(yamlStream));\n    }\n\n    /**\n     * Extract the label from a node\n     * @param node The node to have the label extracted from\n     * @return The string for the label of the node\n     */\n    private String extractLabel(JsonNode node) {\n        if (node != null && node.has(LABEL)) {\n            return node.get(LABEL).asText();\n        }\n        return null;\n    }\n\n    /**\n     * Extract the class parameter from a node representing a document\n     * @param rootNode The root node of a cwl document\n     * @return Which process this document represents\n     */\n    private CWLProcess extractProcess(JsonNode rootNode) {\n        if (rootNode != null) {\n            if (rootNode.has(CLASS)) {\n                switch(rootNode.get(CLASS).asText()) {\n                    case WORKFLOW:\n                        return CWLProcess.WORKFLOW;\n                    case COMMANDLINETOOL:\n                        return CWLProcess.COMMANDLINETOOL;\n                    case EXPRESSIONTOOL:\n                        return CWLProcess.EXPRESSIONTOOL;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the steps for a particular document\n     * @param cwlDoc The document to get steps for\n     * @return A map of step IDs and details related to them\n     */\n    private Map<String, CWLStep> getSteps(JsonNode cwlDoc) {\n        if (cwlDoc != null && cwlDoc.has(STEPS)) {\n            Map<String, CWLStep> returnMap = new HashMap<>();\n\n            JsonNode steps = cwlDoc.get(STEPS);\n            if (steps.getClass() == ArrayNode.class) {\n                // Explicit ID and other fields within each input list\n                for (JsonNode step : steps) {\n                    CWLStep stepObject = new CWLStep(extractLabel(step), extractDoc(step),\n                            extractRun(step), getInputs(step));\n                    returnMap.put(extractID(step), stepObject);\n                }\n            } else if (steps.getClass() == ObjectNode.class) {\n                // ID is the key of each object\n                Iterator<Map.Entry<String, JsonNode>> iterator = steps.fields();\n                while (iterator.hasNext()) {\n                    Map.Entry<String, JsonNode> stepNode = iterator.next();\n                    JsonNode stepJson = stepNode.getValue();\n                    CWLStep stepObject = new CWLStep(extractLabel(stepJson), extractDoc(stepJson),\n                            extractRun(stepJson), getInputs(stepJson));\n                    returnMap.put(stepNode.getKey(), stepObject);\n                }\n            }\n\n            return returnMap;\n        }\n        return null;\n    }\n\n    /**\n     * Get a the inputs for a particular document\n     * @param cwlDoc The document to get inputs for\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getInputs(JsonNode cwlDoc) {\n        if (cwlDoc != null) {\n            if (cwlDoc.has(INPUTS)) {\n                // For all version workflow inputs/outputs and draft steps\n                return getInputsOutputs(cwlDoc.get(INPUTS));\n            } else if (cwlDoc.has(IN)) {\n                // For V1.0 steps\n                return getStepInputsOutputs(cwlDoc.get(IN));\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the outputs for a particular document\n     * @param cwlDoc The document to get outputs for\n     * @return A map of output IDs and details related to them\n     */\n    private Map<String, CWLElement> getOutputs(JsonNode cwlDoc) {\n        if (cwlDoc != null) {\n            // For all version workflow inputs/outputs and draft steps\n            if (cwlDoc.has(OUTPUTS)) {\n                return getInputsOutputs(cwlDoc.get(OUTPUTS));\n            }\n            // Outputs are not gathered for v1 steps\n        }\n        return null;\n    }\n\n    /**\n     * Get inputs or outputs from an in or out node\n     * @param inOut The in or out node\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getStepInputsOutputs(JsonNode inOut) {\n        Map<String, CWLElement> returnMap = new HashMap<>();\n\n        if (inOut.getClass() == ArrayNode.class) {\n            // array<WorkflowStepInput>\n            for (JsonNode inOutNode : inOut) {\n                if (inOutNode.getClass() == ObjectNode.class) {\n                    CWLElement inputOutput = new CWLElement();\n                    List<String> sources = extractSource(inOutNode);\n                    if (sources.size() > 0) {\n                        for (String source : sources) {\n                            inputOutput.addSourceID(stepIDFromSource(source));\n                        }\n                    } else {\n                        inputOutput.setDefaultVal(extractDefault(inOutNode));\n                    }\n                    returnMap.put(extractID(inOutNode), inputOutput);\n                }\n            }\n        } else if (inOut.getClass() == ObjectNode.class) {\n            // map<WorkflowStepInput.id, WorkflowStepInput.source>\n            Iterator<Map.Entry<String, JsonNode>> iterator = inOut.fields();\n            while (iterator.hasNext()) {\n                Map.Entry<String, JsonNode> inOutNode = iterator.next();\n                CWLElement inputOutput = new CWLElement();\n                if (inOutNode.getValue().getClass() == ObjectNode.class) {\n                    JsonNode properties = inOutNode.getValue();\n                    if (properties.has(SOURCE)) {\n                        inputOutput.addSourceID(stepIDFromSource(properties.get(SOURCE).asText()));\n                    } else {\n                        inputOutput.setDefaultVal(extractDefault(properties));\n                    }\n                } else if (inOutNode.getValue().getClass() == ArrayNode.class) {\n                    for (JsonNode key : inOutNode.getValue()) {\n                        inputOutput.addSourceID(stepIDFromSource(key.asText()));\n                    }\n                } else {\n                    inputOutput.addSourceID(stepIDFromSource(inOutNode.getValue().asText()));\n                }\n                returnMap.put(inOutNode.getKey(), inputOutput);\n            }\n        }\n\n        return returnMap;\n    }\n\n    /**\n     * Get inputs or outputs from an inputs or outputs node\n     * @param inputsOutputs The inputs or outputs node\n     * @return A map of input IDs and details related to them\n     */\n    private Map<String, CWLElement> getInputsOutputs(JsonNode inputsOutputs) {\n        Map<String, CWLElement> returnMap = new HashMap<>();\n\n        if (inputsOutputs.getClass() == ArrayNode.class) {\n            // Explicit ID and other fields within each list\n            for (JsonNode inputOutput : inputsOutputs) {\n                String id = inputOutput.get(ID).asText();\n                if (id.charAt(0) == '#') {\n                    id = id.substring(1);\n                }\n                returnMap.put(id, getDetails(inputOutput));\n            }\n        } else if (inputsOutputs.getClass() == ObjectNode.class) {\n            // ID is the key of each object\n            Iterator<Map.Entry<String, JsonNode>> iterator = inputsOutputs.fields();\n            while (iterator.hasNext()) {\n                Map.Entry<String, JsonNode> inputOutputNode = iterator.next();\n                returnMap.put(inputOutputNode.getKey(), getDetails(inputOutputNode.getValue()));\n            }\n        }\n\n        return returnMap;\n    }\n\n    /**\n     * Gets the details of an input or output\n     * @param inputOutput The node of the particular input or output\n     * @return An CWLElement object with the label, doc and type extracted\n     */\n    private CWLElement getDetails(JsonNode inputOutput) {\n        if (inputOutput != null) {\n            CWLElement details = new CWLElement();\n\n            // Shorthand notation \"id: type\" - no label/doc/other params\n            if (inputOutput.getClass() == TextNode.class) {\n                details.setType(inputOutput.asText());\n            } else {\n                details.setLabel(extractLabel(inputOutput));\n                details.setDoc(extractDoc(inputOutput));\n                extractSource(inputOutput).forEach(details::addSourceID);\n                details.setDefaultVal(extractDefault(inputOutput));\n\n                // Type is only for inputs\n                if (inputOutput.has(TYPE)) {\n                    details.setType(extractTypes(inputOutput.get(TYPE)));\n                }\n            }\n\n            return details;\n        }\n        return null;\n    }\n\n    /**\n     * Extract the id from a node\n     * @param node The node to have the id extracted from\n     * @return The string for the id of the node\n     */\n    private String extractID(JsonNode node) {\n        if (node != null && node.has(ID)) {\n            String id = node.get(ID).asText();\n            if (id.startsWith(\"#\")) {\n                return id.substring(1);\n            }\n            return id;\n        }\n        return null;\n    }\n\n    /**\n     * Extract the default value from a node\n     * @param node The node to have the label extracted from\n     * @return The string for the default value of the node\n     */\n    private String extractDefault(JsonNode node) {\n        if (node != null && node.has(DEFAULT)) {\n            if (node.get(DEFAULT).has(LOCATION)) {\n                return node.get(DEFAULT).get(LOCATION).asText();\n            } else {\n                return \"\\\\\\\"\" + node.get(DEFAULT).asText() + \"\\\\\\\"\";\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the source or outputSource from a node\n     * @param node The node to have the sources extracted from\n     * @return A list of strings for the sources\n     */\n    private List<String> extractSource(JsonNode node) {\n        if (node != null) {\n            List<String> sources = new ArrayList<String>();\n            JsonNode sourceNode = null;\n\n            // outputSource and source treated the same\n            if (node.has(OUTPUT_SOURCE)) {\n                sourceNode = node.get(OUTPUT_SOURCE);\n            } else if (node.has(SOURCE)) {\n                sourceNode = node.get(SOURCE);\n            }\n\n            if (sourceNode != null) {\n                // Single source\n                if (sourceNode.getClass() == TextNode.class) {\n                    sources.add(stepIDFromSource(sourceNode.asText()));\n                }\n                // Can be an array of multiple sources\n                if (sourceNode.getClass() == ArrayNode.class) {\n                    for (JsonNode source : sourceNode) {\n                        sources.add(stepIDFromSource(source.asText()));\n                    }\n                }\n            }\n\n            return sources;\n        }\n        return null;\n    }\n\n    /**\n     * Gets just the step ID from source of format 'stepID</ or .>outputID'\n     * @param source The source\n     * @return The step ID\n     */\n    private String stepIDFromSource(String source) {\n        if (source != null && source.length() > 0) {\n            // Strip leading # if it exists\n            if (source.charAt(0) == '#') {\n                source = source.substring(1);\n            }\n\n            // Draft 3/V1 notation is 'stepID/outputID'\n            int slashSplit = source.indexOf(\"/\");\n            if (slashSplit != -1) {\n                source = source.substring(0, slashSplit);\n            } else {\n                // Draft 2 notation was 'stepID.outputID'\n                int dotSplit = source.indexOf(\".\");\n                if (dotSplit != -1) {\n                    source = source.substring(0, dotSplit);\n                }\n            }\n        }\n        return source;\n    }\n\n    /**\n     * Extract the doc or description from a node\n     * @param node The node to have the doc/description extracted from\n     * @return The string for the doc/description of the node\n     */\n    private String extractDoc(JsonNode node) {\n        if (node != null) {\n            if (node.has(DOC)) {\n                return node.get(DOC).asText();\n            } else if (node.has(DESCRIPTION)) {\n                // This is to support older standards of cwl which use description instead of doc\n                return node.get(DESCRIPTION).asText();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the types from a node representing inputs or outputs\n     * @param typeNode The root node representing an input or output\n     * @return A string with the types listed\n     */\n    private String extractTypes(JsonNode typeNode) {\n        if (typeNode != null) {\n            if (typeNode.getClass() == TextNode.class) {\n                // Single type\n                return typeNode.asText();\n            } else if (typeNode.getClass() == ArrayNode.class) {\n                // Multiple types, build a string to represent them\n                StringBuilder typeDetails = new StringBuilder();\n                boolean optional = false;\n                for (JsonNode type : typeNode) {\n                    if (type.getClass() == TextNode.class) {\n                        // This is a simple type\n                        if (type.asText().equals(\"null\")) {\n                            // null as a type means this field is optional\n                            optional = true;\n                        } else {\n                            // Add a simple type to the string\n                            typeDetails.append(type.asText());\n                            typeDetails.append(\", \");\n                        }\n                    } else if (typeNode.getClass() == ArrayNode.class) {\n                        // This is a verbose type with sub-fields broken down into type: and other params\n                        if (type.get(TYPE).asText().equals(ARRAY)) {\n                            typeDetails.append(type.get(ARRAY_ITEMS).asText());\n                            typeDetails.append(\"[], \");\n                        } else {\n                            typeDetails.append(type.get(TYPE).asText());\n                        }\n                    }\n                }\n\n                // Trim off excessive separators\n                if (typeDetails.length() > 1) {\n                    typeDetails.setLength(typeDetails.length() - 2);\n                }\n\n                // Add optional if null was included in the multiple types\n                if (optional) typeDetails.append(\"?\");\n\n                // Set the type to the constructed string\n                return typeDetails.toString();\n\n            } else if (typeNode.getClass() == ObjectNode.class) {\n                // Type: array and items:\n                if (typeNode.has(ARRAY_ITEMS)) {\n                    return typeNode.get(ARRAY_ITEMS).asText() + \"[]\";\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Extract the run parameter from a node representing a step\n     * @param stepNode The root node of a step\n     * @return A string with the run parameter if it exists\n     */\n    private String extractRun(JsonNode stepNode) {\n        if (stepNode != null) {\n            if (stepNode.has(RUN)) {\n                return stepNode.get(RUN).asText();\n            }\n        }\n        return null;\n    }\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700299,
    "RELATED_CWE": [
      "CWE-94",
      "CWE-78",
      "CWE-97"
    ]
  }
]