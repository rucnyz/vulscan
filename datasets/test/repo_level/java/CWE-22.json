[
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/*\n * Copyright 2002-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.web.servlet;\n\nimport java.io.IOException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.util.AntPathMatcher;\nimport org.springframework.util.PathMatcher;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.context.support.ServletContextResource;\n\n/**\n * Simple servlet that can expose an internal resource, including a\n * default URL if the specified resource is not found. An alternative,\n * for example, to trying and catching exceptions when using JSP include.\n *\n * <p>A further usage of this servlet is the ability to apply last-modified\n * timestamps to quasi-static resources (typically JSPs). This can happen\n * as bridge to parameter-specified resources, or as proxy for a specific\n * target resource (or a list of specific target resources to combine).\n *\n * <p>A typical usage would map a URL like \"/ResourceServlet\" onto an instance\n * of this servlet, and use the \"JSP include\" action to include this URL,\n * with the \"resource\" parameter indicating the actual target path in the WAR.\n *\n * <p>The {@code defaultUrl} property can be set to the internal\n * resource path of a default URL, to be rendered when the target resource\n * is not found or not specified in the first place.\n *\n * <p>The \"resource\" parameter and the {@code defaultUrl} property can\n * also specify a list of target resources to combine. Those resources will be\n * included one by one to build the response. If last-modified determination\n * is active, the newest timestamp among those files will be used.\n *\n * <p>The {@code allowedResources} property can be set to a URL\n * pattern of resources that should be available via this servlet.\n * If not set, any target resource can be requested, including resources\n * in the WEB-INF directory!\n *\n * <p>If using this servlet for direct access rather than via includes,\n * the {@code contentType} property should be specified to apply a\n * proper content type. Note that a content type header in the target JSP will\n * be ignored when including the resource via a RequestDispatcher include.\n *\n * <p>To apply last-modified timestamps for the target resource, set the\n * {@code applyLastModified} property to true. This servlet will then\n * return the file timestamp of the target resource as last-modified value,\n * falling back to the startup time of this servlet if not retrievable.\n *\n * <p>Note that applying the last-modified timestamp in the above fashion\n * just makes sense if the target resource does not generate content that\n * depends on the HttpSession or cookies; it is just allowed to evaluate\n * request parameters.\n *\n * <p>A typical case for such last-modified usage is a JSP that just makes\n * minimal usage of basic means like includes or message resolution to\n * build quasi-static content. Regenerating such content on every request\n * is unnecessary; it can be cached as long as the file hasn't changed.\n *\n * <p>Note that this servlet will apply the last-modified timestamp if you\n * tell it to do so: It's your decision whether the content of the target\n * resource can be cached in such a fashion. Typical use cases are helper\n * resources that are not fronted by a controller, like JavaScript files\n * that are generated by a JSP (without depending on the HttpSession).\n *\n * @author Juergen Hoeller\n * @author Rod Johnson\n * @see #setDefaultUrl\n * @see #setAllowedResources\n * @see #setApplyLastModified\n * @deprecated as of Spring 4.3.5, in favor of\n * {@link org.springframework.web.servlet.resource.ResourceHttpRequestHandler}\n */\n@SuppressWarnings(\"serial\")\n@Deprecated\npublic class ResourceServlet extends HttpServletBean {\n\n\t/**\n\t * Any number of these characters are considered delimiters\n\t * between multiple resource paths in a single String value.\n\t */\n\tpublic static final String RESOURCE_URL_DELIMITERS = \",; \\t\\n\";\n\n\t/**\n\t * Name of the parameter that must contain the actual resource path.\n\t */\n\tpublic static final String RESOURCE_PARAM_NAME = \"resource\";\n\n\n\tprivate String defaultUrl;\n\n\tprivate String allowedResources;\n\n\tprivate String contentType;\n\n\tprivate boolean applyLastModified = false;\n\n\tprivate PathMatcher pathMatcher;\n\n\tprivate long startupTime;\n\n\n\t/**\n\t * Set the URL within the current web application from which to\n\t * include content if the requested path isn't found, or if none\n\t * is specified in the first place.\n\t * <p>If specifying multiple URLs, they will be included one by one\n\t * to build the response. If last-modified determination is active,\n\t * the newest timestamp among those files will be used.\n\t * @see #setApplyLastModified\n\t */\n\tpublic void setDefaultUrl(String defaultUrl) {\n\t\tthis.defaultUrl = defaultUrl;\n\t}\n\n\t/**\n\t * Set allowed resources as URL pattern, e.g. \"/WEB-INF/res/*.jsp\",\n\t * The parameter can be any Ant-style pattern parsable by AntPathMatcher.\n\t * @see org.springframework.util.AntPathMatcher\n\t */\n\tpublic void setAllowedResources(String allowedResources) {\n\t\tthis.allowedResources = allowedResources;\n\t}\n\n\t/**\n\t * Set the content type of the target resource (typically a JSP).\n\t * Default is none, which is appropriate when including resources.\n\t * <p>For directly accessing resources, for example to leverage this\n\t * servlet's last-modified support, specify a content type here.\n\t * Note that a content type header in the target JSP will be ignored\n\t * when including the resource via a RequestDispatcher include.\n\t */\n\tpublic void setContentType(String contentType) {\n\t\tthis.contentType = contentType;\n\t}\n\n\t/**\n\t * Set whether to apply the file timestamp of the target resource\n\t * as last-modified value. Default is \"false\".\n\t * <p>This is mainly intended for JSP targets that don't generate\n\t * session-specific or database-driven content: Such files can be\n\t * cached by the browser as long as the last-modified timestamp\n\t * of the JSP file doesn't change.\n\t * <p>This will only work correctly with expanded WAR files that\n\t * allow access to the file timestamps. Else, the startup time\n\t * of this servlet is returned.\n\t */\n\tpublic void setApplyLastModified(boolean applyLastModified) {\n\t\tthis.applyLastModified = applyLastModified;\n\t}\n\n\n\t/**\n\t * Remember the startup time, using no last-modified time before it.\n\t */\n\t@Override\n\tprotected void initServletBean() {\n\t\tthis.pathMatcher = getPathMatcher();\n\t\tthis.startupTime = System.currentTimeMillis();\n\t}\n\n\t/**\n\t * Return a {@link PathMatcher} to use for matching the \"allowedResources\" URL pattern.\n\t * <p>The default is {@link AntPathMatcher}.\n\t * @see #setAllowedResources\n\t * @see org.springframework.util.AntPathMatcher\n\t */\n\tprotected PathMatcher getPathMatcher() {\n\t\treturn new AntPathMatcher();\n\t}\n\n\n\t/**\n\t * Determine the URL of the target resource and include it.\n\t * @see #determineResourceUrl\n\t */\n\t@Override\n\tprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\t// Determine URL of resource to include...\n\t\tString resourceUrl = determineResourceUrl(request);\n\n\t\tif (resourceUrl != null) {\n\t\t\ttry {\n\t\t\t\tdoInclude(request, response, resourceUrl);\n\t\t\t}\n\t\t\tcatch (ServletException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Failed to include content of resource [\" + resourceUrl + \"]\", ex);\n\t\t\t\t}\n\t\t\t\t// Try including default URL if appropriate.\n\t\t\t\tif (!includeDefaultUrl(request, response)) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Failed to include content of resource [\" + resourceUrl + \"]\", ex);\n\t\t\t\t}\n\t\t\t\t// Try including default URL if appropriate.\n\t\t\t\tif (!includeDefaultUrl(request, response)) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No resource URL specified -> try to include default URL.\n\t\telse if (!includeDefaultUrl(request, response)) {\n\t\t\tthrow new ServletException(\"No target resource URL found for request\");\n\t\t}\n\t}\n\n\t/**\n\t * Determine the URL of the target resource of this request.\n\t * <p>Default implementation returns the value of the \"resource\" parameter.\n\t * Can be overridden in subclasses.\n\t * @param request current HTTP request\n\t * @return the URL of the target resource, or {@code null} if none found\n\t * @see #RESOURCE_PARAM_NAME\n\t */\n\tprotected String determineResourceUrl(HttpServletRequest request) {\n\t\treturn request.getParameter(RESOURCE_PARAM_NAME);\n\t}\n\n\t/**\n\t * Include the specified default URL, if appropriate.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @return whether a default URL was included\n\t * @throws ServletException if thrown by the RequestDispatcher\n\t * @throws IOException if thrown by the RequestDispatcher\n\t */\n\tprivate boolean includeDefaultUrl(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\n\t\tif (this.defaultUrl == null) {\n\t\t\treturn false;\n\t\t}\n\t\tdoInclude(request, response, this.defaultUrl);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Include the specified resource via the RequestDispatcher.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param resourceUrl the URL of the target resource\n\t * @throws ServletException if thrown by the RequestDispatcher\n\t * @throws IOException if thrown by the RequestDispatcher\n\t */\n\tprivate void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n\t\t}\n\n\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (String url : resourceUrls) {\n\t\t\t// Check whether URL matches allowed resources\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, url)) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + url +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + url + \"]\");\n\t\t\t}\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(url);\n\t\t\trd.include(request, response);\n\t\t}\n\t}\n\n\t/**\n\t * Return the last-modified timestamp of the file that corresponds\n\t * to the target resource URL (i.e. typically the request \".jsp\" file).\n\t * Will simply return -1 if \"applyLastModified\" is false (the default).\n\t * <p>Returns no last-modified date before the startup time of this servlet,\n\t * to allow for message resolution etc that influences JSP contents,\n\t * assuming that those background resources might have changed on restart.\n\t * <p>Returns the startup time of this servlet if the file that corresponds\n\t * to the target resource URL couldn't be resolved (for example, because\n\t * the WAR is not expanded).\n\t * @see #determineResourceUrl\n\t * @see #getFileTimestamp\n\t */\n\t@Override\n\tprotected final long getLastModified(HttpServletRequest request) {\n\t\tif (this.applyLastModified) {\n\t\t\tString resourceUrl = determineResourceUrl(request);\n\t\t\tif (resourceUrl == null) {\n\t\t\t\tresourceUrl = this.defaultUrl;\n\t\t\t}\n\t\t\tif (resourceUrl != null) {\n\t\t\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\t\t\tlong latestTimestamp = -1;\n\t\t\t\tfor (String url : resourceUrls) {\n\t\t\t\t\tlong timestamp = getFileTimestamp(url);\n\t\t\t\t\tif (timestamp > latestTimestamp) {\n\t\t\t\t\t\tlatestTimestamp = timestamp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (latestTimestamp > this.startupTime ? latestTimestamp : this.startupTime);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Return the file timestamp for the given resource.\n\t * @param resourceUrl the URL of the resource\n\t * @return the file timestamp in milliseconds, or -1 if not determinable\n\t */\n\tprotected long getFileTimestamp(String resourceUrl) {\n\t\tServletContextResource resource = new ServletContextResource(getServletContext(), resourceUrl);\n\t\ttry {\n\t\t\tlong lastModifiedTime = resource.lastModified();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Last-modified timestamp of \" + resource + \" is \" + lastModifiedTime);\n\t\t\t}\n\t\t\treturn lastModifiedTime;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Couldn't retrieve last-modified timestamp of \" + resource +\n\t\t\t\t\t\t\" - using ResourceServlet startup time\");\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200182,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/*\n * Copyright 2002-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.web.servlet;\n\nimport java.io.IOException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.util.AntPathMatcher;\nimport org.springframework.util.PathMatcher;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.context.support.ServletContextResource;\n\n/**\n * Simple servlet that can expose an internal resource, including a\n * default URL if the specified resource is not found. An alternative,\n * for example, to trying and catching exceptions when using JSP include.\n *\n * <p>A further usage of this servlet is the ability to apply last-modified\n * timestamps to quasi-static resources (typically JSPs). This can happen\n * as bridge to parameter-specified resources, or as proxy for a specific\n * target resource (or a list of specific target resources to combine).\n *\n * <p>A typical usage would map a URL like \"/ResourceServlet\" onto an instance\n * of this servlet, and use the \"JSP include\" action to include this URL,\n * with the \"resource\" parameter indicating the actual target path in the WAR.\n *\n * <p>The {@code defaultUrl} property can be set to the internal\n * resource path of a default URL, to be rendered when the target resource\n * is not found or not specified in the first place.\n *\n * <p>The \"resource\" parameter and the {@code defaultUrl} property can\n * also specify a list of target resources to combine. Those resources will be\n * included one by one to build the response. If last-modified determination\n * is active, the newest timestamp among those files will be used.\n *\n * <p>The {@code allowedResources} property can be set to a URL\n * pattern of resources that should be available via this servlet.\n * If not set, any target resource can be requested, including resources\n * in the WEB-INF directory!\n *\n * <p>If using this servlet for direct access rather than via includes,\n * the {@code contentType} property should be specified to apply a\n * proper content type. Note that a content type header in the target JSP will\n * be ignored when including the resource via a RequestDispatcher include.\n *\n * <p>To apply last-modified timestamps for the target resource, set the\n * {@code applyLastModified} property to true. This servlet will then\n * return the file timestamp of the target resource as last-modified value,\n * falling back to the startup time of this servlet if not retrievable.\n *\n * <p>Note that applying the last-modified timestamp in the above fashion\n * just makes sense if the target resource does not generate content that\n * depends on the HttpSession or cookies; it is just allowed to evaluate\n * request parameters.\n *\n * <p>A typical case for such last-modified usage is a JSP that just makes\n * minimal usage of basic means like includes or message resolution to\n * build quasi-static content. Regenerating such content on every request\n * is unnecessary; it can be cached as long as the file hasn't changed.\n *\n * <p>Note that this servlet will apply the last-modified timestamp if you\n * tell it to do so: It's your decision whether the content of the target\n * resource can be cached in such a fashion. Typical use cases are helper\n * resources that are not fronted by a controller, like JavaScript files\n * that are generated by a JSP (without depending on the HttpSession).\n *\n * @author Juergen Hoeller\n * @author Rod Johnson\n * @see #setDefaultUrl\n * @see #setAllowedResources\n * @see #setApplyLastModified\n * @deprecated as of Spring 4.3.5, in favor of\n * {@link org.springframework.web.servlet.resource.ResourceHttpRequestHandler}\n */\n@SuppressWarnings(\"serial\")\n@Deprecated\npublic class ResourceServlet extends HttpServletBean {\n\n\t/**\n\t * Any number of these characters are considered delimiters\n\t * between multiple resource paths in a single String value.\n\t */\n\tpublic static final String RESOURCE_URL_DELIMITERS = \",; \\t\\n\";\n\n\t/**\n\t * Name of the parameter that must contain the actual resource path.\n\t */\n\tpublic static final String RESOURCE_PARAM_NAME = \"resource\";\n\n\n\tprivate String defaultUrl;\n\n\tprivate String allowedResources;\n\n\tprivate String contentType;\n\n\tprivate boolean applyLastModified = false;\n\n\tprivate PathMatcher pathMatcher;\n\n\tprivate long startupTime;\n\n\n\t/**\n\t * Set the URL within the current web application from which to\n\t * include content if the requested path isn't found, or if none\n\t * is specified in the first place.\n\t * <p>If specifying multiple URLs, they will be included one by one\n\t * to build the response. If last-modified determination is active,\n\t * the newest timestamp among those files will be used.\n\t * @see #setApplyLastModified\n\t */\n\tpublic void setDefaultUrl(String defaultUrl) {\n\t\tthis.defaultUrl = defaultUrl;\n\t}\n\n\t/**\n\t * Set allowed resources as URL pattern, e.g. \"/WEB-INF/res/*.jsp\",\n\t * The parameter can be any Ant-style pattern parsable by AntPathMatcher.\n\t * @see org.springframework.util.AntPathMatcher\n\t */\n\tpublic void setAllowedResources(String allowedResources) {\n\t\tthis.allowedResources = allowedResources;\n\t}\n\n\t/**\n\t * Set the content type of the target resource (typically a JSP).\n\t * Default is none, which is appropriate when including resources.\n\t * <p>For directly accessing resources, for example to leverage this\n\t * servlet's last-modified support, specify a content type here.\n\t * Note that a content type header in the target JSP will be ignored\n\t * when including the resource via a RequestDispatcher include.\n\t */\n\tpublic void setContentType(String contentType) {\n\t\tthis.contentType = contentType;\n\t}\n\n\t/**\n\t * Set whether to apply the file timestamp of the target resource\n\t * as last-modified value. Default is \"false\".\n\t * <p>This is mainly intended for JSP targets that don't generate\n\t * session-specific or database-driven content: Such files can be\n\t * cached by the browser as long as the last-modified timestamp\n\t * of the JSP file doesn't change.\n\t * <p>This will only work correctly with expanded WAR files that\n\t * allow access to the file timestamps. Else, the startup time\n\t * of this servlet is returned.\n\t */\n\tpublic void setApplyLastModified(boolean applyLastModified) {\n\t\tthis.applyLastModified = applyLastModified;\n\t}\n\n\n\t/**\n\t * Remember the startup time, using no last-modified time before it.\n\t */\n\t@Override\n\tprotected void initServletBean() {\n\t\tthis.pathMatcher = getPathMatcher();\n\t\tthis.startupTime = System.currentTimeMillis();\n\t}\n\n\t/**\n\t * Return a {@link PathMatcher} to use for matching the \"allowedResources\" URL pattern.\n\t * <p>The default is {@link AntPathMatcher}.\n\t * @see #setAllowedResources\n\t * @see org.springframework.util.AntPathMatcher\n\t */\n\tprotected PathMatcher getPathMatcher() {\n\t\treturn new AntPathMatcher();\n\t}\n\n\n\t/**\n\t * Determine the URL of the target resource and include it.\n\t * @see #determineResourceUrl\n\t */\n\t@Override\n\tprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\t// Determine URL of resource to include...\n\t\tString resourceUrl = determineResourceUrl(request);\n\n\t\tif (resourceUrl != null) {\n\t\t\ttry {\n\t\t\t\tdoInclude(request, response, resourceUrl);\n\t\t\t}\n\t\t\tcatch (ServletException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Failed to include content of resource [\" + resourceUrl + \"]\", ex);\n\t\t\t\t}\n\t\t\t\t// Try including default URL if appropriate.\n\t\t\t\tif (!includeDefaultUrl(request, response)) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Failed to include content of resource [\" + resourceUrl + \"]\", ex);\n\t\t\t\t}\n\t\t\t\t// Try including default URL if appropriate.\n\t\t\t\tif (!includeDefaultUrl(request, response)) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No resource URL specified -> try to include default URL.\n\t\telse if (!includeDefaultUrl(request, response)) {\n\t\t\tthrow new ServletException(\"No target resource URL found for request\");\n\t\t}\n\t}\n\n\t/**\n\t * Determine the URL of the target resource of this request.\n\t * <p>Default implementation returns the value of the \"resource\" parameter.\n\t * Can be overridden in subclasses.\n\t * @param request current HTTP request\n\t * @return the URL of the target resource, or {@code null} if none found\n\t * @see #RESOURCE_PARAM_NAME\n\t */\n\tprotected String determineResourceUrl(HttpServletRequest request) {\n\t\treturn request.getParameter(RESOURCE_PARAM_NAME);\n\t}\n\n\t/**\n\t * Include the specified default URL, if appropriate.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @return whether a default URL was included\n\t * @throws ServletException if thrown by the RequestDispatcher\n\t * @throws IOException if thrown by the RequestDispatcher\n\t */\n\tprivate boolean includeDefaultUrl(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\n\t\tif (this.defaultUrl == null) {\n\t\t\treturn false;\n\t\t}\n\t\tdoInclude(request, response, this.defaultUrl);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Include the specified resource via the RequestDispatcher.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param resourceUrl the URL of the target resource\n\t * @throws ServletException if thrown by the RequestDispatcher\n\t * @throws IOException if thrown by the RequestDispatcher\n\t */\n\tprivate void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n\t\t}\n\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (String url : resourceUrls) {\n\t\t\tString path = StringUtils.cleanPath(url);\n\t\t\t// Check whether URL matches allowed resources\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, path)) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + path +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + path + \"]\");\n\t\t\t}\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(path);\n\t\t\trd.include(request, response);\n\t\t}\n\t}\n\n\t/**\n\t * Return the last-modified timestamp of the file that corresponds\n\t * to the target resource URL (i.e. typically the request \".jsp\" file).\n\t * Will simply return -1 if \"applyLastModified\" is false (the default).\n\t * <p>Returns no last-modified date before the startup time of this servlet,\n\t * to allow for message resolution etc that influences JSP contents,\n\t * assuming that those background resources might have changed on restart.\n\t * <p>Returns the startup time of this servlet if the file that corresponds\n\t * to the target resource URL couldn't be resolved (for example, because\n\t * the WAR is not expanded).\n\t * @see #determineResourceUrl\n\t * @see #getFileTimestamp\n\t */\n\t@Override\n\tprotected final long getLastModified(HttpServletRequest request) {\n\t\tif (this.applyLastModified) {\n\t\t\tString resourceUrl = determineResourceUrl(request);\n\t\t\tif (resourceUrl == null) {\n\t\t\t\tresourceUrl = this.defaultUrl;\n\t\t\t}\n\t\t\tif (resourceUrl != null) {\n\t\t\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\t\t\tlong latestTimestamp = -1;\n\t\t\t\tfor (String url : resourceUrls) {\n\t\t\t\t\tlong timestamp = getFileTimestamp(url);\n\t\t\t\t\tif (timestamp > latestTimestamp) {\n\t\t\t\t\t\tlatestTimestamp = timestamp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (latestTimestamp > this.startupTime ? latestTimestamp : this.startupTime);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Return the file timestamp for the given resource.\n\t * @param resourceUrl the URL of the resource\n\t * @return the file timestamp in milliseconds, or -1 if not determinable\n\t */\n\tprotected long getFileTimestamp(String resourceUrl) {\n\t\tServletContextResource resource = new ServletContextResource(getServletContext(), resourceUrl);\n\t\ttry {\n\t\t\tlong lastModifiedTime = resource.lastModified();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Last-modified timestamp of \" + resource + \" is \" + lastModifiedTime);\n\t\t\t}\n\t\t\treturn lastModifiedTime;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Couldn't retrieve last-modified timestamp of \" + resource +\n\t\t\t\t\t\t\" - using ResourceServlet startup time\");\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200183,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/*\n * Copyright (C) 2012 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage retrofit2;\n\nimport java.io.IOException;\nimport javax.annotation.Nullable;\nimport okhttp3.FormBody;\nimport okhttp3.Headers;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.MultipartBody;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okio.Buffer;\nimport okio.BufferedSink;\n\nfinal class RequestBuilder {\n  private static final char[] HEX_DIGITS =\n      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = \" \\\"<>^`{}|\\\\?#\";\n\n  private final String method;\n\n  private final HttpUrl baseUrl;\n  private @Nullable String relativeUrl;\n  private @Nullable HttpUrl.Builder urlBuilder;\n\n  private final Request.Builder requestBuilder;\n  private @Nullable MediaType contentType;\n\n  private final boolean hasBody;\n  private @Nullable MultipartBody.Builder multipartBuilder;\n  private @Nullable FormBody.Builder formBuilder;\n  private @Nullable RequestBody body;\n\n  RequestBuilder(String method, HttpUrl baseUrl,\n      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,\n      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {\n    this.method = method;\n    this.baseUrl = baseUrl;\n    this.relativeUrl = relativeUrl;\n    this.requestBuilder = new Request.Builder();\n    this.contentType = contentType;\n    this.hasBody = hasBody;\n\n    if (headers != null) {\n      requestBuilder.headers(headers);\n    }\n\n    if (isFormEncoded) {\n      // Will be set to 'body' in 'build'.\n      formBuilder = new FormBody.Builder();\n    } else if (isMultipart) {\n      // Will be set to 'body' in 'build'.\n      multipartBuilder = new MultipartBody.Builder();\n      multipartBuilder.setType(MultipartBody.FORM);\n    }\n  }\n\n  void setRelativeUrl(Object relativeUrl) {\n    this.relativeUrl = relativeUrl.toString();\n  }\n\n  void addHeader(String name, String value) {\n    if (\"Content-Type\".equalsIgnoreCase(name)) {\n      try {\n        contentType = MediaType.get(value);\n      } catch (IllegalArgumentException e) {\n        throw new IllegalArgumentException(\"Malformed content type: \" + value, e);\n      }\n    } else {\n      requestBuilder.addHeader(name, value);\n    }\n  }\n\n  void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      // The relative URL is cleared when the first query parameter is set.\n      throw new AssertionError();\n    }\n    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\n  }\n\n  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {\n    int codePoint;\n    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Slow path: the character at i requires encoding!\n        Buffer out = new Buffer();\n        out.writeUtf8(input, 0, i);\n        canonicalizeForPath(out, input, i, limit, alreadyEncoded);\n        return out.readUtf8();\n      }\n    }\n\n    // Fast path: no characters required encoding.\n    return input;\n  }\n\n  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,\n      boolean alreadyEncoded) {\n    Buffer utf8Buffer = null; // Lazily allocated.\n    int codePoint;\n    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (alreadyEncoded\n          && (codePoint == '\\t' || codePoint == '\\n' || codePoint == '\\f' || codePoint == '\\r')) {\n        // Skip this character.\n      } else if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Percent encode this character.\n        if (utf8Buffer == null) {\n          utf8Buffer = new Buffer();\n        }\n        utf8Buffer.writeUtf8CodePoint(codePoint);\n        while (!utf8Buffer.exhausted()) {\n          int b = utf8Buffer.readByte() & 0xff;\n          out.writeByte('%');\n          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);\n          out.writeByte(HEX_DIGITS[b & 0xf]);\n        }\n      } else {\n        // This character doesn't need encoding. Just copy it over.\n        out.writeUtf8CodePoint(codePoint);\n      }\n    }\n  }\n\n  void addQueryParam(String name, @Nullable String value, boolean encoded) {\n    if (relativeUrl != null) {\n      // Do a one-time combination of the built relative URL and the base URL.\n      urlBuilder = baseUrl.newBuilder(relativeUrl);\n      if (urlBuilder == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n      relativeUrl = null;\n    }\n\n    if (encoded) {\n      //noinspection ConstantConditions Checked to be non-null by above 'if' block.\n      urlBuilder.addEncodedQueryParameter(name, value);\n    } else {\n      //noinspection ConstantConditions Checked to be non-null by above 'if' block.\n      urlBuilder.addQueryParameter(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isFormEncoded was true.\n  void addFormField(String name, String value, boolean encoded) {\n    if (encoded) {\n      formBuilder.addEncoded(name, value);\n    } else {\n      formBuilder.add(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isMultipart was true.\n  void addPart(Headers headers, RequestBody body) {\n    multipartBuilder.addPart(headers, body);\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isMultipart was true.\n  void addPart(MultipartBody.Part part) {\n    multipartBuilder.addPart(part);\n  }\n\n  void setBody(RequestBody body) {\n    this.body = body;\n  }\n\n  Request.Builder get() {\n    HttpUrl url;\n    HttpUrl.Builder urlBuilder = this.urlBuilder;\n    if (urlBuilder != null) {\n      url = urlBuilder.build();\n    } else {\n      // No query parameters triggered builder creation, just combine the relative URL and base URL.\n      //noinspection ConstantConditions Non-null if urlBuilder is null.\n      url = baseUrl.resolve(relativeUrl);\n      if (url == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n    }\n\n    RequestBody body = this.body;\n    if (body == null) {\n      // Try to pull from one of the builders.\n      if (formBuilder != null) {\n        body = formBuilder.build();\n      } else if (multipartBuilder != null) {\n        body = multipartBuilder.build();\n      } else if (hasBody) {\n        // Body is absent, make an empty body.\n        body = RequestBody.create(null, new byte[0]);\n      }\n    }\n\n    MediaType contentType = this.contentType;\n    if (contentType != null) {\n      if (body != null) {\n        body = new ContentTypeOverridingRequestBody(body, contentType);\n      } else {\n        requestBuilder.addHeader(\"Content-Type\", contentType.toString());\n      }\n    }\n\n    return requestBuilder\n        .url(url)\n        .method(method, body);\n  }\n\n  private static class ContentTypeOverridingRequestBody extends RequestBody {\n    private final RequestBody delegate;\n    private final MediaType contentType;\n\n    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {\n      this.delegate = delegate;\n      this.contentType = contentType;\n    }\n\n    @Override public MediaType contentType() {\n      return contentType;\n    }\n\n    @Override public long contentLength() throws IOException {\n      return delegate.contentLength();\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n      delegate.writeTo(sink);\n    }\n  }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200192,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/*\n * Copyright (C) 2012 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage retrofit2;\n\nimport java.io.IOException;\nimport java.util.regex.Pattern;\nimport javax.annotation.Nullable;\nimport okhttp3.FormBody;\nimport okhttp3.Headers;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.MultipartBody;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okio.Buffer;\nimport okio.BufferedSink;\n\nfinal class RequestBuilder {\n  private static final char[] HEX_DIGITS =\n      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = \" \\\"<>^`{}|\\\\?#\";\n\n  /**\n   * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also\n   * matches dots in their percent-encoded form, {@code %2E}.\n   *\n   * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code\n   * index.html}) but when alone they have a special meaning. A single dot resolves to no path\n   * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding\n   * directory, so {@code /one/../three/} becomes {@code /three/}.\n   *\n   * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect.\n   * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE\n   * /account/}.\n   */\n  private static final Pattern PATH_TRAVERSAL = Pattern.compile(\"(.*/)?(\\\\.|%2e|%2E){1,2}(/.*)?\");\n\n  private final String method;\n\n  private final HttpUrl baseUrl;\n  private @Nullable String relativeUrl;\n  private @Nullable HttpUrl.Builder urlBuilder;\n\n  private final Request.Builder requestBuilder;\n  private @Nullable MediaType contentType;\n\n  private final boolean hasBody;\n  private @Nullable MultipartBody.Builder multipartBuilder;\n  private @Nullable FormBody.Builder formBuilder;\n  private @Nullable RequestBody body;\n\n  RequestBuilder(String method, HttpUrl baseUrl,\n      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,\n      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {\n    this.method = method;\n    this.baseUrl = baseUrl;\n    this.relativeUrl = relativeUrl;\n    this.requestBuilder = new Request.Builder();\n    this.contentType = contentType;\n    this.hasBody = hasBody;\n\n    if (headers != null) {\n      requestBuilder.headers(headers);\n    }\n\n    if (isFormEncoded) {\n      // Will be set to 'body' in 'build'.\n      formBuilder = new FormBody.Builder();\n    } else if (isMultipart) {\n      // Will be set to 'body' in 'build'.\n      multipartBuilder = new MultipartBody.Builder();\n      multipartBuilder.setType(MultipartBody.FORM);\n    }\n  }\n\n  void setRelativeUrl(Object relativeUrl) {\n    this.relativeUrl = relativeUrl.toString();\n  }\n\n  void addHeader(String name, String value) {\n    if (\"Content-Type\".equalsIgnoreCase(name)) {\n      try {\n        contentType = MediaType.get(value);\n      } catch (IllegalArgumentException e) {\n        throw new IllegalArgumentException(\"Malformed content type: \" + value, e);\n      }\n    } else {\n      requestBuilder.addHeader(name, value);\n    }\n  }\n\n  void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      // The relative URL is cleared when the first query parameter is set.\n      throw new AssertionError();\n    }\n    String replacement = canonicalizeForPath(value, encoded);\n    String newRelativeUrl = relativeUrl.replace(\"{\" + name + \"}\", replacement);\n    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {\n      throw new IllegalArgumentException(\n          \"@Path parameters shouldn't perform path traversal ('.' or '..'): \" + value);\n    }\n    relativeUrl = newRelativeUrl;\n  }\n\n  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {\n    int codePoint;\n    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Slow path: the character at i requires encoding!\n        Buffer out = new Buffer();\n        out.writeUtf8(input, 0, i);\n        canonicalizeForPath(out, input, i, limit, alreadyEncoded);\n        return out.readUtf8();\n      }\n    }\n\n    // Fast path: no characters required encoding.\n    return input;\n  }\n\n  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,\n      boolean alreadyEncoded) {\n    Buffer utf8Buffer = null; // Lazily allocated.\n    int codePoint;\n    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (alreadyEncoded\n          && (codePoint == '\\t' || codePoint == '\\n' || codePoint == '\\f' || codePoint == '\\r')) {\n        // Skip this character.\n      } else if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Percent encode this character.\n        if (utf8Buffer == null) {\n          utf8Buffer = new Buffer();\n        }\n        utf8Buffer.writeUtf8CodePoint(codePoint);\n        while (!utf8Buffer.exhausted()) {\n          int b = utf8Buffer.readByte() & 0xff;\n          out.writeByte('%');\n          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);\n          out.writeByte(HEX_DIGITS[b & 0xf]);\n        }\n      } else {\n        // This character doesn't need encoding. Just copy it over.\n        out.writeUtf8CodePoint(codePoint);\n      }\n    }\n  }\n\n  void addQueryParam(String name, @Nullable String value, boolean encoded) {\n    if (relativeUrl != null) {\n      // Do a one-time combination of the built relative URL and the base URL.\n      urlBuilder = baseUrl.newBuilder(relativeUrl);\n      if (urlBuilder == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n      relativeUrl = null;\n    }\n\n    if (encoded) {\n      //noinspection ConstantConditions Checked to be non-null by above 'if' block.\n      urlBuilder.addEncodedQueryParameter(name, value);\n    } else {\n      //noinspection ConstantConditions Checked to be non-null by above 'if' block.\n      urlBuilder.addQueryParameter(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isFormEncoded was true.\n  void addFormField(String name, String value, boolean encoded) {\n    if (encoded) {\n      formBuilder.addEncoded(name, value);\n    } else {\n      formBuilder.add(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isMultipart was true.\n  void addPart(Headers headers, RequestBody body) {\n    multipartBuilder.addPart(headers, body);\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isMultipart was true.\n  void addPart(MultipartBody.Part part) {\n    multipartBuilder.addPart(part);\n  }\n\n  void setBody(RequestBody body) {\n    this.body = body;\n  }\n\n  Request.Builder get() {\n    HttpUrl url;\n    HttpUrl.Builder urlBuilder = this.urlBuilder;\n    if (urlBuilder != null) {\n      url = urlBuilder.build();\n    } else {\n      // No query parameters triggered builder creation, just combine the relative URL and base URL.\n      //noinspection ConstantConditions Non-null if urlBuilder is null.\n      url = baseUrl.resolve(relativeUrl);\n      if (url == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n    }\n\n    RequestBody body = this.body;\n    if (body == null) {\n      // Try to pull from one of the builders.\n      if (formBuilder != null) {\n        body = formBuilder.build();\n      } else if (multipartBuilder != null) {\n        body = multipartBuilder.build();\n      } else if (hasBody) {\n        // Body is absent, make an empty body.\n        body = RequestBody.create(null, new byte[0]);\n      }\n    }\n\n    MediaType contentType = this.contentType;\n    if (contentType != null) {\n      if (body != null) {\n        body = new ContentTypeOverridingRequestBody(body, contentType);\n      } else {\n        requestBuilder.addHeader(\"Content-Type\", contentType.toString());\n      }\n    }\n\n    return requestBuilder\n        .url(url)\n        .method(method, body);\n  }\n\n  private static class ContentTypeOverridingRequestBody extends RequestBody {\n    private final RequestBody delegate;\n    private final MediaType contentType;\n\n    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {\n      this.delegate = delegate;\n      this.contentType = contentType;\n    }\n\n    @Override public MediaType contentType() {\n      return contentType;\n    }\n\n    @Override public long contentLength() throws IOException {\n      return delegate.contentLength();\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n      delegate.writeTo(sink);\n    }\n  }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200193,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/**\n *    Copyright (C) 2012 ZeroTurnaround LLC <support@zeroturnaround.com>\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\npackage org.zeroturnaround.zip;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.zeroturnaround.zip.commons.FileUtils;\nimport org.zeroturnaround.zip.commons.FilenameUtils;\nimport org.zeroturnaround.zip.commons.IOUtils;\nimport org.zeroturnaround.zip.transform.ZipEntryTransformer;\nimport org.zeroturnaround.zip.transform.ZipEntryTransformerEntry;\n\n/**\n * ZIP file manipulation utilities.\n *\n * @author Rein Raudj\u00e4rv\n * @author Innokenty Shuvalov\n *\n * @see #containsEntry(File, String)\n * @see #unpackEntry(File, String)\n * @see #unpack(File, File)\n * @see #pack(File, File)\n */\npublic final class ZipUtil {\n\n  private static final String PATH_SEPARATOR = \"/\";\n\n  /** Default compression level */\n  public static final int DEFAULT_COMPRESSION_LEVEL = Deflater.DEFAULT_COMPRESSION;\n\n  // Use / instead of . to work around an issue with Maven Shade Plugin\n  private static final Logger log = LoggerFactory.getLogger(\"org/zeroturnaround/zip/ZipUtil\".replace('/', '.')); // NOSONAR\n\n  private ZipUtil() {\n  }\n\n  /* Extracting single entries from ZIP files. */\n\n  /**\n   * Checks if the ZIP file contains the given entry.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return <code>true</code> if the ZIP file contains the given entry.\n   */\n  public static boolean containsEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      return zf.getEntry(name) != null;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Returns the compression method of a given entry of the ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return Returns <code>ZipEntry.STORED</code>, <code>ZipEntry.DEFLATED</code> or -1 if\n   *         the ZIP file does not contain the given entry.\n   * @deprecated The compression level cannot be retrieved. This method exists only to ensure backwards compatibility with ZipUtil version 1.9, which returned the compression\n   *             method, not the level.\n   */\n  @Deprecated\n  public static int getCompressionLevelOfEntry(File zip, String name) {\n    return getCompressionMethodOfEntry(zip, name);\n  }\n\n  /**\n   * Returns the compression method of a given entry of the ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return Returns <code>ZipEntry.STORED</code>, <code>ZipEntry.DEFLATED</code> or -1 if\n   *         the ZIP file does not contain the given entry.\n   */\n  public static int getCompressionMethodOfEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      ZipEntry zipEntry = zf.getEntry(name);\n      if (zipEntry == null) {\n        return -1;\n      }\n      return zipEntry.getMethod();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Checks if the ZIP file contains any of the given entries.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param names\n   *          entry names.\n   * @return <code>true</code> if the ZIP file contains any of the given\n   *         entries.\n   */\n  public static boolean containsAnyEntry(File zip, String[] names) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      for (int i = 0; i < names.length; i++) {\n        if (zf.getEntry(names[i]) != null) {\n          return true;\n        }\n      }\n      return false;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   *\n   * @param charset\n   *          charset to be used to process the zip\n   *\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(File zip, String name, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset != null) {\n        zf = new ZipFile(zip, charset);\n      }\n      else {\n        zf = new ZipFile(zip);\n      }\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(ZipFile zf, String name) {\n    try {\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  private static byte[] doUnpackEntry(ZipFile zf, String name) throws IOException {\n    ZipEntry ze = zf.getEntry(name);\n    if (ze == null) {\n      return null; // entry not found\n    }\n\n    InputStream is = zf.getInputStream(ze);\n    try {\n      return IOUtils.toByteArray(is);\n    }\n    finally {\n      IOUtils.closeQuietly(is);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP stream.\n   *\n   * @param is\n   *          ZIP stream.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(InputStream is, String name) {\n    ByteArrayUnpacker action = new ByteArrayUnpacker();\n    if (!handle(is, name, action))\n      return null; // entry not found\n    return action.getBytes();\n  }\n\n  /**\n   * Copies an entry into a byte array.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class ByteArrayUnpacker implements ZipEntryCallback {\n\n    private byte[] bytes;\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      bytes = IOUtils.toByteArray(in);\n    }\n\n    public byte[] getBytes() {\n      return bytes;\n    }\n\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(File zip, String name, File file) {\n    return unpackEntry(zip, name, file, null);\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @param charset\n   *          charset to be used processing the zip\n   *\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(File zip, String name, File file, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset != null) {\n        zf = new ZipFile(zip, charset);\n      }\n      else {\n        zf = new ZipFile(zip);\n      }\n      return doUnpackEntry(zf, name, file);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(ZipFile zf, String name, File file) {\n    try {\n      return doUnpackEntry(zf, name, file);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  private static boolean doUnpackEntry(ZipFile zf, String name, File file) throws IOException {\n    if (log.isTraceEnabled()) {\n      log.trace(\"Extracting '\" + zf.getName() + \"' entry '\" + name + \"' into '\" + file + \"'.\");\n    }\n\n    ZipEntry ze = zf.getEntry(name);\n    if (ze == null) {\n      return false; // entry not found\n    }\n\n    if (ze.isDirectory() || zf.getInputStream(ze) == null) {\n      if (file.isDirectory()) {\n        return true;\n      }\n      if (file.exists()) {\n        FileUtils.forceDelete(file);\n      }\n      return file.mkdirs();\n    }\n\n    InputStream in = new BufferedInputStream(zf.getInputStream(ze));\n    try {\n      FileUtils.copy(in, file);\n    }\n    finally {\n      IOUtils.closeQuietly(in);\n    }\n    return true;\n  }\n\n  /**\n   * Unpacks a single file from a ZIP stream to a file.\n   *\n   * @param is\n   *          ZIP stream.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   * @throws java.io.IOException if file is not found or writing to it fails\n   */\n  public static boolean unpackEntry(InputStream is, String name, File file) throws IOException {\n    return handle(is, name, new FileUnpacker(file));\n  }\n\n  /**\n   * Copies an entry into a File.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class FileUnpacker implements ZipEntryCallback {\n\n    private final File file;\n\n    public FileUnpacker(File file) {\n      this.file = file;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      FileUtils.copy(in, file);\n    }\n\n  }\n\n  /* Traversing ZIP files */\n\n  /**\n   * Reads the given ZIP file and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipInfoCallback)\n   */\n  public static void iterate(File zip, ZipEntryCallback action) {\n    iterate(zip, action, null);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @param charset\n   *          Charset used to processed the ZipFile with\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipInfoCallback)\n   */\n  public static void iterate(File zip, ZipEntryCallback action, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset == null) {\n        zf = new ZipFile(zip);\n      }\n      else {\n        zf = new ZipFile(zip, charset);\n      }\n\n      Enumeration<? extends ZipEntry> en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n\n        InputStream is = zf.getInputStream(e);\n        try {\n          action.process(is, e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \"' with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipInfoCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipEntryCallback action) {\n    iterate(zip, entryNames, action, null);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset used to process the zip file\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipInfoCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipEntryCallback action, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset == null) {\n        zf = new ZipFile(zip);\n      }\n      else {\n        zf = new ZipFile(zip, charset);\n      }\n\n      for (int i = 0; i < entryNames.length; i++) {\n        ZipEntry e = zf.getEntry(entryNames[i]);\n        if (e == null) {\n          continue;\n        }\n        InputStream is = zf.getInputStream(e);\n        try {\n          action.process(is, e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Scans the given ZIP file and executes the given action for each entry.\n   * <p>\n   * Only the meta-data without the actual data is read. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipInfoCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(File zip, ZipInfoCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      Enumeration<? extends ZipEntry> en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n        try {\n          action.process(e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Scans the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * Only the meta-data without the actual data is read. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipInfoCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipInfoCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      for (int i = 0; i < entryNames.length; i++) {\n        ZipEntry e = zf.getEntry(entryNames[i]);\n        if (e == null) {\n          continue;\n        }\n        try {\n          action.process(e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset to process entries in\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, ZipEntryCallback action, Charset charset) {\n    try {\n      ZipInputStream in = null;\n      try {\n        in = newCloseShieldZipInputStream(is, charset);\n        ZipEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n          try {\n            action.process(in, entry);\n          }\n          catch (IOException ze) {\n            throw new ZipException(\"Failed to process zip entry '\" + entry.getName() + \" with action \" + action, ze);\n          }\n          catch (ZipBreakException ex) {\n            break;\n          }\n        }\n      }\n      finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * See {@link #iterate(InputStream, ZipEntryCallback, Charset)}. This method\n   * is a shorthand for a version where no Charset is specified.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, ZipEntryCallback action) {\n    iterate(is, action, null);\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset to process entries in\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, String[] entryNames, ZipEntryCallback action, Charset charset) {\n    Set<String> namesSet = new HashSet<String>();\n    for (int i = 0; i < entryNames.length; i++) {\n      namesSet.add(entryNames[i]);\n    }\n    try {\n      ZipInputStream in = null;\n      try {\n        in = newCloseShieldZipInputStream(is, charset);\n        ZipEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n          if (!namesSet.contains(entry.getName())) {\n            // skip the unnecessary entry\n            continue;\n          }\n          try {\n            action.process(in, entry);\n          }\n          catch (IOException ze) {\n            throw new ZipException(\"Failed to process zip entry '\" + entry.getName() + \" with action \" + action, ze);\n          }\n          catch (ZipBreakException ex) {\n            break;\n          }\n        }\n      }\n      finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * See @link{ {@link #iterate(InputStream, ZipEntryCallback, Charset)}. It is a\n   * shorthand where no Charset is specified.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, String[] entryNames, ZipEntryCallback action) {\n    iterate(is, entryNames, action, null);\n  }\n\n  /**\n   * Creates a new {@link ZipInputStream} based on the given {@link InputStream}. It will be buffered and close-shielded.\n   * Closing the result stream flushes the buffers and frees up resources of the {@link ZipInputStream}. However the source stream itself remains open.\n   */\n  private static ZipInputStream newCloseShieldZipInputStream(final InputStream is, Charset charset) {\n    InputStream in = new BufferedInputStream(new CloseShieldInputStream(is));\n    if (charset == null) {\n      return new ZipInputStream(in);\n    }\n    return ZipFileUtil.createZipInputStream(in, charset);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for a single entry.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param name\n   *          entry name.\n   * @param action\n   *          action to be called for this entry.\n   * @return <code>true</code> if the entry was found, <code>false</code> if the\n   *         entry was not found.\n   *\n   * @see ZipEntryCallback\n   */\n  public static boolean handle(File zip, String name, ZipEntryCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      ZipEntry ze = zf.getEntry(name);\n      if (ze == null) {\n        return false; // entry not found\n      }\n\n      InputStream in = new BufferedInputStream(zf.getInputStream(ze));\n      try {\n        action.process(in, ze);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n      return true;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for a single\n   * entry.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param name\n   *          entry name.\n   * @param action\n   *          action to be called for this entry.\n   * @return <code>true</code> if the entry was found, <code>false</code> if the\n   *         entry was not found.\n   *\n   * @see ZipEntryCallback\n   */\n  public static boolean handle(InputStream is, String name, ZipEntryCallback action) {\n    SingleZipEntryCallback helper = new SingleZipEntryCallback(name, action);\n    iterate(is, helper);\n    return helper.found();\n  }\n\n  /**\n   * ZipEntryCallback which is only applied to single entry.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class SingleZipEntryCallback implements ZipEntryCallback {\n\n    private final String name;\n\n    private final ZipEntryCallback action;\n\n    private boolean found;\n\n    public SingleZipEntryCallback(String name, ZipEntryCallback action) {\n      this.name = name;\n      this.action = action;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      if (name.equals(zipEntry.getName())) {\n        found = true;\n        action.process(in, zipEntry);\n      }\n    }\n\n    public boolean found() {\n      return found;\n    }\n\n  }\n\n  /* Extracting whole ZIP files. */\n\n  /**\n   * Unpacks a ZIP file to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unpack(File zip, final File outputDir) {\n    unpack(zip, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory using a specific Charset\n   * for the input file.\n   *\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   *\n   * @param charset\n   *          charset used to unpack the zip file\n   */\n  public static void unpack(File zip, final File outputDir, Charset charset) {\n    unpack(zip, outputDir, IdentityNameMapper.INSTANCE, charset);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param charset\n   *          charset used to process the zip file\n   */\n  public static void unpack(File zip, File outputDir, NameMapper mapper, Charset charset) {\n    log.debug(\"Extracting '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unpacker(outputDir, mapper), charset);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory using a specific Charset\n   * for the input file.\n   *\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unpack(File zip, File outputDir, NameMapper mapper) {\n    log.debug(\"Extracting '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unpacker(outputDir, mapper));\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unwrap(File zip, final File outputDir) {\n    unwrap(zip, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unwrap(File zip, File outputDir, NameMapper mapper) {\n    log.debug(\"Unwrapping '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unwraper(outputDir, mapper));\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unpack(InputStream is, File outputDir) {\n    unpack(is, outputDir, IdentityNameMapper.INSTANCE, null);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param charset\n   *          charset used to process the zip stream\n   */\n  public static void unpack(InputStream is, File outputDir, Charset charset) {\n    unpack(is, outputDir, IdentityNameMapper.INSTANCE, charset);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unpack(InputStream is, File outputDir, NameMapper mapper) {\n    unpack(is, outputDir, mapper, null);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param charset\n   *          charset to use when unpacking the stream\n   */\n  public static void unpack(InputStream is, File outputDir, NameMapper mapper, Charset charset) {\n    log.debug(\"Extracting {} into '{}'.\", is, outputDir);\n    iterate(is, new Unpacker(outputDir, mapper), charset);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unwrap(InputStream is, File outputDir) {\n    unwrap(is, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unwrap(InputStream is, File outputDir, NameMapper mapper) {\n    log.debug(\"Unwrapping {} into '{}'.\", is, outputDir);\n    iterate(is, new Unwraper(outputDir, mapper));\n  }\n\n  /**\n   * Unpacks each ZIP entry.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class Unpacker implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n\n    public Unpacker(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        File file = new File(outputDir, name);\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n\n        ZTFilePermissions permissions = ZipEntryUtil.getZTFilePermissions(zipEntry);\n        if (permissions != null) {\n          ZTFilePermissionsUtil.getDefaultStategy().setPermissions(file, permissions);\n        }\n      }\n    }\n  }\n\n  /**\n   * Unpacks each ZIP entries. Presumes they are packed with the backslash separator.\n   * Some archives can have this problem if they are created with some software\n   * that is not following the ZIP specification.\n   *\n   * @since zt-zip 1.9\n   */\n  public static class BackslashUnpacker implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n\n    public BackslashUnpacker(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public BackslashUnpacker(File outputDir) {\n      this(outputDir, IdentityNameMapper.INSTANCE);\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        /**\n         * We assume that EVERY backslash will denote a directory\n         * separator. Also such broken archives don't have entries that\n         * are just directories. Everything is a file. See the example\n         *\n         * Archive: backSlashTest.zip\n         * testing: testDirectory\\testfileInTestDirectory.txt OK\n         * testing: testDirectory\\testSubdirectory\\testFileInTestSubdirectory.txt OK\n         * No errors detected in compressed data of backSlashTest.zip.\n         */\n        if (name.indexOf('\\\\') != -1) {\n          File parentDirectory = outputDir;\n          String[] dirs = name.split(\"\\\\\\\\\");\n\n          // lets create all the directories and the last entry is the file as EVERY entry is a file\n          for (int i = 0; i < dirs.length - 1; i++) {\n            File file = new File(parentDirectory, dirs[i]);\n            if (!file.exists()) {\n              FileUtils.forceMkdir(file);\n            }\n            parentDirectory = file;\n          }\n          File destFile = new File(parentDirectory, dirs[dirs.length - 1]);\n          FileUtils.copy(in, destFile);\n        }\n        // it could be that there are just top level files that the unpacker is used for\n        else {\n          File destFile = new File(outputDir, name);\n          FileUtils.copy(in, destFile);\n        }\n      }\n    }\n  }\n\n  /**\n   * Unwraps entries excluding a single parent dir. If there are multiple roots\n   * ZipException is thrown.\n   *\n   * @author Oleg Shelajev\n   */\n  private static class Unwraper implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n    private String rootDir;\n\n    public Unwraper(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String root = getRootName(zipEntry.getName());\n      if (rootDir == null) {\n        rootDir = root;\n      }\n      else if (!rootDir.equals(root)) {\n        throw new ZipException(\"Unwrapping with multiple roots is not supported, roots: \" + rootDir + \", \" + root);\n      }\n\n      String name = mapper.map(getUnrootedName(root, zipEntry.getName()));\n      if (name != null) {\n        File file = new File(outputDir, name);\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n      }\n    }\n\n    private String getUnrootedName(String root, String name) {\n      return name.substring(root.length());\n    }\n\n    private String getRootName(final String name) {\n      String newName = name.substring(FilenameUtils.getPrefixLength(name));\n      int idx = newName.indexOf(PATH_SEPARATOR);\n      if (idx < 0) {\n        throw new ZipException(\"Entry \" + newName + \" from the root of the zip is not supported\");\n      }\n      return newName.substring(0, newName.indexOf(PATH_SEPARATOR));\n    }\n  }\n\n  /**\n   * Unpacks a ZIP file to its own location.\n   * <p>\n   * The ZIP file will be first renamed (using a temporary name). After the\n   * extraction it will be deleted.\n   *\n   * @param zip\n   *          input ZIP file as well as the target directory.\n   *\n   * @see #unpack(File, File)\n   */\n  public static void explode(File zip) {\n    try {\n      // Find a new unique name is the same directory\n      File tempFile = FileUtils.getTempFileFor(zip);\n\n      // Rename the archive\n      FileUtils.moveFile(zip, tempFile);\n\n      // Unpack it\n      unpack(tempFile, zip);\n\n      // Delete the archive\n      if (!tempFile.delete()) {\n        throw new IOException(\"Unable to delete file: \" + tempFile);\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /* Compressing single entries to ZIP files. */\n\n  /**\n   * Compresses the given file into a ZIP file with single entry.\n   *\n   * @param file file to be compressed.\n   * @return ZIP file created.\n   */\n  public static byte[] packEntry(File file) {\n    log.trace(\"Compressing '{}' into a ZIP file with single entry.\", file);\n\n    ByteArrayOutputStream result = new ByteArrayOutputStream();\n    try {\n      ZipOutputStream out = new ZipOutputStream(result);\n      ZipEntry entry = ZipEntryUtil.fromFile(file.getName(), file);\n      InputStream in = new BufferedInputStream(new FileInputStream(file));\n      try {\n        ZipEntryUtil.addEntry(entry, in, out);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n      out.close();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    return result.toByteArray();\n  }\n\n  /* Compressing ZIP files. */\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param rootDir\n   *          root directory.\n   * @param zip\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void pack(File rootDir, File zip) {\n    pack(rootDir, zip, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param rootDir\n   *          root directory.\n   * @param zip\n   *          ZIP file that will be created or overwritten.\n   * @param compressionLevel\n   *          compression level\n   */\n  public static void pack(File rootDir, File zip, int compressionLevel) {\n    pack(rootDir, zip, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param preserveRoot\n   *          true if the resulted archive should have the top directory entry\n   */\n  public static void pack(final File sourceDir, final File targetZipFile, final boolean preserveRoot) {\n    if (preserveRoot) {\n      final String parentName = sourceDir.getName();\n      pack(sourceDir, targetZipFile, new NameMapper() {\n        public String map(String name) {\n          return parentName + PATH_SEPARATOR + name;\n        }\n      });\n    }\n    else {\n      pack(sourceDir, targetZipFile);\n    }\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void packEntry(File fileToPack, File destZipFile) {\n    packEntry(fileToPack, destZipFile, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param fileName\n   *          the name for the file inside the archive\n   */\n  public static void packEntry(File fileToPack, File destZipFile, final String fileName) {\n    packEntry(fileToPack, destZipFile, new NameMapper() {\n      public String map(String name) {\n        return fileName;\n      }\n    });\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void packEntry(File fileToPack, File destZipFile, NameMapper mapper) {\n    packEntries(new File[] { fileToPack }, destZipFile, mapper);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile) {\n    packEntries(filesToPack, destZipFile, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, NameMapper mapper) {\n    packEntries(filesToPack, destZipFile, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param compressionLevel\n   *          ZIP file compression level (speed versus filesize), e.g. <code>Deflater.NO_COMPRESSION</code>, <code>Deflater.BEST_SPEED</code>, or\n   *          <code>Deflater.BEST_COMPRESSION</code>\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, int compressionLevel) {\n    packEntries(filesToPack, destZipFile, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          ZIP file compression level (speed versus filesize), e.g. <code>Deflater.NO_COMPRESSION</code>, <code>Deflater.BEST_SPEED</code>, or\n   *          <code>Deflater.BEST_COMPRESSION</code>\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into '{}'.\", filesToPack, destZipFile);\n\n    ZipOutputStream out = null;\n    FileOutputStream fos = null;\n    try {\n      fos = new FileOutputStream(destZipFile);\n      out = new ZipOutputStream(new BufferedOutputStream(fos));\n      out.setLevel(compressionLevel);\n\n      for (int i = 0; i < filesToPack.length; i++) {\n        File fileToPack = filesToPack[i];\n\n        ZipEntry zipEntry = ZipEntryUtil.fromFile(mapper.map(fileToPack.getName()), fileToPack);\n        out.putNextEntry(zipEntry);\n        FileUtils.copy(fileToPack, out);\n        out.closeEntry();\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n      IOUtils.closeQuietly(fos);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZip\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void pack(File sourceDir, File targetZip, NameMapper mapper) {\n    pack(sourceDir, targetZip, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZip\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          compression level\n   */\n  public static void pack(File sourceDir, File targetZip, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into '{}'.\", sourceDir, targetZip);\n    if (!sourceDir.exists()) {\n      throw new ZipException(\"Given file '\" + sourceDir + \"' doesn't exist!\");\n    }\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(targetZip)));\n      out.setLevel(compressionLevel);\n      pack(sourceDir, out, mapper, \"\", true);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os) {\n    pack(sourceDir, os, IdentityNameMapper.INSTANCE, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param compressionLevel\n   *          compression level\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, int compressionLevel) {\n    pack(sourceDir, os, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param mapper\n   *          call-back for renaming the entries.\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, NameMapper mapper) {\n    pack(sourceDir, os, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          compression level\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into a stream.\", sourceDir);\n    if (!sourceDir.exists()) {\n      throw new ZipException(\"Given file '\" + sourceDir + \"' doesn't exist!\");\n    }\n    ZipOutputStream out = null;\n    IOException error = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(os));\n      out.setLevel(compressionLevel);\n      pack(sourceDir, out, mapper, \"\", true);\n    }\n    catch (IOException e) {\n      error = e;\n    }\n    finally {\n      if (out != null && error == null) {\n        try {\n          out.finish();\n          out.flush();\n        }\n        catch (IOException e) {\n          error = e;\n        }\n      }\n    }\n    if (error != null) {\n      throw ZipExceptionUtil.rethrow(error);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   *\n   * @param dir\n   *          root directory.\n   * @param out\n   *          ZIP output stream.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param pathPrefix\n   *          prefix to be used for the entries.\n   * @param mustHaveChildren\n   *          if true, but directory to pack doesn't have any files, throw an exception.\n   */\n  private static void pack(File dir, ZipOutputStream out, NameMapper mapper, String pathPrefix, boolean mustHaveChildren) throws IOException {\n    String[] filenames = dir.list();\n    if (filenames == null) {\n      if (!dir.exists()) {\n        throw new ZipException(\"Given file '\" + dir + \"' doesn't exist!\");\n      }\n      throw new IOException(\"Given file is not a directory '\" + dir + \"'\");\n    }\n\n    if (mustHaveChildren && filenames.length == 0) {\n      throw new ZipException(\"Given directory '\" + dir + \"' doesn't contain any files!\");\n    }\n\n    for (int i = 0; i < filenames.length; i++) {\n      String filename = filenames[i];\n      File file = new File(dir, filename);\n      boolean isDir = file.isDirectory();\n      String path = pathPrefix + file.getName(); // NOSONAR\n      if (isDir) {\n        path += PATH_SEPARATOR; // NOSONAR\n      }\n\n      // Create a ZIP entry\n      String name = mapper.map(path);\n      if (name != null) {\n        ZipEntry zipEntry = ZipEntryUtil.fromFile(name, file);\n\n        out.putNextEntry(zipEntry);\n\n        // Copy the file content\n        if (!isDir) {\n          FileUtils.copy(file, out);\n        }\n\n        out.closeEntry();\n      }\n\n      // Traverse the directory\n      if (isDir) {\n        pack(file, out, mapper, path, false);\n      }\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP file into a new ZIP with a given compression level.\n   * <p>\n   *\n   * @param srcZip\n   *          source ZIP file.\n   * @param dstZip\n   *          destination ZIP file.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(File srcZip, File dstZip, int compressionLevel) {\n\n    log.debug(\"Repacking '{}' into '{}'.\", srcZip, dstZip);\n\n    RepackZipEntryCallback callback = new RepackZipEntryCallback(dstZip, compressionLevel);\n\n    try {\n      iterate(srcZip, callback);\n    }\n    finally {\n      callback.closeStream();\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP input stream into a ZIP file with a given compression level.\n   * <p>\n   *\n   * @param is\n   *          ZIP input stream.\n   * @param dstZip\n   *          destination ZIP file.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(InputStream is, File dstZip, int compressionLevel) {\n\n    log.debug(\"Repacking from input stream into '{}'.\", dstZip);\n\n    RepackZipEntryCallback callback = new RepackZipEntryCallback(dstZip, compressionLevel);\n\n    try {\n      iterate(is, callback);\n    }\n    finally {\n      callback.closeStream();\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP file and replaces old file with the new one.\n   * <p>\n   *\n   * @param zip\n   *          source ZIP file to be repacked and replaced.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(File zip, int compressionLevel) {\n    try {\n      File tmpZip = FileUtils.getTempFileFor(zip);\n\n      repack(zip, tmpZip, compressionLevel);\n\n      // Delete original zip\n      if (!zip.delete()) {\n        throw new IOException(\"Unable to delete the file: \" + zip);\n      }\n\n      // Rename the archive\n      FileUtils.moveFile(tmpZip, zip);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * RepackZipEntryCallback used in repacking methods.\n   *\n   * @author Pavel Grigorenko\n   */\n  private static final class RepackZipEntryCallback implements ZipEntryCallback {\n\n    private ZipOutputStream out;\n\n    private RepackZipEntryCallback(File dstZip, int compressionLevel) {\n      try {\n        this.out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(dstZip)));\n        this.out.setLevel(compressionLevel);\n      }\n      catch (IOException e) {\n        ZipExceptionUtil.rethrow(e);\n      }\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      ZipEntryUtil.copyEntry(zipEntry, in, out);\n    }\n\n    private void closeStream() {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Compresses a given directory in its own location.\n   * <p>\n   * A ZIP file will be first created with a temporary name. After the\n   * compressing the directory will be deleted and the ZIP file will be renamed\n   * as the original directory.\n   *\n   * @param dir\n   *          input directory as well as the target ZIP file.\n   *\n   * @see #pack(File, File)\n   */\n  public static void unexplode(File dir) {\n    unexplode(dir, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses a given directory in its own location.\n   * <p>\n   * A ZIP file will be first created with a temporary name. After the\n   * compressing the directory will be deleted and the ZIP file will be renamed\n   * as the original directory.\n   *\n   * @param dir\n   *          input directory as well as the target ZIP file.\n   * @param compressionLevel\n   *          compression level\n   *\n   * @see #pack(File, File)\n   */\n  public static void unexplode(File dir, int compressionLevel) {\n    try {\n      // Find a new unique name is the same directory\n      File zip = FileUtils.getTempFileFor(dir);\n\n      // Pack it\n      pack(dir, zip, compressionLevel);\n\n      // Delete the directory\n      FileUtils.deleteDirectory(dir);\n\n      // Rename the archive\n      FileUtils.moveFile(zip, dir);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compresses the given entries into an output stream.\n   *\n   * @param entries\n   *          ZIP entries added.\n   * @param os\n   *          output stream for the new ZIP (does not have to be buffered)\n   *\n   * @since 1.9\n   */\n  public static void pack(ZipEntrySource[] entries, OutputStream os) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Creating stream from {}.\", Arrays.asList(entries));\n    }\n    pack(entries, os, false);\n  }\n\n  private static void pack(ZipEntrySource[] entries, OutputStream os, boolean closeStream) {\n    try {\n      ZipOutputStream out = new ZipOutputStream(os);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.flush();\n      out.finish();\n      if (closeStream) {\n        out.close();\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compresses the given entries into a new ZIP file.\n   *\n   * @param entries\n   *          ZIP entries added.\n   * @param zip\n   *          new ZIP file created.\n   */\n  public static void pack(ZipEntrySource[] entries, File zip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Creating '{}' from {}.\", zip, Arrays.asList(entries));\n    }\n\n    OutputStream out = null;\n    try {\n      out = new BufferedOutputStream(new FileOutputStream(zip));\n      pack(entries, out, true);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry to be added.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, String path, File file, File destZip) {\n    addEntry(zip, new FileSource(path, file), destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry to be added.\n   */\n  public static void addEntry(final File zip, final String path, final File file) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, file, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, String path, byte[] bytes, File destZip) {\n    addEntry(zip, new ByteSource(path, bytes), destZip);\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   */\n  public static void addEntry(File zip, String path, byte[] bytes, File destZip, final int compressionMethod) {\n    addEntry(zip, new ByteSource(path, bytes, compressionMethod), destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   */\n  public static void addEntry(final File zip, final String path, final byte[] bytes) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, bytes, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   */\n  public static void addEntry(final File zip, final String path, final byte[] bytes, final int compressionMethod) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, bytes, tmpFile, compressionMethod);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry appended.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, ZipEntrySource entry, File destZip) {\n    addEntries(zip, new ZipEntrySource[] { entry }, destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry appended.\n   */\n  public static void addEntry(final File zip, final ZipEntrySource entry) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, entry, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    OutputStream destOut = null;\n    try {\n      destOut = new BufferedOutputStream(new FileOutputStream(destZip));\n      addEntries(zip, entries, destOut);\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(destOut);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destOut\n   *          new ZIP destination output stream\n   */\n  public static void addEntries(File zip, ZipEntrySource[] entries, OutputStream destOut) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to a stream and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(destOut);\n      copyEntries(zip, out);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.finish();\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param is\n   *          an existing ZIP input stream.\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destOut\n   *          new ZIP destination output stream\n   *\n   * @since 1.9\n   */\n  public static void addEntries(InputStream is, ZipEntrySource[] entries, OutputStream destOut) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying input stream to an output stream and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(destOut);\n      copyEntries(is, out);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.finish();\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes a zip file it with with new entries. in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   */\n  public static void addEntries(final File zip, final ZipEntrySource[] entries) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntries(zip, entries, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and removes entry with a given path.\n   *\n   * @param zip\n   *          an existing ZIP file (only read)\n   * @param path\n   *          path of the entry to remove\n   * @param destZip\n   *          new ZIP file created.\n   * @since 1.7\n   */\n  public static void removeEntry(File zip, String path, File destZip) {\n    removeEntries(zip, new String[] { path }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: removes entry with a given path.\n   *\n   * @param zip\n   *          an existing ZIP file\n   * @param path\n   *          path of the entry to remove\n   * @since 1.7\n   */\n  public static void removeEntry(final File zip, final String path) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        removeEntry(zip, path, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and removes entries with given paths.\n   *\n   * @param zip\n   *          an existing ZIP file (only read)\n   * @param paths\n   *          paths of the entries to remove\n   * @param destZip\n   *          new ZIP file created.\n   * @since 1.7\n   */\n  public static void removeEntries(File zip, String[] paths, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and removing paths \" + Arrays.asList(paths) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      copyEntries(zip, out, new HashSet<String>(Arrays.asList(paths)));\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Changes an existing ZIP file: removes entries with given paths.\n   *\n   * @param zip\n   *          an existing ZIP file\n   * @param paths\n   *          paths of the entries to remove\n   * @since 1.7\n   */\n  public static void removeEntries(final File zip, final String[] paths) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        removeEntries(zip, paths, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP file to another.\n   *\n   * @param zip\n   *          source ZIP file.\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void copyEntries(File zip, final ZipOutputStream out) {\n    // this one doesn't call copyEntries with ignoredEntries, because that has poorer performance\n    final Set<String> names = new HashSet<String>();\n    iterate(zip, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP stream to another.\n   *\n   * @param is\n   *          source stream (contains ZIP file).\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void copyEntries(InputStream is, final ZipOutputStream out) {\n    // this one doesn't call copyEntries with ignoredEntries, because that has poorer performance\n    final Set<String> names = new HashSet<String>();\n    iterate(is, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP file to another, ignoring entries with path in ignoredEntries\n   *\n   * @param zip\n   *          source ZIP file.\n   * @param out\n   *          target ZIP stream.\n   * @param ignoredEntries\n   *          paths of entries not to copy\n   */\n  private static void copyEntries(File zip, final ZipOutputStream out, final Set<String> ignoredEntries) {\n    final Set<String> names = new HashSet<String>();\n    final Set<String> dirNames = filterDirEntries(zip, ignoredEntries);\n    iterate(zip, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (ignoredEntries.contains(entryName)) {\n          return;\n        }\n\n        for (String dirName : dirNames) {\n          if (entryName.startsWith(dirName)) {\n            return;\n          }\n        }\n\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   *\n   * @param zip\n   *          zip file to traverse\n   * @param names\n   *          names of entries to filter dirs from\n   * @return Set<String> names of entries that are dirs.\n   *\n   */\n  static Set<String> filterDirEntries(File zip, Collection<String> names) {\n    Set<String> dirs = new HashSet<String>();\n    if (zip == null) {\n      return dirs;\n    }\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      for (String entryName : names) {\n        ZipEntry entry = zf.getEntry(entryName);\n        if (entry != null) {\n          if (entry.isDirectory()) {\n            dirs.add(entry.getName());\n          }\n          else if (zf.getInputStream(entry) == null) {\n            // no input stream means that this is a dir.\n            dirs.add(entry.getName() + PATH_SEPARATOR);\n          }\n        }\n      }\n\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n    return dirs;\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, String path, File file, File destZip) {\n    return replaceEntry(zip, new FileSource(path, file), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final File file) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new FileSource(path, file), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, String path, byte[] bytes, File destZip) {\n    return replaceEntry(zip, new ByteSource(path, bytes), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final byte[] bytes) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new ByteSource(path, bytes), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final byte[] bytes,\n      final int compressionMethod) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new ByteSource(path, bytes, compressionMethod), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, ZipEntrySource entry, File destZip) {\n    return replaceEntries(zip, new ZipEntrySource[] { entry }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param entry\n   *          new ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final ZipEntrySource entry) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, entry, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries to be replaced with.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean replaceEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and replacing entries \" + Arrays.asList(entries) + \".\");\n    }\n\n    final Map<String, ZipEntrySource> entryByPath = entriesByPath(entries);\n    final int entryCount = entryByPath.size();\n    try {\n      final ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        final Set<String> names = new HashSet<String>();\n        iterate(zip, new ZipEntryCallback() {\n          public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n            if (names.add(zipEntry.getName())) {\n              ZipEntrySource entry = (ZipEntrySource) entryByPath.remove(zipEntry.getName());\n              if (entry != null) {\n                addEntry(entry, out);\n              }\n              else {\n                ZipEntryUtil.copyEntry(zipEntry, in, out);\n              }\n            }\n            else if (log.isDebugEnabled()) {\n              log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n            }\n          }\n        });\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    return entryByPath.size() < entryCount;\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param entries\n   *          new ZIP entries to be replaced with.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean replaceEntries(final File zip, final ZipEntrySource[] entries) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntries(zip, entries, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and adds/replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entries to be replaced or added.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addOrReplaceEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and adding/replacing entries \" + Arrays.asList(entries)\n          + \".\");\n    }\n\n    final Map<String, ZipEntrySource> entryByPath = entriesByPath(entries);\n    try {\n      final ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        // Copy and replace entries\n        final Set<String> names = new HashSet<String>();\n        iterate(zip, new ZipEntryCallback() {\n          public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n            if (names.add(zipEntry.getName())) {\n              ZipEntrySource entry = (ZipEntrySource) entryByPath.remove(zipEntry.getName());\n              if (entry != null) {\n                addEntry(entry, out);\n              }\n              else {\n                ZipEntryUtil.copyEntry(zipEntry, in, out);\n              }\n            }\n            else if (log.isDebugEnabled()) {\n              log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n            }\n          }\n        });\n\n        // Add new entries\n        for (ZipEntrySource zipEntrySource : entryByPath.values()) {\n          addEntry(zipEntrySource, out);\n        }\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes a ZIP file: adds/replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entries to be replaced or added.\n   */\n  public static void addOrReplaceEntries(final File zip, final ZipEntrySource[] entries) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addOrReplaceEntries(zip, entries, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * @return given entries indexed by path.\n   */\n  static Map<String, ZipEntrySource> entriesByPath(ZipEntrySource... entries) {\n    Map<String, ZipEntrySource> result = new HashMap<String, ZipEntrySource>();\n    for (int i = 0; i < entries.length; i++) {\n      ZipEntrySource source = entries[i];\n      result.put(source.getPath(), source);\n    }\n    return result;\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @throws IllegalArgumentException if the destination is the same as the location\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(File zip, String path, ZipEntryTransformer transformer, File destZip) {\n    if(zip.equals(destZip)){throw new IllegalArgumentException(\"Input (\" +zip.getAbsolutePath()+ \") is the same as the destination!\" +\n            \"Please use the transformEntry method without destination for in-place transformation.\" );}\n    return transformEntry(zip, new ZipEntryTransformerEntry(path, transformer), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(final File zip, final String path, final ZipEntryTransformer transformer) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntry(zip, path, transformer, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(File zip, ZipEntryTransformerEntry entry, File destZip) {\n    return transformEntries(zip, new ZipEntryTransformerEntry[] { entry }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(final File zip, final ZipEntryTransformerEntry entry) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntry(zip, entry, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entry transformers.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean transformEntries(File zip, ZipEntryTransformerEntry[] entries, File destZip) {\n    if (log.isDebugEnabled())\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and transforming entries \" + Arrays.asList(entries) + \".\");\n\n    try {\n      ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        TransformerZipEntryCallback action = new TransformerZipEntryCallback(Arrays.asList(entries), out);\n        iterate(zip, action);\n        return action.found();\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entry transformers.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntries(final File zip, final ZipEntryTransformerEntry[] entries) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntries(zip, entries, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(InputStream is, String path, ZipEntryTransformer transformer, OutputStream os) {\n    return transformEntry(is, new ZipEntryTransformerEntry(path, transformer), os);\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(InputStream is, ZipEntryTransformerEntry entry, OutputStream os) {\n    return transformEntries(is, new ZipEntryTransformerEntry[] { entry }, os);\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms the given entries in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param entries\n   *          ZIP entry transformers.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean transformEntries(InputStream is, ZipEntryTransformerEntry[] entries, OutputStream os) {\n    if (log.isDebugEnabled())\n      log.debug(\"Copying '\" + is + \"' to '\" + os + \"' and transforming entries \" + Arrays.asList(entries) + \".\");\n\n    try {\n      ZipOutputStream out = new ZipOutputStream(os);\n      TransformerZipEntryCallback action = new TransformerZipEntryCallback(Arrays.asList(entries), out);\n      iterate(is, action);\n      // Finishes writing the contents of the ZIP output stream without closing\n      // the underlying stream.\n      out.finish();\n      return action.found();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  private static class TransformerZipEntryCallback implements ZipEntryCallback {\n\n    private final Map<String, ZipEntryTransformer> entryByPath;\n    private final int entryCount;\n    private final ZipOutputStream out;\n    private final Set<String> names = new HashSet<String>();\n\n    public TransformerZipEntryCallback(List<ZipEntryTransformerEntry> entries, ZipOutputStream out) {\n      entryByPath = transformersByPath(entries);\n      entryCount = entryByPath.size();\n      this.out = out;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      if (names.add(zipEntry.getName())) {\n        ZipEntryTransformer entry = (ZipEntryTransformer) entryByPath.remove(zipEntry.getName());\n        if (entry != null) {\n          entry.transform(in, zipEntry, out);\n        }\n        else {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n      }\n      else if (log.isDebugEnabled()) {\n        log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n      }\n    }\n\n    /**\n     * @return <code>true</code> if at least one entry was replaced.\n     */\n    public boolean found() {\n      return entryByPath.size() < entryCount;\n    }\n\n  }\n\n  /**\n   * @return transformers by path.\n   */\n  static Map<String, ZipEntryTransformer> transformersByPath(List<ZipEntryTransformerEntry> entries) {\n    Map<String, ZipEntryTransformer> result = new HashMap<String, ZipEntryTransformer>();\n    for (ZipEntryTransformerEntry entry : entries) {\n      result.put(entry.getPath(), entry.getTransformer());\n    }\n    return result;\n  }\n\n  /**\n   * Adds a given ZIP entry to a ZIP file.\n   *\n   * @param entry\n   *          new ZIP entry.\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void addEntry(ZipEntrySource entry, ZipOutputStream out) throws IOException {\n    out.putNextEntry(entry.getEntry());\n    InputStream in = entry.getInputStream();\n    if (in != null) {\n      try {\n        IOUtils.copy(in, out);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n    }\n    out.closeEntry();\n  }\n\n  /* Comparing two ZIP files. */\n\n  /**\n   * Compares two ZIP files and returns <code>true</code> if they contain same\n   * entries.\n   * <p>\n   * First the two files are compared byte-by-byte. If a difference is found the\n   * corresponding entries of both ZIP files are compared. Thus if same contents\n   * is packed differently the two archives may still be the same.\n   * </p>\n   * <p>\n   * Two archives are considered the same if\n   * <ol>\n   * <li>they contain same number of entries,</li>\n   * <li>for each entry in the first archive there exists an entry with the same\n   * in the second archive</li>\n   * <li>for each entry in the first archive and the entry with the same name in\n   * the second archive\n   * <ol>\n   * <li>both are either directories or files,</li>\n   * <li>both have the same size,</li>\n   * <li>both have the same CRC,</li>\n   * <li>both have the same contents (compared byte-by-byte).</li>\n   * </ol>\n   * </li>\n   * </ol>\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @return <code>true</code> if the two ZIP files contain same entries,\n   *         <code>false</code> if a difference was found or an error occurred\n   *         during the comparison.\n   */\n  public static boolean archiveEquals(File f1, File f2) {\n    try {\n      // Check the files byte-by-byte\n      if (FileUtils.contentEquals(f1, f2)) {\n        return true;\n      }\n\n      log.debug(\"Comparing archives '{}' and '{}'...\", f1, f2);\n\n      long start = System.currentTimeMillis();\n      boolean result = archiveEqualsInternal(f1, f2);\n      long time = System.currentTimeMillis() - start;\n      if (time > 0) {\n        log.debug(\"Archives compared in \" + time + \" ms.\");\n      }\n      return result;\n    }\n    catch (Exception e) {\n      log.debug(\"Could not compare '\" + f1 + \"' and '\" + f2 + \"':\", e);\n      return false;\n    }\n  }\n\n  private static boolean archiveEqualsInternal(File f1, File f2) throws IOException {\n    ZipFile zf1 = null;\n    ZipFile zf2 = null;\n    try {\n      zf1 = new ZipFile(f1);\n      zf2 = new ZipFile(f2);\n\n      // Check the number of entries\n      if (zf1.size() != zf2.size()) {\n        log.debug(\"Number of entries changed (\" + zf1.size() + \" vs \" + zf2.size() + \").\");\n        return false;\n      }\n      /*\n       * As there are same number of entries in both archives we can traverse\n       * all entries of one of the archives and get the corresponding entries\n       * from the other archive.\n       *\n       * If a corresponding entry is missing from the second archive the\n       * archives are different and we finish the comparison.\n       *\n       * We guarantee that no entry of the second archive is skipped as there\n       * are same number of unique entries in both archives.\n       */\n      Enumeration<? extends ZipEntry> en = zf1.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e1 = (ZipEntry) en.nextElement();\n        String path = e1.getName();\n        ZipEntry e2 = zf2.getEntry(path);\n\n        // Check meta data\n        if (!metaDataEquals(path, e1, e2)) {\n          return false;\n        }\n\n        // Check the content\n        InputStream is1 = null;\n        InputStream is2 = null;\n        try {\n          is1 = zf1.getInputStream(e1);\n          is2 = zf2.getInputStream(e2);\n\n          if (!IOUtils.contentEquals(is1, is2)) {\n            log.debug(\"Entry '{}' content changed.\", path);\n            return false;\n          }\n        }\n        finally {\n          IOUtils.closeQuietly(is1);\n          IOUtils.closeQuietly(is2);\n        }\n      }\n    }\n    finally {\n      closeQuietly(zf1);\n      closeQuietly(zf2);\n    }\n\n    log.debug(\"Archives are the same.\");\n\n    return true;\n  }\n\n  /**\n   * Compares meta-data of two ZIP entries.\n   * <p>\n   * Two entries are considered the same if\n   * <ol>\n   * <li>both entries exist,</li>\n   * <li>both entries are either directories or files,</li>\n   * <li>both entries have the same size,</li>\n   * <li>both entries have the same CRC.</li>\n   * </ol>\n   *\n   * @param path\n   *          name of the entries.\n   * @param e1\n   *          first entry (required).\n   * @param e2\n   *          second entry (may be <code>null</code>).\n   * @return <code>true</code> if no difference was found.\n   */\n  private static boolean metaDataEquals(String path, ZipEntry e1, ZipEntry e2) throws IOException {\n    // Check if the same entry exists in the second archive\n    if (e2 == null) {\n      log.debug(\"Entry '{}' removed.\", path);\n      return false;\n    }\n\n    // Check the directory flag\n    if (e1.isDirectory()) {\n      if (e2.isDirectory()) {\n        return true; // Let's skip the directory as there is nothing to compare\n      }\n      else {\n        log.debug(\"Entry '{}' not a directory any more.\", path);\n        return false;\n      }\n    }\n    else if (e2.isDirectory()) {\n      log.debug(\"Entry '{}' now a directory.\", path);\n      return false;\n    }\n\n    // Check the size\n    long size1 = e1.getSize();\n    long size2 = e2.getSize();\n    if (size1 != -1 && size2 != -1 && size1 != size2) {\n      log.debug(\"Entry '\" + path + \"' size changed (\" + size1 + \" vs \" + size2 + \").\");\n      return false;\n    }\n\n    // Check the CRC\n    long crc1 = e1.getCrc();\n    long crc2 = e2.getCrc();\n    if (crc1 != -1 && crc2 != -1 && crc1 != crc2) {\n      log.debug(\"Entry '\" + path + \"' CRC changed (\" + crc1 + \" vs \" + crc2 + \").\");\n      return false;\n    }\n\n    // Check the time (ignored, logging only)\n    if (log.isTraceEnabled()) {\n      long time1 = e1.getTime();\n      long time2 = e2.getTime();\n      if (time1 != -1 && time2 != -1 && time1 != time2) {\n        log.trace(\"Entry '\" + path + \"' time changed (\" + new Date(time1) + \" vs \" + new Date(time2) + \").\");\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Compares same entry in two ZIP files (byte-by-byte).\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @param path\n   *          name of the entry.\n   * @return <code>true</code> if the contents of the entry was same in both ZIP\n   *         files.\n   */\n  public static boolean entryEquals(File f1, File f2, String path) {\n    return entryEquals(f1, f2, path, path);\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  public static boolean entryEquals(File f1, File f2, String path1, String path2) {\n    ZipFile zf1 = null;\n    ZipFile zf2 = null;\n\n    try {\n      zf1 = new ZipFile(f1);\n      zf2 = new ZipFile(f2);\n\n      return doEntryEquals(zf1, zf2, path1, path2);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf1);\n      closeQuietly(zf2);\n    }\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param zf1\n   *          first ZIP file.\n   * @param zf2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  public static boolean entryEquals(ZipFile zf1, ZipFile zf2, String path1, String path2) {\n    try {\n      return doEntryEquals(zf1, zf2, path1, path2);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param zf1\n   *          first ZIP file.\n   * @param zf2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  private static boolean doEntryEquals(ZipFile zf1, ZipFile zf2, String path1, String path2) throws IOException {\n    InputStream is1 = null;\n    InputStream is2 = null;\n    try {\n      ZipEntry e1 = zf1.getEntry(path1);\n      ZipEntry e2 = zf2.getEntry(path2);\n\n      if (e1 == null && e2 == null) {\n        return true;\n      }\n\n      if (e1 == null || e2 == null) {\n        return false;\n      }\n\n      is1 = zf1.getInputStream(e1);\n      is2 = zf2.getInputStream(e2);\n      if (is1 == null && is2 == null) {\n        return true;\n      }\n      if (is1 == null || is2 == null) {\n        return false;\n      }\n\n      return IOUtils.contentEquals(is1, is2);\n    }\n    finally {\n      IOUtils.closeQuietly(is1);\n      IOUtils.closeQuietly(is2);\n    }\n  }\n\n  /**\n   * Closes the ZIP file while ignoring any errors.\n   *\n   * @param zf\n   *          ZIP file to be closed.\n   */\n  public static void closeQuietly(ZipFile zf) {\n    try {\n      if (zf != null) {\n        zf.close();\n      }\n    }\n    catch (IOException e) {\n    }\n  }\n\n  /**\n   * Simple helper to make inplace operation easier\n   *\n   * @author shelajev\n   */\n  private abstract static class InPlaceAction {\n\n    /**\n     * @return true if something has been changed during the action.\n     */\n    abstract boolean act(File tmpFile);\n  }\n\n  /**\n   *\n   * This method provides a general infrastructure for in-place operations.\n   * It creates temp file as a destination, then invokes the action on source and destination.\n   * Then it copies the result back into src file.\n   *\n   * @param src - source zip file we want to modify\n   * @param action - action which actually modifies the archives\n   *\n   * @return result of the action\n   */\n  private static boolean operateInPlace(File src, InPlaceAction action) {\n    File tmp = null;\n    try {\n      tmp = File.createTempFile(\"zt-zip-tmp\", \".zip\");\n      boolean result = action.act(tmp);\n      if (result) { // else nothing changes\n        FileUtils.forceDelete(src);\n        FileUtils.moveFile(tmp, src);\n      }\n      return result;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      FileUtils.deleteQuietly(tmp);\n    }\n  }\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200198,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/**\n *    Copyright (C) 2012 ZeroTurnaround LLC <support@zeroturnaround.com>\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\npackage org.zeroturnaround.zip;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.zeroturnaround.zip.commons.FileUtils;\nimport org.zeroturnaround.zip.commons.FilenameUtils;\nimport org.zeroturnaround.zip.commons.IOUtils;\nimport org.zeroturnaround.zip.transform.ZipEntryTransformer;\nimport org.zeroturnaround.zip.transform.ZipEntryTransformerEntry;\n\n/**\n * ZIP file manipulation utilities.\n *\n * @author Rein Raudj\u00e4rv\n * @author Innokenty Shuvalov\n *\n * @see #containsEntry(File, String)\n * @see #unpackEntry(File, String)\n * @see #unpack(File, File)\n * @see #pack(File, File)\n */\npublic final class ZipUtil {\n\n  private static final String PATH_SEPARATOR = \"/\";\n\n  /** Default compression level */\n  public static final int DEFAULT_COMPRESSION_LEVEL = Deflater.DEFAULT_COMPRESSION;\n\n  // Use / instead of . to work around an issue with Maven Shade Plugin\n  private static final Logger log = LoggerFactory.getLogger(\"org/zeroturnaround/zip/ZipUtil\".replace('/', '.')); // NOSONAR\n\n  private ZipUtil() {\n  }\n\n  /* Extracting single entries from ZIP files. */\n\n  /**\n   * Checks if the ZIP file contains the given entry.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return <code>true</code> if the ZIP file contains the given entry.\n   */\n  public static boolean containsEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      return zf.getEntry(name) != null;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Returns the compression method of a given entry of the ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return Returns <code>ZipEntry.STORED</code>, <code>ZipEntry.DEFLATED</code> or -1 if\n   *         the ZIP file does not contain the given entry.\n   * @deprecated The compression level cannot be retrieved. This method exists only to ensure backwards compatibility with ZipUtil version 1.9, which returned the compression\n   *             method, not the level.\n   */\n  @Deprecated\n  public static int getCompressionLevelOfEntry(File zip, String name) {\n    return getCompressionMethodOfEntry(zip, name);\n  }\n\n  /**\n   * Returns the compression method of a given entry of the ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return Returns <code>ZipEntry.STORED</code>, <code>ZipEntry.DEFLATED</code> or -1 if\n   *         the ZIP file does not contain the given entry.\n   */\n  public static int getCompressionMethodOfEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      ZipEntry zipEntry = zf.getEntry(name);\n      if (zipEntry == null) {\n        return -1;\n      }\n      return zipEntry.getMethod();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Checks if the ZIP file contains any of the given entries.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param names\n   *          entry names.\n   * @return <code>true</code> if the ZIP file contains any of the given\n   *         entries.\n   */\n  public static boolean containsAnyEntry(File zip, String[] names) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      for (int i = 0; i < names.length; i++) {\n        if (zf.getEntry(names[i]) != null) {\n          return true;\n        }\n      }\n      return false;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   *\n   * @param charset\n   *          charset to be used to process the zip\n   *\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(File zip, String name, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset != null) {\n        zf = new ZipFile(zip, charset);\n      }\n      else {\n        zf = new ZipFile(zip);\n      }\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(ZipFile zf, String name) {\n    try {\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  private static byte[] doUnpackEntry(ZipFile zf, String name) throws IOException {\n    ZipEntry ze = zf.getEntry(name);\n    if (ze == null) {\n      return null; // entry not found\n    }\n\n    InputStream is = zf.getInputStream(ze);\n    try {\n      return IOUtils.toByteArray(is);\n    }\n    finally {\n      IOUtils.closeQuietly(is);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP stream.\n   *\n   * @param is\n   *          ZIP stream.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(InputStream is, String name) {\n    ByteArrayUnpacker action = new ByteArrayUnpacker();\n    if (!handle(is, name, action))\n      return null; // entry not found\n    return action.getBytes();\n  }\n\n  /**\n   * Copies an entry into a byte array.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class ByteArrayUnpacker implements ZipEntryCallback {\n\n    private byte[] bytes;\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      bytes = IOUtils.toByteArray(in);\n    }\n\n    public byte[] getBytes() {\n      return bytes;\n    }\n\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(File zip, String name, File file) {\n    return unpackEntry(zip, name, file, null);\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @param charset\n   *          charset to be used processing the zip\n   *\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(File zip, String name, File file, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset != null) {\n        zf = new ZipFile(zip, charset);\n      }\n      else {\n        zf = new ZipFile(zip);\n      }\n      return doUnpackEntry(zf, name, file);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(ZipFile zf, String name, File file) {\n    try {\n      return doUnpackEntry(zf, name, file);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  private static boolean doUnpackEntry(ZipFile zf, String name, File file) throws IOException {\n    if (log.isTraceEnabled()) {\n      log.trace(\"Extracting '\" + zf.getName() + \"' entry '\" + name + \"' into '\" + file + \"'.\");\n    }\n\n    ZipEntry ze = zf.getEntry(name);\n    if (ze == null) {\n      return false; // entry not found\n    }\n\n    if (ze.isDirectory() || zf.getInputStream(ze) == null) {\n      if (file.isDirectory()) {\n        return true;\n      }\n      if (file.exists()) {\n        FileUtils.forceDelete(file);\n      }\n      return file.mkdirs();\n    }\n\n    InputStream in = new BufferedInputStream(zf.getInputStream(ze));\n    try {\n      FileUtils.copy(in, file);\n    }\n    finally {\n      IOUtils.closeQuietly(in);\n    }\n    return true;\n  }\n\n  /**\n   * Unpacks a single file from a ZIP stream to a file.\n   *\n   * @param is\n   *          ZIP stream.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   * @throws java.io.IOException if file is not found or writing to it fails\n   */\n  public static boolean unpackEntry(InputStream is, String name, File file) throws IOException {\n    return handle(is, name, new FileUnpacker(file));\n  }\n\n  /**\n   * Copies an entry into a File.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class FileUnpacker implements ZipEntryCallback {\n\n    private final File file;\n\n    public FileUnpacker(File file) {\n      this.file = file;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      FileUtils.copy(in, file);\n    }\n\n  }\n\n  /* Traversing ZIP files */\n\n  /**\n   * Reads the given ZIP file and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipInfoCallback)\n   */\n  public static void iterate(File zip, ZipEntryCallback action) {\n    iterate(zip, action, null);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @param charset\n   *          Charset used to processed the ZipFile with\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipInfoCallback)\n   */\n  public static void iterate(File zip, ZipEntryCallback action, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset == null) {\n        zf = new ZipFile(zip);\n      }\n      else {\n        zf = new ZipFile(zip, charset);\n      }\n\n      Enumeration<? extends ZipEntry> en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n\n        InputStream is = zf.getInputStream(e);\n        try {\n          action.process(is, e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \"' with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipInfoCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipEntryCallback action) {\n    iterate(zip, entryNames, action, null);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset used to process the zip file\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipInfoCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipEntryCallback action, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset == null) {\n        zf = new ZipFile(zip);\n      }\n      else {\n        zf = new ZipFile(zip, charset);\n      }\n\n      for (int i = 0; i < entryNames.length; i++) {\n        ZipEntry e = zf.getEntry(entryNames[i]);\n        if (e == null) {\n          continue;\n        }\n        InputStream is = zf.getInputStream(e);\n        try {\n          action.process(is, e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Scans the given ZIP file and executes the given action for each entry.\n   * <p>\n   * Only the meta-data without the actual data is read. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipInfoCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(File zip, ZipInfoCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      Enumeration<? extends ZipEntry> en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n        try {\n          action.process(e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Scans the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * Only the meta-data without the actual data is read. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipInfoCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipInfoCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      for (int i = 0; i < entryNames.length; i++) {\n        ZipEntry e = zf.getEntry(entryNames[i]);\n        if (e == null) {\n          continue;\n        }\n        try {\n          action.process(e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset to process entries in\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, ZipEntryCallback action, Charset charset) {\n    try {\n      ZipInputStream in = null;\n      try {\n        in = newCloseShieldZipInputStream(is, charset);\n        ZipEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n          try {\n            action.process(in, entry);\n          }\n          catch (IOException ze) {\n            throw new ZipException(\"Failed to process zip entry '\" + entry.getName() + \" with action \" + action, ze);\n          }\n          catch (ZipBreakException ex) {\n            break;\n          }\n        }\n      }\n      finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * See {@link #iterate(InputStream, ZipEntryCallback, Charset)}. This method\n   * is a shorthand for a version where no Charset is specified.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, ZipEntryCallback action) {\n    iterate(is, action, null);\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset to process entries in\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, String[] entryNames, ZipEntryCallback action, Charset charset) {\n    Set<String> namesSet = new HashSet<String>();\n    for (int i = 0; i < entryNames.length; i++) {\n      namesSet.add(entryNames[i]);\n    }\n    try {\n      ZipInputStream in = null;\n      try {\n        in = newCloseShieldZipInputStream(is, charset);\n        ZipEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n          if (!namesSet.contains(entry.getName())) {\n            // skip the unnecessary entry\n            continue;\n          }\n          try {\n            action.process(in, entry);\n          }\n          catch (IOException ze) {\n            throw new ZipException(\"Failed to process zip entry '\" + entry.getName() + \" with action \" + action, ze);\n          }\n          catch (ZipBreakException ex) {\n            break;\n          }\n        }\n      }\n      finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * See @link{ {@link #iterate(InputStream, ZipEntryCallback, Charset)}. It is a\n   * shorthand where no Charset is specified.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, String[] entryNames, ZipEntryCallback action) {\n    iterate(is, entryNames, action, null);\n  }\n\n  /**\n   * Creates a new {@link ZipInputStream} based on the given {@link InputStream}. It will be buffered and close-shielded.\n   * Closing the result stream flushes the buffers and frees up resources of the {@link ZipInputStream}. However the source stream itself remains open.\n   */\n  private static ZipInputStream newCloseShieldZipInputStream(final InputStream is, Charset charset) {\n    InputStream in = new BufferedInputStream(new CloseShieldInputStream(is));\n    if (charset == null) {\n      return new ZipInputStream(in);\n    }\n    return ZipFileUtil.createZipInputStream(in, charset);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for a single entry.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param name\n   *          entry name.\n   * @param action\n   *          action to be called for this entry.\n   * @return <code>true</code> if the entry was found, <code>false</code> if the\n   *         entry was not found.\n   *\n   * @see ZipEntryCallback\n   */\n  public static boolean handle(File zip, String name, ZipEntryCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      ZipEntry ze = zf.getEntry(name);\n      if (ze == null) {\n        return false; // entry not found\n      }\n\n      InputStream in = new BufferedInputStream(zf.getInputStream(ze));\n      try {\n        action.process(in, ze);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n      return true;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for a single\n   * entry.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param name\n   *          entry name.\n   * @param action\n   *          action to be called for this entry.\n   * @return <code>true</code> if the entry was found, <code>false</code> if the\n   *         entry was not found.\n   *\n   * @see ZipEntryCallback\n   */\n  public static boolean handle(InputStream is, String name, ZipEntryCallback action) {\n    SingleZipEntryCallback helper = new SingleZipEntryCallback(name, action);\n    iterate(is, helper);\n    return helper.found();\n  }\n\n  /**\n   * ZipEntryCallback which is only applied to single entry.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class SingleZipEntryCallback implements ZipEntryCallback {\n\n    private final String name;\n\n    private final ZipEntryCallback action;\n\n    private boolean found;\n\n    public SingleZipEntryCallback(String name, ZipEntryCallback action) {\n      this.name = name;\n      this.action = action;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      if (name.equals(zipEntry.getName())) {\n        found = true;\n        action.process(in, zipEntry);\n      }\n    }\n\n    public boolean found() {\n      return found;\n    }\n\n  }\n\n  /* Extracting whole ZIP files. */\n\n  /**\n   * Unpacks a ZIP file to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unpack(File zip, final File outputDir) {\n    unpack(zip, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory using a specific Charset\n   * for the input file.\n   *\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   *\n   * @param charset\n   *          charset used to unpack the zip file\n   */\n  public static void unpack(File zip, final File outputDir, Charset charset) {\n    unpack(zip, outputDir, IdentityNameMapper.INSTANCE, charset);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param charset\n   *          charset used to process the zip file\n   */\n  public static void unpack(File zip, File outputDir, NameMapper mapper, Charset charset) {\n    log.debug(\"Extracting '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unpacker(outputDir, mapper), charset);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory using a specific Charset\n   * for the input file.\n   *\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unpack(File zip, File outputDir, NameMapper mapper) {\n    log.debug(\"Extracting '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unpacker(outputDir, mapper));\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unwrap(File zip, final File outputDir) {\n    unwrap(zip, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unwrap(File zip, File outputDir, NameMapper mapper) {\n    log.debug(\"Unwrapping '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unwraper(outputDir, mapper));\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unpack(InputStream is, File outputDir) {\n    unpack(is, outputDir, IdentityNameMapper.INSTANCE, null);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param charset\n   *          charset used to process the zip stream\n   */\n  public static void unpack(InputStream is, File outputDir, Charset charset) {\n    unpack(is, outputDir, IdentityNameMapper.INSTANCE, charset);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unpack(InputStream is, File outputDir, NameMapper mapper) {\n    unpack(is, outputDir, mapper, null);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param charset\n   *          charset to use when unpacking the stream\n   */\n  public static void unpack(InputStream is, File outputDir, NameMapper mapper, Charset charset) {\n    log.debug(\"Extracting {} into '{}'.\", is, outputDir);\n    iterate(is, new Unpacker(outputDir, mapper), charset);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unwrap(InputStream is, File outputDir) {\n    unwrap(is, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unwrap(InputStream is, File outputDir, NameMapper mapper) {\n    log.debug(\"Unwrapping {} into '{}'.\", is, outputDir);\n    iterate(is, new Unwraper(outputDir, mapper));\n  }\n\n  /**\n   * Unpacks each ZIP entry.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class Unpacker implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n\n    public Unpacker(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        File file = new File(outputDir, name);\n\n        /* If we see the relative traversal string of \"..\" we need to make sure\n         * that the outputdir + name doesn't leave the outputdir. See\n         * DirectoryTraversalMaliciousTest for details.\n         */\n        if (name.indexOf(\"..\") != -1 && !file.getCanonicalPath().startsWith(outputDir.getCanonicalPath())) {\n          throw new ZipException(\"The file \"+name+\" is trying to leave the target output directory of \"+outputDir+\". Ignoring this file.\");\n        }\n\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n\n        ZTFilePermissions permissions = ZipEntryUtil.getZTFilePermissions(zipEntry);\n        if (permissions != null) {\n          ZTFilePermissionsUtil.getDefaultStategy().setPermissions(file, permissions);\n        }\n      }\n    }\n  }\n\n  /**\n   * Unpacks each ZIP entries. Presumes they are packed with the backslash separator.\n   * Some archives can have this problem if they are created with some software\n   * that is not following the ZIP specification.\n   *\n   * @since zt-zip 1.9\n   */\n  public static class BackslashUnpacker implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n\n    public BackslashUnpacker(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public BackslashUnpacker(File outputDir) {\n      this(outputDir, IdentityNameMapper.INSTANCE);\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        /**\n         * We assume that EVERY backslash will denote a directory\n         * separator. Also such broken archives don't have entries that\n         * are just directories. Everything is a file. See the example\n         *\n         * Archive: backSlashTest.zip\n         * testing: testDirectory\\testfileInTestDirectory.txt OK\n         * testing: testDirectory\\testSubdirectory\\testFileInTestSubdirectory.txt OK\n         * No errors detected in compressed data of backSlashTest.zip.\n         */\n        if (name.indexOf('\\\\') != -1) {\n          File parentDirectory = outputDir;\n          String[] dirs = name.split(\"\\\\\\\\\");\n\n          // lets create all the directories and the last entry is the file as EVERY entry is a file\n          for (int i = 0; i < dirs.length - 1; i++) {\n            File file = new File(parentDirectory, dirs[i]);\n            if (!file.exists()) {\n              FileUtils.forceMkdir(file);\n            }\n            parentDirectory = file;\n          }\n          File destFile = new File(parentDirectory, dirs[dirs.length - 1]);\n\n          /* If we see the relative traversal string of \"..\" we need to make sure\n           * that the outputdir + name doesn't leave the outputdir. See\n           * DirectoryTraversalMaliciousTest for details.\n           */\n          if (name.indexOf(\"..\") != -1 && !destFile.getCanonicalPath().startsWith(outputDir.getCanonicalPath())) {\n            throw new ZipException(\"The file \"+name+\" is trying to leave the target output directory of \"+outputDir+\". Ignoring this file.\");\n          }\n\n          FileUtils.copy(in, destFile);\n        }\n        // it could be that there are just top level files that the unpacker is used for\n        else {\n          File destFile = new File(outputDir, name);\n\n          /* If we see the relative traversal string of \"..\" we need to make sure\n           * that the outputdir + name doesn't leave the outputdir. See\n           * DirectoryTraversalMaliciousTest for details.\n           */\n          if (name.indexOf(\"..\") != -1 && !destFile.getCanonicalPath().startsWith(outputDir.getCanonicalPath())) {\n            throw new ZipException(\"The file \"+name+\" is trying to leave the target output directory of \"+outputDir+\". Ignoring this file.\");\n          }\n\n          FileUtils.copy(in, destFile);\n        }\n      }\n    }\n  }\n\n  /**\n   * Unwraps entries excluding a single parent dir. If there are multiple roots\n   * ZipException is thrown.\n   *\n   * @author Oleg Shelajev\n   */\n  private static class Unwraper implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n    private String rootDir;\n\n    public Unwraper(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String root = getRootName(zipEntry.getName());\n      if (rootDir == null) {\n        rootDir = root;\n      }\n      else if (!rootDir.equals(root)) {\n        throw new ZipException(\"Unwrapping with multiple roots is not supported, roots: \" + rootDir + \", \" + root);\n      }\n\n      String name = mapper.map(getUnrootedName(root, zipEntry.getName()));\n      if (name != null) {\n        File file = new File(outputDir, name);\n\n        /* If we see the relative traversal string of \"..\" we need to make sure\n         * that the outputdir + name doesn't leave the outputdir. See\n         * DirectoryTraversalMaliciousTest for details.\n         */\n        if (name.indexOf(\"..\") != -1 && !file.getCanonicalPath().startsWith(outputDir.getCanonicalPath())) {\n          throw new ZipException(\"The file \"+name+\" is trying to leave the target output directory of \"+outputDir+\". Ignoring this file.\");\n        }\n\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n      }\n    }\n\n    private String getUnrootedName(String root, String name) {\n      return name.substring(root.length());\n    }\n\n    private String getRootName(final String name) {\n      String newName = name.substring(FilenameUtils.getPrefixLength(name));\n      int idx = newName.indexOf(PATH_SEPARATOR);\n      if (idx < 0) {\n        throw new ZipException(\"Entry \" + newName + \" from the root of the zip is not supported\");\n      }\n      return newName.substring(0, newName.indexOf(PATH_SEPARATOR));\n    }\n  }\n\n  /**\n   * Unpacks a ZIP file to its own location.\n   * <p>\n   * The ZIP file will be first renamed (using a temporary name). After the\n   * extraction it will be deleted.\n   *\n   * @param zip\n   *          input ZIP file as well as the target directory.\n   *\n   * @see #unpack(File, File)\n   */\n  public static void explode(File zip) {\n    try {\n      // Find a new unique name is the same directory\n      File tempFile = FileUtils.getTempFileFor(zip);\n\n      // Rename the archive\n      FileUtils.moveFile(zip, tempFile);\n\n      // Unpack it\n      unpack(tempFile, zip);\n\n      // Delete the archive\n      if (!tempFile.delete()) {\n        throw new IOException(\"Unable to delete file: \" + tempFile);\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /* Compressing single entries to ZIP files. */\n\n  /**\n   * Compresses the given file into a ZIP file with single entry.\n   *\n   * @param file file to be compressed.\n   * @return ZIP file created.\n   */\n  public static byte[] packEntry(File file) {\n    log.trace(\"Compressing '{}' into a ZIP file with single entry.\", file);\n\n    ByteArrayOutputStream result = new ByteArrayOutputStream();\n    try {\n      ZipOutputStream out = new ZipOutputStream(result);\n      ZipEntry entry = ZipEntryUtil.fromFile(file.getName(), file);\n      InputStream in = new BufferedInputStream(new FileInputStream(file));\n      try {\n        ZipEntryUtil.addEntry(entry, in, out);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n      out.close();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    return result.toByteArray();\n  }\n\n  /* Compressing ZIP files. */\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param rootDir\n   *          root directory.\n   * @param zip\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void pack(File rootDir, File zip) {\n    pack(rootDir, zip, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param rootDir\n   *          root directory.\n   * @param zip\n   *          ZIP file that will be created or overwritten.\n   * @param compressionLevel\n   *          compression level\n   */\n  public static void pack(File rootDir, File zip, int compressionLevel) {\n    pack(rootDir, zip, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param preserveRoot\n   *          true if the resulted archive should have the top directory entry\n   */\n  public static void pack(final File sourceDir, final File targetZipFile, final boolean preserveRoot) {\n    if (preserveRoot) {\n      final String parentName = sourceDir.getName();\n      pack(sourceDir, targetZipFile, new NameMapper() {\n        public String map(String name) {\n          return parentName + PATH_SEPARATOR + name;\n        }\n      });\n    }\n    else {\n      pack(sourceDir, targetZipFile);\n    }\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void packEntry(File fileToPack, File destZipFile) {\n    packEntry(fileToPack, destZipFile, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param fileName\n   *          the name for the file inside the archive\n   */\n  public static void packEntry(File fileToPack, File destZipFile, final String fileName) {\n    packEntry(fileToPack, destZipFile, new NameMapper() {\n      public String map(String name) {\n        return fileName;\n      }\n    });\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void packEntry(File fileToPack, File destZipFile, NameMapper mapper) {\n    packEntries(new File[] { fileToPack }, destZipFile, mapper);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile) {\n    packEntries(filesToPack, destZipFile, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, NameMapper mapper) {\n    packEntries(filesToPack, destZipFile, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param compressionLevel\n   *          ZIP file compression level (speed versus filesize), e.g. <code>Deflater.NO_COMPRESSION</code>, <code>Deflater.BEST_SPEED</code>, or\n   *          <code>Deflater.BEST_COMPRESSION</code>\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, int compressionLevel) {\n    packEntries(filesToPack, destZipFile, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          ZIP file compression level (speed versus filesize), e.g. <code>Deflater.NO_COMPRESSION</code>, <code>Deflater.BEST_SPEED</code>, or\n   *          <code>Deflater.BEST_COMPRESSION</code>\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into '{}'.\", filesToPack, destZipFile);\n\n    ZipOutputStream out = null;\n    FileOutputStream fos = null;\n    try {\n      fos = new FileOutputStream(destZipFile);\n      out = new ZipOutputStream(new BufferedOutputStream(fos));\n      out.setLevel(compressionLevel);\n\n      for (int i = 0; i < filesToPack.length; i++) {\n        File fileToPack = filesToPack[i];\n\n        ZipEntry zipEntry = ZipEntryUtil.fromFile(mapper.map(fileToPack.getName()), fileToPack);\n        out.putNextEntry(zipEntry);\n        FileUtils.copy(fileToPack, out);\n        out.closeEntry();\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n      IOUtils.closeQuietly(fos);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZip\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void pack(File sourceDir, File targetZip, NameMapper mapper) {\n    pack(sourceDir, targetZip, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZip\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          compression level\n   */\n  public static void pack(File sourceDir, File targetZip, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into '{}'.\", sourceDir, targetZip);\n    if (!sourceDir.exists()) {\n      throw new ZipException(\"Given file '\" + sourceDir + \"' doesn't exist!\");\n    }\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(targetZip)));\n      out.setLevel(compressionLevel);\n      pack(sourceDir, out, mapper, \"\", true);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os) {\n    pack(sourceDir, os, IdentityNameMapper.INSTANCE, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param compressionLevel\n   *          compression level\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, int compressionLevel) {\n    pack(sourceDir, os, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param mapper\n   *          call-back for renaming the entries.\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, NameMapper mapper) {\n    pack(sourceDir, os, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          compression level\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into a stream.\", sourceDir);\n    if (!sourceDir.exists()) {\n      throw new ZipException(\"Given file '\" + sourceDir + \"' doesn't exist!\");\n    }\n    ZipOutputStream out = null;\n    IOException error = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(os));\n      out.setLevel(compressionLevel);\n      pack(sourceDir, out, mapper, \"\", true);\n    }\n    catch (IOException e) {\n      error = e;\n    }\n    finally {\n      if (out != null && error == null) {\n        try {\n          out.finish();\n          out.flush();\n        }\n        catch (IOException e) {\n          error = e;\n        }\n      }\n    }\n    if (error != null) {\n      throw ZipExceptionUtil.rethrow(error);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   *\n   * @param dir\n   *          root directory.\n   * @param out\n   *          ZIP output stream.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param pathPrefix\n   *          prefix to be used for the entries.\n   * @param mustHaveChildren\n   *          if true, but directory to pack doesn't have any files, throw an exception.\n   */\n  private static void pack(File dir, ZipOutputStream out, NameMapper mapper, String pathPrefix, boolean mustHaveChildren) throws IOException {\n    String[] filenames = dir.list();\n    if (filenames == null) {\n      if (!dir.exists()) {\n        throw new ZipException(\"Given file '\" + dir + \"' doesn't exist!\");\n      }\n      throw new IOException(\"Given file is not a directory '\" + dir + \"'\");\n    }\n\n    if (mustHaveChildren && filenames.length == 0) {\n      throw new ZipException(\"Given directory '\" + dir + \"' doesn't contain any files!\");\n    }\n\n    for (int i = 0; i < filenames.length; i++) {\n      String filename = filenames[i];\n      File file = new File(dir, filename);\n      boolean isDir = file.isDirectory();\n      String path = pathPrefix + file.getName(); // NOSONAR\n      if (isDir) {\n        path += PATH_SEPARATOR; // NOSONAR\n      }\n\n      // Create a ZIP entry\n      String name = mapper.map(path);\n      if (name != null) {\n        ZipEntry zipEntry = ZipEntryUtil.fromFile(name, file);\n\n        out.putNextEntry(zipEntry);\n\n        // Copy the file content\n        if (!isDir) {\n          FileUtils.copy(file, out);\n        }\n\n        out.closeEntry();\n      }\n\n      // Traverse the directory\n      if (isDir) {\n        pack(file, out, mapper, path, false);\n      }\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP file into a new ZIP with a given compression level.\n   * <p>\n   *\n   * @param srcZip\n   *          source ZIP file.\n   * @param dstZip\n   *          destination ZIP file.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(File srcZip, File dstZip, int compressionLevel) {\n\n    log.debug(\"Repacking '{}' into '{}'.\", srcZip, dstZip);\n\n    RepackZipEntryCallback callback = new RepackZipEntryCallback(dstZip, compressionLevel);\n\n    try {\n      iterate(srcZip, callback);\n    }\n    finally {\n      callback.closeStream();\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP input stream into a ZIP file with a given compression level.\n   * <p>\n   *\n   * @param is\n   *          ZIP input stream.\n   * @param dstZip\n   *          destination ZIP file.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(InputStream is, File dstZip, int compressionLevel) {\n\n    log.debug(\"Repacking from input stream into '{}'.\", dstZip);\n\n    RepackZipEntryCallback callback = new RepackZipEntryCallback(dstZip, compressionLevel);\n\n    try {\n      iterate(is, callback);\n    }\n    finally {\n      callback.closeStream();\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP file and replaces old file with the new one.\n   * <p>\n   *\n   * @param zip\n   *          source ZIP file to be repacked and replaced.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(File zip, int compressionLevel) {\n    try {\n      File tmpZip = FileUtils.getTempFileFor(zip);\n\n      repack(zip, tmpZip, compressionLevel);\n\n      // Delete original zip\n      if (!zip.delete()) {\n        throw new IOException(\"Unable to delete the file: \" + zip);\n      }\n\n      // Rename the archive\n      FileUtils.moveFile(tmpZip, zip);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * RepackZipEntryCallback used in repacking methods.\n   *\n   * @author Pavel Grigorenko\n   */\n  private static final class RepackZipEntryCallback implements ZipEntryCallback {\n\n    private ZipOutputStream out;\n\n    private RepackZipEntryCallback(File dstZip, int compressionLevel) {\n      try {\n        this.out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(dstZip)));\n        this.out.setLevel(compressionLevel);\n      }\n      catch (IOException e) {\n        ZipExceptionUtil.rethrow(e);\n      }\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      ZipEntryUtil.copyEntry(zipEntry, in, out);\n    }\n\n    private void closeStream() {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Compresses a given directory in its own location.\n   * <p>\n   * A ZIP file will be first created with a temporary name. After the\n   * compressing the directory will be deleted and the ZIP file will be renamed\n   * as the original directory.\n   *\n   * @param dir\n   *          input directory as well as the target ZIP file.\n   *\n   * @see #pack(File, File)\n   */\n  public static void unexplode(File dir) {\n    unexplode(dir, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses a given directory in its own location.\n   * <p>\n   * A ZIP file will be first created with a temporary name. After the\n   * compressing the directory will be deleted and the ZIP file will be renamed\n   * as the original directory.\n   *\n   * @param dir\n   *          input directory as well as the target ZIP file.\n   * @param compressionLevel\n   *          compression level\n   *\n   * @see #pack(File, File)\n   */\n  public static void unexplode(File dir, int compressionLevel) {\n    try {\n      // Find a new unique name is the same directory\n      File zip = FileUtils.getTempFileFor(dir);\n\n      // Pack it\n      pack(dir, zip, compressionLevel);\n\n      // Delete the directory\n      FileUtils.deleteDirectory(dir);\n\n      // Rename the archive\n      FileUtils.moveFile(zip, dir);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compresses the given entries into an output stream.\n   *\n   * @param entries\n   *          ZIP entries added.\n   * @param os\n   *          output stream for the new ZIP (does not have to be buffered)\n   *\n   * @since 1.9\n   */\n  public static void pack(ZipEntrySource[] entries, OutputStream os) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Creating stream from {}.\", Arrays.asList(entries));\n    }\n    pack(entries, os, false);\n  }\n\n  private static void pack(ZipEntrySource[] entries, OutputStream os, boolean closeStream) {\n    try {\n      ZipOutputStream out = new ZipOutputStream(os);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.flush();\n      out.finish();\n      if (closeStream) {\n        out.close();\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compresses the given entries into a new ZIP file.\n   *\n   * @param entries\n   *          ZIP entries added.\n   * @param zip\n   *          new ZIP file created.\n   */\n  public static void pack(ZipEntrySource[] entries, File zip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Creating '{}' from {}.\", zip, Arrays.asList(entries));\n    }\n\n    OutputStream out = null;\n    try {\n      out = new BufferedOutputStream(new FileOutputStream(zip));\n      pack(entries, out, true);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry to be added.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, String path, File file, File destZip) {\n    addEntry(zip, new FileSource(path, file), destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry to be added.\n   */\n  public static void addEntry(final File zip, final String path, final File file) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, file, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, String path, byte[] bytes, File destZip) {\n    addEntry(zip, new ByteSource(path, bytes), destZip);\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   */\n  public static void addEntry(File zip, String path, byte[] bytes, File destZip, final int compressionMethod) {\n    addEntry(zip, new ByteSource(path, bytes, compressionMethod), destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   */\n  public static void addEntry(final File zip, final String path, final byte[] bytes) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, bytes, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   */\n  public static void addEntry(final File zip, final String path, final byte[] bytes, final int compressionMethod) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, bytes, tmpFile, compressionMethod);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry appended.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, ZipEntrySource entry, File destZip) {\n    addEntries(zip, new ZipEntrySource[] { entry }, destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry appended.\n   */\n  public static void addEntry(final File zip, final ZipEntrySource entry) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, entry, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    OutputStream destOut = null;\n    try {\n      destOut = new BufferedOutputStream(new FileOutputStream(destZip));\n      addEntries(zip, entries, destOut);\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(destOut);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destOut\n   *          new ZIP destination output stream\n   */\n  public static void addEntries(File zip, ZipEntrySource[] entries, OutputStream destOut) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to a stream and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(destOut);\n      copyEntries(zip, out);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.finish();\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param is\n   *          an existing ZIP input stream.\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destOut\n   *          new ZIP destination output stream\n   *\n   * @since 1.9\n   */\n  public static void addEntries(InputStream is, ZipEntrySource[] entries, OutputStream destOut) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying input stream to an output stream and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(destOut);\n      copyEntries(is, out);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.finish();\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes a zip file it with with new entries. in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   */\n  public static void addEntries(final File zip, final ZipEntrySource[] entries) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntries(zip, entries, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and removes entry with a given path.\n   *\n   * @param zip\n   *          an existing ZIP file (only read)\n   * @param path\n   *          path of the entry to remove\n   * @param destZip\n   *          new ZIP file created.\n   * @since 1.7\n   */\n  public static void removeEntry(File zip, String path, File destZip) {\n    removeEntries(zip, new String[] { path }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: removes entry with a given path.\n   *\n   * @param zip\n   *          an existing ZIP file\n   * @param path\n   *          path of the entry to remove\n   * @since 1.7\n   */\n  public static void removeEntry(final File zip, final String path) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        removeEntry(zip, path, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and removes entries with given paths.\n   *\n   * @param zip\n   *          an existing ZIP file (only read)\n   * @param paths\n   *          paths of the entries to remove\n   * @param destZip\n   *          new ZIP file created.\n   * @since 1.7\n   */\n  public static void removeEntries(File zip, String[] paths, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and removing paths \" + Arrays.asList(paths) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      copyEntries(zip, out, new HashSet<String>(Arrays.asList(paths)));\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Changes an existing ZIP file: removes entries with given paths.\n   *\n   * @param zip\n   *          an existing ZIP file\n   * @param paths\n   *          paths of the entries to remove\n   * @since 1.7\n   */\n  public static void removeEntries(final File zip, final String[] paths) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        removeEntries(zip, paths, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP file to another.\n   *\n   * @param zip\n   *          source ZIP file.\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void copyEntries(File zip, final ZipOutputStream out) {\n    // this one doesn't call copyEntries with ignoredEntries, because that has poorer performance\n    final Set<String> names = new HashSet<String>();\n    iterate(zip, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP stream to another.\n   *\n   * @param is\n   *          source stream (contains ZIP file).\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void copyEntries(InputStream is, final ZipOutputStream out) {\n    // this one doesn't call copyEntries with ignoredEntries, because that has poorer performance\n    final Set<String> names = new HashSet<String>();\n    iterate(is, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP file to another, ignoring entries with path in ignoredEntries\n   *\n   * @param zip\n   *          source ZIP file.\n   * @param out\n   *          target ZIP stream.\n   * @param ignoredEntries\n   *          paths of entries not to copy\n   */\n  private static void copyEntries(File zip, final ZipOutputStream out, final Set<String> ignoredEntries) {\n    final Set<String> names = new HashSet<String>();\n    final Set<String> dirNames = filterDirEntries(zip, ignoredEntries);\n    iterate(zip, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (ignoredEntries.contains(entryName)) {\n          return;\n        }\n\n        for (String dirName : dirNames) {\n          if (entryName.startsWith(dirName)) {\n            return;\n          }\n        }\n\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   *\n   * @param zip\n   *          zip file to traverse\n   * @param names\n   *          names of entries to filter dirs from\n   * @return Set<String> names of entries that are dirs.\n   *\n   */\n  static Set<String> filterDirEntries(File zip, Collection<String> names) {\n    Set<String> dirs = new HashSet<String>();\n    if (zip == null) {\n      return dirs;\n    }\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      for (String entryName : names) {\n        ZipEntry entry = zf.getEntry(entryName);\n        if (entry != null) {\n          if (entry.isDirectory()) {\n            dirs.add(entry.getName());\n          }\n          else if (zf.getInputStream(entry) == null) {\n            // no input stream means that this is a dir.\n            dirs.add(entry.getName() + PATH_SEPARATOR);\n          }\n        }\n      }\n\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n    return dirs;\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, String path, File file, File destZip) {\n    return replaceEntry(zip, new FileSource(path, file), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final File file) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new FileSource(path, file), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, String path, byte[] bytes, File destZip) {\n    return replaceEntry(zip, new ByteSource(path, bytes), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final byte[] bytes) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new ByteSource(path, bytes), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final byte[] bytes,\n      final int compressionMethod) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new ByteSource(path, bytes, compressionMethod), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, ZipEntrySource entry, File destZip) {\n    return replaceEntries(zip, new ZipEntrySource[] { entry }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param entry\n   *          new ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final ZipEntrySource entry) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, entry, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries to be replaced with.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean replaceEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and replacing entries \" + Arrays.asList(entries) + \".\");\n    }\n\n    final Map<String, ZipEntrySource> entryByPath = entriesByPath(entries);\n    final int entryCount = entryByPath.size();\n    try {\n      final ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        final Set<String> names = new HashSet<String>();\n        iterate(zip, new ZipEntryCallback() {\n          public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n            if (names.add(zipEntry.getName())) {\n              ZipEntrySource entry = (ZipEntrySource) entryByPath.remove(zipEntry.getName());\n              if (entry != null) {\n                addEntry(entry, out);\n              }\n              else {\n                ZipEntryUtil.copyEntry(zipEntry, in, out);\n              }\n            }\n            else if (log.isDebugEnabled()) {\n              log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n            }\n          }\n        });\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    return entryByPath.size() < entryCount;\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param entries\n   *          new ZIP entries to be replaced with.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean replaceEntries(final File zip, final ZipEntrySource[] entries) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntries(zip, entries, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and adds/replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entries to be replaced or added.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addOrReplaceEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and adding/replacing entries \" + Arrays.asList(entries)\n          + \".\");\n    }\n\n    final Map<String, ZipEntrySource> entryByPath = entriesByPath(entries);\n    try {\n      final ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        // Copy and replace entries\n        final Set<String> names = new HashSet<String>();\n        iterate(zip, new ZipEntryCallback() {\n          public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n            if (names.add(zipEntry.getName())) {\n              ZipEntrySource entry = (ZipEntrySource) entryByPath.remove(zipEntry.getName());\n              if (entry != null) {\n                addEntry(entry, out);\n              }\n              else {\n                ZipEntryUtil.copyEntry(zipEntry, in, out);\n              }\n            }\n            else if (log.isDebugEnabled()) {\n              log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n            }\n          }\n        });\n\n        // Add new entries\n        for (ZipEntrySource zipEntrySource : entryByPath.values()) {\n          addEntry(zipEntrySource, out);\n        }\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes a ZIP file: adds/replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entries to be replaced or added.\n   */\n  public static void addOrReplaceEntries(final File zip, final ZipEntrySource[] entries) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addOrReplaceEntries(zip, entries, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * @return given entries indexed by path.\n   */\n  static Map<String, ZipEntrySource> entriesByPath(ZipEntrySource... entries) {\n    Map<String, ZipEntrySource> result = new HashMap<String, ZipEntrySource>();\n    for (int i = 0; i < entries.length; i++) {\n      ZipEntrySource source = entries[i];\n      result.put(source.getPath(), source);\n    }\n    return result;\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @throws IllegalArgumentException if the destination is the same as the location\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(File zip, String path, ZipEntryTransformer transformer, File destZip) {\n    if(zip.equals(destZip)){throw new IllegalArgumentException(\"Input (\" +zip.getAbsolutePath()+ \") is the same as the destination!\" +\n            \"Please use the transformEntry method without destination for in-place transformation.\" );}\n    return transformEntry(zip, new ZipEntryTransformerEntry(path, transformer), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(final File zip, final String path, final ZipEntryTransformer transformer) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntry(zip, path, transformer, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(File zip, ZipEntryTransformerEntry entry, File destZip) {\n    return transformEntries(zip, new ZipEntryTransformerEntry[] { entry }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(final File zip, final ZipEntryTransformerEntry entry) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntry(zip, entry, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entry transformers.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean transformEntries(File zip, ZipEntryTransformerEntry[] entries, File destZip) {\n    if (log.isDebugEnabled())\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and transforming entries \" + Arrays.asList(entries) + \".\");\n\n    try {\n      ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        TransformerZipEntryCallback action = new TransformerZipEntryCallback(Arrays.asList(entries), out);\n        iterate(zip, action);\n        return action.found();\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entry transformers.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntries(final File zip, final ZipEntryTransformerEntry[] entries) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntries(zip, entries, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(InputStream is, String path, ZipEntryTransformer transformer, OutputStream os) {\n    return transformEntry(is, new ZipEntryTransformerEntry(path, transformer), os);\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(InputStream is, ZipEntryTransformerEntry entry, OutputStream os) {\n    return transformEntries(is, new ZipEntryTransformerEntry[] { entry }, os);\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms the given entries in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param entries\n   *          ZIP entry transformers.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean transformEntries(InputStream is, ZipEntryTransformerEntry[] entries, OutputStream os) {\n    if (log.isDebugEnabled())\n      log.debug(\"Copying '\" + is + \"' to '\" + os + \"' and transforming entries \" + Arrays.asList(entries) + \".\");\n\n    try {\n      ZipOutputStream out = new ZipOutputStream(os);\n      TransformerZipEntryCallback action = new TransformerZipEntryCallback(Arrays.asList(entries), out);\n      iterate(is, action);\n      // Finishes writing the contents of the ZIP output stream without closing\n      // the underlying stream.\n      out.finish();\n      return action.found();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  private static class TransformerZipEntryCallback implements ZipEntryCallback {\n\n    private final Map<String, ZipEntryTransformer> entryByPath;\n    private final int entryCount;\n    private final ZipOutputStream out;\n    private final Set<String> names = new HashSet<String>();\n\n    public TransformerZipEntryCallback(List<ZipEntryTransformerEntry> entries, ZipOutputStream out) {\n      entryByPath = transformersByPath(entries);\n      entryCount = entryByPath.size();\n      this.out = out;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      if (names.add(zipEntry.getName())) {\n        ZipEntryTransformer entry = (ZipEntryTransformer) entryByPath.remove(zipEntry.getName());\n        if (entry != null) {\n          entry.transform(in, zipEntry, out);\n        }\n        else {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n      }\n      else if (log.isDebugEnabled()) {\n        log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n      }\n    }\n\n    /**\n     * @return <code>true</code> if at least one entry was replaced.\n     */\n    public boolean found() {\n      return entryByPath.size() < entryCount;\n    }\n\n  }\n\n  /**\n   * @return transformers by path.\n   */\n  static Map<String, ZipEntryTransformer> transformersByPath(List<ZipEntryTransformerEntry> entries) {\n    Map<String, ZipEntryTransformer> result = new HashMap<String, ZipEntryTransformer>();\n    for (ZipEntryTransformerEntry entry : entries) {\n      result.put(entry.getPath(), entry.getTransformer());\n    }\n    return result;\n  }\n\n  /**\n   * Adds a given ZIP entry to a ZIP file.\n   *\n   * @param entry\n   *          new ZIP entry.\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void addEntry(ZipEntrySource entry, ZipOutputStream out) throws IOException {\n    out.putNextEntry(entry.getEntry());\n    InputStream in = entry.getInputStream();\n    if (in != null) {\n      try {\n        IOUtils.copy(in, out);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n    }\n    out.closeEntry();\n  }\n\n  /* Comparing two ZIP files. */\n\n  /**\n   * Compares two ZIP files and returns <code>true</code> if they contain same\n   * entries.\n   * <p>\n   * First the two files are compared byte-by-byte. If a difference is found the\n   * corresponding entries of both ZIP files are compared. Thus if same contents\n   * is packed differently the two archives may still be the same.\n   * </p>\n   * <p>\n   * Two archives are considered the same if\n   * <ol>\n   * <li>they contain same number of entries,</li>\n   * <li>for each entry in the first archive there exists an entry with the same\n   * in the second archive</li>\n   * <li>for each entry in the first archive and the entry with the same name in\n   * the second archive\n   * <ol>\n   * <li>both are either directories or files,</li>\n   * <li>both have the same size,</li>\n   * <li>both have the same CRC,</li>\n   * <li>both have the same contents (compared byte-by-byte).</li>\n   * </ol>\n   * </li>\n   * </ol>\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @return <code>true</code> if the two ZIP files contain same entries,\n   *         <code>false</code> if a difference was found or an error occurred\n   *         during the comparison.\n   */\n  public static boolean archiveEquals(File f1, File f2) {\n    try {\n      // Check the files byte-by-byte\n      if (FileUtils.contentEquals(f1, f2)) {\n        return true;\n      }\n\n      log.debug(\"Comparing archives '{}' and '{}'...\", f1, f2);\n\n      long start = System.currentTimeMillis();\n      boolean result = archiveEqualsInternal(f1, f2);\n      long time = System.currentTimeMillis() - start;\n      if (time > 0) {\n        log.debug(\"Archives compared in \" + time + \" ms.\");\n      }\n      return result;\n    }\n    catch (Exception e) {\n      log.debug(\"Could not compare '\" + f1 + \"' and '\" + f2 + \"':\", e);\n      return false;\n    }\n  }\n\n  private static boolean archiveEqualsInternal(File f1, File f2) throws IOException {\n    ZipFile zf1 = null;\n    ZipFile zf2 = null;\n    try {\n      zf1 = new ZipFile(f1);\n      zf2 = new ZipFile(f2);\n\n      // Check the number of entries\n      if (zf1.size() != zf2.size()) {\n        log.debug(\"Number of entries changed (\" + zf1.size() + \" vs \" + zf2.size() + \").\");\n        return false;\n      }\n      /*\n       * As there are same number of entries in both archives we can traverse\n       * all entries of one of the archives and get the corresponding entries\n       * from the other archive.\n       *\n       * If a corresponding entry is missing from the second archive the\n       * archives are different and we finish the comparison.\n       *\n       * We guarantee that no entry of the second archive is skipped as there\n       * are same number of unique entries in both archives.\n       */\n      Enumeration<? extends ZipEntry> en = zf1.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e1 = (ZipEntry) en.nextElement();\n        String path = e1.getName();\n        ZipEntry e2 = zf2.getEntry(path);\n\n        // Check meta data\n        if (!metaDataEquals(path, e1, e2)) {\n          return false;\n        }\n\n        // Check the content\n        InputStream is1 = null;\n        InputStream is2 = null;\n        try {\n          is1 = zf1.getInputStream(e1);\n          is2 = zf2.getInputStream(e2);\n\n          if (!IOUtils.contentEquals(is1, is2)) {\n            log.debug(\"Entry '{}' content changed.\", path);\n            return false;\n          }\n        }\n        finally {\n          IOUtils.closeQuietly(is1);\n          IOUtils.closeQuietly(is2);\n        }\n      }\n    }\n    finally {\n      closeQuietly(zf1);\n      closeQuietly(zf2);\n    }\n\n    log.debug(\"Archives are the same.\");\n\n    return true;\n  }\n\n  /**\n   * Compares meta-data of two ZIP entries.\n   * <p>\n   * Two entries are considered the same if\n   * <ol>\n   * <li>both entries exist,</li>\n   * <li>both entries are either directories or files,</li>\n   * <li>both entries have the same size,</li>\n   * <li>both entries have the same CRC.</li>\n   * </ol>\n   *\n   * @param path\n   *          name of the entries.\n   * @param e1\n   *          first entry (required).\n   * @param e2\n   *          second entry (may be <code>null</code>).\n   * @return <code>true</code> if no difference was found.\n   */\n  private static boolean metaDataEquals(String path, ZipEntry e1, ZipEntry e2) throws IOException {\n    // Check if the same entry exists in the second archive\n    if (e2 == null) {\n      log.debug(\"Entry '{}' removed.\", path);\n      return false;\n    }\n\n    // Check the directory flag\n    if (e1.isDirectory()) {\n      if (e2.isDirectory()) {\n        return true; // Let's skip the directory as there is nothing to compare\n      }\n      else {\n        log.debug(\"Entry '{}' not a directory any more.\", path);\n        return false;\n      }\n    }\n    else if (e2.isDirectory()) {\n      log.debug(\"Entry '{}' now a directory.\", path);\n      return false;\n    }\n\n    // Check the size\n    long size1 = e1.getSize();\n    long size2 = e2.getSize();\n    if (size1 != -1 && size2 != -1 && size1 != size2) {\n      log.debug(\"Entry '\" + path + \"' size changed (\" + size1 + \" vs \" + size2 + \").\");\n      return false;\n    }\n\n    // Check the CRC\n    long crc1 = e1.getCrc();\n    long crc2 = e2.getCrc();\n    if (crc1 != -1 && crc2 != -1 && crc1 != crc2) {\n      log.debug(\"Entry '\" + path + \"' CRC changed (\" + crc1 + \" vs \" + crc2 + \").\");\n      return false;\n    }\n\n    // Check the time (ignored, logging only)\n    if (log.isTraceEnabled()) {\n      long time1 = e1.getTime();\n      long time2 = e2.getTime();\n      if (time1 != -1 && time2 != -1 && time1 != time2) {\n        log.trace(\"Entry '\" + path + \"' time changed (\" + new Date(time1) + \" vs \" + new Date(time2) + \").\");\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Compares same entry in two ZIP files (byte-by-byte).\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @param path\n   *          name of the entry.\n   * @return <code>true</code> if the contents of the entry was same in both ZIP\n   *         files.\n   */\n  public static boolean entryEquals(File f1, File f2, String path) {\n    return entryEquals(f1, f2, path, path);\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  public static boolean entryEquals(File f1, File f2, String path1, String path2) {\n    ZipFile zf1 = null;\n    ZipFile zf2 = null;\n\n    try {\n      zf1 = new ZipFile(f1);\n      zf2 = new ZipFile(f2);\n\n      return doEntryEquals(zf1, zf2, path1, path2);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf1);\n      closeQuietly(zf2);\n    }\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param zf1\n   *          first ZIP file.\n   * @param zf2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  public static boolean entryEquals(ZipFile zf1, ZipFile zf2, String path1, String path2) {\n    try {\n      return doEntryEquals(zf1, zf2, path1, path2);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param zf1\n   *          first ZIP file.\n   * @param zf2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  private static boolean doEntryEquals(ZipFile zf1, ZipFile zf2, String path1, String path2) throws IOException {\n    InputStream is1 = null;\n    InputStream is2 = null;\n    try {\n      ZipEntry e1 = zf1.getEntry(path1);\n      ZipEntry e2 = zf2.getEntry(path2);\n\n      if (e1 == null && e2 == null) {\n        return true;\n      }\n\n      if (e1 == null || e2 == null) {\n        return false;\n      }\n\n      is1 = zf1.getInputStream(e1);\n      is2 = zf2.getInputStream(e2);\n      if (is1 == null && is2 == null) {\n        return true;\n      }\n      if (is1 == null || is2 == null) {\n        return false;\n      }\n\n      return IOUtils.contentEquals(is1, is2);\n    }\n    finally {\n      IOUtils.closeQuietly(is1);\n      IOUtils.closeQuietly(is2);\n    }\n  }\n\n  /**\n   * Closes the ZIP file while ignoring any errors.\n   *\n   * @param zf\n   *          ZIP file to be closed.\n   */\n  public static void closeQuietly(ZipFile zf) {\n    try {\n      if (zf != null) {\n        zf.close();\n      }\n    }\n    catch (IOException e) {\n    }\n  }\n\n  /**\n   * Simple helper to make inplace operation easier\n   *\n   * @author shelajev\n   */\n  private abstract static class InPlaceAction {\n\n    /**\n     * @return true if something has been changed during the action.\n     */\n    abstract boolean act(File tmpFile);\n  }\n\n  /**\n   *\n   * This method provides a general infrastructure for in-place operations.\n   * It creates temp file as a destination, then invokes the action on source and destination.\n   * Then it copies the result back into src file.\n   *\n   * @param src - source zip file we want to modify\n   * @param action - action which actually modifies the archives\n   *\n   * @return result of the action\n   */\n  private static boolean operateInPlace(File src, InPlaceAction action) {\n    File tmp = null;\n    try {\n      tmp = File.createTempFile(\"zt-zip-tmp\", \".zip\");\n      boolean result = action.act(tmp);\n      if (result) { // else nothing changes\n        FileUtils.forceDelete(src);\n        FileUtils.moveFile(tmp, src);\n      }\n      return result;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      FileUtils.deleteQuietly(tmp);\n    }\n  }\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "vul4j",
    "idx": 200199,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/**\n * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/\n *\n * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).\n *\n * This program is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free Software\n * Foundation; either version 3.0 of the License, or (at your option) any later\n * version.\n *\n * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along\n * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.\n *\n */\n\npackage org.bigbluebutton.api;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.bigbluebutton.api.domain.Recording;\nimport org.bigbluebutton.api.domain.RecordingMetadata;\nimport org.bigbluebutton.api.messaging.messages.MakePresentationDownloadableMsg;\nimport org.bigbluebutton.api.util.RecordingMetadataReaderHelper;\nimport org.bigbluebutton.api2.domain.UploadedTrack;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RecordingService {\n    private static Logger log = LoggerFactory.getLogger(RecordingService.class);\n\n    private static String processDir = \"/var/bigbluebutton/recording/process\";\n    private static String publishedDir = \"/var/bigbluebutton/published\";\n    private static String unpublishedDir = \"/var/bigbluebutton/unpublished\";\n    private static String deletedDir = \"/var/bigbluebutton/deleted\";\n    private RecordingMetadataReaderHelper recordingServiceHelper;\n    private String recordStatusDir;\n    private String captionsDir;\n    private String presentationBaseDir;\n    private String defaultServerUrl;\n    private String defaultTextTrackUrl;\n\n    private void copyPresentationFile(File presFile, File dlownloadableFile) {\n        try {\n            FileUtils.copyFile(presFile, dlownloadableFile);\n        } catch (IOException ex) {\n            log.error(\"Failed to copy file: {}\", ex);\n        }\n    }\n\n    public void processMakePresentationDownloadableMsg(MakePresentationDownloadableMsg msg) {\n        File presDir = Util.getPresentationDir(presentationBaseDir, msg.meetingId, msg.presId);\n        File downloadableFile = new File(presDir.getAbsolutePath() + File.separatorChar + msg.presFilename);\n\n        if (presDir != null) {\n            if (msg.downloadable) {\n                String fileExt = FilenameUtils.getExtension(msg.presFilename);\n                File presFile = new File(presDir.getAbsolutePath() + File.separatorChar + msg.presId + \".\" + fileExt);\n                log.info(\"Make file downloadable. {}\", downloadableFile.getAbsolutePath());\n                copyPresentationFile(presFile, downloadableFile);\n            } else {\n                if (downloadableFile.exists()) {\n                    if(downloadableFile.delete()) {\n                        log.info(\"File deleted. {}\", downloadableFile.getAbsolutePath());\n                    } else {\n                        log.warn(\"Failed to delete. {}\", downloadableFile.getAbsolutePath());\n                    }\n                }\n            }\n        }\n    }\n\n    public File getDownloadablePresentationFile(String meetingId, String presId, String presFilename) {\n    \tlog.info(\"Find downloadable presentation for meetingId={} presId={} filename={}\", meetingId, presId, presFilename);\n\n        File presDir = Util.getPresentationDir(presentationBaseDir, meetingId, presId);\n        return new File(presDir.getAbsolutePath() + File.separatorChar + presFilename);\n    }\n\n    public void kickOffRecordingChapterBreak(String meetingId, Long timestamp) {\n        String done = recordStatusDir + File.separatorChar + meetingId + \"-\" + timestamp + \".done\";\n\n        File doneFile = new File(done);\n        if (!doneFile.exists()) {\n            try {\n                doneFile.createNewFile();\n                if (!doneFile.exists())\n                    log.error(\"Failed to create {} file.\", done);\n            } catch (IOException e) {\n                log.error(\"Exception occured when trying to create {} file\", done);\n            }\n        } else {\n            log.error(\"{} file already exists.\", done);\n        }\n    }\n\n    public void startIngestAndProcessing(String meetingId) {\n        String done = recordStatusDir + File.separatorChar + meetingId + \".done\";\n\n        File doneFile = new File(done);\n        if (!doneFile.exists()) {\n            try {\n                doneFile.createNewFile();\n                if (!doneFile.exists())\n                    log.error(\"Failed to create {} file.\", done);\n            } catch (IOException e) {\n                log.error(\"Exception occured when trying to create {} file.\", done);\n            }\n        } else {\n            log.error(\"{} file already exists.\", done);\n        }\n    }\n\n    public void markAsEnded(String meetingId) {\n        String done = recordStatusDir + \"/../ended/\" + meetingId + \".done\";\n\n        File doneFile = new File(done);\n        if (!doneFile.exists()) {\n            try {\n                doneFile.createNewFile();\n                if (!doneFile.exists())\n                    log.error(\"Failed to create \" + done + \" file.\");\n            } catch (IOException e) {\n                log.error(\"Exception occured when trying to create {} file.\", done);\n            }\n        } else {\n            log.error(done + \" file already exists.\");\n        }\n    }\n\n    public List<RecordingMetadata> getRecordingsMetadata(List<String> recordIDs, List<String> states) {\n        List<RecordingMetadata> recs = new ArrayList<>();\n\n        Map<String, List<File>> allDirectories = getAllDirectories(states);\n        if (recordIDs.isEmpty()) {\n            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {\n                recordIDs.addAll(getAllRecordingIds(entry.getValue()));\n            }\n        }\n\n        for (String recordID : recordIDs) {\n            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {\n                List<File> _recs = getRecordingsForPath(recordID, entry.getValue());\n                for (File _rec : _recs) {\n                    RecordingMetadata r = getRecordingMetadata(_rec);\n                    if (r != null) {\n                        recs.add(r);\n                    }\n                }\n            }\n        }\n\n        return recs;\n    }\n\n    public Boolean validateTextTrackSingleUseToken(String recordId, String caption, String token) {\n        return recordingServiceHelper.validateTextTrackSingleUseToken(recordId, caption, token);\n    }\n\n    public String getRecordingTextTracks(String recordId) {\n        return recordingServiceHelper.getRecordingTextTracks(recordId, captionsDir, getCaptionFileUrlDirectory());\n    }\n\n    public String putRecordingTextTrack(UploadedTrack track) {\n        return recordingServiceHelper.putRecordingTextTrack(track);\n    }\n\n    public String getRecordings2x(List<String> idList, List<String> states, Map<String, String> metadataFilters) {\n        List<RecordingMetadata> recsList = getRecordingsMetadata(idList, states);\n        ArrayList<RecordingMetadata> recs = filterRecordingsByMetadata(recsList, metadataFilters);\n        return recordingServiceHelper.getRecordings2x(recs);\n    }\n\n    private RecordingMetadata getRecordingMetadata(File dir) {\n        File file = new File(dir.getPath() + File.separatorChar + \"metadata.xml\");\n        return recordingServiceHelper.getRecordingMetadata(file);\n    }\n\n    public boolean recordingMatchesMetadata(RecordingMetadata recording, Map<String, String> metadataFilters) {\n        boolean matchesMetadata = true;\n        Map<String, String> recMeta = recording.getMeta();\n        for (Map.Entry<String, String> filter : metadataFilters.entrySet()) {\n            String metadataValue = recMeta.get(filter.getKey());\n            if ( metadataValue == null ) {\n                // The recording doesn't have metadata specified\n                matchesMetadata = false;\n            } else {\n                String filterValue = filter.getValue();\n                if( filterValue.charAt(0) == '%' && filterValue.charAt(filterValue.length()-1) == '%' && metadataValue.contains(filterValue.substring(1, filterValue.length()-1)) ){\n                    // Filter value embraced by two wild cards\n                    // AND the filter value is part of the metadata value\n                } else if( filterValue.charAt(0) == '%' && metadataValue.endsWith(filterValue.substring(1, filterValue.length())) ) {\n                    // Filter value starts with a wild cards\n                    // AND the filter value ends with the metadata value\n                } else if( filterValue.charAt(filterValue.length()-1) == '%' && metadataValue.startsWith(filterValue.substring(0, filterValue.length()-1)) ) {\n                    // Filter value ends with a wild cards\n                    // AND the filter value starts with the metadata value\n                } else if( metadataValue.equals(filterValue) ) {\n                    // Filter value doesnt have wildcards\n                    // AND the filter value is the same as metadata value\n                } else {\n                    matchesMetadata = false;\n                }\n            }\n        }\n        return matchesMetadata;\n    }\n\n\n    public ArrayList<RecordingMetadata> filterRecordingsByMetadata(List<RecordingMetadata> recordings, Map<String, String> metadataFilters) {\n        ArrayList<RecordingMetadata> resultRecordings = new ArrayList<>();\n        for (RecordingMetadata entry : recordings) {\n            if (recordingMatchesMetadata(entry, metadataFilters))\n                resultRecordings.add(entry);\n        }\n        return resultRecordings;\n    }\n\n    private ArrayList<File> getAllRecordingsFor(String recordId) {\n        String[] format = getPlaybackFormats(publishedDir);\n        ArrayList<File> ids = new ArrayList<File>();\n\n        for (int i = 0; i < format.length; i++) {\n            List<File> recordings = getDirectories(publishedDir + File.separatorChar + format[i]);\n            for (int f = 0; f < recordings.size(); f++) {\n                if (recordId.equals(recordings.get(f).getName()))\n                    ids.add(recordings.get(f));\n            }\n        }\n\n        return ids;\n    }\n\n    public boolean isRecordingExist(String recordId) {\n        List<String> publishList = getAllRecordingIds(publishedDir);\n        List<String> unpublishList = getAllRecordingIds(unpublishedDir);\n        if (publishList.contains(recordId) || unpublishList.contains(recordId)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public boolean existAnyRecording(List<String> idList) {\n        List<String> publishList = getAllRecordingIds(publishedDir);\n        List<String> unpublishList = getAllRecordingIds(unpublishedDir);\n\n        for (String id : idList) {\n            if (publishList.contains(id) || unpublishList.contains(id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private List<String> getAllRecordingIds(String path) {\n        String[] format = getPlaybackFormats(path);\n\n        return getAllRecordingIds(path, format);\n    }\n\n    private List<String> getAllRecordingIds(String path, String[] format) {\n        List<String> ids = new ArrayList<>();\n\n        for (String aFormat : format) {\n            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);\n            for (File recording : recordings) {\n                if (!ids.contains(recording.getName())) {\n                    ids.add(recording.getName());\n                }\n            }\n        }\n\n        return ids;\n    }\n\n    private Set<String> getAllRecordingIds(List<File> recs) {\n        Set<String> ids = new HashSet<>();\n\n        Iterator<File> iterator = recs.iterator();\n        while (iterator.hasNext()) {\n            ids.add(iterator.next().getName());\n        }\n\n        return ids;\n    }\n\n    private List<File> getRecordingsForPath(String id, List<File> recordings) {\n        List<File> recs = new ArrayList<>();\n\n        Iterator<File> iterator = recordings.iterator();\n        while (iterator.hasNext()) {\n            File rec = iterator.next();\n            if (rec.getName().startsWith(id)) {\n              recs.add(rec);\n            }\n        }\n        return recs;\n    }\n\n    private static void deleteRecording(String id, String path) {\n        String[] format = getPlaybackFormats(path);\n        for (String aFormat : format) {\n            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);\n            for (File recording : recordings) {\n                if (recording.getName().equals(id)) {\n                    deleteDirectory(recording);\n                    createDirectory(recording);\n                }\n            }\n        }\n    }\n\n    private static void createDirectory(File directory) {\n        if (!directory.exists())\n            directory.mkdirs();\n    }\n\n    private static void deleteDirectory(File directory) {\n        /**\n         * Go through each directory and check if it's not empty. We need to\n         * delete files inside a directory before a directory can be deleted.\n         **/\n        File[] files = directory.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {\n                deleteDirectory(file);\n            } else {\n                file.delete();\n            }\n        }\n        // Now that the directory is empty. Delete it.\n        directory.delete();\n    }\n\n    private static List<File> getDirectories(String path) {\n        List<File> files = new ArrayList<>();\n        try {\n            DirectoryStream<Path> stream = Files.newDirectoryStream(FileSystems.getDefault().getPath(path));\n            Iterator<Path> iter = stream.iterator();\n            while (iter.hasNext()) {\n                Path next = iter.next();\n                files.add(next.toFile());\n            }\n            stream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return files;\n    }\n\n    private static String[] getPlaybackFormats(String path) {\n        System.out.println(\"Getting playback formats at \" + path);\n        List<File> dirs = getDirectories(path);\n        String[] formats = new String[dirs.size()];\n\n        for (int i = 0; i < dirs.size(); i++) {\n            System.out.println(\"Playback format = \" + dirs.get(i).getName());\n            formats[i] = dirs.get(i).getName();\n        }\n        return formats;\n    }\n\n    public void setRecordingStatusDir(String dir) {\n        recordStatusDir = dir;\n    }\n\n    public void setUnpublishedDir(String dir) {\n        unpublishedDir = dir;\n    }\n\n    public void setPresentationBaseDir(String dir) {\n        presentationBaseDir = dir;\n    }\n\n    public void setDefaultServerUrl(String url) {\n        defaultServerUrl = url;\n    }\n\n    public void setDefaultTextTrackUrl(String url) {\n        defaultTextTrackUrl = url;\n    }\n\n    public void setPublishedDir(String dir) {\n        publishedDir = dir;\n    }\n\n    public void setCaptionsDir(String dir) {\n        captionsDir = dir;\n    }\n\n    public void setRecordingServiceHelper(RecordingMetadataReaderHelper r) {\n        recordingServiceHelper = r;\n    }\n\n    private boolean shouldIncludeState(List<String> states, String type) {\n        boolean r = false;\n\n        if (!states.isEmpty()) {\n            if (states.contains(\"any\")) {\n                r = true;\n            } else {\n                if (type.equals(Recording.STATE_PUBLISHED) && states.contains(Recording.STATE_PUBLISHED)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_UNPUBLISHED) && states.contains(Recording.STATE_UNPUBLISHED)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_DELETED) && states.contains(Recording.STATE_DELETED)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_PROCESSING) && states.contains(Recording.STATE_PROCESSING)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_PROCESSED) && states.contains(Recording.STATE_PROCESSED)) {\n                    r = true;\n                }\n            }\n\n        } else {\n            if (type.equals(Recording.STATE_PUBLISHED) || type.equals(Recording.STATE_UNPUBLISHED)) {\n                r = true;\n            }\n        }\n\n        return r;\n    }\n\n    public boolean changeState(String recordingId, String state) {\n        boolean succeeded = false;\n        if (state.equals(Recording.STATE_PUBLISHED)) {\n            // It can only be published if it is unpublished\n            succeeded |= changeState(unpublishedDir, recordingId, state);\n        } else if (state.equals(Recording.STATE_UNPUBLISHED)) {\n            // It can only be unpublished if it is published\n            succeeded |= changeState(publishedDir, recordingId, state);\n        } else if (state.equals(Recording.STATE_DELETED)) {\n            // It can be deleted from any state\n            succeeded |= changeState(publishedDir, recordingId, state);\n            succeeded |= changeState(unpublishedDir, recordingId, state);\n        }\n        return succeeded;\n    }\n\n    private boolean changeState(String path, String recordingId, String state) {\n        boolean exists = false;\n        boolean succeeded = true;\n        String[] format = getPlaybackFormats(path);\n         for (String aFormat : format) {\n            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);\n            for (File recording : recordings) {\n                if (recording.getName().equalsIgnoreCase(recordingId)) {\n                    exists = true;\n                    File dest;\n                    if (state.equals(Recording.STATE_PUBLISHED)) {\n                       dest = new File(publishedDir + File.separatorChar + aFormat);\n                       succeeded &= publishRecording(dest, recordingId, recording, aFormat);\n                    } else if (state.equals(Recording.STATE_UNPUBLISHED)) {\n                       dest = new File(unpublishedDir + File.separatorChar + aFormat);\n                       succeeded &= unpublishRecording(dest, recordingId, recording, aFormat);\n                    } else if (state.equals(Recording.STATE_DELETED)) {\n                       dest = new File(deletedDir + File.separatorChar + aFormat);\n                       succeeded &= deleteRecording(dest, recordingId, recording, aFormat);\n                    } else {\n                       log.debug(String.format(\"State: %s, is not supported\", state));\n                       return false;\n                    }\n                }\n            }\n        }\n        return exists && succeeded;\n    }\n\n    public boolean publishRecording(File destDir, String recordingId, File recordingDir, String format) {\n        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());\n        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);\n        if (r != null) {\n            if (!destDir.exists()) destDir.mkdirs();\n\n            try {\n                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));\n\n                r.setState(Recording.STATE_PUBLISHED);\n                r.setPublished(true);\n\n                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(\n                  destDir.getAbsolutePath() + File.separatorChar + recordingId);\n\n                // Process the changes by saving the recording into metadata.xml\n                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);\n            } catch (IOException e) {\n              log.error(\"Failed to publish recording : \" + recordingId, e);\n            }\n        }\n        return false;\n    }\n\n    public boolean unpublishRecording(File destDir, String recordingId, File recordingDir, String format) {\n        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());\n\n        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);\n        if (r != null) {\n            if (!destDir.exists()) destDir.mkdirs();\n\n            try {\n                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));\n                r.setState(Recording.STATE_UNPUBLISHED);\n                r.setPublished(false);\n\n                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(\n                  destDir.getAbsolutePath() + File.separatorChar + recordingId);\n\n                // Process the changes by saving the recording into metadata.xml\n                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);\n            } catch (IOException e) {\n              log.error(\"Failed to unpublish recording : \" + recordingId, e);\n            }\n        }\n        return false;\n    }\n\n    public boolean deleteRecording(File destDir, String recordingId, File recordingDir, String format) {\n        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());\n\n        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);\n        if (r != null) {\n            if (!destDir.exists()) destDir.mkdirs();\n\n            try {\n                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));\n                r.setState(Recording.STATE_DELETED);\n                r.setPublished(false);\n\n                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(\n                  destDir.getAbsolutePath() + File.separatorChar + recordingId);\n\n                // Process the changes by saving the recording into metadata.xml\n                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);\n            } catch (IOException e) {\n              log.error(\"Failed to delete recording : \" + recordingId, e);\n            }\n        }\n        return false;\n    }\n\n\n    private List<File> getAllDirectories(String state) {\n        List<File> allDirectories = new ArrayList<>();\n\n        String dir = getDestinationBaseDirectoryName(state);\n\n        if ( dir != null ) {\n            String[] formats = getPlaybackFormats(dir);\n            for (String format : formats) {\n                allDirectories.addAll(getDirectories(dir + File.separatorChar + format));\n            }\n        }\n\n        return allDirectories;\n    }\n\n    private Map<String, List<File>> getAllDirectories(List<String> states) {\n        Map<String, List<File>> allDirectories = new HashMap<>();\n\n        if ( shouldIncludeState(states, Recording.STATE_PUBLISHED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_PUBLISHED);\n            allDirectories.put(Recording.STATE_PUBLISHED, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_UNPUBLISHED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_UNPUBLISHED);\n            allDirectories.put(Recording.STATE_UNPUBLISHED, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_DELETED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_DELETED);\n            allDirectories.put(Recording.STATE_DELETED, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_PROCESSING) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_PROCESSING);\n            allDirectories.put(Recording.STATE_PROCESSING, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_PROCESSED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_PROCESSED);\n            allDirectories.put(Recording.STATE_PROCESSED, listedDirectories);\n        }\n\n        return allDirectories;\n    }\n\n    public void updateMetaParams(List<String> recordIDs, Map<String,String> metaParams) {\n        // Define the directories used to lookup the recording\n        List<String> states = new ArrayList<>();\n        states.add(Recording.STATE_PUBLISHED);\n        states.add(Recording.STATE_UNPUBLISHED);\n        states.add(Recording.STATE_DELETED);\n\n        // Gather all the existent directories based on the states defined for the lookup\n        Map<String, List<File>> allDirectories = getAllDirectories(states);\n\n        // Retrieve the actual recording from the directories gathered for the lookup\n        for (String recordID : recordIDs) {\n            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {\n                List<File> recs = getRecordingsForPath(recordID, entry.getValue());\n\n                // Go through all recordings of all formats\n                for (File rec : recs) {\n                    File metadataXml = recordingServiceHelper.getMetadataXmlLocation(rec.getPath());\n                    updateRecordingMetadata(metadataXml, metaParams, metadataXml);\n                }\n            }\n        }\n    }\n\n    public void updateRecordingMetadata(File srxMetadataXml, Map<String,String> metaParams, File destMetadataXml) {\n        RecordingMetadata rec = recordingServiceHelper.getRecordingMetadata(srxMetadataXml);\n\n        Map<String, String> recMeta = rec.getMeta();\n\n        if (rec != null && !recMeta.isEmpty()) {\n            for (Map.Entry<String,String> meta : metaParams.entrySet()) {\n                if ( !\"\".equals(meta.getValue()) ) {\n                    // As it has a value, if the meta parameter exists update it, otherwise add it\n                    recMeta.put(meta.getKey(), meta.getValue());\n                } else {\n                    // As it doesn't have a value, if it exists delete it\n                    if ( recMeta.containsKey(meta.getKey()) ) {\n                        recMeta.remove(meta.getKey());\n                    }\n                }\n            }\n\n            rec.setMeta(recMeta);\n\n            // Process the changes by saving the recording into metadata.xml\n            recordingServiceHelper.saveRecordingMetadata(destMetadataXml, rec);\n        }\n    }\n\n\n    private Map<String,File> indexRecordings(List<File> recs) {\n        Map<String,File> indexedRecs = new HashMap<>();\n\n        Iterator<File> iterator = recs.iterator();\n        while (iterator.hasNext()) {\n            File rec = iterator.next();\n            indexedRecs.put(rec.getName(), rec);\n        }\n\n        return indexedRecs;\n    }\n\n    private String getDestinationBaseDirectoryName(String state) {\n        return getDestinationBaseDirectoryName(state, false);\n    }\n\n    private String getDestinationBaseDirectoryName(String state, boolean forceDefault) {\n        String baseDir = null;\n\n        if ( state.equals(Recording.STATE_PROCESSING) || state.equals(Recording.STATE_PROCESSED) )\n            baseDir = processDir;\n        else if ( state.equals(Recording.STATE_PUBLISHED) )\n            baseDir = publishedDir;\n        else if ( state.equals(Recording.STATE_UNPUBLISHED) )\n            baseDir = unpublishedDir;\n        else if ( state.equals(Recording.STATE_DELETED) )\n            baseDir = deletedDir;\n        else if ( forceDefault )\n            baseDir = publishedDir;\n\n        return baseDir;\n    }\n\n    public String getCaptionTrackInboxDir() {\n        return captionsDir + File.separatorChar + \"inbox\";\n    }\n\n    public String getCaptionsDir() {\n      return captionsDir;\n    }\n\n    public String getCaptionFileUrlDirectory() {\n        return defaultTextTrackUrl + \"/textTrack/\";\n    }\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700172,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/**\n * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/\n *\n * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).\n *\n * This program is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free Software\n * Foundation; either version 3.0 of the License, or (at your option) any later\n * version.\n *\n * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along\n * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.\n *\n */\n\npackage org.bigbluebutton.api;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.bigbluebutton.api.domain.Recording;\nimport org.bigbluebutton.api.domain.RecordingMetadata;\nimport org.bigbluebutton.api.messaging.messages.MakePresentationDownloadableMsg;\nimport org.bigbluebutton.api.util.RecordingMetadataReaderHelper;\nimport org.bigbluebutton.api2.domain.UploadedTrack;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RecordingService {\n    private static Logger log = LoggerFactory.getLogger(RecordingService.class);\n\n    private static String processDir = \"/var/bigbluebutton/recording/process\";\n    private static String publishedDir = \"/var/bigbluebutton/published\";\n    private static String unpublishedDir = \"/var/bigbluebutton/unpublished\";\n    private static String deletedDir = \"/var/bigbluebutton/deleted\";\n    private RecordingMetadataReaderHelper recordingServiceHelper;\n    private String recordStatusDir;\n    private String captionsDir;\n    private String presentationBaseDir;\n    private String defaultServerUrl;\n    private String defaultTextTrackUrl;\n\n    private void copyPresentationFile(File presFile, File dlownloadableFile) {\n        try {\n            FileUtils.copyFile(presFile, dlownloadableFile);\n        } catch (IOException ex) {\n            log.error(\"Failed to copy file: {}\", ex);\n        }\n    }\n\n    public void processMakePresentationDownloadableMsg(MakePresentationDownloadableMsg msg) {\n        File presDir = Util.getPresentationDir(presentationBaseDir, msg.meetingId, msg.presId);\n        File downloadableFile = new File(presDir.getAbsolutePath() + File.separatorChar + msg.presFilename);\n\n        if (presDir != null) {\n            if (msg.downloadable) {\n                String fileExt = FilenameUtils.getExtension(msg.presFilename);\n                File presFile = new File(presDir.getAbsolutePath() + File.separatorChar + msg.presId + \".\" + fileExt);\n                log.info(\"Make file downloadable. {}\", downloadableFile.getAbsolutePath());\n                copyPresentationFile(presFile, downloadableFile);\n            } else {\n                if (downloadableFile.exists()) {\n                    if(downloadableFile.delete()) {\n                        log.info(\"File deleted. {}\", downloadableFile.getAbsolutePath());\n                    } else {\n                        log.warn(\"Failed to delete. {}\", downloadableFile.getAbsolutePath());\n                    }\n                }\n            }\n        }\n    }\n\n    public File getDownloadablePresentationFile(String meetingId, String presId, String presFilename) {\n        log.info(\"Find downloadable presentation for meetingId={} presId={} filename={}\", meetingId, presId,\n                presFilename);\n        File presDir = Util.getPresentationDir(presentationBaseDir, meetingId, presId);\n        // Build file to presFilename\n        // Get canonicalPath and make sure it starts with\n        // /var/bigbluebutton/<meetingid-pattern>\n        // If so return file, if not return null\n        File presFile = new File(presDir.getAbsolutePath() + File.separatorChar + presFilename);\n        try {\n            String presFileCanonical = presFile.getCanonicalPath();\n            log.debug(\"Requested presentation name file full path {}\",presFileCanonical);\n            if (presFileCanonical.startsWith(presentationBaseDir)) {\n                return presFile;\n            }\n        } catch (IOException e) {\n            log.error(\"Exception getting canonical path for {}.\\n{}\", presFilename, e);\n            return null;\n        }\n\n        log.error(\"Cannot find file for {}.\", presFilename);\n\n        return null;\n    }\n\n    public void kickOffRecordingChapterBreak(String meetingId, Long timestamp) {\n        String done = recordStatusDir + File.separatorChar + meetingId + \"-\" + timestamp + \".done\";\n\n        File doneFile = new File(done);\n        if (!doneFile.exists()) {\n            try {\n                doneFile.createNewFile();\n                if (!doneFile.exists())\n                    log.error(\"Failed to create {} file.\", done);\n            } catch (IOException e) {\n                log.error(\"Exception occured when trying to create {} file\", done);\n            }\n        } else {\n            log.error(\"{} file already exists.\", done);\n        }\n    }\n\n    public void startIngestAndProcessing(String meetingId) {\n        String done = recordStatusDir + File.separatorChar + meetingId + \".done\";\n\n        File doneFile = new File(done);\n        if (!doneFile.exists()) {\n            try {\n                doneFile.createNewFile();\n                if (!doneFile.exists())\n                    log.error(\"Failed to create {} file.\", done);\n            } catch (IOException e) {\n                log.error(\"Exception occured when trying to create {} file.\", done);\n            }\n        } else {\n            log.error(\"{} file already exists.\", done);\n        }\n    }\n\n    public void markAsEnded(String meetingId) {\n        String done = recordStatusDir + \"/../ended/\" + meetingId + \".done\";\n\n        File doneFile = new File(done);\n        if (!doneFile.exists()) {\n            try {\n                doneFile.createNewFile();\n                if (!doneFile.exists())\n                    log.error(\"Failed to create \" + done + \" file.\");\n            } catch (IOException e) {\n                log.error(\"Exception occured when trying to create {} file.\", done);\n            }\n        } else {\n            log.error(done + \" file already exists.\");\n        }\n    }\n\n    public List<RecordingMetadata> getRecordingsMetadata(List<String> recordIDs, List<String> states) {\n        List<RecordingMetadata> recs = new ArrayList<>();\n\n        Map<String, List<File>> allDirectories = getAllDirectories(states);\n        if (recordIDs.isEmpty()) {\n            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {\n                recordIDs.addAll(getAllRecordingIds(entry.getValue()));\n            }\n        }\n\n        for (String recordID : recordIDs) {\n            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {\n                List<File> _recs = getRecordingsForPath(recordID, entry.getValue());\n                for (File _rec : _recs) {\n                    RecordingMetadata r = getRecordingMetadata(_rec);\n                    if (r != null) {\n                        recs.add(r);\n                    }\n                }\n            }\n        }\n\n        return recs;\n    }\n\n    public Boolean validateTextTrackSingleUseToken(String recordId, String caption, String token) {\n        return recordingServiceHelper.validateTextTrackSingleUseToken(recordId, caption, token);\n    }\n\n    public String getRecordingTextTracks(String recordId) {\n        return recordingServiceHelper.getRecordingTextTracks(recordId, captionsDir, getCaptionFileUrlDirectory());\n    }\n\n    public String putRecordingTextTrack(UploadedTrack track) {\n        return recordingServiceHelper.putRecordingTextTrack(track);\n    }\n\n    public String getRecordings2x(List<String> idList, List<String> states, Map<String, String> metadataFilters) {\n        List<RecordingMetadata> recsList = getRecordingsMetadata(idList, states);\n        ArrayList<RecordingMetadata> recs = filterRecordingsByMetadata(recsList, metadataFilters);\n        return recordingServiceHelper.getRecordings2x(recs);\n    }\n\n    private RecordingMetadata getRecordingMetadata(File dir) {\n        File file = new File(dir.getPath() + File.separatorChar + \"metadata.xml\");\n        return recordingServiceHelper.getRecordingMetadata(file);\n    }\n\n    public boolean recordingMatchesMetadata(RecordingMetadata recording, Map<String, String> metadataFilters) {\n        boolean matchesMetadata = true;\n        Map<String, String> recMeta = recording.getMeta();\n        for (Map.Entry<String, String> filter : metadataFilters.entrySet()) {\n            String metadataValue = recMeta.get(filter.getKey());\n            if ( metadataValue == null ) {\n                // The recording doesn't have metadata specified\n                matchesMetadata = false;\n            } else {\n                String filterValue = filter.getValue();\n                if( filterValue.charAt(0) == '%' && filterValue.charAt(filterValue.length()-1) == '%' && metadataValue.contains(filterValue.substring(1, filterValue.length()-1)) ){\n                    // Filter value embraced by two wild cards\n                    // AND the filter value is part of the metadata value\n                } else if( filterValue.charAt(0) == '%' && metadataValue.endsWith(filterValue.substring(1, filterValue.length())) ) {\n                    // Filter value starts with a wild cards\n                    // AND the filter value ends with the metadata value\n                } else if( filterValue.charAt(filterValue.length()-1) == '%' && metadataValue.startsWith(filterValue.substring(0, filterValue.length()-1)) ) {\n                    // Filter value ends with a wild cards\n                    // AND the filter value starts with the metadata value\n                } else if( metadataValue.equals(filterValue) ) {\n                    // Filter value doesnt have wildcards\n                    // AND the filter value is the same as metadata value\n                } else {\n                    matchesMetadata = false;\n                }\n            }\n        }\n        return matchesMetadata;\n    }\n\n\n    public ArrayList<RecordingMetadata> filterRecordingsByMetadata(List<RecordingMetadata> recordings, Map<String, String> metadataFilters) {\n        ArrayList<RecordingMetadata> resultRecordings = new ArrayList<>();\n        for (RecordingMetadata entry : recordings) {\n            if (recordingMatchesMetadata(entry, metadataFilters))\n                resultRecordings.add(entry);\n        }\n        return resultRecordings;\n    }\n\n    private ArrayList<File> getAllRecordingsFor(String recordId) {\n        String[] format = getPlaybackFormats(publishedDir);\n        ArrayList<File> ids = new ArrayList<File>();\n\n        for (int i = 0; i < format.length; i++) {\n            List<File> recordings = getDirectories(publishedDir + File.separatorChar + format[i]);\n            for (int f = 0; f < recordings.size(); f++) {\n                if (recordId.equals(recordings.get(f).getName()))\n                    ids.add(recordings.get(f));\n            }\n        }\n\n        return ids;\n    }\n\n    public boolean isRecordingExist(String recordId) {\n        List<String> publishList = getAllRecordingIds(publishedDir);\n        List<String> unpublishList = getAllRecordingIds(unpublishedDir);\n        if (publishList.contains(recordId) || unpublishList.contains(recordId)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public boolean existAnyRecording(List<String> idList) {\n        List<String> publishList = getAllRecordingIds(publishedDir);\n        List<String> unpublishList = getAllRecordingIds(unpublishedDir);\n\n        for (String id : idList) {\n            if (publishList.contains(id) || unpublishList.contains(id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private List<String> getAllRecordingIds(String path) {\n        String[] format = getPlaybackFormats(path);\n\n        return getAllRecordingIds(path, format);\n    }\n\n    private List<String> getAllRecordingIds(String path, String[] format) {\n        List<String> ids = new ArrayList<>();\n\n        for (String aFormat : format) {\n            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);\n            for (File recording : recordings) {\n                if (!ids.contains(recording.getName())) {\n                    ids.add(recording.getName());\n                }\n            }\n        }\n\n        return ids;\n    }\n\n    private Set<String> getAllRecordingIds(List<File> recs) {\n        Set<String> ids = new HashSet<>();\n\n        Iterator<File> iterator = recs.iterator();\n        while (iterator.hasNext()) {\n            ids.add(iterator.next().getName());\n        }\n\n        return ids;\n    }\n\n    private List<File> getRecordingsForPath(String id, List<File> recordings) {\n        List<File> recs = new ArrayList<>();\n\n        Iterator<File> iterator = recordings.iterator();\n        while (iterator.hasNext()) {\n            File rec = iterator.next();\n            if (rec.getName().startsWith(id)) {\n              recs.add(rec);\n            }\n        }\n        return recs;\n    }\n\n    private static void deleteRecording(String id, String path) {\n        String[] format = getPlaybackFormats(path);\n        for (String aFormat : format) {\n            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);\n            for (File recording : recordings) {\n                if (recording.getName().equals(id)) {\n                    deleteDirectory(recording);\n                    createDirectory(recording);\n                }\n            }\n        }\n    }\n\n    private static void createDirectory(File directory) {\n        if (!directory.exists())\n            directory.mkdirs();\n    }\n\n    private static void deleteDirectory(File directory) {\n        /**\n         * Go through each directory and check if it's not empty. We need to\n         * delete files inside a directory before a directory can be deleted.\n         **/\n        File[] files = directory.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {\n                deleteDirectory(file);\n            } else {\n                file.delete();\n            }\n        }\n        // Now that the directory is empty. Delete it.\n        directory.delete();\n    }\n\n    private static List<File> getDirectories(String path) {\n        List<File> files = new ArrayList<>();\n        try {\n            DirectoryStream<Path> stream = Files.newDirectoryStream(FileSystems.getDefault().getPath(path));\n            Iterator<Path> iter = stream.iterator();\n            while (iter.hasNext()) {\n                Path next = iter.next();\n                files.add(next.toFile());\n            }\n            stream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return files;\n    }\n\n    private static String[] getPlaybackFormats(String path) {\n        System.out.println(\"Getting playback formats at \" + path);\n        List<File> dirs = getDirectories(path);\n        String[] formats = new String[dirs.size()];\n\n        for (int i = 0; i < dirs.size(); i++) {\n            System.out.println(\"Playback format = \" + dirs.get(i).getName());\n            formats[i] = dirs.get(i).getName();\n        }\n        return formats;\n    }\n\n    public void setRecordingStatusDir(String dir) {\n        recordStatusDir = dir;\n    }\n\n    public void setUnpublishedDir(String dir) {\n        unpublishedDir = dir;\n    }\n\n    public void setPresentationBaseDir(String dir) {\n        presentationBaseDir = dir;\n    }\n\n    public void setDefaultServerUrl(String url) {\n        defaultServerUrl = url;\n    }\n\n    public void setDefaultTextTrackUrl(String url) {\n        defaultTextTrackUrl = url;\n    }\n\n    public void setPublishedDir(String dir) {\n        publishedDir = dir;\n    }\n\n    public void setCaptionsDir(String dir) {\n        captionsDir = dir;\n    }\n\n    public void setRecordingServiceHelper(RecordingMetadataReaderHelper r) {\n        recordingServiceHelper = r;\n    }\n\n    private boolean shouldIncludeState(List<String> states, String type) {\n        boolean r = false;\n\n        if (!states.isEmpty()) {\n            if (states.contains(\"any\")) {\n                r = true;\n            } else {\n                if (type.equals(Recording.STATE_PUBLISHED) && states.contains(Recording.STATE_PUBLISHED)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_UNPUBLISHED) && states.contains(Recording.STATE_UNPUBLISHED)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_DELETED) && states.contains(Recording.STATE_DELETED)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_PROCESSING) && states.contains(Recording.STATE_PROCESSING)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_PROCESSED) && states.contains(Recording.STATE_PROCESSED)) {\n                    r = true;\n                }\n            }\n\n        } else {\n            if (type.equals(Recording.STATE_PUBLISHED) || type.equals(Recording.STATE_UNPUBLISHED)) {\n                r = true;\n            }\n        }\n\n        return r;\n    }\n\n    public boolean changeState(String recordingId, String state) {\n        boolean succeeded = false;\n        if (state.equals(Recording.STATE_PUBLISHED)) {\n            // It can only be published if it is unpublished\n            succeeded |= changeState(unpublishedDir, recordingId, state);\n        } else if (state.equals(Recording.STATE_UNPUBLISHED)) {\n            // It can only be unpublished if it is published\n            succeeded |= changeState(publishedDir, recordingId, state);\n        } else if (state.equals(Recording.STATE_DELETED)) {\n            // It can be deleted from any state\n            succeeded |= changeState(publishedDir, recordingId, state);\n            succeeded |= changeState(unpublishedDir, recordingId, state);\n        }\n        return succeeded;\n    }\n\n    private boolean changeState(String path, String recordingId, String state) {\n        boolean exists = false;\n        boolean succeeded = true;\n        String[] format = getPlaybackFormats(path);\n         for (String aFormat : format) {\n            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);\n            for (File recording : recordings) {\n                if (recording.getName().equalsIgnoreCase(recordingId)) {\n                    exists = true;\n                    File dest;\n                    if (state.equals(Recording.STATE_PUBLISHED)) {\n                       dest = new File(publishedDir + File.separatorChar + aFormat);\n                       succeeded &= publishRecording(dest, recordingId, recording, aFormat);\n                    } else if (state.equals(Recording.STATE_UNPUBLISHED)) {\n                       dest = new File(unpublishedDir + File.separatorChar + aFormat);\n                       succeeded &= unpublishRecording(dest, recordingId, recording, aFormat);\n                    } else if (state.equals(Recording.STATE_DELETED)) {\n                       dest = new File(deletedDir + File.separatorChar + aFormat);\n                       succeeded &= deleteRecording(dest, recordingId, recording, aFormat);\n                    } else {\n                       log.debug(String.format(\"State: %s, is not supported\", state));\n                       return false;\n                    }\n                }\n            }\n        }\n        return exists && succeeded;\n    }\n\n    public boolean publishRecording(File destDir, String recordingId, File recordingDir, String format) {\n        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());\n        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);\n        if (r != null) {\n            if (!destDir.exists()) destDir.mkdirs();\n\n            try {\n                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));\n\n                r.setState(Recording.STATE_PUBLISHED);\n                r.setPublished(true);\n\n                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(\n                  destDir.getAbsolutePath() + File.separatorChar + recordingId);\n\n                // Process the changes by saving the recording into metadata.xml\n                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);\n            } catch (IOException e) {\n              log.error(\"Failed to publish recording : \" + recordingId, e);\n            }\n        }\n        return false;\n    }\n\n    public boolean unpublishRecording(File destDir, String recordingId, File recordingDir, String format) {\n        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());\n\n        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);\n        if (r != null) {\n            if (!destDir.exists()) destDir.mkdirs();\n\n            try {\n                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));\n                r.setState(Recording.STATE_UNPUBLISHED);\n                r.setPublished(false);\n\n                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(\n                  destDir.getAbsolutePath() + File.separatorChar + recordingId);\n\n                // Process the changes by saving the recording into metadata.xml\n                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);\n            } catch (IOException e) {\n              log.error(\"Failed to unpublish recording : \" + recordingId, e);\n            }\n        }\n        return false;\n    }\n\n    public boolean deleteRecording(File destDir, String recordingId, File recordingDir, String format) {\n        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());\n\n        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);\n        if (r != null) {\n            if (!destDir.exists()) destDir.mkdirs();\n\n            try {\n                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));\n                r.setState(Recording.STATE_DELETED);\n                r.setPublished(false);\n\n                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(\n                  destDir.getAbsolutePath() + File.separatorChar + recordingId);\n\n                // Process the changes by saving the recording into metadata.xml\n                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);\n            } catch (IOException e) {\n              log.error(\"Failed to delete recording : \" + recordingId, e);\n            }\n        }\n        return false;\n    }\n\n\n    private List<File> getAllDirectories(String state) {\n        List<File> allDirectories = new ArrayList<>();\n\n        String dir = getDestinationBaseDirectoryName(state);\n\n        if ( dir != null ) {\n            String[] formats = getPlaybackFormats(dir);\n            for (String format : formats) {\n                allDirectories.addAll(getDirectories(dir + File.separatorChar + format));\n            }\n        }\n\n        return allDirectories;\n    }\n\n    private Map<String, List<File>> getAllDirectories(List<String> states) {\n        Map<String, List<File>> allDirectories = new HashMap<>();\n\n        if ( shouldIncludeState(states, Recording.STATE_PUBLISHED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_PUBLISHED);\n            allDirectories.put(Recording.STATE_PUBLISHED, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_UNPUBLISHED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_UNPUBLISHED);\n            allDirectories.put(Recording.STATE_UNPUBLISHED, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_DELETED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_DELETED);\n            allDirectories.put(Recording.STATE_DELETED, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_PROCESSING) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_PROCESSING);\n            allDirectories.put(Recording.STATE_PROCESSING, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_PROCESSED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_PROCESSED);\n            allDirectories.put(Recording.STATE_PROCESSED, listedDirectories);\n        }\n\n        return allDirectories;\n    }\n\n    public void updateMetaParams(List<String> recordIDs, Map<String,String> metaParams) {\n        // Define the directories used to lookup the recording\n        List<String> states = new ArrayList<>();\n        states.add(Recording.STATE_PUBLISHED);\n        states.add(Recording.STATE_UNPUBLISHED);\n        states.add(Recording.STATE_DELETED);\n\n        // Gather all the existent directories based on the states defined for the lookup\n        Map<String, List<File>> allDirectories = getAllDirectories(states);\n\n        // Retrieve the actual recording from the directories gathered for the lookup\n        for (String recordID : recordIDs) {\n            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {\n                List<File> recs = getRecordingsForPath(recordID, entry.getValue());\n\n                // Go through all recordings of all formats\n                for (File rec : recs) {\n                    File metadataXml = recordingServiceHelper.getMetadataXmlLocation(rec.getPath());\n                    updateRecordingMetadata(metadataXml, metaParams, metadataXml);\n                }\n            }\n        }\n    }\n\n    public void updateRecordingMetadata(File srxMetadataXml, Map<String,String> metaParams, File destMetadataXml) {\n        RecordingMetadata rec = recordingServiceHelper.getRecordingMetadata(srxMetadataXml);\n\n        Map<String, String> recMeta = rec.getMeta();\n\n        if (rec != null && !recMeta.isEmpty()) {\n            for (Map.Entry<String,String> meta : metaParams.entrySet()) {\n                if ( !\"\".equals(meta.getValue()) ) {\n                    // As it has a value, if the meta parameter exists update it, otherwise add it\n                    recMeta.put(meta.getKey(), meta.getValue());\n                } else {\n                    // As it doesn't have a value, if it exists delete it\n                    if ( recMeta.containsKey(meta.getKey()) ) {\n                        recMeta.remove(meta.getKey());\n                    }\n                }\n            }\n\n            rec.setMeta(recMeta);\n\n            // Process the changes by saving the recording into metadata.xml\n            recordingServiceHelper.saveRecordingMetadata(destMetadataXml, rec);\n        }\n    }\n\n\n    private Map<String,File> indexRecordings(List<File> recs) {\n        Map<String,File> indexedRecs = new HashMap<>();\n\n        Iterator<File> iterator = recs.iterator();\n        while (iterator.hasNext()) {\n            File rec = iterator.next();\n            indexedRecs.put(rec.getName(), rec);\n        }\n\n        return indexedRecs;\n    }\n\n    private String getDestinationBaseDirectoryName(String state) {\n        return getDestinationBaseDirectoryName(state, false);\n    }\n\n    private String getDestinationBaseDirectoryName(String state, boolean forceDefault) {\n        String baseDir = null;\n\n        if ( state.equals(Recording.STATE_PROCESSING) || state.equals(Recording.STATE_PROCESSED) )\n            baseDir = processDir;\n        else if ( state.equals(Recording.STATE_PUBLISHED) )\n            baseDir = publishedDir;\n        else if ( state.equals(Recording.STATE_UNPUBLISHED) )\n            baseDir = unpublishedDir;\n        else if ( state.equals(Recording.STATE_DELETED) )\n            baseDir = deletedDir;\n        else if ( forceDefault )\n            baseDir = publishedDir;\n\n        return baseDir;\n    }\n\n    public String getCaptionTrackInboxDir() {\n        return captionsDir + File.separatorChar + \"inbox\";\n    }\n\n    public String getCaptionsDir() {\n      return captionsDir;\n    }\n\n    public String getCaptionFileUrlDirectory() {\n        return defaultTextTrackUrl + \"/textTrack/\";\n    }\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700173,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/**\n * This file is part of the Goobi viewer - a content presentation and management application for digitized objects.\n *\n * Visit these websites for more information.\n *          - http://www.intranda.com\n *          - http://digiverso.com\n *\n * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage io.goobi.viewer.controller;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ContentLibException;\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ContentNotFoundException;\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ServiceNotAllowedException;\nimport io.goobi.viewer.api.rest.AbstractApiUrlManager;\nimport io.goobi.viewer.api.rest.resourcebuilders.TextResourceBuilder;\nimport io.goobi.viewer.exceptions.AccessDeniedException;\nimport io.goobi.viewer.exceptions.DAOException;\nimport io.goobi.viewer.exceptions.HTTPException;\nimport io.goobi.viewer.exceptions.IndexUnreachableException;\nimport io.goobi.viewer.exceptions.PresentationException;\nimport io.goobi.viewer.exceptions.ViewerConfigurationException;\nimport io.goobi.viewer.managedbeans.utils.BeanUtils;\n\n/**\n * Utility class for retrieving data folders, data files and source files.\n *\n */\npublic class DataFileTools {\n\n    private static final Logger logger = LoggerFactory.getLogger(DataFileTools.class);\n\n\n    /**\n     * Retrieves the path to viewer home or repositories root, depending on the record. Used to generate a specific task client query parameter.\n     *\n     * @param pi Record identifier\n     * @return The root folder path of the data repositories; viewer home if none are used\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getDataRepositoryPathForRecord(String pi) throws PresentationException, IndexUnreachableException {\n        String dataRepositoryPath = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getDataRepositoryPath(dataRepositoryPath);\n    }\n\n    /**\n     * Returns the absolute path to the data repository with the given name (including a slash at the end). Package private to discourage direct usage\n     * by clients.\n     *\n     * @param dataRepositoryPath Data repository name or absolute path\n     * @return\n     * @should return correct path for empty data repository\n     * @should return correct path for data repository name\n     * @should return correct path for absolute data repository path\n     */\n    static String getDataRepositoryPath(String dataRepositoryPath) {\n        if (StringUtils.isBlank(dataRepositoryPath)) {\n            return DataManager.getInstance().getConfiguration().getViewerHome();\n        }\n\n        if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryPath)).isAbsolute()) {\n            return dataRepositoryPath + '/';\n        }\n\n        return DataManager.getInstance().getConfiguration().getDataRepositoriesHome() + dataRepositoryPath + '/';\n    }\n\n    /**\n     * Constructs the media folder path for the given pi, either directly in viewer-home or within a data repository\n     *\n     * @param pi The work PI. This is both the actual name of the folder and the identifier used to look up data repository in solr\n     * @return A Path to the media folder for the given PI\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getMediaFolder(String pi) throws PresentationException, IndexUnreachableException {\n        return getDataFolder(pi, DataManager.getInstance().getConfiguration().getMediaFolder());\n    }\n\n    /**\n     * Returns a map of Paths for each data folder name passed as an argument.\n     *\n     * @param pi The record identifier. This is both the actual name of the folder and the identifier used to look up data repository in Solr\n     * @return HashMap<dataFolderName,Path>\n     * @should return all requested data folders\n     * @param dataFolderNames a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Map<String, Path> getDataFolders(String pi, String... dataFolderNames) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n        if (dataFolderNames == null) {\n            throw new IllegalArgumentException(\"dataFolderNames may not be null\");\n        }\n\n        String dataRepositoryName = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n\n        Map<String, Path> ret = new HashMap<>(dataFolderNames.length);\n        for (String dataFolderName : dataFolderNames) {\n            ret.put(dataFolderName, getDataFolder(pi, dataFolderName, dataRepositoryName));\n        }\n\n        return ret;\n    }\n\n    /**\n     * Constructs the folder path for data of the given pi, either directly in viewer-home or within a data repository.\n     *\n     * @param pi The record identifier. This is both the actual name of the folder and the identifier used to look up data repository in Solr\n     * @param dataFolderName the data folder within the repository; e.g 'media' or 'alto'\n     * @return A Path to the data folder for the given PI\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFolder(String pi, String dataFolderName) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getDataFolder(pi, dataFolderName, dataRepository);\n    }\n\n    /**\n     * Returns the data folder path for the given record identifier. To be used in clients that already possess the data repository name.\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param dataFolderName a {@link java.lang.String} object.\n     * @param dataRepositoryFolder Absolute path to the data repository folder or just the folder name\n     * @should return correct folder if no data repository used\n     * @should return correct folder if data repository used\n     * @return a {@link java.nio.file.Path} object.\n     */\n    public static Path getDataFolder(String pi, String dataFolderName, String dataRepositoryFolder) {\n        Path repository;\n        // TODO Find a way to use absolute repo paths in unit tests\n        if (StringUtils.isBlank(dataRepositoryFolder)) {\n            repository = Paths.get(DataManager.getInstance().getConfiguration().getViewerHome());\n        } else if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryFolder)).isAbsolute()) {\n            repository = Paths.get(dataRepositoryFolder);\n        } else {\n            repository = Paths.get(DataManager.getInstance().getConfiguration().getDataRepositoriesHome(), dataRepositoryFolder);\n        }\n\n        Path folder = repository.resolve(dataFolderName).resolve(pi);\n\n        return folder;\n    }\n\n    /**\n     * <p>\n     * getDataFilePath.\n     * </p>\n     *\n     * @param pi Record identifier\n     * @param dataFolderName Name of the data folder (e.g. 'alto') - first choice\n     * @param altDataFolderName Name of the data folder - second choice\n     * @param fileName Name of the content file\n     * @return Path to the requested file\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)\n            throws PresentationException, IndexUnreachableException {\n        java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);\n        if (StringUtils.isNotBlank(fileName)) {\n            dataFolderPath = dataFolderPath.resolve(fileName);\n        }\n        if (StringUtils.isNotBlank(altDataFolderName) && !Files.exists(dataFolderPath)) {\n            return getDataFilePath(pi, altDataFolderName, null, fileName);\n        }\n\n        return dataFolderPath;\n    }\n\n    /**\n     * <p>\n     * getDataFilePath.\n     * </p>\n     *\n     * @param pi Record identifier\n     * @param relativeFilePath File path relative to data repositories root\n     * @return File represented by the relative file path\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFilePath(String pi, String relativeFilePath) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n\n        String dataRepositoryName = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        String dataRepositoryPath = getDataRepositoryPath(dataRepositoryName);\n\n        return Paths.get(dataRepositoryPath, relativeFilePath);\n    }\n\n    /**\n     * Returns the absolute path to the source (METS/LIDO) file with the given file name.\n     *\n     * @param fileName a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getSourceFilePath(String fileName, String format) throws PresentationException, IndexUnreachableException {\n        String pi = FilenameUtils.getBaseName(fileName);\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getSourceFilePath(fileName, dataRepository, format);\n    }\n\n    /**\n     * Returns the absolute path to the source (METS/LIDO/DENKXWEB/DUBLINCORE) file with the given file name.\n     *\n     * @param fileName a {@link java.lang.String} object.\n     * @param dataRepository a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @should construct METS file path correctly\n     * @should construct LIDO file path correctly\n     * @should construct DenkXweb file path correctly\n     * @should throw IllegalArgumentException if fileName is null\n     * @should throw IllegalArgumentException if format is unknown\n     * @return a {@link java.lang.String} object.\n     */\n    public static String getSourceFilePath(String fileName, String dataRepository, String format) {\n        if (StringUtils.isEmpty(fileName)) {\n            throw new IllegalArgumentException(\"fileName may not be null or empty\");\n        }\n        if (StringUtils.isEmpty(format)) {\n            throw new IllegalArgumentException(\"format may not be null or empty\");\n        }\n        switch (format) {\n            case SolrConstants._METS:\n            case SolrConstants._LIDO:\n            case SolrConstants._DENKXWEB:\n            case SolrConstants._WORLDVIEWS:\n            case SolrConstants._DUBLINCORE:\n                break;\n            default:\n                throw new IllegalArgumentException(\"format must be: METS | LIDO | DENKXWEB | DUBLINCORE | WORLDVIEWS\");\n        }\n\n        StringBuilder sb = new StringBuilder(getDataRepositoryPath(dataRepository));\n        switch (format) {\n            case SolrConstants._METS:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedMetsFolder());\n                break;\n            case SolrConstants._LIDO:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedLidoFolder());\n                break;\n            case SolrConstants._DENKXWEB:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedDenkxwebFolder());\n                break;\n            case SolrConstants._DUBLINCORE:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedDublinCoreFolder());\n                break;\n            case SolrConstants._WORLDVIEWS:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedMetsFolder());\n                break;\n        }\n        sb.append('/').append(fileName);\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>\n     * getTextFilePath.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param fileName a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @should return correct path\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getTextFilePath(String pi, String fileName, String format) throws PresentationException, IndexUnreachableException {\n        if (StringUtils.isEmpty(fileName)) {\n            throw new IllegalArgumentException(\"fileName may not be null or empty\");\n        }\n        if (StringUtils.isEmpty(format)) {\n            throw new IllegalArgumentException(\"format may not be null or empty\");\n        }\n\n        String dataFolderName = null;\n        switch (format) {\n            case SolrConstants.FILENAME_ALTO:\n                dataFolderName = DataManager.getInstance().getConfiguration().getAltoFolder();\n                break;\n            case SolrConstants.FILENAME_FULLTEXT:\n                dataFolderName = DataManager.getInstance().getConfiguration().getFulltextFolder();\n                break;\n            case SolrConstants.FILENAME_TEI:\n                dataFolderName = DataManager.getInstance().getConfiguration().getTeiFolder();\n                break;\n        }\n\n        return getDataFilePath(pi, dataFolderName, null, fileName).toAbsolutePath().toString();\n    }\n\n    /**\n     * <p>\n     * getTextFilePath.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param relativeFilePath ALTO/text file path relative to the data folder\n     * @return a {@link java.nio.file.Path} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getTextFilePath(String pi, String relativeFilePath) throws PresentationException, IndexUnreachableException {\n        if (StringUtils.isBlank(relativeFilePath)) {\n            return null;\n        }\n\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        Path filePath = Paths.get(getDataRepositoryPath(dataRepository), relativeFilePath);\n\n        return filePath;\n    }\n\n    /**\n     * Loads plain full-text via the REST service. ALTO is preferred (and converted to plain text, with a plain text fallback.\n     *\n     * @param altoFilePath ALTO file path relative to the repository root (e.g. \"alto/PPN123/00000001.xml\")\n     * @param fulltextFilePath plain full-text file path relative to the repository root (e.g. \"fulltext/PPN123/00000001.xml\")\n     * @param mergeLineBreakWords a boolean.\n     * @param request a {@link javax.servlet.http.HttpServletRequest} object.\n     * @should load fulltext from alto correctly\n     * @should load fulltext from plain text correctly\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.AccessDeniedException if any.\n     * @throws java.io.FileNotFoundException if any.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public static String loadFulltext(String altoFilePath, String fulltextFilePath, boolean mergeLineBreakWords,\n            HttpServletRequest request)\n            throws AccessDeniedException, FileNotFoundException, IOException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        if (altoFilePath != null) {\n            // ALTO file\n            try {\n                String alto = builder.getAltoDocument(FileTools.getBottomFolderFromPathString(altoFilePath),\n                        FileTools.getFilenameFromPathString(altoFilePath));\n                if (alto != null) {\n                    return ALTOTools.getFullText(alto, mergeLineBreakWords, request);\n                }\n            } catch (ContentNotFoundException e) {\n                throw new FileNotFoundException(e.getMessage());\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            } catch (PresentationException e) {\n                logger.error(e.getMessage());\n            }\n        }\n        if (fulltextFilePath != null) {\n            // Plain full-text file\n            try {\n                String fulltext = builder.getFulltext(FileTools.getBottomFolderFromPathString(fulltextFilePath),\n                        FileTools.getFilenameFromPathString(fulltextFilePath));\n                if (fulltext != null) {\n                    return fulltext;\n                }\n            } catch (ContentNotFoundException e) {\n                throw new FileNotFoundException(e.getMessage());\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            } catch (PresentationException e) {\n                logger.error(e.getMessage());\n            }\n        }\n\n        return null;\n    }\n    \n    public static String loadAlto(String altoFilePath)\n            throws  ContentNotFoundException, AccessDeniedException, IndexUnreachableException, DAOException, PresentationException {\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        if (altoFilePath != null) {\n            // ALTO file\n            try {\n                String alto = builder.getAltoDocument(FileTools.getBottomFolderFromPathString(altoFilePath),\n                        FileTools.getFilenameFromPathString(altoFilePath));\n                return alto;\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            }\n        } else throw new ContentNotFoundException(\"Alto file \" + altoFilePath + \" not found\");\n        \n\n    }\n\n    /**\n     * <p>\n     * loadTei.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param language a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.AccessDeniedException if any.\n     * @throws java.io.FileNotFoundException if any.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public static String loadTei(String pi, String language)\n            throws AccessDeniedException, FileNotFoundException, IOException, ViewerConfigurationException {\n        logger.trace(\"loadTei: {}/{}\", pi, language);\n        if (pi == null) {\n            return null;\n        }\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        try {\n            return builder.getTeiDocument(pi, language);\n        } catch (PresentationException | IndexUnreachableException | DAOException | ContentLibException e) {\n            logger.error(e.toString());\n            return null;\n        }\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700186,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/**\n * This file is part of the Goobi viewer - a content presentation and management application for digitized objects.\n *\n * Visit these websites for more information.\n *          - http://www.intranda.com\n *          - http://digiverso.com\n *\n * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage io.goobi.viewer.controller;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ContentLibException;\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ContentNotFoundException;\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ServiceNotAllowedException;\nimport io.goobi.viewer.api.rest.AbstractApiUrlManager;\nimport io.goobi.viewer.api.rest.resourcebuilders.TextResourceBuilder;\nimport io.goobi.viewer.exceptions.AccessDeniedException;\nimport io.goobi.viewer.exceptions.DAOException;\nimport io.goobi.viewer.exceptions.HTTPException;\nimport io.goobi.viewer.exceptions.IndexUnreachableException;\nimport io.goobi.viewer.exceptions.PresentationException;\nimport io.goobi.viewer.exceptions.ViewerConfigurationException;\nimport io.goobi.viewer.managedbeans.utils.BeanUtils;\n\n/**\n * Utility class for retrieving data folders, data files and source files.\n *\n */\npublic class DataFileTools {\n\n    private static final Logger logger = LoggerFactory.getLogger(DataFileTools.class);\n\n\n    /**\n     * Retrieves the path to viewer home or repositories root, depending on the record. Used to generate a specific task client query parameter.\n     *\n     * @param pi Record identifier\n     * @return The root folder path of the data repositories; viewer home if none are used\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getDataRepositoryPathForRecord(String pi) throws PresentationException, IndexUnreachableException {\n        String dataRepositoryPath = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getDataRepositoryPath(dataRepositoryPath);\n    }\n\n    /**\n     * Returns the absolute path to the data repository with the given name (including a slash at the end). Package private to discourage direct usage\n     * by clients.\n     *\n     * @param dataRepositoryPath Data repository name or absolute path\n     * @return\n     * @should return correct path for empty data repository\n     * @should return correct path for data repository name\n     * @should return correct path for absolute data repository path\n     */\n    static String getDataRepositoryPath(String dataRepositoryPath) {\n        if (StringUtils.isBlank(dataRepositoryPath)) {\n            return DataManager.getInstance().getConfiguration().getViewerHome();\n        }\n\n        if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryPath)).isAbsolute()) {\n            return dataRepositoryPath + '/';\n        }\n\n        return DataManager.getInstance().getConfiguration().getDataRepositoriesHome() + dataRepositoryPath + '/';\n    }\n\n    /**\n     * Constructs the media folder path for the given pi, either directly in viewer-home or within a data repository\n     *\n     * @param pi The work PI. This is both the actual name of the folder and the identifier used to look up data repository in solr\n     * @return A Path to the media folder for the given PI\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getMediaFolder(String pi) throws PresentationException, IndexUnreachableException {\n        return getDataFolder(pi, DataManager.getInstance().getConfiguration().getMediaFolder());\n    }\n\n    /**\n     * Returns a map of Paths for each data folder name passed as an argument.\n     *\n     * @param pi The record identifier. This is both the actual name of the folder and the identifier used to look up data repository in Solr\n     * @return HashMap<dataFolderName,Path>\n     * @should return all requested data folders\n     * @param dataFolderNames a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Map<String, Path> getDataFolders(String pi, String... dataFolderNames) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n        if (dataFolderNames == null) {\n            throw new IllegalArgumentException(\"dataFolderNames may not be null\");\n        }\n\n        String dataRepositoryName = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n\n        Map<String, Path> ret = new HashMap<>(dataFolderNames.length);\n        for (String dataFolderName : dataFolderNames) {\n            ret.put(dataFolderName, getDataFolder(pi, dataFolderName, dataRepositoryName));\n        }\n\n        return ret;\n    }\n\n    /**\n     * Constructs the folder path for data of the given pi, either directly in viewer-home or within a data repository.\n     *\n     * @param pi The record identifier. This is both the actual name of the folder and the identifier used to look up data repository in Solr\n     * @param dataFolderName the data folder within the repository; e.g 'media' or 'alto'\n     * @return A Path to the data folder for the given PI\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFolder(String pi, String dataFolderName) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getDataFolder(pi, dataFolderName, dataRepository);\n    }\n\n    /**\n     * Returns the data folder path for the given record identifier. To be used in clients that already possess the data repository name.\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param dataFolderName a {@link java.lang.String} object.\n     * @param dataRepositoryFolder Absolute path to the data repository folder or just the folder name\n     * @should return correct folder if no data repository used\n     * @should return correct folder if data repository used\n     * @return a {@link java.nio.file.Path} object.\n     */\n    public static Path getDataFolder(String pi, String dataFolderName, String dataRepositoryFolder) {\n        Path repository;\n        // TODO Find a way to use absolute repo paths in unit tests\n        if (StringUtils.isBlank(dataRepositoryFolder)) {\n            repository = Paths.get(DataManager.getInstance().getConfiguration().getViewerHome());\n        } else if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryFolder)).isAbsolute()) {\n            repository = Paths.get(dataRepositoryFolder);\n        } else {\n            repository = Paths.get(DataManager.getInstance().getConfiguration().getDataRepositoriesHome(), dataRepositoryFolder);\n        }\n\n        Path folder = repository.resolve(dataFolderName).resolve(pi);\n\n        return folder;\n    }\n\n    /**\n     * <p>\n     * getDataFilePath.\n     * </p>\n     *\n     * @param pi Record identifier\n     * @param dataFolderName Name of the data folder (e.g. 'alto') - first choice\n     * @param altDataFolderName Name of the data folder - second choice\n     * @param fileName Name of the content file\n     * @return Path to the requested file\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)\n            throws PresentationException, IndexUnreachableException {\n        //make sure fileName is a pure filename and not a path\n        fileName = Paths.get(fileName).getFileName().toString();\n        java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);\n        if (StringUtils.isNotBlank(fileName)) {\n            dataFolderPath = dataFolderPath.resolve(fileName);\n        }\n        if (StringUtils.isNotBlank(altDataFolderName) && !Files.exists(dataFolderPath)) {\n            return getDataFilePath(pi, altDataFolderName, null, fileName);\n        }\n\n        return dataFolderPath;\n    }\n\n    /**\n     * <p>\n     * getDataFilePath.\n     * </p>\n     *\n     * @param pi Record identifier\n     * @param relativeFilePath File path relative to data repositories root\n     * @return File represented by the relative file path\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFilePath(String pi, String relativeFilePath) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n\n        String dataRepositoryName = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        String dataRepositoryPath = getDataRepositoryPath(dataRepositoryName);\n\n        return Paths.get(dataRepositoryPath, relativeFilePath);\n    }\n\n    /**\n     * Returns the absolute path to the source (METS/LIDO) file with the given file name.\n     *\n     * @param fileName a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getSourceFilePath(String fileName, String format) throws PresentationException, IndexUnreachableException {\n        String pi = FilenameUtils.getBaseName(fileName);\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getSourceFilePath(fileName, dataRepository, format);\n    }\n\n    /**\n     * Returns the absolute path to the source (METS/LIDO/DENKXWEB/DUBLINCORE) file with the given file name.\n     *\n     * @param fileName a {@link java.lang.String} object.\n     * @param dataRepository a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @should construct METS file path correctly\n     * @should construct LIDO file path correctly\n     * @should construct DenkXweb file path correctly\n     * @should throw IllegalArgumentException if fileName is null\n     * @should throw IllegalArgumentException if format is unknown\n     * @return a {@link java.lang.String} object.\n     */\n    public static String getSourceFilePath(String fileName, String dataRepository, String format) {\n        if (StringUtils.isEmpty(fileName)) {\n            throw new IllegalArgumentException(\"fileName may not be null or empty\");\n        }\n        if (StringUtils.isEmpty(format)) {\n            throw new IllegalArgumentException(\"format may not be null or empty\");\n        }\n        switch (format) {\n            case SolrConstants._METS:\n            case SolrConstants._LIDO:\n            case SolrConstants._DENKXWEB:\n            case SolrConstants._WORLDVIEWS:\n            case SolrConstants._DUBLINCORE:\n                break;\n            default:\n                throw new IllegalArgumentException(\"format must be: METS | LIDO | DENKXWEB | DUBLINCORE | WORLDVIEWS\");\n        }\n\n        StringBuilder sb = new StringBuilder(getDataRepositoryPath(dataRepository));\n        switch (format) {\n            case SolrConstants._METS:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedMetsFolder());\n                break;\n            case SolrConstants._LIDO:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedLidoFolder());\n                break;\n            case SolrConstants._DENKXWEB:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedDenkxwebFolder());\n                break;\n            case SolrConstants._DUBLINCORE:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedDublinCoreFolder());\n                break;\n            case SolrConstants._WORLDVIEWS:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedMetsFolder());\n                break;\n        }\n        sb.append('/').append(fileName);\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>\n     * getTextFilePath.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param fileName a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @should return correct path\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getTextFilePath(String pi, String fileName, String format) throws PresentationException, IndexUnreachableException {\n        if (StringUtils.isEmpty(fileName)) {\n            throw new IllegalArgumentException(\"fileName may not be null or empty\");\n        }\n        if (StringUtils.isEmpty(format)) {\n            throw new IllegalArgumentException(\"format may not be null or empty\");\n        }\n\n        String dataFolderName = null;\n        switch (format) {\n            case SolrConstants.FILENAME_ALTO:\n                dataFolderName = DataManager.getInstance().getConfiguration().getAltoFolder();\n                break;\n            case SolrConstants.FILENAME_FULLTEXT:\n                dataFolderName = DataManager.getInstance().getConfiguration().getFulltextFolder();\n                break;\n            case SolrConstants.FILENAME_TEI:\n                dataFolderName = DataManager.getInstance().getConfiguration().getTeiFolder();\n                break;\n        }\n\n        return getDataFilePath(pi, dataFolderName, null, fileName).toAbsolutePath().toString();\n    }\n\n    /**\n     * <p>\n     * getTextFilePath.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param relativeFilePath ALTO/text file path relative to the data folder\n     * @return a {@link java.nio.file.Path} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getTextFilePath(String pi, String relativeFilePath) throws PresentationException, IndexUnreachableException {\n        if (StringUtils.isBlank(relativeFilePath)) {\n            return null;\n        }\n\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        Path filePath = Paths.get(getDataRepositoryPath(dataRepository), relativeFilePath);\n\n        return filePath;\n    }\n\n    /**\n     * Loads plain full-text via the REST service. ALTO is preferred (and converted to plain text, with a plain text fallback.\n     *\n     * @param altoFilePath ALTO file path relative to the repository root (e.g. \"alto/PPN123/00000001.xml\")\n     * @param fulltextFilePath plain full-text file path relative to the repository root (e.g. \"fulltext/PPN123/00000001.xml\")\n     * @param mergeLineBreakWords a boolean.\n     * @param request a {@link javax.servlet.http.HttpServletRequest} object.\n     * @should load fulltext from alto correctly\n     * @should load fulltext from plain text correctly\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.AccessDeniedException if any.\n     * @throws java.io.FileNotFoundException if any.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public static String loadFulltext(String altoFilePath, String fulltextFilePath, boolean mergeLineBreakWords,\n            HttpServletRequest request)\n            throws AccessDeniedException, FileNotFoundException, IOException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        if (altoFilePath != null) {\n            // ALTO file\n            try {\n                String alto = builder.getAltoDocument(FileTools.getBottomFolderFromPathString(altoFilePath),\n                        FileTools.getFilenameFromPathString(altoFilePath));\n                if (alto != null) {\n                    return ALTOTools.getFullText(alto, mergeLineBreakWords, request);\n                }\n            } catch (ContentNotFoundException e) {\n                throw new FileNotFoundException(e.getMessage());\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            } catch (PresentationException e) {\n                logger.error(e.getMessage());\n            }\n        }\n        if (fulltextFilePath != null) {\n            // Plain full-text file\n            try {\n                String fulltext = builder.getFulltext(FileTools.getBottomFolderFromPathString(fulltextFilePath),\n                        FileTools.getFilenameFromPathString(fulltextFilePath));\n                if (fulltext != null) {\n                    return fulltext;\n                }\n            } catch (ContentNotFoundException e) {\n                throw new FileNotFoundException(e.getMessage());\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            } catch (PresentationException e) {\n                logger.error(e.getMessage());\n            }\n        }\n\n        return null;\n    }\n    \n    public static String loadAlto(String altoFilePath)\n            throws  ContentNotFoundException, AccessDeniedException, IndexUnreachableException, DAOException, PresentationException {\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        if (altoFilePath != null) {\n            // ALTO file\n            try {\n                String alto = builder.getAltoDocument(FileTools.getBottomFolderFromPathString(altoFilePath),\n                        FileTools.getFilenameFromPathString(altoFilePath));\n                return alto;\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            }\n        } else throw new ContentNotFoundException(\"Alto file \" + altoFilePath + \" not found\");\n        \n\n    }\n\n    /**\n     * <p>\n     * loadTei.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param language a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.AccessDeniedException if any.\n     * @throws java.io.FileNotFoundException if any.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public static String loadTei(String pi, String language)\n            throws AccessDeniedException, FileNotFoundException, IOException, ViewerConfigurationException {\n        logger.trace(\"loadTei: {}/{}\", pi, language);\n        if (pi == null) {\n            return null;\n        }\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        try {\n            return builder.getTeiDocument(pi, language);\n        } catch (PresentationException | IndexUnreachableException | DAOException | ContentLibException e) {\n            logger.error(e.toString());\n            return null;\n        }\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700187,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/*\n * file:       InputStreamHelper.java\n * author:     Jon Iles\n * copyright:  (c) Packwood Software 2016\n * date:       06/06/2016\n */\n\n/*\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by the\n * Free Software Foundation; either version 2.1 of the License, or (at your\n * option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n */\n\npackage net.sf.mpxj.common;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\nimport java.util.zip.ZipInputStream;\n\n/**\n * Helper methods for dealing with InputStreams.\n */\npublic class InputStreamHelper\n{\n   /**\n    * Copy the data from an InputStream to a temp file.\n    *\n    * @param inputStream data source\n    * @param tempFileSuffix suffix to use for temp file\n    * @return File instance\n    */\n   public static File writeStreamToTempFile(InputStream inputStream, String tempFileSuffix) throws IOException\n   {\n      FileOutputStream outputStream = null;\n\n      try\n      {\n         File file = File.createTempFile(\"mpxj\", tempFileSuffix);\n         outputStream = new FileOutputStream(file);\n         byte[] buffer = new byte[1024];\n         while (true)\n         {\n            int bytesRead = inputStream.read(buffer);\n            if (bytesRead == -1)\n            {\n               break;\n            }\n            outputStream.write(buffer, 0, bytesRead);\n         }\n         return file;\n      }\n\n      finally\n      {\n         if (outputStream != null)\n         {\n            outputStream.close();\n         }\n      }\n   }\n\n   /**\n    * Expands a zip file input stream into a temporary directory.\n    *\n    * @param inputStream zip file input stream\n    * @return File instance representing the temporary directory\n    */\n   public static File writeZipStreamToTempDir(InputStream inputStream) throws IOException\n   {\n      File dir = FileHelper.createTempDir();\n\n      try\n      {\n         processZipStream(dir, inputStream);\n      }\n\n      catch (ZipException ex)\n      {\n         // Java doesn't support zip files with zero byte entries.\n         // We could use a different library which does handle these zip files, but\n         // I'm reluctant to add new dependencies just for this. Rather than\n         // propagating the error, we'll just stop at this point and see if we\n         // can make sense of anything we have extracted from the zip file so far.\n         // For what it's worth I haven't come across a valid compressed schedule file\n         // which includes zero bytes files.\n         if (!ex.getMessage().equals(\"only DEFLATED entries can have EXT descriptor\"))\n         {\n            throw ex;\n         }\n      }\n\n      return dir;\n   }\n\n   /**\n    * Expands a zip file input stream into a temporary directory.\n    *\n    * @param dir temporary directory\n    * @param inputStream zip file input stream\n    */\n   private static void processZipStream(File dir, InputStream inputStream) throws IOException\n   {\n      ZipInputStream zip = new ZipInputStream(inputStream);\n      while (true)\n      {\n         ZipEntry entry = zip.getNextEntry();\n         if (entry == null)\n         {\n            break;\n         }\n\n         File file = new File(dir, entry.getName());\n         if (entry.isDirectory())\n         {\n            FileHelper.mkdirsQuietly(file);\n            continue;\n         }\n\n         File parent = file.getParentFile();\n         if (parent != null)\n         {\n            FileHelper.mkdirsQuietly(parent);\n         }\n\n         FileOutputStream fos = new FileOutputStream(file);\n         byte[] bytes = new byte[1024];\n         int length;\n         while ((length = zip.read(bytes)) >= 0)\n         {\n            fos.write(bytes, 0, length);\n         }\n         fos.close();\n      }\n   }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700210,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/*\n * file:       InputStreamHelper.java\n * author:     Jon Iles\n * copyright:  (c) Packwood Software 2016\n * date:       06/06/2016\n */\n\n/*\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by the\n * Free Software Foundation; either version 2.1 of the License, or (at your\n * option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n */\n\npackage net.sf.mpxj.common;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\nimport java.util.zip.ZipInputStream;\n\n/**\n * Helper methods for dealing with InputStreams.\n */\npublic class InputStreamHelper\n{\n   /**\n    * Copy the data from an InputStream to a temp file.\n    *\n    * @param inputStream data source\n    * @param tempFileSuffix suffix to use for temp file\n    * @return File instance\n    */\n   public static File writeStreamToTempFile(InputStream inputStream, String tempFileSuffix) throws IOException\n   {\n      FileOutputStream outputStream = null;\n\n      try\n      {\n         File file = File.createTempFile(\"mpxj\", tempFileSuffix);\n         outputStream = new FileOutputStream(file);\n         byte[] buffer = new byte[1024];\n         while (true)\n         {\n            int bytesRead = inputStream.read(buffer);\n            if (bytesRead == -1)\n            {\n               break;\n            }\n            outputStream.write(buffer, 0, bytesRead);\n         }\n         return file;\n      }\n\n      finally\n      {\n         if (outputStream != null)\n         {\n            outputStream.close();\n         }\n      }\n   }\n\n   /**\n    * Expands a zip file input stream into a temporary directory.\n    *\n    * @param inputStream zip file input stream\n    * @return File instance representing the temporary directory\n    */\n   public static File writeZipStreamToTempDir(InputStream inputStream) throws IOException\n   {\n      File dir = FileHelper.createTempDir();\n\n      try\n      {\n         processZipStream(dir, inputStream);\n      }\n\n      catch (ZipException ex)\n      {\n         // Java doesn't support zip files with zero byte entries.\n         // We could use a different library which does handle these zip files, but\n         // I'm reluctant to add new dependencies just for this. Rather than\n         // propagating the error, we'll just stop at this point and see if we\n         // can make sense of anything we have extracted from the zip file so far.\n         // For what it's worth I haven't come across a valid compressed schedule file\n         // which includes zero bytes files.\n         if (!ex.getMessage().equals(\"only DEFLATED entries can have EXT descriptor\"))\n         {\n            throw ex;\n         }\n      }\n\n      return dir;\n   }\n\n   /**\n    * Expands a zip file input stream into a temporary directory.\n    *\n    * @param dir temporary directory\n    * @param inputStream zip file input stream\n    */\n   private static void processZipStream(File dir, InputStream inputStream) throws IOException\n   {\n      String canonicalDestinationDirPath = dir.getCanonicalPath();\n      ZipInputStream zip = new ZipInputStream(inputStream);\n      while (true)\n      {\n         ZipEntry entry = zip.getNextEntry();\n         if (entry == null)\n         {\n            break;\n         }\n\n         File file = new File(dir, entry.getName());\n\n         // https://snyk.io/research/zip-slip-vulnerability\n         String canonicalDestinationFile = file.getCanonicalPath();\n         if (!canonicalDestinationFile.startsWith(canonicalDestinationDirPath + File.separator))\n         {\n            throw new IOException(\"Entry is outside of the target dir: \" + entry.getName());\n         }\n\n         if (entry.isDirectory())\n         {\n            FileHelper.mkdirsQuietly(file);\n            continue;\n         }\n\n         File parent = file.getParentFile();\n         if (parent != null)\n         {\n            FileHelper.mkdirsQuietly(parent);\n         }\n\n         FileOutputStream fos = new FileOutputStream(file);\n         byte[] bytes = new byte[1024];\n         int length;\n         while ((length = zip.read(bytes)) >= 0)\n         {\n            fos.write(bytes, 0, length);\n         }\n         fos.close();\n      }\n   }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700211,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/**\n * <a href=\"http://www.openolat.org\">\n * OpenOLAT - Online Learning and Training</a><br>\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n * you may not use this file except in compliance with the License.<br>\n * You may obtain a copy of the License at the\n * <a href=\"http://www.apache.org/licenses/LICENSE-2.0\">Apache homepage</a>\n * <p>\n * Unless required by applicable law or agreed to in writing,<br>\n * software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n * See the License for the specific language governing permissions and <br>\n * limitations under the License.\n * <p>\n * Initial code contributed and copyrighted by<br>\n * frentix GmbH, http://www.frentix.com\n * <p>\n */\npackage org.olat.modules.wiki;\n\nimport java.io.File;\nimport java.net.URISyntaxException;\nimport java.net.URL;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.olat.core.logging.OLATRuntimeException;\nimport org.olat.core.util.CodeHelper;\nimport org.olat.core.util.FileUtils;\nimport org.olat.core.util.WebappHelper;\nimport org.olat.test.OlatTestCase;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.wildfly.common.Assert;\n\n/**\n * \n * Initial date: 22 juin 2021<br>\n * @author srosse, stephane.rosse@frentix.com, http://www.frentix.com\n *\n */\npublic class WikiManagerTest extends OlatTestCase {\n\t\n\t@Autowired\n\tprivate WikiManager wikiManager;\n\t\n\tprivate File tmpWikiDir;\n\t\n\t@Before\n\tpublic void createTmpDir() {\n\t\ttmpWikiDir = new File(WebappHelper.getTmpDir(), \"wiki\" + CodeHelper.getForeverUniqueID());\n\t}\n\t\n\t@After\n\tpublic void deleteTmpDir() {\n\t\tFileUtils.deleteDirsAndFiles(tmpWikiDir, true, true);\n\t}\n\t\n\t@Test\n\tpublic void importWiki() throws URISyntaxException {\n\t\tURL wikiUrl = WikiManagerTest.class.getResource(\"wiki.zip\");\n\t\tFile wikiFile = new File(wikiUrl.toURI());\n\t\twikiManager.importWiki(wikiFile, null, tmpWikiDir);\n\t\t\n\t\tFile image = new File(tmpWikiDir, \"media/IMG_1482.jpg\");\n\t\tAssert.assertTrue(image.exists());\n\t\tFile imageMetadata = new File(tmpWikiDir, \"media/IMG_1482.jpg.metadata\");\n\t\tAssert.assertTrue(imageMetadata.exists());\n\t\tFile indexPage = new File(tmpWikiDir, \"wiki/SW5kZXg=.wp\");\n\t\tAssert.assertTrue(indexPage.exists());\n\t}\n\t\n\t@Test(expected=OLATRuntimeException.class)\n\tpublic void importWikiSlide() throws URISyntaxException {\n\t\tURL wikiUrl = WikiManagerTest.class.getResource(\"wiki_alt.zip\");\n\t\tFile wikiFile = new File(wikiUrl.toURI());\n\t\twikiManager.importWiki(wikiFile, null, tmpWikiDir);\n\t}\n\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700294,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "/**\n * <a href=\"http://www.openolat.org\">\n * OpenOLAT - Online Learning and Training</a><br>\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n * you may not use this file except in compliance with the License.<br>\n * You may obtain a copy of the License at the\n * <a href=\"http://www.apache.org/licenses/LICENSE-2.0\">Apache homepage</a>\n * <p>\n * Unless required by applicable law or agreed to in writing,<br>\n * software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n * See the License for the specific language governing permissions and <br>\n * limitations under the License.\n * <p>\n * Initial code contributed and copyrighted by<br>\n * frentix GmbH, http://www.frentix.com\n * <p>\n */\npackage org.olat.modules.wiki;\n\nimport java.io.File;\nimport java.net.URISyntaxException;\nimport java.net.URL;\n\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.olat.core.logging.OLATRuntimeException;\nimport org.olat.core.util.CodeHelper;\nimport org.olat.core.util.FileUtils;\nimport org.olat.core.util.WebappHelper;\nimport org.olat.test.OlatTestCase;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n/**\n * \n * Initial date: 22 juin 2021<br>\n * @author srosse, stephane.rosse@frentix.com, http://www.frentix.com\n *\n */\npublic class WikiManagerTest extends OlatTestCase {\n\t\n\t@Autowired\n\tprivate WikiManager wikiManager;\n\t\n\tprivate File tmpWikiDir;\n\t\n\t@Before\n\tpublic void createTmpDir() {\n\t\ttmpWikiDir = new File(WebappHelper.getTmpDir(), \"wiki\" + CodeHelper.getForeverUniqueID());\n\t}\n\t\n\t@After\n\tpublic void deleteTmpDir() {\n\t\tFileUtils.deleteDirsAndFiles(tmpWikiDir, true, true);\n\t}\n\t\n\t@Test\n\tpublic void importWiki() throws URISyntaxException {\n\t\tURL wikiUrl = WikiManagerTest.class.getResource(\"wiki.zip\");\n\t\tFile wikiFile = new File(wikiUrl.toURI());\n\t\twikiManager.importWiki(wikiFile, null, tmpWikiDir);\n\t\t\n\t\tFile image = new File(tmpWikiDir, \"media/IMG_1482.jpg\");\n\t\tAssert.assertTrue(image.exists());\n\t\tFile imageMetadata = new File(tmpWikiDir, \"media/IMG_1482.jpg.metadata\");\n\t\tAssert.assertTrue(imageMetadata.exists());\n\t\tFile indexPage = new File(tmpWikiDir, \"wiki/SW5kZXg=.wp\");\n\t\tAssert.assertTrue(indexPage.exists());\n\t}\n\t\n\t@Test(expected=OLATRuntimeException.class)\n\tpublic void importWikiSlide() throws URISyntaxException {\n\t\tURL wikiUrl = WikiManagerTest.class.getResource(\"wiki_alt.zip\");\n\t\tFile wikiFile = new File(wikiUrl.toURI());\n\t\twikiManager.importWiki(wikiFile, null, tmpWikiDir);\n\t}\n\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700295,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  }
]