[
  {
    "CWE_ID": [
      "CWE-863"
    ],
    "code": "package com.hubspot.jinjava.el.ext;\n\nimport com.google.common.base.CaseFormat;\nimport com.google.common.collect.ImmutableSet;\nimport java.util.Set;\nimport javax.el.BeanELResolver;\nimport javax.el.ELContext;\nimport javax.el.MethodNotFoundException;\n\n/**\n * {@link BeanELResolver} supporting snake case property names.\n */\npublic class JinjavaBeanELResolver extends BeanELResolver {\n  private static final Set<String> RESTRICTED_PROPERTIES = ImmutableSet\n    .<String>builder()\n    .add(\"class\")\n    .build();\n\n  private static final Set<String> RESTRICTED_METHODS = ImmutableSet\n    .<String>builder()\n    .add(\"class\")\n    .add(\"clone\")\n    .add(\"hashCode\")\n    .add(\"getClass\")\n    .add(\"getDeclaringClass\")\n    .add(\"forName\")\n    .add(\"notify\")\n    .add(\"notifyAll\")\n    .add(\"wait\")\n    .build();\n\n  /**\n   * Creates a new read/write {@link JinjavaBeanELResolver}.\n   */\n  public JinjavaBeanELResolver() {}\n\n  /**\n   * Creates a new {@link JinjavaBeanELResolver} whose read-only status is determined by the given parameter.\n   */\n  public JinjavaBeanELResolver(boolean readOnly) {\n    super(readOnly);\n  }\n\n  @Override\n  public Class<?> getType(ELContext context, Object base, Object property) {\n    return super.getType(context, base, validatePropertyName(property));\n  }\n\n  @Override\n  public Object getValue(ELContext context, Object base, Object property) {\n    Object result = super.getValue(context, base, validatePropertyName(property));\n    return result instanceof Class ? null : result;\n  }\n\n  @Override\n  public boolean isReadOnly(ELContext context, Object base, Object property) {\n    return super.isReadOnly(context, base, validatePropertyName(property));\n  }\n\n  @Override\n  public void setValue(ELContext context, Object base, Object property, Object value) {\n    super.setValue(context, base, validatePropertyName(property), value);\n  }\n\n  @Override\n  public Object invoke(\n    ELContext context,\n    Object base,\n    Object method,\n    Class<?>[] paramTypes,\n    Object[] params\n  ) {\n    if (method == null || RESTRICTED_METHODS.contains(method.toString())) {\n      throw new MethodNotFoundException(\n        \"Cannot find method '\" + method + \"' in \" + base.getClass()\n      );\n    }\n\n    checkRestrictedClass(base, method);\n\n    Object result = super.invoke(context, base, method, paramTypes, params);\n\n    checkRestrictedClass(result, method);\n\n    return result;\n  }\n\n  private String validatePropertyName(Object property) {\n    String propertyName = transformPropertyName(property);\n\n    if (RESTRICTED_PROPERTIES.contains(propertyName)) {\n      return null;\n    }\n\n    return propertyName;\n  }\n\n  /**\n   * Transform snake case to property name.\n   */\n  private String transformPropertyName(Object property) {\n    if (property == null) {\n      return null;\n    }\n\n    String propertyStr = property.toString();\n    if (propertyStr.indexOf('_') == -1) {\n      return propertyStr;\n    }\n    return CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, propertyStr);\n  }\n\n  private void checkRestrictedClass(Object o, Object method) {\n    if (o instanceof Class || o instanceof ClassLoader || o instanceof Thread) {\n      throw new MethodNotFoundException(\n        \"Cannot find method '\" + method + \"' in \" + o.getClass()\n      );\n    }\n  }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700176,
    "RELATED_CWE": [
      "CWE-287",
      "CWE-306",
      "CWE-862"
    ]
  },
  {
    "CWE_ID": [
      "CWE-863"
    ],
    "code": "package com.hubspot.jinjava.el.ext;\n\nimport com.google.common.base.CaseFormat;\nimport com.google.common.collect.ImmutableSet;\nimport java.lang.reflect.Method;\nimport java.util.Set;\nimport javax.el.BeanELResolver;\nimport javax.el.ELContext;\nimport javax.el.MethodNotFoundException;\n\n/**\n * {@link BeanELResolver} supporting snake case property names.\n */\npublic class JinjavaBeanELResolver extends BeanELResolver {\n  private static final Set<String> RESTRICTED_PROPERTIES = ImmutableSet\n    .<String>builder()\n    .add(\"class\")\n    .build();\n\n  private static final Set<String> RESTRICTED_METHODS = ImmutableSet\n    .<String>builder()\n    .add(\"class\")\n    .add(\"clone\")\n    .add(\"hashCode\")\n    .add(\"getClass\")\n    .add(\"getDeclaringClass\")\n    .add(\"forName\")\n    .add(\"notify\")\n    .add(\"notifyAll\")\n    .add(\"wait\")\n    .build();\n\n  /**\n   * Creates a new read/write {@link JinjavaBeanELResolver}.\n   */\n  public JinjavaBeanELResolver() {}\n\n  /**\n   * Creates a new {@link JinjavaBeanELResolver} whose read-only status is determined by the given parameter.\n   */\n  public JinjavaBeanELResolver(boolean readOnly) {\n    super(readOnly);\n  }\n\n  @Override\n  public Class<?> getType(ELContext context, Object base, Object property) {\n    return super.getType(context, base, validatePropertyName(property));\n  }\n\n  @Override\n  public Object getValue(ELContext context, Object base, Object property) {\n    Object result = super.getValue(context, base, validatePropertyName(property));\n    return result instanceof Class ? null : result;\n  }\n\n  @Override\n  public boolean isReadOnly(ELContext context, Object base, Object property) {\n    return super.isReadOnly(context, base, validatePropertyName(property));\n  }\n\n  @Override\n  public void setValue(ELContext context, Object base, Object property, Object value) {\n    super.setValue(context, base, validatePropertyName(property), value);\n  }\n\n  @Override\n  public Object invoke(\n    ELContext context,\n    Object base,\n    Object method,\n    Class<?>[] paramTypes,\n    Object[] params\n  ) {\n    if (method == null || RESTRICTED_METHODS.contains(method.toString())) {\n      throw new MethodNotFoundException(\n        \"Cannot find method '\" + method + \"' in \" + base.getClass()\n      );\n    }\n\n    checkRestrictedClass(base, method);\n\n    Object result = super.invoke(context, base, method, paramTypes, params);\n\n    checkRestrictedClass(result, method);\n\n    return result;\n  }\n\n  private String validatePropertyName(Object property) {\n    String propertyName = transformPropertyName(property);\n\n    if (RESTRICTED_PROPERTIES.contains(propertyName)) {\n      return null;\n    }\n\n    return propertyName;\n  }\n\n  /**\n   * Transform snake case to property name.\n   */\n  private String transformPropertyName(Object property) {\n    if (property == null) {\n      return null;\n    }\n\n    String propertyStr = property.toString();\n    if (propertyStr.indexOf('_') == -1) {\n      return propertyStr;\n    }\n    return CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, propertyStr);\n  }\n\n  private void checkRestrictedClass(Object o, Object method) {\n    if (\n      o instanceof Class ||\n      o instanceof ClassLoader ||\n      o instanceof Thread ||\n      o instanceof Method\n    ) {\n      throw new MethodNotFoundException(\n        \"Cannot find method '\" + method + \"' in \" + o.getClass()\n      );\n    }\n  }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700177,
    "RELATED_CWE": [
      "CWE-287",
      "CWE-306",
      "CWE-862"
    ]
  }
]