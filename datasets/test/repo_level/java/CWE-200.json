[
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "    @Override\n    public SearchIndexBuilder makeSearchIndex() {\n        SearchIndexBuilder searchIndexBuilder = super.makeSearchIndex();\n\n        CollectionSearchIndex<TopLevelItem> collectionSearchIndexItem=new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { \n                    return getItemByFullName(key, TopLevelItem.class); \n                }\n                protected Collection<TopLevelItem> all() { \n                    return getAllItems(TopLevelItem.class); \n                }\n        };\n\n\n        CollectionSearchIndex collectionSearchIndexComputer = new CollectionSearchIndex() {\n                protected Collection<Computer> all() { \n                    return computers.values(); \n                }\n                protected Computer get(String key) { \n                    return getComputer(key); \n                }\n\n        };\n\n\n        searchIndexBuilder.add(collectionSearchIndexItem);\n        searchIndexBuilder.add(\"configure\", \"config\",\"configure\");\n        View primaryView_ = getPrimaryView();\n        SearchIndexBuilder primaryViewSearchIndexBuilder = primaryView_.makeSearchIndex();\n        searchIndexBuilder.add(primaryViewSearchIndexBuilder);\n        searchIndexBuilder.add(collectionSearchIndexComputer); \n\n        searchIndexBuilder.add(\"manage\");\n        searchIndexBuilder.add(\"log\");\n\n\n         CollectionSearchIndex collectionSearchIndexView = new CollectionSearchIndex() {\n                protected Collection<View> all() { \n                    return views; \n                }\n                protected View get(String key) { \n                    return getView(key); \n                }\n            };\n\n\n           CollectionSearchIndex collectionSearchIndexUser = new CollectionSearchIndex() {\n                protected Collection<User> all() { \n                    return User.getAll(); \n                }\n                protected User get(String key) { \n                    return User.get(key,false); \n                }\n                \n            };\n            \n        searchIndexBuilder.add(collectionSearchIndexUser);\n            \n        searchIndexBuilder.add(collectionSearchIndexView);\n\n        return searchIndexBuilder;\n            \n        \n    }",
    "target": 1,
    "language": "java",
    "dataset": "VJBench",
    "idx": 200068,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "    @Override\n    public SearchIndexBuilder makeSearchIndex() {\n        SearchIndexBuilder searchIndexBuilder = super.makeSearchIndex();\n\n        CollectionSearchIndex<TopLevelItem> collectionSearchIndexItem=new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { \n                    return getItemByFullName(key, TopLevelItem.class); \n                }\n                protected Collection<TopLevelItem> all() { \n                    return getAllItems(TopLevelItem.class); \n                }\n        };\n\n\n        CollectionSearchIndex collectionSearchIndexComputer = new CollectionSearchIndex() {\n                protected Collection<Computer> all() { \n                    return computers.values(); \n                }\n                protected Computer get(String key) { \n                    return getComputer(key); \n                }\n\n        };\n\n\n        searchIndexBuilder.add(collectionSearchIndexItem);\n        searchIndexBuilder.add(\"configure\", \"config\",\"configure\");\n        View primaryView_ = getPrimaryView();\n        SearchIndexBuilder primaryViewSearchIndexBuilder = primaryView_.makeSearchIndex();\n        searchIndexBuilder.add(primaryViewSearchIndexBuilder);\n        searchIndexBuilder.add(collectionSearchIndexComputer); \n\n        searchIndexBuilder.add(\"manage\");\n        searchIndexBuilder.add(\"log\");\n\n\n         CollectionSearchIndex collectionSearchIndexView = new CollectionSearchIndex() {\n                protected Collection<View> all() { \n                    return getViews(); \n                }\n                protected View get(String key) { \n                    return getView(key); \n                }\n            };\n\n\n           CollectionSearchIndex collectionSearchIndexUser = new CollectionSearchIndex() {\n                protected Collection<User> all() { \n                    return User.getAll(); \n                }\n                protected User get(String key) { \n                    return User.get(key,false); \n                }\n                \n            };\n\n        searchIndexBuilder.add(collectionSearchIndexUser);\n\n        searchIndexBuilder.add(collectionSearchIndexView);\n\n        return searchIndexBuilder;\n            \n        \n    }",
    "target": 0,
    "language": "java",
    "dataset": "VJBench",
    "idx": 200069,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "/**\n *  ownCloud Android client application\n *\n *  @author Bartek Przybylski\n *  @author masensio\n *  @author LukeOwnCloud\n *  @author David A. Velasco\n *  @author Chris Narkiewicz\n *\n *  Copyright (C) 2012 Bartek Przybylski\n *  Copyright (C) 2012-2016 ownCloud Inc.\n *  Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2,\n *  as published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage com.owncloud.android.files.services;\n\nimport android.accounts.Account;\nimport android.accounts.AccountManager;\nimport android.accounts.OnAccountsUpdateListener;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.graphics.BitmapFactory;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.HandlerThread;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcelable;\nimport android.os.Process;\nimport android.util.Pair;\n\nimport com.nextcloud.client.account.User;\nimport com.nextcloud.client.account.UserAccountManager;\nimport com.nextcloud.client.device.BatteryStatus;\nimport com.nextcloud.client.device.PowerManagementService;\nimport com.nextcloud.client.network.Connectivity;\nimport com.nextcloud.client.network.ConnectivityService;\nimport com.nextcloud.java.util.Optional;\nimport com.owncloud.android.MainApp;\nimport com.owncloud.android.R;\nimport com.owncloud.android.authentication.AuthenticatorActivity;\nimport com.owncloud.android.datamodel.FileDataStorageManager;\nimport com.owncloud.android.datamodel.OCFile;\nimport com.owncloud.android.datamodel.ThumbnailsCacheManager;\nimport com.owncloud.android.datamodel.UploadsStorageManager;\nimport com.owncloud.android.datamodel.UploadsStorageManager.UploadStatus;\nimport com.owncloud.android.db.OCUpload;\nimport com.owncloud.android.db.UploadResult;\nimport com.owncloud.android.lib.common.OwnCloudAccount;\nimport com.owncloud.android.lib.common.OwnCloudClient;\nimport com.owncloud.android.lib.common.OwnCloudClientManagerFactory;\nimport com.owncloud.android.lib.common.network.OnDatatransferProgressListener;\nimport com.owncloud.android.lib.common.operations.RemoteOperationResult;\nimport com.owncloud.android.lib.common.operations.RemoteOperationResult.ResultCode;\nimport com.owncloud.android.lib.common.utils.Log_OC;\nimport com.owncloud.android.lib.resources.files.FileUtils;\nimport com.owncloud.android.operations.UploadFileOperation;\nimport com.owncloud.android.ui.activity.ConflictsResolveActivity;\nimport com.owncloud.android.ui.activity.UploadListActivity;\nimport com.owncloud.android.ui.notifications.NotificationUtils;\nimport com.owncloud.android.utils.ErrorMessageAdapter;\nimport com.owncloud.android.utils.theme.ThemeColorUtils;\n\nimport java.io.File;\nimport java.security.SecureRandom;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.annotation.Nullable;\nimport javax.inject.Inject;\n\nimport androidx.annotation.NonNull;\nimport androidx.core.app.NotificationCompat;\nimport androidx.localbroadcastmanager.content.LocalBroadcastManager;\nimport dagger.android.AndroidInjection;\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\n/**\n * Service for uploading files. Invoke using context.startService(...).\n *\n * Files to be uploaded are stored persistently using {@link UploadsStorageManager}.\n *\n * On next invocation of {@link FileUploader} uploaded files which previously failed will be uploaded again until either\n * upload succeeded or a fatal error occurred.\n *\n * Every file passed to this service is uploaded. No filtering is performed. However, Intent keys (e.g., KEY_WIFI_ONLY)\n * are obeyed.\n */\npublic class FileUploader extends Service\n    implements OnDatatransferProgressListener, OnAccountsUpdateListener, UploadFileOperation.OnRenameListener {\n\n    private static final String TAG = FileUploader.class.getSimpleName();\n\n    private static final String UPLOADS_ADDED_MESSAGE = \"UPLOADS_ADDED\";\n    private static final String UPLOAD_START_MESSAGE = \"UPLOAD_START\";\n    private static final String UPLOAD_FINISH_MESSAGE = \"UPLOAD_FINISH\";\n    public static final String EXTRA_UPLOAD_RESULT = \"RESULT\";\n    public static final String EXTRA_REMOTE_PATH = \"REMOTE_PATH\";\n    public static final String EXTRA_OLD_REMOTE_PATH = \"OLD_REMOTE_PATH\";\n    public static final String EXTRA_OLD_FILE_PATH = \"OLD_FILE_PATH\";\n    public static final String EXTRA_LINKED_TO_PATH = \"LINKED_TO\";\n    public static final String ACCOUNT_NAME = \"ACCOUNT_NAME\";\n\n    private static final int FOREGROUND_SERVICE_ID = 411;\n\n    public static final String KEY_FILE = \"FILE\";\n    public static final String KEY_LOCAL_FILE = \"LOCAL_FILE\";\n    public static final String KEY_REMOTE_FILE = \"REMOTE_FILE\";\n    public static final String KEY_MIME_TYPE = \"MIME_TYPE\";\n\n    /**\n     * Call this Service with only this Intent key if all pending uploads are to be retried.\n     */\n    private static final String KEY_RETRY = \"KEY_RETRY\";\n//    /**\n//     * Call this Service with KEY_RETRY and KEY_RETRY_REMOTE_PATH to retry\n//     * upload of file identified by KEY_RETRY_REMOTE_PATH.\n//     */\n//    private static final String KEY_RETRY_REMOTE_PATH = \"KEY_RETRY_REMOTE_PATH\";\n    /**\n     * Call this Service with KEY_RETRY and KEY_RETRY_UPLOAD to retry upload of file identified by KEY_RETRY_UPLOAD.\n     */\n    private static final String KEY_RETRY_UPLOAD = \"KEY_RETRY_UPLOAD\";\n    /**\n     * {@link Account} to which file is to be uploaded.\n     */\n    public static final String KEY_ACCOUNT = \"ACCOUNT\";\n\n    /**\n     * What {@link NameCollisionPolicy} to do when the file already exists on the remote.\n     */\n    public static final String KEY_NAME_COLLISION_POLICY = \"KEY_NAME_COLLISION_POLICY\";\n\n    /**\n     * Set to true if remote folder is to be created if it does not exist.\n     */\n    public static final String KEY_CREATE_REMOTE_FOLDER = \"CREATE_REMOTE_FOLDER\";\n    /**\n     * Key to signal what is the origin of the upload request\n     */\n    public static final String KEY_CREATED_BY = \"CREATED_BY\";\n\n    public static final String KEY_WHILE_ON_WIFI_ONLY = \"KEY_ON_WIFI_ONLY\";\n\n    /**\n     * Set to true if upload is to performed only when phone is being charged.\n     */\n    public static final String KEY_WHILE_CHARGING_ONLY = \"KEY_WHILE_CHARGING_ONLY\";\n\n    public static final String KEY_LOCAL_BEHAVIOUR = \"BEHAVIOUR\";\n\n    /**\n     * Set to true if the HTTP library should disable automatic retries of uploads.\n     */\n    public static final String KEY_DISABLE_RETRIES = \"DISABLE_RETRIES\";\n\n    public static final int LOCAL_BEHAVIOUR_COPY = 0;\n    public static final int LOCAL_BEHAVIOUR_MOVE = 1;\n    public static final int LOCAL_BEHAVIOUR_FORGET = 2;\n    public static final int LOCAL_BEHAVIOUR_DELETE = 3;\n\n\n    private Notification mNotification;\n    private Looper mServiceLooper;\n    private ServiceHandler mServiceHandler;\n    private IBinder mBinder;\n    private OwnCloudClient mUploadClient;\n    private Account mCurrentAccount;\n    private FileDataStorageManager mStorageManager;\n\n    @Inject UserAccountManager accountManager;\n    @Inject UploadsStorageManager mUploadsStorageManager;\n    @Inject ConnectivityService connectivityService;\n    @Inject PowerManagementService powerManagementService;\n    @Inject LocalBroadcastManager localBroadcastManager;\n\n    private IndexedForest<UploadFileOperation> mPendingUploads = new IndexedForest<>();\n\n    /**\n     * {@link UploadFileOperation} object of ongoing upload. Can be null. Note: There can only be one concurrent\n     * upload!\n     */\n    private UploadFileOperation mCurrentUpload;\n\n    private NotificationManager mNotificationManager;\n    private NotificationCompat.Builder mNotificationBuilder;\n    private int mLastPercent;\n\n\n    @Override\n    public void onRenameUpload() {\n        mUploadsStorageManager.updateDatabaseUploadStart(mCurrentUpload);\n        sendBroadcastUploadStarted(mCurrentUpload);\n    }\n\n    /**\n     * Service initialization\n     */\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        AndroidInjection.inject(this);\n        Log_OC.d(TAG, \"Creating service\");\n        mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n        HandlerThread thread = new HandlerThread(\"FileUploaderThread\", Process.THREAD_PRIORITY_BACKGROUND);\n        thread.start();\n        mServiceLooper = thread.getLooper();\n        mServiceHandler = new ServiceHandler(mServiceLooper, this);\n        mBinder = new FileUploaderBinder();\n\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(this).setContentTitle(\n            getApplicationContext().getResources().getString(R.string.app_name))\n            .setContentText(getApplicationContext().getResources().getString(R.string.foreground_service_upload))\n            .setSmallIcon(R.drawable.notification_icon)\n            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.notification_icon))\n            .setColor(ThemeColorUtils.primaryColor(getApplicationContext(), true));\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            builder.setChannelId(NotificationUtils.NOTIFICATION_CHANNEL_UPLOAD);\n        }\n\n        mNotification = builder.build();\n\n        // TODO Add UploadResult.KILLED?\n        int failedCounter = mUploadsStorageManager.failInProgressUploads(UploadResult.SERVICE_INTERRUPTED);\n        if (failedCounter > 0) {\n            resurrection();\n        }\n\n        // add AccountsUpdatedListener\n        AccountManager am = AccountManager.get(getApplicationContext());\n        am.addOnAccountsUpdatedListener(this, null, false);\n    }\n\n    /**\n     * Service clean-up when restarted after being killed\n     */\n    private void resurrection() {\n        // remove stucked notification\n        mNotificationManager.cancel(FOREGROUND_SERVICE_ID);\n    }\n\n    /**\n     * Service clean up\n     */\n    @SuppressWarnings(\"PMD.NullAssignment\")\n    @Override\n    public void onDestroy() {\n        Log_OC.v(TAG, \"Destroying service\");\n        mBinder = null;\n        mServiceHandler = null;\n        mServiceLooper.quit();\n        mServiceLooper = null;\n        if (mNotificationManager != null) {\n            mNotificationManager.cancel(FOREGROUND_SERVICE_ID);\n        }\n        mNotificationManager = null;\n\n        // remove AccountsUpdatedListener\n        AccountManager am = AccountManager.get(getApplicationContext());\n        am.removeOnAccountsUpdatedListener(this);\n\n        super.onDestroy();\n    }\n\n    /**\n     * Entry point to add one or several files to the queue of uploads.\n     *\n     * New uploads are added calling to startService(), resulting in a call to this method. This ensures the service\n     * will keep on working although the caller activity goes away.\n     */\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        Log_OC.d(TAG, \"Starting command with id \" + startId);\n\n        startForeground(FOREGROUND_SERVICE_ID, mNotification);\n\n        if (intent == null) {\n            Log_OC.e(TAG, \"Intent is null\");\n            return Service.START_NOT_STICKY;\n        }\n\n        if (!intent.hasExtra(KEY_ACCOUNT)) {\n            Log_OC.e(TAG, \"Not enough information provided in intent\");\n            return Service.START_NOT_STICKY;\n        }\n\n        final Account account = intent.getParcelableExtra(KEY_ACCOUNT);\n        if (account == null) {\n            return Service.START_NOT_STICKY;\n        }\n        Optional<User> optionalUser = accountManager.getUser(account.name);\n        if (!optionalUser.isPresent()) {\n            return Service.START_NOT_STICKY;\n        }\n        final User user = optionalUser.get();\n\n        boolean retry = intent.getBooleanExtra(KEY_RETRY, false);\n        List<String> requestedUploads = new ArrayList<>();\n\n        boolean onWifiOnly = intent.getBooleanExtra(KEY_WHILE_ON_WIFI_ONLY, false);\n        boolean whileChargingOnly = intent.getBooleanExtra(KEY_WHILE_CHARGING_ONLY, false);\n\n        if (!retry) { // Start new uploads\n            if (!(intent.hasExtra(KEY_LOCAL_FILE) || intent.hasExtra(KEY_FILE))) {\n                Log_OC.e(TAG, \"Not enough information provided in intent\");\n                return Service.START_NOT_STICKY;\n            }\n\n            Integer error = gatherAndStartNewUploads(intent, user, requestedUploads, onWifiOnly, whileChargingOnly);\n            if (error != null) {\n                return error;\n            }\n        } else { // Retry uploads\n            if (!intent.hasExtra(KEY_ACCOUNT) || !intent.hasExtra(KEY_RETRY_UPLOAD)) {\n                Log_OC.e(TAG, \"Not enough information provided in intent: no KEY_RETRY_UPLOAD_KEY\");\n                return START_NOT_STICKY;\n            }\n            retryUploads(intent, user, requestedUploads);\n        }\n\n        if (requestedUploads.size() > 0) {\n            Message msg = mServiceHandler.obtainMessage();\n            msg.arg1 = startId;\n            msg.obj = requestedUploads;\n            mServiceHandler.sendMessage(msg);\n            sendBroadcastUploadsAdded();\n        }\n        return Service.START_NOT_STICKY;\n    }\n\n    /**\n     * Gather and start new uploads.\n     *\n     * @return A {@link Service} constant in case of error, {@code null} otherwise.\n     */\n    @Nullable\n    private Integer gatherAndStartNewUploads(\n        Intent intent,\n        User user,\n        List<String> requestedUploads,\n        boolean onWifiOnly,\n        boolean whileChargingOnly\n    ) {\n        String[] localPaths = null;\n        String[] remotePaths = null;\n        String[] mimeTypes = null;\n        OCFile[] files = null;\n\n        if (intent.hasExtra(KEY_FILE)) {\n            Parcelable[] files_temp = intent.getParcelableArrayExtra(KEY_FILE);\n            files = new OCFile[files_temp.length];\n            System.arraycopy(files_temp, 0, files, 0, files_temp.length);\n        } else {\n            localPaths = intent.getStringArrayExtra(KEY_LOCAL_FILE);\n            remotePaths = intent.getStringArrayExtra(KEY_REMOTE_FILE);\n            mimeTypes = intent.getStringArrayExtra(KEY_MIME_TYPE);\n        }\n\n        if (intent.hasExtra(KEY_FILE) && files == null) {\n            Log_OC.e(TAG, \"Incorrect array for OCFiles provided in upload intent\");\n            return Service.START_NOT_STICKY;\n        } else if (!intent.hasExtra(KEY_FILE)) {\n            if (localPaths == null) {\n                Log_OC.e(TAG, \"Incorrect array for local paths provided in upload intent\");\n                return Service.START_NOT_STICKY;\n            }\n            if (remotePaths == null) {\n                Log_OC.e(TAG, \"Incorrect array for remote paths provided in upload intent\");\n                return Service.START_NOT_STICKY;\n            }\n            if (localPaths.length != remotePaths.length) {\n                Log_OC.e(TAG, \"Different number of remote paths and local paths!\");\n                return Service.START_NOT_STICKY;\n            }\n\n            files = new OCFile[localPaths.length];\n            for (int i = 0; i < localPaths.length; i++) {\n                files[i] = UploadFileOperation.obtainNewOCFileToUpload(\n                    remotePaths[i],\n                    localPaths[i],\n                    mimeTypes != null ? mimeTypes[i] : null\n                );\n                if (files[i] == null) {\n                    Log_OC.e(TAG, \"obtainNewOCFileToUpload() returned null for remotePaths[i]:\" + remotePaths[i]\n                        + \" and localPaths[i]:\" + localPaths[i]);\n                    return Service.START_NOT_STICKY;\n                }\n            }\n        }\n        // at this point variable \"OCFile[] files\" is loaded correctly.\n\n        NameCollisionPolicy nameCollisionPolicy = (NameCollisionPolicy) intent.getSerializableExtra(KEY_NAME_COLLISION_POLICY);\n        if (nameCollisionPolicy == null) {\n            nameCollisionPolicy = NameCollisionPolicy.DEFAULT;\n        }\n        int localAction = intent.getIntExtra(KEY_LOCAL_BEHAVIOUR, LOCAL_BEHAVIOUR_FORGET);\n        boolean isCreateRemoteFolder = intent.getBooleanExtra(KEY_CREATE_REMOTE_FOLDER, false);\n        int createdBy = intent.getIntExtra(KEY_CREATED_BY, UploadFileOperation.CREATED_BY_USER);\n        boolean disableRetries = intent.getBooleanExtra(KEY_DISABLE_RETRIES, true);\n        try {\n            for (OCFile file : files) {\n                startNewUpload(\n                    user,\n                    requestedUploads,\n                    onWifiOnly,\n                    whileChargingOnly,\n                    nameCollisionPolicy,\n                    localAction,\n                    isCreateRemoteFolder,\n                    createdBy,\n                    file,\n                    disableRetries\n                              );\n            }\n        } catch (IllegalArgumentException e) {\n            Log_OC.e(TAG, \"Not enough information provided in intent: \" + e.getMessage());\n            return START_NOT_STICKY;\n        } catch (IllegalStateException e) {\n            Log_OC.e(TAG, \"Bad information provided in intent: \" + e.getMessage());\n            return START_NOT_STICKY;\n        } catch (Exception e) {\n            Log_OC.e(TAG, \"Unexpected exception while processing upload intent\", e);\n            return START_NOT_STICKY;\n        }\n        return null;\n    }\n\n    /**\n     * Start a new {@link UploadFileOperation}.\n     */\n    private void startNewUpload(\n        User user,\n        List<String> requestedUploads,\n        boolean onWifiOnly,\n        boolean whileChargingOnly,\n        NameCollisionPolicy nameCollisionPolicy,\n        int localAction,\n        boolean isCreateRemoteFolder,\n        int createdBy,\n        OCFile file,\n        boolean disableRetries\n                               ) {\n        OCUpload ocUpload = new OCUpload(file, user.toPlatformAccount());\n        ocUpload.setFileSize(file.getFileLength());\n        ocUpload.setNameCollisionPolicy(nameCollisionPolicy);\n        ocUpload.setCreateRemoteFolder(isCreateRemoteFolder);\n        ocUpload.setCreatedBy(createdBy);\n        ocUpload.setLocalAction(localAction);\n        ocUpload.setUseWifiOnly(onWifiOnly);\n        ocUpload.setWhileChargingOnly(whileChargingOnly);\n        ocUpload.setUploadStatus(UploadStatus.UPLOAD_IN_PROGRESS);\n\n        UploadFileOperation newUpload = new UploadFileOperation(\n            mUploadsStorageManager,\n            connectivityService,\n            powerManagementService,\n            user,\n            file,\n            ocUpload,\n            nameCollisionPolicy,\n            localAction,\n            this,\n            onWifiOnly,\n            whileChargingOnly,\n            disableRetries\n        );\n        newUpload.setCreatedBy(createdBy);\n        if (isCreateRemoteFolder) {\n            newUpload.setRemoteFolderToBeCreated();\n        }\n        newUpload.addDataTransferProgressListener(this);\n        newUpload.addDataTransferProgressListener((FileUploaderBinder) mBinder);\n\n        newUpload.addRenameUploadListener(this);\n\n        Pair<String, String> putResult = mPendingUploads.putIfAbsent(\n            user.getAccountName(),\n            file.getRemotePath(),\n            newUpload\n        );\n\n        if (putResult != null) {\n            requestedUploads.add(putResult.first);\n\n            // Save upload in database\n            long id = mUploadsStorageManager.storeUpload(ocUpload);\n            newUpload.setOCUploadId(id);\n        }\n    }\n\n    /**\n     * Retries a list of uploads.\n     */\n    private void retryUploads(Intent intent, User user, List<String> requestedUploads) {\n        boolean onWifiOnly;\n        boolean whileChargingOnly;\n        OCUpload upload = intent.getParcelableExtra(KEY_RETRY_UPLOAD);\n\n        onWifiOnly = upload.isUseWifiOnly();\n        whileChargingOnly = upload.isWhileChargingOnly();\n\n        UploadFileOperation newUpload = new UploadFileOperation(\n            mUploadsStorageManager,\n            connectivityService,\n            powerManagementService,\n            user,\n            null,\n            upload,\n            upload.getNameCollisionPolicy(),\n            upload.getLocalAction(),\n            this,\n            onWifiOnly,\n            whileChargingOnly,\n            true\n        );\n\n        newUpload.addDataTransferProgressListener(this);\n        newUpload.addDataTransferProgressListener((FileUploaderBinder) mBinder);\n\n        newUpload.addRenameUploadListener(this);\n\n        Pair<String, String> putResult = mPendingUploads.putIfAbsent(\n            user.getAccountName(),\n            upload.getRemotePath(),\n            newUpload\n        );\n        if (putResult != null) {\n            String uploadKey = putResult.first;\n            requestedUploads.add(uploadKey);\n\n            // Update upload in database\n            upload.setUploadStatus(UploadStatus.UPLOAD_IN_PROGRESS);\n            mUploadsStorageManager.updateUpload(upload);\n        }\n    }\n\n    /**\n     * Provides a binder object that clients can use to perform operations on the queue of uploads, excepting the\n     * addition of new files.\n     *\n     * Implemented to perform cancellation, pause and resume of existing uploads.\n     */\n    @Override\n    public IBinder onBind(Intent intent) {\n        return mBinder;\n    }\n\n    /**\n     * Called when ALL the bound clients were onbound.\n     */\n    @Override\n    public boolean onUnbind(Intent intent) {\n        ((FileUploaderBinder) mBinder).clearListeners();\n        return false;   // not accepting rebinding (default behaviour)\n    }\n\n    @Override\n    public void onAccountsUpdated(Account[] accounts) {\n        // Review current upload, and cancel it if its account doesn't exist\n        if (mCurrentUpload != null && !accountManager.exists(mCurrentUpload.getAccount())) {\n            mCurrentUpload.cancel(ResultCode.ACCOUNT_NOT_FOUND);\n        }\n        // The rest of uploads are cancelled when they try to start\n    }\n\n    /**\n     * Core upload method: sends the file(s) to upload\n     *\n     * @param uploadKey Key to access the upload to perform, contained in mPendingUploads\n     */\n    public void uploadFile(String uploadKey) {\n        mCurrentUpload = mPendingUploads.get(uploadKey);\n\n        if (mCurrentUpload != null) {\n            /// Check account existence\n            if (!accountManager.exists(mCurrentUpload.getAccount())) {\n                Log_OC.w(TAG, \"Account \" + mCurrentUpload.getAccount().name +\n                    \" does not exist anymore -> cancelling all its uploads\");\n                cancelUploadsForAccount(mCurrentUpload.getAccount());\n                return;\n            }\n\n            /// OK, let's upload\n            mUploadsStorageManager.updateDatabaseUploadStart(mCurrentUpload);\n\n            notifyUploadStart(mCurrentUpload);\n\n            sendBroadcastUploadStarted(mCurrentUpload);\n\n            RemoteOperationResult uploadResult = null;\n\n            try {\n                /// prepare client object to send the request to the ownCloud server\n                if (mCurrentAccount == null || !mCurrentAccount.equals(mCurrentUpload.getAccount())) {\n                    mCurrentAccount = mCurrentUpload.getAccount();\n                    mStorageManager = new FileDataStorageManager(mCurrentAccount, getContentResolver());\n                }   // else, reuse storage manager from previous operation\n\n                // always get client from client manager, to get fresh credentials in case of update\n                OwnCloudAccount ocAccount = new OwnCloudAccount(mCurrentAccount, this);\n                mUploadClient = OwnCloudClientManagerFactory.getDefaultSingleton().getClientFor(ocAccount, this);\n\n\n//                // If parent folder is encrypted, upload file encrypted\n//                OCFile parent = mStorageManager.getFileByPath(mCurrentUpload.getFile().getParentRemotePath());\n\n//                if (parent.isEncrypted()) {\n//                    UploadEncryptedFileOperation uploadEncryptedFileOperation =\n//                            new UploadEncryptedFileOperation(parent, mCurrentUpload);\n//\n//                    uploadResult = uploadEncryptedFileOperation.execute(mUploadClient, mStorageManager);\n//                } else {\n                /// perform the regular upload\n                uploadResult = mCurrentUpload.execute(mUploadClient, mStorageManager);\n//                }\n            } catch (Exception e) {\n                Log_OC.e(TAG, \"Error uploading\", e);\n                uploadResult = new RemoteOperationResult(e);\n            } finally {\n                Pair<UploadFileOperation, String> removeResult;\n                if (mCurrentUpload.wasRenamed()) {\n                    removeResult = mPendingUploads.removePayload(\n                        mCurrentAccount.name,\n                        mCurrentUpload.getOldFile().getRemotePath()\n                    );\n                    // TODO: grant that name is also updated for mCurrentUpload.getOCUploadId\n\n                } else {\n                    removeResult = mPendingUploads.removePayload(mCurrentAccount.name,\n                                                                 mCurrentUpload.getDecryptedRemotePath());\n                }\n\n                mUploadsStorageManager.updateDatabaseUploadResult(uploadResult, mCurrentUpload);\n\n                /// notify result\n                notifyUploadResult(mCurrentUpload, uploadResult);\n\n                sendBroadcastUploadFinished(mCurrentUpload, uploadResult, removeResult.second);\n            }\n\n            // generate new Thumbnail\n            final ThumbnailsCacheManager.ThumbnailGenerationTask task =\n                new ThumbnailsCacheManager.ThumbnailGenerationTask(mStorageManager, mCurrentAccount);\n\n            File file = new File(mCurrentUpload.getOriginalStoragePath());\n            String remoteId = mCurrentUpload.getFile().getRemoteId();\n\n            task.execute(new ThumbnailsCacheManager.ThumbnailGenerationTaskObject(file, remoteId));\n        }\n    }\n\n\n    /**\n     * Creates a status notification to show the upload progress\n     *\n     * @param upload Upload operation starting.\n     */\n    private void notifyUploadStart(UploadFileOperation upload) {\n        // / create status notification with a progress bar\n        mLastPercent = 0;\n        mNotificationBuilder = NotificationUtils.newNotificationBuilder(this);\n        mNotificationBuilder\n            .setOngoing(true)\n            .setSmallIcon(R.drawable.notification_icon)\n            .setTicker(getString(R.string.uploader_upload_in_progress_ticker))\n            .setContentTitle(getString(R.string.uploader_upload_in_progress_ticker))\n            .setProgress(100, 0, false)\n            .setContentText(\n                String.format(getString(R.string.uploader_upload_in_progress_content), 0, upload.getFileName())\n            );\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            mNotificationBuilder.setChannelId(NotificationUtils.NOTIFICATION_CHANNEL_UPLOAD);\n        }\n\n        /// includes a pending intent in the notification showing the details\n        Intent intent = UploadListActivity.createIntent(upload.getFile(),\n                                                        upload.getAccount(),\n                                                        Intent.FLAG_ACTIVITY_CLEAR_TOP,\n                                                        this);\n        mNotificationBuilder.setContentIntent(PendingIntent.getActivity(this,\n                                                                        (int) System.currentTimeMillis(),\n                                                                        intent,\n                                                                        0)\n                                             );\n\n        if (!upload.isInstantPicture() && !upload.isInstantVideo()) {\n            if (mNotificationManager == null) {\n                mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n            }\n\n            mNotificationManager.notify(FOREGROUND_SERVICE_ID, mNotificationBuilder.build());\n        }   // else wait until the upload really start (onTransferProgress is called), so that if it's discarded\n        // due to lack of Wifi, no notification is shown\n        // TODO generalize for automated uploads\n    }\n\n    /**\n     * Callback method to update the progress bar in the status notification\n     */\n    @Override\n    public void onTransferProgress(\n        long progressRate,\n        long totalTransferredSoFar,\n        long totalToTransfer,\n        String filePath\n    ) {\n        int percent = (int) (100.0 * ((double) totalTransferredSoFar) / ((double) totalToTransfer));\n        if (percent != mLastPercent) {\n            mNotificationBuilder.setProgress(100, percent, false);\n            String fileName = filePath.substring(filePath.lastIndexOf(FileUtils.PATH_SEPARATOR) + 1);\n            String text = String.format(getString(R.string.uploader_upload_in_progress_content), percent, fileName);\n            mNotificationBuilder.setContentText(text);\n            if (mNotificationManager == null) {\n                mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n            }\n            mNotificationManager.notify(FOREGROUND_SERVICE_ID, mNotificationBuilder.build());\n        }\n        mLastPercent = percent;\n    }\n\n    /**\n     * Updates the status notification with the result of an upload operation.\n     *\n     * @param uploadResult Result of the upload operation.\n     * @param upload       Finished upload operation\n     */\n    @SuppressFBWarnings(\"DMI\")\n    private void notifyUploadResult(UploadFileOperation upload, RemoteOperationResult uploadResult) {\n        Log_OC.d(TAG, \"NotifyUploadResult with resultCode: \" + uploadResult.getCode());\n        // cancelled operation or success -> silent removal of progress notification\n        if (mNotificationManager == null) {\n            mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n        }\n\n        // Only notify if the upload fails\n        if (!uploadResult.isCancelled() &&\n            !uploadResult.isSuccess() &&\n            !ResultCode.LOCAL_FILE_NOT_FOUND.equals(uploadResult.getCode()) &&\n            !uploadResult.getCode().equals(ResultCode.DELAYED_FOR_WIFI) &&\n            !uploadResult.getCode().equals(ResultCode.DELAYED_FOR_CHARGING) &&\n            !uploadResult.getCode().equals(ResultCode.DELAYED_IN_POWER_SAVE_MODE) &&\n            !uploadResult.getCode().equals(ResultCode.LOCK_FAILED)) {\n\n            int tickerId = R.string.uploader_upload_failed_ticker;\n\n            String content;\n\n            // check credentials error\n            boolean needsToUpdateCredentials = uploadResult.getCode() == ResultCode.UNAUTHORIZED;\n            if (needsToUpdateCredentials) {\n                tickerId = R.string.uploader_upload_failed_credentials_error;\n            } else if (uploadResult.getCode() == ResultCode.SYNC_CONFLICT) { // check file conflict\n                tickerId = R.string.uploader_upload_failed_sync_conflict_error;\n            }\n\n            mNotificationBuilder\n                .setTicker(getString(tickerId))\n                .setContentTitle(getString(tickerId))\n                .setAutoCancel(true)\n                .setOngoing(false)\n                .setProgress(0, 0, false);\n\n            content = ErrorMessageAdapter.getErrorCauseMessage(uploadResult, upload, getResources());\n\n            if (needsToUpdateCredentials) {\n                // let the user update credentials with one click\n                Intent updateAccountCredentials = new Intent(this, AuthenticatorActivity.class);\n                updateAccountCredentials.putExtra(\n                    AuthenticatorActivity.EXTRA_ACCOUNT, upload.getAccount()\n                );\n                updateAccountCredentials.putExtra(\n                    AuthenticatorActivity.EXTRA_ACTION,\n                    AuthenticatorActivity.ACTION_UPDATE_EXPIRED_TOKEN\n                );\n\n                updateAccountCredentials.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                updateAccountCredentials.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                updateAccountCredentials.addFlags(Intent.FLAG_FROM_BACKGROUND);\n                mNotificationBuilder.setContentIntent(PendingIntent.getActivity(\n                    this,\n                    (int) System.currentTimeMillis(),\n                    updateAccountCredentials,\n                    PendingIntent.FLAG_ONE_SHOT\n                ));\n            } else {\n                Intent intent;\n                if (uploadResult.getCode().equals(ResultCode.SYNC_CONFLICT)) {\n                    intent = ConflictsResolveActivity.createIntent(upload.getFile(),\n                                                                   upload.getAccount(),\n                                                                   upload.getOCUploadId(),\n                                                                   Intent.FLAG_ACTIVITY_CLEAR_TOP,\n                                                                   this);\n                } else {\n                    intent = UploadListActivity.createIntent(upload.getFile(),\n                                                             upload.getAccount(),\n                                                             Intent.FLAG_ACTIVITY_CLEAR_TOP,\n                                                             this);\n                }\n\n                mNotificationBuilder.setContentIntent(PendingIntent.getActivity(this,\n                                                                                (int) System.currentTimeMillis(),\n                                                                                intent,\n                                                                                0)\n                                                     );\n            }\n\n            mNotificationBuilder.setContentText(content);\n            if (!uploadResult.isSuccess()) {\n                mNotificationManager.notify((new SecureRandom()).nextInt(), mNotificationBuilder.build());\n            }\n\n        }\n    }\n\n    /**\n     * Sends a broadcast in order to the interested activities can update their view\n     *\n     * TODO - no more broadcasts, replace with a callback to subscribed listeners\n     */\n    private void sendBroadcastUploadsAdded() {\n        Intent start = new Intent(getUploadsAddedMessage());\n        // nothing else needed right now\n        start.setPackage(getPackageName());\n        localBroadcastManager.sendBroadcast(start);\n    }\n\n    /**\n     * Sends a broadcast in order to the interested activities can update their view\n     *\n     * TODO - no more broadcasts, replace with a callback to subscribed listeners\n     *\n     * @param upload Finished upload operation\n     */\n    private void sendBroadcastUploadStarted(UploadFileOperation upload) {\n        Intent start = new Intent(getUploadStartMessage());\n        start.putExtra(EXTRA_REMOTE_PATH, upload.getRemotePath()); // real remote\n        start.putExtra(EXTRA_OLD_FILE_PATH, upload.getOriginalStoragePath());\n        start.putExtra(ACCOUNT_NAME, upload.getAccount().name);\n\n        start.setPackage(getPackageName());\n        localBroadcastManager.sendBroadcast(start);\n    }\n\n    /**\n     * Sends a broadcast in order to the interested activities can update their view\n     *\n     * TODO - no more broadcasts, replace with a callback to subscribed listeners\n     *\n     * @param upload                 Finished upload operation\n     * @param uploadResult           Result of the upload operation\n     * @param unlinkedFromRemotePath Path in the uploads tree where the upload was unlinked from\n     */\n    private void sendBroadcastUploadFinished(\n        UploadFileOperation upload,\n        RemoteOperationResult uploadResult,\n        String unlinkedFromRemotePath\n    ) {\n        Intent end = new Intent(getUploadFinishMessage());\n        end.putExtra(EXTRA_REMOTE_PATH, upload.getRemotePath()); // real remote\n        // path, after\n        // possible\n        // automatic\n        // renaming\n        if (upload.wasRenamed()) {\n            end.putExtra(EXTRA_OLD_REMOTE_PATH, upload.getOldFile().getRemotePath());\n        }\n        end.putExtra(EXTRA_OLD_FILE_PATH, upload.getOriginalStoragePath());\n        end.putExtra(ACCOUNT_NAME, upload.getAccount().name);\n        end.putExtra(EXTRA_UPLOAD_RESULT, uploadResult.isSuccess());\n        if (unlinkedFromRemotePath != null) {\n            end.putExtra(EXTRA_LINKED_TO_PATH, unlinkedFromRemotePath);\n        }\n        end.setPackage(getPackageName());\n        localBroadcastManager.sendBroadcast(end);\n    }\n\n    /**\n     * Remove and 'forgets' pending uploads of an account.\n     *\n     * @param account Account which uploads will be cancelled\n     */\n    private void cancelUploadsForAccount(Account account) {\n        mPendingUploads.remove(account.name);\n        mUploadsStorageManager.removeUploads(account.name);\n    }\n\n\n    /**\n     * Upload a new file\n     */\n    public static void uploadNewFile(\n        Context context,\n        Account account,\n        String localPath,\n        String remotePath,\n        int behaviour,\n        String mimeType,\n        boolean createRemoteFile,\n        int createdBy,\n        boolean requiresWifi,\n        boolean requiresCharging,\n        NameCollisionPolicy nameCollisionPolicy\n    ) {\n        uploadNewFile(\n            context,\n            account,\n            new String[]{localPath},\n            new String[]{remotePath},\n            new String[]{mimeType},\n            behaviour,\n            createRemoteFile,\n            createdBy,\n            requiresWifi,\n            requiresCharging,\n            nameCollisionPolicy\n        );\n    }\n\n    /**\n     * Upload multiple new files\n     */\n    public static void uploadNewFile(\n        Context context,\n        Account account,\n        String[] localPaths,\n        String[] remotePaths,\n        String[] mimeTypes,\n        Integer behaviour,\n        Boolean createRemoteFolder,\n        int createdBy,\n        boolean requiresWifi,\n        boolean requiresCharging,\n        NameCollisionPolicy nameCollisionPolicy\n    ) {\n        Intent intent = new Intent(context, FileUploader.class);\n\n        intent.putExtra(FileUploader.KEY_ACCOUNT, account);\n        intent.putExtra(FileUploader.KEY_LOCAL_FILE, localPaths);\n        intent.putExtra(FileUploader.KEY_REMOTE_FILE, remotePaths);\n        intent.putExtra(FileUploader.KEY_MIME_TYPE, mimeTypes);\n        intent.putExtra(FileUploader.KEY_LOCAL_BEHAVIOUR, behaviour);\n        intent.putExtra(FileUploader.KEY_CREATE_REMOTE_FOLDER, createRemoteFolder);\n        intent.putExtra(FileUploader.KEY_CREATED_BY, createdBy);\n        intent.putExtra(FileUploader.KEY_WHILE_ON_WIFI_ONLY, requiresWifi);\n        intent.putExtra(FileUploader.KEY_WHILE_CHARGING_ONLY, requiresCharging);\n        intent.putExtra(FileUploader.KEY_NAME_COLLISION_POLICY, nameCollisionPolicy);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            context.startForegroundService(intent);\n        } else {\n            context.startService(intent);\n        }\n    }\n\n    /**\n     * Upload and overwrite an already uploaded file with disabled retries\n     */\n    public static void uploadUpdateFile(\n        Context context,\n        Account account,\n        OCFile existingFile,\n        Integer behaviour,\n        NameCollisionPolicy nameCollisionPolicy\n                                       ) {\n        uploadUpdateFile(context, account, new OCFile[]{existingFile}, behaviour, nameCollisionPolicy, true);\n    }\n\n    /**\n     * Upload and overwrite an already uploaded file\n     */\n    public static void uploadUpdateFile(\n        Context context,\n        Account account,\n        OCFile existingFile,\n        Integer behaviour,\n        NameCollisionPolicy nameCollisionPolicy,\n        boolean disableRetries\n                                       ) {\n        uploadUpdateFile(context, account, new OCFile[]{existingFile}, behaviour, nameCollisionPolicy, disableRetries);\n    }\n\n    /**\n     * Upload and overwrite already uploaded files\n     */\n    public static void uploadUpdateFile(\n        Context context,\n        Account account,\n        OCFile[] existingFiles,\n        Integer behaviour,\n        NameCollisionPolicy nameCollisionPolicy,\n        boolean disableRetries\n                                       ) {\n        Intent intent = new Intent(context, FileUploader.class);\n\n        intent.putExtra(FileUploader.KEY_ACCOUNT, account);\n        intent.putExtra(FileUploader.KEY_FILE, existingFiles);\n        intent.putExtra(FileUploader.KEY_LOCAL_BEHAVIOUR, behaviour);\n        intent.putExtra(FileUploader.KEY_NAME_COLLISION_POLICY, nameCollisionPolicy);\n        intent.putExtra(FileUploader.KEY_DISABLE_RETRIES, disableRetries);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            context.startForegroundService(intent);\n        } else {\n            context.startService(intent);\n        }\n    }\n\n    /**\n     * Retry a failed {@link OCUpload} identified by {@link OCUpload#getRemotePath()}\n     */\n    public static void retryUpload(@NonNull Context context, @NonNull Account account, @NonNull OCUpload upload) {\n        Intent i = new Intent(context, FileUploader.class);\n        i.putExtra(FileUploader.KEY_RETRY, true);\n        i.putExtra(FileUploader.KEY_ACCOUNT, account);\n        i.putExtra(FileUploader.KEY_RETRY_UPLOAD, upload);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            context.startForegroundService(i);\n        } else {\n            context.startService(i);\n        }\n    }\n\n    /**\n     * Retry a subset of all the stored failed uploads.\n     *\n     * @param context      Caller {@link Context}\n     * @param account      If not null, only failed uploads to this OC account will be retried; otherwise, uploads of\n     *                     all accounts will be retried.\n     * @param uploadResult If not null, only failed uploads with the result specified will be retried; otherwise, failed\n     *                     uploads due to any result will be retried.\n     */\n    public static void retryFailedUploads(\n        @NonNull final Context context,\n        @Nullable final Account account,\n        @NonNull final UploadsStorageManager uploadsStorageManager,\n        @NonNull final ConnectivityService connectivityService,\n        @NonNull final UserAccountManager accountManager,\n        @NonNull final PowerManagementService powerManagementService,\n        @Nullable final UploadResult uploadResult\n    ) {\n        OCUpload[] failedUploads = uploadsStorageManager.getFailedUploads();\n        if(failedUploads.length == 0)\n        {\n            //nothing to do\n            return;\n        }\n\n        Account currentAccount = null;\n        boolean resultMatch;\n        boolean accountMatch;\n\n        final Connectivity connectivity = connectivityService.getConnectivity();\n        final boolean gotNetwork = connectivity.isConnected() && !connectivityService.isInternetWalled();\n        final boolean gotWifi = connectivity.isWifi();\n        final BatteryStatus batteryStatus = powerManagementService.getBattery();\n        final boolean charging = batteryStatus.isCharging() || batteryStatus.isFull();\n        final boolean isPowerSaving = powerManagementService.isPowerSavingEnabled();\n\n        for (OCUpload failedUpload : failedUploads) {\n            accountMatch = account == null || account.name.equals(failedUpload.getAccountName());\n            resultMatch = uploadResult == null || uploadResult == failedUpload.getLastResult();\n            if (accountMatch && resultMatch) {\n                if (currentAccount == null || !currentAccount.name.equals(failedUpload.getAccountName())) {\n                    currentAccount = failedUpload.getAccount(accountManager);\n                }\n\n                if (!new File(failedUpload.getLocalPath()).exists()) {\n                    if (failedUpload.getLastResult() != UploadResult.FILE_NOT_FOUND) {\n                        failedUpload.setLastResult(UploadResult.FILE_NOT_FOUND);\n                        uploadsStorageManager.updateUpload(failedUpload);\n                    }\n                } else {\n\n                    if (!isPowerSaving && gotNetwork && canUploadBeRetried(failedUpload, gotWifi, charging)) {\n                        retryUpload(context, currentAccount, failedUpload);\n                    }\n                }\n            }\n        }\n    }\n\n    private static boolean canUploadBeRetried(OCUpload upload, boolean gotWifi, boolean isCharging) {\n        File file = new File(upload.getLocalPath());\n        boolean needsWifi = upload.isUseWifiOnly();\n        boolean needsCharging = upload.isWhileChargingOnly();\n\n        return file.exists() && (!needsWifi || gotWifi) && (!needsCharging || isCharging);\n    }\n\n    public static String getUploadsAddedMessage() {\n        return FileUploader.class.getName() + UPLOADS_ADDED_MESSAGE;\n    }\n\n    public static String getUploadStartMessage() {\n        return FileUploader.class.getName() + UPLOAD_START_MESSAGE;\n    }\n\n    public static String getUploadFinishMessage() {\n        return FileUploader.class.getName() + UPLOAD_FINISH_MESSAGE;\n    }\n\n\n    /**\n     * Ordinal of enumerated constants is important for old data compatibility.\n     */\n    public enum NameCollisionPolicy {\n        RENAME, // Ordinal corresponds to old forceOverwrite = false (0 in database)\n        OVERWRITE, // Ordinal corresponds to old forceOverwrite = true (1 in database)\n        CANCEL,\n        ASK_USER;\n\n        public static final NameCollisionPolicy DEFAULT = RENAME;\n\n        public static NameCollisionPolicy deserialize(int ordinal) {\n            NameCollisionPolicy[] values = NameCollisionPolicy.values();\n            return ordinal >= 0 && ordinal < values.length ? values[ordinal] : DEFAULT;\n        }\n\n        public int serialize() {\n            return this.ordinal();\n        }\n    }\n\n    /**\n     * Binder to let client components to perform operations on the queue of uploads.\n     *\n     * It provides by itself the available operations.\n     */\n    public class FileUploaderBinder extends Binder implements OnDatatransferProgressListener {\n\n        /**\n         * Map of listeners that will be reported about progress of uploads from a {@link FileUploaderBinder} instance\n         */\n        private Map<String, OnDatatransferProgressListener> mBoundListeners = new HashMap<>();\n\n        /**\n         * Cancels a pending or current upload of a remote file.\n         *\n         * @param account ownCloud account where the remote file will be stored.\n         * @param file    A file in the queue of pending uploads\n         */\n        public void cancel(Account account, OCFile file) {\n            cancel(account.name, file.getRemotePath(), null);\n        }\n\n        /**\n         * Cancels a pending or current upload that was persisted.\n         *\n         * @param storedUpload Upload operation persisted\n         */\n        public void cancel(OCUpload storedUpload) {\n            cancel(storedUpload.getAccountName(), storedUpload.getRemotePath(), null);\n        }\n\n        /**\n         * Cancels a pending or current upload of a remote file.\n         *\n         * @param accountName Local name of an ownCloud account where the remote file will be stored.\n         * @param remotePath  Remote target of the upload\n         * @param resultCode  Setting result code will pause rather than cancel the job\n         */\n        private void cancel(String accountName, String remotePath, @Nullable ResultCode resultCode) {\n            Pair<UploadFileOperation, String> removeResult = mPendingUploads.remove(accountName, remotePath);\n            UploadFileOperation upload = removeResult.first;\n            if (upload == null && mCurrentUpload != null && mCurrentAccount != null &&\n                mCurrentUpload.getRemotePath().startsWith(remotePath) && accountName.equals(mCurrentAccount.name)) {\n\n                upload = mCurrentUpload;\n            }\n\n            if (upload != null) {\n                upload.cancel(resultCode);\n                // need to update now table in mUploadsStorageManager,\n                // since the operation will not get to be run by FileUploader#uploadFile\n                if (resultCode != null) {\n                    mUploadsStorageManager.updateDatabaseUploadResult(new RemoteOperationResult(resultCode), upload);\n                    notifyUploadResult(upload, new RemoteOperationResult(resultCode));\n                } else {\n                    mUploadsStorageManager.removeUpload(accountName, remotePath);\n                }\n            }\n        }\n\n        /**\n         * Cancels all the uploads for an account.\n         *\n         * @param account ownCloud account.\n         */\n        public void cancel(Account account) {\n            Log_OC.d(TAG, \"Account= \" + account.name);\n\n            if (mCurrentUpload != null) {\n                Log_OC.d(TAG, \"Current Upload Account= \" + mCurrentUpload.getAccount().name);\n                if (mCurrentUpload.getAccount().name.equals(account.name)) {\n                    mCurrentUpload.cancel(ResultCode.CANCELLED);\n                }\n            }\n\n            // Cancel pending uploads\n            cancelUploadsForAccount(account);\n        }\n\n        public void clearListeners() {\n            mBoundListeners.clear();\n        }\n\n        /**\n         * Returns True when the file described by 'file' is being uploaded to the ownCloud account 'account' or waiting\n         * for it\n         *\n         * If 'file' is a directory, returns 'true' if some of its descendant files is uploading or waiting to upload.\n         *\n         * Warning: If remote file exists and target was renamed the original file is being returned here. That is, it\n         * seems as if the original file is being updated when actually a new file is being uploaded.\n         *\n         * @param user    user where the remote file will be stored.\n         * @param file    A file that could be in the queue of pending uploads\n         */\n        public boolean isUploading(User user, OCFile file) {\n            if (user == null || file == null) {\n                return false;\n            }\n\n            return mPendingUploads.contains(user.getAccountName(), file.getRemotePath());\n        }\n\n        public boolean isUploadingNow(OCUpload upload) {\n            return upload != null &&\n                mCurrentAccount != null &&\n                mCurrentUpload != null &&\n                upload.getAccountName().equals(mCurrentAccount.name) &&\n                upload.getRemotePath().equals(mCurrentUpload.getRemotePath());\n        }\n\n        /**\n         * Adds a listener interested in the progress of the upload for a concrete file.\n         *\n         * @param listener Object to notify about progress of transfer.\n         * @param user  user owning the file of interest.\n         * @param file     {@link OCFile} of interest for listener.\n         */\n        public void addDatatransferProgressListener(\n            OnDatatransferProgressListener listener,\n            User user,\n            OCFile file\n        ) {\n            if (user == null || file == null || listener == null) {\n                return;\n            }\n\n            String targetKey = buildRemoteName(user.getAccountName(), file.getRemotePath());\n            mBoundListeners.put(targetKey, listener);\n        }\n\n        /**\n         * Adds a listener interested in the progress of the upload for a concrete file.\n         *\n         * @param listener Object to notify about progress of transfer.\n         * @param ocUpload {@link OCUpload} of interest for listener.\n         */\n        public void addDatatransferProgressListener(\n            OnDatatransferProgressListener listener,\n            OCUpload ocUpload\n        ) {\n            if (ocUpload == null || listener == null) {\n                return;\n            }\n\n            String targetKey = buildRemoteName(ocUpload.getAccountName(), ocUpload.getRemotePath());\n            mBoundListeners.put(targetKey, listener);\n        }\n\n        /**\n         * Removes a listener interested in the progress of the upload for a concrete file.\n         *\n         * @param listener Object to notify about progress of transfer.\n         * @param user user owning the file of interest.\n         * @param file {@link OCFile} of interest for listener.\n         */\n        public void removeDatatransferProgressListener(\n            OnDatatransferProgressListener listener,\n            User user,\n            OCFile file\n        ) {\n            if (user == null || file == null || listener == null) {\n                return;\n            }\n\n            String targetKey = buildRemoteName(user.getAccountName(), file.getRemotePath());\n            if (mBoundListeners.get(targetKey) == listener) {\n                mBoundListeners.remove(targetKey);\n            }\n        }\n\n        /**\n         * Removes a listener interested in the progress of the upload for a concrete file.\n         *\n         * @param listener Object to notify about progress of transfer.\n         * @param ocUpload Stored upload of interest\n         */\n        public void removeDatatransferProgressListener(\n            OnDatatransferProgressListener listener,\n            OCUpload ocUpload\n        ) {\n            if (ocUpload == null || listener == null) {\n                return;\n            }\n\n            String targetKey = buildRemoteName(ocUpload.getAccountName(), ocUpload.getRemotePath());\n            if (mBoundListeners.get(targetKey) == listener) {\n                mBoundListeners.remove(targetKey);\n            }\n        }\n\n        @Override\n        public void onTransferProgress(\n            long progressRate,\n            long totalTransferredSoFar,\n            long totalToTransfer,\n            String fileName\n        ) {\n            String key = buildRemoteName(mCurrentUpload.getAccount().name, mCurrentUpload.getFile().getRemotePath());\n            OnDatatransferProgressListener boundListener = mBoundListeners.get(key);\n\n            if (boundListener != null) {\n                boundListener.onTransferProgress(progressRate, totalTransferredSoFar, totalToTransfer, fileName);\n            }\n\n            Context context = MainApp.getAppContext();\n            if (context != null) {\n                ResultCode cancelReason = null;\n                Connectivity connectivity = connectivityService.getConnectivity();\n                if (mCurrentUpload.isWifiRequired() && !connectivity.isWifi()) {\n                    cancelReason = ResultCode.DELAYED_FOR_WIFI;\n                } else if (mCurrentUpload.isChargingRequired() && !powerManagementService.getBattery().isCharging()) {\n                    cancelReason = ResultCode.DELAYED_FOR_CHARGING;\n                } else if (!mCurrentUpload.isIgnoringPowerSaveMode() && powerManagementService.isPowerSavingEnabled()) {\n                    cancelReason = ResultCode.DELAYED_IN_POWER_SAVE_MODE;\n                }\n\n                if (cancelReason != null) {\n                    cancel(\n                        mCurrentUpload.getAccount().name,\n                        mCurrentUpload.getFile().getRemotePath(),\n                        cancelReason\n                    );\n                }\n            }\n        }\n\n        /**\n         * Builds a key for the map of listeners.\n         *\n         * TODO use method in IndexedForest, or refactor both to a common place add to local database) to better policy\n         * (add to local database, then upload)\n         *\n         * @param accountName Local name of the ownCloud account where the file to upload belongs.\n         * @param remotePath  Remote path to upload the file to.\n         * @return Key\n         */\n        private String buildRemoteName(String accountName, String remotePath) {\n            return accountName + remotePath;\n        }\n    }\n\n\n    /**\n     * Upload worker. Performs the pending uploads in the order they were requested.\n     *\n     * Created with the Looper of a new thread, started in {@link FileUploader#onCreate()}.\n     */\n    private static class ServiceHandler extends Handler {\n        // don't make it a final class, and don't remove the static ; lint will\n        // warn about a possible memory leak\n        private FileUploader mService;\n\n        public ServiceHandler(Looper looper, FileUploader service) {\n            super(looper);\n            if (service == null) {\n                throw new IllegalArgumentException(\"Received invalid NULL in parameter 'service'\");\n            }\n            mService = service;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            @SuppressWarnings(\"unchecked\")\n            List<String> requestedUploads = (List<String>) msg.obj;\n            if (msg.obj != null) {\n                for (String requestedUpload : requestedUploads) {\n                    mService.uploadFile(requestedUpload);\n                }\n            }\n            Log_OC.d(TAG, \"Stopping command after id \" + msg.arg1);\n            mService.mNotificationManager.cancel(FOREGROUND_SERVICE_ID);\n            mService.stopForeground(true);\n            mService.stopSelf(msg.arg1);\n        }\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700286,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "/**\n *  ownCloud Android client application\n *\n *  @author Bartek Przybylski\n *  @author masensio\n *  @author LukeOwnCloud\n *  @author David A. Velasco\n *  @author Chris Narkiewicz\n *\n *  Copyright (C) 2012 Bartek Przybylski\n *  Copyright (C) 2012-2016 ownCloud Inc.\n *  Copyright (C) 2020 Chris Narkiewicz <hello@ezaquarii.com>\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2,\n *  as published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage com.owncloud.android.files.services;\n\nimport android.accounts.Account;\nimport android.accounts.AccountManager;\nimport android.accounts.OnAccountsUpdateListener;\nimport android.annotation.SuppressLint;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.graphics.BitmapFactory;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.HandlerThread;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcelable;\nimport android.os.Process;\nimport android.util.Pair;\n\nimport com.nextcloud.client.account.User;\nimport com.nextcloud.client.account.UserAccountManager;\nimport com.nextcloud.client.device.BatteryStatus;\nimport com.nextcloud.client.device.PowerManagementService;\nimport com.nextcloud.client.network.Connectivity;\nimport com.nextcloud.client.network.ConnectivityService;\nimport com.nextcloud.java.util.Optional;\nimport com.owncloud.android.MainApp;\nimport com.owncloud.android.R;\nimport com.owncloud.android.authentication.AuthenticatorActivity;\nimport com.owncloud.android.datamodel.FileDataStorageManager;\nimport com.owncloud.android.datamodel.OCFile;\nimport com.owncloud.android.datamodel.ThumbnailsCacheManager;\nimport com.owncloud.android.datamodel.UploadsStorageManager;\nimport com.owncloud.android.datamodel.UploadsStorageManager.UploadStatus;\nimport com.owncloud.android.db.OCUpload;\nimport com.owncloud.android.db.UploadResult;\nimport com.owncloud.android.lib.common.OwnCloudAccount;\nimport com.owncloud.android.lib.common.OwnCloudClient;\nimport com.owncloud.android.lib.common.OwnCloudClientManagerFactory;\nimport com.owncloud.android.lib.common.network.OnDatatransferProgressListener;\nimport com.owncloud.android.lib.common.operations.RemoteOperationResult;\nimport com.owncloud.android.lib.common.operations.RemoteOperationResult.ResultCode;\nimport com.owncloud.android.lib.common.utils.Log_OC;\nimport com.owncloud.android.lib.resources.files.FileUtils;\nimport com.owncloud.android.operations.UploadFileOperation;\nimport com.owncloud.android.ui.activity.ConflictsResolveActivity;\nimport com.owncloud.android.ui.activity.UploadListActivity;\nimport com.owncloud.android.ui.notifications.NotificationUtils;\nimport com.owncloud.android.utils.ErrorMessageAdapter;\nimport com.owncloud.android.utils.theme.ThemeColorUtils;\n\nimport java.io.File;\nimport java.security.SecureRandom;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.annotation.Nullable;\nimport javax.inject.Inject;\n\nimport androidx.annotation.NonNull;\nimport androidx.core.app.NotificationCompat;\nimport androidx.localbroadcastmanager.content.LocalBroadcastManager;\nimport dagger.android.AndroidInjection;\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\n/**\n * Service for uploading files. Invoke using context.startService(...).\n *\n * Files to be uploaded are stored persistently using {@link UploadsStorageManager}.\n *\n * On next invocation of {@link FileUploader} uploaded files which previously failed will be uploaded again until either\n * upload succeeded or a fatal error occurred.\n *\n * Every file passed to this service is uploaded. No filtering is performed. However, Intent keys (e.g., KEY_WIFI_ONLY)\n * are obeyed.\n */\npublic class FileUploader extends Service\n    implements OnDatatransferProgressListener, OnAccountsUpdateListener, UploadFileOperation.OnRenameListener {\n\n    private static final String TAG = FileUploader.class.getSimpleName();\n\n    private static final String UPLOADS_ADDED_MESSAGE = \"UPLOADS_ADDED\";\n    private static final String UPLOAD_START_MESSAGE = \"UPLOAD_START\";\n    private static final String UPLOAD_FINISH_MESSAGE = \"UPLOAD_FINISH\";\n    public static final String EXTRA_UPLOAD_RESULT = \"RESULT\";\n    public static final String EXTRA_REMOTE_PATH = \"REMOTE_PATH\";\n    public static final String EXTRA_OLD_REMOTE_PATH = \"OLD_REMOTE_PATH\";\n    public static final String EXTRA_OLD_FILE_PATH = \"OLD_FILE_PATH\";\n    public static final String EXTRA_LINKED_TO_PATH = \"LINKED_TO\";\n    public static final String ACCOUNT_NAME = \"ACCOUNT_NAME\";\n\n    private static final int FOREGROUND_SERVICE_ID = 411;\n\n    public static final String KEY_FILE = \"FILE\";\n    public static final String KEY_LOCAL_FILE = \"LOCAL_FILE\";\n    public static final String KEY_REMOTE_FILE = \"REMOTE_FILE\";\n    public static final String KEY_MIME_TYPE = \"MIME_TYPE\";\n\n    /**\n     * Call this Service with only this Intent key if all pending uploads are to be retried.\n     */\n    private static final String KEY_RETRY = \"KEY_RETRY\";\n//    /**\n//     * Call this Service with KEY_RETRY and KEY_RETRY_REMOTE_PATH to retry\n//     * upload of file identified by KEY_RETRY_REMOTE_PATH.\n//     */\n//    private static final String KEY_RETRY_REMOTE_PATH = \"KEY_RETRY_REMOTE_PATH\";\n    /**\n     * Call this Service with KEY_RETRY and KEY_RETRY_UPLOAD to retry upload of file identified by KEY_RETRY_UPLOAD.\n     */\n    private static final String KEY_RETRY_UPLOAD = \"KEY_RETRY_UPLOAD\";\n    /**\n     * {@link Account} to which file is to be uploaded.\n     */\n    public static final String KEY_ACCOUNT = \"ACCOUNT\";\n\n    /**\n     * What {@link NameCollisionPolicy} to do when the file already exists on the remote.\n     */\n    public static final String KEY_NAME_COLLISION_POLICY = \"KEY_NAME_COLLISION_POLICY\";\n\n    /**\n     * Set to true if remote folder is to be created if it does not exist.\n     */\n    public static final String KEY_CREATE_REMOTE_FOLDER = \"CREATE_REMOTE_FOLDER\";\n    /**\n     * Key to signal what is the origin of the upload request\n     */\n    public static final String KEY_CREATED_BY = \"CREATED_BY\";\n\n    public static final String KEY_WHILE_ON_WIFI_ONLY = \"KEY_ON_WIFI_ONLY\";\n\n    /**\n     * Set to true if upload is to performed only when phone is being charged.\n     */\n    public static final String KEY_WHILE_CHARGING_ONLY = \"KEY_WHILE_CHARGING_ONLY\";\n\n    public static final String KEY_LOCAL_BEHAVIOUR = \"BEHAVIOUR\";\n\n    /**\n     * Set to true if the HTTP library should disable automatic retries of uploads.\n     */\n    public static final String KEY_DISABLE_RETRIES = \"DISABLE_RETRIES\";\n\n    public static final int LOCAL_BEHAVIOUR_COPY = 0;\n    public static final int LOCAL_BEHAVIOUR_MOVE = 1;\n    public static final int LOCAL_BEHAVIOUR_FORGET = 2;\n    public static final int LOCAL_BEHAVIOUR_DELETE = 3;\n\n\n    private Notification mNotification;\n    private Looper mServiceLooper;\n    private ServiceHandler mServiceHandler;\n    private IBinder mBinder;\n    private OwnCloudClient mUploadClient;\n    private Account mCurrentAccount;\n    private FileDataStorageManager mStorageManager;\n\n    @Inject UserAccountManager accountManager;\n    @Inject UploadsStorageManager mUploadsStorageManager;\n    @Inject ConnectivityService connectivityService;\n    @Inject PowerManagementService powerManagementService;\n    @Inject LocalBroadcastManager localBroadcastManager;\n\n    private IndexedForest<UploadFileOperation> mPendingUploads = new IndexedForest<>();\n\n    /**\n     * {@link UploadFileOperation} object of ongoing upload. Can be null. Note: There can only be one concurrent\n     * upload!\n     */\n    private UploadFileOperation mCurrentUpload;\n\n    private NotificationManager mNotificationManager;\n    private NotificationCompat.Builder mNotificationBuilder;\n    private int mLastPercent;\n\n\n    @Override\n    public void onRenameUpload() {\n        mUploadsStorageManager.updateDatabaseUploadStart(mCurrentUpload);\n        sendBroadcastUploadStarted(mCurrentUpload);\n    }\n\n    /**\n     * Service initialization\n     */\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        AndroidInjection.inject(this);\n        Log_OC.d(TAG, \"Creating service\");\n        mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n        HandlerThread thread = new HandlerThread(\"FileUploaderThread\", Process.THREAD_PRIORITY_BACKGROUND);\n        thread.start();\n        mServiceLooper = thread.getLooper();\n        mServiceHandler = new ServiceHandler(mServiceLooper, this);\n        mBinder = new FileUploaderBinder();\n\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(this).setContentTitle(\n            getApplicationContext().getResources().getString(R.string.app_name))\n            .setContentText(getApplicationContext().getResources().getString(R.string.foreground_service_upload))\n            .setSmallIcon(R.drawable.notification_icon)\n            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.notification_icon))\n            .setColor(ThemeColorUtils.primaryColor(getApplicationContext(), true));\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            builder.setChannelId(NotificationUtils.NOTIFICATION_CHANNEL_UPLOAD);\n        }\n\n        mNotification = builder.build();\n\n        // TODO Add UploadResult.KILLED?\n        int failedCounter = mUploadsStorageManager.failInProgressUploads(UploadResult.SERVICE_INTERRUPTED);\n        if (failedCounter > 0) {\n            resurrection();\n        }\n\n        // add AccountsUpdatedListener\n        AccountManager am = AccountManager.get(getApplicationContext());\n        am.addOnAccountsUpdatedListener(this, null, false);\n    }\n\n    /**\n     * Service clean-up when restarted after being killed\n     */\n    private void resurrection() {\n        // remove stucked notification\n        mNotificationManager.cancel(FOREGROUND_SERVICE_ID);\n    }\n\n    /**\n     * Service clean up\n     */\n    @SuppressWarnings(\"PMD.NullAssignment\")\n    @Override\n    public void onDestroy() {\n        Log_OC.v(TAG, \"Destroying service\");\n        mBinder = null;\n        mServiceHandler = null;\n        mServiceLooper.quit();\n        mServiceLooper = null;\n        if (mNotificationManager != null) {\n            mNotificationManager.cancel(FOREGROUND_SERVICE_ID);\n        }\n        mNotificationManager = null;\n\n        // remove AccountsUpdatedListener\n        AccountManager am = AccountManager.get(getApplicationContext());\n        am.removeOnAccountsUpdatedListener(this);\n\n        super.onDestroy();\n    }\n\n    /**\n     * Entry point to add one or several files to the queue of uploads.\n     *\n     * New uploads are added calling to startService(), resulting in a call to this method. This ensures the service\n     * will keep on working although the caller activity goes away.\n     */\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        Log_OC.d(TAG, \"Starting command with id \" + startId);\n\n        startForeground(FOREGROUND_SERVICE_ID, mNotification);\n\n        if (intent == null) {\n            Log_OC.e(TAG, \"Intent is null\");\n            return Service.START_NOT_STICKY;\n        }\n\n        if (!intent.hasExtra(KEY_ACCOUNT)) {\n            Log_OC.e(TAG, \"Not enough information provided in intent\");\n            return Service.START_NOT_STICKY;\n        }\n\n        final Account account = intent.getParcelableExtra(KEY_ACCOUNT);\n        if (account == null) {\n            return Service.START_NOT_STICKY;\n        }\n        Optional<User> optionalUser = accountManager.getUser(account.name);\n        if (!optionalUser.isPresent()) {\n            return Service.START_NOT_STICKY;\n        }\n        final User user = optionalUser.get();\n\n        boolean retry = intent.getBooleanExtra(KEY_RETRY, false);\n        List<String> requestedUploads = new ArrayList<>();\n\n        boolean onWifiOnly = intent.getBooleanExtra(KEY_WHILE_ON_WIFI_ONLY, false);\n        boolean whileChargingOnly = intent.getBooleanExtra(KEY_WHILE_CHARGING_ONLY, false);\n\n        if (!retry) { // Start new uploads\n            if (!(intent.hasExtra(KEY_LOCAL_FILE) || intent.hasExtra(KEY_FILE))) {\n                Log_OC.e(TAG, \"Not enough information provided in intent\");\n                return Service.START_NOT_STICKY;\n            }\n\n            Integer error = gatherAndStartNewUploads(intent, user, requestedUploads, onWifiOnly, whileChargingOnly);\n            if (error != null) {\n                return error;\n            }\n        } else { // Retry uploads\n            if (!intent.hasExtra(KEY_ACCOUNT) || !intent.hasExtra(KEY_RETRY_UPLOAD)) {\n                Log_OC.e(TAG, \"Not enough information provided in intent: no KEY_RETRY_UPLOAD_KEY\");\n                return START_NOT_STICKY;\n            }\n            retryUploads(intent, user, requestedUploads);\n        }\n\n        if (requestedUploads.size() > 0) {\n            Message msg = mServiceHandler.obtainMessage();\n            msg.arg1 = startId;\n            msg.obj = requestedUploads;\n            mServiceHandler.sendMessage(msg);\n            sendBroadcastUploadsAdded();\n        }\n        return Service.START_NOT_STICKY;\n    }\n\n    /**\n     * Gather and start new uploads.\n     *\n     * @return A {@link Service} constant in case of error, {@code null} otherwise.\n     */\n    @Nullable\n    private Integer gatherAndStartNewUploads(\n        Intent intent,\n        User user,\n        List<String> requestedUploads,\n        boolean onWifiOnly,\n        boolean whileChargingOnly\n    ) {\n        String[] localPaths = null;\n        String[] remotePaths = null;\n        String[] mimeTypes = null;\n        OCFile[] files = null;\n\n        if (intent.hasExtra(KEY_FILE)) {\n            Parcelable[] files_temp = intent.getParcelableArrayExtra(KEY_FILE);\n            files = new OCFile[files_temp.length];\n            System.arraycopy(files_temp, 0, files, 0, files_temp.length);\n        } else {\n            localPaths = intent.getStringArrayExtra(KEY_LOCAL_FILE);\n            remotePaths = intent.getStringArrayExtra(KEY_REMOTE_FILE);\n            mimeTypes = intent.getStringArrayExtra(KEY_MIME_TYPE);\n        }\n\n        if (intent.hasExtra(KEY_FILE) && files == null) {\n            Log_OC.e(TAG, \"Incorrect array for OCFiles provided in upload intent\");\n            return Service.START_NOT_STICKY;\n        } else if (!intent.hasExtra(KEY_FILE)) {\n            if (localPaths == null) {\n                Log_OC.e(TAG, \"Incorrect array for local paths provided in upload intent\");\n                return Service.START_NOT_STICKY;\n            }\n            if (remotePaths == null) {\n                Log_OC.e(TAG, \"Incorrect array for remote paths provided in upload intent\");\n                return Service.START_NOT_STICKY;\n            }\n            if (localPaths.length != remotePaths.length) {\n                Log_OC.e(TAG, \"Different number of remote paths and local paths!\");\n                return Service.START_NOT_STICKY;\n            }\n\n            files = new OCFile[localPaths.length];\n            for (int i = 0; i < localPaths.length; i++) {\n                files[i] = UploadFileOperation.obtainNewOCFileToUpload(\n                    remotePaths[i],\n                    localPaths[i],\n                    mimeTypes != null ? mimeTypes[i] : null\n                );\n                if (files[i] == null) {\n                    Log_OC.e(TAG, \"obtainNewOCFileToUpload() returned null for remotePaths[i]:\" + remotePaths[i]\n                        + \" and localPaths[i]:\" + localPaths[i]);\n                    return Service.START_NOT_STICKY;\n                }\n            }\n        }\n        // at this point variable \"OCFile[] files\" is loaded correctly.\n\n        NameCollisionPolicy nameCollisionPolicy = (NameCollisionPolicy) intent.getSerializableExtra(KEY_NAME_COLLISION_POLICY);\n        if (nameCollisionPolicy == null) {\n            nameCollisionPolicy = NameCollisionPolicy.DEFAULT;\n        }\n        int localAction = intent.getIntExtra(KEY_LOCAL_BEHAVIOUR, LOCAL_BEHAVIOUR_FORGET);\n        boolean isCreateRemoteFolder = intent.getBooleanExtra(KEY_CREATE_REMOTE_FOLDER, false);\n        int createdBy = intent.getIntExtra(KEY_CREATED_BY, UploadFileOperation.CREATED_BY_USER);\n        boolean disableRetries = intent.getBooleanExtra(KEY_DISABLE_RETRIES, true);\n        try {\n            for (OCFile file : files) {\n                startNewUpload(\n                    user,\n                    requestedUploads,\n                    onWifiOnly,\n                    whileChargingOnly,\n                    nameCollisionPolicy,\n                    localAction,\n                    isCreateRemoteFolder,\n                    createdBy,\n                    file,\n                    disableRetries\n                              );\n            }\n        } catch (IllegalArgumentException e) {\n            Log_OC.e(TAG, \"Not enough information provided in intent: \" + e.getMessage());\n            return START_NOT_STICKY;\n        } catch (IllegalStateException e) {\n            Log_OC.e(TAG, \"Bad information provided in intent: \" + e.getMessage());\n            return START_NOT_STICKY;\n        } catch (Exception e) {\n            Log_OC.e(TAG, \"Unexpected exception while processing upload intent\", e);\n            return START_NOT_STICKY;\n        }\n        return null;\n    }\n\n    /**\n     * Start a new {@link UploadFileOperation}.\n     */\n    @SuppressLint(\"SdCardPath\")\n    private void startNewUpload(\n        User user,\n        List<String> requestedUploads,\n        boolean onWifiOnly,\n        boolean whileChargingOnly,\n        NameCollisionPolicy nameCollisionPolicy,\n        int localAction,\n        boolean isCreateRemoteFolder,\n        int createdBy,\n        OCFile file,\n        boolean disableRetries\n                               ) {\n        if (file.getStoragePath().startsWith(\"/data/data/\")) {\n            Log_OC.d(TAG, \"Upload from sensitive path is not allowed\");\n            return;\n        }\n\n        OCUpload ocUpload = new OCUpload(file, user.toPlatformAccount());\n        ocUpload.setFileSize(file.getFileLength());\n        ocUpload.setNameCollisionPolicy(nameCollisionPolicy);\n        ocUpload.setCreateRemoteFolder(isCreateRemoteFolder);\n        ocUpload.setCreatedBy(createdBy);\n        ocUpload.setLocalAction(localAction);\n        ocUpload.setUseWifiOnly(onWifiOnly);\n        ocUpload.setWhileChargingOnly(whileChargingOnly);\n        ocUpload.setUploadStatus(UploadStatus.UPLOAD_IN_PROGRESS);\n\n        UploadFileOperation newUpload = new UploadFileOperation(\n            mUploadsStorageManager,\n            connectivityService,\n            powerManagementService,\n            user,\n            file,\n            ocUpload,\n            nameCollisionPolicy,\n            localAction,\n            this,\n            onWifiOnly,\n            whileChargingOnly,\n            disableRetries\n        );\n        newUpload.setCreatedBy(createdBy);\n        if (isCreateRemoteFolder) {\n            newUpload.setRemoteFolderToBeCreated();\n        }\n        newUpload.addDataTransferProgressListener(this);\n        newUpload.addDataTransferProgressListener((FileUploaderBinder) mBinder);\n\n        newUpload.addRenameUploadListener(this);\n\n        Pair<String, String> putResult = mPendingUploads.putIfAbsent(\n            user.getAccountName(),\n            file.getRemotePath(),\n            newUpload\n        );\n\n        if (putResult != null) {\n            requestedUploads.add(putResult.first);\n\n            // Save upload in database\n            long id = mUploadsStorageManager.storeUpload(ocUpload);\n            newUpload.setOCUploadId(id);\n        }\n    }\n\n    /**\n     * Retries a list of uploads.\n     */\n    private void retryUploads(Intent intent, User user, List<String> requestedUploads) {\n        boolean onWifiOnly;\n        boolean whileChargingOnly;\n        OCUpload upload = intent.getParcelableExtra(KEY_RETRY_UPLOAD);\n\n        onWifiOnly = upload.isUseWifiOnly();\n        whileChargingOnly = upload.isWhileChargingOnly();\n\n        UploadFileOperation newUpload = new UploadFileOperation(\n            mUploadsStorageManager,\n            connectivityService,\n            powerManagementService,\n            user,\n            null,\n            upload,\n            upload.getNameCollisionPolicy(),\n            upload.getLocalAction(),\n            this,\n            onWifiOnly,\n            whileChargingOnly,\n            true\n        );\n\n        newUpload.addDataTransferProgressListener(this);\n        newUpload.addDataTransferProgressListener((FileUploaderBinder) mBinder);\n\n        newUpload.addRenameUploadListener(this);\n\n        Pair<String, String> putResult = mPendingUploads.putIfAbsent(\n            user.getAccountName(),\n            upload.getRemotePath(),\n            newUpload\n        );\n        if (putResult != null) {\n            String uploadKey = putResult.first;\n            requestedUploads.add(uploadKey);\n\n            // Update upload in database\n            upload.setUploadStatus(UploadStatus.UPLOAD_IN_PROGRESS);\n            mUploadsStorageManager.updateUpload(upload);\n        }\n    }\n\n    /**\n     * Provides a binder object that clients can use to perform operations on the queue of uploads, excepting the\n     * addition of new files.\n     *\n     * Implemented to perform cancellation, pause and resume of existing uploads.\n     */\n    @Override\n    public IBinder onBind(Intent intent) {\n        return mBinder;\n    }\n\n    /**\n     * Called when ALL the bound clients were onbound.\n     */\n    @Override\n    public boolean onUnbind(Intent intent) {\n        ((FileUploaderBinder) mBinder).clearListeners();\n        return false;   // not accepting rebinding (default behaviour)\n    }\n\n    @Override\n    public void onAccountsUpdated(Account[] accounts) {\n        // Review current upload, and cancel it if its account doesn't exist\n        if (mCurrentUpload != null && !accountManager.exists(mCurrentUpload.getAccount())) {\n            mCurrentUpload.cancel(ResultCode.ACCOUNT_NOT_FOUND);\n        }\n        // The rest of uploads are cancelled when they try to start\n    }\n\n    /**\n     * Core upload method: sends the file(s) to upload\n     *\n     * @param uploadKey Key to access the upload to perform, contained in mPendingUploads\n     */\n    public void uploadFile(String uploadKey) {\n        mCurrentUpload = mPendingUploads.get(uploadKey);\n\n        if (mCurrentUpload != null) {\n            /// Check account existence\n            if (!accountManager.exists(mCurrentUpload.getAccount())) {\n                Log_OC.w(TAG, \"Account \" + mCurrentUpload.getAccount().name +\n                    \" does not exist anymore -> cancelling all its uploads\");\n                cancelUploadsForAccount(mCurrentUpload.getAccount());\n                return;\n            }\n\n            /// OK, let's upload\n            mUploadsStorageManager.updateDatabaseUploadStart(mCurrentUpload);\n\n            notifyUploadStart(mCurrentUpload);\n\n            sendBroadcastUploadStarted(mCurrentUpload);\n\n            RemoteOperationResult uploadResult = null;\n\n            try {\n                /// prepare client object to send the request to the ownCloud server\n                if (mCurrentAccount == null || !mCurrentAccount.equals(mCurrentUpload.getAccount())) {\n                    mCurrentAccount = mCurrentUpload.getAccount();\n                    mStorageManager = new FileDataStorageManager(mCurrentAccount, getContentResolver());\n                }   // else, reuse storage manager from previous operation\n\n                // always get client from client manager, to get fresh credentials in case of update\n                OwnCloudAccount ocAccount = new OwnCloudAccount(mCurrentAccount, this);\n                mUploadClient = OwnCloudClientManagerFactory.getDefaultSingleton().getClientFor(ocAccount, this);\n\n\n//                // If parent folder is encrypted, upload file encrypted\n//                OCFile parent = mStorageManager.getFileByPath(mCurrentUpload.getFile().getParentRemotePath());\n\n//                if (parent.isEncrypted()) {\n//                    UploadEncryptedFileOperation uploadEncryptedFileOperation =\n//                            new UploadEncryptedFileOperation(parent, mCurrentUpload);\n//\n//                    uploadResult = uploadEncryptedFileOperation.execute(mUploadClient, mStorageManager);\n//                } else {\n                /// perform the regular upload\n                uploadResult = mCurrentUpload.execute(mUploadClient, mStorageManager);\n//                }\n            } catch (Exception e) {\n                Log_OC.e(TAG, \"Error uploading\", e);\n                uploadResult = new RemoteOperationResult(e);\n            } finally {\n                Pair<UploadFileOperation, String> removeResult;\n                if (mCurrentUpload.wasRenamed()) {\n                    removeResult = mPendingUploads.removePayload(\n                        mCurrentAccount.name,\n                        mCurrentUpload.getOldFile().getRemotePath()\n                    );\n                    // TODO: grant that name is also updated for mCurrentUpload.getOCUploadId\n\n                } else {\n                    removeResult = mPendingUploads.removePayload(mCurrentAccount.name,\n                                                                 mCurrentUpload.getDecryptedRemotePath());\n                }\n\n                mUploadsStorageManager.updateDatabaseUploadResult(uploadResult, mCurrentUpload);\n\n                /// notify result\n                notifyUploadResult(mCurrentUpload, uploadResult);\n\n                sendBroadcastUploadFinished(mCurrentUpload, uploadResult, removeResult.second);\n            }\n\n            // generate new Thumbnail\n            final ThumbnailsCacheManager.ThumbnailGenerationTask task =\n                new ThumbnailsCacheManager.ThumbnailGenerationTask(mStorageManager, mCurrentAccount);\n\n            File file = new File(mCurrentUpload.getOriginalStoragePath());\n            String remoteId = mCurrentUpload.getFile().getRemoteId();\n\n            task.execute(new ThumbnailsCacheManager.ThumbnailGenerationTaskObject(file, remoteId));\n        }\n    }\n\n\n    /**\n     * Creates a status notification to show the upload progress\n     *\n     * @param upload Upload operation starting.\n     */\n    private void notifyUploadStart(UploadFileOperation upload) {\n        // / create status notification with a progress bar\n        mLastPercent = 0;\n        mNotificationBuilder = NotificationUtils.newNotificationBuilder(this);\n        mNotificationBuilder\n            .setOngoing(true)\n            .setSmallIcon(R.drawable.notification_icon)\n            .setTicker(getString(R.string.uploader_upload_in_progress_ticker))\n            .setContentTitle(getString(R.string.uploader_upload_in_progress_ticker))\n            .setProgress(100, 0, false)\n            .setContentText(\n                String.format(getString(R.string.uploader_upload_in_progress_content), 0, upload.getFileName())\n            );\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            mNotificationBuilder.setChannelId(NotificationUtils.NOTIFICATION_CHANNEL_UPLOAD);\n        }\n\n        /// includes a pending intent in the notification showing the details\n        Intent intent = UploadListActivity.createIntent(upload.getFile(),\n                                                        upload.getAccount(),\n                                                        Intent.FLAG_ACTIVITY_CLEAR_TOP,\n                                                        this);\n        mNotificationBuilder.setContentIntent(PendingIntent.getActivity(this,\n                                                                        (int) System.currentTimeMillis(),\n                                                                        intent,\n                                                                        0)\n                                             );\n\n        if (!upload.isInstantPicture() && !upload.isInstantVideo()) {\n            if (mNotificationManager == null) {\n                mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n            }\n\n            mNotificationManager.notify(FOREGROUND_SERVICE_ID, mNotificationBuilder.build());\n        }   // else wait until the upload really start (onTransferProgress is called), so that if it's discarded\n        // due to lack of Wifi, no notification is shown\n        // TODO generalize for automated uploads\n    }\n\n    /**\n     * Callback method to update the progress bar in the status notification\n     */\n    @Override\n    public void onTransferProgress(\n        long progressRate,\n        long totalTransferredSoFar,\n        long totalToTransfer,\n        String filePath\n    ) {\n        int percent = (int) (100.0 * ((double) totalTransferredSoFar) / ((double) totalToTransfer));\n        if (percent != mLastPercent) {\n            mNotificationBuilder.setProgress(100, percent, false);\n            String fileName = filePath.substring(filePath.lastIndexOf(FileUtils.PATH_SEPARATOR) + 1);\n            String text = String.format(getString(R.string.uploader_upload_in_progress_content), percent, fileName);\n            mNotificationBuilder.setContentText(text);\n            if (mNotificationManager == null) {\n                mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n            }\n            mNotificationManager.notify(FOREGROUND_SERVICE_ID, mNotificationBuilder.build());\n        }\n        mLastPercent = percent;\n    }\n\n    /**\n     * Updates the status notification with the result of an upload operation.\n     *\n     * @param uploadResult Result of the upload operation.\n     * @param upload       Finished upload operation\n     */\n    @SuppressFBWarnings(\"DMI\")\n    private void notifyUploadResult(UploadFileOperation upload, RemoteOperationResult uploadResult) {\n        Log_OC.d(TAG, \"NotifyUploadResult with resultCode: \" + uploadResult.getCode());\n        // cancelled operation or success -> silent removal of progress notification\n        if (mNotificationManager == null) {\n            mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n        }\n\n        // Only notify if the upload fails\n        if (!uploadResult.isCancelled() &&\n            !uploadResult.isSuccess() &&\n            !ResultCode.LOCAL_FILE_NOT_FOUND.equals(uploadResult.getCode()) &&\n            !uploadResult.getCode().equals(ResultCode.DELAYED_FOR_WIFI) &&\n            !uploadResult.getCode().equals(ResultCode.DELAYED_FOR_CHARGING) &&\n            !uploadResult.getCode().equals(ResultCode.DELAYED_IN_POWER_SAVE_MODE) &&\n            !uploadResult.getCode().equals(ResultCode.LOCK_FAILED)) {\n\n            int tickerId = R.string.uploader_upload_failed_ticker;\n\n            String content;\n\n            // check credentials error\n            boolean needsToUpdateCredentials = uploadResult.getCode() == ResultCode.UNAUTHORIZED;\n            if (needsToUpdateCredentials) {\n                tickerId = R.string.uploader_upload_failed_credentials_error;\n            } else if (uploadResult.getCode() == ResultCode.SYNC_CONFLICT) { // check file conflict\n                tickerId = R.string.uploader_upload_failed_sync_conflict_error;\n            }\n\n            mNotificationBuilder\n                .setTicker(getString(tickerId))\n                .setContentTitle(getString(tickerId))\n                .setAutoCancel(true)\n                .setOngoing(false)\n                .setProgress(0, 0, false);\n\n            content = ErrorMessageAdapter.getErrorCauseMessage(uploadResult, upload, getResources());\n\n            if (needsToUpdateCredentials) {\n                // let the user update credentials with one click\n                Intent updateAccountCredentials = new Intent(this, AuthenticatorActivity.class);\n                updateAccountCredentials.putExtra(\n                    AuthenticatorActivity.EXTRA_ACCOUNT, upload.getAccount()\n                );\n                updateAccountCredentials.putExtra(\n                    AuthenticatorActivity.EXTRA_ACTION,\n                    AuthenticatorActivity.ACTION_UPDATE_EXPIRED_TOKEN\n                );\n\n                updateAccountCredentials.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                updateAccountCredentials.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                updateAccountCredentials.addFlags(Intent.FLAG_FROM_BACKGROUND);\n                mNotificationBuilder.setContentIntent(PendingIntent.getActivity(\n                    this,\n                    (int) System.currentTimeMillis(),\n                    updateAccountCredentials,\n                    PendingIntent.FLAG_ONE_SHOT\n                ));\n            } else {\n                Intent intent;\n                if (uploadResult.getCode().equals(ResultCode.SYNC_CONFLICT)) {\n                    intent = ConflictsResolveActivity.createIntent(upload.getFile(),\n                                                                   upload.getAccount(),\n                                                                   upload.getOCUploadId(),\n                                                                   Intent.FLAG_ACTIVITY_CLEAR_TOP,\n                                                                   this);\n                } else {\n                    intent = UploadListActivity.createIntent(upload.getFile(),\n                                                             upload.getAccount(),\n                                                             Intent.FLAG_ACTIVITY_CLEAR_TOP,\n                                                             this);\n                }\n\n                mNotificationBuilder.setContentIntent(PendingIntent.getActivity(this,\n                                                                                (int) System.currentTimeMillis(),\n                                                                                intent,\n                                                                                0)\n                                                     );\n            }\n\n            mNotificationBuilder.setContentText(content);\n            if (!uploadResult.isSuccess()) {\n                mNotificationManager.notify((new SecureRandom()).nextInt(), mNotificationBuilder.build());\n            }\n\n        }\n    }\n\n    /**\n     * Sends a broadcast in order to the interested activities can update their view\n     *\n     * TODO - no more broadcasts, replace with a callback to subscribed listeners\n     */\n    private void sendBroadcastUploadsAdded() {\n        Intent start = new Intent(getUploadsAddedMessage());\n        // nothing else needed right now\n        start.setPackage(getPackageName());\n        localBroadcastManager.sendBroadcast(start);\n    }\n\n    /**\n     * Sends a broadcast in order to the interested activities can update their view\n     *\n     * TODO - no more broadcasts, replace with a callback to subscribed listeners\n     *\n     * @param upload Finished upload operation\n     */\n    private void sendBroadcastUploadStarted(UploadFileOperation upload) {\n        Intent start = new Intent(getUploadStartMessage());\n        start.putExtra(EXTRA_REMOTE_PATH, upload.getRemotePath()); // real remote\n        start.putExtra(EXTRA_OLD_FILE_PATH, upload.getOriginalStoragePath());\n        start.putExtra(ACCOUNT_NAME, upload.getAccount().name);\n\n        start.setPackage(getPackageName());\n        localBroadcastManager.sendBroadcast(start);\n    }\n\n    /**\n     * Sends a broadcast in order to the interested activities can update their view\n     *\n     * TODO - no more broadcasts, replace with a callback to subscribed listeners\n     *\n     * @param upload                 Finished upload operation\n     * @param uploadResult           Result of the upload operation\n     * @param unlinkedFromRemotePath Path in the uploads tree where the upload was unlinked from\n     */\n    private void sendBroadcastUploadFinished(\n        UploadFileOperation upload,\n        RemoteOperationResult uploadResult,\n        String unlinkedFromRemotePath\n    ) {\n        Intent end = new Intent(getUploadFinishMessage());\n        end.putExtra(EXTRA_REMOTE_PATH, upload.getRemotePath()); // real remote\n        // path, after\n        // possible\n        // automatic\n        // renaming\n        if (upload.wasRenamed()) {\n            end.putExtra(EXTRA_OLD_REMOTE_PATH, upload.getOldFile().getRemotePath());\n        }\n        end.putExtra(EXTRA_OLD_FILE_PATH, upload.getOriginalStoragePath());\n        end.putExtra(ACCOUNT_NAME, upload.getAccount().name);\n        end.putExtra(EXTRA_UPLOAD_RESULT, uploadResult.isSuccess());\n        if (unlinkedFromRemotePath != null) {\n            end.putExtra(EXTRA_LINKED_TO_PATH, unlinkedFromRemotePath);\n        }\n        end.setPackage(getPackageName());\n        localBroadcastManager.sendBroadcast(end);\n    }\n\n    /**\n     * Remove and 'forgets' pending uploads of an account.\n     *\n     * @param account Account which uploads will be cancelled\n     */\n    private void cancelUploadsForAccount(Account account) {\n        mPendingUploads.remove(account.name);\n        mUploadsStorageManager.removeUploads(account.name);\n    }\n\n\n    /**\n     * Upload a new file\n     */\n    public static void uploadNewFile(\n        Context context,\n        Account account,\n        String localPath,\n        String remotePath,\n        int behaviour,\n        String mimeType,\n        boolean createRemoteFile,\n        int createdBy,\n        boolean requiresWifi,\n        boolean requiresCharging,\n        NameCollisionPolicy nameCollisionPolicy\n    ) {\n        uploadNewFile(\n            context,\n            account,\n            new String[]{localPath},\n            new String[]{remotePath},\n            new String[]{mimeType},\n            behaviour,\n            createRemoteFile,\n            createdBy,\n            requiresWifi,\n            requiresCharging,\n            nameCollisionPolicy\n        );\n    }\n\n    /**\n     * Upload multiple new files\n     */\n    public static void uploadNewFile(\n        Context context,\n        Account account,\n        String[] localPaths,\n        String[] remotePaths,\n        String[] mimeTypes,\n        Integer behaviour,\n        Boolean createRemoteFolder,\n        int createdBy,\n        boolean requiresWifi,\n        boolean requiresCharging,\n        NameCollisionPolicy nameCollisionPolicy\n    ) {\n        Intent intent = new Intent(context, FileUploader.class);\n\n        intent.putExtra(FileUploader.KEY_ACCOUNT, account);\n        intent.putExtra(FileUploader.KEY_LOCAL_FILE, localPaths);\n        intent.putExtra(FileUploader.KEY_REMOTE_FILE, remotePaths);\n        intent.putExtra(FileUploader.KEY_MIME_TYPE, mimeTypes);\n        intent.putExtra(FileUploader.KEY_LOCAL_BEHAVIOUR, behaviour);\n        intent.putExtra(FileUploader.KEY_CREATE_REMOTE_FOLDER, createRemoteFolder);\n        intent.putExtra(FileUploader.KEY_CREATED_BY, createdBy);\n        intent.putExtra(FileUploader.KEY_WHILE_ON_WIFI_ONLY, requiresWifi);\n        intent.putExtra(FileUploader.KEY_WHILE_CHARGING_ONLY, requiresCharging);\n        intent.putExtra(FileUploader.KEY_NAME_COLLISION_POLICY, nameCollisionPolicy);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            context.startForegroundService(intent);\n        } else {\n            context.startService(intent);\n        }\n    }\n\n    /**\n     * Upload and overwrite an already uploaded file with disabled retries\n     */\n    public static void uploadUpdateFile(\n        Context context,\n        Account account,\n        OCFile existingFile,\n        Integer behaviour,\n        NameCollisionPolicy nameCollisionPolicy\n                                       ) {\n        uploadUpdateFile(context, account, new OCFile[]{existingFile}, behaviour, nameCollisionPolicy, true);\n    }\n\n    /**\n     * Upload and overwrite an already uploaded file\n     */\n    public static void uploadUpdateFile(\n        Context context,\n        Account account,\n        OCFile existingFile,\n        Integer behaviour,\n        NameCollisionPolicy nameCollisionPolicy,\n        boolean disableRetries\n                                       ) {\n        uploadUpdateFile(context, account, new OCFile[]{existingFile}, behaviour, nameCollisionPolicy, disableRetries);\n    }\n\n    /**\n     * Upload and overwrite already uploaded files\n     */\n    public static void uploadUpdateFile(\n        Context context,\n        Account account,\n        OCFile[] existingFiles,\n        Integer behaviour,\n        NameCollisionPolicy nameCollisionPolicy,\n        boolean disableRetries\n                                       ) {\n        Intent intent = new Intent(context, FileUploader.class);\n\n        intent.putExtra(FileUploader.KEY_ACCOUNT, account);\n        intent.putExtra(FileUploader.KEY_FILE, existingFiles);\n        intent.putExtra(FileUploader.KEY_LOCAL_BEHAVIOUR, behaviour);\n        intent.putExtra(FileUploader.KEY_NAME_COLLISION_POLICY, nameCollisionPolicy);\n        intent.putExtra(FileUploader.KEY_DISABLE_RETRIES, disableRetries);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            context.startForegroundService(intent);\n        } else {\n            context.startService(intent);\n        }\n    }\n\n    /**\n     * Retry a failed {@link OCUpload} identified by {@link OCUpload#getRemotePath()}\n     */\n    public static void retryUpload(@NonNull Context context, @NonNull Account account, @NonNull OCUpload upload) {\n        Intent i = new Intent(context, FileUploader.class);\n        i.putExtra(FileUploader.KEY_RETRY, true);\n        i.putExtra(FileUploader.KEY_ACCOUNT, account);\n        i.putExtra(FileUploader.KEY_RETRY_UPLOAD, upload);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            context.startForegroundService(i);\n        } else {\n            context.startService(i);\n        }\n    }\n\n    /**\n     * Retry a subset of all the stored failed uploads.\n     *\n     * @param context      Caller {@link Context}\n     * @param account      If not null, only failed uploads to this OC account will be retried; otherwise, uploads of\n     *                     all accounts will be retried.\n     * @param uploadResult If not null, only failed uploads with the result specified will be retried; otherwise, failed\n     *                     uploads due to any result will be retried.\n     */\n    public static void retryFailedUploads(\n        @NonNull final Context context,\n        @Nullable final Account account,\n        @NonNull final UploadsStorageManager uploadsStorageManager,\n        @NonNull final ConnectivityService connectivityService,\n        @NonNull final UserAccountManager accountManager,\n        @NonNull final PowerManagementService powerManagementService,\n        @Nullable final UploadResult uploadResult\n    ) {\n        OCUpload[] failedUploads = uploadsStorageManager.getFailedUploads();\n        if(failedUploads.length == 0)\n        {\n            //nothing to do\n            return;\n        }\n\n        Account currentAccount = null;\n        boolean resultMatch;\n        boolean accountMatch;\n\n        final Connectivity connectivity = connectivityService.getConnectivity();\n        final boolean gotNetwork = connectivity.isConnected() && !connectivityService.isInternetWalled();\n        final boolean gotWifi = connectivity.isWifi();\n        final BatteryStatus batteryStatus = powerManagementService.getBattery();\n        final boolean charging = batteryStatus.isCharging() || batteryStatus.isFull();\n        final boolean isPowerSaving = powerManagementService.isPowerSavingEnabled();\n\n        for (OCUpload failedUpload : failedUploads) {\n            accountMatch = account == null || account.name.equals(failedUpload.getAccountName());\n            resultMatch = uploadResult == null || uploadResult == failedUpload.getLastResult();\n            if (accountMatch && resultMatch) {\n                if (currentAccount == null || !currentAccount.name.equals(failedUpload.getAccountName())) {\n                    currentAccount = failedUpload.getAccount(accountManager);\n                }\n\n                if (!new File(failedUpload.getLocalPath()).exists()) {\n                    if (failedUpload.getLastResult() != UploadResult.FILE_NOT_FOUND) {\n                        failedUpload.setLastResult(UploadResult.FILE_NOT_FOUND);\n                        uploadsStorageManager.updateUpload(failedUpload);\n                    }\n                } else {\n\n                    if (!isPowerSaving && gotNetwork && canUploadBeRetried(failedUpload, gotWifi, charging)) {\n                        retryUpload(context, currentAccount, failedUpload);\n                    }\n                }\n            }\n        }\n    }\n\n    private static boolean canUploadBeRetried(OCUpload upload, boolean gotWifi, boolean isCharging) {\n        File file = new File(upload.getLocalPath());\n        boolean needsWifi = upload.isUseWifiOnly();\n        boolean needsCharging = upload.isWhileChargingOnly();\n\n        return file.exists() && (!needsWifi || gotWifi) && (!needsCharging || isCharging);\n    }\n\n    public static String getUploadsAddedMessage() {\n        return FileUploader.class.getName() + UPLOADS_ADDED_MESSAGE;\n    }\n\n    public static String getUploadStartMessage() {\n        return FileUploader.class.getName() + UPLOAD_START_MESSAGE;\n    }\n\n    public static String getUploadFinishMessage() {\n        return FileUploader.class.getName() + UPLOAD_FINISH_MESSAGE;\n    }\n\n\n    /**\n     * Ordinal of enumerated constants is important for old data compatibility.\n     */\n    public enum NameCollisionPolicy {\n        RENAME, // Ordinal corresponds to old forceOverwrite = false (0 in database)\n        OVERWRITE, // Ordinal corresponds to old forceOverwrite = true (1 in database)\n        CANCEL,\n        ASK_USER;\n\n        public static final NameCollisionPolicy DEFAULT = RENAME;\n\n        public static NameCollisionPolicy deserialize(int ordinal) {\n            NameCollisionPolicy[] values = NameCollisionPolicy.values();\n            return ordinal >= 0 && ordinal < values.length ? values[ordinal] : DEFAULT;\n        }\n\n        public int serialize() {\n            return this.ordinal();\n        }\n    }\n\n    /**\n     * Binder to let client components to perform operations on the queue of uploads.\n     *\n     * It provides by itself the available operations.\n     */\n    public class FileUploaderBinder extends Binder implements OnDatatransferProgressListener {\n\n        /**\n         * Map of listeners that will be reported about progress of uploads from a {@link FileUploaderBinder} instance\n         */\n        private Map<String, OnDatatransferProgressListener> mBoundListeners = new HashMap<>();\n\n        /**\n         * Cancels a pending or current upload of a remote file.\n         *\n         * @param account ownCloud account where the remote file will be stored.\n         * @param file    A file in the queue of pending uploads\n         */\n        public void cancel(Account account, OCFile file) {\n            cancel(account.name, file.getRemotePath(), null);\n        }\n\n        /**\n         * Cancels a pending or current upload that was persisted.\n         *\n         * @param storedUpload Upload operation persisted\n         */\n        public void cancel(OCUpload storedUpload) {\n            cancel(storedUpload.getAccountName(), storedUpload.getRemotePath(), null);\n        }\n\n        /**\n         * Cancels a pending or current upload of a remote file.\n         *\n         * @param accountName Local name of an ownCloud account where the remote file will be stored.\n         * @param remotePath  Remote target of the upload\n         * @param resultCode  Setting result code will pause rather than cancel the job\n         */\n        private void cancel(String accountName, String remotePath, @Nullable ResultCode resultCode) {\n            Pair<UploadFileOperation, String> removeResult = mPendingUploads.remove(accountName, remotePath);\n            UploadFileOperation upload = removeResult.first;\n            if (upload == null && mCurrentUpload != null && mCurrentAccount != null &&\n                mCurrentUpload.getRemotePath().startsWith(remotePath) && accountName.equals(mCurrentAccount.name)) {\n\n                upload = mCurrentUpload;\n            }\n\n            if (upload != null) {\n                upload.cancel(resultCode);\n                // need to update now table in mUploadsStorageManager,\n                // since the operation will not get to be run by FileUploader#uploadFile\n                if (resultCode != null) {\n                    mUploadsStorageManager.updateDatabaseUploadResult(new RemoteOperationResult(resultCode), upload);\n                    notifyUploadResult(upload, new RemoteOperationResult(resultCode));\n                } else {\n                    mUploadsStorageManager.removeUpload(accountName, remotePath);\n                }\n            }\n        }\n\n        /**\n         * Cancels all the uploads for an account.\n         *\n         * @param account ownCloud account.\n         */\n        public void cancel(Account account) {\n            Log_OC.d(TAG, \"Account= \" + account.name);\n\n            if (mCurrentUpload != null) {\n                Log_OC.d(TAG, \"Current Upload Account= \" + mCurrentUpload.getAccount().name);\n                if (mCurrentUpload.getAccount().name.equals(account.name)) {\n                    mCurrentUpload.cancel(ResultCode.CANCELLED);\n                }\n            }\n\n            // Cancel pending uploads\n            cancelUploadsForAccount(account);\n        }\n\n        public void clearListeners() {\n            mBoundListeners.clear();\n        }\n\n        /**\n         * Returns True when the file described by 'file' is being uploaded to the ownCloud account 'account' or waiting\n         * for it\n         *\n         * If 'file' is a directory, returns 'true' if some of its descendant files is uploading or waiting to upload.\n         *\n         * Warning: If remote file exists and target was renamed the original file is being returned here. That is, it\n         * seems as if the original file is being updated when actually a new file is being uploaded.\n         *\n         * @param user    user where the remote file will be stored.\n         * @param file    A file that could be in the queue of pending uploads\n         */\n        public boolean isUploading(User user, OCFile file) {\n            if (user == null || file == null) {\n                return false;\n            }\n\n            return mPendingUploads.contains(user.getAccountName(), file.getRemotePath());\n        }\n\n        public boolean isUploadingNow(OCUpload upload) {\n            return upload != null &&\n                mCurrentAccount != null &&\n                mCurrentUpload != null &&\n                upload.getAccountName().equals(mCurrentAccount.name) &&\n                upload.getRemotePath().equals(mCurrentUpload.getRemotePath());\n        }\n\n        /**\n         * Adds a listener interested in the progress of the upload for a concrete file.\n         *\n         * @param listener Object to notify about progress of transfer.\n         * @param user  user owning the file of interest.\n         * @param file     {@link OCFile} of interest for listener.\n         */\n        public void addDatatransferProgressListener(\n            OnDatatransferProgressListener listener,\n            User user,\n            OCFile file\n        ) {\n            if (user == null || file == null || listener == null) {\n                return;\n            }\n\n            String targetKey = buildRemoteName(user.getAccountName(), file.getRemotePath());\n            mBoundListeners.put(targetKey, listener);\n        }\n\n        /**\n         * Adds a listener interested in the progress of the upload for a concrete file.\n         *\n         * @param listener Object to notify about progress of transfer.\n         * @param ocUpload {@link OCUpload} of interest for listener.\n         */\n        public void addDatatransferProgressListener(\n            OnDatatransferProgressListener listener,\n            OCUpload ocUpload\n        ) {\n            if (ocUpload == null || listener == null) {\n                return;\n            }\n\n            String targetKey = buildRemoteName(ocUpload.getAccountName(), ocUpload.getRemotePath());\n            mBoundListeners.put(targetKey, listener);\n        }\n\n        /**\n         * Removes a listener interested in the progress of the upload for a concrete file.\n         *\n         * @param listener Object to notify about progress of transfer.\n         * @param user user owning the file of interest.\n         * @param file {@link OCFile} of interest for listener.\n         */\n        public void removeDatatransferProgressListener(\n            OnDatatransferProgressListener listener,\n            User user,\n            OCFile file\n        ) {\n            if (user == null || file == null || listener == null) {\n                return;\n            }\n\n            String targetKey = buildRemoteName(user.getAccountName(), file.getRemotePath());\n            if (mBoundListeners.get(targetKey) == listener) {\n                mBoundListeners.remove(targetKey);\n            }\n        }\n\n        /**\n         * Removes a listener interested in the progress of the upload for a concrete file.\n         *\n         * @param listener Object to notify about progress of transfer.\n         * @param ocUpload Stored upload of interest\n         */\n        public void removeDatatransferProgressListener(\n            OnDatatransferProgressListener listener,\n            OCUpload ocUpload\n        ) {\n            if (ocUpload == null || listener == null) {\n                return;\n            }\n\n            String targetKey = buildRemoteName(ocUpload.getAccountName(), ocUpload.getRemotePath());\n            if (mBoundListeners.get(targetKey) == listener) {\n                mBoundListeners.remove(targetKey);\n            }\n        }\n\n        @Override\n        public void onTransferProgress(\n            long progressRate,\n            long totalTransferredSoFar,\n            long totalToTransfer,\n            String fileName\n        ) {\n            String key = buildRemoteName(mCurrentUpload.getAccount().name, mCurrentUpload.getFile().getRemotePath());\n            OnDatatransferProgressListener boundListener = mBoundListeners.get(key);\n\n            if (boundListener != null) {\n                boundListener.onTransferProgress(progressRate, totalTransferredSoFar, totalToTransfer, fileName);\n            }\n\n            Context context = MainApp.getAppContext();\n            if (context != null) {\n                ResultCode cancelReason = null;\n                Connectivity connectivity = connectivityService.getConnectivity();\n                if (mCurrentUpload.isWifiRequired() && !connectivity.isWifi()) {\n                    cancelReason = ResultCode.DELAYED_FOR_WIFI;\n                } else if (mCurrentUpload.isChargingRequired() && !powerManagementService.getBattery().isCharging()) {\n                    cancelReason = ResultCode.DELAYED_FOR_CHARGING;\n                } else if (!mCurrentUpload.isIgnoringPowerSaveMode() && powerManagementService.isPowerSavingEnabled()) {\n                    cancelReason = ResultCode.DELAYED_IN_POWER_SAVE_MODE;\n                }\n\n                if (cancelReason != null) {\n                    cancel(\n                        mCurrentUpload.getAccount().name,\n                        mCurrentUpload.getFile().getRemotePath(),\n                        cancelReason\n                    );\n                }\n            }\n        }\n\n        /**\n         * Builds a key for the map of listeners.\n         *\n         * TODO use method in IndexedForest, or refactor both to a common place add to local database) to better policy\n         * (add to local database, then upload)\n         *\n         * @param accountName Local name of the ownCloud account where the file to upload belongs.\n         * @param remotePath  Remote path to upload the file to.\n         * @return Key\n         */\n        private String buildRemoteName(String accountName, String remotePath) {\n            return accountName + remotePath;\n        }\n    }\n\n\n    /**\n     * Upload worker. Performs the pending uploads in the order they were requested.\n     *\n     * Created with the Looper of a new thread, started in {@link FileUploader#onCreate()}.\n     */\n    private static class ServiceHandler extends Handler {\n        // don't make it a final class, and don't remove the static ; lint will\n        // warn about a possible memory leak\n        private FileUploader mService;\n\n        public ServiceHandler(Looper looper, FileUploader service) {\n            super(looper);\n            if (service == null) {\n                throw new IllegalArgumentException(\"Received invalid NULL in parameter 'service'\");\n            }\n            mService = service;\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            @SuppressWarnings(\"unchecked\")\n            List<String> requestedUploads = (List<String>) msg.obj;\n            if (msg.obj != null) {\n                for (String requestedUpload : requestedUploads) {\n                    mService.uploadFile(requestedUpload);\n                }\n            }\n            Log_OC.d(TAG, \"Stopping command after id \" + msg.arg1);\n            mService.mNotificationManager.cancel(FOREGROUND_SERVICE_ID);\n            mService.stopForeground(true);\n            mService.stopSelf(msg.arg1);\n        }\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700287,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  }
]