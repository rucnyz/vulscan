[
  {
    "CWE_ID": [
      "CWE-1021"
    ],
    "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.nifi.web.server;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Lists;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.nifi.NiFiServer;\nimport org.apache.nifi.bundle.Bundle;\nimport org.apache.nifi.bundle.BundleDetails;\nimport org.apache.nifi.controller.UninheritableFlowException;\nimport org.apache.nifi.controller.serialization.FlowSerializationException;\nimport org.apache.nifi.controller.serialization.FlowSynchronizationException;\nimport org.apache.nifi.documentation.DocGenerator;\nimport org.apache.nifi.lifecycle.LifeCycleStartException;\nimport org.apache.nifi.nar.ExtensionManager;\nimport org.apache.nifi.nar.ExtensionMapping;\nimport org.apache.nifi.security.util.KeyStoreUtils;\nimport org.apache.nifi.services.FlowService;\nimport org.apache.nifi.ui.extension.UiExtension;\nimport org.apache.nifi.ui.extension.UiExtensionMapping;\nimport org.apache.nifi.util.NiFiProperties;\nimport org.apache.nifi.web.ContentAccess;\nimport org.apache.nifi.web.NiFiWebConfigurationContext;\nimport org.apache.nifi.web.UiExtensionType;\nimport org.eclipse.jetty.annotations.AnnotationConfiguration;\nimport org.eclipse.jetty.server.Connector;\nimport org.eclipse.jetty.server.Handler;\nimport org.eclipse.jetty.server.HttpConfiguration;\nimport org.eclipse.jetty.server.HttpConnectionFactory;\nimport org.eclipse.jetty.server.SecureRequestCustomizer;\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.server.ServerConnector;\nimport org.eclipse.jetty.server.SslConnectionFactory;\nimport org.eclipse.jetty.server.handler.ContextHandler;\nimport org.eclipse.jetty.server.handler.ContextHandlerCollection;\nimport org.eclipse.jetty.server.handler.HandlerCollection;\nimport org.eclipse.jetty.server.handler.ResourceHandler;\nimport org.eclipse.jetty.server.handler.gzip.GzipHandler;\nimport org.eclipse.jetty.servlet.FilterHolder;\nimport org.eclipse.jetty.util.resource.Resource;\nimport org.eclipse.jetty.util.resource.ResourceCollection;\nimport org.eclipse.jetty.util.ssl.SslContextFactory;\nimport org.eclipse.jetty.util.thread.QueuedThreadPool;\nimport org.eclipse.jetty.webapp.Configuration;\nimport org.eclipse.jetty.webapp.JettyWebXmlConfiguration;\nimport org.eclipse.jetty.webapp.WebAppClassLoader;\nimport org.eclipse.jetty.webapp.WebAppContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.BeansException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\n\nimport javax.servlet.DispatcherType;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.stream.Collectors;\n\n/**\n * Encapsulates the Jetty instance.\n */\npublic class JettyServer implements NiFiServer {\n\n    private static final Logger logger = LoggerFactory.getLogger(JettyServer.class);\n    private static final String WEB_DEFAULTS_XML = \"org/apache/nifi/web/webdefault.xml\";\n    private static final int HEADER_BUFFER_SIZE = 16 * 1024; // 16kb\n\n    private static final FileFilter WAR_FILTER = new FileFilter() {\n        @Override\n        public boolean accept(File pathname) {\n            final String nameToTest = pathname.getName().toLowerCase();\n            return nameToTest.endsWith(\".war\") && pathname.isFile();\n        }\n    };\n\n    private final Server server;\n    private final NiFiProperties props;\n\n    private Bundle systemBundle;\n    private Set<Bundle> bundles;\n    private ExtensionMapping extensionMapping;\n\n    private WebAppContext webApiContext;\n    private WebAppContext webDocsContext;\n\n    // content viewer and mime type specific extensions\n    private WebAppContext webContentViewerContext;\n    private Collection<WebAppContext> contentViewerWebContexts;\n\n    // component (processor, controller service, reporting task) ui extensions\n    private UiExtensionMapping componentUiExtensions;\n    private Collection<WebAppContext> componentUiExtensionWebContexts;\n\n    public JettyServer(final NiFiProperties props, final Set<Bundle> bundles) {\n        final QueuedThreadPool threadPool = new QueuedThreadPool(props.getWebThreads());\n        threadPool.setName(\"NiFi Web Server\");\n\n        // create the server\n        this.server = new Server(threadPool);\n        this.props = props;\n\n        // enable the annotation based configuration to ensure the jsp container is initialized properly\n        final Configuration.ClassList classlist = Configuration.ClassList.setServerDefault(server);\n        classlist.addBefore(JettyWebXmlConfiguration.class.getName(), AnnotationConfiguration.class.getName());\n\n        // configure server\n        configureConnectors(server);\n\n        // load wars from the bundle\n        loadWars(bundles);\n    }\n\n    private void loadWars(final Set<Bundle> bundles) {\n\n        // load WARs\n        final Map<File, Bundle> warToBundleLookup = findWars(bundles);\n\n        // locate each war being deployed\n        File webUiWar = null;\n        File webApiWar = null;\n        File webErrorWar = null;\n        File webDocsWar = null;\n        File webContentViewerWar = null;\n        List<File> otherWars = new ArrayList<>();\n        for (File war : warToBundleLookup.keySet()) {\n            if (war.getName().toLowerCase().startsWith(\"nifi-web-api\")) {\n                webApiWar = war;\n            } else if (war.getName().toLowerCase().startsWith(\"nifi-web-error\")) {\n                webErrorWar = war;\n            } else if (war.getName().toLowerCase().startsWith(\"nifi-web-docs\")) {\n                webDocsWar = war;\n            } else if (war.getName().toLowerCase().startsWith(\"nifi-web-content-viewer\")) {\n                webContentViewerWar = war;\n            } else if (war.getName().toLowerCase().startsWith(\"nifi-web\")) {\n                webUiWar = war;\n            } else {\n                otherWars.add(war);\n            }\n        }\n\n        // ensure the required wars were found\n        if (webUiWar == null) {\n            throw new RuntimeException(\"Unable to load nifi-web WAR\");\n        } else if (webApiWar == null) {\n            throw new RuntimeException(\"Unable to load nifi-web-api WAR\");\n        } else if (webDocsWar == null) {\n            throw new RuntimeException(\"Unable to load nifi-web-docs WAR\");\n        } else if (webErrorWar == null) {\n            throw new RuntimeException(\"Unable to load nifi-web-error WAR\");\n        } else if (webContentViewerWar == null) {\n            throw new RuntimeException(\"Unable to load nifi-web-content-viewer WAR\");\n        }\n\n        // handlers for each war and init params for the web api\n        final HandlerCollection handlers = new HandlerCollection();\n        final Map<String, String> mimeMappings = new HashMap<>();\n        final ClassLoader frameworkClassLoader = getClass().getClassLoader();\n        final ClassLoader jettyClassLoader = frameworkClassLoader.getParent();\n\n        // deploy the other wars\n        if (CollectionUtils.isNotEmpty(otherWars)) {\n            // hold onto to the web contexts for all ui extensions\n            componentUiExtensionWebContexts = new ArrayList<>();\n            contentViewerWebContexts = new ArrayList<>();\n\n            // ui extension organized by component type\n            final Map<String, List<UiExtension>> componentUiExtensionsByType = new HashMap<>();\n            for (File war : otherWars) {\n                // identify all known extension types in the war\n                final Map<UiExtensionType, List<String>> uiExtensionInWar = new HashMap<>();\n                identifyUiExtensionsForComponents(uiExtensionInWar, war);\n\n                // only include wars that are for custom processor ui's\n                if (!uiExtensionInWar.isEmpty()) {\n                    // get the context path\n                    String warName = StringUtils.substringBeforeLast(war.getName(), \".\");\n                    String warContextPath = String.format(\"/%s\", warName);\n\n                    // get the classloader for this war\n                    ClassLoader narClassLoaderForWar = warToBundleLookup.get(war).getClassLoader();\n\n                    // this should never be null\n                    if (narClassLoaderForWar == null) {\n                        narClassLoaderForWar = jettyClassLoader;\n                    }\n\n                    // create the extension web app context\n                    WebAppContext extensionUiContext = loadWar(war, warContextPath, narClassLoaderForWar);\n\n                    // create the ui extensions\n                    for (final Map.Entry<UiExtensionType, List<String>> entry : uiExtensionInWar.entrySet()) {\n                        final UiExtensionType extensionType = entry.getKey();\n                        final List<String> types = entry.getValue();\n\n                        if (UiExtensionType.ContentViewer.equals(extensionType)) {\n                            // consider each content type identified\n                            for (final String contentType : types) {\n                                // map the content type to the context path\n                                mimeMappings.put(contentType, warContextPath);\n                            }\n\n                            // this ui extension provides a content viewer\n                            contentViewerWebContexts.add(extensionUiContext);\n                        } else {\n                            // consider each component type identified\n                            for (final String componentTypeCoordinates : types) {\n                                logger.info(String.format(\"Loading UI extension [%s, %s] for %s\", extensionType, warContextPath, componentTypeCoordinates));\n\n                                // record the extension definition\n                                final UiExtension uiExtension = new UiExtension(extensionType, warContextPath);\n\n                                // create if this is the first extension for this component type\n                                List<UiExtension> componentUiExtensionsForType = componentUiExtensionsByType.get(componentTypeCoordinates);\n                                if (componentUiExtensionsForType == null) {\n                                    componentUiExtensionsForType = new ArrayList<>();\n                                    componentUiExtensionsByType.put(componentTypeCoordinates, componentUiExtensionsForType);\n                                }\n\n                                // see if there is already a ui extension of this same time\n                                if (containsUiExtensionType(componentUiExtensionsForType, extensionType)) {\n                                    throw new IllegalStateException(String.format(\"Encountered duplicate UI for %s\", componentTypeCoordinates));\n                                }\n\n                                // record this extension\n                                componentUiExtensionsForType.add(uiExtension);\n                            }\n\n                            // this ui extension provides a component custom ui\n                            componentUiExtensionWebContexts.add(extensionUiContext);\n                        }\n                    }\n\n                    // include custom ui web context in the handlers\n                    handlers.addHandler(extensionUiContext);\n                }\n\n            }\n\n            // record all ui extensions to give to the web api\n            componentUiExtensions = new UiExtensionMapping(componentUiExtensionsByType);\n        } else {\n            componentUiExtensions = new UiExtensionMapping(Collections.EMPTY_MAP);\n        }\n\n        // load the web ui app\n        handlers.addHandler(loadWar(webUiWar, \"/nifi\", frameworkClassLoader));\n\n        // load the web api app\n        webApiContext = loadWar(webApiWar, \"/nifi-api\", frameworkClassLoader);\n        handlers.addHandler(webApiContext);\n\n        // load the content viewer app\n        webContentViewerContext = loadWar(webContentViewerWar, \"/nifi-content-viewer\", frameworkClassLoader);\n        webContentViewerContext.getInitParams().putAll(mimeMappings);\n        handlers.addHandler(webContentViewerContext);\n\n        // create a web app for the docs\n        final String docsContextPath = \"/nifi-docs\";\n\n        // load the documentation war\n        webDocsContext = loadWar(webDocsWar, docsContextPath, frameworkClassLoader);\n\n        // overlay the actual documentation\n        final ContextHandlerCollection documentationHandlers = new ContextHandlerCollection();\n        documentationHandlers.addHandler(createDocsWebApp(docsContextPath));\n        documentationHandlers.addHandler(webDocsContext);\n        handlers.addHandler(documentationHandlers);\n\n        // load the web error app\n        handlers.addHandler(loadWar(webErrorWar, \"/\", frameworkClassLoader));\n\n        // deploy the web apps\n        server.setHandler(gzip(handlers));\n    }\n\n    /**\n     * Returns whether or not the specified ui extensions already contains an extension of the specified type.\n     *\n     * @param componentUiExtensionsForType  ui extensions for the type\n     * @param extensionType type of ui extension\n     * @return whether or not the specified ui extensions already contains an extension of the specified type\n     */\n    private boolean containsUiExtensionType(final List<UiExtension> componentUiExtensionsForType, final UiExtensionType extensionType) {\n        for (final UiExtension uiExtension : componentUiExtensionsForType) {\n            if (extensionType.equals(uiExtension.getExtensionType())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Enables compression for the specified handler.\n     *\n     * @param handler handler to enable compression for\n     * @return compression enabled handler\n     */\n    private Handler gzip(final Handler handler) {\n        final GzipHandler gzip = new GzipHandler();\n        gzip.setIncludedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\");\n        gzip.setHandler(handler);\n        return gzip;\n    }\n\n    private Map<File, Bundle> findWars(final Set<Bundle> bundles) {\n        final Map<File, Bundle> wars = new HashMap<>();\n\n        // consider each nar working directory\n        bundles.forEach(bundle -> {\n            final BundleDetails details = bundle.getBundleDetails();\n            final File narDependencies = new File(details.getWorkingDirectory(), \"META-INF/bundled-dependencies\");\n            if (narDependencies.isDirectory()) {\n                // list the wars from this nar\n                final File[] narDependencyDirs = narDependencies.listFiles(WAR_FILTER);\n                if (narDependencyDirs == null) {\n                    throw new IllegalStateException(String.format(\"Unable to access working directory for NAR dependencies in: %s\", narDependencies.getAbsolutePath()));\n                }\n\n                // add each war\n                for (final File war : narDependencyDirs) {\n                    wars.put(war, bundle);\n                }\n            }\n        });\n\n        return wars;\n    }\n\n    private void readUiExtensions(final Map<UiExtensionType, List<String>> uiExtensions, final UiExtensionType uiExtensionType, final JarFile jarFile, final JarEntry jarEntry) throws IOException {\n        if (jarEntry == null) {\n            return;\n        }\n\n        // get an input stream for the nifi-processor configuration file\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(jarFile.getInputStream(jarEntry)))) {\n\n            // read in each configured type\n            String rawComponentType;\n            while ((rawComponentType = in.readLine()) != null) {\n                // extract the component type\n                final String componentType = extractComponentType(rawComponentType);\n                if (componentType != null) {\n                    List<String> extensions = uiExtensions.get(uiExtensionType);\n\n                    // if there are currently no extensions for this type create it\n                    if (extensions == null) {\n                        extensions = new ArrayList<>();\n                        uiExtensions.put(uiExtensionType, extensions);\n                    }\n\n                    // add the specified type\n                    extensions.add(componentType);\n                }\n            }\n        }\n    }\n\n    /**\n     * Identifies all known UI extensions and stores them in the specified map.\n     *\n     * @param uiExtensions extensions\n     * @param warFile war\n     */\n    private void identifyUiExtensionsForComponents(final Map<UiExtensionType, List<String>> uiExtensions, final File warFile) {\n        try (final JarFile jarFile = new JarFile(warFile)) {\n            // locate the ui extensions\n            readUiExtensions(uiExtensions, UiExtensionType.ContentViewer, jarFile, jarFile.getJarEntry(\"META-INF/nifi-content-viewer\"));\n            readUiExtensions(uiExtensions, UiExtensionType.ProcessorConfiguration, jarFile, jarFile.getJarEntry(\"META-INF/nifi-processor-configuration\"));\n            readUiExtensions(uiExtensions, UiExtensionType.ControllerServiceConfiguration, jarFile, jarFile.getJarEntry(\"META-INF/nifi-controller-service-configuration\"));\n            readUiExtensions(uiExtensions, UiExtensionType.ReportingTaskConfiguration, jarFile, jarFile.getJarEntry(\"META-INF/nifi-reporting-task-configuration\"));\n        } catch (IOException ioe) {\n            logger.warn(String.format(\"Unable to inspect %s for a UI extensions.\", warFile));\n        }\n    }\n\n    /**\n     * Extracts the component type. Trims the line and considers comments.\n     * Returns null if no type was found.\n     *\n     * @param line line\n     * @return type\n     */\n    private String extractComponentType(final String line) {\n        final String trimmedLine = line.trim();\n        if (!trimmedLine.isEmpty() && !trimmedLine.startsWith(\"#\")) {\n            final int indexOfPound = trimmedLine.indexOf(\"#\");\n            return (indexOfPound > 0) ? trimmedLine.substring(0, indexOfPound) : trimmedLine;\n        }\n        return null;\n    }\n\n    private WebAppContext loadWar(final File warFile, final String contextPath, final ClassLoader parentClassLoader) {\n        final WebAppContext webappContext = new WebAppContext(warFile.getPath(), contextPath);\n        webappContext.setContextPath(contextPath);\n        webappContext.setDisplayName(contextPath);\n\n        // instruction jetty to examine these jars for tlds, web-fragments, etc\n        webappContext.setAttribute(\"org.eclipse.jetty.server.webapp.ContainerIncludeJarPattern\", \".*/[^/]*servlet-api-[^/]*\\\\.jar$|.*/javax.servlet.jsp.jstl-.*\\\\\\\\.jar$|.*/[^/]*taglibs.*\\\\.jar$\" );\n\n        // remove slf4j server class to allow WAR files to have slf4j dependencies in WEB-INF/lib\n        List<String> serverClasses = new ArrayList<>(Arrays.asList(webappContext.getServerClasses()));\n        serverClasses.remove(\"org.slf4j.\");\n        webappContext.setServerClasses(serverClasses.toArray(new String[0]));\n        webappContext.setDefaultsDescriptor(WEB_DEFAULTS_XML);\n\n        // get the temp directory for this webapp\n        File tempDir = new File(props.getWebWorkingDirectory(), warFile.getName());\n        if (tempDir.exists() && !tempDir.isDirectory()) {\n            throw new RuntimeException(tempDir.getAbsolutePath() + \" is not a directory\");\n        } else if (!tempDir.exists()) {\n            final boolean made = tempDir.mkdirs();\n            if (!made) {\n                throw new RuntimeException(tempDir.getAbsolutePath() + \" could not be created\");\n            }\n        }\n        if (!(tempDir.canRead() && tempDir.canWrite())) {\n            throw new RuntimeException(tempDir.getAbsolutePath() + \" directory does not have read/write privilege\");\n        }\n\n        // configure the temp dir\n        webappContext.setTempDirectory(tempDir);\n\n        // configure the max form size (3x the default)\n        webappContext.setMaxFormContentSize(600000);\n\n        // add a filter to set the X-Frame-Options filter\n        webappContext.addFilter(new FilterHolder(FRAME_OPTIONS_FILTER), \"/*\", EnumSet.allOf(DispatcherType.class));\n\n        try {\n            // configure the class loader - webappClassLoader -> jetty nar -> web app's nar -> ...\n            webappContext.setClassLoader(new WebAppClassLoader(parentClassLoader, webappContext));\n        } catch (final IOException ioe) {\n            startUpFailure(ioe);\n        }\n\n        logger.info(\"Loading WAR: \" + warFile.getAbsolutePath() + \" with context path set to \" + contextPath);\n        return webappContext;\n    }\n\n    private ContextHandler createDocsWebApp(final String contextPath) {\n        try {\n            final ResourceHandler resourceHandler = new ResourceHandler();\n            resourceHandler.setDirectoriesListed(false);\n\n            // load the docs directory\n            final File docsDir = Paths.get(\"docs\").toRealPath().toFile();\n            final Resource docsResource = Resource.newResource(docsDir);\n\n            // load the component documentation working directory\n            final File componentDocsDirPath = props.getComponentDocumentationWorkingDirectory();\n            final File workingDocsDirectory = componentDocsDirPath.toPath().toRealPath().getParent().toFile();\n            final Resource workingDocsResource = Resource.newResource(workingDocsDirectory);\n\n            // load the rest documentation\n            final File webApiDocsDir = new File(webApiContext.getTempDirectory(), \"webapp/docs\");\n            if (!webApiDocsDir.exists()) {\n                final boolean made = webApiDocsDir.mkdirs();\n                if (!made) {\n                    throw new RuntimeException(webApiDocsDir.getAbsolutePath() + \" could not be created\");\n                }\n            }\n            final Resource webApiDocsResource = Resource.newResource(webApiDocsDir);\n\n            // create resources for both docs locations\n            final ResourceCollection resources = new ResourceCollection(docsResource, workingDocsResource, webApiDocsResource);\n            resourceHandler.setBaseResource(resources);\n\n            // create the context handler\n            final ContextHandler handler = new ContextHandler(contextPath);\n            handler.setHandler(resourceHandler);\n\n            logger.info(\"Loading documents web app with context path set to \" + contextPath);\n            return handler;\n        } catch (Exception ex) {\n            throw new IllegalStateException(\"Resource directory paths are malformed: \" + ex.getMessage());\n        }\n    }\n\n    private void configureConnectors(final Server server) throws ServerConfigurationException {\n        // create the http configuration\n        final HttpConfiguration httpConfiguration = new HttpConfiguration();\n        httpConfiguration.setRequestHeaderSize(HEADER_BUFFER_SIZE);\n        httpConfiguration.setResponseHeaderSize(HEADER_BUFFER_SIZE);\n\n        if (props.getPort() != null) {\n            final Integer port = props.getPort();\n            if (port < 0 || (int) Math.pow(2, 16) <= port) {\n                throw new ServerConfigurationException(\"Invalid HTTP port: \" + port);\n            }\n\n            logger.info(\"Configuring Jetty for HTTP on port: \" + port);\n\n            final List<Connector> serverConnectors = Lists.newArrayList();\n\n            final Map<String, String> httpNetworkInterfaces = props.getHttpNetworkInterfaces();\n            if (httpNetworkInterfaces.isEmpty() || httpNetworkInterfaces.values().stream().filter(value -> !Strings.isNullOrEmpty(value)).collect(Collectors.toList()).isEmpty()) {\n                // create the connector\n                final ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfiguration));\n                // set host and port\n                if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.WEB_HTTP_HOST))) {\n                    http.setHost(props.getProperty(NiFiProperties.WEB_HTTP_HOST));\n                }\n                http.setPort(port);\n                serverConnectors.add(http);\n            } else {\n                // add connectors for all IPs from http network interfaces\n                serverConnectors.addAll(Lists.newArrayList(httpNetworkInterfaces.values().stream().map(ifaceName -> {\n                    NetworkInterface iface = null;\n                    try {\n                        iface = NetworkInterface.getByName(ifaceName);\n                    } catch (SocketException e) {\n                        logger.error(\"Unable to get network interface by name {}\", ifaceName, e);\n                    }\n                    if (iface == null) {\n                        logger.warn(\"Unable to find network interface named {}\", ifaceName);\n                    }\n                    return iface;\n                }).filter(Objects::nonNull).flatMap(iface -> Collections.list(iface.getInetAddresses()).stream())\n                        .map(inetAddress -> {\n                            // create the connector\n                            final ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfiguration));\n                            // set host and port\n                            http.setHost(inetAddress.getHostAddress());\n                            http.setPort(port);\n                            return http;\n                        }).collect(Collectors.toList())));\n            }\n            // add all connectors\n            serverConnectors.forEach(server::addConnector);\n        }\n\n        if (props.getSslPort() != null) {\n            final Integer port = props.getSslPort();\n            if (port < 0 || (int) Math.pow(2, 16) <= port) {\n                throw new ServerConfigurationException(\"Invalid HTTPs port: \" + port);\n            }\n\n            logger.info(\"Configuring Jetty for HTTPs on port: \" + port);\n\n            final List<Connector> serverConnectors = Lists.newArrayList();\n\n            final Map<String, String> httpsNetworkInterfaces = props.getHttpsNetworkInterfaces();\n            if (httpsNetworkInterfaces.isEmpty() || httpsNetworkInterfaces.values().stream().filter(value -> !Strings.isNullOrEmpty(value)).collect(Collectors.toList()).isEmpty()) {\n                final ServerConnector https = createUnconfiguredSslServerConnector(server, httpConfiguration);\n\n                // set host and port\n                if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.WEB_HTTPS_HOST))) {\n                    https.setHost(props.getProperty(NiFiProperties.WEB_HTTPS_HOST));\n                }\n                https.setPort(port);\n                serverConnectors.add(https);\n            } else {\n                // add connectors for all IPs from https network interfaces\n                serverConnectors.addAll(Lists.newArrayList(httpsNetworkInterfaces.values().stream().map(ifaceName -> {\n                    NetworkInterface iface = null;\n                    try {\n                        iface = NetworkInterface.getByName(ifaceName);\n                    } catch (SocketException e) {\n                        logger.error(\"Unable to get network interface by name {}\", ifaceName, e);\n                    }\n                    if (iface == null) {\n                        logger.warn(\"Unable to find network interface named {}\", ifaceName);\n                    }\n                    return iface;\n                }).filter(Objects::nonNull).flatMap(iface -> Collections.list(iface.getInetAddresses()).stream())\n                        .map(inetAddress -> {\n                            final ServerConnector https = createUnconfiguredSslServerConnector(server, httpConfiguration);\n\n                            // set host and port\n                            https.setHost(inetAddress.getHostAddress());\n                            https.setPort(port);\n                            return https;\n                        }).collect(Collectors.toList())));\n            }\n            // add all connectors\n            serverConnectors.forEach(server::addConnector);\n        }\n    }\n\n    private ServerConnector createUnconfiguredSslServerConnector(Server server, HttpConfiguration httpConfiguration) {\n        // add some secure config\n        final HttpConfiguration httpsConfiguration = new HttpConfiguration(httpConfiguration);\n        httpsConfiguration.setSecureScheme(\"https\");\n        httpsConfiguration.setSecurePort(props.getSslPort());\n        httpsConfiguration.addCustomizer(new SecureRequestCustomizer());\n\n        // build the connector\n        return new ServerConnector(server,\n                new SslConnectionFactory(createSslContextFactory(), \"http/1.1\"),\n                new HttpConnectionFactory(httpsConfiguration));\n    }\n\n    private SslContextFactory createSslContextFactory() {\n        final SslContextFactory contextFactory = new SslContextFactory();\n        configureSslContextFactory(contextFactory, props);\n        return contextFactory;\n    }\n\n    protected static void configureSslContextFactory(SslContextFactory contextFactory, NiFiProperties props) {\n        // require client auth when not supporting login, Kerberos service, or anonymous access\n        if (props.isClientAuthRequiredForRestApi()) {\n            contextFactory.setNeedClientAuth(true);\n        } else {\n            contextFactory.setWantClientAuth(true);\n        }\n\n        /* below code sets JSSE system properties when values are provided */\n        // keystore properties\n        if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.SECURITY_KEYSTORE))) {\n            contextFactory.setKeyStorePath(props.getProperty(NiFiProperties.SECURITY_KEYSTORE));\n        }\n        String keyStoreType = props.getProperty(NiFiProperties.SECURITY_KEYSTORE_TYPE);\n        if (StringUtils.isNotBlank(keyStoreType)) {\n            contextFactory.setKeyStoreType(keyStoreType);\n            String keyStoreProvider = KeyStoreUtils.getKeyStoreProvider(keyStoreType);\n            if (StringUtils.isNoneEmpty(keyStoreProvider)) {\n                contextFactory.setKeyStoreProvider(keyStoreProvider);\n            }\n        }\n        final String keystorePassword = props.getProperty(NiFiProperties.SECURITY_KEYSTORE_PASSWD);\n        final String keyPassword = props.getProperty(NiFiProperties.SECURITY_KEY_PASSWD);\n        if (StringUtils.isNotBlank(keystorePassword)) {\n            // if no key password was provided, then assume the keystore password is the same as the key password.\n            final String defaultKeyPassword = (StringUtils.isBlank(keyPassword)) ? keystorePassword : keyPassword;\n            contextFactory.setKeyStorePassword(keystorePassword);\n            contextFactory.setKeyManagerPassword(defaultKeyPassword);\n        } else if (StringUtils.isNotBlank(keyPassword)) {\n            // since no keystore password was provided, there will be no keystore integrity check\n            contextFactory.setKeyManagerPassword(keyPassword);\n        }\n\n        // truststore properties\n        if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE))) {\n            contextFactory.setTrustStorePath(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE));\n        }\n        String trustStoreType = props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE_TYPE);\n        if (StringUtils.isNotBlank(trustStoreType)) {\n            contextFactory.setTrustStoreType(trustStoreType);\n            String trustStoreProvider = KeyStoreUtils.getKeyStoreProvider(trustStoreType);\n            if (StringUtils.isNoneEmpty(trustStoreProvider)) {\n                contextFactory.setTrustStoreProvider(trustStoreProvider);\n            }\n        }\n        if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE_PASSWD))) {\n            contextFactory.setTrustStorePassword(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE_PASSWD));\n        }\n    }\n\n    @Override\n    public void start() {\n        try {\n            ExtensionManager.discoverExtensions(systemBundle, bundles);\n            ExtensionManager.logClassLoaderMapping();\n\n            DocGenerator.generate(props, extensionMapping);\n\n            // start the server\n            server.start();\n\n            // ensure everything started successfully\n            for (Handler handler : server.getChildHandlers()) {\n                // see if the handler is a web app\n                if (handler instanceof WebAppContext) {\n                    WebAppContext context = (WebAppContext) handler;\n\n                    // see if this webapp had any exceptions that would\n                    // cause it to be unavailable\n                    if (context.getUnavailableException() != null) {\n                        startUpFailure(context.getUnavailableException());\n                    }\n                }\n            }\n\n            // ensure the appropriate wars deployed successfully before injecting the NiFi context and security filters\n            // this must be done after starting the server (and ensuring there were no start up failures)\n            if (webApiContext != null) {\n                // give the web api the component ui extensions\n                final ServletContext webApiServletContext = webApiContext.getServletHandler().getServletContext();\n                webApiServletContext.setAttribute(\"nifi-ui-extensions\", componentUiExtensions);\n\n                // get the application context\n                final WebApplicationContext webApplicationContext = WebApplicationContextUtils.getRequiredWebApplicationContext(webApiServletContext);\n\n                // component ui extensions\n                if (CollectionUtils.isNotEmpty(componentUiExtensionWebContexts)) {\n                    final NiFiWebConfigurationContext configurationContext = webApplicationContext.getBean(\"nifiWebConfigurationContext\", NiFiWebConfigurationContext.class);\n\n                    for (final WebAppContext customUiContext : componentUiExtensionWebContexts) {\n                        // set the NiFi context in each custom ui servlet context\n                        final ServletContext customUiServletContext = customUiContext.getServletHandler().getServletContext();\n                        customUiServletContext.setAttribute(\"nifi-web-configuration-context\", configurationContext);\n\n                        // add the security filter to any ui extensions wars\n                        final FilterHolder securityFilter = webApiContext.getServletHandler().getFilter(\"springSecurityFilterChain\");\n                        if (securityFilter != null) {\n                            customUiContext.addFilter(securityFilter, \"/*\", EnumSet.allOf(DispatcherType.class));\n                        }\n                    }\n                }\n\n                // content viewer extensions\n                if (CollectionUtils.isNotEmpty(contentViewerWebContexts)) {\n                    for (final WebAppContext contentViewerContext : contentViewerWebContexts) {\n                        // add the security filter to any content viewer  wars\n                        final FilterHolder securityFilter = webApiContext.getServletHandler().getFilter(\"springSecurityFilterChain\");\n                        if (securityFilter != null) {\n                            contentViewerContext.addFilter(securityFilter, \"/*\", EnumSet.allOf(DispatcherType.class));\n                        }\n                    }\n                }\n\n                // content viewer controller\n                if (webContentViewerContext != null) {\n                    final ContentAccess contentAccess = webApplicationContext.getBean(\"contentAccess\", ContentAccess.class);\n\n                    // add the content access\n                    final ServletContext webContentViewerServletContext = webContentViewerContext.getServletHandler().getServletContext();\n                    webContentViewerServletContext.setAttribute(\"nifi-content-access\", contentAccess);\n\n                    final FilterHolder securityFilter = webApiContext.getServletHandler().getFilter(\"springSecurityFilterChain\");\n                    if (securityFilter != null) {\n                        webContentViewerContext.addFilter(securityFilter, \"/*\", EnumSet.allOf(DispatcherType.class));\n                    }\n                }\n            }\n\n            // ensure the web document war was loaded and provide the extension mapping\n            if (webDocsContext != null) {\n                final ServletContext webDocsServletContext = webDocsContext.getServletHandler().getServletContext();\n                webDocsServletContext.setAttribute(\"nifi-extension-mapping\", extensionMapping);\n            }\n\n            // if this nifi is a node in a cluster, start the flow service and load the flow - the\n            // flow service is loaded here for clustered nodes because the loading of the flow will\n            // initialize the connection between the node and the NCM. if the node connects (starts\n            // heartbeating, etc), the NCM may issue web requests before the application (wars) have\n            // finished loading. this results in the node being disconnected since its unable to\n            // successfully respond to the requests. to resolve this, flow loading was moved to here\n            // (after the wars have been successfully deployed) when this nifi instance is a node\n            // in a cluster\n            if (props.isNode()) {\n\n                FlowService flowService = null;\n                try {\n\n                    logger.info(\"Loading Flow...\");\n\n                    ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(webApiContext.getServletContext());\n                    flowService = ctx.getBean(\"flowService\", FlowService.class);\n\n                    // start and load the flow\n                    flowService.start();\n                    flowService.load(null);\n\n                    logger.info(\"Flow loaded successfully.\");\n\n                } catch (BeansException | LifeCycleStartException | IOException | FlowSerializationException | FlowSynchronizationException | UninheritableFlowException e) {\n                    // ensure the flow service is terminated\n                    if (flowService != null && flowService.isRunning()) {\n                        flowService.stop(false);\n                    }\n                    throw new Exception(\"Unable to load flow due to: \" + e, e);\n                }\n            }\n\n            // dump the application url after confirming everything started successfully\n            dumpUrls();\n        } catch (Exception ex) {\n            startUpFailure(ex);\n        }\n    }\n\n    private void dumpUrls() throws SocketException {\n        final List<String> urls = new ArrayList<>();\n\n        for (Connector connector : server.getConnectors()) {\n            if (connector instanceof ServerConnector) {\n                final ServerConnector serverConnector = (ServerConnector) connector;\n\n                Set<String> hosts = new HashSet<>();\n\n                // determine the hosts\n                if (StringUtils.isNotBlank(serverConnector.getHost())) {\n                    hosts.add(serverConnector.getHost());\n                } else {\n                    Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();\n                    if (networkInterfaces != null) {\n                        for (NetworkInterface networkInterface : Collections.list(networkInterfaces)) {\n                            for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {\n                                hosts.add(inetAddress.getHostAddress());\n                            }\n                        }\n                    }\n                }\n\n                // ensure some hosts were found\n                if (!hosts.isEmpty()) {\n                    String scheme = \"http\";\n                    if (props.getSslPort() != null && serverConnector.getPort() == props.getSslPort()) {\n                        scheme = \"https\";\n                    }\n\n                    // dump each url\n                    for (String host : hosts) {\n                        urls.add(String.format(\"%s://%s:%s\", scheme, host, serverConnector.getPort()));\n                    }\n                }\n            }\n        }\n\n        if (urls.isEmpty()) {\n            logger.warn(\"NiFi has started, but the UI is not available on any hosts. Please verify the host properties.\");\n        } else {\n            // log the ui location\n            logger.info(\"NiFi has started. The UI is available at the following URLs:\");\n            for (final String url : urls) {\n                logger.info(String.format(\"%s/nifi\", url));\n            }\n        }\n    }\n\n    private void startUpFailure(Throwable t) {\n        System.err.println(\"Failed to start web server: \" + t.getMessage());\n        System.err.println(\"Shutting down...\");\n        logger.warn(\"Failed to start web server... shutting down.\", t);\n        System.exit(1);\n    }\n\n    @Override\n    public void setExtensionMapping(ExtensionMapping extensionMapping) {\n        this.extensionMapping = extensionMapping;\n    }\n\n    @Override\n    public void setBundles(Bundle systemBundle, Set<Bundle> bundles) {\n        this.systemBundle = systemBundle;\n        this.bundles = bundles;\n    }\n\n    @Override\n    public void stop() {\n        try {\n            server.stop();\n        } catch (Exception ex) {\n            logger.warn(\"Failed to stop web server\", ex);\n        }\n    }\n\n    private static final Filter FRAME_OPTIONS_FILTER = new Filter() {\n        private static final String FRAME_OPTIONS = \"X-Frame-Options\";\n        private static final String SAME_ORIGIN = \"SAMEORIGIN\";\n\n        @Override\n        public void doFilter(final ServletRequest req, final ServletResponse resp, final FilterChain filterChain)\n                throws IOException, ServletException {\n\n            // set frame options accordingly\n            final HttpServletResponse response = (HttpServletResponse) resp;\n            response.addHeader(FRAME_OPTIONS, SAME_ORIGIN);\n\n            filterChain.doFilter(req, resp);\n        }\n\n        @Override\n        public void init(final FilterConfig config) {\n        }\n\n        @Override\n        public void destroy() {\n        }\n    };\n}",
    "target": 1,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800074,
    "RELATED_CWE": [
      "CWE-311",
      "CWE-532",
      "CWE-863"
    ]
  },
  {
    "CWE_ID": [
      "CWE-1021"
    ],
    "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.nifi.web.server;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Lists;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.nifi.NiFiServer;\nimport org.apache.nifi.bundle.Bundle;\nimport org.apache.nifi.bundle.BundleDetails;\nimport org.apache.nifi.controller.UninheritableFlowException;\nimport org.apache.nifi.controller.serialization.FlowSerializationException;\nimport org.apache.nifi.controller.serialization.FlowSynchronizationException;\nimport org.apache.nifi.documentation.DocGenerator;\nimport org.apache.nifi.lifecycle.LifeCycleStartException;\nimport org.apache.nifi.nar.ExtensionManager;\nimport org.apache.nifi.nar.ExtensionMapping;\nimport org.apache.nifi.processor.DataUnit;\nimport org.apache.nifi.security.util.KeyStoreUtils;\nimport org.apache.nifi.services.FlowService;\nimport org.apache.nifi.ui.extension.UiExtension;\nimport org.apache.nifi.ui.extension.UiExtensionMapping;\nimport org.apache.nifi.util.FormatUtils;\nimport org.apache.nifi.util.NiFiProperties;\nimport org.apache.nifi.web.ContentAccess;\nimport org.apache.nifi.web.NiFiWebConfigurationContext;\nimport org.apache.nifi.web.UiExtensionType;\nimport org.eclipse.jetty.annotations.AnnotationConfiguration;\nimport org.eclipse.jetty.server.Connector;\nimport org.eclipse.jetty.server.Handler;\nimport org.eclipse.jetty.server.HttpConfiguration;\nimport org.eclipse.jetty.server.HttpConnectionFactory;\nimport org.eclipse.jetty.server.SecureRequestCustomizer;\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.server.ServerConnector;\nimport org.eclipse.jetty.server.SslConnectionFactory;\nimport org.eclipse.jetty.server.handler.ContextHandler;\nimport org.eclipse.jetty.server.handler.ContextHandlerCollection;\nimport org.eclipse.jetty.server.handler.HandlerCollection;\nimport org.eclipse.jetty.server.handler.HandlerList;\nimport org.eclipse.jetty.server.handler.ResourceHandler;\nimport org.eclipse.jetty.server.handler.gzip.GzipHandler;\nimport org.eclipse.jetty.servlet.FilterHolder;\nimport org.eclipse.jetty.util.resource.Resource;\nimport org.eclipse.jetty.util.resource.ResourceCollection;\nimport org.eclipse.jetty.util.ssl.SslContextFactory;\nimport org.eclipse.jetty.util.thread.QueuedThreadPool;\nimport org.eclipse.jetty.webapp.Configuration;\nimport org.eclipse.jetty.webapp.JettyWebXmlConfiguration;\nimport org.eclipse.jetty.webapp.WebAppClassLoader;\nimport org.eclipse.jetty.webapp.WebAppContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.BeansException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\n\nimport javax.servlet.DispatcherType;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.stream.Collectors;\n\n/**\n * Encapsulates the Jetty instance.\n */\npublic class JettyServer implements NiFiServer {\n\n    private static final Logger logger = LoggerFactory.getLogger(JettyServer.class);\n    private static final String WEB_DEFAULTS_XML = \"org/apache/nifi/web/webdefault.xml\";\n\n    private static final FileFilter WAR_FILTER = new FileFilter() {\n        @Override\n        public boolean accept(File pathname) {\n            final String nameToTest = pathname.getName().toLowerCase();\n            return nameToTest.endsWith(\".war\") && pathname.isFile();\n        }\n    };\n\n    private final Server server;\n    private final NiFiProperties props;\n\n    private Bundle systemBundle;\n    private Set<Bundle> bundles;\n    private ExtensionMapping extensionMapping;\n\n    private WebAppContext webApiContext;\n    private WebAppContext webDocsContext;\n\n    // content viewer and mime type specific extensions\n    private WebAppContext webContentViewerContext;\n    private Collection<WebAppContext> contentViewerWebContexts;\n\n    // component (processor, controller service, reporting task) ui extensions\n    private UiExtensionMapping componentUiExtensions;\n    private Collection<WebAppContext> componentUiExtensionWebContexts;\n\n    public JettyServer(final NiFiProperties props, final Set<Bundle> bundles) {\n        final QueuedThreadPool threadPool = new QueuedThreadPool(props.getWebThreads());\n        threadPool.setName(\"NiFi Web Server\");\n\n        // create the server\n        this.server = new Server(threadPool);\n        this.props = props;\n\n        // enable the annotation based configuration to ensure the jsp container is initialized properly\n        final Configuration.ClassList classlist = Configuration.ClassList.setServerDefault(server);\n        classlist.addBefore(JettyWebXmlConfiguration.class.getName(), AnnotationConfiguration.class.getName());\n\n        // configure server\n        configureConnectors(server);\n\n        // load wars from the bundle\n        Handler warHandlers = loadWars(bundles);\n\n        HandlerList allHandlers = new HandlerList();\n\n        // Only restrict the host header if running in HTTPS mode\n        if (props.isHTTPSConfigured()) {\n            // Create a handler for the host header and add it to the server\n            HostHeaderHandler hostHeaderHandler = new HostHeaderHandler(props);\n            logger.info(\"Created HostHeaderHandler [\" + hostHeaderHandler.toString() + \"]\");\n\n            // Add this before the WAR handlers\n            allHandlers.addHandler(hostHeaderHandler);\n        } else {\n            logger.info(\"Running in HTTP mode; host headers not restricted\");\n        }\n\n        allHandlers.addHandler(warHandlers);\n        server.setHandler(allHandlers);\n    }\n\n    /**\n     * Instantiates this object but does not perform any configuration. Used for unit testing.\n     */\n     JettyServer(Server server, NiFiProperties properties) {\n        this.server = server;\n        this.props = properties;\n    }\n\n    private Handler loadWars(final Set<Bundle> bundles) {\n\n        // load WARs\n        final Map<File, Bundle> warToBundleLookup = findWars(bundles);\n\n        // locate each war being deployed\n        File webUiWar = null;\n        File webApiWar = null;\n        File webErrorWar = null;\n        File webDocsWar = null;\n        File webContentViewerWar = null;\n        List<File> otherWars = new ArrayList<>();\n        for (File war : warToBundleLookup.keySet()) {\n            if (war.getName().toLowerCase().startsWith(\"nifi-web-api\")) {\n                webApiWar = war;\n            } else if (war.getName().toLowerCase().startsWith(\"nifi-web-error\")) {\n                webErrorWar = war;\n            } else if (war.getName().toLowerCase().startsWith(\"nifi-web-docs\")) {\n                webDocsWar = war;\n            } else if (war.getName().toLowerCase().startsWith(\"nifi-web-content-viewer\")) {\n                webContentViewerWar = war;\n            } else if (war.getName().toLowerCase().startsWith(\"nifi-web\")) {\n                webUiWar = war;\n            } else {\n                otherWars.add(war);\n            }\n        }\n\n        // ensure the required wars were found\n        if (webUiWar == null) {\n            throw new RuntimeException(\"Unable to load nifi-web WAR\");\n        } else if (webApiWar == null) {\n            throw new RuntimeException(\"Unable to load nifi-web-api WAR\");\n        } else if (webDocsWar == null) {\n            throw new RuntimeException(\"Unable to load nifi-web-docs WAR\");\n        } else if (webErrorWar == null) {\n            throw new RuntimeException(\"Unable to load nifi-web-error WAR\");\n        } else if (webContentViewerWar == null) {\n            throw new RuntimeException(\"Unable to load nifi-web-content-viewer WAR\");\n        }\n\n        // handlers for each war and init params for the web api\n        final HandlerCollection handlers = new HandlerCollection();\n        final Map<String, String> mimeMappings = new HashMap<>();\n        final ClassLoader frameworkClassLoader = getClass().getClassLoader();\n        final ClassLoader jettyClassLoader = frameworkClassLoader.getParent();\n\n        // deploy the other wars\n        if (CollectionUtils.isNotEmpty(otherWars)) {\n            // hold onto to the web contexts for all ui extensions\n            componentUiExtensionWebContexts = new ArrayList<>();\n            contentViewerWebContexts = new ArrayList<>();\n\n            // ui extension organized by component type\n            final Map<String, List<UiExtension>> componentUiExtensionsByType = new HashMap<>();\n            for (File war : otherWars) {\n                // identify all known extension types in the war\n                final Map<UiExtensionType, List<String>> uiExtensionInWar = new HashMap<>();\n                identifyUiExtensionsForComponents(uiExtensionInWar, war);\n\n                // only include wars that are for custom processor ui's\n                if (!uiExtensionInWar.isEmpty()) {\n                    // get the context path\n                    String warName = StringUtils.substringBeforeLast(war.getName(), \".\");\n                    String warContextPath = String.format(\"/%s\", warName);\n\n                    // get the classloader for this war\n                    ClassLoader narClassLoaderForWar = warToBundleLookup.get(war).getClassLoader();\n\n                    // this should never be null\n                    if (narClassLoaderForWar == null) {\n                        narClassLoaderForWar = jettyClassLoader;\n                    }\n\n                    // create the extension web app context\n                    WebAppContext extensionUiContext = loadWar(war, warContextPath, narClassLoaderForWar);\n\n                    // create the ui extensions\n                    for (final Map.Entry<UiExtensionType, List<String>> entry : uiExtensionInWar.entrySet()) {\n                        final UiExtensionType extensionType = entry.getKey();\n                        final List<String> types = entry.getValue();\n\n                        if (UiExtensionType.ContentViewer.equals(extensionType)) {\n                            // consider each content type identified\n                            for (final String contentType : types) {\n                                // map the content type to the context path\n                                mimeMappings.put(contentType, warContextPath);\n                            }\n\n                            // this ui extension provides a content viewer\n                            contentViewerWebContexts.add(extensionUiContext);\n                        } else {\n                            // consider each component type identified\n                            for (final String componentTypeCoordinates : types) {\n                                logger.info(String.format(\"Loading UI extension [%s, %s] for %s\", extensionType, warContextPath, componentTypeCoordinates));\n\n                                // record the extension definition\n                                final UiExtension uiExtension = new UiExtension(extensionType, warContextPath);\n\n                                // create if this is the first extension for this component type\n                                List<UiExtension> componentUiExtensionsForType = componentUiExtensionsByType.get(componentTypeCoordinates);\n                                if (componentUiExtensionsForType == null) {\n                                    componentUiExtensionsForType = new ArrayList<>();\n                                    componentUiExtensionsByType.put(componentTypeCoordinates, componentUiExtensionsForType);\n                                }\n\n                                // see if there is already a ui extension of this same time\n                                if (containsUiExtensionType(componentUiExtensionsForType, extensionType)) {\n                                    throw new IllegalStateException(String.format(\"Encountered duplicate UI for %s\", componentTypeCoordinates));\n                                }\n\n                                // record this extension\n                                componentUiExtensionsForType.add(uiExtension);\n                            }\n\n                            // this ui extension provides a component custom ui\n                            componentUiExtensionWebContexts.add(extensionUiContext);\n                        }\n                    }\n\n                    // include custom ui web context in the handlers\n                    handlers.addHandler(extensionUiContext);\n                }\n\n            }\n\n            // record all ui extensions to give to the web api\n            componentUiExtensions = new UiExtensionMapping(componentUiExtensionsByType);\n        } else {\n            componentUiExtensions = new UiExtensionMapping(Collections.EMPTY_MAP);\n        }\n\n        // load the web ui app\n        final WebAppContext webUiContext = loadWar(webUiWar, \"/nifi\", frameworkClassLoader);\n        webUiContext.getInitParams().put(\"oidc-supported\", String.valueOf(props.isOidcEnabled()));\n        webUiContext.getInitParams().put(\"knox-supported\", String.valueOf(props.isKnoxSsoEnabled()));\n        handlers.addHandler(webUiContext);\n\n        // load the web api app\n        webApiContext = loadWar(webApiWar, \"/nifi-api\", frameworkClassLoader);\n        handlers.addHandler(webApiContext);\n\n        // load the content viewer app\n        webContentViewerContext = loadWar(webContentViewerWar, \"/nifi-content-viewer\", frameworkClassLoader);\n        webContentViewerContext.getInitParams().putAll(mimeMappings);\n        handlers.addHandler(webContentViewerContext);\n\n        // create a web app for the docs\n        final String docsContextPath = \"/nifi-docs\";\n\n        // load the documentation war\n        webDocsContext = loadWar(webDocsWar, docsContextPath, frameworkClassLoader);\n\n        // overlay the actual documentation\n        final ContextHandlerCollection documentationHandlers = new ContextHandlerCollection();\n        documentationHandlers.addHandler(createDocsWebApp(docsContextPath));\n        documentationHandlers.addHandler(webDocsContext);\n        handlers.addHandler(documentationHandlers);\n\n        // load the web error app\n        final WebAppContext webErrorContext = loadWar(webErrorWar, \"/\", frameworkClassLoader);\n        webErrorContext.getInitParams().put(\"whitelistedContextPaths\", props.getWhitelistedContextPaths());\n        handlers.addHandler(webErrorContext);\n\n        // deploy the web apps\n        return gzip(handlers);\n    }\n\n    /**\n     * Returns whether or not the specified ui extensions already contains an extension of the specified type.\n     *\n     * @param componentUiExtensionsForType ui extensions for the type\n     * @param extensionType                type of ui extension\n     * @return whether or not the specified ui extensions already contains an extension of the specified type\n     */\n    private boolean containsUiExtensionType(final List<UiExtension> componentUiExtensionsForType, final UiExtensionType extensionType) {\n        for (final UiExtension uiExtension : componentUiExtensionsForType) {\n            if (extensionType.equals(uiExtension.getExtensionType())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Enables compression for the specified handler.\n     *\n     * @param handler handler to enable compression for\n     * @return compression enabled handler\n     */\n    private Handler gzip(final Handler handler) {\n        final GzipHandler gzip = new GzipHandler();\n        gzip.setIncludedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\");\n        gzip.setHandler(handler);\n        return gzip;\n    }\n\n    private Map<File, Bundle> findWars(final Set<Bundle> bundles) {\n        final Map<File, Bundle> wars = new HashMap<>();\n\n        // consider each nar working directory\n        bundles.forEach(bundle -> {\n            final BundleDetails details = bundle.getBundleDetails();\n            final File narDependencies = new File(details.getWorkingDirectory(), \"META-INF/bundled-dependencies\");\n            if (narDependencies.isDirectory()) {\n                // list the wars from this nar\n                final File[] narDependencyDirs = narDependencies.listFiles(WAR_FILTER);\n                if (narDependencyDirs == null) {\n                    throw new IllegalStateException(String.format(\"Unable to access working directory for NAR dependencies in: %s\", narDependencies.getAbsolutePath()));\n                }\n\n                // add each war\n                for (final File war : narDependencyDirs) {\n                    wars.put(war, bundle);\n                }\n            }\n        });\n\n        return wars;\n    }\n\n    private void readUiExtensions(final Map<UiExtensionType, List<String>> uiExtensions, final UiExtensionType uiExtensionType, final JarFile jarFile, final JarEntry jarEntry) throws IOException {\n        if (jarEntry == null) {\n            return;\n        }\n\n        // get an input stream for the nifi-processor configuration file\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(jarFile.getInputStream(jarEntry)))) {\n\n            // read in each configured type\n            String rawComponentType;\n            while ((rawComponentType = in.readLine()) != null) {\n                // extract the component type\n                final String componentType = extractComponentType(rawComponentType);\n                if (componentType != null) {\n                    List<String> extensions = uiExtensions.get(uiExtensionType);\n\n                    // if there are currently no extensions for this type create it\n                    if (extensions == null) {\n                        extensions = new ArrayList<>();\n                        uiExtensions.put(uiExtensionType, extensions);\n                    }\n\n                    // add the specified type\n                    extensions.add(componentType);\n                }\n            }\n        }\n    }\n\n    /**\n     * Identifies all known UI extensions and stores them in the specified map.\n     *\n     * @param uiExtensions extensions\n     * @param warFile      war\n     */\n    private void identifyUiExtensionsForComponents(final Map<UiExtensionType, List<String>> uiExtensions, final File warFile) {\n        try (final JarFile jarFile = new JarFile(warFile)) {\n            // locate the ui extensions\n            readUiExtensions(uiExtensions, UiExtensionType.ContentViewer, jarFile, jarFile.getJarEntry(\"META-INF/nifi-content-viewer\"));\n            readUiExtensions(uiExtensions, UiExtensionType.ProcessorConfiguration, jarFile, jarFile.getJarEntry(\"META-INF/nifi-processor-configuration\"));\n            readUiExtensions(uiExtensions, UiExtensionType.ControllerServiceConfiguration, jarFile, jarFile.getJarEntry(\"META-INF/nifi-controller-service-configuration\"));\n            readUiExtensions(uiExtensions, UiExtensionType.ReportingTaskConfiguration, jarFile, jarFile.getJarEntry(\"META-INF/nifi-reporting-task-configuration\"));\n        } catch (IOException ioe) {\n            logger.warn(String.format(\"Unable to inspect %s for a UI extensions.\", warFile));\n        }\n    }\n\n    /**\n     * Extracts the component type. Trims the line and considers comments.\n     * Returns null if no type was found.\n     *\n     * @param line line\n     * @return type\n     */\n    private String extractComponentType(final String line) {\n        final String trimmedLine = line.trim();\n        if (!trimmedLine.isEmpty() && !trimmedLine.startsWith(\"#\")) {\n            final int indexOfPound = trimmedLine.indexOf(\"#\");\n            return (indexOfPound > 0) ? trimmedLine.substring(0, indexOfPound) : trimmedLine;\n        }\n        return null;\n    }\n\n    private WebAppContext loadWar(final File warFile, final String contextPath, final ClassLoader parentClassLoader) {\n        final WebAppContext webappContext = new WebAppContext(warFile.getPath(), contextPath);\n        webappContext.setContextPath(contextPath);\n        webappContext.setDisplayName(contextPath);\n\n        // instruction jetty to examine these jars for tlds, web-fragments, etc\n        webappContext.setAttribute(\"org.eclipse.jetty.server.webapp.ContainerIncludeJarPattern\", \".*/[^/]*servlet-api-[^/]*\\\\.jar$|.*/javax.servlet.jsp.jstl-.*\\\\\\\\.jar$|.*/[^/]*taglibs.*\\\\.jar$\");\n\n        // remove slf4j server class to allow WAR files to have slf4j dependencies in WEB-INF/lib\n        List<String> serverClasses = new ArrayList<>(Arrays.asList(webappContext.getServerClasses()));\n        serverClasses.remove(\"org.slf4j.\");\n        webappContext.setServerClasses(serverClasses.toArray(new String[0]));\n        webappContext.setDefaultsDescriptor(WEB_DEFAULTS_XML);\n\n        // get the temp directory for this webapp\n        File tempDir = new File(props.getWebWorkingDirectory(), warFile.getName());\n        if (tempDir.exists() && !tempDir.isDirectory()) {\n            throw new RuntimeException(tempDir.getAbsolutePath() + \" is not a directory\");\n        } else if (!tempDir.exists()) {\n            final boolean made = tempDir.mkdirs();\n            if (!made) {\n                throw new RuntimeException(tempDir.getAbsolutePath() + \" could not be created\");\n            }\n        }\n        if (!(tempDir.canRead() && tempDir.canWrite())) {\n            throw new RuntimeException(tempDir.getAbsolutePath() + \" directory does not have read/write privilege\");\n        }\n\n        // configure the temp dir\n        webappContext.setTempDirectory(tempDir);\n\n        // configure the max form size (3x the default)\n        webappContext.setMaxFormContentSize(600000);\n\n        // add a filter to set the X-Frame-Options filter\n        webappContext.addFilter(new FilterHolder(FRAME_OPTIONS_FILTER), \"/*\", EnumSet.allOf(DispatcherType.class));\n\n        try {\n            // configure the class loader - webappClassLoader -> jetty nar -> web app's nar -> ...\n            webappContext.setClassLoader(new WebAppClassLoader(parentClassLoader, webappContext));\n        } catch (final IOException ioe) {\n            startUpFailure(ioe);\n        }\n\n        logger.info(\"Loading WAR: \" + warFile.getAbsolutePath() + \" with context path set to \" + contextPath);\n        return webappContext;\n    }\n\n    private ContextHandler createDocsWebApp(final String contextPath) {\n        try {\n            final ResourceHandler resourceHandler = new ResourceHandler();\n            resourceHandler.setDirectoriesListed(false);\n\n            final File docsDir = getDocsDir(\"docs\");\n            final Resource docsResource = Resource.newResource(docsDir);\n\n            // load the component documentation working directory\n            final File componentDocsDirPath = props.getComponentDocumentationWorkingDirectory();\n            final File workingDocsDirectory = getWorkingDocsDirectory(componentDocsDirPath);\n            final Resource workingDocsResource = Resource.newResource(workingDocsDirectory);\n\n            final File webApiDocsDir = getWebApiDocsDir();\n            final Resource webApiDocsResource = Resource.newResource(webApiDocsDir);\n\n            // create resources for both docs locations\n            final ResourceCollection resources = new ResourceCollection(docsResource, workingDocsResource, webApiDocsResource);\n            resourceHandler.setBaseResource(resources);\n\n            // create the context handler\n            final ContextHandler handler = new ContextHandler(contextPath);\n            handler.setHandler(resourceHandler);\n\n            logger.info(\"Loading documents web app with context path set to \" + contextPath);\n            return handler;\n        } catch (Exception ex) {\n            logger.error(\"Unhandled Exception in createDocsWebApp: \" + ex.getMessage());\n            startUpFailure(ex);\n            return null;    // required by compiler, though never be executed.\n        }\n    }\n\n    /**\n     * Returns a File object for the directory containing NIFI documentation.\n     * <p>\n     * Formerly, if the docsDirectory did not exist NIFI would fail to start\n     * with an IllegalStateException and a rather unhelpful log message.\n     * NIFI-2184 updates the process such that if the docsDirectory does not\n     * exist an attempt will be made to create the directory. If that is\n     * successful NIFI will no longer fail and will start successfully barring\n     * any other errors. The side effect of the docsDirectory not being present\n     * is that the documentation links under the 'General' portion of the help\n     * page will not be accessible, but at least the process will be running.\n     *\n     * @param docsDirectory Name of documentation directory in installation directory.\n     * @return A File object to the documentation directory; else startUpFailure called.\n     */\n    private File getDocsDir(final String docsDirectory) {\n        File docsDir;\n        try {\n            docsDir = Paths.get(docsDirectory).toRealPath().toFile();\n        } catch (IOException ex) {\n            logger.info(\"Directory '\" + docsDirectory + \"' is missing. Some documentation will be unavailable.\");\n            docsDir = new File(docsDirectory).getAbsoluteFile();\n            final boolean made = docsDir.mkdirs();\n            if (!made) {\n                logger.error(\"Failed to create 'docs' directory!\");\n                startUpFailure(new IOException(docsDir.getAbsolutePath() + \" could not be created\"));\n            }\n        }\n        return docsDir;\n    }\n\n    private File getWorkingDocsDirectory(final File componentDocsDirPath) {\n        File workingDocsDirectory = null;\n        try {\n            workingDocsDirectory = componentDocsDirPath.toPath().toRealPath().getParent().toFile();\n        } catch (IOException ex) {\n            logger.error(\"Failed to load :\" + componentDocsDirPath.getAbsolutePath());\n            startUpFailure(ex);\n        }\n        return workingDocsDirectory;\n    }\n\n    private File getWebApiDocsDir() {\n        // load the rest documentation\n        final File webApiDocsDir = new File(webApiContext.getTempDirectory(), \"webapp/docs\");\n        if (!webApiDocsDir.exists()) {\n            final boolean made = webApiDocsDir.mkdirs();\n            if (!made) {\n                logger.error(\"Failed to create \" + webApiDocsDir.getAbsolutePath());\n                startUpFailure(new IOException(webApiDocsDir.getAbsolutePath() + \" could not be created\"));\n            }\n        }\n        return webApiDocsDir;\n    }\n\n    private void configureConnectors(final Server server) throws ServerConfigurationException {\n        // create the http configuration\n        final HttpConfiguration httpConfiguration = new HttpConfiguration();\n        final int headerSize = DataUnit.parseDataSize(props.getWebMaxHeaderSize(), DataUnit.B).intValue();\n        httpConfiguration.setRequestHeaderSize(headerSize);\n        httpConfiguration.setResponseHeaderSize(headerSize);\n\n        // Check if both HTTP and HTTPS connectors are configured and fail if both are configured\n        if (bothHttpAndHttpsConnectorsConfigured(props)) {\n            logger.error(\"NiFi only supports one mode of HTTP or HTTPS operation, not both simultaneously. \" +\n                    \"Check the nifi.properties file and ensure that either the HTTP hostname and port or the HTTPS hostname and port are empty\");\n            startUpFailure(new IllegalStateException(\"Only one of the HTTP and HTTPS connectors can be configured at one time\"));\n        }\n\n        if (props.getSslPort() != null) {\n            configureHttpsConnector(server, httpConfiguration);\n        } else if (props.getPort() != null) {\n            configureHttpConnector(server, httpConfiguration);\n        } else {\n            logger.error(\"Neither the HTTP nor HTTPS connector was configured in nifi.properties\");\n            startUpFailure(new IllegalStateException(\"Must configure HTTP or HTTPS connector\"));\n        }\n    }\n\n    /**\n     * Configures an HTTPS connector and adds it to the server.\n     *\n     * @param server            the Jetty server instance\n     * @param httpConfiguration the configuration object for the HTTPS protocol settings\n     */\n    private void configureHttpsConnector(Server server, HttpConfiguration httpConfiguration) {\n        String hostname = props.getProperty(NiFiProperties.WEB_HTTPS_HOST);\n        final Integer port = props.getSslPort();\n        String connectorLabel = \"HTTPS\";\n        final Map<String, String> httpsNetworkInterfaces = props.getHttpsNetworkInterfaces();\n        ServerConnectorCreator<Server, HttpConfiguration, ServerConnector> scc = (s, c) -> createUnconfiguredSslServerConnector(s, c, port);\n\n        configureGenericConnector(server, httpConfiguration, hostname, port, connectorLabel, httpsNetworkInterfaces, scc);\n    }\n\n    /**\n     * Configures an HTTP connector and adds it to the server.\n     *\n     * @param server            the Jetty server instance\n     * @param httpConfiguration the configuration object for the HTTP protocol settings\n     */\n    private void configureHttpConnector(Server server, HttpConfiguration httpConfiguration) {\n        String hostname = props.getProperty(NiFiProperties.WEB_HTTP_HOST);\n        final Integer port = props.getPort();\n        String connectorLabel = \"HTTP\";\n        final Map<String, String> httpNetworkInterfaces = props.getHttpNetworkInterfaces();\n        ServerConnectorCreator<Server, HttpConfiguration, ServerConnector> scc = (s, c) -> new ServerConnector(s, new HttpConnectionFactory(c));\n\n        configureGenericConnector(server, httpConfiguration, hostname, port, connectorLabel, httpNetworkInterfaces, scc);\n    }\n\n    /**\n     * Configures an HTTP(S) connector for the server given the provided parameters. The functionality between HTTP and HTTPS connectors is largely similar.\n     * Here the common behavior has been extracted into a shared method and the respective calling methods obtain the right values and a lambda function for the differing behavior.\n     *\n     * @param server                 the Jetty server instance\n     * @param configuration          the HTTP/HTTPS configuration instance\n     * @param hostname               the hostname from the nifi.properties file\n     * @param port                   the port to expose\n     * @param connectorLabel         used for log output (e.g. \"HTTP\" or \"HTTPS\")\n     * @param networkInterfaces      the map of network interfaces from nifi.properties\n     * @param serverConnectorCreator a function which accepts a {@code Server} and {@code HttpConnection} instance and returns a {@code ServerConnector}\n     */\n    private void configureGenericConnector(Server server, HttpConfiguration configuration, String hostname, Integer port, String connectorLabel, Map<String, String> networkInterfaces,\n                                           ServerConnectorCreator<Server, HttpConfiguration, ServerConnector> serverConnectorCreator) {\n        if (port < 0 || (int) Math.pow(2, 16) <= port) {\n            throw new ServerConfigurationException(\"Invalid \" + connectorLabel + \" port: \" + port);\n        }\n\n        logger.info(\"Configuring Jetty for \" + connectorLabel + \" on port: \" + port);\n\n        final List<Connector> serverConnectors = Lists.newArrayList();\n\n        // Calculate Idle Timeout as twice the auto-refresh interval. This ensures that even with some variance in timing,\n        // we are able to avoid closing connections from users' browsers most of the time. This can make a significant difference\n        // in HTTPS connections, as each HTTPS connection that is established must perform the SSL handshake.\n        final String autoRefreshInterval = props.getAutoRefreshInterval();\n        final long autoRefreshMillis = autoRefreshInterval == null ? 30000L : FormatUtils.getTimeDuration(autoRefreshInterval, TimeUnit.MILLISECONDS);\n        final long idleTimeout = autoRefreshMillis * 2;\n\n        // If the interfaces collection is empty or each element is empty\n        if (networkInterfaces.isEmpty() || networkInterfaces.values().stream().filter(value -> !Strings.isNullOrEmpty(value)).collect(Collectors.toList()).isEmpty()) {\n            final ServerConnector serverConnector = serverConnectorCreator.create(server, configuration);\n\n            // Set host and port\n            if (StringUtils.isNotBlank(hostname)) {\n                serverConnector.setHost(hostname);\n            }\n            serverConnector.setPort(port);\n            serverConnector.setIdleTimeout(idleTimeout);\n            serverConnectors.add(serverConnector);\n        } else {\n            // Add connectors for all IPs from network interfaces\n            serverConnectors.addAll(Lists.newArrayList(networkInterfaces.values().stream().map(ifaceName -> {\n                NetworkInterface iface = null;\n                try {\n                    iface = NetworkInterface.getByName(ifaceName);\n                } catch (SocketException e) {\n                    logger.error(\"Unable to get network interface by name {}\", ifaceName, e);\n                }\n                if (iface == null) {\n                    logger.warn(\"Unable to find network interface named {}\", ifaceName);\n                }\n                return iface;\n            }).filter(Objects::nonNull).flatMap(iface -> Collections.list(iface.getInetAddresses()).stream())\n                    .map(inetAddress -> {\n                        final ServerConnector serverConnector = serverConnectorCreator.create(server, configuration);\n\n                        // Set host and port\n                        serverConnector.setHost(inetAddress.getHostAddress());\n                        serverConnector.setPort(port);\n                        serverConnector.setIdleTimeout(idleTimeout);\n\n                        return serverConnector;\n                    }).collect(Collectors.toList())));\n        }\n        // Add all connectors\n        serverConnectors.forEach(server::addConnector);\n    }\n\n    /**\n     * Returns true if there are configured properties for both HTTP and HTTPS connectors (specifically port because the hostname can be left blank in the HTTP connector).\n     * Prints a warning log message with the relevant properties.\n     *\n     * @param props the NiFiProperties\n     * @return true if both ports are present\n     */\n    static boolean bothHttpAndHttpsConnectorsConfigured(NiFiProperties props) {\n        Integer httpPort = props.getPort();\n        String httpHostname = props.getProperty(NiFiProperties.WEB_HTTP_HOST);\n\n        Integer httpsPort = props.getSslPort();\n        String httpsHostname = props.getProperty(NiFiProperties.WEB_HTTPS_HOST);\n\n        if (httpPort != null && httpsPort != null) {\n            logger.warn(\"Both the HTTP and HTTPS connectors are configured in nifi.properties. Only one of these connectors should be configured. See the NiFi Admin Guide for more details\");\n            logger.warn(\"HTTP connector:   http://\" + httpHostname + \":\" + httpPort);\n            logger.warn(\"HTTPS connector: https://\" + httpsHostname + \":\" + httpsPort);\n            return true;\n        }\n\n        return false;\n    }\n\n    private ServerConnector createUnconfiguredSslServerConnector(Server server, HttpConfiguration httpConfiguration, int port) {\n        // add some secure config\n        final HttpConfiguration httpsConfiguration = new HttpConfiguration(httpConfiguration);\n        httpsConfiguration.setSecureScheme(\"https\");\n        httpsConfiguration.setSecurePort(port);\n        httpsConfiguration.addCustomizer(new SecureRequestCustomizer());\n\n        // build the connector\n        return new ServerConnector(server,\n                new SslConnectionFactory(createSslContextFactory(), \"http/1.1\"),\n                new HttpConnectionFactory(httpsConfiguration));\n    }\n\n    private SslContextFactory createSslContextFactory() {\n        final SslContextFactory contextFactory = new SslContextFactory();\n        configureSslContextFactory(contextFactory, props);\n        return contextFactory;\n    }\n\n    protected static void configureSslContextFactory(SslContextFactory contextFactory, NiFiProperties props) {\n        // require client auth when not supporting login, Kerberos service, or anonymous access\n        if (props.isClientAuthRequiredForRestApi()) {\n            contextFactory.setNeedClientAuth(true);\n        } else {\n            contextFactory.setWantClientAuth(true);\n        }\n\n        /* below code sets JSSE system properties when values are provided */\n        // keystore properties\n        if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.SECURITY_KEYSTORE))) {\n            contextFactory.setKeyStorePath(props.getProperty(NiFiProperties.SECURITY_KEYSTORE));\n        }\n        String keyStoreType = props.getProperty(NiFiProperties.SECURITY_KEYSTORE_TYPE);\n        if (StringUtils.isNotBlank(keyStoreType)) {\n            contextFactory.setKeyStoreType(keyStoreType);\n            String keyStoreProvider = KeyStoreUtils.getKeyStoreProvider(keyStoreType);\n            if (StringUtils.isNoneEmpty(keyStoreProvider)) {\n                contextFactory.setKeyStoreProvider(keyStoreProvider);\n            }\n        }\n        final String keystorePassword = props.getProperty(NiFiProperties.SECURITY_KEYSTORE_PASSWD);\n        final String keyPassword = props.getProperty(NiFiProperties.SECURITY_KEY_PASSWD);\n        if (StringUtils.isNotBlank(keystorePassword)) {\n            // if no key password was provided, then assume the keystore password is the same as the key password.\n            final String defaultKeyPassword = (StringUtils.isBlank(keyPassword)) ? keystorePassword : keyPassword;\n            contextFactory.setKeyStorePassword(keystorePassword);\n            contextFactory.setKeyManagerPassword(defaultKeyPassword);\n        } else if (StringUtils.isNotBlank(keyPassword)) {\n            // since no keystore password was provided, there will be no keystore integrity check\n            contextFactory.setKeyManagerPassword(keyPassword);\n        }\n\n        // truststore properties\n        if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE))) {\n            contextFactory.setTrustStorePath(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE));\n        }\n        String trustStoreType = props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE_TYPE);\n        if (StringUtils.isNotBlank(trustStoreType)) {\n            contextFactory.setTrustStoreType(trustStoreType);\n            String trustStoreProvider = KeyStoreUtils.getKeyStoreProvider(trustStoreType);\n            if (StringUtils.isNoneEmpty(trustStoreProvider)) {\n                contextFactory.setTrustStoreProvider(trustStoreProvider);\n            }\n        }\n        if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE_PASSWD))) {\n            contextFactory.setTrustStorePassword(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE_PASSWD));\n        }\n    }\n\n    @Override\n    public void start() {\n        try {\n            ExtensionManager.discoverExtensions(systemBundle, bundles);\n            ExtensionManager.logClassLoaderMapping();\n\n            DocGenerator.generate(props, extensionMapping);\n\n            // start the server\n            server.start();\n\n            // ensure everything started successfully\n            for (Handler handler : server.getChildHandlers()) {\n                // see if the handler is a web app\n                if (handler instanceof WebAppContext) {\n                    WebAppContext context = (WebAppContext) handler;\n\n                    // see if this webapp had any exceptions that would\n                    // cause it to be unavailable\n                    if (context.getUnavailableException() != null) {\n                        startUpFailure(context.getUnavailableException());\n                    }\n                }\n            }\n\n            // ensure the appropriate wars deployed successfully before injecting the NiFi context and security filters\n            // this must be done after starting the server (and ensuring there were no start up failures)\n            if (webApiContext != null) {\n                // give the web api the component ui extensions\n                final ServletContext webApiServletContext = webApiContext.getServletHandler().getServletContext();\n                webApiServletContext.setAttribute(\"nifi-ui-extensions\", componentUiExtensions);\n\n                // get the application context\n                final WebApplicationContext webApplicationContext = WebApplicationContextUtils.getRequiredWebApplicationContext(webApiServletContext);\n\n                // component ui extensions\n                if (CollectionUtils.isNotEmpty(componentUiExtensionWebContexts)) {\n                    final NiFiWebConfigurationContext configurationContext = webApplicationContext.getBean(\"nifiWebConfigurationContext\", NiFiWebConfigurationContext.class);\n\n                    for (final WebAppContext customUiContext : componentUiExtensionWebContexts) {\n                        // set the NiFi context in each custom ui servlet context\n                        final ServletContext customUiServletContext = customUiContext.getServletHandler().getServletContext();\n                        customUiServletContext.setAttribute(\"nifi-web-configuration-context\", configurationContext);\n\n                        // add the security filter to any ui extensions wars\n                        final FilterHolder securityFilter = webApiContext.getServletHandler().getFilter(\"springSecurityFilterChain\");\n                        if (securityFilter != null) {\n                            customUiContext.addFilter(securityFilter, \"/*\", EnumSet.allOf(DispatcherType.class));\n                        }\n                    }\n                }\n\n                // content viewer extensions\n                if (CollectionUtils.isNotEmpty(contentViewerWebContexts)) {\n                    for (final WebAppContext contentViewerContext : contentViewerWebContexts) {\n                        // add the security filter to any content viewer  wars\n                        final FilterHolder securityFilter = webApiContext.getServletHandler().getFilter(\"springSecurityFilterChain\");\n                        if (securityFilter != null) {\n                            contentViewerContext.addFilter(securityFilter, \"/*\", EnumSet.allOf(DispatcherType.class));\n                        }\n                    }\n                }\n\n                // content viewer controller\n                if (webContentViewerContext != null) {\n                    final ContentAccess contentAccess = webApplicationContext.getBean(\"contentAccess\", ContentAccess.class);\n\n                    // add the content access\n                    final ServletContext webContentViewerServletContext = webContentViewerContext.getServletHandler().getServletContext();\n                    webContentViewerServletContext.setAttribute(\"nifi-content-access\", contentAccess);\n\n                    final FilterHolder securityFilter = webApiContext.getServletHandler().getFilter(\"springSecurityFilterChain\");\n                    if (securityFilter != null) {\n                        webContentViewerContext.addFilter(securityFilter, \"/*\", EnumSet.allOf(DispatcherType.class));\n                    }\n                }\n            }\n\n            // ensure the web document war was loaded and provide the extension mapping\n            if (webDocsContext != null) {\n                final ServletContext webDocsServletContext = webDocsContext.getServletHandler().getServletContext();\n                webDocsServletContext.setAttribute(\"nifi-extension-mapping\", extensionMapping);\n            }\n\n            // if this nifi is a node in a cluster, start the flow service and load the flow - the\n            // flow service is loaded here for clustered nodes because the loading of the flow will\n            // initialize the connection between the node and the NCM. if the node connects (starts\n            // heartbeating, etc), the NCM may issue web requests before the application (wars) have\n            // finished loading. this results in the node being disconnected since its unable to\n            // successfully respond to the requests. to resolve this, flow loading was moved to here\n            // (after the wars have been successfully deployed) when this nifi instance is a node\n            // in a cluster\n            if (props.isNode()) {\n\n                FlowService flowService = null;\n                try {\n\n                    logger.info(\"Loading Flow...\");\n\n                    ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(webApiContext.getServletContext());\n                    flowService = ctx.getBean(\"flowService\", FlowService.class);\n\n                    // start and load the flow\n                    flowService.start();\n                    flowService.load(null);\n\n                    logger.info(\"Flow loaded successfully.\");\n\n                } catch (BeansException | LifeCycleStartException | IOException | FlowSerializationException | FlowSynchronizationException | UninheritableFlowException e) {\n                    // ensure the flow service is terminated\n                    if (flowService != null && flowService.isRunning()) {\n                        flowService.stop(false);\n                    }\n                    logger.error(\"Unable to load flow due to: \" + e, e);\n                    throw new Exception(\"Unable to load flow due to: \" + e); // cannot wrap the exception as they are not defined in a classloader accessible to the caller\n                }\n            }\n\n            // dump the application url after confirming everything started successfully\n            dumpUrls();\n        } catch (Exception ex) {\n            startUpFailure(ex);\n        }\n    }\n\n    private void dumpUrls() throws SocketException {\n        final List<String> urls = new ArrayList<>();\n\n        for (Connector connector : server.getConnectors()) {\n            if (connector instanceof ServerConnector) {\n                final ServerConnector serverConnector = (ServerConnector) connector;\n\n                Set<String> hosts = new HashSet<>();\n\n                // determine the hosts\n                if (StringUtils.isNotBlank(serverConnector.getHost())) {\n                    hosts.add(serverConnector.getHost());\n                } else {\n                    Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();\n                    if (networkInterfaces != null) {\n                        for (NetworkInterface networkInterface : Collections.list(networkInterfaces)) {\n                            for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {\n                                hosts.add(inetAddress.getHostAddress());\n                            }\n                        }\n                    }\n                }\n\n                // ensure some hosts were found\n                if (!hosts.isEmpty()) {\n                    String scheme = \"http\";\n                    if (props.getSslPort() != null && serverConnector.getPort() == props.getSslPort()) {\n                        scheme = \"https\";\n                    }\n\n                    // dump each url\n                    for (String host : hosts) {\n                        urls.add(String.format(\"%s://%s:%s\", scheme, host, serverConnector.getPort()));\n                    }\n                }\n            }\n        }\n\n        if (urls.isEmpty()) {\n            logger.warn(\"NiFi has started, but the UI is not available on any hosts. Please verify the host properties.\");\n        } else {\n            // log the ui location\n            logger.info(\"NiFi has started. The UI is available at the following URLs:\");\n            for (final String url : urls) {\n                logger.info(String.format(\"%s/nifi\", url));\n            }\n        }\n    }\n\n    private void startUpFailure(Throwable t) {\n        System.err.println(\"Failed to start web server: \" + t.getMessage());\n        System.err.println(\"Shutting down...\");\n        logger.warn(\"Failed to start web server... shutting down.\", t);\n        System.exit(1);\n    }\n\n    @Override\n    public void setExtensionMapping(ExtensionMapping extensionMapping) {\n        this.extensionMapping = extensionMapping;\n    }\n\n    @Override\n    public void setBundles(Bundle systemBundle, Set<Bundle> bundles) {\n        this.systemBundle = systemBundle;\n        this.bundles = bundles;\n    }\n\n    @Override\n    public void stop() {\n        try {\n            server.stop();\n        } catch (Exception ex) {\n            logger.warn(\"Failed to stop web server\", ex);\n        }\n    }\n\n    private static final Filter FRAME_OPTIONS_FILTER = new Filter() {\n        private static final String FRAME_OPTIONS = \"X-Frame-Options\";\n        private static final String SAME_ORIGIN = \"SAMEORIGIN\";\n\n        @Override\n        public void doFilter(final ServletRequest req, final ServletResponse resp, final FilterChain filterChain)\n                throws IOException, ServletException {\n\n            // set frame options accordingly\n            final HttpServletResponse response = (HttpServletResponse) resp;\n            response.setHeader(FRAME_OPTIONS, SAME_ORIGIN);\n\n            filterChain.doFilter(req, resp);\n        }\n\n        @Override\n        public void init(final FilterConfig config) {\n        }\n\n        @Override\n        public void destroy() {\n        }\n    };\n}\n\n@FunctionalInterface\ninterface ServerConnectorCreator<Server, HttpConfiguration, ServerConnector> {\n    ServerConnector create(Server server, HttpConfiguration httpConfiguration);\n}",
    "target": 0,
    "language": "java",
    "dataset": "A-Manually-Curated-Dataset-of-Vulnerability-Introducing-Commits-in-Java",
    "idx": 800075,
    "RELATED_CWE": [
      "CWE-311",
      "CWE-532",
      "CWE-863"
    ]
  }
]