[
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.plugins.signing.signatory.pgp;\n\nimport org.bouncycastle.bcpg.BCPGOutputStream;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPException;\nimport org.bouncycastle.openpgp.PGPPrivateKey;\nimport org.bouncycastle.openpgp.PGPSecretKey;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.PBESecretKeyDecryptor;\nimport org.bouncycastle.openpgp.operator.bc.BcPBESecretKeyDecryptorBuilder;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider;\nimport org.gradle.api.UncheckedIOException;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.plugins.signing.signatory.SignatorySupport;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.Security;\n\n/**\n * PGP signatory from PGP key and password.\n */\npublic class PgpSignatory extends SignatorySupport {\n\n    {\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    private final String name;\n    private final PGPSecretKey secretKey;\n    private final PGPPrivateKey privateKey;\n\n    public PgpSignatory(String name, PGPSecretKey secretKey, String password) {\n        this.name = name;\n        this.secretKey = secretKey;\n        this.privateKey = createPrivateKey(secretKey, password);\n    }\n\n    @Override\n    public final String getName() {\n        return name;\n    }\n\n    /**\n     * Exhausts {@code toSign}, and writes the signature to {@code signatureDestination}.\n     *\n     * The caller is responsible for closing the streams, though the output WILL be flushed.\n     */\n    @Override\n    public void sign(InputStream toSign, OutputStream signatureDestination) {\n        PGPSignatureGenerator generator = createSignatureGenerator();\n        try {\n            feedGeneratorWith(toSign, generator);\n\n            PGPSignature signature = generator.generate();\n            writeSignatureTo(signatureDestination, signature);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    @Override\n    public String getKeyId() {\n        PgpKeyId id = new PgpKeyId(secretKey.getKeyID());\n        return id == null ? null : id.getAsHex();\n    }\n\n    private void feedGeneratorWith(InputStream toSign, PGPSignatureGenerator generator) throws IOException {\n        byte[] buffer = new byte[1024];\n        int read = toSign.read(buffer);\n        while (read > 0) {\n            generator.update(buffer, 0, read);\n            read = toSign.read(buffer);\n        }\n    }\n\n    private void writeSignatureTo(OutputStream signatureDestination, PGPSignature pgpSignature) throws PGPException, IOException {\n        // BCPGOutputStream seems to do some internal buffering, it's unclear whether it's strictly required here though\n        BCPGOutputStream bufferedOutput = new BCPGOutputStream(signatureDestination);\n        pgpSignature.encode(bufferedOutput);\n        bufferedOutput.flush();\n    }\n\n    public PGPSignatureGenerator createSignatureGenerator() {\n        try {\n            PGPSignatureGenerator generator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(secretKey.getPublicKey().getAlgorithm(), PGPUtil.SHA1));\n            generator.init(PGPSignature.BINARY_DOCUMENT, privateKey);\n            return generator;\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    private PGPPrivateKey createPrivateKey(PGPSecretKey secretKey, String password) {\n        try {\n            PBESecretKeyDecryptor decryptor = new BcPBESecretKeyDecryptorBuilder(new BcPGPDigestCalculatorProvider()).build(password.toCharArray());\n            return secretKey.extractPrivateKey(decryptor);\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700128,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.plugins.signing.signatory.pgp;\n\nimport org.bouncycastle.bcpg.BCPGOutputStream;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPException;\nimport org.bouncycastle.openpgp.PGPPrivateKey;\nimport org.bouncycastle.openpgp.PGPSecretKey;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.PBESecretKeyDecryptor;\nimport org.bouncycastle.openpgp.operator.bc.BcPBESecretKeyDecryptorBuilder;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider;\nimport org.gradle.api.UncheckedIOException;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.plugins.signing.signatory.SignatorySupport;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.Security;\n\n/**\n * PGP signatory from PGP key and password.\n */\npublic class PgpSignatory extends SignatorySupport {\n\n    {\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    private final String name;\n    private final PGPSecretKey secretKey;\n    private final PGPPrivateKey privateKey;\n\n    public PgpSignatory(String name, PGPSecretKey secretKey, String password) {\n        this.name = name;\n        this.secretKey = secretKey;\n        this.privateKey = createPrivateKey(secretKey, password);\n    }\n\n    @Override\n    public final String getName() {\n        return name;\n    }\n\n    /**\n     * Exhausts {@code toSign}, and writes the signature to {@code signatureDestination}.\n     *\n     * The caller is responsible for closing the streams, though the output WILL be flushed.\n     */\n    @Override\n    public void sign(InputStream toSign, OutputStream signatureDestination) {\n        PGPSignatureGenerator generator = createSignatureGenerator();\n        try {\n            feedGeneratorWith(toSign, generator);\n\n            PGPSignature signature = generator.generate();\n            writeSignatureTo(signatureDestination, signature);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    @Override\n    public String getKeyId() {\n        PgpKeyId id = new PgpKeyId(secretKey.getKeyID());\n        return id == null ? null : id.getAsHex();\n    }\n\n    private void feedGeneratorWith(InputStream toSign, PGPSignatureGenerator generator) throws IOException {\n        byte[] buffer = new byte[1024];\n        int read = toSign.read(buffer);\n        while (read > 0) {\n            generator.update(buffer, 0, read);\n            read = toSign.read(buffer);\n        }\n    }\n\n    private void writeSignatureTo(OutputStream signatureDestination, PGPSignature pgpSignature) throws PGPException, IOException {\n        // BCPGOutputStream seems to do some internal buffering, it's unclear whether it's strictly required here though\n        BCPGOutputStream bufferedOutput = new BCPGOutputStream(signatureDestination);\n        pgpSignature.encode(bufferedOutput);\n        bufferedOutput.flush();\n    }\n\n    public PGPSignatureGenerator createSignatureGenerator() {\n        try {\n            PGPSignatureGenerator generator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(secretKey.getPublicKey().getAlgorithm(), PGPUtil.SHA512));\n            generator.init(PGPSignature.BINARY_DOCUMENT, privateKey);\n            return generator;\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    private PGPPrivateKey createPrivateKey(PGPSecretKey secretKey, String password) {\n        try {\n            PBESecretKeyDecryptor decryptor = new BcPBESecretKeyDecryptorBuilder(new BcPGPDigestCalculatorProvider()).build(password.toCharArray());\n            return secretKey.extractPrivateKey(decryptor);\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700129,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.plugins.signing.signatory.pgp;\n\nimport org.bouncycastle.bcpg.BCPGOutputStream;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPException;\nimport org.bouncycastle.openpgp.PGPPrivateKey;\nimport org.bouncycastle.openpgp.PGPSecretKey;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.PBESecretKeyDecryptor;\nimport org.bouncycastle.openpgp.operator.bc.BcPBESecretKeyDecryptorBuilder;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider;\nimport org.gradle.api.UncheckedIOException;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.plugins.signing.signatory.SignatorySupport;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.Security;\n\n/**\n * PGP signatory from PGP key and password.\n */\npublic class PgpSignatory extends SignatorySupport {\n\n    {\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    private final String name;\n    private final PGPSecretKey secretKey;\n    private final PGPPrivateKey privateKey;\n\n    public PgpSignatory(String name, PGPSecretKey secretKey, String password) {\n        this.name = name;\n        this.secretKey = secretKey;\n        this.privateKey = createPrivateKey(secretKey, password);\n    }\n\n    @Override\n    public final String getName() {\n        return name;\n    }\n\n    /**\n     * Exhausts {@code toSign}, and writes the signature to {@code signatureDestination}.\n     *\n     * The caller is responsible for closing the streams, though the output WILL be flushed.\n     */\n    @Override\n    public void sign(InputStream toSign, OutputStream signatureDestination) {\n        PGPSignatureGenerator generator = createSignatureGenerator();\n        try {\n            feedGeneratorWith(toSign, generator);\n\n            PGPSignature signature = generator.generate();\n            writeSignatureTo(signatureDestination, signature);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    @Override\n    public String getKeyId() {\n        PgpKeyId id = new PgpKeyId(secretKey.getKeyID());\n        return id == null ? null : id.getAsHex();\n    }\n\n    private void feedGeneratorWith(InputStream toSign, PGPSignatureGenerator generator) throws IOException {\n        byte[] buffer = new byte[1024];\n        int read = toSign.read(buffer);\n        while (read > 0) {\n            generator.update(buffer, 0, read);\n            read = toSign.read(buffer);\n        }\n    }\n\n    private void writeSignatureTo(OutputStream signatureDestination, PGPSignature pgpSignature) throws PGPException, IOException {\n        // BCPGOutputStream seems to do some internal buffering, it's unclear whether it's strictly required here though\n        BCPGOutputStream bufferedOutput = new BCPGOutputStream(signatureDestination);\n        pgpSignature.encode(bufferedOutput);\n        bufferedOutput.flush();\n    }\n\n    public PGPSignatureGenerator createSignatureGenerator() {\n        try {\n            PGPSignatureGenerator generator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(secretKey.getPublicKey().getAlgorithm(), PGPUtil.SHA1));\n            generator.init(PGPSignature.BINARY_DOCUMENT, privateKey);\n            return generator;\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    private PGPPrivateKey createPrivateKey(PGPSecretKey secretKey, String password) {\n        try {\n            PBESecretKeyDecryptor decryptor = new BcPBESecretKeyDecryptorBuilder(new BcPGPDigestCalculatorProvider()).build(password.toCharArray());\n            return secretKey.extractPrivateKey(decryptor);\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n}\n",
    "target": 1,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700130,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.plugins.signing.signatory.pgp;\n\nimport org.bouncycastle.bcpg.BCPGOutputStream;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPException;\nimport org.bouncycastle.openpgp.PGPPrivateKey;\nimport org.bouncycastle.openpgp.PGPSecretKey;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.PBESecretKeyDecryptor;\nimport org.bouncycastle.openpgp.operator.bc.BcPBESecretKeyDecryptorBuilder;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider;\nimport org.gradle.api.UncheckedIOException;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.plugins.signing.signatory.SignatorySupport;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.Security;\n\n/**\n * PGP signatory from PGP key and password.\n */\npublic class PgpSignatory extends SignatorySupport {\n\n    {\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    private final String name;\n    private final PGPSecretKey secretKey;\n    private final PGPPrivateKey privateKey;\n\n    public PgpSignatory(String name, PGPSecretKey secretKey, String password) {\n        this.name = name;\n        this.secretKey = secretKey;\n        this.privateKey = createPrivateKey(secretKey, password);\n    }\n\n    @Override\n    public final String getName() {\n        return name;\n    }\n\n    /**\n     * Exhausts {@code toSign}, and writes the signature to {@code signatureDestination}.\n     *\n     * The caller is responsible for closing the streams, though the output WILL be flushed.\n     */\n    @Override\n    public void sign(InputStream toSign, OutputStream signatureDestination) {\n        PGPSignatureGenerator generator = createSignatureGenerator();\n        try {\n            feedGeneratorWith(toSign, generator);\n\n            PGPSignature signature = generator.generate();\n            writeSignatureTo(signatureDestination, signature);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    @Override\n    public String getKeyId() {\n        PgpKeyId id = new PgpKeyId(secretKey.getKeyID());\n        return id == null ? null : id.getAsHex();\n    }\n\n    private void feedGeneratorWith(InputStream toSign, PGPSignatureGenerator generator) throws IOException {\n        byte[] buffer = new byte[1024];\n        int read = toSign.read(buffer);\n        while (read > 0) {\n            generator.update(buffer, 0, read);\n            read = toSign.read(buffer);\n        }\n    }\n\n    private void writeSignatureTo(OutputStream signatureDestination, PGPSignature pgpSignature) throws PGPException, IOException {\n        // BCPGOutputStream seems to do some internal buffering, it's unclear whether it's strictly required here though\n        BCPGOutputStream bufferedOutput = new BCPGOutputStream(signatureDestination);\n        pgpSignature.encode(bufferedOutput);\n        bufferedOutput.flush();\n    }\n\n    public PGPSignatureGenerator createSignatureGenerator() {\n        try {\n            PGPSignatureGenerator generator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(secretKey.getPublicKey().getAlgorithm(), PGPUtil.SHA512));\n            generator.init(PGPSignature.BINARY_DOCUMENT, privateKey);\n            return generator;\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    private PGPPrivateKey createPrivateKey(PGPSecretKey secretKey, String password) {\n        try {\n            PBESecretKeyDecryptor decryptor = new BcPBESecretKeyDecryptorBuilder(new BcPGPDigestCalculatorProvider()).build(password.toCharArray());\n            return secretKey.extractPrivateKey(decryptor);\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n}\n",
    "target": 0,
    "language": "java",
    "dataset": "TreeVul",
    "idx": 700131,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  }
]