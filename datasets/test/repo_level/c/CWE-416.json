[
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int __class_reset_perm_values(__attribute__((unused)) hashtab_key_t k, hashtab_datum_t d, void *args)\n{\n\tstruct cil_perm *perm = (struct cil_perm *)d;\n\n\tperm->value -= *((int *)args);\n\n\treturn SEPOL_OK;\n}\n\nint hashtab_map(hashtab_t h,\n\t\tint (*apply) (hashtab_key_t k,\n\t\t\t      hashtab_datum_t d, void *args), void *args)\n{\n\tunsigned int i, ret;\n\thashtab_ptr_t cur;\n\n\tif (!h)\n\t\treturn SEPOL_OK;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur != NULL) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn SEPOL_OK;\n}\n\nint cil_symtab_map(symtab_t *symtab,\n\t\t\t\t   int (*apply) (hashtab_key_t k, hashtab_datum_t d, void *args),\n\t\t\t\t   void *args)\n{\n\treturn hashtab_map(symtab->table, apply, args);\n}\n\nstatic void cil_reset_class(struct cil_class *class)\n{\n\tif (class->common != NULL) {\n\t\t/* Must assume that the common has been destroyed */\n\t\tint num_common_perms = class->num_perms - class->perms.nprim;\n\t\tcil_symtab_map(&class->perms, __class_reset_perm_values, &num_common_perms);\n\t\t/* during a re-resolve, we need to reset the common, so a classcommon\n\t\t * statement isn't seen as a duplicate */\n\t\tclass->num_perms = class->perms.nprim;\n\t\tclass->common = NULL; /* Must make this NULL or there will be an error when re-resolving */\n\t}\n\tclass->ordered = CIL_FALSE;\n}\n\nint __cil_reset_node(struct cil_tree_node *node,  __attribute__((unused)) uint32_t *finished, __attribute__((unused)) void *extra_args)\n{\n\tswitch (node->flavor) {\n\tcase CIL_CLASS:\n\t\tcil_reset_class(node->data);\n\t\tbreak;\n\tcase CIL_PERM:\n\tcase CIL_MAP_PERM:\n\t\tcil_reset_perm(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSION:\n\t\tcil_reset_classpermission(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSIONSET:\n\t\tcil_reset_classpermissionset(node->data);\n\t\tbreak;\n\tcase CIL_CLASSMAPPING:\n\t\tcil_reset_classmapping(node->data);\n\t\tbreak;\n\tcase CIL_TYPEALIAS:\n\tcase CIL_SENSALIAS:\n\tcase CIL_CATALIAS:\n\t\tcil_reset_alias(node->data);\n\t\tbreak;\n\tcase CIL_USERRANGE:\n\t\tcil_reset_userrange(node->data);\n\t\tbreak;\n\tcase CIL_USERLEVEL:\n\t\tcil_reset_userlevel(node->data);\n\t\tbreak;\n\tcase CIL_USER:\n\t\tcil_reset_user(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTE:\n\t\tcil_reset_userattr(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTESET:\n\t\tcil_reset_userattributeset(node->data);\n\t\tbreak;\n\tcase CIL_SELINUXUSERDEFAULT:\n\tcase CIL_SELINUXUSER:\n\t\tcil_reset_selinuxuser(node->data);\n\t\tbreak;\n\tcase CIL_ROLE:\n\t\tcil_reset_role(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTE:\n\t\tcil_reset_roleattr(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTESET:\n\t\tcil_reset_roleattributeset(node->data);\n\t\tbreak;\n\tcase CIL_TYPE:\n\t\tcil_reset_type(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTE:\n\t\tcil_reset_typeattr(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTESET:\n\t\tcil_reset_typeattributeset(node->data);\n\t\tbreak;\n\tcase CIL_RANGETRANSITION:\n\t\tcil_reset_rangetransition(node->data);\n\t\tbreak;\n\tcase CIL_AVRULE:\n\t\tcil_reset_avrule(node->data);\n\t\tbreak;\n\tcase CIL_SENS:\n\t\tcil_reset_sens(node->data);\n\t\tbreak;\n\tcase CIL_CAT:\n\t\tcil_reset_cat(node->data);\n\t\tbreak;\n\tcase CIL_SENSCAT:\n\t\tcil_reset_senscat(node->data);\n\t\tbreak;\n\tcase CIL_CATSET:\n\t\tcil_reset_catset(node->data);\n\t\tbreak;\n\tcase CIL_LEVEL:\n\t\tcil_reset_level(node->data);\n\t\tbreak;\n\tcase CIL_LEVELRANGE:\n\t\tcil_reset_levelrange(node->data);\n\t\tbreak;\n\tcase CIL_CONTEXT:\n\t\tcil_reset_context(node->data);\n\t\tbreak;\n\tcase CIL_SIDCONTEXT:\n\t\tcil_reset_sidcontext(node->data);\n\t\tbreak;\n\tcase CIL_FILECON:\n\t\tcil_reset_filecon(node->data);\n\t\tbreak;\n\tcase CIL_IBPKEYCON:\n\t\tcil_reset_ibpkeycon(node->data);\n\t\tbreak;\n\tcase CIL_IBENDPORTCON:\n\t\tcil_reset_ibendportcon(node->data);\n\t\tbreak;\n\tcase CIL_PORTCON:\n\t\tcil_reset_portcon(node->data);\n\t\tbreak;\n\tcase CIL_NODECON:\n\t\tcil_reset_nodecon(node->data);\n\t\tbreak;\n\tcase CIL_GENFSCON:\n\t\tcil_reset_genfscon(node->data);\n\t\tbreak;\n\tcase CIL_NETIFCON:\n\t\tcil_reset_netifcon(node->data);\n\t\tbreak;\n\tcase CIL_PIRQCON:\n\t\tcil_reset_pirqcon(node->data);\n\t\tbreak;\n\tcase CIL_IOMEMCON:\n\t\tcil_reset_iomemcon(node->data);\n\t\tbreak;\n\tcase CIL_IOPORTCON:\n\t\tcil_reset_ioportcon(node->data);\n\t\tbreak;\n\tcase CIL_PCIDEVICECON:\n\t\tcil_reset_pcidevicecon(node->data);\n\t\tbreak;\n\tcase CIL_DEVICETREECON:\n\t\tcil_reset_devicetreecon(node->data);\n\t\tbreak;\n\tcase CIL_FSUSE:\n\t\tcil_reset_fsuse(node->data);\n\t\tbreak;\n\tcase CIL_SID:\n\t\tcil_reset_sid(node->data);\n\t\tbreak;\n\tcase CIL_CONSTRAIN:\n\tcase CIL_MLSCONSTRAIN:\n\t\tcil_reset_constrain(node->data);\n\t\tbreak;\n\tcase CIL_VALIDATETRANS:\n\tcase CIL_MLSVALIDATETRANS:\n\t\tcil_reset_validatetrans(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTUSER:\n\tcase CIL_DEFAULTROLE:\n\tcase CIL_DEFAULTTYPE:\n\t\tcil_reset_default(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTRANGE:\n\t\tcil_reset_defaultrange(node->data);\n\t\tbreak;\n\tcase CIL_BOOLEANIF:\n\t\tcil_reset_booleanif(node->data);\n\t\tbreak;\n\tcase CIL_TUNABLEIF:\n\tcase CIL_CALL:\n\t\tbreak; /* Not effected by optional block disabling */\n\tcase CIL_MACRO:\n\tcase CIL_SIDORDER:\n\tcase CIL_CLASSORDER:\n\tcase CIL_CATORDER:\n\tcase CIL_SENSITIVITYORDER:\n\tcase CIL_EXPANDTYPEATTRIBUTE:\n\t\tbreak; /* Nothing to reset */\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_reset_ast(struct cil_tree_node *current)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_tree_walk(current, __cil_reset_node, NULL, NULL, NULL);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to reset AST\\n\");\n\t\treturn SEPOL_ERR;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_tree_children_destroy(parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}\n\n\n// target function\nstatic void cil_reset_class(struct cil_class *class)\n{\n\tif (class->common != NULL) {\n\t\tstruct cil_class *common = class->common;\n\t\tcil_symtab_map(&class->perms, __class_reset_perm_values, &common->num_perms);\n\t\t/* during a re-resolve, we need to reset the common, so a classcommon\n\t\t * statement isn't seen as a duplicate */\n\t\tclass->num_perms -= common->num_perms;\n\t\tclass->common = NULL; /* Must make this NULL or there will be an error when re-resolving */\n\t}\n\tclass->ordered = CIL_FALSE;\n}\n",
    "target": 1,
    "idx": 1028467,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}\n\n\n// target function\n  p=GetStringInfoDatum(comment);\n  (void) SetImageProperty(image,\"comment\",(const char *) p,exception);\n  comment=DestroyStringInfo(comment);\n  return(TRUE);\n}\n\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *icc_profile,\n    *profile;\n\n  /*\n    Read color profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,ICC_PROFILE) != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < (ssize_t) (length-12); i++)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  if (i != (ssize_t) length)\n    {\n      profile=DestroyStringInfo(profile);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=NULL;\n  icc_profile=(StringInfo *) GetImageProfile(image,\"icc\");\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(icc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"icc\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: ICC, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[MagickPathExtent];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *iptc_profile,\n    *profile;\n\n  /*\n    Determine length of binary data stored here.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  /*\n    Validate that this was written as a Photoshop resource format slug.\n  */\n  for (i=0; i < 10; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  magick[10]='\\0';\n  length-=10;\n  if (length <= 10)\n    return(TRUE);\n  if (LocaleCompare(magick,\"Photoshop \") != 0)\n    {\n      /*\n        Not a IPTC profile, return.\n      */\n      for (i=0; i < (ssize_t) length; i++)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  /*\n    Remove the version number.\n  */\n  for (i=0; i < 4; i++)\n    if (GetCharacter(jpeg_info) == EOF)\n      break;\n  if (length <= 11)\n    return(TRUE);\n  length-=4;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  error_manager->profile=NULL;\n  if (i != (ssize_t) length)\n    {\n      profile=DestroyStringInfo(profile);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  /* The IPTC profile is actually an 8bim */\n  iptc_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  if (iptc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(iptc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n",
    "target": 1,
    "idx": 1015827,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\n\n\n\n\n\n// target function\nvoid pj_set_ctx( projPJ pj, projCtx ctx )\n\n{\n    pj->ctx = ctx;\n}\nprojCtx pj_ctx_alloc()\n\n{\n    projCtx ctx = (projCtx_t *) malloc(sizeof(projCtx_t));\n    memcpy( ctx, pj_get_default_ctx(), sizeof(projCtx_t) );\n    ctx->last_errno = 0;\n\n    return ctx;\n}\nvoid pj_ctx_set_errno( projCtx ctx, int new_errno )\n\n{\n    ctx->last_errno = new_errno;\n    if (ctx!=pj_get_default_ctx())\n        return;\n    if( new_errno == 0 )\n        return;\n    pj_errno = new_errno;\n    errno = new_errno;\n}\nvoid pj_ctx_set_fileapi( projCtx ctx, projFileAPI *fileapi )\n\n{\n    ctx->fileapi = fileapi;\n}\n",
    "target": 1,
    "idx": 1003569,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *variable_ptr;\n\tzval *value_ptr;\n\n\tSAVE_OPLINE();\n\tvalue_ptr = _get_zval_ptr_ptr_var(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);\n\n\tif (IS_VAR == IS_VAR &&\n\t           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {\n\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to an array dimension of an object\");\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else if (IS_VAR == IS_VAR &&\n\t           opline->extended_value == ZEND_RETURNS_FUNCTION &&\n\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\tvariable_ptr = zend_wrong_assign_to_variable_reference(\n\t\t\tvariable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC);\n\t} else {\n\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op2.var));\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op1.var));\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\n\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)\n{\n\tzend_execute_data *execute_data;\n\tvoid *object_or_called_scope;\n\tuint32_t call_info;\n\n\tif (EG(exception) != NULL) {\n\t\treturn;\n\t}\n\n\tobject_or_called_scope = zend_get_this_object(EG(current_execute_data));\n\tif (EXPECTED(!object_or_called_scope)) {\n\t\tobject_or_called_scope = zend_get_called_scope(EG(current_execute_data));\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE;\n\t} else {\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE | ZEND_CALL_HAS_THIS;\n\t}\n\texecute_data = zend_vm_stack_push_call_frame(call_info,\n\t\t(zend_function*)op_array, 0, object_or_called_scope);\n\tif (EG(current_execute_data)) {\n\t\texecute_data->symbol_table = zend_rebuild_symbol_table();\n\t} else {\n\t\texecute_data->symbol_table = &EG(symbol_table);\n\t}\n\tEX(prev_execute_data) = EG(current_execute_data);\n\ti_init_code_execute_data(execute_data, op_array, return_value);\n\tZEND_OBSERVER_FCALL_BEGIN(execute_data);\n\tzend_execute_ex(execute_data);\n\t/* Observer end handlers are called from ZEND_RETURN */\n\tzend_vm_stack_free_call_frame(execute_data);\n}\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\n// target function\nstatic zend_never_inline ZEND_COLD bool zend_wrong_assign_to_variable_reference(zval *variable_ptr, zval *value_ptr OPLINE_DC EXECUTE_DATA_DC)\n{\n\tzend_error(E_NOTICE, \"Only variables should be assigned by reference\");\n\tif (UNEXPECTED(EG(exception) != NULL)) {\n\t\treturn 0;\n\t}\n\n\t/* Use IS_TMP_VAR instead of IS_VAR to avoid ISREF check */\n\tZ_TRY_ADDREF_P(value_ptr);\n\tvalue_ptr = zend_assign_to_variable(variable_ptr, value_ptr, IS_TMP_VAR, EX_USES_STRICT_TYPES());\n\n\treturn 1;\n}\nstatic zend_always_inline void zend_assign_to_property_reference(zval *container, uint32_t container_op_type, zval *prop_ptr, uint32_t prop_op_type, zval *value_ptr OPLINE_DC EXECUTE_DATA_DC)\n{\n\tzval variable, *variable_ptr = &variable;\n\tvoid **cache_addr = (prop_op_type == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_RETURNS_FUNCTION) : NULL;\n\n\tzend_fetch_property_address(variable_ptr, container, container_op_type, prop_ptr, prop_op_type,\n\t\tcache_addr, BP_VAR_W, 0, 0 OPLINE_CC EXECUTE_DATA_CC);\n\n\tif (EXPECTED(Z_TYPE_P(variable_ptr) == IS_INDIRECT)) {\n\t\tvariable_ptr = Z_INDIRECT_P(variable_ptr);\n\t\tif (/*OP_DATA_TYPE == IS_VAR &&*/\n\t\t\t\t   (opline->extended_value & ZEND_RETURNS_FUNCTION) &&\n\t\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\t\tif (UNEXPECTED(!zend_wrong_assign_to_variable_reference(\n\t\t\t\t\tvariable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {\n\t\t\t\tvariable_ptr = &EG(uninitialized_zval);\n\t\t\t}\n\t\t} else {\n\t\t\tzend_property_info *prop_info = NULL;\n\n\t\t\tif (prop_op_type == IS_CONST) {\n\t\t\t\tprop_info = (zend_property_info *) CACHED_PTR_EX(cache_addr + 2);\n\t\t\t} else {\n\t\t\t\tZVAL_DEREF(container);\n\t\t\t\tprop_info = zend_object_fetch_property_type_info(Z_OBJ_P(container), variable_ptr);\n\t\t\t}\n\n\t\t\tif (UNEXPECTED(prop_info)) {\n\t\t\t\tvariable_ptr = zend_assign_to_typed_property_reference(prop_info, variable_ptr, value_ptr EXECUTE_DATA_CC);\n\t\t\t} else {\n\t\t\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t\t\t}\n\t\t}\n\t} else if (Z_ISERROR_P(variable_ptr)) {\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else {\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to overloaded object\");\n\t\tzval_ptr_dtor(&variable);\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n}\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *variable_ptr;\n\tzval *value_ptr;\n\n\tSAVE_OPLINE();\n\tvalue_ptr = _get_zval_ptr_ptr_var(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);\n\n\tif (IS_VAR == IS_VAR &&\n\t           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {\n\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to an array dimension of an object\");\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else if (IS_VAR == IS_VAR &&\n\t           opline->extended_value == ZEND_RETURNS_FUNCTION &&\n\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\tif (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {\n\t\t\tvariable_ptr = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op2.var));\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op1.var));\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *variable_ptr;\n\tzval *value_ptr;\n\n\tSAVE_OPLINE();\n\tvalue_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);\n\n\tif (IS_VAR == IS_VAR &&\n\t           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {\n\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to an array dimension of an object\");\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else if (IS_CV == IS_VAR &&\n\t           opline->extended_value == ZEND_RETURNS_FUNCTION &&\n\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\tif (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {\n\t\t\tvariable_ptr = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op1.var));\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *variable_ptr;\n\tzval *value_ptr;\n\n\tSAVE_OPLINE();\n\tvalue_ptr = _get_zval_ptr_ptr_var(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = EX_VAR(opline->op1.var);\n\n\tif (IS_CV == IS_VAR &&\n\t           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {\n\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to an array dimension of an object\");\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else if (IS_VAR == IS_VAR &&\n\t           opline->extended_value == ZEND_RETURNS_FUNCTION &&\n\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\tif (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {\n\t\t\tvariable_ptr = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op2.var));\n\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *variable_ptr;\n\tzval *value_ptr;\n\n\tSAVE_OPLINE();\n\tvalue_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = EX_VAR(opline->op1.var);\n\n\tif (IS_CV == IS_VAR &&\n\t           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {\n\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to an array dimension of an object\");\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else if (IS_CV == IS_VAR &&\n\t           opline->extended_value == ZEND_RETURNS_FUNCTION &&\n\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\tif (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {\n\t\t\tvariable_ptr = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n\n\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\n",
    "target": 1,
    "idx": 1029899,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid\nsc_pkcs15_free_object(struct sc_pkcs15_object *obj)\n{\n\tif (!obj)\n\t\treturn;\n\tswitch (obj->type & SC_PKCS15_TYPE_CLASS_MASK) {\n\tcase SC_PKCS15_TYPE_PRKEY:\n\t\tsc_pkcs15_free_prkey_info((sc_pkcs15_prkey_info_t *)obj->data);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PUBKEY:\n\t\tsc_pkcs15_free_pubkey_info((sc_pkcs15_pubkey_info_t *)obj->data);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_CERT:\n\t\tsc_pkcs15_free_cert_info((sc_pkcs15_cert_info_t *)obj->data);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_DATA_OBJECT:\n\t\tsc_pkcs15_free_data_info((sc_pkcs15_data_info_t *)obj->data);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_AUTH:\n\t\tsc_pkcs15_free_auth_info((sc_pkcs15_auth_info_t *)obj->data);\n\t\tbreak;\n\tdefault:\n\t\tfree(obj->data);\n\t}\n\n\tsc_pkcs15_free_object_content(obj);\n\n\tfree(obj);\n}\n\n\n// target function\nint LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size)\n{\n    int (* decode_entries[])(struct sc_pkcs15_card *, struct sc_pkcs15_object *,\n            const u8 **nbuf, size_t *nbufsize) = {\n        sc_pkcs15_decode_prkdf_entry, sc_pkcs15_decode_pukdf_entry,\n        sc_pkcs15_decode_skdf_entry, sc_pkcs15_decode_cdf_entry,\n        sc_pkcs15_decode_dodf_entry, sc_pkcs15_decode_aodf_entry\n    };\n    size_t i;\n\n    if (!ctx)\n        sc_establish_context(&ctx, \"fuzz\");\n    if (!p15card) {\n        card.ctx = ctx;\n        p15card = sc_pkcs15_card_new();\n        if (p15card) {\n            p15card->card = &card;\n        }\n    }\n\n    for (i = 0; i < sizeof decode_entries/sizeof *decode_entries; i++) {\n        struct sc_pkcs15_object *obj;\n        const u8 *p = Data;\n        size_t len = Size;\n        obj = calloc(1, sizeof *obj);\n        while (SC_SUCCESS == decode_entries[i](p15card, obj, &p, &len)) {\n            sc_pkcs15_free_object(obj);\n        }\n        sc_pkcs15_free_object(obj);\n    }\n\n    struct sc_pkcs15_pubkey *pubkey = calloc(1, sizeof *pubkey);\n    sc_pkcs15_decode_pubkey(ctx, pubkey, Data, Size);\n    sc_pkcs15_free_pubkey(pubkey);\n\n    struct sc_pkcs15_tokeninfo *tokeninfo = sc_pkcs15_tokeninfo_new();\n    sc_pkcs15_parse_tokeninfo(ctx, tokeninfo, Data, Size);\n    sc_pkcs15_free_tokeninfo(tokeninfo);\n\n    sc_pkcs15_parse_unusedspace(Data, Size, p15card);\n\n    return 0;\n}\n",
    "target": 1,
    "idx": 1017170,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic int read_chunks_after_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n\n    int ret, discard = 0;\n    int prev_was_idat = 1;\n    struct spng_chunk chunk;\n    const unsigned char *data;\n    struct spng_chunk_bitfield stored;\n\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    memcpy(&chunk, &ctx->last_idat, sizeof(struct spng_chunk));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(is_critical_chunk(&chunk))\n        {\n            if(!memcmp(chunk.type, type_iend, 4))\n            {\n                if(chunk.length) return SPNG_ECHUNK_CRC;\n\n                ret = read_and_check_crc(ctx);\n                if(ret == -SPNG_CRC_DISCARD) ret = 0;\n\n                return ret;\n            }\n            else if(!memcmp(chunk.type, type_idat, 4) && prev_was_idat)\n            {/* ignore extra IDATs */\n                ret = discard_chunk_bytes(ctx, chunk.length);\n                if(ret) return ret;\n\n                continue;\n            }\n            else return SPNG_ECHUNK_POS; /* critical chunk after last IDAT that isn't IEND */\n        }\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        data = ctx->data;\n\n        prev_was_idat = 0;\n\n        if(!memcmp(chunk.type, type_chrm, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_gama, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_iccp, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_sbit, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_srgb, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_bkgd, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_hist, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_trns, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_phys, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_splt, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_offs, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n           if(ctx->file.time) return SPNG_EDUP_TIME;\n\n           if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n    }\n\n    return ret;\n}\n\nint spng_decode_image(spng_ctx *ctx, unsigned char *out, size_t out_size, int fmt, int flags)\n{\n    if(ctx == NULL) return 1;\n    if(out == NULL) return 1;\n\n    int ret;\n    size_t out_size_required, out_width;\n\n    ret = spng_decoded_image_size(ctx, fmt, &out_size_required);\n    if(ret) return ret;\n    if(out_size < out_size_required) return SPNG_EBUFSIZ;\n\n    out_width = out_size_required / ctx->ihdr.height;\n\n    uint8_t channels = 1; /* grayscale or indexed_color */\n\n    if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) channels = 3;\n    else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA) channels = 2;\n    else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA) channels = 4;\n\n    uint8_t bytes_per_pixel;\n\n    if(ctx->ihdr.bit_depth < 8) bytes_per_pixel = 1;\n    else bytes_per_pixel = channels * (ctx->ihdr.bit_depth / 8);\n\n    z_stream stream;\n    stream.zalloc = spng__zalloc;\n    stream.zfree = spng__zfree;\n    stream.opaque = ctx;\n\n    if(inflateInit(&stream) != Z_OK) return SPNG_EZLIB;\n\n    int apply_trns = 0;\n    if(flags & SPNG_DECODE_USE_TRNS && ctx->stored.trns) apply_trns = 1;\n\n    int apply_gamma = 0;\n    if(flags & SPNG_DECODE_USE_GAMA && ctx->stored.gama) apply_gamma = 1;\n\n    int use_sbit = 0;\n    if(flags & SPNG_DECODE_USE_SBIT && ctx->stored.sbit) use_sbit = 1;\n\n    int indexed = 0;\n    if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED) indexed = 1;\n\n    int do_scaling = 1;\n    if(indexed) do_scaling = 0;\n\n    int interlaced = 0;\n    if(ctx->ihdr.interlace_method) interlaced = 1;\n\n    int pass;\n    uint8_t filter = 0, next_filter = 0;\n    uint32_t i, k, scanline_idx, width;\n    uint8_t r_8, g_8, b_8, a_8, gray_8;\n    uint16_t r_16, g_16, b_16, a_16, gray_16;\n    r_8=0; g_8=0; b_8=0; a_8=0; gray_8=0;\n    r_16=0; g_16=0; b_16=0; a_16=0; gray_16=0;\n    unsigned char *pixel;\n    size_t pixel_offset = 0;\n    size_t pixel_size = 4; /* SPNG_FMT_RGBA8 */\n    unsigned processing_depth = ctx->ihdr.bit_depth;\n    unsigned depth_target = 8; /* FMT_RGBA8 */\n\n    if(indexed) processing_depth = 8;\n\n    if(fmt == SPNG_FMT_RGBA16)\n    {\n        depth_target = 16;\n        pixel_size = 8;\n    }\n\n    struct spng_subimage sub[7];\n    memset(sub, 0, sizeof(struct spng_subimage) * 7);\n\n    size_t scanline_width;\n\n    ret = calculate_subimages(sub, &scanline_width, &ctx->ihdr, channels);\n    if(ret) return ret;\n\n    unsigned char *row = NULL;\n    unsigned char *scanline = spng__malloc(ctx, scanline_width);\n    unsigned char *prev_scanline = spng__malloc(ctx, scanline_width);\n\n    if(interlaced) row = spng__malloc(ctx, out_width);\n    else row = out;\n\n    if(scanline == NULL || prev_scanline == NULL || row == NULL)\n    {\n        ret = SPNG_EMEM;\n        goto decode_err;\n    }\n\n    uint16_t *gamma_lut = NULL;\n\n    if(apply_gamma)\n    {\n        float file_gamma = (float)ctx->gama / 100000.0f;\n        float max;\n\n        uint32_t lut_entries;\n\n        if(fmt == SPNG_FMT_RGBA8)\n        {\n            lut_entries = 256;\n            max = 255.0f;\n\n            gamma_lut = ctx->gamma_lut8;\n        }\n        else /* SPNG_FMT_RGBA16 */\n        {\n            lut_entries = 65536;\n            max = 65535.0f;\n\n            ctx->gamma_lut = spng__malloc(ctx, lut_entries * sizeof(uint16_t));\n            if(ctx->gamma_lut == NULL)\n            {\n                ret = SPNG_EMEM;\n                goto decode_err;\n            }\n            gamma_lut = ctx->gamma_lut;\n        }\n\n        float screen_gamma = 2.2f;\n        float exponent = file_gamma * screen_gamma;\n\n        if(FP_ZERO == fpclassify(exponent))\n        {\n            ret = SPNG_EGAMA;\n            goto decode_err;\n        }\n\n        exponent = 1.0f / exponent;\n\n        for(i=0; i < lut_entries; i++)\n        {\n            float c = pow((float)i / max, exponent) * max;\n            c = fmin(c, max);\n\n            gamma_lut[i] = (uint16_t)c;\n        }\n    }\n\n    struct spng_sbit sb;\n\n    sb.red_bits = ctx->ihdr.bit_depth;\n    sb.green_bits = ctx->ihdr.bit_depth;\n    sb.blue_bits = ctx->ihdr.bit_depth;\n    sb.alpha_bits = ctx->ihdr.bit_depth;\n    sb.grayscale_bits = ctx->ihdr.bit_depth;\n\n    if(indexed)\n    {\n        sb.red_bits = 8;\n        sb.green_bits = 8;\n        sb.blue_bits = 8;\n        sb.alpha_bits = 8;\n    }\n\n    if(use_sbit)\n    {\n        if(ctx->ihdr.color_type == 0)\n        {\n            sb.grayscale_bits = ctx->sbit.grayscale_bits;\n            sb.alpha_bits = ctx->ihdr.bit_depth;\n        }\n        else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 3)\n        {\n            sb.red_bits = ctx->sbit.red_bits;\n            sb.green_bits = ctx->sbit.green_bits;\n            sb.blue_bits = ctx->sbit.blue_bits;\n            sb.alpha_bits = ctx->ihdr.bit_depth;\n        }\n        else if(ctx->ihdr.color_type == 4)\n        {\n            sb.grayscale_bits = ctx->sbit.grayscale_bits;\n            sb.alpha_bits = ctx->sbit.alpha_bits;\n        }\n        else /* == 6 */\n        {\n            sb.red_bits = ctx->sbit.red_bits;\n            sb.green_bits = ctx->sbit.green_bits;\n            sb.blue_bits = ctx->sbit.blue_bits;\n            sb.alpha_bits = ctx->sbit.alpha_bits;\n        }\n    }\n\n    if(ctx->ihdr.bit_depth == 16 && fmt == SPNG_FMT_RGBA8)\n    {/* in this case samples are scaled down by 8bits */\n        sb.red_bits -= 8;\n        sb.green_bits -= 8;\n        sb.blue_bits -= 8;\n        sb.alpha_bits -= 8;\n        sb.grayscale_bits -= 8;\n\n        processing_depth = 8;\n    }\n\n    /* Prevent infinite loops in sample_to_target() */\n    if(!depth_target || depth_target > 16 ||\n       !processing_depth || processing_depth > 16 ||\n       !sb.grayscale_bits || sb.grayscale_bits > processing_depth ||\n       !sb.alpha_bits || sb.alpha_bits > processing_depth ||\n       !sb.red_bits || sb.red_bits > processing_depth ||\n       !sb.green_bits || sb.green_bits > processing_depth ||\n       !sb.blue_bits || sb.blue_bits > processing_depth)\n    {\n        ret = SPNG_ESBIT;\n        goto decode_err;\n    }\n\n    if(sb.red_bits == sb.green_bits &&\n       sb.green_bits == sb.blue_bits &&\n       sb.blue_bits == sb.alpha_bits &&\n       sb.alpha_bits == processing_depth &&\n       processing_depth == depth_target) do_scaling = 0;\n\n    struct spng_plte_entry16 plte[256];\n\n    /* Pre-process palette entries */\n    if(indexed)\n    {\n        for(i=0; i < ctx->plte.n_entries; i++)\n        {\n            if(apply_trns && i < ctx->trns.n_type3_entries)\n                ctx->plte.entries[i].alpha = ctx->trns.type3_alpha[i];\n            else\n                ctx->plte.entries[i].alpha = 255;\n\n            plte[i].red = sample_to_target(ctx->plte.entries[i].red, 8, sb.red_bits, depth_target);\n            plte[i].green = sample_to_target(ctx->plte.entries[i].green, 8, sb.green_bits, depth_target);\n            plte[i].blue = sample_to_target(ctx->plte.entries[i].blue, 8, sb.blue_bits, depth_target);\n            plte[i].alpha = sample_to_target(ctx->plte.entries[i].alpha, 8, sb.alpha_bits, depth_target);\n\n            if(apply_gamma)\n            {\n                plte[i].red = gamma_lut[plte[i].red];\n                plte[i].green = gamma_lut[plte[i].green];\n                plte[i].blue = gamma_lut[plte[i].blue];\n            }\n        }\n\n        apply_trns = 0;\n        apply_gamma = 0;\n    }\n\n    unsigned char trns_px[8];\n\n    if(apply_trns && ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR)\n    {\n        if(ctx->ihdr.bit_depth == 16)\n        {\n            memcpy(trns_px, &ctx->trns.red, 2);\n            memcpy(trns_px + 2, &ctx->trns.green, 2);\n            memcpy(trns_px + 4, &ctx->trns.blue, 2);\n        }\n        else\n        {\n            trns_px[0] = ctx->trns.red;\n            trns_px[1] = ctx->trns.green;\n            trns_px[2] = ctx->trns.blue;\n        }\n    }\n\n    stream.avail_in = 0;\n    stream.next_in = ctx->data;\n\n    for(pass=0; pass < 7; pass++)\n    {\n        /* Skip empty passes */\n        if(sub[pass].width == 0 || sub[pass].height == 0) continue;\n\n        scanline_width = sub[pass].scanline_width;\n\n        /* prev_scanline is all zeros for the first scanline */\n        memset(prev_scanline, 0, scanline_width);\n\n        /* Read the first filter byte, offsetting all reads by 1 byte.\n           The scanlines will be aligned with the start of the array with\n           the next scanline's filter byte at the end,\n           the last scanline will end up being 1 byte \"shorter\". */\n        ret = read_scanline_bytes(ctx, &stream, &filter, 1);\n        if(ret) goto decode_err;\n\n        for(scanline_idx=0; scanline_idx < sub[pass].height; scanline_idx++)\n        {\n            /* The last scanline is 1 byte \"shorter\" */\n            if(scanline_idx == (sub[pass].height - 1))\n                ret = read_scanline_bytes(ctx, &stream, scanline, scanline_width - 1);\n            else\n                ret = read_scanline_bytes(ctx, &stream, scanline, scanline_width);\n\n            if(ret) goto decode_err;\n\n            memcpy(&next_filter, scanline + scanline_width - 1, 1);\n\n            ret = defilter_scanline(prev_scanline, scanline, scanline_width - 1, bytes_per_pixel, filter);\n            if(ret) goto decode_err;\n\n            filter = next_filter;\n\n            pixel_offset = 0;\n            width = sub[pass].width;\n\n            for(k=0; k < width; k++)\n            {\n                pixel = row + pixel_offset;\n                pixel_offset += pixel_size;\n\n\n                if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR)\n                {\n                    if(ctx->ihdr.bit_depth == 16)\n                    {\n                        r_16 = read_u16(scanline + (k * 6));\n                        g_16 = read_u16(scanline + (k * 6) + 2);\n                        b_16 = read_u16(scanline + (k * 6) + 4);\n\n                        a_16 = 65535;\n                    }\n                    else /* == 8 */\n                    {\n                        if(fmt == SPNG_FMT_RGBA8)\n                        {\n                            memcpy(pixel, scanline + (k * 3), 3);\n                            pixel[3] = 255;\n                            continue;\n                        }\n\n                        memcpy(&r_8, scanline + (k * 3), 1);\n                        memcpy(&g_8, scanline + (k * 3) + 1, 1);\n                        memcpy(&b_8, scanline + (k * 3) + 2, 1);\n\n                        a_8 = 255;\n                    }\n                }\n                else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED)\n                {\n                    uint8_t entry = 0;\n\n                    if(ctx->ihdr.bit_depth == 8)\n                    {\n                        memcpy(&entry, scanline + k, 1);\n                    }\n                    else\n                    {\n                        memcpy(&entry, scanline + k / (8 / ctx->ihdr.bit_depth), 1);\n\n                        uint8_t mask = (1 << ctx->ihdr.bit_depth) - 1;\n                        uint8_t samples_per_byte = 8 / ctx->ihdr.bit_depth;\n                        uint8_t max_shift_amount = 8 - ctx->ihdr.bit_depth;\n                        uint8_t shift_amount = max_shift_amount - ((k % samples_per_byte) * ctx->ihdr.bit_depth);\n\n                        entry = entry & (mask << shift_amount);\n                        entry = entry >> shift_amount;\n                    }\n\n                    if(entry >= ctx->plte.n_entries)\n                    {\n                        ret = SPNG_EPLTE_IDX;\n                        goto decode_err;\n                    }\n\n                    if(fmt == SPNG_FMT_RGBA8)\n                    {\n                        pixel[0] = plte[entry].red;\n                        pixel[1] = plte[entry].green;\n                        pixel[2] = plte[entry].blue;\n                        pixel[3] = plte[entry].alpha;\n\n                        continue;\n                    }\n                    else\n                    {\n                        r_16 = plte[entry].red;\n                        g_16 = plte[entry].green;\n                        b_16 = plte[entry].blue;\n                        a_16 = plte[entry].alpha;\n\n                        memcpy(pixel, &r_16, 2);\n                        memcpy(pixel + 2, &g_16, 2);\n                        memcpy(pixel + 4, &b_16, 2);\n                        memcpy(pixel + 6, &a_16, 2);\n\n                        continue;\n                    }\n                }\n                else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA)\n                {\n                    if(ctx->ihdr.bit_depth == 16)\n                    {\n                        r_16 = read_u16(scanline + (k * 8));\n                        g_16 = read_u16(scanline + (k * 8) + 2);\n                        b_16 = read_u16(scanline + (k * 8) + 4);\n                        a_16 = read_u16(scanline + (k * 8) + 6);\n                    }\n                    else /* == 8 */\n                    {\n                        if(fmt == SPNG_FMT_RGBA8)\n                        {\n                            memcpy(row, scanline, scanline_width - 1);\n                            break;\n                        }\n\n                        memcpy(&r_8, scanline + (k * 4), 1);\n                        memcpy(&g_8, scanline + (k * 4) + 1, 1);\n                        memcpy(&b_8, scanline + (k * 4) + 2, 1);\n                        memcpy(&a_8, scanline + (k * 4) + 3, 1);\n                    }\n                }\n                else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE)\n                {\n                    if(ctx->ihdr.bit_depth == 16)\n                    {\n                        gray_16 = read_u16(scanline + (k * 2));\n\n                        if(apply_trns && ctx->trns.gray == gray_16) a_16 = 0;\n                        else a_16 = 65535;\n\n                        r_16 = gray_16;\n                        g_16 = gray_16;\n                        b_16 = gray_16;\n                    }\n                    else /* <= 8 */\n                    {\n                        memcpy(&gray_8, scanline + k / (8 / ctx->ihdr.bit_depth), 1);\n\n                        uint16_t mask16 = (1 << ctx->ihdr.bit_depth) - 1;\n                        uint8_t mask = mask16; /* avoid shift by width */\n                        uint8_t samples_per_byte = 8 / ctx->ihdr.bit_depth;\n                        uint8_t max_shift_amount = 8 - ctx->ihdr.bit_depth;\n                        uint8_t shift_amount = max_shift_amount - ((k % samples_per_byte) * ctx->ihdr.bit_depth);\n\n                        gray_8 = gray_8 & (mask << shift_amount);\n                        gray_8 = gray_8 >> shift_amount;\n\n                        if(apply_trns && ctx->trns.gray == gray_8) a_8 = 0;\n                        else a_8 = 255;\n\n                        r_8 = gray_8; g_8 = gray_8; b_8 = gray_8;\n                    }\n                }\n                else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA)\n                {\n                    if(ctx->ihdr.bit_depth == 16)\n                    {\n                        gray_16 = read_u16(scanline + (k * 4));\n                        a_16 = read_u16(scanline + (k * 4) + 2);\n\n                        r_16 = gray_16;\n                        g_16 = gray_16;\n                        b_16 = gray_16;\n                    }\n                    else /* == 8 */\n                    {\n                        memcpy(&gray_8, scanline + (k * 2), 1);\n                        memcpy(&a_8, scanline + (k * 2) + 1, 1);\n\n                        r_8 = gray_8;\n                        g_8 = gray_8;\n                        b_8 = gray_8;\n                    }\n                }\n\n\n                if(fmt == SPNG_FMT_RGBA8)\n                {\n                    if(ctx->ihdr.bit_depth == 16)\n                    {\n                        r_8 = r_16 >> 8;\n                        g_8 = g_16 >> 8;\n                        b_8 = b_16 >> 8;\n                        a_8 = a_16 >> 8;\n                    }\n\n                    memcpy(pixel, &r_8, 1);\n                    memcpy(pixel + 1, &g_8, 1);\n                    memcpy(pixel + 2, &b_8, 1);\n                    memcpy(pixel + 3, &a_8, 1);\n                }\n                else if(fmt == SPNG_FMT_RGBA16)\n                {\n                    if(ctx->ihdr.bit_depth != 16)\n                    {\n                        r_16 = r_8;\n                        g_16 = g_8;\n                        b_16 = b_8;\n                        a_16 = a_8;\n                    }\n\n                    memcpy(pixel, &r_16, 2);\n                    memcpy(pixel + 2, &g_16, 2);\n                    memcpy(pixel + 4, &b_16, 2);\n                    memcpy(pixel + 6, &a_16, 2);\n                }\n            }/* for(k=0; k < sub[pass].width; k++) */\n\n            if(apply_trns) trns_row(row, scanline, trns_px, width, fmt, ctx->ihdr.color_type, ctx->ihdr.bit_depth);\n\n            if(do_scaling) scale_row(row, width, fmt, processing_depth, &sb);\n\n            if(apply_gamma) gamma_correct_row(row, width, fmt, gamma_lut);\n\n            /* prev_scanline is always defiltered */\n            memcpy(prev_scanline, scanline, scanline_width);\n\n            if(interlaced)\n            {\n                const unsigned int adam7_x_start[7] = { 0, 4, 0, 2, 0, 1, 0 };\n                const unsigned int adam7_y_start[7] = { 0, 0, 4, 0, 2, 0, 1 };\n                const unsigned int adam7_x_delta[7] = { 8, 8, 4, 4, 2, 2, 1 };\n                const unsigned int adam7_y_delta[7] = { 8, 8, 8, 4, 4, 2, 2 };\n\n                for(k=0; k < width; k++)\n                {\n                    size_t ioffset = ((adam7_y_start[pass] + scanline_idx * adam7_y_delta[pass]) *\n                                      ctx->ihdr.width + adam7_x_start[pass] + k * adam7_x_delta[pass]) * pixel_size;\n\n                    memcpy((unsigned char*)out + ioffset, row + k * pixel_size, pixel_size);\n                }\n            }\n            else\n            {/* avoid creating an invalid reference */\n                if(scanline_idx != (sub[pass].height - 1) ) row += out_width;\n            }\n\n        }/* for(scanline_idx=0; scanline_idx < sub[pass].height; scanline_idx++) */\n    }/* for(pass=0; pass < 7; pass++) */\n\n    if(ctx->cur_chunk_bytes_left) /* zlib stream ended before an IDAT chunk boundary */\n    {/* discard the rest of the chunk */\n        ret = discard_chunk_bytes(ctx, ctx->cur_chunk_bytes_left);\n    }\n\ndecode_err:\n\n    inflateEnd(&stream);\n    if(interlaced) spng__free(ctx, row);\n    spng__free(ctx, scanline);\n    spng__free(ctx, prev_scanline);\n\n    if(ret)\n    {\n        ctx->valid_state = 0;\n        return ret;\n    }\n\n    memcpy(&ctx->last_idat, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n    ret = read_chunks_after_idat(ctx);\n\n    if(ret) ctx->valid_state = 0;\n\n    return ret;\n}\n\n\n// target function\nstatic inline int read_and_check_crc(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n\n    int ret;\n    ret = read_data(ctx, 4);\n    if(ret) return ret;\n\n    ctx->current_chunk.crc = read_u32(ctx->data);\n\n    if(ctx->cur_actual_crc != ctx->current_chunk.crc)\n    {\n        if(is_critical_chunk(&ctx->current_chunk))\n        {\n            if(ctx->crc_action_critical == SPNG_CRC_USE) return 0;\n        }\n        else\n        {\n            if(ctx->crc_action_ancillary == SPNG_CRC_USE) return 0;\n            if(ctx->crc_action_ancillary == SPNG_CRC_DISCARD) return SPNG_CRC_DISCARD;\n        }\n\n        return SPNG_ECHUNK_CRC;\n    }\n\n    return 0;\n}\nstatic inline int read_header(spng_ctx *ctx, int *discard)\n{\n    if(ctx == NULL) return 1;\n\n    int ret;\n    struct spng_chunk chunk = { 0 };\n\n    ret = read_and_check_crc(ctx);\n    if(ret)\n    {\n        if(ret == SPNG_CRC_DISCARD)\n        {\n            if(discard != NULL) *discard = 1;\n        }\n        else return ret;\n    }\n\n    ret = read_data(ctx, 8);\n    if(ret) return ret;\n\n    chunk.offset = ctx->bytes_read - 8;\n\n    chunk.length = read_u32(ctx->data);\n\n    memcpy(&chunk.type, ctx->data + 4, 4);\n\n    if(chunk.length > png_u32max) return SPNG_ECHUNK_SIZE;\n\n    ctx->cur_chunk_bytes_left = chunk.length;\n\n    ctx->cur_actual_crc = crc32(0, NULL, 0);\n    ctx->cur_actual_crc = crc32(ctx->cur_actual_crc, chunk.type, 4);\n\n    memcpy(&ctx->current_chunk, &chunk, sizeof(struct spng_chunk));\n\n    return 0;\n}\nstatic int read_chunks_before_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n    if(ctx->data == NULL) return 1;\n    if(!ctx->valid_state) return SPNG_EBADSTATE;\n\n    int ret, discard = 0;\n    const unsigned char *data;\n    struct spng_chunk chunk;\n\n    chunk.offset = 8;\n    chunk.length = 13;\n    size_t sizeof_sig_ihdr = 29;\n\n    ret = read_data(ctx, sizeof_sig_ihdr);\n    if(ret) return ret;\n\n    data = ctx->data;\n\n    uint8_t signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n    if(memcmp(data, signature, sizeof(signature))) return SPNG_ESIGNATURE;\n\n    chunk.length = read_u32(data + 8);\n    memcpy(&chunk.type, data + 12, 4);\n\n    if(chunk.length != 13) return SPNG_EIHDR_SIZE;\n    if(memcmp(chunk.type, type_ihdr, 4)) return SPNG_ENOIHDR;\n\n    ctx->cur_actual_crc = crc32(0, NULL, 0);\n    ctx->cur_actual_crc = crc32(ctx->cur_actual_crc, data + 12, 17);\n\n    ctx->ihdr.width = read_u32(data + 16);\n    ctx->ihdr.height = read_u32(data + 20);\n    memcpy(&ctx->ihdr.bit_depth, data + 24, 1);\n    memcpy(&ctx->ihdr.color_type, data + 25, 1);\n    memcpy(&ctx->ihdr.compression_method, data + 26, 1);\n    memcpy(&ctx->ihdr.filter_method, data + 27, 1);\n    memcpy(&ctx->ihdr.interlace_method, data + 28, 1);\n\n    if(!ctx->max_width) ctx->max_width = png_u32max;\n    if(!ctx->max_height) ctx->max_height = png_u32max;\n\n    ret = check_ihdr(&ctx->ihdr, ctx->max_width, ctx->max_height);\n    if(ret) return ret;\n\n    ctx->file.ihdr = 1;\n    ctx->stored.ihdr = 1;\n\n    struct spng_chunk_bitfield stored;\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(!memcmp(chunk.type, type_idat, 4))\n        {\n            memcpy(&ctx->first_idat, &chunk, sizeof(struct spng_chunk));\n            return 0;\n        }\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        data = ctx->data;\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        if(is_critical_chunk(&chunk)) /* Critical chunk */\n        {\n            if(!memcmp(chunk.type, type_plte, 4))\n            {\n                if(chunk.length % 3 != 0) return SPNG_ECHUNK_SIZE;\n\n                ctx->plte.n_entries = chunk.length / 3;\n\n                if(check_plte(&ctx->plte, &ctx->ihdr)) return SPNG_ECHUNK_SIZE; /* XXX: EPLTE? */\n\n                size_t i;\n                for(i=0; i < ctx->plte.n_entries; i++)\n                {\n                    memcpy(&ctx->plte.entries[i].red,   data + i * 3, 1);\n                    memcpy(&ctx->plte.entries[i].green, data + i * 3 + 1, 1);\n                    memcpy(&ctx->plte.entries[i].blue,  data + i * 3 + 2, 1);\n                }\n\n                ctx->plte_offset = chunk.offset;\n\n                ctx->file.plte = 1;\n            }\n            else if(!memcmp(chunk.type, type_iend, 4)) return SPNG_ECHUNK_POS;\n            else if(!memcmp(chunk.type, type_ihdr, 4)) return SPNG_ECHUNK_POS;\n            else return SPNG_ECHUNK_UNKNOWN_CRITICAL;\n        }\n        else if(!memcmp(chunk.type, type_chrm, 4)) /* Ancillary chunks */\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.chrm) return SPNG_EDUP_CHRM;\n\n            if(chunk.length != 32) return SPNG_ECHUNK_SIZE;\n\n            ctx->chrm_int.white_point_x = read_u32(data);\n            ctx->chrm_int.white_point_y = read_u32(data + 4);\n            ctx->chrm_int.red_x = read_u32(data + 8);\n            ctx->chrm_int.red_y = read_u32(data + 12);\n            ctx->chrm_int.green_x = read_u32(data + 16);\n            ctx->chrm_int.green_y = read_u32(data + 20);\n            ctx->chrm_int.blue_x = read_u32(data + 24);\n            ctx->chrm_int.blue_y = read_u32(data + 28);\n\n            if(check_chrm_int(&ctx->chrm_int)) return SPNG_ECHRM;\n\n            ctx->file.chrm = 1;\n            ctx->stored.chrm = 1;\n        }\n        else if(!memcmp(chunk.type, type_gama, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.gama) return SPNG_EDUP_GAMA;\n\n            if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n            ctx->gama = read_u32(data);\n\n            if(!ctx->gama) return SPNG_EGAMA;\n            if(ctx->gama > png_u32max) return SPNG_EGAMA;\n\n            ctx->file.gama = 1;\n            ctx->stored.gama = 1;\n        }\n        else if(!memcmp(chunk.type, type_iccp, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.iccp) return SPNG_EDUP_ICCP;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_sbit, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.sbit) return SPNG_EDUP_SBIT;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 3) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1 , 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n            }\n            else if(ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 1, 1);\n            }\n            else if(ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1, 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 3, 1);\n            }\n\n            if(check_sbit(&ctx->sbit, &ctx->ihdr)) return SPNG_ESBIT;\n\n            ctx->file.sbit = 1;\n            ctx->stored.sbit = 1;\n        }\n        else if(!memcmp(chunk.type, type_srgb, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.srgb) return SPNG_EDUP_SRGB;\n\n            if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->srgb_rendering_intent, data, 1);\n\n            if(ctx->srgb_rendering_intent > 3) return SPNG_ESRGB;\n\n            ctx->file.srgb = 1;\n            ctx->stored.srgb = 1;\n        }\n        else if(!memcmp(chunk.type, type_bkgd, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.bkgd) return SPNG_EDUP_BKGD;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0 || ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.red = read_u16(data) & mask;\n                ctx->bkgd.green = read_u16(data + 2) & mask;\n                ctx->bkgd.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_EBKGD_NO_PLTE;\n\n                memcpy(&ctx->bkgd.plte_index, data, 1);\n                if(ctx->bkgd.plte_index >= ctx->plte.n_entries) return SPNG_EBKGD_PLTE_IDX;\n            }\n\n            ctx->file.bkgd = 1;\n            ctx->stored.bkgd = 1;\n        }\n        else if(!memcmp(chunk.type, type_trns, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.trns) return SPNG_EDUP_TRNS;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.red = read_u16(data) & mask;\n                ctx->trns.green = read_u16(data + 2) & mask;\n                ctx->trns.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length > ctx->plte.n_entries) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_ETRNS_NO_PLTE;\n\n                size_t k;\n                for(k=0; k < chunk.length; k++)\n                {\n                    memcpy(&ctx->trns.type3_alpha[k], data + k, 1);\n                }\n                ctx->trns.n_type3_entries = chunk.length;\n            }\n            else return SPNG_ETRNS_COLOR_TYPE;\n\n            ctx->file.trns = 1;\n            ctx->stored.trns = 1;\n        }\n        else if(!memcmp(chunk.type, type_hist, 4))\n        {\n            if(!ctx->file.plte) return SPNG_EHIST_NO_PLTE;\n            if(chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.hist) return SPNG_EDUP_HIST;\n\n            if( (chunk.length / 2) != (ctx->plte.n_entries) ) return SPNG_ECHUNK_SIZE;\n\n            size_t k;\n            for(k=0; k < (chunk.length / 2); k++)\n            {\n                ctx->hist.frequency[k] = read_u16(data + k*2);\n            }\n\n            ctx->file.hist = 1;\n            ctx->stored.hist = 1;\n        }\n        else if(!memcmp(chunk.type, type_phys, 4))\n        {\n            if(ctx->file.phys) return SPNG_EDUP_PHYS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->phys.ppu_x = read_u32(data);\n            ctx->phys.ppu_y = read_u32(data + 4);\n            memcpy(&ctx->phys.unit_specifier, data + 8, 1);\n\n            if(check_phys(&ctx->phys)) return SPNG_EPHYS;\n\n            ctx->file.phys = 1;\n            ctx->stored.phys = 1;\n        }\n        else if(!memcmp(chunk.type, type_splt, 4))\n        {\n            if(ctx->user.splt) continue; /* XXX: should check profile names for uniqueness */\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            ctx->file.splt = 1;\n\n            if(!ctx->stored.splt)\n            {\n                ctx->n_splt = 1;\n                ctx->splt_list = spng__calloc(ctx, 1, sizeof(struct spng_splt));\n                if(ctx->splt_list == NULL) return SPNG_EMEM;\n            }\n            else\n            {\n                ctx->n_splt++;\n                if(ctx->n_splt < 1) return SPNG_EOVERFLOW;\n                if(sizeof(struct spng_splt) > SIZE_MAX / ctx->n_splt) return SPNG_EOVERFLOW;\n\n                void *buf = spng__realloc(ctx, ctx->splt_list, ctx->n_splt * sizeof(struct spng_splt));\n                if(buf == NULL) return SPNG_EMEM;\n                ctx->splt_list = buf;\n                memset(&ctx->splt_list[ctx->n_splt - 1], 0, sizeof(struct spng_splt));\n            }\n\n            uint32_t i = ctx->n_splt - 1;\n\n            size_t keyword_len = chunk.length > 80 ? 80 : chunk.length;\n            char *keyword_nul = memchr(data, '\\0', keyword_len);\n            if(keyword_nul == NULL) return SPNG_ESPLT_NAME;\n\n            memcpy(&ctx->splt_list[i].name, data, keyword_len);\n\n            if(check_png_keyword(ctx->splt_list[i].name)) return SPNG_ESPLT_NAME;\n\n            keyword_len = strlen(ctx->splt_list[i].name);\n\n            if( (chunk.length - keyword_len - 1) ==  0) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->splt_list[i].sample_depth, data + keyword_len + 1, 1);\n\n            if(ctx->n_splt > 1)\n            {\n                uint32_t j;\n                for(j=0; j < i; j++)\n                {\n                    if(!strcmp(ctx->splt_list[j].name, ctx->splt_list[i].name)) return SPNG_ESPLT_DUP_NAME;\n                }\n            }\n\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                if( (chunk.length - keyword_len - 2) % 10 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 10;\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                if( (chunk.length - keyword_len - 2) % 6 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 6;\n            }\n            else return SPNG_ESPLT_DEPTH;\n\n            if(ctx->splt_list[i].n_entries == 0) return SPNG_ECHUNK_SIZE;\n            if(sizeof(struct spng_splt_entry) > SIZE_MAX / ctx->splt_list[i].n_entries) return SPNG_EOVERFLOW;\n\n            ctx->splt_list[i].entries = spng__malloc(ctx, sizeof(struct spng_splt_entry) * ctx->splt_list[i].n_entries);\n            if(ctx->splt_list[i].entries == NULL) return SPNG_EMEM;\n\n            const unsigned char *splt = data + keyword_len + 2;\n\n            size_t k;\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    ctx->splt_list[i].entries[k].red = read_u16(splt + k * 10);\n                    ctx->splt_list[i].entries[k].green = read_u16(splt + k * 10 + 2);\n                    ctx->splt_list[i].entries[k].blue = read_u16(splt + k * 10 + 4);\n                    ctx->splt_list[i].entries[k].alpha = read_u16(splt + k * 10 + 6);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 10 + 8);\n                }\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    uint8_t red, green, blue, alpha;\n                    memcpy(&red,   splt + k * 6, 1);\n                    memcpy(&green, splt + k * 6 + 1, 1);\n                    memcpy(&blue,  splt + k * 6 + 2, 1);\n                    memcpy(&alpha, splt + k * 6 + 3, 1);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 6 + 4);\n\n                    ctx->splt_list[i].entries[k].red = red;\n                    ctx->splt_list[i].entries[k].green = green;\n                    ctx->splt_list[i].entries[k].blue = blue;\n                    ctx->splt_list[i].entries[k].alpha = alpha;\n                }\n            }\n\n            ctx->stored.splt = 1;\n        }\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n            if(ctx->file.time) return SPNG_EDUP_TIME;\n\n            if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_offs, 4))\n        {\n            if(ctx->file.offs) return SPNG_EDUP_OFFS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->offs.x = read_s32(data);\n            ctx->offs.y = read_s32(data + 4);\n            memcpy(&ctx->offs.unit_specifier, data + 8, 1);\n\n            if(check_offs(&ctx->offs)) return SPNG_EOFFS;\n\n            ctx->file.offs = 1;\n            ctx->stored.offs = 1;\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n    }\n\n    return ret;\n}\nstatic int read_chunks_after_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n\n    int ret, discard = 0;\n    int prev_was_idat = 1;\n    struct spng_chunk chunk;\n    const unsigned char *data;\n    struct spng_chunk_bitfield stored;\n\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    memcpy(&chunk, &ctx->last_idat, sizeof(struct spng_chunk));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        data = ctx->data;\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        /* Critical chunk */\n        if(is_critical_chunk(&chunk))\n        {\n            if(!memcmp(chunk.type, type_iend, 4)) return 0;\n            else if(!memcmp(chunk.type, type_idat, 4) && prev_was_idat) continue; /* ignore extra IDATs */\n            else return SPNG_ECHUNK_POS; /* critical chunk after last IDAT that isn't IEND */\n        }\n\n        prev_was_idat = 0;\n\n        if(!memcmp(chunk.type, type_chrm, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_gama, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_iccp, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_sbit, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_srgb, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_bkgd, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_hist, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_trns, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_phys, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_splt, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_offs, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n           if(ctx->file.time) return SPNG_EDUP_TIME;\n\n           if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n    }\n\n    return ret;\n}\n",
    "target": 1,
    "idx": 1016081,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n        size_t\n        read(char* buffer, size_t length) override\n        {\n            throwException();\n            return 0;\n        }\n\nvoid\nQPDF::reconstruct_xref(QPDFExc& e)\n{\n    if (m->reconstructed_xref) {\n        // Avoid xref reconstruction infinite loops. This is getting very hard to reproduce because\n        // qpdf is throwing many fewer exceptions while parsing. Most situations are warnings now.\n        throw e;\n    }\n\n    m->reconstructed_xref = true;\n    // We may find more objects, which may contain dangling references.\n    m->fixed_dangling_refs = false;\n\n    warn(damagedPDF(\"\", 0, \"file is damaged\"));\n    warn(e);\n    warn(damagedPDF(\"\", 0, \"Attempting to reconstruct cross-reference table\"));\n\n    // Delete all references to type 1 (uncompressed) objects\n    std::set<QPDFObjGen> to_delete;\n    for (auto const& iter: m->xref_table) {\n        if (iter.second.getType() == 1) {\n            to_delete.insert(iter.first);\n        }\n    }\n    for (auto const& iter: to_delete) {\n        m->xref_table.erase(iter);\n    }\n\n    m->file->seek(0, SEEK_END);\n    qpdf_offset_t eof = m->file->tell();\n    m->file->seek(0, SEEK_SET);\n    qpdf_offset_t line_start = 0;\n    // Don't allow very long tokens here during recovery.\n    static size_t const MAX_LEN = 100;\n    while (m->file->tell() < eof) {\n        m->file->findAndSkipNextEOL();\n        qpdf_offset_t next_line_start = m->file->tell();\n        m->file->seek(line_start, SEEK_SET);\n        QPDFTokenizer::Token t1 = readToken(m->file, MAX_LEN);\n        qpdf_offset_t token_start = m->file->tell() - toO(t1.getValue().length());\n        if (token_start >= next_line_start) {\n            // don't process yet -- wait until we get to the line containing this token\n        } else if (t1.isInteger()) {\n            QPDFTokenizer::Token t2 = readToken(m->file, MAX_LEN);\n            if ((t2.isInteger()) && (readToken(m->file, MAX_LEN).isWord(\"obj\"))) {\n                int obj = QUtil::string_to_int(t1.getValue().c_str());\n                int gen = QUtil::string_to_int(t2.getValue().c_str());\n                insertReconstructedXrefEntry(obj, token_start, gen);\n            }\n        } else if (!m->trailer.isInitialized() && t1.isWord(\"trailer\")) {\n            QPDFObjectHandle t = readTrailer();\n            if (!t.isDictionary()) {\n                // Oh well.  It was worth a try.\n            } else {\n                setTrailer(t);\n            }\n        }\n        m->file->seek(next_line_start, SEEK_SET);\n        line_start = next_line_start;\n    }\n    m->deleted_objects.clear();\n\n    if (!m->trailer.isInitialized()) {\n        qpdf_offset_t max_offset{0};\n        // If there are any xref streams, take the last one to appear.\n        for (auto const& iter: m->xref_table) {\n            auto entry = iter.second;\n            if (entry.getType() != 1) {\n                continue;\n            }\n            auto oh = getObjectByObjGen(iter.first);\n            try {\n                if (!oh.isStreamOfType(\"/XRef\")) {\n                    continue;\n                }\n            } catch (std::exception&) {\n                continue;\n            }\n            auto offset = entry.getOffset();\n            if (offset > max_offset) {\n                max_offset = offset;\n                setTrailer(oh.getDict());\n            }\n        }\n        if (max_offset > 0) {\n            try {\n                read_xref(max_offset);\n            } catch (std::exception&) {\n                throw damagedPDF(\n                    \"\", 0, \"error decoding candidate xref stream while recovering damaged file\");\n            }\n            QTC::TC(\"qpdf\", \"QPDF recover xref stream\");\n        }\n    }\n\n    if (!m->trailer.isInitialized()) {\n        // We could check the last encountered object to see if it was an xref stream.  If so, we\n        // could try to get the trailer from there.  This may make it possible to recover files with\n        // bad startxref pointers even when they have object streams.\n\n        throw damagedPDF(\"\", 0, \"unable to find trailer dictionary while recovering damaged file\");\n    }\n\n    // We could iterate through the objects looking for streams and try to find objects inside of\n    // them, but it's probably not worth the trouble.  Acrobat can't recover files with any errors\n    // in an xref stream, and this would be a real long shot anyway.  If we wanted to do anything\n    // that involved looking at stream contents, we'd also have to call initializeEncryption() here.\n    // It's safe to call it more than once.\n}\n\nvoid\nQPDF::parse(char const* password)\n{\n    if (password) {\n        m->encp->provided_password = password;\n    }\n\n    // Find the header anywhere in the first 1024 bytes of the file.\n    PatternFinder hf(*this, &QPDF::findHeader);\n    if (!m->file->findFirst(\"%PDF-\", 0, 1024, hf)) {\n        QTC::TC(\"qpdf\", \"QPDF not a pdf file\");\n        warn(damagedPDF(\"\", 0, \"can't find PDF header\"));\n        // QPDFWriter writes files that usually require at least version 1.2 for /FlateDecode\n        m->pdf_version = \"1.2\";\n    }\n\n    // PDF spec says %%EOF must be found within the last 1024 bytes of/ the file.  We add an extra\n    // 30 characters to leave room for the startxref stuff.\n    m->file->seek(0, SEEK_END);\n    qpdf_offset_t end_offset = m->file->tell();\n    qpdf_offset_t start_offset = (end_offset > 1054 ? end_offset - 1054 : 0);\n    PatternFinder sf(*this, &QPDF::findStartxref);\n    qpdf_offset_t xref_offset = 0;\n    if (m->file->findLast(\"startxref\", start_offset, 0, sf)) {\n        xref_offset = QUtil::string_to_ll(readToken(m->file).getValue().c_str());\n    }\n\n    try {\n        if (xref_offset == 0) {\n            QTC::TC(\"qpdf\", \"QPDF can't find startxref\");\n            throw damagedPDF(\"\", 0, \"can't find startxref\");\n        }\n        try {\n            read_xref(xref_offset);\n        } catch (QPDFExc&) {\n            throw;\n        } catch (std::exception& e) {\n            throw damagedPDF(\"\", 0, std::string(\"error reading xref: \") + e.what());\n        }\n    } catch (QPDFExc& e) {\n        if (m->attempt_recovery) {\n            reconstruct_xref(e);\n            QTC::TC(\"qpdf\", \"QPDF reconstructed xref table\");\n        } else {\n            throw;\n        }\n    }\n\n    initializeEncryption();\n    m->parsed = true;\n}\n\nvoid\nQPDF::processInputSource(std::shared_ptr<InputSource> source, char const* password)\n{\n    m->file = source;\n    parse(password);\n}\n\nstd::shared_ptr<QPDF>\nFuzzHelper::getQpdf()\n{\n    auto is =\n        std::shared_ptr<InputSource>(new BufferInputSource(\"fuzz input\", &this->input_buffer));\n    auto qpdf = QPDF::create();\n    qpdf->processInputSource(is);\n    return qpdf;\n}\n\nvoid\nFuzzHelper::testWrite()\n{\n    // Write in various ways to exercise QPDFWriter\n\n    std::shared_ptr<QPDF> q;\n    std::shared_ptr<QPDFWriter> w;\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setDeterministicID(true);\n    w->setQDFMode(true);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setStaticID(true);\n    w->setLinearization(true);\n    w->setR6EncryptionParameters(\"u\", \"o\", true, true, true, true, true, true, qpdf_r3p_full, true);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setStaticID(true);\n    w->setObjectStreamMode(qpdf_o_disable);\n    w->setR3EncryptionParametersInsecure(\n        \"u\", \"o\", true, true, true, true, true, true, qpdf_r3p_full);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setDeterministicID(true);\n    w->setObjectStreamMode(qpdf_o_generate);\n    w->setLinearization(true);\n    doWrite(w);\n}\n\nvoid\nFuzzHelper::doChecks()\n{\n    // Get as much coverage as possible in parts of the library that\n    // might benefit from fuzzing.\n    testWrite();\n    testPages();\n    testOutlines();\n}\n\nvoid\nFuzzHelper::run()\n{\n    // The goal here is that you should be able to throw anything at\n    // libqpdf and it will respond without any memory errors and never\n    // do anything worse than throwing a QPDFExc or\n    // std::runtime_error. Throwing any other kind of exception,\n    // segfaulting, or having a memory error (when built with\n    // appropriate sanitizers) will all cause abnormal exit.\n    try {\n        doChecks();\n    } catch (QPDFExc const& e) {\n        std::cerr << \"QPDFExc: \" << e.what() << std::endl;\n    } catch (std::runtime_error const& e) {\n        std::cerr << \"runtime_error: \" << e.what() << std::endl;\n    }\n}\n\n\n// target function\nvoid\nQPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    std::set<qpdf_offset_t> visited;\n    while (xref_offset) {\n        visited.insert(xref_offset);\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n        m->file->seek(xref_offset, SEEK_SET);\n        // Some files miss the mark a little with startxref. We could do a better job of searching\n        // in the neighborhood for something that looks like either an xref table or stream, but the\n        // simple heuristic of skipping whitespace can help with the xref table case and is harmless\n        // with the stream case.\n        bool done = false;\n        bool skipped_space = false;\n        while (!done) {\n            char ch;\n            if (1 == m->file->read(&ch, 1)) {\n                if (QUtil::is_space(ch)) {\n                    skipped_space = true;\n                } else {\n                    m->file->unreadCh(ch);\n                    done = true;\n                }\n            } else {\n                QTC::TC(\"qpdf\", \"QPDF eof skipping spaces before xref\", skipped_space ? 0 : 1);\n                done = true;\n            }\n        }\n\n        m->file->read(buf, sizeof(buf) - 1);\n        // The PDF spec says xref must be followed by a line terminator, but files exist in the wild\n        // where it is terminated by arbitrary whitespace.\n        if ((strncmp(buf, \"xref\", 4) == 0) && QUtil::is_space(buf[4])) {\n            if (skipped_space) {\n                QTC::TC(\"qpdf\", \"QPDF xref skipped space\");\n                warn(damagedPDF(\"\", 0, \"extraneous whitespace seen before xref\"));\n            }\n            QTC::TC(\n                \"qpdf\",\n                \"QPDF xref space\",\n                ((buf[4] == '\\n')       ? 0\n                     : (buf[4] == '\\r') ? 1\n                     : (buf[4] == ' ')  ? 2\n                                        : 9999));\n            int skip = 4;\n            // buf is null-terminated, and QUtil::is_space('\\0') is false, so this won't overrun.\n            while (QUtil::is_space(buf[skip])) {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n        } else {\n            xref_offset = read_xrefStream(xref_offset);\n        }\n        if (visited.count(xref_offset) != 0) {\n            QTC::TC(\"qpdf\", \"QPDF xref loop\");\n            throw damagedPDF(\"\", 0, \"loop detected following xref tables\");\n        }\n    }\n\n    if (!m->trailer.isInitialized()) {\n        throw damagedPDF(\"\", 0, \"unable to find trailer while reading xref\");\n    }\n    int size = m->trailer.getKey(\"/Size\").getIntValueAsInt();\n    int max_obj = 0;\n    if (!m->xref_table.empty()) {\n        max_obj = (*(m->xref_table.rbegin())).first.getObj();\n    }\n    if (!m->deleted_objects.empty()) {\n        max_obj = std::max(max_obj, *(m->deleted_objects.rbegin()));\n    }\n    if ((size < 1) || (size - 1 != max_obj)) {\n        QTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n        warn(damagedPDF(\n            \"\",\n            0,\n            (\"reported number of objects (\" + std::to_string(size) +\n             \") is not one plus the highest object number (\" + std::to_string(max_obj) + \")\")));\n    }\n\n    // We no longer need the deleted_objects table, so go ahead and clear it out to make sure we\n    // never depend on its being set.\n    m->deleted_objects.clear();\n\n    // Make sure we keep only the highest generation for any object.\n    QPDFObjGen last_og{-1, 0};\n    for (auto const& og: m->xref_table) {\n        if (og.first.getObj() == last_og.getObj())\n            removeObject(last_og);\n        last_og = og.first;\n    }\n}\nstd::vector<QPDFObjGen>\nQPDF::getCompressibleObjGens()\n{\n    // Return a list of objects that are allowed to be in object streams.  Walk through the objects\n    // by traversing the document from the root, including a traversal of the pages tree.  This\n    // makes that objects that are on the same page are more likely to be in the same object stream,\n    // which is slightly more efficient, particularly with linearized files.  This is better than\n    // iterating through the xref table since it avoids preserving orphaned items.\n\n    // Exclude encryption dictionary, if any\n    QPDFObjectHandle encryption_dict = m->trailer.getKey(\"/Encrypt\");\n    QPDFObjGen encryption_dict_og = encryption_dict.getObjGen();\n\n    const size_t max_obj = getObjectCount();\n    std::vector<bool> visited(max_obj, false);\n    std::vector<QPDFObjectHandle> queue;\n    queue.reserve(512);\n    queue.push_back(m->trailer);\n    std::vector<QPDFObjGen> result;\n    while (!queue.empty()) {\n        auto obj = queue.back();\n        queue.pop_back();\n        if (obj.isIndirect()) {\n            QPDFObjGen og = obj.getObjGen();\n            const size_t id = toS(og.getObj() - 1);\n            if (id >= max_obj)\n                throw std::logic_error(\n                    \"unexpected object id encountered in getCompressibleObjGens\");\n            if (visited[id]) {\n                QTC::TC(\"qpdf\", \"QPDF loop detected traversing objects\");\n                continue;\n            }\n\n            // Check whether this is the current object. If not, remove it (which changes it into a\n            // direct null and therefore stops us from revisiting it) and move on to the next object\n            // in the queue.\n            auto upper = m->obj_cache.upper_bound(og);\n            if (upper != m->obj_cache.end() && upper->first.getObj() == og.getObj()) {\n                removeObject(og);\n                continue;\n            }\n\n            visited[id] = true;\n\n            if (og == encryption_dict_og) {\n                QTC::TC(\"qpdf\", \"QPDF exclude encryption dictionary\");\n            } else if (!(obj.isStream() ||\n                         (obj.isDictionaryOfType(\"/Sig\") && obj.hasKey(\"/ByteRange\") &&\n                          obj.hasKey(\"/Contents\")))) {\n                result.push_back(og);\n            }\n        }\n        if (obj.isStream()) {\n            QPDFObjectHandle dict = obj.getDict();\n            std::set<std::string> keys = dict.getKeys();\n            for (auto iter = keys.rbegin(); iter != keys.rend(); ++iter) {\n                std::string const& key = *iter;\n                QPDFObjectHandle value = dict.getKey(key);\n                if (key == \"/Length\") {\n                    // omit stream lengths\n                    if (value.isIndirect()) {\n                        QTC::TC(\"qpdf\", \"QPDF exclude indirect length\");\n                    }\n                } else {\n                    queue.push_back(value);\n                }\n            }\n        } else if (obj.isDictionary()) {\n            std::set<std::string> keys = obj.getKeys();\n            for (auto iter = keys.rbegin(); iter != keys.rend(); ++iter) {\n                queue.push_back(obj.getKey(*iter));\n            }\n        } else if (obj.isArray()) {\n            int n = obj.getArrayNItems();\n            for (int i = 1; i <= n; ++i) {\n                queue.push_back(obj.getArrayItem(n - i));\n            }\n        }\n    }\n\n    return result;\n}\n",
    "target": 1,
    "idx": 1065777,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic xmlNodePtr\nxmlXIncludeCopyXPointer(xmlXIncludeCtxtPtr ctxt, xmlDocPtr target,\n\t                xmlDocPtr source, xmlXPathObjectPtr obj) {\n    xmlNodePtr list = NULL, last = NULL;\n    int i;\n\n    if (source == NULL)\n\tsource = ctxt->doc;\n    if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||\n\t(obj == NULL))\n\treturn(NULL);\n    switch (obj->type) {\n        case XPATH_NODESET: {\n\t    xmlNodeSetPtr set = obj->nodesetval;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->nodeNr;i++) {\n\t\tif (set->nodeTab[i] == NULL)\n\t\t    continue;\n\t\tswitch (set->nodeTab[i]->type) {\n\t\t    case XML_TEXT_NODE:\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t    case XML_ELEMENT_NODE:\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t    case XML_ENTITY_NODE:\n\t\t    case XML_PI_NODE:\n\t\t    case XML_COMMENT_NODE:\n\t\t    case XML_DOCUMENT_NODE:\n\t\t    case XML_HTML_DOCUMENT_NODE:\n\t\t    case XML_XINCLUDE_END:\n\t\t\tbreak;\n\t\t    case XML_XINCLUDE_START: {\n\t                xmlNodePtr tmp, cur = set->nodeTab[i];\n\n\t\t\tcur = cur->next;\n\t\t\twhile (cur != NULL) {\n\t\t\t    switch(cur->type) {\n\t\t\t\tcase XML_TEXT_NODE:\n\t\t\t\tcase XML_CDATA_SECTION_NODE:\n\t\t\t\tcase XML_ELEMENT_NODE:\n\t\t\t\tcase XML_ENTITY_REF_NODE:\n\t\t\t\tcase XML_ENTITY_NODE:\n\t\t\t\tcase XML_PI_NODE:\n\t\t\t\tcase XML_COMMENT_NODE:\n\t\t\t\t    tmp = xmlXIncludeCopyNode(ctxt, target,\n\t\t\t\t\t\t\t      source, cur);\n\t\t\t\t    if (last == NULL) {\n\t\t\t\t\tlist = last = tmp;\n\t\t\t\t    } else {\n\t\t\t\t\tlast = xmlAddNextSibling(last, tmp);\n\t\t\t\t    }\n\t\t\t\t    cur = cur->next;\n\t\t\t\t    continue;\n\t\t\t\tdefault:\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t    }\n\t\t    case XML_ATTRIBUTE_NODE:\n\t\t    case XML_NAMESPACE_DECL:\n\t\t    case XML_DOCUMENT_TYPE_NODE:\n\t\t    case XML_DOCUMENT_FRAG_NODE:\n\t\t    case XML_NOTATION_NODE:\n\t\t    case XML_DTD_NODE:\n\t\t    case XML_ELEMENT_DECL:\n\t\t    case XML_ATTRIBUTE_DECL:\n\t\t    case XML_ENTITY_DECL:\n\t\t\tcontinue; /* for */\n\t\t}\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t                              set->nodeTab[i]);\n\t\telse {\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t\t                set->nodeTab[i]));\n\t\t    if (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n#ifdef LIBXML_XPTR_LOCS_ENABLED\n\tcase XPATH_LOCATIONSET: {\n\t    xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->locNr;i++) {\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t                                  set->locTab[i]);\n\t\telse\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t\t                    set->locTab[i]));\n\t\tif (last != NULL) {\n\t\t    while (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tcase XPATH_RANGE:\n\t    return(xmlXIncludeCopyRange(ctxt, target, source, obj));\n\tcase XPATH_POINT:\n\t    /* points are ignored in XInclude */\n\t    break;\n#endif\n\tdefault:\n\t    break;\n    }\n    return(list);\n}\n\nstatic int\nxmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur, end, list, tmp;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n\n    list = ctxt->incTab[nr]->inc;\n    ctxt->incTab[nr]->inc = NULL;\n    ctxt->incTab[nr]->emptyFb = 0;\n\n    /*\n     * Check against the risk of generating a multi-rooted document\n     */\n    if ((cur->parent != NULL) &&\n\t(cur->parent->type != XML_ELEMENT_NODE)) {\n\tint nb_elem = 0;\n\n\ttmp = list;\n\twhile (tmp != NULL) {\n\t    if (tmp->type == XML_ELEMENT_NODE)\n\t\tnb_elem++;\n\t    tmp = tmp->next;\n\t}\n\tif (nb_elem > 1) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_MULTIPLE_ROOT,\n\t\t       \"XInclude error: would result in multiple root nodes\\n\",\n\t\t\t   NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    end = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(cur, end);\n\t}\n        /*\n         * FIXME: xmlUnlinkNode doesn't coalesce text nodes.\n         */\n\txmlUnlinkNode(cur);\n\txmlFreeNode(cur);\n    } else {\n        xmlNodePtr child, next;\n\n\t/*\n\t * Change the current node as an XInclude start one, and add an\n\t * XInclude end one\n\t */\n        if (ctxt->incTab[nr]->fallback)\n            xmlUnsetProp(cur, BAD_CAST \"href\");\n\tcur->type = XML_XINCLUDE_START;\n        /* Remove fallback children */\n        for (child = cur->children; child != NULL; child = next) {\n            next = child->next;\n            xmlUnlinkNode(child);\n            xmlFreeNode(child);\n        }\n\tend = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);\n\tif (end == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_BUILD_FAILED,\n\t\t\t   \"failed to build node\\n\", NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n\tend->type = XML_XINCLUDE_END;\n\txmlAddNextSibling(cur, end);\n\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    cur = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(end, cur);\n\t}\n    }\n\n\n    return(0);\n}\n\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * TODO: The phases must run separately for recursive inclusions.\n     *\n     * - Phase 1 should start with top-level XInclude nodes, load documents,\n     *   execute XPointer expressions, then process only the result nodes\n     *   (not whole document, see bug #324081) and only for phase 1\n     *   recursively. We will need a backreference from xmlNodes to\n     *   xmlIncludeRefs to detect references that were already visited.\n     *   This can also be used for proper cycle detection, see bug #344240.\n     *\n     * - Phase 2 should visit all top-level XInclude nodes and expand\n     *   possible subreferences in the replacement recursively.\n     *\n     * - Phase 3 should finally replace the top-level XInclude nodes.\n     *   It could also be run together with phase 2.\n     */\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   ((cur->type == XML_DOCUMENT_NODE) ||\n                    (cur->type == XML_ELEMENT_NODE))) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}\n\nint\nxmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {\n    xmlXIncludeCtxtPtr ctxt;\n    int ret = 0;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n        (tree->doc == NULL))\n        return(-1);\n\n    ctxt = xmlXIncludeNewContext(tree->doc);\n    if (ctxt == NULL)\n        return(-1);\n    ctxt->_private = data;\n    ctxt->base = xmlStrdup((xmlChar *)tree->doc->URL);\n    xmlXIncludeSetFlags(ctxt, flags);\n    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree, 0);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n        ret = -1;\n\n    xmlXIncludeFreeContext(ctxt);\n    return(ret);\n}\n\nint\nxmlXIncludeProcessFlagsData(xmlDocPtr doc, int flags, void *data) {\n    xmlNodePtr tree;\n\n    if (doc == NULL)\n\treturn(-1);\n    tree = xmlDocGetRootElement(doc);\n    if (tree == NULL)\n\treturn(-1);\n    return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));\n}\n\nint\nxmlXIncludeProcessFlags(xmlDocPtr doc, int flags) {\n    return xmlXIncludeProcessFlagsData(doc, flags, NULL);\n}\n\n\n// target function\nstatic void\nxmlXIncludeFreeRef(xmlXIncludeRefPtr ref) {\n    if (ref == NULL)\n\treturn;\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Freeing ref\\n\");\n#endif\n    if (ref->doc != NULL) {\n#ifdef DEBUG_XINCLUDE\n\txmlGenericError(xmlGenericErrorContext, \"Freeing doc %s\\n\", ref->URI);\n#endif\n\txmlFreeDoc(ref->doc);\n    }\n    if (ref->URI != NULL)\n\txmlFree(ref->URI);\n    if (ref->fragment != NULL)\n\txmlFree(ref->fragment);\n    if (ref->xptr != NULL)\n\txmlXPathFreeObject(ref->xptr);\n    xmlFree(ref);\n}\nstatic int\nxmlXIncludeLoadDoc(xmlXIncludeCtxtPtr ctxt, const xmlChar *url, int nr) {\n    xmlDocPtr doc;\n    xmlURIPtr uri;\n    xmlChar *URL;\n    xmlChar *fragment = NULL;\n    int i = 0;\n#ifdef LIBXML_XPTR_ENABLED\n    int saveFlags;\n#endif\n\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Loading doc %s:%d\\n\", url, nr);\n#endif\n    /*\n     * Check the URL and remove any fragment identifier\n     */\n    uri = xmlParseURI((const char *)url);\n    if (uri == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_HREF_URI,\n\t\t       \"invalid value URI %s\\n\", url);\n\treturn(-1);\n    }\n    if (uri->fragment != NULL) {\n\tfragment = (xmlChar *) uri->fragment;\n\turi->fragment = NULL;\n    }\n    if ((ctxt->incTab != NULL) && (ctxt->incTab[nr] != NULL) &&\n        (ctxt->incTab[nr]->fragment != NULL)) {\n\tif (fragment != NULL) xmlFree(fragment);\n\tfragment = xmlStrdup(ctxt->incTab[nr]->fragment);\n    }\n    URL = xmlSaveUri(uri);\n    xmlFreeURI(uri);\n    if (URL == NULL) {\n        if (ctxt->incTab != NULL)\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t   XML_XINCLUDE_HREF_URI,\n\t\t\t   \"invalid value URI %s\\n\", url);\n\telse\n\t    xmlXIncludeErr(ctxt, NULL,\n\t\t\t   XML_XINCLUDE_HREF_URI,\n\t\t\t   \"invalid value URI %s\\n\", url);\n\tif (fragment != NULL)\n\t    xmlFree(fragment);\n\treturn(-1);\n    }\n\n    /*\n     * Handling of references to the local document are done\n     * directly through ctxt->doc.\n     */\n    if ((URL[0] == 0) || (URL[0] == '#') ||\n\t((ctxt->doc != NULL) && (xmlStrEqual(URL, ctxt->doc->URL)))) {\n\tdoc = NULL;\n        goto loaded;\n    }\n\n    /*\n     * Prevent reloading twice the document.\n     */\n    for (i = 0; i < ctxt->incNr; i++) {\n\tif ((xmlStrEqual(URL, ctxt->incTab[i]->URI)) &&\n\t    (ctxt->incTab[i]->doc != NULL)) {\n\t    doc = ctxt->incTab[i]->doc;\n#ifdef DEBUG_XINCLUDE\n\t    printf(\"Already loaded %s\\n\", URL);\n#endif\n\t    goto loaded;\n\t}\n    }\n\n    /*\n     * Load it.\n     */\n#ifdef DEBUG_XINCLUDE\n    printf(\"loading %s\\n\", URL);\n#endif\n#ifdef LIBXML_XPTR_ENABLED\n    /*\n     * If this is an XPointer evaluation, we want to assure that\n     * all entities have been resolved prior to processing the\n     * referenced document\n     */\n    saveFlags = ctxt->parseFlags;\n    if (fragment != NULL) {\t/* if this is an XPointer eval */\n\tctxt->parseFlags |= XML_PARSE_NOENT;\n    }\n#endif\n\n    doc = xmlXIncludeParseFile(ctxt, (const char *)URL);\n#ifdef LIBXML_XPTR_ENABLED\n    ctxt->parseFlags = saveFlags;\n#endif\n    if (doc == NULL) {\n\txmlFree(URL);\n\tif (fragment != NULL)\n\t    xmlFree(fragment);\n\treturn(-1);\n    }\n    ctxt->incTab[nr]->doc = doc;\n    /*\n     * It's possible that the requested URL has been mapped to a\n     * completely different location (e.g. through a catalog entry).\n     * To check for this, we compare the URL with that of the doc\n     * and change it if they disagree (bug 146988).\n     */\n   if (!xmlStrEqual(URL, doc->URL)) {\n       xmlFree(URL);\n       URL = xmlStrdup(doc->URL);\n   }\n    for (i = nr + 1; i < ctxt->incNr; i++) {\n\tif (xmlStrEqual(URL, ctxt->incTab[i]->URI)) {\n\t    ctxt->incTab[nr]->count++;\n#ifdef DEBUG_XINCLUDE\n\t    printf(\"Increasing %s count since reused\\n\", URL);\n#endif\n            break;\n\t}\n    }\n\n    /*\n     * Make sure we have all entities fixed up\n     */\n    xmlXIncludeMergeEntities(ctxt, ctxt->doc, doc);\n\n    /*\n     * We don't need the DTD anymore, free up space\n    if (doc->intSubset != NULL) {\n\txmlUnlinkNode((xmlNodePtr) doc->intSubset);\n\txmlFreeNode((xmlNodePtr) doc->intSubset);\n\tdoc->intSubset = NULL;\n    }\n    if (doc->extSubset != NULL) {\n\txmlUnlinkNode((xmlNodePtr) doc->extSubset);\n\txmlFreeNode((xmlNodePtr) doc->extSubset);\n\tdoc->extSubset = NULL;\n    }\n     */\n    xmlXIncludeRecurseDoc(ctxt, doc, URL);\n\nloaded:\n    if (fragment == NULL) {\n\t/*\n\t * Add the top children list as the replacement copy.\n\t */\n\tif (doc == NULL)\n\t{\n\t    /* Hopefully a DTD declaration won't be copied from\n\t     * the same document */\n\t    ctxt->incTab[nr]->inc = xmlCopyNodeList(ctxt->doc->children);\n\t} else {\n\t    ctxt->incTab[nr]->inc = xmlXIncludeCopyNodeList(ctxt, ctxt->doc,\n\t\t                                       doc, doc->children);\n\t}\n    }\n#ifdef LIBXML_XPTR_ENABLED\n    else {\n\t/*\n\t * Computes the XPointer expression and make a copy used\n\t * as the replacement copy.\n\t */\n\txmlXPathObjectPtr xptr;\n\txmlXPathContextPtr xptrctxt;\n\txmlNodeSetPtr set;\n\n\tif (doc == NULL) {\n\t    xptrctxt = xmlXPtrNewContext(ctxt->doc, ctxt->incTab[nr]->ref,\n\t\t                         NULL);\n\t} else {\n\t    xptrctxt = xmlXPtrNewContext(doc, NULL, NULL);\n\t}\n\tif (xptrctxt == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_XPTR_FAILED,\n\t\t\t   \"could not create XPointer context\\n\", NULL);\n\t    xmlFree(URL);\n\t    xmlFree(fragment);\n\t    return(-1);\n\t}\n\txptr = xmlXPtrEval(fragment, xptrctxt);\n\tif (xptr == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_XPTR_FAILED,\n\t\t\t   \"XPointer evaluation failed: #%s\\n\",\n\t\t\t   fragment);\n\t    xmlXPathFreeContext(xptrctxt);\n\t    xmlFree(URL);\n\t    xmlFree(fragment);\n\t    return(-1);\n\t}\n\tswitch (xptr->type) {\n\t    case XPATH_UNDEFINED:\n\t    case XPATH_BOOLEAN:\n\t    case XPATH_NUMBER:\n\t    case XPATH_STRING:\n#ifdef LIBXML_XPTR_LOCS_ENABLED\n\t    case XPATH_POINT:\n#endif\n\t    case XPATH_USERS:\n\t    case XPATH_XSLT_TREE:\n\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t       \"XPointer is not a range: #%s\\n\",\n\t\t\t       fragment);\n                xmlXPathFreeObject(xptr);\n\t\txmlXPathFreeContext(xptrctxt);\n\t\txmlFree(URL);\n\t\txmlFree(fragment);\n\t\treturn(-1);\n\t    case XPATH_NODESET:\n\t        if ((xptr->nodesetval == NULL) ||\n\t\t    (xptr->nodesetval->nodeNr <= 0)) {\n                    xmlXPathFreeObject(xptr);\n\t\t    xmlXPathFreeContext(xptrctxt);\n\t\t    xmlFree(URL);\n\t\t    xmlFree(fragment);\n\t\t    return(-1);\n\t\t}\n\n#ifdef LIBXML_XPTR_LOCS_ENABLED\n\t    case XPATH_RANGE:\n\t    case XPATH_LOCATIONSET:\n\t\tbreak;\n#endif\n\t}\n\tset = xptr->nodesetval;\n\tif (set != NULL) {\n\t    for (i = 0;i < set->nodeNr;i++) {\n\t\tif (set->nodeTab[i] == NULL)\n\t\t    continue;\n\t\tswitch (set->nodeTab[i]->type) {\n\t\t    case XML_ELEMENT_NODE:\n\t\t    case XML_TEXT_NODE:\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t    case XML_ENTITY_NODE:\n\t\t    case XML_PI_NODE:\n\t\t    case XML_COMMENT_NODE:\n\t\t    case XML_DOCUMENT_NODE:\n\t\t    case XML_HTML_DOCUMENT_NODE:\n\t\t\tcontinue;\n\n\t\t    case XML_ATTRIBUTE_NODE:\n\t\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t\t       \"XPointer selects an attribute: #%s\\n\",\n\t\t\t\t       fragment);\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tcontinue;\n\t\t    case XML_NAMESPACE_DECL:\n\t\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t\t       \"XPointer selects a namespace: #%s\\n\",\n\t\t\t\t       fragment);\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tcontinue;\n\t\t    case XML_DOCUMENT_TYPE_NODE:\n\t\t    case XML_DOCUMENT_FRAG_NODE:\n\t\t    case XML_NOTATION_NODE:\n\t\t    case XML_DTD_NODE:\n\t\t    case XML_ELEMENT_DECL:\n\t\t    case XML_ATTRIBUTE_DECL:\n\t\t    case XML_ENTITY_DECL:\n\t\t    case XML_XINCLUDE_START:\n\t\t    case XML_XINCLUDE_END:\n\t\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t\t   \"XPointer selects unexpected nodes: #%s\\n\",\n\t\t\t\t       fragment);\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tcontinue; /* for */\n\t\t}\n\t    }\n\t}\n\tif (doc == NULL) {\n\t    ctxt->incTab[nr]->xptr = xptr;\n\t    ctxt->incTab[nr]->inc = NULL;\n\t} else {\n\t    ctxt->incTab[nr]->inc =\n\t\txmlXIncludeCopyXPointer(ctxt, ctxt->doc, doc, xptr);\n\t    xmlXPathFreeObject(xptr);\n\t}\n\txmlXPathFreeContext(xptrctxt);\n\txmlFree(fragment);\n    }\n#endif\n\n    /*\n     * Do the xml:base fixup if needed\n     */\n    if ((doc != NULL) && (URL != NULL) &&\n        (!(ctxt->parseFlags & XML_PARSE_NOBASEFIX)) &&\n\t(!(doc->parseFlags & XML_PARSE_NOBASEFIX))) {\n\txmlNodePtr node;\n\txmlChar *base;\n\txmlChar *curBase;\n\n\t/*\n\t * The base is only adjusted if \"necessary\", i.e. if the xinclude node\n\t * has a base specified, or the URL is relative\n\t */\n\tbase = xmlGetNsProp(ctxt->incTab[nr]->ref, BAD_CAST \"base\",\n\t\t\tXML_XML_NAMESPACE);\n\tif (base == NULL) {\n\t    /*\n\t     * No xml:base on the xinclude node, so we check whether the\n\t     * URI base is different than (relative to) the context base\n\t     */\n\t    curBase = xmlBuildRelativeURI(URL, ctxt->base);\n\t    if (curBase == NULL) {\t/* Error return */\n\t        xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_HREF_URI,\n\t\t       \"trying to build relative URI from %s\\n\", URL);\n\t    } else {\n\t\t/* If the URI doesn't contain a slash, it's not relative */\n\t        if (!xmlStrchr(curBase, '/'))\n\t\t    xmlFree(curBase);\n\t\telse\n\t\t    base = curBase;\n\t    }\n\t}\n\tif (base != NULL) {\t/* Adjustment may be needed */\n\t    node = ctxt->incTab[nr]->inc;\n\t    while (node != NULL) {\n\t\t/* Only work on element nodes */\n\t\tif (node->type == XML_ELEMENT_NODE) {\n\t\t    curBase = xmlNodeGetBase(node->doc, node);\n\t\t    /* If no current base, set it */\n\t\t    if (curBase == NULL) {\n\t\t\txmlNodeSetBase(node, base);\n\t\t    } else {\n\t\t\t/*\n\t\t\t * If the current base is the same as the\n\t\t\t * URL of the document, then reset it to be\n\t\t\t * the specified xml:base or the relative URI\n\t\t\t */\n\t\t\tif (xmlStrEqual(curBase, node->doc->URL)) {\n\t\t\t    xmlNodeSetBase(node, base);\n\t\t\t} else {\n\t\t\t    /*\n\t\t\t     * If the element already has an xml:base\n\t\t\t     * set, then relativise it if necessary\n\t\t\t     */\n\t\t\t    xmlChar *xmlBase;\n\t\t\t    xmlBase = xmlGetNsProp(node,\n\t\t\t\t\t    BAD_CAST \"base\",\n\t\t\t\t\t    XML_XML_NAMESPACE);\n\t\t\t    if (xmlBase != NULL) {\n\t\t\t\txmlChar *relBase;\n\t\t\t\trelBase = xmlBuildURI(xmlBase, base);\n\t\t\t\tif (relBase == NULL) { /* error */\n\t\t\t\t    xmlXIncludeErr(ctxt,\n\t\t\t\t\t\tctxt->incTab[nr]->ref,\n\t\t\t\t\t\tXML_XINCLUDE_HREF_URI,\n\t\t\t\t\t\"trying to rebuild base from %s\\n\",\n\t\t\t\t\t\txmlBase);\n\t\t\t\t} else {\n\t\t\t\t    xmlNodeSetBase(node, relBase);\n\t\t\t\t    xmlFree(relBase);\n\t\t\t\t}\n\t\t\t\txmlFree(xmlBase);\n\t\t\t    }\n\t\t\t}\n\t\t\txmlFree(curBase);\n\t\t    }\n\t\t}\n\t        node = node->next;\n\t    }\n\t    xmlFree(base);\n\t}\n    }\n    if ((nr < ctxt->incNr) && (ctxt->incTab[nr]->doc != NULL) &&\n\t(ctxt->incTab[nr]->count <= 1)) {\n#ifdef DEBUG_XINCLUDE\n        printf(\"freeing %s\\n\", ctxt->incTab[nr]->doc->URL);\n#endif\n\txmlFreeDoc(ctxt->incTab[nr]->doc);\n\tctxt->incTab[nr]->doc = NULL;\n    }\n    xmlFree(URL);\n    return(0);\n}\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * TODO: The phases must run separately for recursive inclusions.\n     *\n     * - Phase 1 should start with top-level XInclude nodes, load documents,\n     *   execute XPointer expressions, then process only the result nodes\n     *   (not whole document, see bug #324081) and only for phase 1\n     *   recursively. We will need a backreference from xmlNodes to\n     *   xmlIncludeRefs to detect references that were already visited.\n     *   This can also be used for proper cycle detection, see bug #344240.\n     *\n     * - Phase 2 should visit all top-level XInclude nodes and expand\n     *   possible subreferences in the replacement recursively.\n     *\n     * - Phase 3 should finally replace the top-level XInclude nodes.\n     *   It could also be run together with phase 2.\n     */\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   ((cur->type == XML_DOCUMENT_NODE) ||\n                    (cur->type == XML_ELEMENT_NODE))) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n            (ctxt->incTab[i]->xptr != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}\n",
    "target": 1,
    "idx": 1052554,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nEXPORT void\ndwg_free_object (Dwg_Object *obj)\n{\n  int error = 0;\n  long unsigned int j;\n  Dwg_Data *dwg;\n  Bit_Chain *dat = &pdat;\n\n  if (obj && obj->parent)\n    {\n      dwg = obj->parent;\n      dat->version = dwg->header.version;\n      dat->from_version = dwg->header.from_version;\n    }\n  else\n    return;\n  if (obj->type == DWG_TYPE_FREED || obj->tio.object == NULL)\n    return;\n\n  PRE (R_13) {\n    free_preR13_object (obj);\n    return;\n  }\n\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      dwg_free_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      dwg_free_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      dwg_free_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      dwg_free_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      dwg_free_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      dwg_free_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      dwg_free_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      dwg_free_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      dwg_free_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      dwg_free_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      dwg_free_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      dwg_free_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      dwg_free_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      dwg_free_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      dwg_free_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      dwg_free_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      dwg_free_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      dwg_free_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      dwg_free_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      dwg_free_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      dwg_free_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      dwg_free_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      dwg_free_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      dwg_free_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      dwg_free_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      dwg_free_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      dwg_free__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      dwg_free_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      dwg_free_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      dwg_free_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      dwg_free_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      dwg_free_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      dwg_free_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      dwg_free_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      dwg_free_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      dwg_free_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      dwg_free__3DSOLID (dat, obj);\n      break; /* Check the type of the object */\n    case DWG_TYPE_BODY:\n      dwg_free_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      dwg_free_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      dwg_free_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      dwg_free_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      dwg_free_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      dwg_free_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      dwg_free_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      dwg_free_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      dwg_free_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      dwg_free_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      dwg_free_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      dwg_free_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      dwg_free_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      dwg_free_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      dwg_free_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      dwg_free_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      dwg_free_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      dwg_free_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      dwg_free_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      dwg_free_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      dwg_free_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      dwg_free_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      dwg_free_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      dwg_free_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      dwg_free_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      dwg_free_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VX_CONTROL:\n      dwg_free_VX_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VX_TABLE_RECORD:\n      dwg_free_VX_TABLE_RECORD (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      dwg_free_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      dwg_free_MLINESTYLE (dat, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      dwg_free_OLE2FRAME (dat, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      dwg_free_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      dwg_free_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      dwg_free_LWPOLYLINE (dat, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      dwg_free_HATCH (dat, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      dwg_free_XRECORD (dat, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      dwg_free_PLACEHOLDER (dat, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      dwg_free_OLEFRAME (dat, obj);\n      break;\n#ifdef DEBUG_VBA_PROJECT\n    case DWG_TYPE_VBA_PROJECT:\n      dwg_free_VBA_PROJECT (dat, obj);\n      break;\n#endif\n    case DWG_TYPE_LAYOUT:\n      dwg_free_LAYOUT (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      dwg_free_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      dwg_free_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type\n          && obj->fixedtype == DWG_TYPE_LAYOUT)\n        {\n          SINCE (R_13)\n          {\n            dwg_free_LAYOUT (dat, obj); // XXX avoid double-free, esp. in eed\n          }\n        }\n      else if ((error = dwg_free_variable_type (obj->parent, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)\n              dwg_free_UNKNOWN_ENT (dat, obj);\n          else if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)\n              dwg_free_UNKNOWN_OBJ (dat, obj);\n        }\n    }\n  /* With indxf the dxfname is dynamic, just the name is const */\n  if (dwg->opts & DWG_OPTS_IN)\n    FREE_IF (obj->dxfname);\n  /* With injson even the name is dynamic */\n  if (dwg->opts & DWG_OPTS_INJSON)\n    FREE_IF (obj->name);\n  obj->type = DWG_TYPE_FREED;\n}\n\nvoid\ndwg_free (Dwg_Data *dwg)\n{\n  BITCODE_BL i;\n  if (dwg)\n    {\n      pdat.version = dwg->header.version;\n      pdat.from_version = dwg->header.from_version;\n      if (dwg->opts)\n        {\n          loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n          pdat.opts = dwg->opts;\n        }\n#ifdef USE_TRACING\n      /* Before starting, set the logging level, but only do so once.  */\n      if (!env_var_checked_p)\n        {\n          char *probe = getenv (\"LIBREDWG_TRACE\");\n          if (probe)\n            loglevel = atoi (probe);\n          env_var_checked_p = 1;\n        }\n#endif /* USE_TRACING */\n      LOG_INFO (\"\\n============\\ndwg_free\\n\")\n      // copied table fields have duplicate pointers, but are freed only once\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (!dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      dwg_free_header_vars (dwg);\n      dwg_free_summaryinfo (dwg);\n      FREE_IF (dwg->thumbnail.chain);\n      if (dwg->header.section_infohdr.num_desc)\n        {\n          for (i = 0; i < dwg->header.section_infohdr.num_desc; ++i)\n            FREE_IF (dwg->header.section_info[i].sections);\n          FREE_IF (dwg->header.section_info);\n        }\n      dwg_free_appinfo (dwg);\n      dwg_free_filedeplist (dwg);\n      dwg_free_security (dwg);\n      dwg_free_acds (dwg);\n\n      FREE_IF (dwg->vbaproject.unknown_bits);\n      FREE_IF (dwg->revhistory.histories);\n      FREE_IF (dwg->appinfohistory.unknown_bits);\n      //FREE_IF (dwg->objfreespace...);\n      FREE_IF (dwg->Template.description);\n      FREE_IF (dwg->header.section);\n      for (i = 0; i < dwg->second_header.num_handlers; i++)\n        FREE_IF (dwg->second_header.handlers[i].data);\n      // auxheader has no strings\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      if (dwg->num_classes && dwg->dwg_class)\n        {\n          for (i = 0; i < dwg->num_classes; ++i)\n            {\n              FREE_IF (dwg->dwg_class[i].appname);\n              FREE_IF (dwg->dwg_class[i].cppname);\n              FREE_IF (dwg->dwg_class[i].dxfname);\n              if (dwg->header.from_version >= R_2007)\n                FREE_IF (dwg->dwg_class[i].dxfname_u);\n            }\n        }\n      FREE_IF (dwg->dwg_class);\n      if (dwg->object_ref)\n        {\n          LOG_HANDLE (\"free %d global refs\\n\", dwg->num_object_refs)\n          for (i = 0; i < dwg->num_object_refs; ++i)\n            {\n              //LOG_HANDLE (\"free ref %d\\n\", i)\n              FREE_IF (dwg->object_ref[i]);\n            }\n        }\n      FREE_IF (dwg->object_ref);\n      for (i = 0; i < dwg->num_acis_sab_hdl; ++i)\n        {\n          FREE_IF (dwg->acis_sab_hdl[i]);\n        }\n      FREE_IF (dwg->acis_sab_hdl);\n      FREE_IF (dwg->object);\n      if (dwg->object_map)\n        hash_free (dwg->object_map);\n      dwg->num_objects = dwg->num_classes = dwg->num_object_refs = 0;\n#undef FREE_IF\n    }\n}\n\n\n// target function\nATTRIBUTE_MALLOC\nBITCODE_TV\nbit_read_TV (Bit_Chain *restrict dat)\n{\n  unsigned int i;\n  unsigned int length;\n  unsigned char *chain;\n\n  CHK_OVERFLOW_PLUS (1,__FUNCTION__,NULL)\n  length = bit_read_BS (dat);\n  CHK_OVERFLOW_PLUS (length,__FUNCTION__,NULL)\n  chain = (unsigned char *)malloc (length + 1);\n  if (!chain)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"Out of memory\");\n      return NULL;\n    }\n  for (i = 0; i < length; i++)\n    chain[i] = bit_read_RC (dat);\n  // check if the string is already zero-terminated or not.\n  // only observed >=r2004 as writer app\n  if (length > 0 && dat->from_version > R_2000 && chain[length - 1] != '\\0')\n    LOG_HANDLE (\"TV-not-ZERO %u\\n \", length)\n  else if (length > 0 && dat->from_version <= R_2000 && chain[length - 1] == '\\0')\n    LOG_HANDLE (\"TV-ZERO %u\\n\", length)\n  // normally not needed, as the DWG since r2004 itself contains the ending \\0 as last char\n  chain[i] = '\\0';\n  return (char *)chain;\n}\nvoid\nbit_write_TV (Bit_Chain *restrict dat, BITCODE_TV restrict chain)\n{\n  int i;\n  int length = (chain && *chain) ? strlen ((const char *)chain) : 0;\n  if (dat->version <= R_2000 && length)\n    length++;\n  bit_write_BS (dat, length);\n  for (i = 0; i < length; i++)\n    bit_write_RC (dat, (unsigned char)chain[i]);\n}\nstatic int ishex (int c)\n{\n  return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')\n          || (c >= 'A' && c <= 'F'));\n}\nEXPORT void\ndwg_free_object (Dwg_Object *obj)\n{\n  int error = 0;\n  long unsigned int j;\n  Dwg_Data *dwg;\n  Bit_Chain *dat = &pdat;\n\n  if (obj && obj->parent)\n    {\n      dwg = obj->parent;\n      dat->version = dwg->header.version;\n      dat->from_version = dwg->header.from_version;\n    }\n  else\n    return;\n  if (obj->type == DWG_TYPE_FREED || obj->tio.object == NULL)\n    return;\n\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      dwg_free_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      dwg_free_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      dwg_free_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      dwg_free_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      dwg_free_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      dwg_free_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      dwg_free_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      dwg_free_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      dwg_free_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      dwg_free_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      dwg_free_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      dwg_free_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      dwg_free_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      dwg_free_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      dwg_free_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      dwg_free_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      dwg_free_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      dwg_free_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      dwg_free_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      dwg_free_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      dwg_free_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      dwg_free_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      dwg_free_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      dwg_free_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      dwg_free_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      dwg_free_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      dwg_free__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      dwg_free_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      dwg_free_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      dwg_free_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      dwg_free_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      dwg_free_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      dwg_free_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      dwg_free_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      dwg_free_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      dwg_free_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      dwg_free__3DSOLID (dat, obj);\n      break; /* Check the type of the object */\n    case DWG_TYPE_BODY:\n      dwg_free_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      dwg_free_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      dwg_free_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      dwg_free_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      dwg_free_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      dwg_free_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      dwg_free_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      dwg_free_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      dwg_free_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      dwg_free_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      dwg_free_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      dwg_free_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      dwg_free_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      dwg_free_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      dwg_free_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      dwg_free_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      dwg_free_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      dwg_free_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      dwg_free_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      dwg_free_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      dwg_free_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      dwg_free_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      dwg_free_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      dwg_free_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      dwg_free_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      dwg_free_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VX_CONTROL:\n      dwg_free_VX_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VX_TABLE_RECORD:\n      dwg_free_VX_TABLE_RECORD (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      dwg_free_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      dwg_free_MLINESTYLE (dat, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      dwg_free_OLE2FRAME (dat, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      dwg_free_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      dwg_free_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      dwg_free_LWPOLYLINE (dat, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      dwg_free_HATCH (dat, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      dwg_free_XRECORD (dat, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      dwg_free_PLACEHOLDER (dat, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      dwg_free_OLEFRAME (dat, obj);\n      break;\n#ifdef DEBUG_VBA_PROJECT\n    case DWG_TYPE_VBA_PROJECT:\n      dwg_free_VBA_PROJECT (dat, obj);\n      break;\n#endif\n    case DWG_TYPE_LAYOUT:\n      dwg_free_LAYOUT (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      dwg_free_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      dwg_free_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type\n          && obj->fixedtype == DWG_TYPE_LAYOUT)\n        {\n          SINCE (R_13)\n          {\n            dwg_free_LAYOUT (dat, obj); // XXX avoid double-free, esp. in eed\n          }\n        }\n      else if ((error = dwg_free_variable_type (obj->parent, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)\n              dwg_free_UNKNOWN_ENT (dat, obj);\n          else if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)\n              dwg_free_UNKNOWN_OBJ (dat, obj);\n        }\n    }\n  /* With indxf the dxfname is dynamic, just the name is const */\n  if (dwg->opts & DWG_OPTS_IN)\n    FREE_IF (obj->dxfname);\n  /* With injson even the name is dynamic */\n  if (dwg->opts & DWG_OPTS_INJSON)\n    FREE_IF (obj->name);\n  obj->type = DWG_TYPE_FREED;\n}\n",
    "target": 1,
    "idx": 1034377,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\n    size_t array_like_size() const { return m_storage->array_like_size(); }\n\n    void append(Value value, PropertyAttributes attributes = default_attributes) { put(nullptr, array_like_size(), value, attributes, false); }\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Interpreter::execute_statement(GlobalObject& global_object, const Statement& statement, ScopeType scope_type)\n{\n    if (!is<ScopeNode>(statement))\n        return statement.execute(*this, global_object);\n\n    auto& block = static_cast<const ScopeNode&>(statement);\n    enter_scope(block, scope_type, global_object);\n\n    if (block.children().is_empty())\n        vm().set_last_value({}, js_undefined());\n\n    for (auto& node : block.children()) {\n        vm().set_last_value({}, node.execute(*this, global_object));\n        if (vm().should_unwind()) {\n            if (!block.label().is_null() && vm().should_unwind_until(ScopeType::Breakable, block.label()))\n                vm().stop_unwind();\n            break;\n        }\n    }\n\n    bool did_return = vm().unwind_until() == ScopeType::Function;\n\n    if (vm().unwind_until() == scope_type)\n        vm().unwind(ScopeType::None);\n\n    exit_scope(block);\n\n    return did_return ? vm().last_value() : js_undefined();\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Interpreter::run(GlobalObject& global_object, const Program& program)\n{\n    auto& vm = this->vm();\n    VERIFY(!vm.exception());\n\n    VM::InterpreterExecutionScope scope(*this);\n\n    CallFrame global_call_frame;\n    global_call_frame.this_value = &global_object;\n    static FlyString global_execution_context_name = \"(global execution context)\";\n    global_call_frame.function_name = global_execution_context_name;\n    global_call_frame.scope = &global_object;\n    VERIFY(!vm.exception());\n    global_call_frame.is_strict_mode = program.is_strict_mode();\n    vm.push_call_frame(global_call_frame, global_object);\n    VERIFY(!vm.exception());\n    auto result = program.execute(*this, global_object);\n    vm.pop_call_frame();\n    return result;\n}\n\n\n// target function\nArray::Array(Object& prototype)\n    : Object(prototype)\n{\n    auto& vm = this->vm();\n    define_native_property(vm.names.length, length_getter, length_setter, Attribute::Writable);\n}\nArray::~Array()\n{\n}\nArrayPrototype::ArrayPrototype(GlobalObject& global_object)\n    : Object(*global_object.object_prototype())\n{\n}\nvoid ArrayPrototype::initialize(GlobalObject& global_object)\n{\n    auto& vm = this->vm();\n    Object::initialize(global_object);\n    u8 attr = Attribute::Writable | Attribute::Configurable;\n\n    define_native_function(vm.names.filter, filter, 1, attr);\n    define_native_function(vm.names.forEach, for_each, 1, attr);\n    define_native_function(vm.names.map, map, 1, attr);\n    define_native_function(vm.names.pop, pop, 0, attr);\n    define_native_function(vm.names.push, push, 1, attr);\n    define_native_function(vm.names.shift, shift, 0, attr);\n    define_native_function(vm.names.toString, to_string, 0, attr);\n    define_native_function(vm.names.toLocaleString, to_locale_string, 0, attr);\n    define_native_function(vm.names.unshift, unshift, 1, attr);\n    define_native_function(vm.names.join, join, 1, attr);\n    define_native_function(vm.names.concat, concat, 1, attr);\n    define_native_function(vm.names.slice, slice, 2, attr);\n    define_native_function(vm.names.indexOf, index_of, 1, attr);\n    define_native_function(vm.names.reduce, reduce, 1, attr);\n    define_native_function(vm.names.reduceRight, reduce_right, 1, attr);\n    define_native_function(vm.names.reverse, reverse, 0, attr);\n    define_native_function(vm.names.sort, sort, 1, attr);\n    define_native_function(vm.names.lastIndexOf, last_index_of, 1, attr);\n    define_native_function(vm.names.includes, includes, 1, attr);\n    define_native_function(vm.names.find, find, 1, attr);\n    define_native_function(vm.names.findIndex, find_index, 1, attr);\n    define_native_function(vm.names.some, some, 1, attr);\n    define_native_function(vm.names.every, every, 1, attr);\n    define_native_function(vm.names.splice, splice, 2, attr);\n    define_native_function(vm.names.fill, fill, 1, attr);\n    define_native_function(vm.names.values, values, 0, attr);\n    define_native_function(vm.names.flat, flat, 0, attr);\n    define_property(vm.names.length, Value(0), Attribute::Configurable);\n\n    // Use define_property here instead of define_native_function so that\n    // Object.is(Array.prototype[Symbol.iterator], Array.prototype.values)\n    // evaluates to true\n    define_property(vm.well_known_symbol_iterator(), get(vm.names.values), attr);\n}\n",
    "target": 1,
    "idx": 1030921,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic inline void\nstack_copy(mrb_value *dst, const mrb_value *src, size_t size)\n{\n  memcpy(dst, src, sizeof(mrb_value)*size);\n}\n\nMRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend_adjust(mrb, n + argc + 3, &argv);\n    if (argc >= 15) {\n      ci->stack[n+1] = mrb_ary_new_from_values(mrb, argc, argv);\n      ci->stack[n+2] = blk;\n      argc = 15;\n    }\n    else {\n      if (argc > 0)\n        stack_copy(ci->stack+n+1, argv, argc);\n      ci->stack[n+argc+1] = blk;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      uint16_t ac = (uint16_t)argc;\n      m = prepare_missing(mrb, self, mid, &c, (uint32_t)n, &ac, mrb_nil_value(), 0);\n      argc = (mrb_int)ac;\n      mid = MRB_SYM(method_missing);\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, (uint16_t)argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    ci->stack[0] = self;\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\n\nmrb_value\nmrb_instance_new(mrb_state *mrb, mrb_value cv)\n{\n  mrb_value obj, blk;\n  const mrb_value *argv;\n  mrb_int argc;\n  mrb_sym init;\n\n  mrb_get_args(mrb, \"*!&\", &argv, &argc, &blk);\n  obj = mrb_instance_alloc(mrb, cv);\n  init = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, init, mrb_do_nothing)) {\n    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);\n  }\n  return obj;\n}\n\nMRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend_adjust(mrb, n + argc + 3, &argv);\n    if (argc >= 15) {\n      ci->stack[n+1] = mrb_ary_new_from_values(mrb, argc, argv);\n      ci->stack[n+2] = blk;\n      argc = 15;\n    }\n    else {\n      if (argc > 0)\n        stack_copy(ci->stack+n+1, argv, argc);\n      ci->stack[n+argc+1] = blk;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      uint16_t ac = (uint16_t)argc;\n      m = prepare_missing(mrb, self, mid, &c, (uint32_t)n, &ac, mrb_nil_value(), 0);\n      argc = (mrb_int)ac;\n      mid = MRB_SYM(method_missing);\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, (uint16_t)argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    ci->stack[0] = self;\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\n\nMRB_API mrb_value\nmrb_funcall_argv(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv)\n{\n  return mrb_funcall_with_block(mrb, self, mid, argc, argv, mrb_nil_value());\n}\n\nMRB_API mrb_value\nmrb_make_exception(mrb_state *mrb, mrb_int argc, const mrb_value *argv)\n{\n  mrb_value mesg;\n  int n;\n\n  mesg = mrb_nil_value();\n  switch (argc) {\n    case 0:\n    break;\n    case 1:\n      if (mrb_nil_p(argv[0]))\n        break;\n      if (mrb_string_p(argv[0])) {\n        mesg = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, argv[0]);\n        break;\n      }\n      n = 0;\n      goto exception_call;\n\n    case 2:\n    case 3:\n      n = 1;\nexception_call:\n      {\n        mrb_sym exc = MRB_SYM(exception);\n        if (mrb_respond_to(mrb, argv[0], exc)) {\n          mesg = mrb_funcall_argv(mrb, argv[0], exc, n, argv+1);\n        }\n        else {\n          /* undef */\n          mrb_raise(mrb, E_TYPE_ERROR, \"exception class/object expected\");\n        }\n      }\n\n      break;\n    default:\n      mrb_argnum_error(mrb, argc, 0, 3);\n      break;\n  }\n  if (argc > 0) {\n    if (!mrb_obj_is_kind_of(mrb, mesg, mrb->eException_class))\n      mrb_raise(mrb, mrb->eException_class, \"exception object expected\");\n    if (argc > 2)\n      set_backtrace(mrb, mesg, argv[2]);\n  }\n\n  return mesg;\n}\n\nMRB_API mrb_value\nmrb_f_raise(mrb_state *mrb, mrb_value self)\n{\n  mrb_value a[2], exc;\n  mrb_int argc;\n\n  argc = mrb_get_args(mrb, \"|oo\", &a[0], &a[1]);\n  mrb->c->ci->mid = 0;\n  switch (argc) {\n  case 0:\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"\");\n    break;\n  case 1:\n    if (mrb_string_p(a[0])) {\n      a[1] = a[0];\n      argc = 2;\n      a[0] = mrb_obj_value(E_RUNTIME_ERROR);\n    }\n    /* fall through */\n  default:\n    exc = mrb_make_exception(mrb, argc, a);\n    mrb_exc_raise(mrb, exc);\n    break;\n  }\n  return mrb_nil_value();            /* not reached */\n}\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nint FuzzRB(const uint8_t *Data, size_t size) {\n\tmrb_value v;\n\tmrb_state *mrb = mrb_open();\n\tif (!mrb)\n\t\treturn 0;\n\n\tchar *code = (char *)malloc(size+1);\n\tif (!code)\n\t\treturn 0;\n\tmemcpy(code, Data, size);\n\tcode[size] = '\\0';\n\n\tif (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n\t\t// With libFuzzer binary run this to generate an RB file x.rb:\n\t\t// PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n\t\tstd::ofstream of(dump_path);\n\t\tof.write(code, size);\n\t}\n\tv = mrb_load_string(mrb, code);\n\tmrb_close(mrb);\n\n\tfree(code);\n\treturn 0;\n}\n\n\n\n\n// target function\nMRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n    ptrdiff_t voff = -1;\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {\n      voff = argv - mrb->c->stbase;\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend(mrb, n + argc + 3);\n    if (argc >= 15) {\n      ci->stack[n+1] = mrb_ary_new_from_values(mrb, argc, argv);\n      ci->stack[n+2] = blk;\n      argc = 15;\n    }\n    else {\n      if (argc > 0)\n        stack_copy(ci->stack+n+1, argv, argc);\n      ci->stack[n+argc+1] = blk;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      uint16_t ac = (uint16_t)argc;\n      m = prepare_missing(mrb, self, mid, &c, (uint32_t)n, &ac, mrb_nil_value(), 0);\n      argc = (mrb_int)ac;\n      mid = MRB_SYM(method_missing);\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, (uint16_t)argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    if (voff >= 0) {\n      argv = mrb->c->stbase + voff;\n    }\n    ci->stack[0] = self;\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\nMRB_API mrb_value\nmrb_yield_with_class(mrb_state *mrb, mrb_value b, mrb_int argc, const mrb_value *argv, mrb_value self, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_sym mid = mrb->c->ci->mid;\n  mrb_callinfo *ci;\n  mrb_value val;\n  mrb_int n;\n\n  check_block(mrb, b);\n  ci = mrb->c->ci;\n  n = mrb_ci_nregs(ci);\n  p = mrb_proc_ptr(b);\n  ci = cipush(mrb, n, CINFO_SKIP, c, p, mid, 0 /* dummy */);\n  ci->nk = 0;\n  if (argc >= CALL_MAXARGS) {\n    ci->n = 15;\n    n = 3;\n  }\n  else {\n    ci->n = (uint8_t)argc;\n    n = argc + 2;\n  }\n  mrb_stack_extend(mrb, n);\n  mrb->c->ci->stack[0] = self;\n  if (ci->n == 15) {\n    mrb->c->ci->stack[1] = mrb_ary_new_from_values(mrb, argc, argv);\n    argc = 1;\n  }\n  else if (argc > 0) {\n    stack_copy(mrb->c->ci->stack+1, argv, argc);\n  }\n  mrb->c->ci->stack[argc+1] = mrb_nil_value(); /* clear blk */\n\n  if (MRB_PROC_CFUNC_P(p)) {\n    ci->cci = CINFO_DIRECT;\n    val = MRB_PROC_CFUNC(p)(mrb, self);\n    cipop(mrb);\n  }\n  else {\n    val = mrb_run(mrb, p, self);\n  }\n  return val;\n}\n",
    "target": 1,
    "idx": 1047213,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n\n\nstatic void\nfz_draw_pop_clip(fz_context *ctx, fz_device *devp)\n{\n\tfz_draw_device *dev = (fz_draw_device*)devp;\n\tfz_draw_state *state;\n\n\tif (dev->top == 0)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"unexpected pop clip\");\n\n\tstate = pop_stack(ctx, dev, \"clip\");\n\n\t/* We can get here with state[1].mask == NULL if the clipping actually\n\t * resolved to a rectangle earlier.\n\t */\n\tif (state[1].mask)\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top, \"\");\n\t\tfz_dump_blend(ctx, \"Clipping \", state[1].dest);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n\t\tfz_dump_blend(ctx, \" onto \", state[0].dest);\n\t\tif (state[0].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[0].shape);\n\t\tif (state[0].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[0].group_alpha);\n\t\tfz_dump_blend(ctx, \" with \", state[1].mask);\n#endif\n\n\t\tfz_paint_pixmap_with_mask(state[0].dest, state[1].dest, state[1].mask);\n\t\tif (state[0].shape != state[1].shape)\n\t\t{\n\t\t\tfz_paint_pixmap_with_mask(state[0].shape, state[1].shape, state[1].mask);\n\t\t\tfz_drop_pixmap(ctx, state[1].shape);\n\t\t\tstate[1].shape = NULL;\n\t\t}\n\t\tif (state[0].group_alpha != state[1].group_alpha)\n\t\t{\n\t\t\tfz_paint_pixmap_with_mask(state[0].group_alpha, state[1].group_alpha, state[1].mask);\n\t\t\tfz_drop_pixmap(ctx, state[1].group_alpha);\n\t\t\tstate[1].group_alpha = NULL;\n\t\t}\n\t\tfz_drop_pixmap(ctx, state[1].mask);\n\t\tstate[1].mask = NULL;\n\t\tfz_drop_pixmap(ctx, state[1].dest);\n\t\tstate[1].dest = NULL;\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tfz_dump_blend(ctx, \" to get \", state[0].dest);\n\t\tif (state[0].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[0].shape);\n\t\tif (state[0].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[0].group_alpha);\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\telse\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top, \"Clip end\\n\");\n#endif\n\t}\n}\n\nvoid\nfz_pop_clip(fz_context *ctx, fz_device *dev)\n{\n\tpop_clip_stack(ctx, dev, fz_device_container_stack_is_clip);\n\n\tif (dev->pop_clip)\n\t{\n\t\tfz_try(ctx)\n\t\t\tdev->pop_clip(ctx, dev);\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tfz_disable_device(ctx, dev);\n\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}\n\nstatic void\npdf_show_path(fz_context *ctx, pdf_run_processor *pr, int doclose, int dofill, int dostroke, int even_odd)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tfz_path *path;\n\tfz_rect bbox;\n\tsoftmask_save softmask = { NULL };\n\tint knockout_group = 0;\n\n\tif (dostroke) {\n\t\tif (pr->dev->flags & (FZ_DEVFLAG_STROKECOLOR_UNDEFINED | FZ_DEVFLAG_LINEJOIN_UNDEFINED | FZ_DEVFLAG_LINEWIDTH_UNDEFINED))\n\t\t\tpr->dev->flags |= FZ_DEVFLAG_UNCACHEABLE;\n\t\telse if (gstate->stroke_state->dash_len != 0 && pr->dev->flags & (FZ_DEVFLAG_STARTCAP_UNDEFINED | FZ_DEVFLAG_DASHCAP_UNDEFINED | FZ_DEVFLAG_ENDCAP_UNDEFINED))\n\t\t\tpr->dev->flags |= FZ_DEVFLAG_UNCACHEABLE;\n\t\telse if (gstate->stroke_state->linejoin == FZ_LINEJOIN_MITER && (pr->dev->flags & FZ_DEVFLAG_MITERLIMIT_UNDEFINED))\n\t\t\tpr->dev->flags |= FZ_DEVFLAG_UNCACHEABLE;\n\t}\n\tif (dofill) {\n\t\tif (pr->dev->flags & FZ_DEVFLAG_FILLCOLOR_UNDEFINED)\n\t\t\tpr->dev->flags |= FZ_DEVFLAG_UNCACHEABLE;\n\t}\n\n\tpath = pr->path;\n\tpr->path = fz_new_path(ctx);\n\n\tfz_try(ctx)\n\t{\n\t\tif (doclose)\n\t\t\tfz_closepath(ctx, path);\n\n\t\tbbox = fz_bound_path(ctx, path, (dostroke ? gstate->stroke_state : NULL), gstate->ctm);\n\n\t\tif (pr->super.hidden)\n\t\t\tdostroke = dofill = 0;\n\n\t\tif (dofill || dostroke)\n\t\t\tgstate = pdf_begin_group(ctx, pr, bbox, &softmask);\n\n\t\tif (dofill && dostroke)\n\t\t{\n\t\t\t/* We may need to push a knockout group */\n\t\t\tif (gstate->stroke.alpha == 0)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't do anything */\n\t\t\t}\n\t\t\telse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't show up */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tknockout_group = 1;\n\t\t\t\tfz_begin_group(ctx, pr->dev, bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (dofill)\n\t\t{\n\t\t\tswitch (gstate->fill.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_fill_path(ctx, pr->dev, path, even_odd, gstate->ctm,\n\t\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, gstate->fill.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->fill.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, gstate->ctm, bbox);\n\t\t\t\t\tgstate = pdf_show_pattern(ctx, pr, gstate->fill.pattern, gstate->fill.gstate_num, bbox, PDF_FILL);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->fill.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, gstate->ctm, bbox);\n\t\t\t\t\t/* The cluster and page 2 of patterns.pdf shows that fz_fill_shade should NOT be called with gstate->ctm. */\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, gstate->fill.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dostroke)\n\t\t{\n\t\t\tswitch (gstate->stroke.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, gstate->ctm,\n\t\t\t\t\tgstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, gstate->stroke.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->stroke.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, gstate->ctm, bbox);\n\t\t\t\t\tgstate = pdf_show_pattern(ctx, pr, gstate->stroke.pattern, gstate->stroke.gstate_num, bbox, PDF_STROKE);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->stroke.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, gstate->ctm, bbox);\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, gstate->stroke.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (knockout_group)\n\t\t\tfz_end_group(ctx, pr->dev);\n\n\t\tif (dofill || dostroke)\n\t\t\tpdf_end_group(ctx, pr, &softmask);\n\n\t\tif (pr->clip)\n\t\t{\n\t\t\tgstate->clip_depth++;\n\t\t\tfz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, gstate->ctm, bbox);\n\t\t\tpr->clip = 0;\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_path(ctx, path);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, softmask.softmask);\n\t\tpdf_drop_obj(ctx, softmask.page_resources);\n\t\tfz_rethrow(ctx);\n\t}\n}\n\nstatic void pdf_run_fstar(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_path(ctx, pr, 0, 1, 0, 1);\n}\n\nstatic void\npdf_process_stream(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm)\n{\n\tpdf_document *doc = csi->doc;\n\tpdf_lexbuf *buf = csi->buf;\n\tfz_cookie *cookie = csi->cookie;\n\n\tpdf_token tok = PDF_TOK_ERROR;\n\tint in_text_array = 0;\n\tint syntax_errors = 0;\n\n\t/* make sure we have a clean slate if we come here from flush_text */\n\tpdf_clear_stack(ctx, csi);\n\n\tfz_var(in_text_array);\n\tfz_var(tok);\n\n\tif (cookie)\n\t{\n\t\tcookie->progress_max = -1;\n\t\tcookie->progress = 0;\n\t}\n\n\tdo\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\t/* Check the cookie */\n\t\t\t\tif (cookie)\n\t\t\t\t{\n\t\t\t\t\tif (cookie->abort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcookie->progress++;\n\t\t\t\t}\n\n\t\t\t\ttok = pdf_lex(ctx, stm, buf);\n\n\t\t\t\tif (in_text_array)\n\t\t\t\t{\n\t\t\t\t\tswitch(tok)\n\t\t\t\t\t{\n\t\t\t\t\tcase PDF_TOK_CLOSE_ARRAY:\n\t\t\t\t\t\tin_text_array = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\t\tpdf_array_push_real(ctx, csi->obj, buf->f);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\t\tpdf_array_push_int(ctx, csi->obj, buf->i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\t\tpdf_array_push_string(ctx, csi->obj, buf->scratch, buf->len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\t\tif (buf->scratch[0] == 'T' && (buf->scratch[1] == 'w' || buf->scratch[1] == 'c') && buf->scratch[2] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint n = pdf_array_len(ctx, csi->obj);\n\t\t\t\t\t\t\tif (n > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpdf_obj *o = pdf_array_get(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\tif (pdf_is_number(ctx, o))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcsi->stack[0] = pdf_to_real(ctx, o);\n\t\t\t\t\t\t\t\t\tpdf_array_delete(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Deliberate Fallthrough! */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in array\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse switch (tok)\n\t\t\t\t{\n\t\t\t\tcase PDF_TOK_ENDSTREAM:\n\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_ARRAY:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (csi->in_text)\n\t\t\t\t\t{\n\t\t\t\t\t\tin_text_array = 1;\n\t\t\t\t\t\tcsi->obj = pdf_new_array(ctx, doc, 4);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcsi->obj = pdf_parse_array(ctx, doc, stm, buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_DICT:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tcsi->obj = pdf_parse_dict(ctx, doc, stm, buf);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_NAME:\n\t\t\t\t\tif (csi->name[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\tcsi->obj = pdf_new_name(ctx, buf->scratch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_strlcpy(csi->name, buf->scratch, sizeof(csi->name));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->i;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->f;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\tif (buf->len <= sizeof(csi->string))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(csi->string, buf->scratch, buf->len);\n\t\t\t\t\t\tcsi->string_len = buf->len;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsi->obj = pdf_new_string(ctx, buf->scratch, buf->len);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\tpdf_clear_stack(ctx, csi);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in content stream\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (tok != PDF_TOK_EOF);\n\t\t}\n\t\tfz_always(ctx)\n\t\t{\n\t\t\tpdf_clear_stack(ctx, csi);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tint caught = fz_caught(ctx);\n\t\t\tif (cookie)\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t{\n\t\t\t\t\tcookie->incomplete++;\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t\t/* ignore minor errors */ ;\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* If we do catch an error, then reset ourselves to a base lexing state */\n\t\t\tin_text_array = 0;\n\t\t}\n\t}\n\twhile (tok != PDF_TOK_EOF);\n}\n\nvoid\npdf_process_contents(fz_context *ctx, pdf_processor *proc, pdf_document *doc, pdf_obj *rdb, pdf_obj *stmobj, fz_cookie *cookie)\n{\n\tpdf_csi csi;\n\tpdf_lexbuf buf;\n\tfz_stream *stm = NULL;\n\n\tif (!stmobj)\n\t\treturn;\n\n\tfz_var(stm);\n\n\tpdf_lexbuf_init(ctx, &buf, PDF_LEXBUF_SMALL);\n\tpdf_init_csi(ctx, &csi, doc, rdb, &buf, cookie);\n\n\tfz_try(ctx)\n\t{\n\t\tfz_defer_reap_start(ctx);\n\t\tstm = pdf_open_contents_stream(ctx, doc, stmobj);\n\t\tpdf_process_stream(ctx, proc, &csi, stm);\n\t\tpdf_process_end(ctx, proc, &csi);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_defer_reap_end(ctx);\n\t\tfz_drop_stream(ctx, stm);\n\t\tpdf_clear_stack(ctx, &csi);\n\t\tpdf_lexbuf_fin(ctx, &buf);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tproc->close_processor = NULL; /* aborted run, don't warn about unclosed processor */\n\t\tfz_rethrow(ctx);\n\t}\n}\n\nstatic void\npdf_run_xobject(fz_context *ctx, pdf_run_processor *proc, pdf_obj *xobj, pdf_obj *page_resources, fz_matrix transform, int is_smask)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = NULL;\n\tint oldtop = 0;\n\tint oldbot = -1;\n\tsoftmask_save softmask = { NULL };\n\tint gparent_save;\n\tfz_matrix gparent_save_ctm;\n\tpdf_obj *resources;\n\tfz_rect xobj_bbox;\n\tfz_matrix xobj_matrix;\n\tint transparency = 0;\n\tpdf_document *doc;\n\tfz_colorspace *cs = NULL;\n\tfz_default_colorspaces *save_default_cs = NULL;\n\tfz_default_colorspaces *xobj_default_cs = NULL;\n\n\t/* Avoid infinite recursion */\n\tif (xobj == NULL || pdf_mark_obj(ctx, xobj))\n\t\treturn;\n\n\tfz_var(cs);\n\tfz_var(xobj_default_cs);\n\n\tgparent_save = pr->gparent;\n\tpr->gparent = pr->gtop;\n\toldtop = pr->gtop;\n\n\tsave_default_cs = pr->default_cs;\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_gsave(ctx, pr);\n\n\t\tgstate = pr->gstate + pr->gtop;\n\n\t\txobj_bbox = pdf_xobject_bbox(ctx, xobj);\n\t\txobj_matrix = pdf_xobject_matrix(ctx, xobj);\n\t\ttransparency = pdf_xobject_transparency(ctx, xobj);\n\n\t\t/* apply xobject's transform matrix */\n\t\ttransform = fz_concat(xobj_matrix, transform);\n\t\tgstate->ctm = fz_concat(transform, gstate->ctm);\n\n\t\t/* The gparent is updated with the modified ctm */\n\t\tgparent_save_ctm = pr->gstate[pr->gparent].ctm;\n\t\tpr->gstate[pr->gparent].ctm = gstate->ctm;\n\n\t\t/* apply soft mask, create transparency group and reset state */\n\t\tif (transparency)\n\t\t{\n\t\t\tint isolated = pdf_xobject_isolated(ctx, xobj);\n\n\t\t\tfz_rect bbox = fz_transform_rect(xobj_bbox, gstate->ctm);\n\n\t\t\tgstate = begin_softmask(ctx, pr, &softmask);\n\n\t\t\tif (isolated)\n\t\t\t\tcs = pdf_xobject_colorspace(ctx, xobj);\n\t\t\tfz_begin_group(ctx, pr->dev, bbox,\n\t\t\t\t\tcs,\n\t\t\t\t\t(is_smask ? 1 : isolated),\n\t\t\t\t\tpdf_xobject_knockout(ctx, xobj),\n\t\t\t\t\tgstate->blendmode, gstate->fill.alpha);\n\n\t\t\tgstate->blendmode = 0;\n\t\t\tgstate->stroke.alpha = 1;\n\t\t\tgstate->fill.alpha = 1;\n\t\t}\n\n\t\tpdf_gsave(ctx, pr); /* Save here so the clippath doesn't persist */\n\n\t\t/* clip to the bounds */\n\t\tfz_moveto(ctx, pr->path, xobj_bbox.x0, xobj_bbox.y0);\n\t\tfz_lineto(ctx, pr->path, xobj_bbox.x1, xobj_bbox.y0);\n\t\tfz_lineto(ctx, pr->path, xobj_bbox.x1, xobj_bbox.y1);\n\t\tfz_lineto(ctx, pr->path, xobj_bbox.x0, xobj_bbox.y1);\n\t\tfz_closepath(ctx, pr->path);\n\t\tpr->clip = 1;\n\t\tpdf_show_path(ctx, pr, 0, 0, 0, 0);\n\n\t\t/* run contents */\n\n\t\tresources = pdf_xobject_resources(ctx, xobj);\n\t\tif (!resources)\n\t\t\tresources = page_resources;\n\n\t\tfz_try(ctx)\n\t\t\txobj_default_cs = pdf_update_default_colorspaces(ctx, pr->default_cs, resources);\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tif (fz_caught(ctx) != FZ_ERROR_TRYLATER)\n\t\t\t\tfz_rethrow(ctx);\n\t\t\tif (pr->cookie)\n\t\t\t\tpr->cookie->incomplete = 1;\n\t\t}\n\t\tif (xobj_default_cs != save_default_cs)\n\t\t{\n\t\t\tfz_set_default_colorspaces(ctx, pr->dev, xobj_default_cs);\n\t\t\tpr->default_cs = xobj_default_cs;\n\t\t}\n\n\t\tdoc = pdf_get_bound_document(ctx, xobj);\n\n\t\toldbot = pr->gbot;\n\t\tpr->gbot = pr->gtop;\n\n\t\tpdf_process_contents(ctx, (pdf_processor*)pr, doc, resources, xobj, pr->cookie);\n\n\t\t/* Undo any gstate mismatches due to the pdf_process_contents call */\n\t\tif (oldbot != -1)\n\t\t{\n\t\t\twhile (pr->gtop > pr->gbot)\n\t\t\t{\n\t\t\t\tpdf_grestore(ctx, pr);\n\t\t\t}\n\t\t\tpr->gbot = oldbot;\n\t\t}\n\n\t\tpdf_grestore(ctx, pr); /* Remove the state we pushed for the clippath */\n\n\t\t/* wrap up transparency stacks */\n\t\tif (transparency)\n\t\t{\n\t\t\tfz_end_group(ctx, pr->dev);\n\t\t\tend_softmask(ctx, pr, &softmask);\n\t\t}\n\n\t\tpr->gstate[pr->gparent].ctm = gparent_save_ctm;\n\t\tpr->gparent = gparent_save;\n\n\t\twhile (oldtop < pr->gtop)\n\t\t\tpdf_grestore(ctx, pr);\n\n\t\tif (xobj_default_cs != save_default_cs)\n\t\t{\n\t\t\tfz_set_default_colorspaces(ctx, pr->dev, save_default_cs);\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tpr->default_cs = save_default_cs;\n\t\tfz_drop_default_colorspaces(ctx, xobj_default_cs);\n\t\tfz_drop_colorspace(ctx, cs);\n\t\tpdf_unmark_obj(ctx, xobj);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, softmask.softmask);\n\t\tpdf_drop_obj(ctx, softmask.page_resources);\n\t\t/* Note: Any SYNTAX errors should have been swallowed\n\t\t * by pdf_process_contents, but in case any escape from other\n\t\t * functions, recast the error type here to be safe. */\n\t\tif (fz_caught(ctx) == FZ_ERROR_SYNTAX)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"syntax error in xobject\");\n\t\tfz_rethrow(ctx);\n\t}\n}\n\nstatic void pdf_run_Do_form(fz_context *ctx, pdf_processor *proc, const char *name, pdf_obj *xobj, pdf_obj *page_resources)\n{\n\tpdf_run_xobject(ctx, (pdf_run_processor*)proc, xobj, page_resources, fz_identity, 0);\n}\n\nstatic void\npdf_process_Do(fz_context *ctx, pdf_processor *proc, pdf_csi *csi)\n{\n\tpdf_obj *xres, *xobj, *subtype;\n\n\txres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(XObject));\n\txobj = pdf_dict_gets(ctx, xres, csi->name);\n\tif (!xobj)\n\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find XObject resource '%s'\", csi->name);\n\tsubtype = pdf_dict_get(ctx, xobj, PDF_NAME(Subtype));\n\tif (pdf_name_eq(ctx, subtype, PDF_NAME(Form)))\n\t{\n\t\tpdf_obj *st = pdf_dict_get(ctx, xobj, PDF_NAME(Subtype2));\n\t\tif (st)\n\t\t\tsubtype = st;\n\t}\n\tif (!pdf_is_name(ctx, subtype))\n\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"no XObject subtype specified\");\n\n\tif (pdf_is_ocg_hidden(ctx, csi->doc, csi->rdb, proc->usage, pdf_dict_get(ctx, xobj, PDF_NAME(OC))))\n\t\treturn;\n\n\tif (pdf_name_eq(ctx, subtype, PDF_NAME(Form)))\n\t{\n\t\tif (proc->op_Do_form)\n\t\t\tproc->op_Do_form(ctx, proc, csi->name, xobj, csi->rdb);\n\t}\n\n\telse if (pdf_name_eq(ctx, subtype, PDF_NAME(Image)))\n\t{\n\t\tif (proc->op_Do_image)\n\t\t{\n\t\t\tfz_image *image = pdf_load_image(ctx, csi->doc, xobj);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_Do_image(ctx, proc, csi->name, image);\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_image(ctx, image);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n\n\telse if (!strcmp(pdf_to_name(ctx, subtype), \"PS\"))\n\t\tfz_warn(ctx, \"ignoring XObject with subtype PS\");\n\telse\n\t\tfz_warn(ctx, \"ignoring XObject with unknown subtype: '%s'\", pdf_to_name(ctx, subtype));\n}\n\nstatic void\npdf_process_keyword(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm, char *word)\n{\n\tfloat *s = csi->stack;\n\tchar csname[40];\n\tint key;\n\n\tkey = word[0];\n\tif (word[1])\n\t{\n\t\tkey |= word[1] << 8;\n\t\tif (word[2])\n\t\t{\n\t\t\tkey |= word[2] << 16;\n\t\t\tif (word[3])\n\t\t\t\tkey = 0;\n\t\t}\n\t}\n\n\tswitch (key)\n\t{\n\tdefault:\n\t\tif (!csi->xbalance)\n\t\t{\n\t\t\tif (is_known_bad_word(word))\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"unknown keyword: '%s'\", word);\n\t\t\telse\n\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"unknown keyword: '%s'\", word);\n\t\t}\n\t\tbreak;\n\n\t/* general graphics state */\n\tcase A('w'): if (proc->op_w) proc->op_w(ctx, proc, s[0]); break;\n\tcase A('j'): if (proc->op_j) proc->op_j(ctx, proc, fz_clampi(s[0], 0, 2)); break;\n\tcase A('J'): if (proc->op_J) proc->op_J(ctx, proc, fz_clampi(s[0], 0, 2)); break;\n\tcase A('M'): if (proc->op_M) proc->op_M(ctx, proc, s[0]); break;\n\tcase A('d'): if (proc->op_d) proc->op_d(ctx, proc, csi->obj, s[0]); break;\n\tcase B('r','i'): if (proc->op_ri) proc->op_ri(ctx, proc, csi->name); break;\n\tcase A('i'): if (proc->op_i) proc->op_i(ctx, proc, s[0]); break;\n\n\tcase B('g','s'):\n\t\t{\n\t\t\tpdf_obj *gsres, *gsobj;\n\t\t\tgsres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(ExtGState));\n\t\t\tgsobj = pdf_dict_gets(ctx, gsres, csi->name);\n\t\t\tif (!gsobj)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find ExtGState resource '%s'\", csi->name);\n\t\t\tif (proc->op_gs_begin)\n\t\t\t\tproc->op_gs_begin(ctx, proc, csi->name, gsobj);\n\t\t\tpdf_process_extgstate(ctx, proc, csi, gsobj);\n\t\t\tif (proc->op_gs_end)\n\t\t\t\tproc->op_gs_end(ctx, proc);\n\t\t}\n\t\tbreak;\n\n\t/* special graphics state */\n\tcase A('q'): pdf_process_gsave(ctx, proc, csi); break;\n\tcase A('Q'): pdf_process_grestore(ctx, proc, csi); break;\n\tcase B('c','m'): if (proc->op_cm) proc->op_cm(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\n\t/* path construction */\n\tcase A('m'): if (proc->op_m) proc->op_m(ctx, proc, s[0], s[1]); break;\n\tcase A('l'): if (proc->op_l) proc->op_l(ctx, proc, s[0], s[1]); break;\n\tcase A('c'): if (proc->op_c) proc->op_c(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\tcase A('v'): if (proc->op_v) proc->op_v(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('y'): if (proc->op_y) proc->op_y(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('h'): if (proc->op_h) proc->op_h(ctx, proc); break;\n\tcase B('r','e'): if (proc->op_re) proc->op_re(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\n\t/* path painting */\n\tcase A('S'): if (proc->op_S) proc->op_S(ctx, proc); break;\n\tcase A('s'): if (proc->op_s) proc->op_s(ctx, proc); break;\n\tcase A('F'): if (proc->op_F) proc->op_F(ctx, proc); break;\n\tcase A('f'): if (proc->op_f) proc->op_f(ctx, proc); break;\n\tcase B('f','*'): if (proc->op_fstar) proc->op_fstar(ctx, proc); break;\n\tcase A('B'): if (proc->op_B) proc->op_B(ctx, proc); break;\n\tcase B('B','*'): if (proc->op_Bstar) proc->op_Bstar(ctx, proc); break;\n\tcase A('b'): if (proc->op_b) proc->op_b(ctx, proc); break;\n\tcase B('b','*'): if (proc->op_bstar) proc->op_bstar(ctx, proc); break;\n\tcase A('n'): if (proc->op_n) proc->op_n(ctx, proc); break;\n\n\t/* path clipping */\n\tcase A('W'): if (proc->op_W) proc->op_W(ctx, proc); break;\n\tcase B('W','*'): if (proc->op_Wstar) proc->op_Wstar(ctx, proc); break;\n\n\t/* text objects */\n\tcase B('B','T'): csi->in_text = 1; if (proc->op_BT) proc->op_BT(ctx, proc); break;\n\tcase B('E','T'): csi->in_text = 0; if (proc->op_ET) proc->op_ET(ctx, proc); break;\n\n\t/* text state */\n\tcase B('T','c'): if (proc->op_Tc) proc->op_Tc(ctx, proc, s[0]); break;\n\tcase B('T','w'): if (proc->op_Tw) proc->op_Tw(ctx, proc, s[0]); break;\n\tcase B('T','z'): if (proc->op_Tz) proc->op_Tz(ctx, proc, s[0]); break;\n\tcase B('T','L'): if (proc->op_TL) proc->op_TL(ctx, proc, s[0]); break;\n\tcase B('T','r'): if (proc->op_Tr) proc->op_Tr(ctx, proc, s[0]); break;\n\tcase B('T','s'): if (proc->op_Ts) proc->op_Ts(ctx, proc, s[0]); break;\n\n\tcase B('T','f'):\n\t\tif (proc->op_Tf)\n\t\t{\n\t\t\tpdf_obj *fontres, *fontobj;\n\t\t\tpdf_font_desc *font;\n\t\t\tfontres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(Font));\n\t\t\tfontobj = pdf_dict_gets(ctx, fontres, csi->name);\n\t\t\tif (pdf_is_dict(ctx, fontobj))\n\t\t\t\tfont = pdf_try_load_font(ctx, csi->doc, csi->rdb, fontobj, csi->cookie);\n\t\t\telse\n\t\t\t\tfont = pdf_load_hail_mary_font(ctx, csi->doc);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_Tf(ctx, proc, csi->name, font, s[0]);\n\t\t\tfz_always(ctx)\n\t\t\t\tpdf_drop_font(ctx, font);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\t/* text positioning */\n\tcase B('T','d'): if (proc->op_Td) proc->op_Td(ctx, proc, s[0], s[1]); break;\n\tcase B('T','D'): if (proc->op_TD) proc->op_TD(ctx, proc, s[0], s[1]); break;\n\tcase B('T','m'): if (proc->op_Tm) proc->op_Tm(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\tcase B('T','*'): if (proc->op_Tstar) proc->op_Tstar(ctx, proc); break;\n\n\t/* text showing */\n\tcase B('T','J'): if (proc->op_TJ) proc->op_TJ(ctx, proc, csi->obj); break;\n\tcase B('T','j'):\n\t\tif (proc->op_Tj)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_Tj(ctx, proc, csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_Tj(ctx, proc, pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\tcase A('\\''):\n\t\tif (proc->op_squote)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_squote(ctx, proc, csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_squote(ctx, proc, pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\tcase A('\"'):\n\t\tif (proc->op_dquote)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_dquote(ctx, proc, s[0], s[1], csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_dquote(ctx, proc, s[0], s[1], pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\n\t/* type 3 fonts */\n\tcase B('d','0'): if (proc->op_d0) proc->op_d0(ctx, proc, s[0], s[1]); break;\n\tcase B('d','1'): if (proc->op_d1) proc->op_d1(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\n\t/* color */\n\tcase B('C','S'): pdf_process_CS(ctx, proc, csi, 1); break;\n\tcase B('c','s'): pdf_process_CS(ctx, proc, csi, 0); break;\n\tcase B('S','C'): pdf_process_SC(ctx, proc, csi, 1); break;\n\tcase B('s','c'): pdf_process_SC(ctx, proc, csi, 0); break;\n\tcase C('S','C','N'): pdf_process_SC(ctx, proc, csi, 1); break;\n\tcase C('s','c','n'): pdf_process_SC(ctx, proc, csi, 0); break;\n\n\tcase A('G'): if (proc->op_G) proc->op_G(ctx, proc, s[0]); break;\n\tcase A('g'): if (proc->op_g) proc->op_g(ctx, proc, s[0]); break;\n\tcase B('R','G'): if (proc->op_RG) proc->op_RG(ctx, proc, s[0], s[1], s[2]); break;\n\tcase B('r','g'): if (proc->op_rg) proc->op_rg(ctx, proc, s[0], s[1], s[2]); break;\n\tcase A('K'): if (proc->op_K) proc->op_K(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('k'): if (proc->op_k) proc->op_k(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\n\t/* shadings, images, xobjects */\n\tcase B('B','I'):\n\t\t{\n\t\t\tfz_image *img = parse_inline_image(ctx, csi, stm, csname, sizeof csname);\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tif (proc->op_BI)\n\t\t\t\t\tproc->op_BI(ctx, proc, img, csname[0] ? csname : NULL);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_image(ctx, img);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\tcase B('s','h'):\n\t\tif (proc->op_sh)\n\t\t{\n\t\t\tpdf_obj *shaderes, *shadeobj;\n\t\t\tfz_shade *shade;\n\t\t\tshaderes = pdf_dict_get(ctx, csi->rdb, PDF_NAME(Shading));\n\t\t\tshadeobj = pdf_dict_gets(ctx, shaderes, csi->name);\n\t\t\tif (!shadeobj)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find Shading resource '%s'\", csi->name);\n\t\t\tshade = pdf_load_shading(ctx, csi->doc, shadeobj);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_sh(ctx, proc, csi->name, shade);\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_shade(ctx, shade);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\tcase B('D','o'): pdf_process_Do(ctx, proc, csi); break;\n\n\t/* marked content */\n\tcase B('M','P'): if (proc->op_MP) proc->op_MP(ctx, proc, csi->name); break;\n\tcase B('D','P'): if (proc->op_DP) proc->op_DP(ctx, proc, csi->name, csi->obj, resolve_properties(ctx, csi, csi->obj)); break;\n\tcase C('B','M','C'): pdf_process_BMC(ctx, proc, csi, csi->name); break;\n\tcase C('B','D','C'): pdf_process_BDC(ctx, proc, csi); break;\n\tcase C('E','M','C'): pdf_process_EMC(ctx, proc, csi); break;\n\n\t/* compatibility */\n\tcase B('B','X'): ++csi->xbalance; if (proc->op_BX) proc->op_BX(ctx, proc); break;\n\tcase B('E','X'): --csi->xbalance; if (proc->op_EX) proc->op_EX(ctx, proc); break;\n\t}\n}\n\nstatic void\npdf_process_stream(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm)\n{\n\tpdf_document *doc = csi->doc;\n\tpdf_lexbuf *buf = csi->buf;\n\tfz_cookie *cookie = csi->cookie;\n\n\tpdf_token tok = PDF_TOK_ERROR;\n\tint in_text_array = 0;\n\tint syntax_errors = 0;\n\n\t/* make sure we have a clean slate if we come here from flush_text */\n\tpdf_clear_stack(ctx, csi);\n\n\tfz_var(in_text_array);\n\tfz_var(tok);\n\n\tif (cookie)\n\t{\n\t\tcookie->progress_max = -1;\n\t\tcookie->progress = 0;\n\t}\n\n\tdo\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\t/* Check the cookie */\n\t\t\t\tif (cookie)\n\t\t\t\t{\n\t\t\t\t\tif (cookie->abort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcookie->progress++;\n\t\t\t\t}\n\n\t\t\t\ttok = pdf_lex(ctx, stm, buf);\n\n\t\t\t\tif (in_text_array)\n\t\t\t\t{\n\t\t\t\t\tswitch(tok)\n\t\t\t\t\t{\n\t\t\t\t\tcase PDF_TOK_CLOSE_ARRAY:\n\t\t\t\t\t\tin_text_array = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\t\tpdf_array_push_real(ctx, csi->obj, buf->f);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\t\tpdf_array_push_int(ctx, csi->obj, buf->i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\t\tpdf_array_push_string(ctx, csi->obj, buf->scratch, buf->len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\t\tif (buf->scratch[0] == 'T' && (buf->scratch[1] == 'w' || buf->scratch[1] == 'c') && buf->scratch[2] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint n = pdf_array_len(ctx, csi->obj);\n\t\t\t\t\t\t\tif (n > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpdf_obj *o = pdf_array_get(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\tif (pdf_is_number(ctx, o))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcsi->stack[0] = pdf_to_real(ctx, o);\n\t\t\t\t\t\t\t\t\tpdf_array_delete(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Deliberate Fallthrough! */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in array\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse switch (tok)\n\t\t\t\t{\n\t\t\t\tcase PDF_TOK_ENDSTREAM:\n\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_ARRAY:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (csi->in_text)\n\t\t\t\t\t{\n\t\t\t\t\t\tin_text_array = 1;\n\t\t\t\t\t\tcsi->obj = pdf_new_array(ctx, doc, 4);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcsi->obj = pdf_parse_array(ctx, doc, stm, buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_DICT:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tcsi->obj = pdf_parse_dict(ctx, doc, stm, buf);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_NAME:\n\t\t\t\t\tif (csi->name[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\tcsi->obj = pdf_new_name(ctx, buf->scratch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_strlcpy(csi->name, buf->scratch, sizeof(csi->name));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->i;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->f;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\tif (buf->len <= sizeof(csi->string))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(csi->string, buf->scratch, buf->len);\n\t\t\t\t\t\tcsi->string_len = buf->len;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsi->obj = pdf_new_string(ctx, buf->scratch, buf->len);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\tpdf_clear_stack(ctx, csi);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in content stream\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (tok != PDF_TOK_EOF);\n\t\t}\n\t\tfz_always(ctx)\n\t\t{\n\t\t\tpdf_clear_stack(ctx, csi);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tint caught = fz_caught(ctx);\n\t\t\tif (cookie)\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t{\n\t\t\t\t\tcookie->incomplete++;\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t\t/* ignore minor errors */ ;\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* If we do catch an error, then reset ourselves to a base lexing state */\n\t\t\tin_text_array = 0;\n\t\t}\n\t}\n\twhile (tok != PDF_TOK_EOF);\n}\n\nvoid\npdf_process_contents(fz_context *ctx, pdf_processor *proc, pdf_document *doc, pdf_obj *rdb, pdf_obj *stmobj, fz_cookie *cookie)\n{\n\tpdf_csi csi;\n\tpdf_lexbuf buf;\n\tfz_stream *stm = NULL;\n\n\tif (!stmobj)\n\t\treturn;\n\n\tfz_var(stm);\n\n\tpdf_lexbuf_init(ctx, &buf, PDF_LEXBUF_SMALL);\n\tpdf_init_csi(ctx, &csi, doc, rdb, &buf, cookie);\n\n\tfz_try(ctx)\n\t{\n\t\tfz_defer_reap_start(ctx);\n\t\tstm = pdf_open_contents_stream(ctx, doc, stmobj);\n\t\tpdf_process_stream(ctx, proc, &csi, stm);\n\t\tpdf_process_end(ctx, proc, &csi);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_defer_reap_end(ctx);\n\t\tfz_drop_stream(ctx, stm);\n\t\tpdf_clear_stack(ctx, &csi);\n\t\tpdf_lexbuf_fin(ctx, &buf);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tproc->close_processor = NULL; /* aborted run, don't warn about unclosed processor */\n\t\tfz_rethrow(ctx);\n\t}\n}\n\nstatic void\npdf_run_page_contents_with_usage_imp(fz_context *ctx, pdf_document *doc, pdf_page *page, fz_device *dev, fz_matrix ctm, const char *usage, fz_cookie *cookie)\n{\n\tfz_matrix page_ctm;\n\tpdf_obj *resources;\n\tpdf_obj *contents;\n\tfz_rect mediabox;\n\tpdf_processor *proc = NULL;\n\tfz_default_colorspaces *default_cs = NULL;\n\tfz_colorspace *colorspace = NULL;\n\n\tfz_var(proc);\n\tfz_var(colorspace);\n\tfz_var(default_cs);\n\n\tif (cookie && page->super.incomplete)\n\t\tcookie->incomplete = 1;\n\n\tfz_try(ctx)\n\t{\n\t\tdefault_cs = pdf_load_default_colorspaces(ctx, doc, page);\n\t\tif (default_cs)\n\t\t\tfz_set_default_colorspaces(ctx, dev, default_cs);\n\n\t\tpdf_page_transform(ctx, page, &mediabox, &page_ctm);\n\t\tctm = fz_concat(page_ctm, ctm);\n\t\tmediabox = fz_transform_rect(mediabox, ctm);\n\n\t\tresources = pdf_page_resources(ctx, page);\n\t\tcontents = pdf_page_contents(ctx, page);\n\n\t\tif (page->transparency)\n\t\t{\n\t\t\tpdf_obj *group = pdf_page_group(ctx, page);\n\n\t\t\tif (group)\n\t\t\t{\n\t\t\t\tpdf_obj *cs = pdf_dict_get(ctx, group, PDF_NAME(CS));\n\t\t\t\tif (cs)\n\t\t\t\t{\n\t\t\t\t\tfz_try(ctx)\n\t\t\t\t\t\tcolorspace = pdf_load_colorspace(ctx, cs);\n\t\t\t\t\tfz_catch(ctx)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t\t\t\t\tfz_warn(ctx, \"Ignoring Page blending colorspace.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fz_is_valid_blend_colorspace(ctx, colorspace))\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"Ignoring invalid Page blending colorspace: %s.\", colorspace->name);\n\t\t\t\t\t\tfz_drop_colorspace(ctx, colorspace);\n\t\t\t\t\t\tcolorspace = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_default_output_intent(ctx, default_cs));\n\n\t\t\tfz_begin_group(ctx, dev, mediabox, colorspace, 1, 0, 0, 1);\n\t\t}\n\n\t\tproc = pdf_new_run_processor(ctx, dev, ctm, usage, NULL, default_cs, cookie);\n\t\tpdf_process_contents(ctx, proc, doc, resources, contents, cookie);\n\t\tpdf_close_processor(ctx, proc);\n\n\t\tif (page->transparency)\n\t\t{\n\t\t\tfz_end_group(ctx, dev);\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tpdf_drop_processor(ctx, proc);\n\t\tfz_drop_colorspace(ctx, colorspace);\n\t\tfz_drop_default_colorspaces(ctx, default_cs);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}\n\nvoid pdf_run_page_contents_with_usage(fz_context *ctx, pdf_page *page, fz_device *dev, fz_matrix ctm, const char *usage, fz_cookie *cookie)\n{\n\tpdf_document *doc = page->doc;\n\tint nocache;\n\n\tnocache = !!(dev->hints & FZ_NO_CACHE);\n\tif (nocache)\n\t\tpdf_mark_xref(ctx, doc);\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_run_page_contents_with_usage_imp(ctx, doc, page, dev, ctm, usage, cookie);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tif (nocache)\n\t\t\tpdf_clear_xref_to_mark(ctx, doc);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}\n\nvoid pdf_run_page_contents(fz_context *ctx, pdf_page *page, fz_device *dev, fz_matrix ctm, fz_cookie *cookie)\n{\n\tpdf_run_page_contents_with_usage(ctx, page, dev, ctm, \"View\", cookie);\n}\n\nvoid\nfz_run_page_contents(fz_context *ctx, fz_page *page, fz_device *dev, fz_matrix transform, fz_cookie *cookie)\n{\n\tif (page && page->run_page_contents)\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tpage->run_page_contents(ctx, page, dev, transform, cookie);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tdev->close_device = NULL; /* aborted run, don't warn about unclosed device */\n\t\t\tif (fz_caught(ctx) != FZ_ERROR_ABORT)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}\n\nvoid\nfz_run_page(fz_context *ctx, fz_page *page, fz_device *dev, fz_matrix transform, fz_cookie *cookie)\n{\n\tfz_run_page_contents(ctx, page, dev, transform, cookie);\n\tfz_run_page_annots(ctx, page, dev, transform, cookie);\n\tfz_run_page_widgets(ctx, page, dev, transform, cookie);\n}\n\n\n\n\n\n\n\n\n// target function\nstatic void\nfz_draw_clip_image_mask(fz_context *ctx, fz_device *devp, fz_image *image, fz_matrix in_ctm, fz_rect scissor)\n{\n\tfz_draw_device *dev = (fz_draw_device*)devp;\n\tfz_matrix local_ctm = fz_concat(in_ctm, dev->transform);\n\tfz_irect bbox;\n\tfz_pixmap *scaled = NULL;\n\tfz_pixmap *pixmap = NULL;\n\tint dx, dy;\n\tfz_draw_state *state = push_stack(ctx, dev, \"clip image mask\");\n\tfz_colorspace *model = state->dest->colorspace;\n\tfz_irect clip;\n\tfz_irect src_area;\n\n\tfz_var(pixmap);\n\n\tif (dev->top == 0 && dev->resolve_spots)\n\t\tstate = push_group_for_separations(ctx, dev, fz_default_color_params /* FIXME */, dev->default_cs);\n\n\tclip = fz_pixmap_bbox(ctx, state->dest);\n\tclip = fz_intersect_irect(clip, state->scissor);\n\n\tif (image->w == 0 || image->h == 0)\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (empty) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n\tlocal_ctm = fz_gridfit_matrix(devp->flags & FZ_DEVFLAG_GRIDFIT_AS_TILED, local_ctm);\n\n\tsrc_area = find_src_area_required(local_ctm, image, clip);\n\tif (fz_is_empty_irect(src_area))\n\t\treturn;\n\n\tbbox = fz_irect_from_rect(fz_transform_rect(fz_unit_rect, local_ctm));\n\tbbox = fz_intersect_irect(bbox, state->scissor);\n\tif (!fz_is_infinite_rect(scissor))\n\t{\n\t\tfz_rect tscissor = fz_transform_rect(scissor, dev->transform);\n\t\tbbox = fz_intersect_irect(bbox, fz_irect_from_rect(tscissor));\n\t}\n\tif (!fz_is_valid_irect(bbox))\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (invalid) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\tdump_spaces(dev->top-1, \"Clip (image mask) begin\\n\");\n#endif\n\n\tfz_try(ctx)\n\t{\n\t\tpixmap = fz_get_pixmap_from_image(ctx, image, &src_area, &local_ctm, &dx, &dy);\n\n\t\tstate[1].mask = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\tfz_clear_pixmap(ctx, state[1].mask);\n\n\t\tstate[1].dest = fz_new_pixmap_with_bbox(ctx, model, bbox, state[0].dest->seps, state[0].dest->alpha);\n\t\tfz_copy_pixmap_rect(ctx, state[1].dest, state[0].dest, bbox, dev->default_cs);\n\t\tif (state[0].shape)\n\t\t{\n\t\t\tstate[1].shape = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].shape);\n\t\t}\n\t\tif (state[0].group_alpha)\n\t\t{\n\t\t\tstate[1].group_alpha = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].group_alpha);\n\t\t}\n\n\t\tstate[1].blendmode |= FZ_BLEND_ISOLATED;\n\t\tstate[1].scissor = bbox;\n\n\t\tif (!(devp->hints & FZ_DONT_INTERPOLATE_IMAGES) && ctx->tuning->image_scale(ctx->tuning->image_scale_arg, dx, dy, pixmap->w, pixmap->h))\n\t\t{\n\t\t\tint gridfit = !(dev->flags & FZ_DRAWDEV_FLAGS_TYPE3);\n\t\t\tscaled = fz_transform_pixmap(ctx, dev, pixmap, &local_ctm, state->dest->x, state->dest->y, dx, dy, gridfit, &clip);\n\t\t\tif (!scaled)\n\t\t\t{\n\t\t\t\tif (dx < 1)\n\t\t\t\t\tdx = 1;\n\t\t\t\tif (dy < 1)\n\t\t\t\t\tdy = 1;\n\t\t\t\tscaled = fz_scale_pixmap_cached(ctx, pixmap, pixmap->x, pixmap->y, dx, dy, NULL, dev->cache_x, dev->cache_y);\n\t\t\t}\n\t\t\tif (scaled)\n\t\t\t{\n\t\t\t\tfz_drop_pixmap(ctx, pixmap);\n\t\t\t\tpixmap = scaled;\n\t\t\t}\n\t\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top, \"\");\n\t\tfz_dump_blend(ctx, \"Creating imagemask: plotting \", pixmap);\n\t\tfz_dump_blend(ctx, \" onto \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n#endif\n\n\t\tfz_paint_image(ctx, state[1].mask, &bbox, state[1].shape, state[1].group_alpha, pixmap, local_ctm, 255, !(devp->hints & FZ_DONT_INTERPOLATE_IMAGES), 0);\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tfz_dump_blend(ctx, \" to get \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_pixmap(ctx, pixmap);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}\n",
    "target": 1,
    "idx": 1036463,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic zend_always_inline uint32_t zend_gc_delref(zend_refcounted_h *p) {\n\tZEND_ASSERT(p->refcount > 0);\n\tZEND_RC_MOD_CHECK(p);\n\treturn --(p->refcount);\n}\n\nstatic zend_always_inline uint32_t zval_delref_p(zval* pz) {\n\tZEND_ASSERT(Z_REFCOUNTED_P(pz));\n\treturn GC_DELREF(Z_COUNTED_P(pz));\n}\n\nstatic zend_always_inline void zval_ptr_dtor_nogc(zval *zval_ptr)\n{\n\tif (Z_REFCOUNTED_P(zval_ptr) && !Z_DELREF_P(zval_ptr)) {\n\t\trc_dtor_func(Z_COUNTED_P(zval_ptr));\n\t}\n}\n\nZEND_API void destroy_op_array(zend_op_array *op_array)\n{\n\tuint32_t i;\n\n\tif (op_array->static_variables) {\n\t\tHashTable *ht = ZEND_MAP_PTR_GET(op_array->static_variables_ptr);\n\t\tif (ht && !(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {\n\t\t\tif (GC_DELREF(ht) == 0) {\n\t\t\t\tzend_array_destroy(ht);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((op_array->fn_flags & ZEND_ACC_HEAP_RT_CACHE)\n\t && ZEND_MAP_PTR(op_array->run_time_cache)) {\n\t\tefree(ZEND_MAP_PTR(op_array->run_time_cache));\n\t}\n\n\tif (op_array->function_name) {\n\t\tzend_string_release_ex(op_array->function_name, 0);\n\t}\n\n\tif (!op_array->refcount || --(*op_array->refcount) > 0) {\n\t\treturn;\n\t}\n\n\tefree_size(op_array->refcount, sizeof(*(op_array->refcount)));\n\n\tif (op_array->vars) {\n\t\ti = op_array->last_var;\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tzend_string_release_ex(op_array->vars[i], 0);\n\t\t}\n\t\tefree(op_array->vars);\n\t}\n\n\tif (op_array->literals) {\n\t\tzval *literal = op_array->literals;\n\t\tzval *end = literal + op_array->last_literal;\n\t \twhile (literal < end) {\n\t\t\tzval_ptr_dtor_nogc(literal);\n\t\t\tliteral++;\n\t\t}\n\t\tif (ZEND_USE_ABS_CONST_ADDR\n\t\t || !(op_array->fn_flags & ZEND_ACC_DONE_PASS_TWO)) {\n\t\t\tefree(op_array->literals);\n\t\t}\n\t}\n\tefree(op_array->opcodes);\n\n\tif (op_array->doc_comment) {\n\t\tzend_string_release_ex(op_array->doc_comment, 0);\n\t}\n\tif (op_array->attributes) {\n\t\tzend_hash_release(op_array->attributes);\n\t}\n\tif (op_array->live_range) {\n\t\tefree(op_array->live_range);\n\t}\n\tif (op_array->try_catch_array) {\n\t\tefree(op_array->try_catch_array);\n\t}\n\tif (zend_extension_flags & ZEND_EXTENSIONS_HAVE_OP_ARRAY_DTOR) {\n\t\tif (op_array->fn_flags & ZEND_ACC_DONE_PASS_TWO) {\n\t\t\tzend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_op_array_dtor_handler, op_array);\n\t\t}\n\t}\n\tif (op_array->arg_info) {\n\t\tuint32_t num_args = op_array->num_args;\n\t\tzend_arg_info *arg_info = op_array->arg_info;\n\n\t\tif (op_array->fn_flags & ZEND_ACC_HAS_RETURN_TYPE) {\n\t\t\targ_info--;\n\t\t\tnum_args++;\n\t\t}\n\t\tif (op_array->fn_flags & ZEND_ACC_VARIADIC) {\n\t\t\tnum_args++;\n\t\t}\n\t\tfor (i = 0 ; i < num_args; i++) {\n\t\t\tif (arg_info[i].name) {\n\t\t\t\tzend_string_release_ex(arg_info[i].name, 0);\n\t\t\t}\n\t\t\tzend_type_release(arg_info[i].type, /* persistent */ 0);\n\t\t}\n\t\tefree(arg_info);\n\t}\n}\n\nint fuzzer_do_request(zend_file_handle *file_handle, char *filename)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\tSG(headers_sent) = 1;\n\tSG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_op_array *op_array = zend_compile_file(file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\t\t/*retval = php_execute_script(file_handle);*/\n\t} zend_end_try();\n\nint fuzzer_do_request_from_buffer(char *filename, char *data, size_t data_len)\n{\n\tzend_file_handle file_handle;\n\tfile_handle.filename = filename;\n\tfile_handle.free_filename = 0;\n\tfile_handle.opened_path = NULL;\n\tfile_handle.handle.stream.handle = NULL;\n\tfile_handle.handle.stream.reader = (zend_stream_reader_t)_php_stream_read;\n\tfile_handle.handle.stream.fsizer = NULL;\n\tfile_handle.handle.stream.isatty = 0;\n\tfile_handle.handle.stream.closer   = NULL;\n\tfile_handle.buf = data;\n\tfile_handle.len = data_len;\n\tfile_handle.type = ZEND_HANDLE_STREAM;\n\n\treturn fuzzer_do_request(&file_handle, filename);\n}\n\n\n// target function\nstatic void zend_emit_jmp_null(znode *obj_node)\n{\n\tuint32_t jmp_null_opnum = get_next_op_number();\n\tzend_emit_op(NULL, ZEND_JMP_NULL, obj_node, NULL);\n\tzend_stack_push(&CG(short_circuiting_opnums), &jmp_null_opnum);\n}\n",
    "target": 1,
    "idx": 1024436,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\nstatic void\ncompact_list (\n  FriBidiRun *list\n)\n{\n  fribidi_assert (list);\n\n  if (list->next)\n    for_run_list (list, list)\n      if (RL_TYPE (list->prev) == RL_TYPE (list)\n\t  && RL_LEVEL (list->prev) == RL_LEVEL (list)\n          && RL_ISOLATE_LEVEL (list->prev) == RL_ISOLATE_LEVEL (list)\n          && RL_BRACKET_TYPE(list) == FRIBIDI_NO_BRACKET /* Don't join brackets! */\n          && RL_BRACKET_TYPE(list->prev) == FRIBIDI_NO_BRACKET\n          )\n      list = merge_with_prev (list);\n}\n\nFRIBIDI_ENTRY FriBidiLevel\nfribidi_get_par_embedding_levels_ex (\n  /* input */\n  const FriBidiCharType *bidi_types,\n  const FriBidiBracketType *bracket_types,\n  const FriBidiStrIndex len,\n  /* input and output */\n  FriBidiParType *pbase_dir,\n  /* output */\n  FriBidiLevel *embedding_levels\n)\n{\n  FriBidiLevel base_level, max_level = 0;\n  FriBidiParType base_dir;\n  FriBidiRun *main_run_list = NULL, *explicits_list = NULL, *pp;\n  fribidi_boolean status = false;\n  int max_iso_level = 0;\n\n  if UNLIKELY\n    (!len)\n    {\n      status = true;\n      goto out;\n    }\n\n  DBG (\"in fribidi_get_par_embedding_levels\");\n\n  fribidi_assert (bidi_types);\n  fribidi_assert (pbase_dir);\n  fribidi_assert (embedding_levels);\n\n  /* Determinate character types */\n  {\n    /* Get run-length encoded character types */\n    main_run_list = run_list_encode_bidi_types (bidi_types, bracket_types, len);\n    if UNLIKELY\n      (!main_run_list) goto out;\n  }\n\n  /* Find base level */\n  /* If no strong base_dir was found, resort to the weak direction\n     that was passed on input. */\n  base_level = FRIBIDI_DIR_TO_LEVEL (*pbase_dir);\n  if (!FRIBIDI_IS_STRONG (*pbase_dir))\n    /* P2. P3. Search for first strong character and use its direction as\n       base direction */\n    {\n      int valid_isolate_count = 0;\n      for_run_list (pp, main_run_list)\n        {\n          if (RL_TYPE(pp) == FRIBIDI_TYPE_PDI)\n            {\n              /* Ignore if there is no matching isolate */\n              if (valid_isolate_count>0)\n                valid_isolate_count--;\n            }\n          else if (FRIBIDI_IS_ISOLATE(RL_TYPE(pp)))\n            valid_isolate_count++;\n          else if (valid_isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (pp)))\n            {\n              base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (pp));\n              *pbase_dir = FRIBIDI_LEVEL_TO_DIR (base_level);\n              break;\n            }\n        }\n    }\n  base_dir = FRIBIDI_LEVEL_TO_DIR (base_level);\n  DBG2 (\"  base level : %c\", fribidi_char_from_level (base_level));\n  DBG2 (\"  base dir   : %s\", fribidi_get_bidi_type_name (base_dir));\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* Explicit Levels and Directions */\n  DBG (\"explicit levels and directions\");\n  {\n    FriBidiLevel level, new_level = 0;\n    int isolate_level = 0;\n    FriBidiCharType override, new_override;\n    FriBidiStrIndex i;\n    int stack_size, over_pushed, first_interval;\n    int valid_isolate_count = 0;\n    int isolate_overflow = 0;\n    int isolate = 0; /* The isolate status flag */\n    struct\n    {\n      FriBidiCharType override;\t/* only LTR, RTL and ON are valid */\n      FriBidiLevel level;\n      int isolate;\n      int isolate_level;\n    } status_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n    FriBidiRun temp_link;\n    FriBidiRun *run_per_isolate_level[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n    int prev_isolate_level = 0; /* When running over the isolate levels, remember the previous level */\n\n    memset(run_per_isolate_level, 0, sizeof(run_per_isolate_level[0])\n           * FRIBIDI_BIDI_MAX_RESOLVED_LEVELS);\n\n/* explicits_list is a list like main_run_list, that holds the explicit\n   codes that are removed from main_run_list, to reinsert them later by\n   calling the shadow_run_list.\n*/\n    explicits_list = new_run_list ();\n    if UNLIKELY\n      (!explicits_list) goto out;\n\n    /* X1. Begin by setting the current embedding level to the paragraph\n       embedding level. Set the directional override status to neutral,\n       and directional isolate status to false.\n\n       Process each character iteratively, applying rules X2 through X8.\n       Only embedding levels from 0 to 123 are valid in this phase. */\n\n    level = base_level;\n    override = FRIBIDI_TYPE_ON;\n    /* stack */\n    stack_size = 0;\n    over_pushed = 0;\n    first_interval = 0;\n    valid_isolate_count = 0;\n    isolate_overflow = 0;\n\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType this_type = RL_TYPE (pp);\n      RL_ISOLATE_LEVEL (pp) = isolate_level;\n\n      if (FRIBIDI_IS_EXPLICIT_OR_BN (this_type))\n\t{\n\t  if (FRIBIDI_IS_STRONG (this_type))\n\t    {\t\t\t/* LRE, RLE, LRO, RLO */\n\t      /* 1. Explicit Embeddings */\n\t      /*   X2. With each RLE, compute the least greater odd\n\t         embedding level. */\n\t      /*   X3. With each LRE, compute the least greater even\n\t         embedding level. */\n\t      /* 2. Explicit Overrides */\n\t      /*   X4. With each RLO, compute the least greater odd\n\t         embedding level. */\n\t      /*   X5. With each LRO, compute the least greater even\n\t         embedding level. */\n\t      new_override = FRIBIDI_EXPLICIT_TO_OVERRIDE_DIR (this_type);\n\t      for (i = RL_LEN (pp); i; i--)\n\t\t{\n\t\t  new_level =\n\t\t    ((level + FRIBIDI_DIR_TO_LEVEL (this_type) + 2) & ~1) -\n\t\t    FRIBIDI_DIR_TO_LEVEL (this_type);\n                  isolate = 0;\n\t\t  PUSH_STATUS;\n\t\t}\n\t    }\n\t  else if (this_type == FRIBIDI_TYPE_PDF)\n\t    {\n\t      /* 3. Terminating Embeddings and overrides */\n\t      /*   X7. With each PDF, determine the matching embedding or\n\t         override code. */\n              for (i = RL_LEN (pp); i; i--)\n                {\n                  if (stack_size && status_stack[stack_size-1].isolate != 0)\n                    break;\n                  POP_STATUS;\n                }\n\t    }\n\n\t  /* X9. Remove all RLE, LRE, RLO, LRO, PDF, and BN codes. */\n\t  /* Remove element and add it to explicits_list */\n\t  RL_LEVEL (pp) = FRIBIDI_SENTINEL;\n\t  temp_link.next = pp->next;\n\t  move_node_before (pp, explicits_list);\n\t  pp = &temp_link;\n\t}\n      else if (this_type == FRIBIDI_TYPE_PDI)\n        /* X6a. pop the direction of the stack */\n        {\n          for (i = RL_LEN (pp); i; i--)\n            {\n              if (isolate_overflow > 0)\n                {\n                  isolate_overflow--;\n                  RL_LEVEL (pp) = level;\n                }\n\n              else if (valid_isolate_count > 0)\n                {\n                  /* Pop away all LRE,RLE,LRO, RLO levels\n                     from the stack, as these are implicitly\n                     terminated by the PDI */\n                  while (stack_size && !status_stack[stack_size-1].isolate)\n                    POP_STATUS;\n                  over_pushed = 0; /* The PDI resets the overpushed! */\n                  POP_STATUS;\n                  if (isolate_level>0)\n                    isolate_level--;\n                  valid_isolate_count--;\n                  RL_LEVEL (pp) = level;\n                  RL_ISOLATE_LEVEL (pp) = isolate_level;\n                }\n              else\n                {\n                  /* Ignore isolated PDI's by turning them into ON's */\n                  RL_TYPE (pp) = FRIBIDI_TYPE_ON;\n                  RL_LEVEL (pp) = level;\n                }\n            }\n        }\n      else if (FRIBIDI_IS_ISOLATE(this_type))\n        {\n          /* TBD support RL_LEN > 1 */\n          new_override = FRIBIDI_TYPE_ON;\n          isolate = 1;\n          if (this_type == FRIBIDI_TYPE_LRI)\n            new_level = level + 2 - (level%2);\n          else if (this_type == FRIBIDI_TYPE_RLI)\n            new_level = level + 1 + (level%2);\n          else if (this_type == FRIBIDI_TYPE_FSI)\n            {\n              /* Search for a local strong character until we\n                 meet the corresponding PDI or the end of the\n                 paragraph */\n              FriBidiRun *fsi_pp;\n              int isolate_count = 0;\n              int fsi_base_level = 0;\n              for_run_list (fsi_pp, pp)\n                {\n                  if (RL_TYPE(fsi_pp) == FRIBIDI_TYPE_PDI)\n                    {\n                      isolate_count--;\n                      if (valid_isolate_count < 0)\n                        break;\n                    }\n                  else if (FRIBIDI_IS_ISOLATE(RL_TYPE(fsi_pp)))\n                    isolate_count++;\n                  else if (isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (fsi_pp)))\n                    {\n                      fsi_base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (fsi_pp));\n                      break;\n                    }\n                }\n\n              /* Same behavior like RLI and LRI above */\n              if (FRIBIDI_LEVEL_IS_RTL (fsi_base_level))\n                new_level = level + 1 + (level%2);\n              else\n                new_level = level + 2 - (level%2);\n            }\n\n\t  RL_LEVEL (pp) = level;\n          RL_ISOLATE_LEVEL (pp) = isolate_level;\n          if (isolate_level < FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL-1)\n              isolate_level++;\n\n\t  if (!FRIBIDI_IS_NEUTRAL (override))\n\t    RL_TYPE (pp) = override;\n\n          if (new_level <= FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL)\n            {\n              valid_isolate_count++;\n              PUSH_STATUS;\n              level = new_level;\n            }\n          else\n            isolate_overflow += 1;\n        }\n      else if (this_type == FRIBIDI_TYPE_BS)\n\t{\n\t  /* X8. All explicit directional embeddings and overrides are\n\t     completely terminated at the end of each paragraph. Paragraph\n\t     separators are not included in the embedding. */\n\t  break;\n\t}\n      else\n\t{\n\t  /* X6. For all types besides RLE, LRE, RLO, LRO, and PDF:\n\t     a. Set the level of the current character to the current\n\t     embedding level.\n\t     b. Whenever the directional override status is not neutral,\n\t     reset the current character type to the directional override\n\t     status. */\n\t  RL_LEVEL (pp) = level;\n\t  if (!FRIBIDI_IS_NEUTRAL (override))\n\t    RL_TYPE (pp) = override;\n\t}\n    }\n\n    /* Build the isolate_level connections */\n    prev_isolate_level = 0;\n    for_run_list (pp, main_run_list)\n    {\n      int isolate_level = RL_ISOLATE_LEVEL (pp);\n      int i;\n\n      /* When going from an upper to a lower level, zero out all higher levels\n         in order not erroneous connections! */\n      if (isolate_level<prev_isolate_level)\n        for (i=isolate_level+1; i<=prev_isolate_level; i++)\n          run_per_isolate_level[i]=0;\n      prev_isolate_level = isolate_level;\n      \n      if (run_per_isolate_level[isolate_level])\n        {\n          run_per_isolate_level[isolate_level]->next_isolate = pp;\n          pp->prev_isolate = run_per_isolate_level[isolate_level];\n        }\n      run_per_isolate_level[isolate_level] = pp;\n    }\n\n    /* Implementing X8. It has no effect on a single paragraph! */\n    level = base_level;\n    override = FRIBIDI_TYPE_ON;\n    stack_size = 0;\n    over_pushed = 0;\n  }\n  /* X10. The remaining rules are applied to each run of characters at the\n     same level. For each run, determine the start-of-level-run (sor) and\n     end-of-level-run (eor) type, either L or R. This depends on the\n     higher of the two levels on either side of the boundary (at the start\n     or end of the paragraph, the level of the 'other' run is the base\n     embedding level). If the higher level is odd, the type is R, otherwise\n     it is L. */\n  /* Resolving Implicit Levels can be done out of X10 loop, so only change\n     of Resolving Weak Types and Resolving Neutral Types is needed. */\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_bidi_string (bidi_types, len);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 4. Resolving weak types. Also calculate the maximum isolate level */\n  max_iso_level = 0;\n  DBG (\"4a. resolving weak types\");\n  {\n    int last_strong_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n    FriBidiCharType prev_type_orig;\n    fribidi_boolean w4;\n\n    last_strong_stack[0] = base_dir;\n\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiCharType prev_type, this_type, next_type;\n      FriBidiRun *ppp_prev, *ppp_next;\n      int iso_level;\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      this_type = RL_TYPE (pp);\n      iso_level = RL_ISOLATE_LEVEL(pp);\n\n      if (iso_level > max_iso_level)\n        max_iso_level = iso_level;\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = RL_TYPE(ppp_prev);\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = RL_TYPE(ppp_next);\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_STRONG (prev_type))\n\tlast_strong_stack[iso_level] = prev_type;\n\n      /* W1. NSM\n         Examine each non-spacing mark (NSM) in the level run, and change the\n         type of the NSM to the type of the previous character. If the NSM\n         is at the start of the level run, it will get the type of sor. */\n      /* Implementation note: it is important that if the previous character\n         is not sor, then we should merge this run with the previous,\n         because of rules like W5, that we assume all of a sequence of\n         adjacent ETs are in one FriBidiRun. */\n      if (this_type == FRIBIDI_TYPE_NSM)\n\t{\n          /* New rule in Unicode 6.3 */\n          if (FRIBIDI_IS_ISOLATE (RL_TYPE (pp->prev)))\n              RL_TYPE(pp) = FRIBIDI_TYPE_ON;\n\n\t  if (RL_LEVEL (ppp_prev) == RL_LEVEL (pp))\n            {\n              if (ppp_prev == pp->prev)\n                pp = merge_with_prev (pp);\n            }\n\t  else\n\t    RL_TYPE (pp) = prev_type;\n\n\t  if (prev_type == next_type && RL_LEVEL (pp) == RL_LEVEL (pp->next))\n\t    {\n              if (ppp_next == pp->next)\n                pp = merge_with_prev (pp->next);\n\t    }\n\t  continue;\t\t/* As we know the next condition cannot be true. */\n\t}\n\n      /* W2: European numbers. */\n      if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_AL)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_AN;\n\n\t  /* Resolving dependency of loops for rules W1 and W2, so we\n\t     can merge them in one loop. */\n\t  if (next_type == FRIBIDI_TYPE_NSM)\n\t    RL_TYPE (ppp_next) = FRIBIDI_TYPE_AN;\n\t}\n    }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n    /* The last iso level is used to invalidate the the last strong values when going from\n       a higher to a lower iso level. When this occur, all \"last_strong\" values are\n       set to the base_dir. */\n    last_strong_stack[0] = base_dir;\n\n    DBG (\"4b. resolving weak types. W4 and W5\");\n\n    /* Resolving dependency of loops for rules W4 and W5, W5 may\n       want to prevent W4 to take effect in the next turn, do this\n       through \"w4\". */\n    w4 = true;\n    /* Resolving dependency of loops for rules W4 and W5 with W7,\n       W7 may change an EN to L but it sets the prev_type_orig if needed,\n       so W4 and W5 in next turn can still do their works. */\n    prev_type_orig = FRIBIDI_TYPE_ON;\n\n    /* Each isolate level has its own memory of the last strong character */\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiCharType prev_type, this_type, next_type;\n      int iso_level;\n      FriBidiRun *ppp_prev, *ppp_next;\n\n      this_type = RL_TYPE (pp);\n      iso_level = RL_ISOLATE_LEVEL(pp);\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = RL_TYPE(ppp_prev);\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = RL_TYPE(ppp_next);\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_STRONG (prev_type))\n\tlast_strong_stack[iso_level] = prev_type;\n\n      /* W2 ??? */\n\n      /* W3: Change ALs to R. */\n      if (this_type == FRIBIDI_TYPE_AL)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_RTL;\n\t  w4 = true;\n\t  prev_type_orig = FRIBIDI_TYPE_ON;\n\t  continue;\n\t}\n\n      /* W4. A single european separator changes to a european number.\n         A single common separator between two numbers of the same type\n         changes to that type. */\n      if (w4\n\t  && RL_LEN (pp) == 1 && FRIBIDI_IS_ES_OR_CS (this_type)\n\t  && FRIBIDI_IS_NUMBER (prev_type_orig)\n\t  && prev_type_orig == next_type\n\t  && (prev_type_orig == FRIBIDI_TYPE_EN\n\t      || this_type == FRIBIDI_TYPE_CS))\n\t{\n\t  RL_TYPE (pp) = prev_type;\n\t  this_type = RL_TYPE (pp);\n\t}\n      w4 = true;\n\n      /* W5. A sequence of European terminators adjacent to European\n         numbers changes to All European numbers. */\n      if (this_type == FRIBIDI_TYPE_ET\n\t  && (prev_type_orig == FRIBIDI_TYPE_EN\n\t      || next_type == FRIBIDI_TYPE_EN))\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_EN;\n\t  w4 = false;\n\t  this_type = RL_TYPE (pp);\n\t}\n\n      /* W6. Otherwise change separators and terminators to other neutral. */\n      if (FRIBIDI_IS_NUMBER_SEPARATOR_OR_TERMINATOR (this_type))\n\tRL_TYPE (pp) = FRIBIDI_TYPE_ON;\n\n      /* W7. Change european numbers to L. */\n      if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_LTR)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_LTR;\n\t  prev_type_orig = (RL_LEVEL (pp) == RL_LEVEL (pp->next) ?\n\t\t\t    FRIBIDI_TYPE_EN : FRIBIDI_TYPE_ON);\n\t}\n      else\n\tprev_type_orig = PREV_TYPE_OR_SOR (pp->next);\n    }\n  }\n\n  compact_neutrals (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 5. Resolving Neutral Types */\n\n  DBG (\"5. resolving neutral types - N0\");\n  {\n    /*  BD16 - Build list of all pairs*/\n    int num_iso_levels = max_iso_level + 1;\n    FriBidiPairingNode *pairing_nodes = NULL;\n    FriBidiRun *local_bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL][LOCAL_BRACKET_SIZE];\n    FriBidiRun **bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];\n    int bracket_stack_size[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];\n    int last_level = RL_LEVEL(main_run_list);\n    int last_iso_level = 0;\n\n    memset(bracket_stack, 0, sizeof(bracket_stack[0])*num_iso_levels);\n    memset(bracket_stack_size, 0, sizeof(bracket_stack_size[0])*num_iso_levels);\n\n    /* populate the bracket_size. The first LOCAL_BRACKET_SIZE entries\n       of the stack are one the stack. Allocate the rest of the entries.\n     */\n    {\n      int iso_level;\n      for (iso_level=0; iso_level < LOCAL_BRACKET_SIZE; iso_level++)\n        bracket_stack[iso_level] = local_bracket_stack[iso_level];\n\n      for (iso_level=LOCAL_BRACKET_SIZE; iso_level < num_iso_levels; iso_level++)\n        bracket_stack[iso_level] = fribidi_malloc (sizeof (bracket_stack[0])\n                                                       * FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS);\n    }\n\n    /* Build the bd16 pair stack. */\n    for_run_list (pp, main_run_list)\n      {\n        int level = RL_LEVEL(pp);\n        int iso_level = RL_ISOLATE_LEVEL(pp);\n        FriBidiBracketType brack_prop = RL_BRACKET_TYPE(pp);\n\n        /* Interpret the isolating run sequence as such that they\n           end at a change in the level, unless the iso_level has been\n           raised. */\n        if (level != last_level && last_iso_level == iso_level)\n          bracket_stack_size[last_iso_level] = 0;\n\n        if (brack_prop!= FRIBIDI_NO_BRACKET\n            && RL_TYPE(pp)==FRIBIDI_TYPE_ON)\n          {\n            if (FRIBIDI_IS_BRACKET_OPEN(brack_prop))\n              {\n                if (bracket_stack_size[iso_level]==FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS)\n                  break;\n\n                /* push onto the pair stack */\n                bracket_stack[iso_level][bracket_stack_size[iso_level]++] = pp;\n              }\n            else\n              {\n                int stack_idx = bracket_stack_size[iso_level] - 1;\n                while (stack_idx >= 0)\n                  {\n                    FriBidiBracketType se_brack_prop = RL_BRACKET_TYPE(bracket_stack[iso_level][stack_idx]);\n                    if (FRIBIDI_BRACKET_ID(se_brack_prop) == FRIBIDI_BRACKET_ID(brack_prop))\n                      {\n                        bracket_stack_size[iso_level] = stack_idx;\n\n                        pairing_nodes = pairing_nodes_push(pairing_nodes,\n                                                           bracket_stack[iso_level][stack_idx],\n                                                           pp);\n                        break;\n                    }\n                    stack_idx--;\n                  }\n              }\n          }\n        last_level = level;\n        last_iso_level = iso_level;\n      }\n\n    /* The list must now be sorted for the next algo to work! */\n    sort_pairing_nodes(&pairing_nodes);\n\n# if DEBUG\n    if UNLIKELY\n    (fribidi_debug_status ())\n      {\n        print_pairing_nodes (pairing_nodes);\n      }\n# endif\t/* DEBUG */\n\n    /* Start the N0 */\n    {\n      FriBidiPairingNode *ppairs = pairing_nodes;\n      while (ppairs)\n        {\n          int embedding_level = ppairs->open->level; \n\n          /* Find matching strong. */\n          fribidi_boolean found = false;\n          FriBidiRun *ppn;\n          for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)\n            {\n              FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n\n              /* Calculate level like in resolve implicit levels below to prevent\n                 embedded levels not to match the base_level */\n              int this_level = RL_LEVEL (ppn) +\n                (FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n              /* N0b */\n              if (FRIBIDI_IS_STRONG (this_type) && this_level == embedding_level)\n                {\n                  RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = this_level%2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;\n                  found = true;\n                  break;\n                }\n            }\n\n          /* N0c */\n          /* Search for any strong type preceding and within the bracket pair */\n          if (!found)\n            {\n              /* Search for a preceding strong */\n              int prec_strong_level = embedding_level; /* TBDov! Extract from Isolate level in effect */\n              int iso_level = RL_ISOLATE_LEVEL(ppairs->open);\n              for (ppn = ppairs->open->prev; ppn->type != FRIBIDI_TYPE_SENTINEL; ppn=ppn->prev)\n                {\n                  FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n                  if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)\n                    {\n                      prec_strong_level = RL_LEVEL (ppn) +\n                        (FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n                      break;\n                    }\n                }\n\n              for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)\n                {\n                  FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n                  if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)\n                    {\n                      /* By constraint this is opposite the embedding direction,\n                         since we did not match the N0b rule. We must now\n                         compare with the preceding strong to establish whether\n                         to apply N0c1 (opposite) or N0c2 embedding */\n                      RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = prec_strong_level % 2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;\n                      found = true;\n                      break;\n                    }\n                }\n            }\n\n          ppairs = ppairs->next;\n        }\n\n      free_pairing_nodes(pairing_nodes);\n\n      if (num_iso_levels >= LOCAL_BRACKET_SIZE)\n        {\n          int i;\n          /* Only need to free the non static members */\n          for (i=LOCAL_BRACKET_SIZE; i<num_iso_levels; i++)\n            fribidi_free(bracket_stack[i]);\n        }\n\n      /* Remove the bracket property and re-compact */\n      {\n        const FriBidiBracketType NoBracket = FRIBIDI_NO_BRACKET;\n        for_run_list (pp, main_run_list)\n          pp->bracket_type = NoBracket;\n        compact_neutrals (main_run_list);\n      }\n    }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n  }\n\n  DBG (\"resolving neutral types - N1+N2\");\n  {\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType prev_type, this_type, next_type;\n      FriBidiRun *ppp_prev, *ppp_next;\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      /* \"European and Arabic numbers are treated as though they were R\"\n         FRIBIDI_CHANGE_NUMBER_TO_RTL does this. */\n      this_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE (pp));\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_prev));\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_next));\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_NEUTRAL (this_type))\n\tRL_TYPE (pp) = (prev_type == next_type) ?\n\t  /* N1. */ prev_type :\n\t  /* N2. */ FRIBIDI_EMBEDDING_DIRECTION (pp);\n    }\n  }\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 6. Resolving implicit levels */\n  DBG (\"resolving implicit levels\");\n  {\n    max_level = base_level;\n\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType this_type;\n      int level;\n\n      this_type = RL_TYPE (pp);\n      level = RL_LEVEL (pp);\n\n      /* I1. Even */\n      /* I2. Odd */\n      if (FRIBIDI_IS_NUMBER (this_type))\n\tRL_LEVEL (pp) = (level + 2) & ~1;\n      else\n\tRL_LEVEL (pp) =\n\t  level +\n\t  (FRIBIDI_LEVEL_IS_RTL (level) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n      if (RL_LEVEL (pp) > max_level)\n\tmax_level = RL_LEVEL (pp);\n    }\n  }\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_bidi_string (bidi_types, len);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n/* Reinsert the explicit codes & BN's that are already removed, from the\n   explicits_list to main_run_list. */\n  DBG (\"reinserting explicit codes\");\n  if UNLIKELY\n    (explicits_list->next != explicits_list)\n    {\n      register FriBidiRun *p;\n      register fribidi_boolean stat =\n\tshadow_run_list (main_run_list, explicits_list, true);\n      explicits_list = NULL;\n      if UNLIKELY\n\t(!stat) goto out;\n\n      /* Set level of inserted explicit chars to that of their previous\n       * char, such that they do not affect reordering. */\n      p = main_run_list->next;\n      if (p != main_run_list && p->level == FRIBIDI_SENTINEL)\n\tp->level = base_level;\n      for_run_list (p, main_run_list) if (p->level == FRIBIDI_SENTINEL)\n\tp->level = p->prev->level;\n    }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  DBG (\"reset the embedding levels, 1, 2, 3.\");\n  {\n    register int j, state, pos;\n    register FriBidiCharType char_type;\n    register FriBidiRun *p, *q, *list;\n\n    /* L1. Reset the embedding levels of some chars:\n       1. segment separators,\n       2. paragraph separators,\n       3. any sequence of whitespace characters preceding a segment\n          separator or paragraph separator, and\n       4. any sequence of whitespace characters and/or isolate formatting\n          characters at the end of the line.\n       ... (to be continued in fribidi_reorder_line()). */\n    list = new_run_list ();\n    if UNLIKELY\n      (!list) goto out;\n    q = list;\n    state = 1;\n    pos = len - 1;\n    for (j = len - 1; j >= -1; j--)\n      {\n\t/* close up the open link at the end */\n\tif (j >= 0)\n\t  char_type = bidi_types[j];\n\telse\n\t  char_type = FRIBIDI_TYPE_ON;\n\tif (!state && FRIBIDI_IS_SEPARATOR (char_type))\n\t  {\n\t    state = 1;\n\t    pos = j;\n\t  }\n\telse if (state &&\n                 !(FRIBIDI_IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS(char_type)\n                   || FRIBIDI_IS_ISOLATE(char_type)))\n\t  {\n\t    state = 0;\n\t    p = new_run ();\n\t    if UNLIKELY\n\t      (!p)\n\t      {\n\t\tfree_run_list (list);\n\t\tgoto out;\n\t      }\n\t    p->pos = j + 1;\n\t    p->len = pos - j;\n\t    p->type = base_dir;\n\t    p->level = base_level;\n\t    move_node_before (p, q);\n\t    q = p;\n\t  }\n      }\n    if UNLIKELY\n      (!shadow_run_list (main_run_list, list, false)) goto out;\n  }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  {\n    FriBidiStrIndex pos = 0;\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiStrIndex l;\n      register FriBidiLevel level = pp->level;\n      for (l = pp->len; l; l--)\n\tembedding_levels[pos++] = level;\n    }\n  }\n\n  status = true;\n\nout:\n  DBG (\"leaving fribidi_get_par_embedding_levels\");\n\n  if (main_run_list)\n    free_run_list (main_run_list);\n  if UNLIKELY\n    (explicits_list) free_run_list (explicits_list);\n\n  return status ? max_level + 1 : 0;\n}\n\n\n// target function\nstatic void\ncompact_list (\n  FriBidiRun *list\n)\n{\n  fribidi_assert (list);\n\n  if (list->next)\n    for_run_list (list, list)\n      if (RL_TYPE (list->prev) == RL_TYPE (list)\n\t  && RL_LEVEL (list->prev) == RL_LEVEL (list)\n          && RL_BRACKET_TYPE(list) == FRIBIDI_NO_BRACKET /* Don't join brackets! */\n          && RL_BRACKET_TYPE(list->prev) == FRIBIDI_NO_BRACKET\n          )\n      list = merge_with_prev (list);\n}\nstatic void\ncompact_neutrals (\n  FriBidiRun *list\n)\n{\n  fribidi_assert (list);\n\n  if (list->next)\n    {\n      for_run_list (list, list)\n      {\n\tif (RL_LEVEL (list->prev) == RL_LEVEL (list)\n\t    &&\n\t    ((RL_TYPE (list->prev) == RL_TYPE (list)\n\t      || (FRIBIDI_IS_NEUTRAL (RL_TYPE (list->prev))\n\t\t  && FRIBIDI_IS_NEUTRAL (RL_TYPE (list)))))\n            && RL_BRACKET_TYPE(list) == FRIBIDI_NO_BRACKET /* Don't join brackets! */\n            && RL_BRACKET_TYPE(list->prev) == FRIBIDI_NO_BRACKET\n            )\n\t  list = merge_with_prev (list);\n      }\n    }\n}\n",
    "target": 1,
    "idx": 1034696,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void user_stream_create_object(struct php_user_stream_wrapper *uwrap, php_stream_context *context, zval *object)\n{\n\tif (uwrap->ce->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_TRAIT|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) {\n\t\tZVAL_UNDEF(object);\n\t\treturn;\n\t}\n\n\t/* create an instance of our class */\n\tif (object_init_ex(object, uwrap->ce) == FAILURE) {\n\t\tZVAL_UNDEF(object);\n\t\treturn;\n\t}\n\n\tif (context) {\n\t\tGC_ADDREF(context->res);\n\t\tadd_property_resource(object, \"context\", context->res);\n\t} else {\n\t\tadd_property_null(object, \"context\");\n\t}\n\n\tif (uwrap->ce->constructor) {\n\t\tzend_call_known_instance_method_with_0_params(\n\t\t\tuwrap->ce->constructor, Z_OBJ_P(object), NULL);\n\t}\n}\n\n\n\n\n\nstatic void _php_do_opendir(INTERNAL_FUNCTION_PARAMETERS, int createobject)\n{\n\tchar *dirname;\n\tsize_t dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *dirp;\n\n\tZEND_PARSE_PARAMETERS_START(1, 2)\n\t\tZ_PARAM_PATH(dirname, dir_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tdirp = php_stream_opendir(dirname, REPORT_ERRORS, context);\n\n\tif (dirp == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tdirp->flags |= PHP_STREAM_FLAG_NO_FCLOSE;\n\n\tphp_set_default_dir(dirp->res);\n\n\tif (createobject) {\n\t\tobject_init_ex(return_value, dir_class_entry_ptr);\n\t\tadd_property_stringl(return_value, \"path\", dirname, dir_len);\n\t\tadd_property_resource(return_value, \"handle\", dirp->res);\n\t\tphp_stream_auto_cleanup(dirp); /* so we don't get warnings under debug */\n\t} else {\n\t\tphp_stream_to_zval(dirp, return_value);\n\t}\n}\n\n\n\nstatic ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzend_execute_data *call = EX(call);\n\tzend_function *fbc = call->func;\n\tzval *ret;\n\tzval retval;\n\n\tSAVE_OPLINE();\n\tEX(call) = call->prev_execute_data;\n\n\tcall->prev_execute_data = execute_data;\n\tEG(current_execute_data) = call;\n\n#if ZEND_DEBUG\n\tzend_bool should_throw = zend_internal_call_should_throw(fbc, call);\n#endif\n\n\tret = 0 ? EX_VAR(opline->result.var) : &retval;\n\tZVAL_NULL(ret);\n\n\tfbc->internal_function.handler(call, ret);\n\n#if ZEND_DEBUG\n\tif (!EG(exception) && call->func) {\n\t\tif (should_throw) {\n\t\t\tzend_internal_call_arginfo_violation(call->func);\n\t\t}\n\t\tZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||\n\t\t\tzend_verify_internal_return_type(call->func, ret));\n\t\tZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)\n\t\t\t? Z_ISREF_P(ret) : !Z_ISREF_P(ret));\n\t}\n#endif\n\n\tEG(current_execute_data) = execute_data;\n\tzend_vm_stack_free_args(call);\n\n\tuint32_t call_info = ZEND_CALL_INFO(call);\n\tif (UNEXPECTED(call_info & (ZEND_CALL_HAS_EXTRA_NAMED_PARAMS|ZEND_CALL_ALLOCATED))) {\n\t\tif (call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS) {\n\t\t\tzend_free_extra_named_params(call->extra_named_params);\n\t\t}\n\t\tzend_vm_stack_free_call_frame_ex(call_info, call);\n\t} else {\n\t\tEG(vm_stack_top) = (zval*)call;\n\t}\n\n\tif (!0) {\n\t\ti_zval_ptr_dtor(ret);\n\t}\n\n\tif (UNEXPECTED(EG(exception) != NULL)) {\n\t\tzend_rethrow_exception(execute_data);\n\t\tHANDLE_EXCEPTION();\n\t}\n\n\tZEND_VM_SET_OPCODE(opline + 1);\n\tZEND_VM_CONTINUE();\n}\n\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)\n{\n\tzend_execute_data *execute_data;\n\tvoid *object_or_called_scope;\n\tuint32_t call_info;\n\n\tif (EG(exception) != NULL) {\n\t\treturn;\n\t}\n\n\tobject_or_called_scope = zend_get_this_object(EG(current_execute_data));\n\tif (EXPECTED(!object_or_called_scope)) {\n\t\tobject_or_called_scope = zend_get_called_scope(EG(current_execute_data));\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE;\n\t} else {\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE | ZEND_CALL_HAS_THIS;\n\t}\n\texecute_data = zend_vm_stack_push_call_frame(call_info,\n\t\t(zend_function*)op_array, 0, object_or_called_scope);\n\tif (EG(current_execute_data)) {\n\t\texecute_data->symbol_table = zend_rebuild_symbol_table();\n\t} else {\n\t\texecute_data->symbol_table = &EG(symbol_table);\n\t}\n\tEX(prev_execute_data) = EG(current_execute_data);\n\ti_init_code_execute_data(execute_data, op_array, return_value);\n\tZEND_OBSERVER_FCALL_BEGIN(execute_data);\n\tzend_execute_ex(execute_data);\n\t/* Observer end handlers are called from ZEND_RETURN */\n\tzend_vm_stack_free_call_frame(execute_data);\n}\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\n// target function\nstatic void user_stream_create_object(struct php_user_stream_wrapper *uwrap, php_stream_context *context, zval *object)\n{\n\tif (uwrap->ce->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_TRAIT|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) {\n\t\tZVAL_UNDEF(object);\n\t\treturn;\n\t}\n\n\t/* create an instance of our class */\n\tif (object_init_ex(object, uwrap->ce) == FAILURE) {\n\t\tZVAL_UNDEF(object);\n\t\treturn;\n\t}\n\n\tif (context) {\n\t\tadd_property_resource(object, \"context\", context->res);\n\t\tGC_ADDREF(context->res);\n\t} else {\n\t\tadd_property_null(object, \"context\");\n\t}\n\n\tif (uwrap->ce->constructor) {\n\t\tzend_call_known_instance_method_with_0_params(\n\t\t\tuwrap->ce->constructor, Z_OBJ_P(object), NULL);\n\t}\n}\n",
    "target": 1,
    "idx": 1047997,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nMRB_API void\nmrb_gc_mark(mrb_state *mrb, struct RBasic *obj)\n{\n  if (obj == 0) return;\n  if (!is_white(obj)) return;\n  if (is_red(obj)) return;\n  mrb_assert((obj)->tt != MRB_TT_FREE);\n  add_gray_list(mrb, &mrb->gc, obj);\n}\n\nstatic int\niv_mark_i(mrb_state *mrb, mrb_sym sym, mrb_value v, void *p)\n{\n  mrb_gc_mark_value(mrb, v);\n  return 0;\n}\n\nstatic void\niv_foreach(mrb_state *mrb, iv_tbl *t, mrb_iv_foreach_func *func, void *p)\n{\n  int i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  mrb_value *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    if (IV_KEY_P(keys[i])) {\n      if ((*func)(mrb, keys[i], vals[i], p) != 0) {\n        return;\n      }\n    }\n  }\n  return;\n}\n\nstatic void\nmark_tbl(mrb_state *mrb, iv_tbl *t)\n{\n  iv_foreach(mrb, t, iv_mark_i, 0);\n}\n\nvoid\nmrb_gc_mark_iv(mrb_state *mrb, struct RObject *obj)\n{\n  mark_tbl(mrb, obj->iv);\n}\n\nstatic void\ngc_mark_children(mrb_state *mrb, mrb_gc *gc, struct RBasic *obj)\n{\n  mrb_assert(is_gray(obj));\n  paint_black(obj);\n  mrb_gc_mark(mrb, (struct RBasic*)obj->c);\n  switch (obj->tt) {\n  case MRB_TT_ICLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n      if (MRB_FLAG_TEST(c, MRB_FL_CLASS_IS_ORIGIN))\n        mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RClass*)obj)->super);\n    }\n    break;\n\n  case MRB_TT_CLASS:\n  case MRB_TT_MODULE:\n  case MRB_TT_SCLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n\n      mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)c->super);\n    }\n    /* fall through */\n\n  case MRB_TT_OBJECT:\n  case MRB_TT_CDATA:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    break;\n\n  case MRB_TT_PROC:\n    {\n      struct RProc *p = (struct RProc*)obj;\n\n      mrb_gc_mark(mrb, (struct RBasic*)p->upper);\n      mrb_gc_mark(mrb, (struct RBasic*)p->e.env);\n    }\n    break;\n\n  case MRB_TT_ENV:\n    {\n      struct REnv *e = (struct REnv*)obj;\n      mrb_int i, len;\n\n      if (MRB_ENV_ONSTACK_P(e) && e->cxt && e->cxt->fib) {\n        mrb_gc_mark(mrb, (struct RBasic*)e->cxt->fib);\n      }\n      len = MRB_ENV_LEN(e);\n      for (i=0; i<len; i++) {\n        mrb_gc_mark_value(mrb, e->stack[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_FIBER:\n    {\n      struct mrb_context *c = ((struct RFiber*)obj)->cxt;\n\n      if (c) mark_context(mrb, c);\n    }\n    break;\n\n  case MRB_TT_STRUCT:\n  case MRB_TT_ARRAY:\n    {\n      struct RArray *a = (struct RArray*)obj;\n      size_t i, e=ARY_LEN(a);\n      mrb_value *p = ARY_PTR(a);\n\n      for (i=0; i<e; i++) {\n        mrb_gc_mark_value(mrb, p[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_HASH:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    mrb_gc_mark_hash(mrb, (struct RHash*)obj);\n    break;\n\n  case MRB_TT_STRING:\n    if (RSTR_FSHARED_P(obj)) {\n      struct RString *s = (struct RString*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)s->as.heap.aux.fshared);\n    }\n    break;\n\n  case MRB_TT_RANGE:\n    mrb_gc_mark_range(mrb, (struct RRange*)obj);\n    break;\n\n  case MRB_TT_BREAK:\n    {\n      struct RBreak *brk = (struct RBreak*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)mrb_break_proc_get(brk));\n      mrb_gc_mark_value(mrb, mrb_break_value_get(brk));\n    }\n    break;\n\n  case MRB_TT_EXCEPTION:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    if (((struct RException*)obj)->mesg) {\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->mesg);\n    }\n    mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->backtrace);\n    break;\n\n  default:\n    break;\n  }\n}\n\nstatic size_t\nincremental_marking_phase(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  size_t tried_marks = 0;\n\n  while (gc->gray_list && tried_marks < limit) {\n    struct RBasic *obj = gc->gray_list;\n    gc->gray_list = obj->gcnext;\n    gc_mark_children(mrb, gc, obj);\n    tried_marks += gc_gray_counts(mrb, gc, obj);\n  }\n\n  return tried_marks;\n}\n\nstatic size_t\nincremental_gc(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  switch (gc->state) {\n  case MRB_GC_STATE_ROOT:\n    root_scan_phase(mrb, gc);\n    gc->state = MRB_GC_STATE_MARK;\n    flip_white_part(gc);\n    return 0;\n  case MRB_GC_STATE_MARK:\n    if (gc->gray_list) {\n      return incremental_marking_phase(mrb, gc, limit);\n    }\n    else {\n      final_marking_phase(mrb, gc);\n      prepare_incremental_sweep(mrb, gc);\n      return 0;\n    }\n  case MRB_GC_STATE_SWEEP: {\n     size_t tried_sweep = 0;\n     tried_sweep = incremental_sweep_phase(mrb, gc, limit);\n     if (tried_sweep == 0)\n       gc->state = MRB_GC_STATE_ROOT;\n     return tried_sweep;\n  }\n  default:\n    /* unknown state */\n    mrb_assert(0);\n    return 0;\n  }\n}\n\nstatic void\nincremental_gc_finish(mrb_state *mrb, mrb_gc *gc)\n{\n  do {\n    incremental_gc(mrb, gc, SIZE_MAX);\n  } while (gc->state != MRB_GC_STATE_ROOT);\n}\n\nMRB_API void\nmrb_full_gc(mrb_state *mrb)\n{\n  mrb_gc *gc = &mrb->gc;\n\n  if (!mrb->c) return;\n  if (gc->disabled || gc->iterating) return;\n\n  if (is_generational(gc)) {\n    /* clear all the old objects back to young */\n    clear_all_old(mrb, gc);\n    gc->full = TRUE;\n  }\n  else if (gc->state != MRB_GC_STATE_ROOT) {\n    /* finish half baked GC cycle */\n    incremental_gc_finish(mrb, gc);\n  }\n\n  incremental_gc_finish(mrb, gc);\n  gc->threshold = (gc->live_after_mark/100) * gc->interval_ratio;\n\n  if (is_generational(gc)) {\n    gc->majorgc_old_threshold = gc->live_after_mark/100 * MAJOR_GC_INC_RATIO;\n    gc->full = FALSE;\n  }\n\n#ifdef MRB_USE_MALLOC_TRIM\n  malloc_trim(0);\n#endif\n}\n\nvoid\nmrb_objspace_each_objects(mrb_state *mrb, mrb_each_object_callback *callback, void *data)\n{\n  mrb_bool iterating = mrb->gc.iterating;\n\n  mrb_full_gc(mrb);\n  mrb->gc.iterating = TRUE;\n  if (iterating) {\n    gc_each_objects(mrb, &mrb->gc, callback, data);\n  }\n  else {\n    struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n    struct mrb_jmpbuf c_jmp;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      gc_each_objects(mrb, &mrb->gc, callback, data);\n      mrb->jmp = prev_jmp;\n      mrb->gc.iterating = iterating;\n   } MRB_CATCH(&c_jmp) {\n      mrb->gc.iterating = iterating;\n      mrb->jmp = prev_jmp;\n      MRB_THROW(prev_jmp);\n    } MRB_END_EXC(&c_jmp);\n  }\n}\n\nstatic mrb_value\nos_count_objects(mrb_state *mrb, mrb_value self)\n{\n  struct os_count_struct obj_count = { 0 };\n  mrb_int i;\n  mrb_value hash;\n\n  if (mrb_get_args(mrb, \"|H\", &hash) == 0) {\n    hash = mrb_hash_new(mrb);\n  }\n\n  if (!mrb_hash_empty_p(mrb, hash)) {\n    mrb_hash_clear(mrb, hash);\n  }\n\n  mrb_objspace_each_objects(mrb, os_count_object_type, &obj_count);\n\n  mrb_hash_set(mrb, hash, mrb_symbol_value(MRB_SYM(TOTAL)), mrb_fixnum_value(obj_count.total));\n  mrb_hash_set(mrb, hash, mrb_symbol_value(MRB_SYM(FREE)), mrb_fixnum_value(obj_count.freed));\n\n  for (i = MRB_TT_FALSE; i < MRB_TT_MAXDEFINE; i++) {\n    mrb_value type;\n    switch (i) {\n#define COUNT_TYPE(t) case (MRB_T ## t): type = mrb_symbol_value(MRB_SYM(t)); break;\n      COUNT_TYPE(T_INTEGER);\n      COUNT_TYPE(T_FLOAT);\n      COUNT_TYPE(T_CPTR);\n      COUNT_TYPE(T_OBJECT);\n      COUNT_TYPE(T_CLASS);\n      COUNT_TYPE(T_MODULE);\n      COUNT_TYPE(T_ICLASS);\n      COUNT_TYPE(T_SCLASS);\n      COUNT_TYPE(T_PROC);\n      COUNT_TYPE(T_ARRAY);\n      COUNT_TYPE(T_HASH);\n      COUNT_TYPE(T_STRING);\n      COUNT_TYPE(T_RANGE);\n      COUNT_TYPE(T_EXCEPTION);\n      COUNT_TYPE(T_ENV);\n      COUNT_TYPE(T_DATA);\n      COUNT_TYPE(T_FIBER);\n      COUNT_TYPE(T_STRUCT);\n      COUNT_TYPE(T_ISTRUCT);\n      COUNT_TYPE(T_BREAK);\n      COUNT_TYPE(T_COMPLEX);\n      COUNT_TYPE(T_RATIONAL);\n      COUNT_TYPE(T_BIGINT);\n#undef COUNT_TYPE\n    default:\n      type = mrb_fixnum_value(i); break;\n    }\n    if (obj_count.counts[i])\n      mrb_hash_set(mrb, hash, type, mrb_fixnum_value(obj_count.counts[i]));\n  }\n\n  return hash;\n}\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  else {\n    struct REnv *e = CI_ENV(mrb->c->ci);\n    if (stack_keep == 0 || (e && irep->nlocals < MRB_ENV_LEN(e))) {\n      ci_env_set(mrb->c->ci, NULL);\n      mrb_env_unshare(mrb, e, FALSE);\n    }\n  }\n  stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nint FuzzRB(const uint8_t *Data, size_t size) {\n  mrb_value v;\n  mrb_state *mrb = mrb_open();\n  if (!mrb)\n    return 0;\n\n  char *code = (char *)malloc(size+1);\n  if (!code)\n    return 0;\n  memcpy(code, Data, size);\n  code[size] = '\\0';\n\n  if (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n    // With libFuzzer binary run this to generate an RB file x.rb:\n    // PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n    std::ofstream of(dump_path);\n    of.write(code, size);\n  }\n  std::cout << \"\\n\\n############\\n\" << code << \"\\n############\\n\\n\";\n  v = mrb_load_string(mrb, code);\n  mrb_close(mrb);\n\n  free(code);\n  return 0;\n}\n\n\n\n\n// target function\nMRB_API void\nmrb_field_write_barrier(mrb_state *mrb, struct RBasic *obj, struct RBasic *value)\n{\n  mrb_gc *gc = &mrb->gc;\n\n  if (!value) return;\n  if (!is_black(obj)) return;\n  if (!is_white(value)) return;\n  if (is_red(value)) return;\n\n  mrb_assert(gc->state == MRB_GC_STATE_MARK || (!is_dead(gc, value) && !is_dead(gc, obj)));\n  mrb_assert(is_generational(gc) || gc->state != MRB_GC_STATE_ROOT);\n\n  if (is_generational(gc) || gc->state == MRB_GC_STATE_MARK) {\n    add_gray_list(mrb, gc, value);\n  }\n  else {\n    mrb_assert(gc->state == MRB_GC_STATE_SWEEP);\n    paint_partial_white(gc, obj); /* for never write barriers */\n  }\n}\n",
    "target": 1,
    "idx": 1056991,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nint64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n  constexpr int64_t pop_len = sizeof(uint64_t) * 8;\n  DCHECK_GE(bit_offset, 0);\n  int64_t count = 0;\n\n  const auto p = BitmapWordAlign<pop_len / 8>(data, bit_offset, length);\n  for (int64_t i = bit_offset; i < bit_offset + p.leading_bits; ++i) {\n    if (BitUtil::GetBit(data, i)) {\n      ++count;\n    }\n  }\n\n  if (p.aligned_words > 0) {\n    // popcount as much as possible with the widest possible count\n    const uint64_t* u64_data = reinterpret_cast<const uint64_t*>(p.aligned_start);\n    DCHECK_EQ(reinterpret_cast<size_t>(u64_data) & 7, 0);\n    const uint64_t* end = u64_data + p.aligned_words;\n\n    for (auto iter = u64_data; iter < end; ++iter) {\n      count += __builtin_popcountll(*iter);\n    }\n  }\n\n  // Account for left over bits (in theory we could fall back to smaller\n  // versions of popcount but the code complexity is likely not worth it)\n  for (int64_t i = p.trailing_bit_offset; i < bit_offset + length; ++i) {\n    if (BitUtil::GetBit(data, i)) {\n      ++count;\n    }\n  }\n\n  return count;\n}\n\nint64_t ArrayData::GetNullCount() const {\n  int64_t precomputed = this->null_count.load();\n  if (ARROW_PREDICT_FALSE(precomputed == kUnknownNullCount)) {\n    if (this->buffers[0]) {\n      precomputed = this->length -\n                    CountSetBits(this->buffers[0]->data(), this->offset, this->length);\n    } else {\n      precomputed = 0;\n    }\n    this->null_count.store(precomputed);\n  }\n  return precomputed;\n}\n\nint64_t Array::null_count() const { return data_->GetNullCount(); }\n\nARROW_EXPORT\nStatus ValidateArray(const Array& array) {\n  // First check the array layout conforms to the spec\n  const DataType& type = *array.type();\n  const auto layout = type.layout();\n  const ArrayData& data = *array.data();\n\n  if (array.length() < 0) {\n    return Status::Invalid(\"Array length is negative\");\n  }\n\n  if (array.null_count() > array.length()) {\n    return Status::Invalid(\"Null count exceeds array length\");\n  }\n\n  if (data.buffers.size() != layout.bit_widths.size()) {\n    return Status::Invalid(\"Expected \", layout.bit_widths.size(),\n                           \" buffers in array \"\n                           \"of type \",\n                           type.ToString(), \", got \", data.buffers.size());\n  }\n  if (type.id() != Type::EXTENSION) {\n    if (data.child_data.size() != static_cast<size_t>(type.num_children())) {\n      return Status::Invalid(\"Expected \", type.num_children(),\n                             \" child arrays in array \"\n                             \"of type \",\n                             type.ToString(), \", got \", data.child_data.size());\n    }\n  }\n  if (layout.has_dictionary && !data.dictionary) {\n    return Status::Invalid(\"Array of type \", type.ToString(),\n                           \" must have dictionary values\");\n  }\n  if (!layout.has_dictionary && data.dictionary) {\n    return Status::Invalid(\"Unexpected dictionary values in array of type \",\n                           type.ToString());\n  }\n\n  ValidateArrayVisitor visitor;\n  return VisitArrayInline(array, &visitor);\n}\n\n  Status Visit(const ExtensionArray& array) {\n    return ValidateArrayData(*array.storage());\n  }\n\n  static Status Visit(const ArrayData& arr, Visitor* visitor) {\n    const auto& fw_type = internal::checked_cast<const FixedSizeBinaryType&>(*arr.type);\n\n    const int32_t byte_width = fw_type.byte_width();\n    const uint8_t* data =\n        arr.GetValues<uint8_t>(1,\n                               /*absolute_offset=*/arr.offset * byte_width);\n\n    if (arr.null_count != 0) {\n      internal::BitmapReader valid_reader(arr.buffers[0]->data(), arr.offset, arr.length);\n      for (int64_t i = 0; i < arr.length; ++i) {\n        const bool is_null = valid_reader.IsNotSet();\n        valid_reader.Next();\n        if (is_null) {\n          ARROW_RETURN_NOT_OK(visitor->VisitNull());\n        } else {\n          auto value = util::string_view(reinterpret_cast<const char*>(data), byte_width);\n          ARROW_RETURN_NOT_OK(visitor->VisitValue(value));\n        }\n        data += byte_width;\n      }\n    } else {\n      for (int64_t i = 0; i < arr.length; ++i) {\n        auto value = util::string_view(reinterpret_cast<const char*>(data), byte_width);\n        ARROW_RETURN_NOT_OK(visitor->VisitValue(value));\n        data += byte_width;\n      }\n    }\n    return Status::OK();\n  }\n\nARROW_EXPORT\nStatus ValidateArray(const Array& array) {\n  // First check the array layout conforms to the spec\n  const DataType& type = *array.type();\n  const auto layout = type.layout();\n  const ArrayData& data = *array.data();\n\n  if (array.length() < 0) {\n    return Status::Invalid(\"Array length is negative\");\n  }\n\n  if (array.null_count() > array.length()) {\n    return Status::Invalid(\"Null count exceeds array length\");\n  }\n\n  if (data.buffers.size() != layout.bit_widths.size()) {\n    return Status::Invalid(\"Expected \", layout.bit_widths.size(),\n                           \" buffers in array \"\n                           \"of type \",\n                           type.ToString(), \", got \", data.buffers.size());\n  }\n  if (type.id() != Type::EXTENSION) {\n    if (data.child_data.size() != static_cast<size_t>(type.num_children())) {\n      return Status::Invalid(\"Expected \", type.num_children(),\n                             \" child arrays in array \"\n                             \"of type \",\n                             type.ToString(), \", got \", data.child_data.size());\n    }\n  }\n  if (layout.has_dictionary && !data.dictionary) {\n    return Status::Invalid(\"Array of type \", type.ToString(),\n                           \" must have dictionary values\");\n  }\n  if (!layout.has_dictionary && data.dictionary) {\n    return Status::Invalid(\"Unexpected dictionary values in array of type \",\n                           type.ToString());\n  }\n\n  ValidateArrayVisitor visitor;\n  return VisitArrayInline(array, &visitor);\n}\n\n  Status Validate() const override {\n    if (static_cast<int>(columns_.size()) != schema_->num_fields()) {\n      return Status::Invalid(\"Number of columns did not match schema\");\n    }\n    return RecordBatch::Validate();\n  }\n\n  Status Validate() const override {\n    if (static_cast<int>(columns_.size()) != schema_->num_fields()) {\n      return Status::Invalid(\"Number of columns did not match schema\");\n    }\n    return RecordBatch::Validate();\n  }\n\n  Status Validate() const override {\n    if (static_cast<int>(columns_.size()) != schema_->num_fields()) {\n      return Status::Invalid(\"Number of columns did not match schema\");\n    }\n    return RecordBatch::Validate();\n  }\n\nStatus FuzzIpcStream(const uint8_t* data, int64_t size) {\n  auto buffer = std::make_shared<Buffer>(data, size);\n  io::BufferReader buffer_reader(buffer);\n\n  std::shared_ptr<RecordBatchReader> batch_reader;\n  RETURN_NOT_OK(RecordBatchStreamReader::Open(&buffer_reader, &batch_reader));\n\n  while (true) {\n    std::shared_ptr<arrow::RecordBatch> batch;\n    RETURN_NOT_OK(batch_reader->ReadNext(&batch));\n    if (batch == nullptr) {\n      break;\n    }\n    RETURN_NOT_OK(batch->ValidateFull());\n  }\n\n  return Status::OK();\n}\n\n\n// target function\n  Status Reserve(const int64_t capacity) override {\n    if (!mutable_data_ || capacity > capacity_) {\n      uint8_t* new_data;\n      int64_t new_capacity = BitUtil::RoundUpToMultipleOf64(capacity);\n      if (mutable_data_) {\n        RETURN_NOT_OK(pool_->Reallocate(capacity_, new_capacity, &mutable_data_));\n      } else {\n        RETURN_NOT_OK(pool_->Allocate(new_capacity, &new_data));\n        mutable_data_ = new_data;\n      }\n      data_ = mutable_data_;\n      capacity_ = new_capacity;\n    }\n    return Status::OK();\n  }\n  Status Resize(const int64_t new_size, bool shrink_to_fit = true) override {\n    if (mutable_data_ && shrink_to_fit && new_size <= size_) {\n      // Buffer is non-null and is not growing, so shrink to the requested size without\n      // excess space.\n      int64_t new_capacity = BitUtil::RoundUpToMultipleOf64(new_size);\n      if (capacity_ != new_capacity) {\n        // Buffer hasn't got yet the requested size.\n        RETURN_NOT_OK(pool_->Reallocate(capacity_, new_capacity, &mutable_data_));\n        data_ = mutable_data_;\n        capacity_ = new_capacity;\n      }\n    } else {\n      RETURN_NOT_OK(Reserve(new_size));\n    }\n    size_ = new_size;\n\n    return Status::OK();\n  }\n  Result<int64_t> ReadAt(int64_t position, int64_t nbytes, void* out) {\n    RETURN_NOT_OK(CheckClosed());\n    // ReadAt() leaves the file position undefined, so require that we seek\n    // before calling Read() or Write().\n    need_seeking_.store(true);\n    return ::arrow::internal::FileReadAt(fd_, reinterpret_cast<uint8_t*>(out), position,\n                                         nbytes);\n  }\nResult<int64_t> MemoryMappedFile::ReadAt(int64_t position, int64_t nbytes, void* out) {\n  RETURN_NOT_OK(memory_map_->CheckClosed());\n  auto guard_resize = memory_map_->writable()\n                          ? std::unique_lock<std::mutex>(memory_map_->resize_lock())\n                          : std::unique_lock<std::mutex>();\n  nbytes = std::max<int64_t>(0, std::min(nbytes, memory_map_->size() - position));\n  if (nbytes > 0) {\n    memcpy(out, memory_map_->data() + position, static_cast<size_t>(nbytes));\n  }\n  return nbytes;\n}\nStatus MemoryMappedFile::WriteAt(int64_t position, const void* data, int64_t nbytes) {\n  RETURN_NOT_OK(memory_map_->CheckClosed());\n  std::lock_guard<std::mutex> guard(memory_map_->write_lock());\n\n  if (!memory_map_->opened() || !memory_map_->writable()) {\n    return Status::IOError(\"Unable to write\");\n  }\n  if (position + nbytes > memory_map_->size()) {\n    return Status::Invalid(\"Cannot write past end of memory map\");\n  }\n\n  RETURN_NOT_OK(memory_map_->Seek(position));\n  if (nbytes + memory_map_->position() > memory_map_->size()) {\n    return Status::Invalid(\"Cannot write past end of memory map\");\n  }\n\n  return WriteInternal(data, nbytes);\n}\nStatus MemoryMappedFile::Write(const void* data, int64_t nbytes) {\n  RETURN_NOT_OK(memory_map_->CheckClosed());\n  std::lock_guard<std::mutex> guard(memory_map_->write_lock());\n\n  if (!memory_map_->opened() || !memory_map_->writable()) {\n    return Status::IOError(\"Unable to write\");\n  }\n  if (nbytes + memory_map_->position() > memory_map_->size()) {\n    return Status::Invalid(\"Cannot write past end of memory map\");\n  }\n\n  return WriteInternal(data, nbytes);\n}\n  Status Write(const void* data, int64_t nbytes) {\n    if (position_ + nbytes > size_) {\n      return Status::IOError(\"Write out of bounds\");\n    }\n    if (nbytes > memcopy_threshold_ && memcopy_num_threads_ > 1) {\n      ::arrow::internal::parallel_memcopy(mutable_data_ + position_,\n                                          reinterpret_cast<const uint8_t*>(data), nbytes,\n                                          memcopy_blocksize_, memcopy_num_threads_);\n    } else {\n      memcpy(mutable_data_ + position_, data, nbytes);\n    }\n    position_ += nbytes;\n    return Status::OK();\n  }\n  Status WriteAt(int64_t position, const void* data, int64_t nbytes) {\n    std::lock_guard<std::mutex> guard(lock_);\n    RETURN_NOT_OK(Seek(position));\n    return Write(data, nbytes);\n  }\nResult<std::shared_ptr<Buffer>> BufferReader::DoReadAt(int64_t position, int64_t nbytes) {\n  RETURN_NOT_OK(CheckClosed());\n\n  if (nbytes < 0) {\n    return Status::IOError(\"Cannot read a negative number of bytes from BufferReader.\");\n  }\n  int64_t size = std::min(nbytes, size_ - position);\n\n  if (size > 0 && buffer_ != nullptr) {\n    return SliceBuffer(buffer_, position, size);\n  } else {\n    return std::make_shared<Buffer>(data_ + position, size);\n  }\n}\nStatus FieldFromFlatbuffer(const flatbuf::Field* field, DictionaryMemo* dictionary_memo,\n                           std::shared_ptr<Field>* out) {\n  std::shared_ptr<DataType> type;\n\n  std::shared_ptr<KeyValueMetadata> metadata;\n  RETURN_NOT_OK(GetFieldMetadata(field, &metadata));\n\n  // Reconstruct the data type\n  auto children = field->children();\n  if (children == nullptr) {\n    return Status::IOError(\"Children-pointer of flatbuffer-encoded Field is null.\");\n  }\n  std::vector<std::shared_ptr<Field>> child_fields(children->size());\n  for (int i = 0; i < static_cast<int>(children->size()); ++i) {\n    RETURN_NOT_OK(\n        FieldFromFlatbuffer(children->Get(i), dictionary_memo, &child_fields[i]));\n  }\n  RETURN_NOT_OK(TypeFromFlatbuffer(field, child_fields, metadata.get(), &type));\n\n  const flatbuf::DictionaryEncoding* encoding = field->dictionary();\n\n  if (encoding != nullptr) {\n    // The field is dictionary-encoded. Construct the DictionaryType\n    // based on the DictionaryEncoding metadata and record in the\n    // dictionary_memo\n    std::shared_ptr<DataType> index_type;\n    auto int_data = encoding->indexType();\n    if (int_data == nullptr) {\n      return Status::IOError(\n          \"indexType-pointer in custom metadata of flatbuffer-encoded DictionaryEncoding \"\n          \"is null.\");\n    }\n    RETURN_NOT_OK(IntFromFlatbuffer(int_data, &index_type));\n    type = ::arrow::dictionary(index_type, type, encoding->isOrdered());\n    *out = ::arrow::field(field->name()->str(), type, field->nullable(), metadata);\n    RETURN_NOT_OK(dictionary_memo->AddField(encoding->id(), *out));\n  } else {\n    auto name = field->name();\n    if (name == nullptr) {\n      return Status::IOError(\"Name-pointer of flatbuffer-encoded Field is null.\");\n    }\n    *out = ::arrow::field(name->str(), type, field->nullable(), metadata);\n  }\n  return Status::OK();\n}\nStatus ReadRecordBatch(const std::shared_ptr<Schema>& schema,\n                       const DictionaryMemo* dictionary_memo, io::InputStream* file,\n                       std::shared_ptr<RecordBatch>* out) {\n  auto options = IpcOptions::Defaults();\n  std::unique_ptr<Message> message;\n  RETURN_NOT_OK(ReadContiguousPayload(file, &message));\n  io::BufferReader buffer_reader(message->body());\n  return ReadRecordBatch(*message->metadata(), schema, dictionary_memo, options,\n                         &buffer_reader, out);\n}\n  Status ReadDictionaries() {\n    // Read all the dictionaries\n    for (int i = 0; i < num_dictionaries(); ++i) {\n      std::unique_ptr<Message> message;\n      RETURN_NOT_OK(ReadMessageFromBlock(GetDictionaryBlock(i), &message));\n\n      io::BufferReader reader(message->body());\n      RETURN_NOT_OK(ReadDictionary(*message->metadata(), &dictionary_memo_, &reader));\n    }\n    return Status::OK();\n  }\nResult<std::shared_ptr<Tensor>> ReadTensor(const Message& message) {\n  std::shared_ptr<DataType> type;\n  std::vector<int64_t> shape;\n  std::vector<int64_t> strides;\n  std::vector<std::string> dim_names;\n  RETURN_NOT_OK(internal::GetTensorMetadata(*message.metadata(), &type, &shape, &strides,\n                                            &dim_names));\n  return Tensor::Make(type, message.body(), shape, strides, dim_names);\n}\nResult<std::shared_ptr<SparseTensor>> ReadSparseTensor(io::InputStream* file) {\n  std::unique_ptr<Message> message;\n  RETURN_NOT_OK(ReadContiguousPayload(file, &message));\n  CHECK_MESSAGE_TYPE(Message::SPARSE_TENSOR, message->type());\n  CHECK_HAS_BODY(*message);\n  io::BufferReader buffer_reader(message->body());\n  return ReadSparseTensor(*message->metadata(), &buffer_reader);\n}\nint DictionaryType::bit_width() const {\n  return checked_cast<const FixedWidthType&>(*index_type_).bit_width();\n}\nDictionaryType::DictionaryType(const std::shared_ptr<DataType>& index_type,\n                               const std::shared_ptr<DataType>& value_type, bool ordered)\n    : FixedWidthType(Type::DICTIONARY),\n      index_type_(index_type),\n      value_type_(value_type),\n      ordered_(ordered) {\n  ARROW_CHECK(is_integer(index_type->id()))\n      << \"dictionary index type should be signed integer\";\n  const auto& int_type = checked_cast<const IntegerType&>(*index_type);\n  ARROW_CHECK(int_type.is_signed()) << \"dictionary index type should be signed integer\";\n}\nDataTypeLayout DictionaryType::layout() const {\n  auto layout = index_type_->layout();\n  layout.has_dictionary = true;\n  return layout;\n}\n  std::string name() const override { return \"dictionary\"; }\n",
    "target": 1,
    "idx": 1020120,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nR_API void r_core_task_decref (RCoreTask *task) {\n\tif (!task) {\n\t\treturn;\n\t}\n\tTASK_SIGSET_T old_sigset;\n\tRCore *core = task->core;\n\ttasks_lock_enter (core, &old_sigset);\n\ttask->refcount--;\n\tif (task->refcount <= 0) {\n\t\ttask_free (task);\n\t}\n\ttasks_lock_leave (core, &old_sigset);\n}\n\nR_API void r_list_delete(RList *list, RListIter *iter) {\n\tr_return_if_fail (list && iter);\n\tr_list_split_iter (list, iter);\n\tif (list->free && iter->data) {\n\t\tlist->free (iter->data);\n\t}\n\titer->data = NULL;\n\tR_FREE (iter);\n}\n\nR_API void r_list_purge(RList *list) {\n\tRListIter *it;\n\n\tr_return_if_fail (list);\n\n\tit = list->head;\n\twhile (it) {\n\t\tRListIter *next = it->n;\n\t\tr_list_delete (list, it);\n\t\tit = next;\n\t}\n\tlist->head = list->tail = NULL;\n}\n\nR_API void r_list_free(RList *list) {\n\tif (list) {\n\t\tr_list_purge (list);\n\t\tR_FREE (list);\n\t}\n}\n\n\n\nstatic void r_core_free_autocomplete(RCore *core) {\n\tif (!core || !core->cons || !core->cons->line) {\n\t\treturn;\n\t}\n\tr_line_free_autocomplete (core->cons->line);\n}\n\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  if (SMR.IsClient())\n    SMR.WriteByteArray(Data, Size);\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (EF->__msan_unpoison)\n    EF->__msan_unpoison(DataCopy, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  {\n    ScopedEnableMsanInterceptorChecks S;\n    AllocTracer.Start(Options.TraceMalloc);\n    UnitStartTime = system_clock::now();\n    TPC.ResetMaps();\n    RunningUserCallback = true;\n    int Res = CB(DataCopy, Size);\n    RunningUserCallback = false;\n    UnitStopTime = system_clock::now();\n    (void)Res;\n    assert(Res == 0);\n    HasMoreMallocsThanFrees = AllocTracer.Stop();\n  }\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\n\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\n\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  if (EF->__msan_scoped_disable_interceptor_checks)\n    EF->__msan_scoped_disable_interceptor_checks();\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.LenControl = Flags.len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.ReduceDepth = Flags.reduce_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  Options.MallocLimitMb = Flags.malloc_limit_mb;\n  if (!Options.MallocLimitMb)\n    Options.MallocLimitMb = Options.RssLimitMb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  Options.PrintUnstableStats = Flags.print_unstable_stats;\n  if (Flags.handle_unstable == TracePC::MinUnstable ||\n      Flags.handle_unstable == TracePC::ZeroUnstable)\n    Options.HandleUnstable = Flags.handle_unstable;\n  Options.DumpCoverage = Flags.dump_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n  if (Flags.focus_function)\n    Options.FocusFunction = Flags.focus_function;\n  if (Flags.data_flow_trace)\n    Options.DataFlowTrace = Flags.data_flow_trace;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n#if 0  // deprecated, to be removed.\n  if (auto Name = Flags.run_equivalence_server) {\n    SMR.Destroy(Name);\n    if (!SMR.Create(Name)) {\n       Printf(\"ERROR: can't create shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE SERVER UP\\n\");\n    while (true) {\n      SMR.WaitClient();\n      size_t Size = SMR.ReadByteArraySize();\n      SMR.WriteByteArray(nullptr, 0);\n      const Unit tmp(SMR.GetByteArray(), SMR.GetByteArray() + Size);\n      F->ExecuteCallback(tmp.data(), tmp.size());\n      SMR.PostServer();\n    }\n    return 0;\n  }\n\n  if (auto Name = Flags.use_equivalence_server) {\n    if (!SMR.Open(Name)) {\n      Printf(\"ERROR: can't open shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE CLIENT UP\\n\");\n  }\n#endif\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.merge) {\n    F->CrashResistantMerge(Args, *Inputs,\n                           Flags.load_coverage_summary,\n                           Flags.save_coverage_summary,\n                           Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis succeeded\\n\");\n    exit(0);\n  }\n\n  F->Loop(*Inputs);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\n\n__attribute__((visibility(\"default\"))) int main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}\n\n\n// target function\nR_API void r_core_task_decref (RCoreTask *task) {\n\tif (!task) {\n\t\treturn;\n\t}\n\tTASK_SIGSET_T old_sigset;\n\ttasks_lock_enter (task->core, &old_sigset);\n\ttask->refcount--;\n\tif (task->refcount <= 0) {\n\t\ttask_free (task);\n\t}\n\ttasks_lock_leave (task->core, &old_sigset);\n}\n",
    "target": 1,
    "idx": 1011359,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid CMSEXPORT cmsFreeNamedColorList(cmsNAMEDCOLORLIST* v)\n{\n    if (v == NULL) return;\n    if (v ->List) _cmsFree(v ->ContextID, v ->List);\n    _cmsFree(v ->ContextID, v);\n}\n\nstatic\nvoid Type_NamedColor_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid freeOneTag(_cmsICCPROFILE* Icc, cmsUInt32Number i)\n{\n    if (Icc->TagPtrs[i]) {\n\n        cmsTagTypeHandler* TypeHandler = Icc->TagTypeHandlers[i];\n\n        if (TypeHandler != NULL) {\n            cmsTagTypeHandler LocalTypeHandler = *TypeHandler;\n\n            LocalTypeHandler.ContextID = Icc->ContextID;             \n            LocalTypeHandler.ICCVersion = Icc->Version;\n            LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc->TagPtrs[i]);\n        }\n        else\n            _cmsFree(Icc->ContextID, Icc->TagPtrs[i]);\n    }\n}\n\ncmsBool  CMSEXPORT cmsCloseProfile(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    cmsBool  rc = TRUE;\n    cmsUInt32Number i;\n\n    if (!Icc) return FALSE;\n\n    // Was open in write mode?\n    if (Icc ->IsWrite) {\n\n        Icc ->IsWrite = FALSE;      // Assure no further writing\n        rc &= cmsSaveProfileToFile(hProfile, Icc ->IOhandler->PhysicalFile);\n    }\n\n    for (i=0; i < Icc -> TagCount; i++) {\n\n        freeOneTag(Icc, i);        \n    }\n\n    if (Icc ->IOhandler != NULL) {\n        rc &= cmsCloseIOhandler(Icc->IOhandler);\n    }\n\n    _cmsDestroyMutex(Icc->ContextID, Icc->UsrMutex);\n\n    _cmsFree(Icc ->ContextID, Icc);   // Free placeholder memory\n\n    return rc;\n}\n\nvoid\nrun_test(const uint8_t *data,\n         size_t size,\n         uint32_t intent_id,\n         uint32_t input_format,\n         uint32_t output_format,\n         uint32_t flags) {\n if (size < 2) {\n   return;\n }\n\n size_t mid = size / 2;\n\n cmsHPROFILE hInProfile, hOutProfile;\n cmsHTRANSFORM hTransform;\n\n hInProfile = cmsOpenProfileFromMem(data, mid);\n hOutProfile = cmsOpenProfileFromMem(data + mid, size - mid);\n hTransform = cmsCreateTransform(hInProfile, input_format, hOutProfile,\n                                 output_format, intent_id, flags);\n cmsCloseProfile(hInProfile);\n cmsCloseProfile(hOutProfile);\n\n if (hTransform) {\n   cmsDeleteTransform(hTransform);\n }\n}\n\n\n// target function\ncmsHPROFILE CMSEXPORT cmsCreateProfilePlaceholder(cmsContext ContextID)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) _cmsMallocZero(ContextID, sizeof(_cmsICCPROFILE));\n    if (Icc == NULL) return NULL;\n\n    Icc ->ContextID = ContextID;\n\n    // Set it to empty\n    Icc -> TagCount   = 0;\n\n    // Set default version\n    Icc ->Version =  0x02100000;\n    \n    // Set creation date/time\n    if (!_cmsGetTime(&Icc->Created))\n        goto Error;\n\n    // Create a mutex if the user provided proper plugin. NULL otherwise\n    Icc ->UsrMutex = _cmsCreateMutex(ContextID);\n\n    // Return the handle\n    return (cmsHPROFILE) Icc;\n\nError:\n    _cmsFree(ContextID, Icc);\n    return NULL;\n}\ncmsBool _cmsReadHeader(_cmsICCPROFILE* Icc)\n{\n    cmsTagEntry Tag;\n    cmsICCHeader Header;\n    cmsUInt32Number i, j;\n    cmsUInt32Number HeaderSize;\n    cmsIOHANDLER* io = Icc ->IOhandler;\n    cmsUInt32Number TagCount;\n\n\n    // Read the header\n    if (io -> Read(io, &Header, sizeof(cmsICCHeader), 1) != 1) {\n        return FALSE;\n    }\n\n    // Validate file as an ICC profile\n    if (_cmsAdjustEndianess32(Header.magic) != cmsMagicNumber) {\n        cmsSignalError(Icc ->ContextID, cmsERROR_BAD_SIGNATURE, \"not an ICC profile, invalid signature\");\n        return FALSE;\n    }\n\n    // Adjust endianness of the used parameters\n    Icc -> DeviceClass     = (cmsProfileClassSignature) _cmsAdjustEndianess32(Header.deviceClass);\n    Icc -> ColorSpace      = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.colorSpace);\n    Icc -> PCS             = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.pcs);\n   \n    Icc -> RenderingIntent = _cmsAdjustEndianess32(Header.renderingIntent);\n    Icc -> flags           = _cmsAdjustEndianess32(Header.flags);\n    Icc -> manufacturer    = _cmsAdjustEndianess32(Header.manufacturer);\n    Icc -> model           = _cmsAdjustEndianess32(Header.model);\n    Icc -> creator         = _cmsAdjustEndianess32(Header.creator);\n    \n    _cmsAdjustEndianess64(&Icc -> attributes, &Header.attributes);\n    Icc -> Version         = _cmsAdjustEndianess32(_validatedVersion(Header.version));\n\n    // Get size as reported in header\n    HeaderSize = _cmsAdjustEndianess32(Header.size);\n\n    // Make sure HeaderSize is lower than profile size\n    if (HeaderSize >= Icc ->IOhandler ->ReportedSize)\n            HeaderSize = Icc ->IOhandler ->ReportedSize;\n\n\n    // Get creation date/time\n    _cmsDecodeDateTimeNumber(&Header.date, &Icc ->Created);\n\n    // The profile ID are 32 raw bytes\n    memmove(Icc ->ProfileID.ID32, Header.profileID.ID32, 16);\n\n\n    // Read tag directory\n    if (!_cmsReadUInt32Number(io, &TagCount)) return FALSE;\n    if (TagCount > MAX_TABLE_TAG) {\n\n        cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, \"Too many tags (%d)\", TagCount);\n        return FALSE;\n    }\n\n\n    // Read tag directory\n    Icc -> TagCount = 0;\n    for (i=0; i < TagCount; i++) {\n\n        if (!_cmsReadUInt32Number(io, (cmsUInt32Number *) &Tag.sig)) return FALSE;\n        if (!_cmsReadUInt32Number(io, &Tag.offset)) return FALSE;\n        if (!_cmsReadUInt32Number(io, &Tag.size)) return FALSE;\n\n        // Perform some sanity check. Offset + size should fall inside file.\n        if (Tag.size == 0 || Tag.offset == 0) continue;\n        if (Tag.offset + Tag.size > HeaderSize ||\n            Tag.offset + Tag.size < Tag.offset)\n                  continue;\n\n        Icc -> TagNames[Icc ->TagCount]   = Tag.sig;\n        Icc -> TagOffsets[Icc ->TagCount] = Tag.offset;\n        Icc -> TagSizes[Icc ->TagCount]   = Tag.size;\n\n       // Search for links\n        for (j=0; j < Icc ->TagCount; j++) {\n           \n            if ((Icc ->TagOffsets[j] == Tag.offset) &&\n                (Icc ->TagSizes[j]   == Tag.size)) {\n\n                // Check types. \n                if (CompatibleTypes(_cmsGetTagDescriptor(Icc->ContextID, Icc->TagNames[j]),\n                                    _cmsGetTagDescriptor(Icc->ContextID, Tag.sig))) {\n\n                    Icc->TagLinked[Icc->TagCount] = Icc->TagNames[j];\n                }\n            }\n\n        }\n\n        Icc ->TagCount++;\n    }\n\n\n    for (i = 0; i < Icc->TagCount; i++) {\n        for (j = 0; j < Icc->TagCount; j++) {\n\n            // Tags cannot be duplicate\n            if ((i != j) && (Icc->TagNames[i] == Icc->TagNames[j])) {\n                cmsSignalError(Icc->ContextID, cmsERROR_RANGE, \"Duplicate tag found\");\n                return FALSE;\n            }\n\n        }\n    }\n\n    return TRUE;\n}\ncmsHPROFILE CMSEXPORT cmsCreateRGBProfileTHR(cmsContext ContextID,\n                                          const cmsCIExyY* WhitePoint,\n                                          const cmsCIExyYTRIPLE* Primaries,\n                                          cmsToneCurve* const TransferFunction[3])\n{\n    cmsHPROFILE hICC;\n    cmsMAT3 MColorants;\n    cmsCIEXYZTRIPLE Colorants;\n    cmsCIExyY MaxWhite;\n    cmsMAT3 CHAD;\n    cmsCIEXYZ WhitePointXYZ;\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.3);\n\n    cmsSetDeviceClass(hICC,      cmsSigDisplayClass);\n    cmsSetColorSpace(hICC,       cmsSigRgbData);\n    cmsSetPCS(hICC,              cmsSigXYZData);\n\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n\n    // Implement profile using following tags:\n    //\n    //  1 cmsSigProfileDescriptionTag\n    //  2 cmsSigMediaWhitePointTag\n    //  3 cmsSigRedColorantTag\n    //  4 cmsSigGreenColorantTag\n    //  5 cmsSigBlueColorantTag\n    //  6 cmsSigRedTRCTag\n    //  7 cmsSigGreenTRCTag\n    //  8 cmsSigBlueTRCTag\n    //  9 Chromatic adaptation Tag\n    // This conforms a standard RGB DisplayProfile as says ICC, and then I add (As per addendum II)\n    // 10 cmsSigChromaticityTag\n\n\n    if (!SetTextTags(hICC, L\"RGB built-in\")) goto Error;\n\n    if (WhitePoint) {\n\n        if (!cmsWriteTag(hICC, cmsSigMediaWhitePointTag, cmsD50_XYZ())) goto Error;\n\n        cmsxyY2XYZ(&WhitePointXYZ, WhitePoint);\n        _cmsAdaptationMatrix(&CHAD, NULL, &WhitePointXYZ, cmsD50_XYZ());\n\n        // This is a V4 tag, but many CMM does read and understand it no matter which version\n        if (!cmsWriteTag(hICC, cmsSigChromaticAdaptationTag, (void*) &CHAD)) goto Error;\n    }\n\n    if (WhitePoint && Primaries) {\n\n        MaxWhite.x =  WhitePoint -> x;\n        MaxWhite.y =  WhitePoint -> y;\n        MaxWhite.Y =  1.0;\n\n        if (!_cmsBuildRGB2XYZtransferMatrix(&MColorants, &MaxWhite, Primaries)) goto Error;\n\n        Colorants.Red.X   = MColorants.v[0].n[0];\n        Colorants.Red.Y   = MColorants.v[1].n[0];\n        Colorants.Red.Z   = MColorants.v[2].n[0];\n\n        Colorants.Green.X = MColorants.v[0].n[1];\n        Colorants.Green.Y = MColorants.v[1].n[1];\n        Colorants.Green.Z = MColorants.v[2].n[1];\n\n        Colorants.Blue.X  = MColorants.v[0].n[2];\n        Colorants.Blue.Y  = MColorants.v[1].n[2];\n        Colorants.Blue.Z  = MColorants.v[2].n[2];\n\n        if (!cmsWriteTag(hICC, cmsSigRedColorantTag,   (void*) &Colorants.Red)) goto Error;\n        if (!cmsWriteTag(hICC, cmsSigBlueColorantTag,  (void*) &Colorants.Blue)) goto Error;\n        if (!cmsWriteTag(hICC, cmsSigGreenColorantTag, (void*) &Colorants.Green)) goto Error;\n    }\n\n\n    if (TransferFunction) {\n\n        // Tries to minimize space. Thanks to Richard Hughes for this nice idea         \n        if (!cmsWriteTag(hICC, cmsSigRedTRCTag,   (void*) TransferFunction[0])) goto Error;\n\n        if (TransferFunction[1] == TransferFunction[0]) {\n\n            if (!cmsLinkTag (hICC, cmsSigGreenTRCTag, cmsSigRedTRCTag)) goto Error;\n\n        } else {\n\n            if (!cmsWriteTag(hICC, cmsSigGreenTRCTag, (void*) TransferFunction[1])) goto Error;\n        }\n\n        if (TransferFunction[2] == TransferFunction[0]) {\n\n            if (!cmsLinkTag (hICC, cmsSigBlueTRCTag, cmsSigRedTRCTag)) goto Error;\n\n        } else {\n\n            if (!cmsWriteTag(hICC, cmsSigBlueTRCTag, (void*) TransferFunction[2])) goto Error;\n        }\n    }\n\n    if (Primaries) {\n        if (!cmsWriteTag(hICC, cmsSigChromaticityTag, (void*) Primaries)) goto Error;\n    }\n\n\n    return hICC;\n\nError:\n    if (hICC)\n        cmsCloseProfile(hICC);\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateGrayProfileTHR(cmsContext ContextID,\n                                           const cmsCIExyY* WhitePoint,\n                                           const cmsToneCurve* TransferFunction)\n{\n    cmsHPROFILE hICC;\n    cmsCIEXYZ tmp;\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.3);\n\n    cmsSetDeviceClass(hICC,      cmsSigDisplayClass);\n    cmsSetColorSpace(hICC,       cmsSigGrayData);\n    cmsSetPCS(hICC,              cmsSigXYZData);\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n\n    // Implement profile using following tags:\n    //\n    //  1 cmsSigProfileDescriptionTag\n    //  2 cmsSigMediaWhitePointTag\n    //  3 cmsSigGrayTRCTag\n\n    // This conforms a standard Gray DisplayProfile\n\n    // Fill-in the tags\n\n    if (!SetTextTags(hICC, L\"gray built-in\")) goto Error;\n\n\n    if (WhitePoint) {\n\n        cmsxyY2XYZ(&tmp, WhitePoint);\n        if (!cmsWriteTag(hICC, cmsSigMediaWhitePointTag, (void*) &tmp)) goto Error;\n    }\n\n    if (TransferFunction) {\n\n        if (!cmsWriteTag(hICC, cmsSigGrayTRCTag, (void*) TransferFunction)) goto Error;\n    }\n\n    return hICC;\n\nError:\n    if (hICC)\n        cmsCloseProfile(hICC);\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateLinearizationDeviceLinkTHR(cmsContext ContextID,\n                                                          cmsColorSpaceSignature ColorSpace,\n                                                          cmsToneCurve* const TransferFunctions[])\n{\n    cmsHPROFILE hICC;\n    cmsPipeline* Pipeline;\n    cmsUInt32Number nChannels;\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.3);\n\n    cmsSetDeviceClass(hICC,      cmsSigLinkClass);\n    cmsSetColorSpace(hICC,       ColorSpace);\n    cmsSetPCS(hICC,              ColorSpace);\n\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n    // Set up channels\n    nChannels = cmsChannelsOf(ColorSpace);\n\n    // Creates a Pipeline with prelinearization step only\n    Pipeline = cmsPipelineAlloc(ContextID, nChannels, nChannels);\n    if (Pipeline == NULL) goto Error;\n\n\n    // Copy tables to Pipeline\n    if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, cmsStageAllocToneCurves(ContextID, nChannels, TransferFunctions)))\n        goto Error;\n\n    // Create tags\n    if (!SetTextTags(hICC, L\"Linearization built-in\")) goto Error;\n    if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline)) goto Error;\n    if (!SetSeqDescTag(hICC, \"Linearization built-in\")) goto Error;\n\n    // Pipeline is already on virtual profile\n    cmsPipelineFree(Pipeline);\n\n    // Ok, done\n    return hICC;\n\nError:\n    cmsPipelineFree(Pipeline);\n    if (hICC)\n        cmsCloseProfile(hICC);\n\n\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateInkLimitingDeviceLinkTHR(cmsContext ContextID,\n                                                     cmsColorSpaceSignature ColorSpace,\n                                                     cmsFloat64Number Limit)\n{\n    cmsHPROFILE hICC;\n    cmsPipeline* LUT;\n    cmsStage* CLUT;\n    cmsUInt32Number nChannels;\n\n    if (ColorSpace != cmsSigCmykData) {\n        cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, \"InkLimiting: Only CMYK currently supported\");\n        return NULL;\n    }\n\n    if (Limit < 0.0 || Limit > 400) {\n\n        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 0..400\");\n        if (Limit < 0) Limit = 0;\n        if (Limit > 400) Limit = 400;\n\n    }\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.3);\n\n    cmsSetDeviceClass(hICC,      cmsSigLinkClass);\n    cmsSetColorSpace(hICC,       ColorSpace);\n    cmsSetPCS(hICC,              ColorSpace);\n\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n\n    // Creates a Pipeline with 3D grid only\n    LUT = cmsPipelineAlloc(ContextID, 4, 4);\n    if (LUT == NULL) goto Error;\n\n\n    nChannels = cmsChannelsOf(ColorSpace);\n\n    CLUT = cmsStageAllocCLut16bit(ContextID, 17, nChannels, nChannels, NULL);\n    if (CLUT == NULL) goto Error;\n\n    if (!cmsStageSampleCLut16bit(CLUT, InkLimitingSampler, (void*) &Limit, 0)) goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, nChannels)) ||\n        !cmsPipelineInsertStage(LUT, cmsAT_END, CLUT) ||\n        !cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, nChannels)))\n        goto Error;\n\n    // Create tags\n    if (!SetTextTags(hICC, L\"ink-limiting built-in\")) goto Error;\n\n    if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) LUT))  goto Error;\n    if (!SetSeqDescTag(hICC, \"ink-limiting built-in\")) goto Error;\n\n    // cmsPipeline is already on virtual profile\n    cmsPipelineFree(LUT);\n\n    // Ok, done\n    return hICC;\n\nError:\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hICC != NULL)\n        cmsCloseProfile(hICC);\n\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateLab4ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n\n    hProfile = cmsCreateRGBProfileTHR(ContextID, WhitePoint == NULL ? cmsD50_xyY() : WhitePoint, NULL, NULL);\n    if (hProfile == NULL) return NULL;\n\n    cmsSetProfileVersion(hProfile, 4.3);\n\n    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);\n    cmsSetColorSpace(hProfile,  cmsSigLabData);\n    cmsSetPCS(hProfile,         cmsSigLabData);\n\n    if (!SetTextTags(hProfile, L\"Lab identity built-in\")) goto Error;\n\n    // An empty LUTs is all we need\n    LUT = cmsPipelineAlloc(ContextID, 3, 3);\n    if (LUT == NULL) goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))\n        goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;\n    cmsPipelineFree(LUT);\n\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateXYZProfileTHR(cmsContext ContextID)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n\n    hProfile = cmsCreateRGBProfileTHR(ContextID, cmsD50_xyY(), NULL, NULL);\n    if (hProfile == NULL) return NULL;\n\n    cmsSetProfileVersion(hProfile, 4.3);\n\n    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);\n    cmsSetColorSpace(hProfile,  cmsSigXYZData);\n    cmsSetPCS(hProfile,         cmsSigXYZData);\n\n    if (!SetTextTags(hProfile, L\"XYZ identity built-in\")) goto Error;\n\n    // An identity LUT is all we need\n    LUT = cmsPipelineAlloc(ContextID, 3, 3);\n    if (LUT == NULL) goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))\n        goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;\n    cmsPipelineFree(LUT);\n\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateNULLProfileTHR(cmsContext ContextID)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n    cmsStage* PostLin;\n    cmsStage* OutLin;\n    cmsToneCurve* EmptyTab[3];\n    cmsUInt16Number Zero[2] = { 0, 0 };\n    const cmsFloat64Number PickLstarMatrix[] = { 1, 0, 0 };\n\n    hProfile = cmsCreateProfilePlaceholder(ContextID);\n    if (!hProfile)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hProfile, 4.3);\n\n    if (!SetTextTags(hProfile, L\"NULL profile built-in\")) goto Error;\n\n\n    cmsSetDeviceClass(hProfile, cmsSigOutputClass);\n    cmsSetColorSpace(hProfile,  cmsSigGrayData);\n    cmsSetPCS(hProfile,         cmsSigLabData);\n\n    // Create a valid ICC 4 structure\n    LUT = cmsPipelineAlloc(ContextID, 3, 1);\n    if (LUT == NULL) goto Error;\n    \n    EmptyTab[0] = EmptyTab[1] = EmptyTab[2] = cmsBuildTabulatedToneCurve16(ContextID, 2, Zero);\n    PostLin = cmsStageAllocToneCurves(ContextID, 3, EmptyTab);\n    OutLin  = cmsStageAllocToneCurves(ContextID, 1, EmptyTab);\n    cmsFreeToneCurve(EmptyTab[0]);\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_END, PostLin))\n        goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_END, cmsStageAllocMatrix(ContextID, 1, 3, PickLstarMatrix, NULL)))\n        goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_END, OutLin))\n        goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, (void*) LUT)) goto Error;\n    if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, cmsD50_XYZ())) goto Error;\n\n    cmsPipelineFree(LUT);\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}\n",
    "target": 1,
    "idx": 1049546,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid timelib_error_container_dtor(timelib_error_container *errors)\n{\n\tint i;\n\n\tfor (i = 0; i < errors->warning_count; i++) {\n\t\ttimelib_free(errors->warning_messages[i].message);\n\t}\n\ttimelib_free(errors->warning_messages);\n\tfor (i = 0; i < errors->error_count; i++) {\n\t\ttimelib_free(errors->error_messages[i].message);\n\t}\n\ttimelib_free(errors->error_messages);\n\ttimelib_free(errors);\n}\n\n\n\nZEND_API void zend_post_deactivate_modules(void) /* {{{ */\n{\n\tif (EG(full_tables_cleanup)) {\n\t\tzend_module_entry *module;\n\t\tzval *zv;\n\t\tzend_string *key;\n\n\t\tZEND_HASH_MAP_FOREACH_PTR(&module_registry, module) {\n\t\t\tif (module->post_deactivate_func) {\n\t\t\t\tmodule->post_deactivate_func();\n\t\t\t}\n\t\t} ZEND_HASH_FOREACH_END();\n\t\tZEND_HASH_MAP_REVERSE_FOREACH_STR_KEY_VAL(&module_registry, key, zv) {\n\t\t\tmodule = Z_PTR_P(zv);\n\t\t\tif (module->type != MODULE_TEMPORARY) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmodule_destructor(module);\n\t\t\tzend_string_release_ex(key, 0);\n\t\t} ZEND_HASH_MAP_FOREACH_END_DEL();\n\t} else {\n\t\tzend_module_entry **p = module_post_deactivate_handlers;\n\n\t\twhile (*p) {\n\t\t\tzend_module_entry *module = *p;\n\n\t\t\tmodule->post_deactivate_func();\n\t\t\tp++;\n\t\t}\n\t}\n}\n\nvoid php_request_shutdown(void *dummy)\n{\n\tbool report_memleaks;\n\n\tEG(flags) |= EG_FLAGS_IN_SHUTDOWN;\n\n\treport_memleaks = PG(report_memleaks);\n\n\t/* EG(current_execute_data) points into nirvana and therefore cannot be safely accessed\n\t * inside zend_executor callback functions.\n\t */\n\tEG(current_execute_data) = NULL;\n\n\tphp_deactivate_ticks();\n\n\t/* 0. Call any open observer end handlers that are still open after a zend_bailout */\n\tif (ZEND_OBSERVER_ENABLED) {\n\t\tzend_observer_fcall_end_all();\n\t}\n\n\t/* 1. Call all possible shutdown functions registered with register_shutdown_function() */\n\tif (PG(modules_activated)) {\n\t\tphp_call_shutdown_functions();\n\t}\n\n\t/* 2. Call all possible __destruct() functions */\n\tzend_try {\n\t\tzend_call_destructors();\n\t} zend_end_try();\n\nvoid fuzzer_request_shutdown()\n{\n\tzend_try {\n\t\t/* Destroy thrown exceptions. This does not happen as part of request shutdown. */\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\n\t\t/* Some fuzzers (like unserialize) may create circular structures. Make sure we free them.\n\t\t * Two calls are performed to handle objects with destructors. */\n\t\tzend_gc_collect_cycles();\n\t\tzend_gc_collect_cycles();\n\t} zend_end_try();\n\n\tphp_request_shutdown(NULL);\n}\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, bool execute,\n\t\tvoid (*before_shutdown)(void))\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.primary_script = 1;\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\t\t/* Avoid ZEND_HANDLE_FILENAME for opcache. */\n\t\tfile_handle.type = ZEND_HANDLE_STREAM;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tzend_destroy_file_handle(&file_handle);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tzend_destroy_static_vars(op_array);\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\tCG(compiled_filename) = NULL; /* ??? */\n\tif (before_shutdown) {\n\t\tbefore_shutdown();\n\t}\n\tfuzzer_request_shutdown();\n\n\treturn (retval == SUCCESS) ? SUCCESS : FAILURE;\n}\n\n\n// target function\nstatic void update_errors_warnings(timelib_error_container **last_errors) /* {{{ */\n{\n\tif (DATEG(last_errors)) {\n\t\ttimelib_error_container_dtor(DATEG(last_errors));\n\t\tDATEG(last_errors) = NULL;\n\t}\n\n\tif (last_errors == NULL || (*last_errors) == NULL) {\n\t\treturn;\n\t}\n\n\tif ((*last_errors)->warning_count || (*last_errors)->error_count) {\n\t\tDATEG(last_errors) = *last_errors;\n\t}\n\n\ttimelib_error_container_dtor(*last_errors);\n\t*last_errors = NULL;\n} /* }}} */\n",
    "target": 1,
    "idx": 1051169,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nMRB_API void\nmrb_gc_mark(mrb_state *mrb, struct RBasic *obj)\n{\n  if (obj == 0) return;\n  if (!is_white(obj)) return;\n  if (is_red(obj)) return;\n  mrb_assert((obj)->tt != MRB_TT_FREE);\n  add_gray_list(mrb, &mrb->gc, obj);\n}\n\nstatic int\niv_mark_i(mrb_state *mrb, mrb_sym sym, mrb_value v, void *p)\n{\n  mrb_gc_mark_value(mrb, v);\n  return 0;\n}\n\nstatic void\niv_foreach(mrb_state *mrb, iv_tbl *t, mrb_iv_foreach_func *func, void *p)\n{\n  int i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  mrb_value *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    if (IV_KEY_P(keys[i])) {\n      if ((*func)(mrb, keys[i], vals[i], p) != 0) {\n        return;\n      }\n    }\n  }\n  return;\n}\n\nstatic void\nmark_tbl(mrb_state *mrb, iv_tbl *t)\n{\n  iv_foreach(mrb, t, iv_mark_i, 0);\n}\n\nvoid\nmrb_gc_mark_iv(mrb_state *mrb, struct RObject *obj)\n{\n  mark_tbl(mrb, obj->iv);\n}\n\nstatic void\ngc_mark_children(mrb_state *mrb, mrb_gc *gc, struct RBasic *obj)\n{\n  mrb_assert(is_gray(obj));\n  paint_black(obj);\n  mrb_gc_mark(mrb, (struct RBasic*)obj->c);\n  switch (obj->tt) {\n  case MRB_TT_ICLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n      if (MRB_FLAG_TEST(c, MRB_FL_CLASS_IS_ORIGIN))\n        mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RClass*)obj)->super);\n    }\n    break;\n\n  case MRB_TT_CLASS:\n  case MRB_TT_MODULE:\n  case MRB_TT_SCLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n\n      mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)c->super);\n    }\n    /* fall through */\n\n  case MRB_TT_OBJECT:\n  case MRB_TT_CDATA:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    break;\n\n  case MRB_TT_PROC:\n    {\n      struct RProc *p = (struct RProc*)obj;\n\n      mrb_gc_mark(mrb, (struct RBasic*)p->upper);\n      mrb_gc_mark(mrb, (struct RBasic*)p->e.env);\n    }\n    break;\n\n  case MRB_TT_ENV:\n    {\n      struct REnv *e = (struct REnv*)obj;\n      mrb_int i, len;\n\n      if (MRB_ENV_ONSTACK_P(e) && e->cxt && e->cxt->fib) {\n        mrb_gc_mark(mrb, (struct RBasic*)e->cxt->fib);\n      }\n      len = MRB_ENV_LEN(e);\n      for (i=0; i<len; i++) {\n        mrb_gc_mark_value(mrb, e->stack[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_FIBER:\n    {\n      struct mrb_context *c = ((struct RFiber*)obj)->cxt;\n\n      if (c) mark_context(mrb, c);\n    }\n    break;\n\n  case MRB_TT_STRUCT:\n  case MRB_TT_ARRAY:\n    {\n      struct RArray *a = (struct RArray*)obj;\n      size_t e=ARY_LEN(a);\n      mrb_value *p = ARY_PTR(a);\n\n      for (size_t i=0; i<e; i++) {\n        mrb_gc_mark_value(mrb, p[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_HASH:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    mrb_gc_mark_hash(mrb, (struct RHash*)obj);\n    break;\n\n  case MRB_TT_STRING:\n    if (RSTR_FSHARED_P(obj)) {\n      struct RString *s = (struct RString*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)s->as.heap.aux.fshared);\n    }\n    break;\n\n  case MRB_TT_RANGE:\n    mrb_gc_mark_range(mrb, (struct RRange*)obj);\n    break;\n\n  case MRB_TT_BREAK:\n    {\n      struct RBreak *brk = (struct RBreak*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)mrb_break_proc_get(brk));\n      mrb_gc_mark_value(mrb, mrb_break_value_get(brk));\n    }\n    break;\n\n  case MRB_TT_EXCEPTION:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    if (((struct RException*)obj)->mesg) {\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->mesg);\n    }\n    mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->backtrace);\n    break;\n\n  default:\n    break;\n  }\n}\n\nstatic size_t\nincremental_marking_phase(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  size_t tried_marks = 0;\n\n  while (gc->gray_list && tried_marks < limit) {\n    struct RBasic *obj = gc->gray_list;\n    gc->gray_list = obj->gcnext;\n    obj->gcnext = NULL;\n    gc_mark_children(mrb, gc, obj);\n    tried_marks += gc_gray_counts(mrb, gc, obj);\n  }\n\n  return tried_marks;\n}\n\nstatic size_t\nincremental_gc(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  switch (gc->state) {\n  case MRB_GC_STATE_ROOT:\n    root_scan_phase(mrb, gc);\n    gc->state = MRB_GC_STATE_MARK;\n    flip_white_part(gc);\n    return 0;\n  case MRB_GC_STATE_MARK:\n    if (gc->gray_list) {\n      return incremental_marking_phase(mrb, gc, limit);\n    }\n    else {\n      final_marking_phase(mrb, gc);\n      prepare_incremental_sweep(mrb, gc);\n      return 0;\n    }\n  case MRB_GC_STATE_SWEEP: {\n     size_t tried_sweep = 0;\n     tried_sweep = incremental_sweep_phase(mrb, gc, limit);\n     if (tried_sweep == 0)\n       gc->state = MRB_GC_STATE_ROOT;\n     return tried_sweep;\n  }\n  default:\n    /* unknown state */\n    mrb_assert(0);\n    return 0;\n  }\n}\n\nstatic void\nincremental_gc_finish(mrb_state *mrb, mrb_gc *gc)\n{\n  do {\n    incremental_gc(mrb, gc, SIZE_MAX);\n  } while (gc->state != MRB_GC_STATE_ROOT);\n}\n\nMRB_API void\nmrb_full_gc(mrb_state *mrb)\n{\n  mrb_gc *gc = &mrb->gc;\n\n  if (!mrb->c) return;\n  if (gc->disabled || gc->iterating) return;\n\n  if (is_generational(gc)) {\n    /* clear all the old objects back to young */\n    clear_all_old(mrb, gc);\n    gc->full = TRUE;\n  }\n  else if (gc->state != MRB_GC_STATE_ROOT) {\n    /* finish half baked GC cycle */\n    incremental_gc_finish(mrb, gc);\n  }\n\n  incremental_gc_finish(mrb, gc);\n  gc->threshold = (gc->live_after_mark/100) * gc->interval_ratio;\n\n  if (is_generational(gc)) {\n    gc->majorgc_old_threshold = gc->live_after_mark/100 * MAJOR_GC_INC_RATIO;\n    gc->full = FALSE;\n  }\n\n#ifdef MRB_USE_MALLOC_TRIM\n  malloc_trim(0);\n#endif\n}\n\nvoid\nmrb_objspace_each_objects(mrb_state *mrb, mrb_each_object_callback *callback, void *data)\n{\n  mrb_bool iterating = mrb->gc.iterating;\n\n  mrb_full_gc(mrb);\n  mrb->gc.iterating = TRUE;\n  if (iterating) {\n    gc_each_objects(mrb, &mrb->gc, callback, data);\n  }\n  else {\n    struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n    struct mrb_jmpbuf c_jmp;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      gc_each_objects(mrb, &mrb->gc, callback, data);\n      mrb->jmp = prev_jmp;\n      mrb->gc.iterating = iterating;\n    } MRB_CATCH(&c_jmp) {\n      mrb->gc.iterating = iterating;\n      mrb->jmp = prev_jmp;\n      MRB_THROW(prev_jmp);\n    } MRB_END_EXC(&c_jmp);\n  }\n}\n\nstatic mrb_value\nos_count_objects(mrb_state *mrb, mrb_value self)\n{\n  struct os_count_struct obj_count = { 0 };\n  mrb_int i;\n  mrb_value hash;\n\n  if (mrb_get_args(mrb, \"|H\", &hash) == 0) {\n    hash = mrb_hash_new(mrb);\n  }\n\n  if (!mrb_hash_empty_p(mrb, hash)) {\n    mrb_hash_clear(mrb, hash);\n  }\n\n  mrb_objspace_each_objects(mrb, os_count_object_type, &obj_count);\n\n  mrb_hash_set(mrb, hash, mrb_symbol_value(MRB_SYM(TOTAL)), mrb_fixnum_value(obj_count.total));\n  mrb_hash_set(mrb, hash, mrb_symbol_value(MRB_SYM(FREE)), mrb_fixnum_value(obj_count.freed));\n\n  for (i = MRB_TT_FALSE; i < MRB_TT_MAXDEFINE; i++) {\n    mrb_value type;\n    switch (i) {\n#define COUNT_TYPE(t) case (MRB_T ## t): type = mrb_symbol_value(MRB_SYM(t)); break;\n      COUNT_TYPE(T_INTEGER);\n      COUNT_TYPE(T_FLOAT);\n      COUNT_TYPE(T_CPTR);\n      COUNT_TYPE(T_OBJECT);\n      COUNT_TYPE(T_CLASS);\n      COUNT_TYPE(T_MODULE);\n      COUNT_TYPE(T_ICLASS);\n      COUNT_TYPE(T_SCLASS);\n      COUNT_TYPE(T_PROC);\n      COUNT_TYPE(T_ARRAY);\n      COUNT_TYPE(T_HASH);\n      COUNT_TYPE(T_STRING);\n      COUNT_TYPE(T_RANGE);\n      COUNT_TYPE(T_EXCEPTION);\n      COUNT_TYPE(T_ENV);\n      COUNT_TYPE(T_DATA);\n      COUNT_TYPE(T_FIBER);\n      COUNT_TYPE(T_STRUCT);\n      COUNT_TYPE(T_ISTRUCT);\n      COUNT_TYPE(T_BREAK);\n      COUNT_TYPE(T_COMPLEX);\n      COUNT_TYPE(T_RATIONAL);\n      COUNT_TYPE(T_BIGINT);\n#undef COUNT_TYPE\n    default:\n      type = mrb_fixnum_value(i); break;\n    }\n    if (obj_count.counts[i])\n      mrb_hash_set(mrb, hash, type, mrb_fixnum_value(obj_count.counts[i]));\n  }\n\n  return hash;\n}\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  else {\n    struct REnv *e = CI_ENV(mrb->c->ci);\n    if (stack_keep == 0 || (e && irep->nlocals < MRB_ENV_LEN(e))) {\n      ci_env_set(mrb->c->ci, NULL);\n      mrb_env_unshare(mrb, e, FALSE);\n    }\n  }\n  stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nMRB_API mrb_value\nmrb_top_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  if (mrb->c->cibase && mrb->c->ci > mrb->c->cibase) {\n    cipush(mrb, 0, CINFO_SKIP, mrb->object_class, NULL, NULL, 0, 0);\n  }\n  return mrb_vm_run(mrb, proc, self, stack_keep);\n}\n\nint FuzzRB(const uint8_t *Data, size_t size) {\n  mrb_value v;\n  mrb_state *mrb = mrb_open();\n  if (!mrb)\n    return 0;\n\n  char *code = (char*)malloc(size+1);\n  if (!code)\n    return 0;\n  memcpy(code, Data, size);\n  code[size] = '\\0';\n\n  if (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n    // With libFuzzer binary run this to generate an RB file x.rb:\n    // PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n    std::ofstream of(dump_path);\n    of.write(code, size);\n  }\n  std::cout << \"\\n\\n############\\n\" << code << \"\\n############\\n\\n\";\n  v = mrb_load_string(mrb, code);\n  mrb_close(mrb);\n\n  free(code);\n  return 0;\n}\n\n\n\n\n// target function\nstatic void\nclear_all_old(mrb_state *mrb, mrb_gc *gc)\n{\n  mrb_assert(is_generational(gc));\n  if (gc->full) {\n    /* finish the half baked GC */\n    incremental_gc_finish(mrb, gc);\n  }\n  else {\n    /* Sweep the dead objects, then reset all the live objects\n     * (including all the old objects, of course) to white. */\n    gc->generational = FALSE;\n    prepare_incremental_sweep(mrb, gc);\n    incremental_gc_finish(mrb, gc);\n    gc->generational = TRUE;\n  }\n  /* The gray objects have already been painted as white */\n  gc->atomic_gray_list = gc->gray_list = NULL;\n}\n",
    "target": 1,
    "idx": 1057703,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\ndxf_tables_read (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  char table[80];\n  Dxf_Pair *pair;\n\n  pair = dxf_read_pair (dat);\n  table[0] = '\\0'; // init\n  while (pair)     // read next 0 TABLE\n    {\n      if (pair->code == 0 && pair->value.s) // TABLE or ENDTAB\n        {\n          if (strEQc (pair->value.s, \"TABLE\"))\n            table[0] = '\\0'; // new table coming up\n          else if (strEQc (pair->value.s, \"BLOCK_RECORD\"))\n            {\n              strncpy (table, pair->value.s, 79);\n              table[79] = '\\0';\n            }\n          else if (strEQc (pair->value.s, \"ENDTAB\"))\n            {\n              table[0] = '\\0'; // close table\n            }\n          else if (strEQc (pair->value.s, \"ENDSEC\"))\n            {\n              dxf_free_pair (pair);\n              return 0;\n            }\n          else\n            {\n              LOG_ERROR (\"Unknown 0 %s (%s)\", pair->value.s, \"tables\");\n              dxf_free_pair (pair);\n              return 1;\n            }\n        }\n      else if (pair->code == 2 && pair->value.s && strlen (pair->value.s) < 80\n               && is_table_name (pair->value.s)) // new table NAME\n        {\n          long i = 0;\n          BITCODE_BL ctrl_id;\n          strncpy (table, pair->value.s, 79);\n          table[79] = '\\0';\n          pair = new_table_control (table, dat, dwg); // until 0 table\n          ctrl_id = dwg->num_objects - 1;             // dwg->object might move\n          while (pair && pair->code == 0 && pair->value.s\n                 && strEQ (pair->value.s, table))\n            {\n              Dwg_Object *obj;\n              Dwg_Object *ctrl;\n              char *dxfname = strdup (pair->value.s);\n              BITCODE_BL idx = dwg->num_objects;\n              BITCODE_H ref;\n              dxf_free_pair (pair);\n              // until 0 table or 0 ENDTAB\n              pair = new_object (table, dxfname, dat, dwg, ctrl_id,\n                                 (BITCODE_BL *)&i);\n              obj = &dwg->object[idx];\n              ctrl = &dwg->object[ctrl_id];\n              if (!pair)\n                {\n                  free (dxfname);\n                  if (idx != dwg->num_objects)\n                    obj->dxfname = NULL;\n                  return DWG_ERR_INVALIDDWG;\n                }\n              // A minimal DXF will have no handle values\n              if (!obj->handle.value)\n                {\n                  BITCODE_RLL next_handle = dwg_next_handle (dwg);\n                  dwg_add_handle (&obj->handle, 0, next_handle, NULL);\n                  // ref = dwg_add_handleref (dwg, 3, next_handle, ctrl);\n                  LOG_TRACE (\"%s.handle = (0.%d.\" FORMAT_RLLx \")\\n\", obj->name,\n                             obj->handle.size, obj->handle.value);\n                }\n              {\n                Dwg_Object_BLOCK_CONTROL *_ctrl\n                    = ctrl->tio.object->tio.BLOCK_CONTROL;\n                ref = dwg_add_handleref (dwg, 2, obj->handle.value, NULL);\n                PUSH_HV (_ctrl, num_entries, entries, ref);\n              }\n              // undo BLOCK_CONTROL.entries and LTYPE_CONTROL.entries\n              if (strEQc (table, \"BLOCK_RECORD\"))\n                {\n                  Dwg_Object_BLOCK_CONTROL *_ctrl\n                      = ctrl->tio.object->tio.BLOCK_CONTROL;\n                  if (_ctrl->model_space\n                      && obj->handle.value == _ctrl->model_space->absolute_ref)\n                    i--;\n                  else if (_ctrl->paper_space\n                           && obj->handle.value\n                                  == _ctrl->paper_space->absolute_ref)\n                    i--;\n                }\n              else if (strEQc (table, \"LTYPE\"))\n                {\n                  Dwg_Object_LTYPE *_obj = obj->tio.object->tio.LTYPE;\n                  Dwg_Object_LTYPE_CONTROL *_ctrl\n                      = ctrl->tio.object->tio.LTYPE_CONTROL;\n                  int j = _ctrl->num_entries;\n                  if (_ctrl->bylayer\n                      && obj->handle.value == _ctrl->bylayer->absolute_ref)\n                    i--;\n                  else if (_ctrl->byblock\n                           && obj->handle.value\n                                  == _ctrl->byblock->absolute_ref)\n                    i--;\n                  else\n                    {\n                      if (dwg->header.from_version > R_2004 && _obj->name\n                          && _obj->has_strings_area)\n                        {\n                          _obj->strings_area = (BITCODE_TF)xcalloc (512, 1);\n                          if (!_obj->strings_area)\n                            {\n                              free (dxfname);\n                              goto outofmem;\n                            }\n                        }\n                      if (dwg->header.from_version <= R_2004)\n                        {\n                          _obj->strings_area = (BITCODE_TF)xcalloc (256, 1);\n                          if (!_obj->strings_area)\n                            {\n                              free (dxfname);\n                              goto outofmem;\n                            }\n                        }\n                    }\n                }\n            }\n          // next table\n          // fixup entries vs num_entries (no NULL entries)\n          {\n            Dwg_Object *ctrl = &dwg->object[ctrl_id];\n            Dwg_Object_BLOCK_CONTROL *_ctrl\n                = ctrl->tio.object->tio.BLOCK_CONTROL;\n            int at_end = 1;\n            unsigned num_entries = 0;\n            if (!dwg_obj_is_control (ctrl))\n              {\n                LOG_ERROR (\"Missing CONTROL object\");\n                dxf_free_pair (pair);\n                return 1;\n              }\n            // A minimal DXF will have no handle values, assign them then\n            if (!ctrl->handle.value)\n              {\n                BITCODE_RLL next_handle = dwg_next_handle (dwg);\n                dwg_add_handle (&ctrl->handle, 0, next_handle, NULL);\n                // adds header_vars->CONTROL ref\n                (void)dwg_ctrl_table (dwg, table);\n                // ref = dwg_add_handleref (dwg, 3, next_handle, ctrl);\n                LOG_TRACE (\"%s.handle = (0.%d.\" FORMAT_RLLx \")\\n\", ctrl->name,\n                           ctrl->handle.size, ctrl->handle.value);\n              }\n            num_entries = _ctrl->num_entries;\n            if (_ctrl && ctrl->fixedtype == DWG_TYPE_BLOCK_CONTROL)\n              {\n                for (int j = num_entries - 1; j >= 0; j--)\n                  {\n                    BITCODE_H ref = _ctrl->entries ? _ctrl->entries[j] : NULL;\n                    if (!ref)\n                      {\n                        if (at_end)\n                          {\n                            num_entries--;\n                          }\n                        else\n                          {\n                            _ctrl->entries[j]\n                                = dwg_add_handleref (dwg, 2, 0, NULL);\n                            LOG_TRACE (\"%s.entries[%d] = (2.0.0)\\n\",\n                                       ctrl->name, j);\n                          }\n                      }\n                    else\n                      at_end = 0;\n                  }\n                // remove many empty entries at the end at once (avoids DDOS)\n                if (num_entries != _ctrl->num_entries)\n                  {\n                    _ctrl->entries = (BITCODE_H *)realloc (\n                        _ctrl->entries, num_entries * sizeof (BITCODE_H));\n                    if (num_entries && !_ctrl->entries)\n                      goto outofmem;\n                    _ctrl->num_entries = num_entries;\n                    LOG_TRACE (\"%s.num_entries => %d\\n\", ctrl->name,\n                               _ctrl->num_entries);\n                  }\n                // leave room for one active entry\n                if (_ctrl->num_entries == 1 && !_ctrl->entries[0])\n                  {\n                    _ctrl->entries[0] = dwg_add_handleref (dwg, 2, 0, NULL);\n                    LOG_TRACE (\"%s.entries[0] = (2.0.0)\\n\", ctrl->name);\n                  }\n              }\n          }\n        }\n      DXF_RETURN_ENDSEC (0) // next TABLE or ENDSEC\n      dxf_free_pair (pair);\n      pair = dxf_read_pair (dat);\n      DXF_CHECK_EOF;\n    } // while (pair)\n  dxf_free_pair (pair);\n  return 0;\n\noutofmem:\n  dxf_free_pair (pair);\n  return DWG_ERR_OUTOFMEM;\n}\n\nEXPORT int\ndwg_read_dxf (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  // const int minimal = dwg->opts & DWG_OPTS_MINIMAL;\n  Dxf_Pair *pair = NULL;\n  int error = 0;\n\n  loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n  if (!dat->chain && dat->fh)\n    {\n      error = dat_read_stream (dat, dat->fh);\n      if (error >= DWG_ERR_CRITICAL)\n        return error;\n      if (dat->size >= 22\n          && !memcmp (dat->chain, \"AutoCAD Binary DXF\",\n                      sizeof (\"AutoCAD Binary DXF\") - 1))\n        {\n          dat->opts |= DWG_OPTS_DXFB;\n          dat->byte = 22;\n        }\n    }\n  if (dat->size < 256)\n    {\n      LOG_ERROR (\"DXF input too small, %\" PRIuSIZE \" byte.\\n\", dat->size);\n      return DWG_ERR_IOERROR;\n    }\n  /* Fail early on DWG */\n  if (!memcmp (dat->chain, \"AC10\", 4) || !memcmp (dat->chain, \"AC1.\", 4)\n      || !memcmp (dat->chain, \"AC2.10\", 4) || !memcmp (dat->chain, \"MC0.0\", 4))\n    {\n      LOG_ERROR (\"This is a DWG, not a DXF\\n\");\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->opts |= DWG_OPTS_INDXF;\n  dwg->opts |= DWG_OPTS_INDXF;\n  // num_dxf_objs = 0;\n  // size_dxf_objs = 1000;\n  // dxf_objs = (Dxf_Objs *)malloc (1000 * sizeof (Dxf_Objs));\n  if (!dwg->object_map)\n    dwg->object_map = hash_new (dat->size / 1000);\n  // cannot rely on ref->obj during realloc's\n  dwg->dirty_refs = 1;\n\n  header_hdls = new_array_hdls (16);\n  eed_hdls = new_array_hdls (16);\n  obj_hdls = new_array_hdls (16);\n\n  // start with the BLOCK_HEADER at objid 0\n  if (!dwg->num_objects)\n    {\n      Dwg_Object *obj;\n      Dwg_Object_BLOCK_HEADER *_obj;\n      char *dxfname = strdup ((char *)\"BLOCK_HEADER\");\n      NEW_OBJECT (dwg, obj);\n      ADD_OBJECT1 (BLOCK_HEADER, BLOCK_HEADER);\n      // dwg->header.version probably here still unknown. <r2000: 0x17\n      // later fixed up when reading $ACADVER and the BLOCK_HEADER.name\n      _obj->name = dwg_add_u8_input (dwg, \"*Model_Space\");\n      _obj->is_xref_ref = 1;\n      obj->tio.object->is_xdic_missing = 1;\n      dwg_add_handle (&obj->handle, 0, 0x1F, obj);\n      obj->tio.object->ownerhandle = dwg_add_handleref (dwg, 4, 1, NULL);\n    }\n\n  while (dat->byte < dat->size)\n    {\n      pair = dxf_read_pair (dat);\n      DXF_BREAK_EOF;\n      pair = dxf_expect_code (dat, pair, 0);\n      DXF_BREAK_EOF;\n      if (pair->type == DWG_VT_STRING && strEQc (pair->value.s, \"SECTION\"))\n        {\n          dxf_free_pair (pair);\n          pair = dxf_read_pair (dat);\n          DXF_BREAK_EOF;\n          pair = dxf_expect_code (dat, pair, 2);\n          DXF_BREAK_EOF;\n          if (!pair->value.s)\n            {\n              LOG_ERROR (\"Expected SECTION string code 2, got code %d\",\n                         pair->code);\n              dxf_free_pair (pair);\n              pair = NULL;\n              break;\n            }\n          else if (strEQc (pair->value.s, \"HEADER\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_header_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n              dxf_fixup_header (dat, dwg);\n              // skip minimal DXF\n              /*\n              if (!dwg->header_vars.DIMPOST) // T in all versions\n                {\n                  LOG_ERROR (\"Unsupported minimal DXF\");\n                  return DWG_ERR_INVALIDDWG;\n                }\n              */\n            }\n          else if (strEQc (pair->value.s, \"CLASSES\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dat, dwg);\n              error = dxf_classes_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                return error;\n            }\n          else if (strEQc (pair->value.s, \"TABLES\"))\n            {\n              BITCODE_H hdl;\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_tables_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n\n              resolve_postponed_header_refs (dwg);\n              resolve_postponed_eed_refs (dwg);\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dat, dwg);\n\n              // should not happen\n              if (!dwg->header_vars.LTYPE_BYLAYER\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"ByLayer\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_BYLAYER\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              // should not happen\n              if (!dwg->header_vars.LTYPE_BYBLOCK\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"ByBlock\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_BYBLOCK\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              // but this is needed\n              if (!dwg->header_vars.LTYPE_CONTINUOUS\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"Continuous\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_CONTINUOUS\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n            }\n          else if (strEQc (pair->value.s, \"BLOCKS\"))\n            {\n              BITCODE_H hdl;\n              dxf_free_pair (pair);\n              pair = NULL;\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dat, dwg);\n              error = dxf_blocks_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n\n              // resolve_postponed_header_refs (dwg);\n              if (!dwg->header_vars.BLOCK_RECORD_PSPACE\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"*Paper_Space\", \"BLOCK\")))\n                dwg->header_vars.BLOCK_RECORD_PSPACE\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              if (!dwg->header_vars.BLOCK_RECORD_MSPACE\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"*Model_Space\", \"BLOCK\")))\n                dwg->header_vars.BLOCK_RECORD_MSPACE\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n            }\n          else if (strEQc (pair->value.s, \"ENTITIES\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              resolve_postponed_object_refs (dwg);\n              error = dxf_entities_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n            }\n          else if (strEQc (pair->value.s, \"OBJECTS\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_objects_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n              resolve_header_dicts (dwg);\n            }\n          else if (strEQc (pair->value.s, \"THUMBNAILIMAGE\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_thumbnail_read (dat, dwg);\n            }\n          else if (strEQc (pair->value.s, \"ACDSDATA\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_acds_read (dat, dwg);\n            }\n          else // if (strEQc (pair->value.s, \"\"))\n            {\n              LOG_WARN (\"SECTION %s ignored for now\", pair->value.s);\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_unknownsection_read (dat, dwg);\n            }\n        }\n      else\n        {\n          LOG_ERROR (\"Expected string SECTION\");\n          dxf_free_pair (pair);\n        }\n    }\n  if (pair != NULL && pair->code == 0 && pair->value.s != NULL\n      && strEQc (pair->value.s, \"EOF\"))\n    ;\n  else if (dat->byte >= dat->size || (pair == NULL))\n    error |= DWG_ERR_IOERROR;\n  dxf_free_pair (pair);\n  resolve_postponed_header_refs (dwg);\n  resolve_postponed_object_refs (dwg);\n  LOG_HANDLE (\"Resolving pointers from ObjectRef vector:\\n\");\n  dwg_resolve_objectrefs_silent (dwg);\n  free_array_hdls (header_hdls);\n  free_array_hdls (eed_hdls);\n  free_array_hdls (obj_hdls);\n  if (dwg->header.version <= R_2000 && dwg->header.from_version > R_2000)\n    dwg_fixup_BLOCKS_entities (dwg);\n  LOG_TRACE (\"import from DXF\\n\");\n  if (error > DWG_ERR_CRITICAL)\n    return error;\n  else\n    return dwg->num_objects ? 1 : 0;\n\nerror:\n  dwg->dirty_refs = 0;\n  free_array_hdls (header_hdls);\n  free_array_hdls (eed_hdls);\n  free_array_hdls (obj_hdls);\n  return error;\n}\n\n\n// target function\nstatic int\ndxf_tables_read (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  char table[80];\n  Dxf_Pair *pair;\n\n  pair = dxf_read_pair (dat);\n  table[0] = '\\0'; // init\n  while (pair)     // read next 0 TABLE\n    {\n      if (pair->code == 0 && pair->value.s) // TABLE or ENDTAB\n        {\n          if (strEQc (pair->value.s, \"TABLE\"))\n            table[0] = '\\0'; // new table coming up\n          else if (strEQc (pair->value.s, \"BLOCK_RECORD\"))\n            {\n              strncpy (table, pair->value.s, 79);\n              table[79] = '\\0';\n            }\n          else if (strEQc (pair->value.s, \"ENDTAB\"))\n            {\n              table[0] = '\\0'; // close table\n            }\n          else if (strEQc (pair->value.s, \"ENDSEC\"))\n            {\n              dxf_free_pair (pair);\n              return 0;\n            }\n          else\n            {\n              LOG_ERROR (\"Unknown 0 %s (%s)\", pair->value.s, \"tables\");\n              dxf_free_pair (pair);\n              return 1;\n            }\n        }\n      else if (pair->code == 2 && pair->value.s && strlen (pair->value.s) < 80\n               && is_table_name (pair->value.s)) // new table NAME\n        {\n          long i = 0;\n          BITCODE_BL ctrl_id;\n          strncpy (table, pair->value.s, 79);\n          table[79] = '\\0';\n          pair = new_table_control (table, dat, dwg); // until 0 table\n          ctrl_id = dwg->num_objects - 1;             // dwg->object might move\n          while (pair && pair->code == 0 && pair->value.s\n                 && strEQ (pair->value.s, table))\n            {\n              Dwg_Object *obj;\n              Dwg_Object *ctrl = &dwg->object[ctrl_id];\n              char *dxfname = strdup (pair->value.s);\n              BITCODE_BL idx = dwg->num_objects;\n              BITCODE_H ref;\n              dxf_free_pair (pair);\n              // until 0 table or 0 ENDTAB\n              pair = new_object (table, dxfname, dat, dwg, ctrl_id,\n                                 (BITCODE_BL *)&i);\n              obj = &dwg->object[idx];\n              if (!pair)\n                {\n                  free (dxfname);\n                  if (idx != dwg->num_objects)\n                    obj->dxfname = NULL;\n                  return DWG_ERR_INVALIDDWG;\n                }\n              // A minimal DXF will have no handle values\n              if (!obj->handle.value)\n                {\n                  BITCODE_RLL next_handle = dwg_next_handle (dwg);\n                  dwg_add_handle (&obj->handle, 0, next_handle, NULL);\n                  // ref = dwg_add_handleref (dwg, 3, next_handle, ctrl);\n                  LOG_TRACE (\"%s.handle = (0.%d.\" FORMAT_RLLx \")\\n\", obj->name,\n                             obj->handle.size, obj->handle.value);\n                }\n              {\n                Dwg_Object_BLOCK_CONTROL *_ctrl\n                    = ctrl->tio.object->tio.BLOCK_CONTROL;\n                ref = dwg_add_handleref (dwg, 2, obj->handle.value, NULL);\n                PUSH_HV (_ctrl, num_entries, entries, ref);\n              }\n              // undo BLOCK_CONTROL.entries and LTYPE_CONTROL.entries\n              if (strEQc (table, \"BLOCK_RECORD\"))\n                {\n                  Dwg_Object_BLOCK_CONTROL *_ctrl\n                      = ctrl->tio.object->tio.BLOCK_CONTROL;\n                  if (_ctrl->model_space\n                      && obj->handle.value == _ctrl->model_space->absolute_ref)\n                    i--;\n                  else if (_ctrl->paper_space\n                           && obj->handle.value\n                                  == _ctrl->paper_space->absolute_ref)\n                    i--;\n                }\n              else if (strEQc (table, \"LTYPE\"))\n                {\n                  Dwg_Object_LTYPE *_obj = obj->tio.object->tio.LTYPE;\n                  Dwg_Object_LTYPE_CONTROL *_ctrl\n                      = ctrl->tio.object->tio.LTYPE_CONTROL;\n                  int j = _ctrl->num_entries;\n                  if (_ctrl->bylayer\n                      && obj->handle.value == _ctrl->bylayer->absolute_ref)\n                    i--;\n                  else if (_ctrl->byblock\n                           && obj->handle.value\n                                  == _ctrl->byblock->absolute_ref)\n                    i--;\n                  else\n                    {\n                      if (dwg->header.from_version > R_2004 && _obj->name\n                          && _obj->has_strings_area)\n                        {\n                          _obj->strings_area = (BITCODE_TF)xcalloc (512, 1);\n                          if (!_obj->strings_area)\n                            {\n                              free (dxfname);\n                              goto outofmem;\n                            }\n                        }\n                      if (dwg->header.from_version <= R_2004)\n                        {\n                          _obj->strings_area = (BITCODE_TF)xcalloc (256, 1);\n                          if (!_obj->strings_area)\n                            {\n                              free (dxfname);\n                              goto outofmem;\n                            }\n                        }\n                    }\n                }\n            }\n          // next table\n          // fixup entries vs num_entries (no NULL entries)\n          {\n            Dwg_Object *ctrl = &dwg->object[ctrl_id];\n            Dwg_Object_BLOCK_CONTROL *_ctrl\n                = ctrl->tio.object->tio.BLOCK_CONTROL;\n            int at_end = 1;\n            unsigned num_entries = 0;\n            if (!dwg_obj_is_control (ctrl))\n              {\n                LOG_ERROR (\"Missing CONTROL object\");\n                dxf_free_pair (pair);\n                return 1;\n              }\n            // A minimal DXF will have no handle values, assign them then\n            if (!ctrl->handle.value)\n              {\n                BITCODE_RLL next_handle = dwg_next_handle (dwg);\n                dwg_add_handle (&ctrl->handle, 0, next_handle, NULL);\n                // adds header_vars->CONTROL ref\n                (void)dwg_ctrl_table (dwg, table);\n                // ref = dwg_add_handleref (dwg, 3, next_handle, ctrl);\n                LOG_TRACE (\"%s.handle = (0.%d.\" FORMAT_RLLx \")\\n\", ctrl->name,\n                           ctrl->handle.size, ctrl->handle.value);\n              }\n            num_entries = _ctrl->num_entries;\n            if (_ctrl && ctrl->fixedtype == DWG_TYPE_BLOCK_CONTROL)\n              {\n                for (int j = num_entries - 1; j >= 0; j--)\n                  {\n                    BITCODE_H ref = _ctrl->entries ? _ctrl->entries[j] : NULL;\n                    if (!ref)\n                      {\n                        if (at_end)\n                          {\n                            num_entries--;\n                          }\n                        else\n                          {\n                            _ctrl->entries[j]\n                                = dwg_add_handleref (dwg, 2, 0, NULL);\n                            LOG_TRACE (\"%s.entries[%d] = (2.0.0)\\n\",\n                                       ctrl->name, j);\n                          }\n                      }\n                    else\n                      at_end = 0;\n                  }\n                // remove many empty entries at the end at once (avoids DDOS)\n                if (num_entries != _ctrl->num_entries)\n                  {\n                    _ctrl->entries = (BITCODE_H *)realloc (\n                        _ctrl->entries, num_entries * sizeof (BITCODE_H));\n                    if (num_entries && !_ctrl->entries)\n                      goto outofmem;\n                    _ctrl->num_entries = num_entries;\n                    LOG_TRACE (\"%s.num_entries => %d\\n\", ctrl->name,\n                               _ctrl->num_entries);\n                  }\n                // leave room for one active entry\n                if (_ctrl->num_entries == 1 && !_ctrl->entries[0])\n                  {\n                    _ctrl->entries[0] = dwg_add_handleref (dwg, 2, 0, NULL);\n                    LOG_TRACE (\"%s.entries[0] = (2.0.0)\\n\", ctrl->name);\n                  }\n              }\n          }\n        }\n      DXF_RETURN_ENDSEC (0) // next TABLE or ENDSEC\n      dxf_free_pair (pair);\n      pair = dxf_read_pair (dat);\n      DXF_CHECK_EOF;\n    } // while (pair)\n  dxf_free_pair (pair);\n  return 0;\n\noutofmem:\n  dxf_free_pair (pair);\n  return DWG_ERR_OUTOFMEM;\n}\n",
    "target": 1,
    "idx": 1066835,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n    *q = *p ^ *q,\n    *p = *p ^ *q;\n  }\n}\n\nstatic inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      PixelInfo\n        *color;\n\n      Quantum\n        index;\n\n      index=pixel;\n      if (packet_size == 1)\n        index=(Quantum) ScaleQuantumToChar(index);\n      index=(Quantum) ConstrainColormapIndex(image,(ssize_t) index,\n        exception);\n\n      if (type == 0)\n        SetPixelIndex(image,index,q);\n      if ((type == 0) && (channels > 1))\n        return;\n      color=image->colormap+(ssize_t) GetPixelIndex(image,q);\n      if (type != 0)\n        color->alpha=(MagickRealType) pixel;\n      SetPixelViaPixelInfo(image,color,q);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(image,pixel,q);\n      break;\n    }\n    case -3:\n    case 1:\n    {\n      SetPixelGreen(image,pixel,q);\n      break;\n    }\n    case -4:\n    case 2:\n    {\n      SetPixelBlue(image,pixel,q);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelBlack(image,pixel,q);\n      else\n        if (image->alpha_trait != UndefinedPixelTrait)\n          SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->alpha_trait != UndefinedPixelTrait)\n\n      break;\n    }\n  }\n}\n\nstatic MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  register const unsigned char\n    *p;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType) (QuantumRange*nibble));\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}\n\nstatic MagickBooleanType ReadPSDChannelRaw(Image *image,const size_t channels,\n  const ssize_t type,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RAW\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  (void) memset(pixels,0,row_size*sizeof(*pixels));\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,row_size,pixels);\n    if (count != (ssize_t) row_size)\n      {\n        status=MagickFalse;\n        break;\n      }\n\n    status=ReadPSDChannelPixels(image,channels,y,type,pixels,exception);\n    if (status == MagickFalse)\n      break;\n\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n#endif\n\nstatic MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if ((layer_info->channel_info[channel].type < -1) &&\n      (layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0))\n    {\n      const char\n        *option;\n\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n        {\n          (void) SeekBlob(image,(MagickOffsetType)\n            layer_info->channel_info[channel].size-2,SEEK_CUR);\n          return(MagickTrue);\n        }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          (void) ResetImagePixels(mask,exception);\n          (void) SetImageType(mask,GrayscaleType,exception);\n          channel_image=mask;\n        }\n    }\n\n  offset=TellBlob(image);\n  status=MagickFalse;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        (ssize_t) layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          (ssize_t) layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        (ssize_t) layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  (void) SeekBlob(image,offset+layer_info->channel_info[channel].size-2,\n    SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        (void) DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  if (mask != (Image *) NULL)\n    {\n      if (layer_info->mask.image != (Image *) NULL)\n\n      layer_info->mask.image=mask;\n    }\n  return(status);\n}\n\nstatic MagickBooleanType ReadPSDLayer(Image *image,const ImageInfo *image_info,\n  const PSDInfo *psd_info,LayerInfo* layer_info,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    j;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    setting up new layer image\");\n  if (psd_info->mode != IndexedMode)\n    (void) SetImageBackgroundColor(layer_info->image,exception);\n  layer_info->image->compose=PSDBlendModeToCompositeOperator(\n    layer_info->blendkey);\n  if (layer_info->visible == MagickFalse)\n    layer_info->image->compose=NoCompositeOp;\n  /*\n    Set up some hidden attributes for folks that need them.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.x);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.x\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.y);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.y\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",(double)\n    layer_info->opacity);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.opacity\",message);\n  (void) SetImageProperty(layer_info->image,\"label\",(char *) layer_info->name,\n    exception);\n\n  status=MagickTrue;\n  for (j=0; j < (ssize_t) layer_info->channels; j++)\n  {\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    reading data for channel %.20g\",(double) j);\n\n    compression=(PSDCompressionType) ReadBlobShort(layer_info->image);\n\n    /* TODO: Remove this when we figure out how to support this */\n    if ((compression == ZipWithPrediction) && (image->depth == 32))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          TypeError,\"CompressionNotSupported\",\"ZipWithPrediction(32 bit)\");\n        return(MagickFalse);\n      }\n\n    layer_info->image->compression=ConvertPSDCompression(compression);\n    if (layer_info->channel_info[j].type == -1)\n      layer_info->image->alpha_trait=BlendPixelTrait;\n\n    status=ReadPSDChannel(layer_info->image,image_info,psd_info,layer_info,\n      (size_t) j,compression,exception);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    status=ApplyPSDLayerOpacity(layer_info->image,layer_info->opacity,\n      MagickFalse,exception);\n\n  if ((status != MagickFalse) &&\n      (layer_info->image->colorspace == CMYKColorspace))\n    status=NegateCMYK(layer_info->image,exception);\n\n  if ((status != MagickFalse) && (layer_info->mask.image != (Image *) NULL))\n    {\n      const char\n        *option;\n\n      layer_info->mask.image->page.x=layer_info->mask.page.x;\n      layer_info->mask.image->page.y=layer_info->mask.page.y;\n      /* Do not composite the mask when it is disabled */\n      if ((layer_info->mask.flags & 0x02) == 0x02)\n        layer_info->mask.image->compose=NoCompositeOp;\n      else\n        status=ApplyPSDOpacityMask(layer_info->image,layer_info->mask.image,\n          layer_info->mask.background == 0 ? 0 : QuantumRange,MagickFalse,\n          exception);\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if (IsStringTrue(option) != MagickFalse)\n        PreservePSDOpacityMask(image,layer_info,exception);\n\n  if (index > image_info->scene+image_info->number_scenes-1)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    index,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      if (count == 4)\n        ReversePSDString(image,type,(size_t) count);\n      if ((count != 4) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          if (count == 4)\n            ReversePSDString(image,type,4);\n          if ((count == 4) && ((LocaleNCompare(type,\"Lr16\",4) == 0) ||\n              (LocaleNCompare(type,\"Lr32\",4) == 0)))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  if (size == 0)\n    return(MagickTrue);\n\n  layer_info=(LayerInfo *) NULL;\n  number_layers=(ssize_t) ReadBlobSignedShort(image);\n\n  if (number_layers < 0)\n    {\n      /*\n        The first alpha channel in the merged result contains the\n        transparency data for the merged result.\n      */\n      number_layers=MagickAbsoluteValue(number_layers);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  negative layer count corrected for\");\n      image->alpha_trait=BlendPixelTrait;\n    }\n\n  /*\n    We only need to know if the image has an alpha channel\n  */\n  if (skip_layers != MagickFalse)\n    return(MagickTrue);\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  image contains %.20g layers\",(double) number_layers);\n\n  if (number_layers == 0)\n    ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n      image->filename);\n\n  layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n    sizeof(*layer_info));\n  if (layer_info == (LayerInfo *) NULL)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  allocation of LayerInfo failed\");\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) memset(layer_info,0,(size_t) number_layers*sizeof(*layer_info));\n\n  for (i=0; i < number_layers; i++)\n  {\n    ssize_t\n      top,\n      left,\n      bottom,\n      right;\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  reading layer #%.20g\",(double) i+1);\n    top=(ssize_t) ReadBlobSignedLong(image);\n    left=(ssize_t) ReadBlobSignedLong(image);\n    bottom=(ssize_t) ReadBlobSignedLong(image);\n    right=(ssize_t) ReadBlobSignedLong(image);\n    if ((right < left) || (bottom < top))\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    layer_info[i].page.y=top;\n    layer_info[i].page.x=left;\n    layer_info[i].page.width=(size_t) (right-left);\n    layer_info[i].page.height=(size_t) (bottom-top);\n    layer_info[i].channels=ReadBlobShort(image);\n    if (layer_info[i].channels > MaxPSDChannels)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n          image->filename);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n        (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n        (double) layer_info[i].page.height,(double)\n        layer_info[i].page.width,(double) layer_info[i].channels);\n    for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n    {\n      layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n      if ((layer_info[i].channel_info[j].type < -4) ||\n          (layer_info[i].channel_info[j].type > 4))\n        {\n          layer_info=DestroyLayerInfo(layer_info,number_layers);\n          ThrowBinaryException(CorruptImageError,\"NoSuchImageChannel\",\n            image->filename);\n        }\n      layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n        image);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n          (double) layer_info[i].channel_info[j].type,\n          (double) layer_info[i].channel_info[j].size);\n    }\n    if (CheckPSDChannels(psd_info,&layer_info[i]) == MagickFalse)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    count=ReadBlob(image,4,(unsigned char *) type);\n    if (count == 4)\n      ReversePSDString(image,type,4);\n    if ((count != 4) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  layer type was %.4s instead of 8BIM\", type);\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n    if (count != 4)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    ReversePSDString(image,layer_info[i].blendkey,4);\n    layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n      ReadBlobByte(image));\n    layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n    layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n    layer_info[i].visible=!(layer_info[i].flags & 0x02);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n        layer_info[i].blendkey,(double) layer_info[i].opacity,\n        layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n        layer_info[i].visible ? \"true\" : \"false\");\n    (void) ReadBlobByte(image);  /* filler */\n\n    size=ReadBlobLong(image);\n    if (size != 0)\n      {\n        MagickSizeType\n          combined_length,\n          length;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    layer contains additional info\");\n        length=ReadBlobLong(image);\n        combined_length=length+4;\n        if (length != 0)\n          {\n            /*\n              Layer mask info.\n            */\n            layer_info[i].mask.page.y=(ssize_t) ReadBlobSignedLong(image);\n            layer_info[i].mask.page.x=(ssize_t) ReadBlobSignedLong(image);\n            layer_info[i].mask.page.height=(size_t)\n              (ReadBlobSignedLong(image)-layer_info[i].mask.page.y);\n            layer_info[i].mask.page.width=(size_t) (\n              ReadBlobSignedLong(image)-layer_info[i].mask.page.x);\n            layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n              image);\n            layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n            if (!(layer_info[i].mask.flags & 0x01))\n              {\n                layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                  layer_info[i].page.y;\n                layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                  layer_info[i].page.x;\n              }\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                (double) layer_info[i].mask.page.x,(double)\n                layer_info[i].mask.page.y,(double)\n                layer_info[i].mask.page.width,(double)\n                layer_info[i].mask.page.height,(double) ((MagickOffsetType)\n                length)-18);\n            /*\n              Skip over the rest of the layer mask information.\n            */\n            if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        length=ReadBlobLong(image);\n        combined_length+=length+4;\n        if (length != 0)\n          {\n            /*\n              Layer blending ranges info.\n            */\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer blending ranges: length=%.20g\",(double)\n                ((MagickOffsetType) length));\n            if (DiscardBlobBytes(image,length) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        /*\n          Layer name.\n        */\n        length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n        combined_length+=length+1;\n        if (length > 0)\n          (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n        layer_info[i].name[length]='\\0';\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      layer name: %s\",layer_info[i].name);\n        if ((length % 4) != 0)\n          {\n            length=4-(length % 4);\n            combined_length+=length;\n            /* Skip over the padding of the layer name */\n            if (DiscardBlobBytes(image,length) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        length=(MagickSizeType) size-combined_length;\n        if (length > 0)\n          {\n            unsigned char\n              *info;\n\n            if (length > GetBlobSize(image))\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image->filename);\n              }\n            layer_info[i].info=AcquireStringInfo((const size_t) length);\n            info=GetStringInfoDatum(layer_info[i].info);\n            (void) ReadBlob(image,(const size_t) length,info);\n          }\n      }\n  }\n\n  for (i=0; i < number_layers; i++)\n  {\n    if ((layer_info[i].page.width == 0) || (layer_info[i].page.height == 0))\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      layer data is empty\");\n        if (layer_info[i].info != (StringInfo *) NULL)\n          layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n        continue;\n      }\n\n    /*\n      Allocate layered image.\n    */\n    layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n      layer_info[i].page.height,MagickFalse,exception);\n    if (layer_info[i].image == (Image *) NULL)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  allocation of image for layer %.20g failed\",(double) i);\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      }\n    if (layer_info[i].info != (StringInfo *) NULL)\n      {\n        (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n          layer_info[i].info,exception);\n        layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n      }\n  }\n  if (image_info->ping != MagickFalse)\n    {\n      AttachPSDLayers(image,layer_info,number_layers);\n      return(MagickTrue);\n    }\n  status=MagickTrue;\n  index=0;\n  for (i=0; i < number_layers; i++)\n  {\n    if ((layer_info[i].image == (Image *) NULL) ||\n        (PSDSkipImage(psd_info, image_info,++index) != MagickFalse))\n      {\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          if (DiscardBlobBytes(image,(MagickSizeType)\n              layer_info[i].channel_info[j].size) == MagickFalse)\n            {\n              layer_info=DestroyLayerInfo(layer_info,number_layers);\n              ThrowBinaryException(CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n            }\n        }\n        continue;\n      }\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  reading data for layer %.20g\",(double) i);\n\n    status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n      exception);\n    if (status == MagickFalse)\n      break;\n\n    status=SetImageProgress(image,LoadImagesTag,(MagickOffsetType) i,\n      (MagickSizeType) number_layers);\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    AttachPSDLayers(image,layer_info,number_layers);\n\n\n\n\n\n\n\nvoid Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}\n\n\n// target function\n    }\n\n  return(status);\n}\n\nstatic MagickBooleanType CheckPSDChannels(const PSDInfo *psd_info,\n  LayerInfo *layer_info)\n{\n  int\n    channel_type;\n\n  register ssize_t\n    i;\n\n  if (layer_info->channels < psd_info->min_channels)\n    return(MagickFalse);\n  channel_type=RedChannel;\n  if (psd_info->min_channels >= 3)\n    channel_type|=(GreenChannel | BlueChannel);\n  if (psd_info->min_channels >= 4)\n    channel_type|=BlackChannel;\n  for (i=0; i < (ssize_t) layer_info->channels; i++)\n  {\n    short\n      type;\n\n    type=layer_info->channel_info[i].type;\n    if (type == -1)\n      {\n        channel_type|=AlphaChannel;\n        continue;\n      }\n    if (type < -1)\n      continue;\n    if (type == 0)\n      channel_type&=~RedChannel;\n    else if (type == 1)\n      channel_type&=~GreenChannel;\n    else if (type == 2)\n      channel_type&=~BlueChannel;\n    else if (type == 3)\n      channel_type&=~BlackChannel;\n  }\n  if (channel_type == 0)\n    return(MagickTrue);\n",
    "target": 1,
    "idx": 1019744,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nint yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* child;\n  RE_NODE* concat;\n\n  int result;\n\n  *result_re_ast = re_ast;\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  if (re_ast->root_node->type != RE_NODE_CONCAT)\n    return ERROR_SUCCESS;\n\n  child = re_ast->root_node->children_head;\n\n  while (child != NULL)\n  {\n    if (!child->greedy &&\n         child->type == RE_NODE_RANGE_ANY &&\n         child->prev_sibling != NULL &&\n         child->next_sibling != NULL &&\n        (child->start > YR_STRING_CHAINING_THRESHOLD ||\n         child->end > YR_STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      concat = yr_re_node_create(RE_NODE_CONCAT);\n\n      if (concat == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      concat->children_head = re_ast->root_node->children_head;\n      concat->children_tail = child->prev_sibling;\n\n      re_ast->root_node->children_head = child->next_sibling;\n\n      child->prev_sibling->next_sibling = NULL;\n      child->next_sibling->prev_sibling = NULL;\n\n      *min_gap = child->start;\n      *max_gap = child->end;\n\n      (*result_re_ast)->root_node = re_ast->root_node;\n      (*result_re_ast)->flags = re_ast->flags;\n      (*remainder_re_ast)->root_node = concat;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      yr_re_node_destroy(child);\n\n      return ERROR_SUCCESS;\n    }\n\n    child = child->next_sibling;\n  }\n\n  return ERROR_SUCCESS;\n}\n\nint yr_parser_reduce_string_declaration(\n    yyscan_t yyscanner,\n    int32_t string_flags,\n    const char* identifier,\n    SIZED_STRING* str,\n    YR_STRING** string)\n{\n  int min_atom_quality = YR_MIN_ATOM_QUALITY;\n  int min_atom_quality_aux = YR_MIN_ATOM_QUALITY;\n\n  int32_t min_gap;\n  int32_t max_gap;\n\n  char message[512];\n\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n  YR_STRING* aux_string;\n  YR_STRING* prev_string;\n\n  RE_AST* re_ast = NULL;\n  RE_AST* remainder_re_ast = NULL;\n\n  RE_ERROR re_error;\n\n  int result = ERROR_SUCCESS;\n\n  // Determine if a string with the same identifier was already defined\n  // by searching for the identifier in string_table.\n\n  *string = (YR_STRING*) yr_hash_table_lookup(\n      compiler->strings_table,\n      identifier,\n      NULL);\n\n  if (*string != NULL)\n  {\n    result = ERROR_DUPLICATED_STRING_IDENTIFIER;\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    goto _exit;\n  }\n\n  // Empty strings are not allowed\n\n  if (str->length == 0)\n  {\n    result = ERROR_EMPTY_STRING;\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    goto _exit;\n  }\n\n  if (str->flags & SIZED_STRING_FLAGS_NO_CASE)\n    string_flags |= STRING_GFLAGS_NO_CASE;\n\n  if (str->flags & SIZED_STRING_FLAGS_DOT_ALL)\n    string_flags |= STRING_GFLAGS_DOT_ALL;\n\n  if (strcmp(identifier,\"$\") == 0)\n    string_flags |= STRING_GFLAGS_ANONYMOUS;\n\n  if (!(string_flags & STRING_GFLAGS_WIDE) &&\n      !(string_flags & STRING_GFLAGS_XOR))\n    string_flags |= STRING_GFLAGS_ASCII;\n\n  // Hex strings are always handled as DOT_ALL regexps.\n\n  if (string_flags & STRING_GFLAGS_HEXADECIMAL)\n    string_flags |= STRING_GFLAGS_DOT_ALL;\n\n  // The STRING_GFLAGS_SINGLE_MATCH flag indicates that finding\n  // a single match for the string is enough. This is true in\n  // most cases, except when the string count (#) and string offset (@)\n  // operators are used. All strings are marked STRING_FLAGS_SINGLE_MATCH\n  // initially, and unmarked later if required.\n\n  string_flags |= STRING_GFLAGS_SINGLE_MATCH;\n\n  // The STRING_GFLAGS_FIXED_OFFSET indicates that the string doesn't\n  // need to be searched all over the file because the user is using the\n  // \"at\" operator. The string must be searched at a fixed offset in the\n  // file. All strings are marked STRING_GFLAGS_FIXED_OFFSET initially,\n  // and unmarked later if required.\n\n  string_flags |= STRING_GFLAGS_FIXED_OFFSET;\n\n  if (string_flags & STRING_GFLAGS_HEXADECIMAL ||\n      string_flags & STRING_GFLAGS_REGEXP)\n  {\n    if (string_flags & STRING_GFLAGS_HEXADECIMAL)\n      result = yr_re_parse_hex(str->c_string, &re_ast, &re_error);\n    else\n      result = yr_re_parse(str->c_string, &re_ast, &re_error);\n\n    if (result != ERROR_SUCCESS)\n    {\n      snprintf(\n          message,\n          sizeof(message),\n          \"invalid %s \\\"%s\\\": %s\",\n          (string_flags & STRING_GFLAGS_HEXADECIMAL) ?\n              \"hex string\" : \"regular expression\",\n          identifier,\n          re_error.message);\n\n      yr_compiler_set_error_extra_info(\n          compiler, message);\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_FAST_REGEXP)\n      string_flags |= STRING_GFLAGS_FAST_REGEXP;\n\n    // Regular expressions in the strings section can't mix greedy and ungreedy\n    // quantifiers like .* and .*?. That's because these regular expressions can\n    // be matched forwards and/or backwards depending on the atom found, and we\n    // need the regexp to be all-greedy or all-ungreedy to be able to properly\n    // calculate the length of the match.\n\n    if ((re_ast->flags & RE_FLAGS_GREEDY) &&\n        (re_ast->flags & RE_FLAGS_UNGREEDY))\n    {\n      result = ERROR_INVALID_REGULAR_EXPRESSION;\n\n      yr_compiler_set_error_extra_info(compiler,\n          \"greedy and ungreedy quantifiers can't be mixed in a regular \"\n          \"expression\");\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_GREEDY)\n      string_flags |= STRING_GFLAGS_GREEDY_REGEXP;\n\n    if (yr_re_ast_contains_dot_star(re_ast))\n    {\n      yywarning(\n          yyscanner,\n          \"%s contains .* or .+, consider using .{N} or .{1,N} with a reasonable value for N\",\n          identifier);\n    }\n\n    if (compiler->re_ast_callback != NULL)\n    {\n      compiler->re_ast_callback(\n          compiler->current_rule,\n          identifier,\n          re_ast,\n          compiler->re_ast_clbk_user_data);\n    }\n\n    result = yr_re_ast_split_at_chaining_point(\n        re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    result = _yr_parser_write_string(\n        identifier,\n        string_flags,\n        compiler,\n        NULL,\n        re_ast,\n        string,\n        &min_atom_quality,\n        &compiler->current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    if (remainder_re_ast != NULL)\n    {\n      (*string)->g_flags |= STRING_GFLAGS_CHAIN_TAIL | STRING_GFLAGS_CHAIN_PART;\n      (*string)->chain_gap_min = min_gap;\n      (*string)->chain_gap_max = max_gap;\n    }\n\n    // Use \"aux_string\" from now on, we want to keep the value of \"string\"\n    // because it will returned.\n\n    aux_string = *string;\n\n    while (remainder_re_ast != NULL)\n    {\n      // Destroy regexp pointed by 're_ast' before yr_re_split_at_chaining_point\n      // overwrites 're_ast' with another value.\n\n      yr_re_ast_destroy(re_ast);\n\n      result = yr_re_ast_split_at_chaining_point(\n          remainder_re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      prev_string = aux_string;\n\n      result = _yr_parser_write_string(\n          identifier,\n          string_flags,\n          compiler,\n          NULL,\n          re_ast,\n          &aux_string,\n          &min_atom_quality_aux,\n          &compiler->current_rule->num_atoms);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      if (min_atom_quality_aux < min_atom_quality)\n        min_atom_quality = min_atom_quality_aux;\n\n      aux_string->g_flags |= STRING_GFLAGS_CHAIN_PART;\n      aux_string->chain_gap_min = min_gap;\n      aux_string->chain_gap_max = max_gap;\n\n      prev_string->chained_to = aux_string;\n\n      // prev_string is now chained to aux_string, an string chained\n      // to another one can't have a fixed offset, only the head of the\n      // string chain can have a fixed offset.\n\n      prev_string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n    }\n  }\n  else\n  {\n    result = _yr_parser_write_string(\n        identifier,\n        string_flags,\n        compiler,\n        str,\n        NULL,\n        string,\n        &min_atom_quality,\n        &compiler->current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (!STRING_IS_ANONYMOUS(*string))\n  {\n    result = yr_hash_table_add(\n      compiler->strings_table,\n      identifier,\n      NULL,\n      *string);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (min_atom_quality < compiler->atoms_config.quality_warning_threshold)\n  {\n    yywarning(\n        yyscanner,\n        \"%s in rule %s is slowing down scanning\",\n        (*string)->identifier,\n        compiler->current_rule->identifier);\n  }\n\n_exit:\n\n  if (re_ast != NULL)\n    yr_re_ast_destroy(re_ast);\n\n  if (remainder_re_ast != NULL)\n    yr_re_ast_destroy(remainder_re_ast);\n\n  return result;\n}\n\n\n// target function\nint yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* child;\n  RE_NODE* concat;\n\n  int result;\n\n  *result_re_ast = re_ast;\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  if (re_ast->root_node->type != RE_NODE_CONCAT)\n    return ERROR_SUCCESS;\n\n  child = re_ast->root_node->children_head;\n\n  while (child != NULL)\n  {\n    if (!child->greedy &&\n         child->type == RE_NODE_RANGE_ANY &&\n        (child->start > YR_STRING_CHAINING_THRESHOLD ||\n         child->end > YR_STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      concat = yr_re_node_create(RE_NODE_CONCAT);\n\n      if (concat == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      concat->children_head = re_ast->root_node->children_head;\n      concat->children_tail = child->prev_sibling;\n\n      re_ast->root_node->children_head = child->next_sibling;\n\n      if (child->prev_sibling != NULL)\n        child->prev_sibling->next_sibling = NULL;\n\n      if (child->next_sibling != NULL)\n        child->next_sibling->prev_sibling = NULL;\n\n      *min_gap = child->start;\n      *max_gap = child->end;\n\n      (*result_re_ast)->root_node = re_ast->root_node;\n      (*result_re_ast)->flags = re_ast->flags;\n      (*remainder_re_ast)->root_node = concat;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      yr_re_node_destroy(child);\n\n      return ERROR_SUCCESS;\n    }\n\n    child = child->next_sibling;\n  }\n\n  return ERROR_SUCCESS;\n}\nvoid test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\"a|b\", \"a\", \"a\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab{1,2}c\", \"abbbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_false_regexp(\"ab{1}c\", \"ac\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_false_regexp(\"ab{3}c\", \"abbbbc\");  // Issue #817\n  assert_false_regexp(\"ab{4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,4}\", \"abbbbc\", \"abbbb\");\n  assert_true_regexp(\"ab{3,4}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\"ab{3,5}\", \"abbbbb\", \"abbbbb\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbc\");\n  assert_false_regexp(\"ab{3,5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  // Test case for issue #682\n  assert_true_regexp(\"(a|\\\\b)[a]{1,}\", \"aaaa\", \"aaaa\");\n\n  // Test for integer overflow in repeat interval\n  assert_regexp_syntax_error(\"a{2977952116}\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^D]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^D]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^F]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n       \"rule test { strings: $a = /abc[^F]/ condition: $a }\",\n       \"abcd\");\n}\n",
    "target": 1,
    "idx": 1011752,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid  m3_FreeModule  (IM3Module i_module)\n{\n    if (i_module)\n    {\n        m3log (module, \"freeing module: %s (funcs: %d; segments: %d)\",\n               i_module->name, i_module->numFunctions, i_module->numDataSegments);\n\n        Module_FreeFunctions (i_module);\n\n        m3_Free (i_module->functions);\n        //m3_Free (i_module->imports);\n        m3_Free (i_module->funcTypes);\n        m3_Free (i_module->dataSegments);\n        m3_Free (i_module->table0);\n\n        for (u32 i = 0; i < i_module->numGlobals; ++i)\n        {\n            m3_Free (i_module->globals[i].name);\n            FreeImportInfo(&(i_module->globals[i].import));\n        }\n        m3_Free (i_module->globals);\n\n        m3_Free (i_module);\n    }\n}\n\n\n\nM3Result  Compile_ExtendedOpcode  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;\n\n_try {\n    u8 opcode;\n_   (Read_u8 (& opcode, & o->wasm, o->wasmEnd));             m3log (compile, d_indent \" (FC: %\" PRIi32 \")\", get_indention_string (o), opcode);\n\n    i_opcode = (i_opcode << 8) | opcode;\n\n    //printf(\"Extended opcode: 0x%x\\n\", i_opcode);\n\n    const M3OpInfo* opinfo = GetOpInfo (i_opcode);\n    _throwif (m3Err_unknownOpcode, not opinfo);\n\n    M3Compiler compiler = opinfo->compiler;\n    _throwif (m3Err_noCompiler, not compiler);\n\n_   ((* compiler) (o, i_opcode));\n\n    o->previousOpcode = i_opcode;\n\n\t} _catch: return result;\n}\n\nM3Result  CompileBlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n    bool validEnd = false;\n\n    while (o->wasm < o->wasmEnd)\n    {                                                                   emit_stack_dump (o);\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        // Restrict opcodes when evaluating expressions\n        if (not o->function) {\n            switch (opcode) {\n            case c_waOp_i32_const: case c_waOp_i64_const:\n            case c_waOp_f32_const: case c_waOp_f64_const:\n            case c_waOp_getGlobal: case c_waOp_end:\n                break;\n            default:\n                _throw(m3Err_restictedOpcode);\n            }\n        }\n\n        IM3OpInfo opinfo = GetOpInfo(opcode);\n        \n        if (opinfo == NULL)\n            _throw (ErrorCompile (m3Err_unknownOpcode, o, \"opcode '%x' not available\", opcode));\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;\n\n        if (opcode == c_waOp_else)\n        {\n            _throwif (m3Err_wasmMalformed, o->block.opcode != c_waOp_if);\n            validEnd = true;\n            break;\n        }\n        else if (opcode == c_waOp_end)\n        {\n            validEnd = true;\n            break;\n        }\n    }\n    _throwif(m3Err_wasmMalformed, !(validEnd));\n\n_catch:\n    return result;\n}\n\nM3Result  CompileBlock  (IM3Compilation o, IM3FuncType i_blockType, m3opcode_t i_blockOpcode)\n{\n    M3Result result = m3Err_none;                                                       d_m3Assert (not IsRegisterAllocated (o, 0));\n                                                                                        d_m3Assert (not IsRegisterAllocated (o, 1));\n    M3CompilationScope outerScope = o->block;\n    M3CompilationScope * block = & o->block;\n\n    block->outer            = & outerScope;\n    block->pc               = GetPagePC (o->page);\n    block->patches          = NULL;\n    block->type             = i_blockType;\n    block->depth            ++;\n    block->opcode           = i_blockOpcode;\n\n    /*\n     The block stack frame is a little strange but for good reasons.  Because blocks need to be restarted to\n     compile different pathways (if/else), the incoming params must be saved.  The parameters are popped\n     and validated.  But, then the stack top is readjusted so they aren't subsequently overwritten.\n     Next, the result are preallocated to find destination slots.  But again these are immediately popped\n     (deallocated) and the stack top is readjusted to keep these records in pace. This allows branch instructions\n     to find their result landing pads.  Finally, the params are copied from the \"dead\" records and pushed back\n     onto the stack as active stack items for the CompileBlockStatements () call.\n\n    [     block      ]\n    [     params     ]\n    ------------------\n    [     result     ]  <---- blockStackIndex\n    [      slots     ]\n    ------------------\n    [   saved param  ]\n    [     records    ]\n                        <----- exitStackIndex\n    */\n\n_try {\n    // validate and dealloc params ----------------------------\n\n    u16 stackIndex = o->stackIndex;\n\n    u16 numParams = GetFuncTypeNumParams (i_blockType);\n\n    if (i_blockOpcode != c_waOp_else)\n    {\n        for (u16 i = 0; i < numParams; ++i)\n        {\n            u8 type = GetFuncTypeParamType (i_blockType, numParams - 1 - i);\n_           (PopType (o, type));\n        }\n    }\n    else o->stackIndex -= numParams;\n\n    u16 paramIndex = o->stackIndex;\n    block->exitStackIndex = paramIndex; // consume the params at block exit\n\n    // keep copies of param slots in the stack\n    o->stackIndex = stackIndex;\n\n    // find slots for the results ----------------------------\n    PushBlockResults (o);\n\n    stackIndex = o->stackIndex;\n\n    // dealloc but keep record of the result slots in the stack\n    u16 numResults = GetFuncTypeNumResults (i_blockType);\n    while (numResults--)\n        Pop (o);\n\n    block->blockStackIndex = o->stackIndex = stackIndex;\n\n    // push the params back onto the stack -------------------\n    for (u16 i = 0; i < numParams; ++i)\n    {\n        u8 type = GetFuncTypeParamType (i_blockType, i);\n\n        u16 slot = GetSlotForStackIndex (o, paramIndex + i);\n        Push (o, type, slot);\n\n        if (slot >= o->slotFirstDynamicIndex)\n            MarkSlotsAllocatedByType (o, slot, type);\n    }\n\n    //--------------------------------------------------------\n\n_   (CompileBlockStatements (o));\n\n_   (ValidateBlockEnd (o));\n\n    if (o->function)    // skip for expressions\n    {\n        if (not IsStackPolymorphic (o))\n_           (ResolveBlockResults (o, & o->block, /* isBranch: */ false));\n\n_       (UnwindBlockStack (o))\n\n        if (not ((i_blockOpcode == c_waOp_if and numResults) or o->previousOpcode == c_waOp_else))\n        {\n            o->stackIndex = o->block.exitStackIndex;\n_           (PushBlockResults (o));\n        }\n    }\n\n    PatchBranches (o);\n\n    o->block = outerScope;\n\n}   _catch: return result;\n}\n\nM3Result  Compile_LoopOrBlock  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    // TODO: these shouldn't be necessary for non-loop blocks?\n_   (PreserveRegisters (o));\n_   (PreserveArgsAndLocals (o));\n\n    IM3FuncType blockType;\n_   (ReadBlockType (o, & blockType));\n\n    if (i_opcode == c_waOp_loop)\n    {\n        u16 numParams = GetFuncTypeNumParams (blockType);\n        if (numParams)\n        {\n            // instantiate constants\n            u16 numValues = GetNumBlockValuesOnStack (o);                   // CompileBlock enforces this at comptime\n                                                                            d_m3Assert (numValues >= numParams);\n            if (numValues >= numParams)\n            {\n                u16 stackTop = GetStackTopIndex (o) + 1;\n\n                for (u16 i = stackTop - numParams; i < stackTop; ++i)\n                {\n                    u16 slot = GetSlotForStackIndex (o, i);\n                    u8 type = GetStackTypeFromBottom (o, i);\n\n                    if (IsConstantSlot (o, slot))\n                    {\n                        u16 newSlot;\n_                       (AllocateSlots (o, & newSlot, type));\n_                       (CopyStackIndexToSlot (o, newSlot, i));\n                        o->wasmStack [i] = newSlot;\n                    }\n                }\n            }\n        }\n\n_       (EmitOp (o, op_Loop));\n    }\n    else\n    {\n    }\n\n_   (CompileBlock (o, blockType, i_opcode));\n\n    _catch: return result;\n}\n\nM3Result  CompileBlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n    bool validEnd = false;\n\n    while (o->wasm < o->wasmEnd)\n    {                                                                   emit_stack_dump (o);\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        // Restrict opcodes when evaluating expressions\n        if (not o->function) {\n            switch (opcode) {\n            case c_waOp_i32_const: case c_waOp_i64_const:\n            case c_waOp_f32_const: case c_waOp_f64_const:\n            case c_waOp_getGlobal: case c_waOp_end:\n                break;\n            default:\n                _throw(m3Err_restictedOpcode);\n            }\n        }\n\n        IM3OpInfo opinfo = GetOpInfo(opcode);\n        \n        if (opinfo == NULL)\n            _throw (ErrorCompile (m3Err_unknownOpcode, o, \"opcode '%x' not available\", opcode));\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;\n\n        if (opcode == c_waOp_else)\n        {\n            _throwif (m3Err_wasmMalformed, o->block.opcode != c_waOp_if);\n            validEnd = true;\n            break;\n        }\n        else if (opcode == c_waOp_end)\n        {\n            validEnd = true;\n            break;\n        }\n    }\n    _throwif(m3Err_wasmMalformed, !(validEnd));\n\n_catch:\n    return result;\n}\n\nM3Result  CompileFunction  (IM3Function io_function)\n{\n    M3Result result = m3Err_none;\n\n    if (!io_function->wasm) return \"function body is missing\";\n\n    IM3FuncType funcType = io_function->funcType;                   m3log (compile, \"compiling: [%d] %s %s; wasm-size: %d\",\n                                                                        io_function->index, m3_GetFunctionName (io_function), SPrintFuncTypeSignature (funcType), (u32) (io_function->wasmEnd - io_function->wasm));\n    IM3Runtime runtime = io_function->module->runtime;\n\n    IM3Compilation o = & runtime->compilation;                      d_m3Assert (d_m3MaxFunctionSlots >= d_m3MaxFunctionStackHeight * (d_m3Use32BitSlots + 1))  // need twice as many slots in 32-bit mode\n    memset (o, 0x0, sizeof (M3Compilation));\n\n    o->runtime  = runtime;\n    o->module   = io_function->module;\n    o->function = io_function;\n    o->wasm     = io_function->wasm;\n    o->wasmEnd  = io_function->wasmEnd;\n    o->block.type = funcType;\n\n_try {\n    // skip over code size. the end was already calculated during parse phase\n    u32 size;\n_   (ReadLEB_u32 (& size, & o->wasm, o->wasmEnd));                  d_m3Assert (size == (o->wasmEnd - o->wasm))\n\n_   (AcquireCompilationCodePage (o, & o->page));\n\n    pc_t pc = GetPagePC (o->page);\n\n    u16 numRetSlots = GetFunctionNumReturns (o->function) * c_ioSlotCount;\n\n    for (u16 i = 0; i < numRetSlots; ++i)\n        MarkSlotAllocated (o, i);\n\n    o->function->numRetSlots = o->slotFirstDynamicIndex = numRetSlots;\n\n    u16 numArgs = GetFunctionNumArgs (o->function);\n\n    // push the arg types to the type stack\n    for (u16 i = 0; i < numArgs; ++i)\n    {\n        u8 type = GetFunctionArgType (o->function, i);\n_       (PushAllocatedSlot (o, type));\n\n        // prevent allocator fill-in\n        o->slotFirstDynamicIndex += c_ioSlotCount;\n    }\n\n    o->slotMaxAllocatedIndexPlusOne = o->function->numRetAndArgSlots = o->slotFirstLocalIndex = o->slotFirstDynamicIndex;\n\n_   (CompileLocals (o));\n\n    u16 maxSlot = GetMaxUsedSlotPlusOne (o);\n\n    o->function->numLocalBytes = (maxSlot - o->slotFirstLocalIndex) * sizeof (m3slot_t);\n\n    o->slotFirstConstIndex = o->slotMaxConstIndex = maxSlot;\n\n    // ReserveConstants initializes o->firstDynamicSlotNumber\n_   (ReserveConstants (o));\n\n    // start tracking the max stack used (Push() also updates this value) so that op_Entry can precisely detect stack overflow\n    o->maxStackSlots = o->slotMaxAllocatedIndexPlusOne = o->slotFirstDynamicIndex;\n\n    o->block.blockStackIndex = o->stackFirstDynamicIndex = o->stackIndex;                           m3log (compile, \"start stack index: %d\",\n                                                                                                          (u32) o->stackFirstDynamicIndex);\n_   (EmitOp (o, op_Entry));\n    EmitPointer (o, io_function);\n\n_   (CompileBlockStatements (o));\n\n    // TODO: validate opcode sequences\n    _throwif(m3Err_wasmMalformed, o->previousOpcode != c_waOp_end);\n\n    io_function->compiled = pc;\n    io_function->maxStackSlots = o->maxStackSlots;\n\n    u16 numConstantSlots = o->slotMaxConstIndex - o->slotFirstConstIndex;                           m3log (compile, \"unique constant slots: %d; unused slots: %d\",\n                                                                                                           numConstantSlots, o->slotFirstDynamicIndex - o->slotMaxConstIndex);\n    io_function->numConstantBytes = numConstantSlots * sizeof (m3slot_t);\n\n    if (numConstantSlots)\n    {\n        io_function->constants = m3_CopyMem (o->constants, io_function->numConstantBytes);\n        _throwifnull(io_function->constants);\n    }\n\n} _catch:\n\n    ReleaseCompilationCodePage (o);\n\n    return result;\n}\n\nM3Result  m3_FindFunction  (IM3Function * o_function, IM3Runtime i_runtime, const char * const i_functionName)\n{\n    M3Result result = m3Err_none;                               d_m3Assert (o_function and i_runtime and i_functionName);\n\n    IM3Function function = NULL;\n\n    if (not i_runtime->modules) {\n        _throw (\"no modules loaded\");\n    }\n\n    function = (IM3Function) ForEachModule (i_runtime, (ModuleVisitor) v_FindFunction, (void *) i_functionName);\n\n    if (function)\n    {\n        if (not function->compiled)\n        {\n_           (CompileFunction (function))\n        }\n\n        // Check if start function needs to be called\n        if (function->module->startFunction)\n        {\n_           (m3_RunStart (function->module))\n        }\n    }\n    else _throw (ErrorModule (m3Err_functionLookupFailed, i_runtime->modules, \"'%s'\", i_functionName));\n\n    _catch:\n    if (result)\n        function = NULL;\n\n    * o_function = function;\n\n    return result;\n}\n\n\n// target function\nM3Result  Compile_ExtendedOpcode  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;\n\n_try {\n    u8 opcode;\n_   (Read_u8 (& opcode, & o->wasm, o->wasmEnd));             m3log (compile, d_indent \" (FC: %\" PRIi32 \")\", get_indention_string (o), opcode);\n\n    i_opcode = (i_opcode << 8) | opcode;\n\n    //printf(\"Extended opcode: 0x%x\\n\", i_opcode);\n\n    M3Compiler compiler = GetOpInfo (i_opcode)->compiler;\n    _throwif (m3Err_noCompiler, not compiler);\n\n_   ((* compiler) (o, i_opcode));\n\n    o->previousOpcode = i_opcode;\n\n\t} _catch: return result;\n}\nM3Result  m3_RunStart  (IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    if (io_module and io_module->startFunction >= 0)\n    {\n        IM3Function function = & io_module->functions [io_module->startFunction];\n\n        if (not function->compiled)\n        {\n_           (CompileFunction (function));\n        }\n\n        IM3FuncType ftype = function->funcType;\n        if (ftype->numArgs != 0 || ftype->numRets != 0)\n            _throw (m3Err_argumentCountMismatch);\n\n        IM3Module module = function->module;\n        IM3Runtime runtime = module->runtime;\n\n_       ((M3Result) Call (function->compiled, (m3stack_t) runtime->stack, runtime->memory.mallocated, d_m3OpDefaultArgs));\n\n        io_module->startFunction = -1;\n    }\n\n    _catch: return result;\n}\n",
    "target": 1,
    "idx": 1033765,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nint flb_parser_conf_file(const char *file, struct flb_config *config)\n{\n    int ret;\n    char tmp[PATH_MAX + 1];\n    const char *cfg = NULL;\n    struct mk_rconf *fconf;\n    struct stat st;\n\n#ifndef FLB_HAVE_STATIC_CONF\n    ret = stat(file, &st);\n    if (ret == -1 && errno == ENOENT) {\n        /* Try to resolve the real path (if exists) */\n        if (file[0] == '/') {\n            flb_utils_error(FLB_ERR_CFG_PARSER_FILE);\n            return -1;\n        }\n\n        if (config->conf_path) {\n            snprintf(tmp, PATH_MAX, \"%s%s\", config->conf_path, file);\n            cfg = tmp;\n        }\n    }\n    else {\n        cfg = file;\n    }\n\n    fconf = mk_rconf_open(cfg);\n#else\n    fconf = flb_config_static_open(file);\n#endif\n\n    if (!fconf) {\n        return -1;\n    }\n\n    /* process [PARSER]'s sections */\n    ret = parser_conf_file(cfg, fconf, config);\n    if (ret == -1) {\n        mk_rconf_free(fconf);\n        return -1;\n    }\n\n    ret = multiline_parser_conf_file(cfg, fconf, config);\n    if (ret == -1) {\n        mk_rconf_free(fconf);\n        return -1;\n    }\n\n    mk_rconf_free(fconf);\n    return 0;\n}\n\n\n// target function\nstatic int parser_conf_file(const char *cfg, struct mk_rconf *fconf,\n                            struct flb_config *config)\n{\n    flb_sds_t name;\n    flb_sds_t format;\n    flb_sds_t regex;\n    flb_sds_t time_fmt;\n    flb_sds_t time_key;\n    flb_sds_t time_offset;\n    flb_sds_t types_str;\n    flb_sds_t tmp_str;\n    int time_keep;\n    int time_strict;\n    int types_len;\n    struct mk_list *head;\n    struct mk_list *decoders = NULL;\n    struct mk_rconf_section *section;\n    struct flb_parser_types *types = NULL;\n\n    /* Read all [PARSER] sections */\n    mk_list_foreach(head, &fconf->sections) {\n        name = NULL;\n        format = NULL;\n        regex = NULL;\n        time_fmt = NULL;\n        time_key = NULL;\n        time_offset = NULL;\n        types_str = NULL;\n        tmp_str = NULL;\n\n        section = mk_list_entry(head, struct mk_rconf_section, _head);\n        if (strcasecmp(section->name, \"PARSER\") != 0) {\n            continue;\n        }\n\n        /* Name */\n        name = get_parser_key(\"Name\", config, section);\n        if (!name) {\n            flb_error(\"[parser] no parser 'name' found in file '%s'\", cfg);\n            goto fconf_error;\n        }\n\n        /* Format */\n        format = get_parser_key(\"Format\", config, section);\n        if (!format) {\n            flb_error(\"[parser] no parser 'format' found for '%s' in file '%s'\",\n                      name, cfg);\n            goto fconf_error;\n        }\n\n        /* Regex (if 'format' == 'regex') */\n        regex = get_parser_key(\"Regex\", config, section);\n        if (!regex && strcmp(format, \"regex\") == 0) {\n            flb_error(\"[parser] no parser 'regex' found for '%s' in file '%s\", name, cfg);\n            goto fconf_error;\n        }\n\n        /* Time_Format */\n        time_fmt = get_parser_key(\"Time_Format\", config, section);\n\n        /* Time_Key */\n        time_key = get_parser_key(\"Time_Key\", config, section);\n\n        /* Time_Keep */\n        time_keep = FLB_FALSE;\n        tmp_str = get_parser_key(\"Time_Keep\", config, section);\n        if (tmp_str) {\n            time_keep = flb_utils_bool(tmp_str);\n            flb_sds_destroy(tmp_str);\n        }\n\n        /* Time_Strict */\n        time_strict = FLB_TRUE;\n        tmp_str = get_parser_key(\"Time_Strict\", config, section);\n        if (tmp_str) {\n            time_strict = flb_utils_bool(tmp_str);\n            flb_sds_destroy(tmp_str);\n        }\n\n        /* Time_Offset (UTC offset) */\n        time_offset = get_parser_key(\"Time_Offset\", config, section);\n\n        /* Types */\n        types_str = get_parser_key(\"Types\", config, section);\n        if (types_str) {\n            types_len = proc_types_str(types_str, &types);\n        }\n        else {\n            types_len = 0;\n        }\n\n        /* Decoders */\n        decoders = flb_parser_decoder_list_create(section);\n\n        /* Create the parser context */\n        if (!flb_parser_create(name, format, regex,\n                               time_fmt, time_key, time_offset, time_keep, time_strict,\n                               types, types_len, decoders, config)) {\n            goto fconf_error;\n        }\n\n        flb_debug(\"[parser] new parser registered: %s\", name);\n\n        flb_sds_destroy(name);\n        flb_sds_destroy(format);\n\n        if (regex) {\n            flb_sds_destroy(regex);\n        }\n        if (time_fmt) {\n            flb_sds_destroy(time_fmt);\n        }\n        if (time_key) {\n            flb_sds_destroy(time_key);\n        }\n        if (time_offset) {\n            flb_sds_destroy(time_offset);\n        }\n        if (types_str) {\n            flb_sds_destroy(types_str);\n        }\n        decoders = NULL;\n    }\n\n    mk_rconf_free(fconf);\n    return 0;\n\n fconf_error:\n    flb_sds_destroy(name);\n    flb_sds_destroy(format);\n    if (regex) {\n        flb_sds_destroy(regex);\n    }\n    if (time_fmt) {\n        flb_sds_destroy(time_fmt);\n    }\n    if (time_key) {\n        flb_sds_destroy(time_key);\n    }\n    if (time_offset) {\n        flb_sds_destroy(time_offset);\n    }\n    if (types_str) {\n        flb_sds_destroy(types_str);\n    }\n    if (decoders) {\n        flb_parser_decoder_list_destroy(decoders);\n    }\n    return -1;\n}\nstatic int multiline_parser_conf_file(const char *cfg, struct mk_rconf *fconf,\n                                      struct flb_config *config)\n{\n    flb_sds_t name;\n    int type;\n    flb_sds_t match_string;\n    int negate;\n    flb_sds_t key_content;\n    flb_sds_t key_pattern;\n    flb_sds_t key_group;\n    flb_sds_t parser;\n    flb_sds_t tmp;\n    int flush_timeout;\n    struct mk_list *head;\n    struct mk_rconf_section *section;\n    struct flb_ml *ml;\n\n    /* Read all [PARSER] sections */\n    mk_list_foreach(head, &fconf->sections) {\n        name = NULL;\n        type = -1;\n        match_string = NULL;\n        negate = FLB_FALSE;\n        key_content = NULL;\n        key_pattern = NULL;\n        key_group = NULL;\n        parser = NULL;\n        flush_timeout = -1;\n\n        section = mk_list_entry(head, struct mk_rconf_section, _head);\n        if (strcasecmp(section->name, \"MULTILINE_PARSER\") != 0) {\n            continue;\n        }\n\n        /* name */\n        name = get_parser_key(\"name\", config, section);\n        if (!name) {\n            flb_error(\"[multiline_parser] no 'name' defined in file '%s'\", cfg);\n            goto fconf_error;\n        }\n\n        /* type */\n        tmp = get_parser_key(\"type\", config, section);\n        if (!tmp) {\n            flb_error(\"[multiline_parser] no 'type' defined in file '%s'\", cfg);\n            goto fconf_error;\n        }\n        else {\n            type = flb_ml_type_lookup(tmp);\n            if (type == -1) {\n                flb_error(\"[multiline_parser] invalid type '%s'\", tmp);\n                flb_sds_destroy(tmp);\n                goto fconf_error;\n            }\n            flb_sds_destroy(tmp);\n        }\n\n        /* match_string */\n        match_string = get_parser_key(\"match_string\", config, section);\n\n        /* negate */\n        tmp = get_parser_key(\"negate\", config, section);\n        if (tmp) {\n            negate = flb_utils_bool(tmp);\n            flb_sds_destroy(tmp);\n        }\n\n        /* key_content */\n        key_content = get_parser_key(\"key_content\", config, section);\n\n        /* key_pattern */\n        key_pattern = get_parser_key(\"key_pattern\", config, section);\n\n        /* key_group */\n        key_group = get_parser_key(\"key_group\", config, section);\n\n        /* parser */\n        parser = get_parser_key(\"parser\", config, section);\n\n        /* flush_timeout */\n        tmp = get_parser_key(\"flush_timeout\", config, section);\n        if (tmp) {\n            flush_timeout = atoi(tmp);\n        }\n\n        ml = flb_ml_create(config, name, type, match_string, negate,\n                           flush_timeout, key_content, key_group, key_pattern,\n                           NULL, parser);\n\n        flb_sds_destroy(name);\n        flb_sds_destroy(match_string);\n        flb_sds_destroy(key_content);\n        flb_sds_destroy(key_pattern);\n        flb_sds_destroy(key_group);\n    }\n\n    mk_rconf_free(fconf);\n    return 0;\n\n fconf_error:\n    flb_sds_destroy(name);\n    flb_sds_destroy(match_string);\n    flb_sds_destroy(key_content);\n    flb_sds_destroy(key_pattern);\n    flb_sds_destroy(key_group);\n\n    return -1;\n}\n",
    "target": 1,
    "idx": 1034960,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic zend_always_inline uint32_t zend_gc_delref(zend_refcounted_h *p) {\n\tZEND_ASSERT(p->refcount > 0);\n\tZEND_RC_MOD_CHECK(p);\n\treturn --(p->refcount);\n}\n\nstatic zend_always_inline void i_zval_ptr_dtor(zval *zval_ptr)\n{\n\tif (Z_REFCOUNTED_P(zval_ptr)) {\n\t\tzend_refcounted *ref = Z_COUNTED_P(zval_ptr);\n\t\tif (!GC_DELREF(ref)) {\n\t\t\trc_dtor_func(ref);\n\t\t} else {\n\t\t\tgc_check_possible_root(ref);\n\t\t}\n\t}\n}\n\nZEND_API void zval_ptr_dtor(zval *zval_ptr) /* {{{ */\n{\n\ti_zval_ptr_dtor(zval_ptr);\n}\n\nvoid user_shutdown_function_dtor(zval *zv) /* {{{ */\n{\n\tint i;\n\tphp_shutdown_function_entry *shutdown_function_entry = Z_PTR_P(zv);\n\n\tfor (i = 0; i < shutdown_function_entry->arg_count; i++) {\n\t\tzval_ptr_dtor(&shutdown_function_entry->arguments[i]);\n\t}\n\tefree(shutdown_function_entry->arguments);\n\tefree(shutdown_function_entry);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_destroy(HashTable *ht)\n{\n\tBucket *p, *end;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(ht, GC_REFCOUNT(ht) <= 1);\n\n\tif (ht->nNumUsed) {\n\t\tp = ht->arData;\n\t\tend = p + ht->nNumUsed;\n\t\tif (ht->pDestructor) {\n\t\t\tSET_INCONSISTENT(HT_IS_DESTROYING);\n\n\t\t\tif (HT_HAS_STATIC_KEYS_ONLY(ht)) {\n\t\t\t\tif (HT_IS_WITHOUT_HOLES(ht)) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t}\n\t\t\t} else if (HT_IS_WITHOUT_HOLES(ht)) {\n\t\t\t\tdo {\n\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t}\n\n\t\t\tSET_INCONSISTENT(HT_DESTROYED);\n\t\t} else {\n\t\t\tif (!HT_HAS_STATIC_KEYS_ONLY(ht)) {\n\t\t\t\tdo {\n\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t}\n\t\t}\n\t\tzend_hash_iterators_remove(ht);\n\t} else if (EXPECTED(HT_FLAGS(ht) & HASH_FLAG_UNINITIALIZED)) {\n\t\treturn;\n\t}\n\tpefree(HT_GET_DATA_ADDR(ht), GC_FLAGS(ht) & IS_ARRAY_PERSISTENT);\n}\n\nPHPAPI void php_free_shutdown_functions(void) /* {{{ */\n{\n\tif (BG(user_shutdown_function_names))\n\t\tzend_try {\n\t\t\tzend_hash_destroy(BG(user_shutdown_function_names));\n\t\t\tFREE_HASHTABLE(BG(user_shutdown_function_names));\n\t\t\tBG(user_shutdown_function_names) = NULL;\n\t\t} zend_catch {\n\nvoid php_request_shutdown(void *dummy)\n{\n\tzend_bool report_memleaks;\n\n\tEG(flags) |= EG_FLAGS_IN_SHUTDOWN;\n\n\treport_memleaks = PG(report_memleaks);\n\n\t/* EG(current_execute_data) points into nirvana and therefore cannot be safely accessed\n\t * inside zend_executor callback functions.\n\t */\n\tEG(current_execute_data) = NULL;\n\n\tphp_deactivate_ticks();\n\n\t/* 1. Call all possible shutdown functions registered with register_shutdown_function() */\n\tif (PG(modules_activated)) {\n\t\tphp_call_shutdown_functions();\n\t}\n\n\t/* 2. Call all possible __destruct() functions */\n\tzend_try {\n\t\tzend_call_destructors();\n\t} zend_end_try();\n\nvoid fuzzer_request_shutdown()\n{\n\tzend_try {\n\t\t/* Destroy thrown exceptions. This does not happen as part of request shutdown. */\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\n\t\t/* Some fuzzers (like unserialize) may create circular structures. Make sure we free them.\n\t\t * Two calls are performed to handle objects with destructors. */\n\t\tzend_gc_collect_cycles();\n\t\tzend_gc_collect_cycles();\n\t} zend_end_try();\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\n// target function\nstatic ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_NULL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *val;\n\n\tval = RT_CONSTANT(opline, opline->op1);\n\tif (IS_CONST != IS_CONST) {\n\t\tZVAL_DEREF(val);\n\t}\n\n\tif (Z_TYPE_INFO_P(val) > IS_NULL) {\n\t\tZEND_VM_NEXT_OPCODE();\n\t} else {\n\t\tzval *result = EX_VAR(opline->result.var);\n\n\t\tif (EXPECTED(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EXPR)) {\n\t\t\tif (UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {\n\t\t\t\tSAVE_OPLINE();\n\t\t\t\tZVAL_UNDEFINED_OP1();\n\t\t\t\tif (UNEXPECTED(EG(exception) != NULL)) {\n\t\t\t\t\tHANDLE_EXCEPTION();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tZVAL_NULL(result);\n\t\t} else if (opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_ISSET) {\n\t\t\tZVAL_FALSE(result);\n\t\t} else {\n\t\t\tZEND_ASSERT(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EMPTY);\n\t\t\tZVAL_TRUE(result);\n\t\t}\n\n\t\tZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);\n\t}\n}\nstatic ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_NULL_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *val;\n\n\tval = EX_VAR(opline->op1.var);\n\tif ((IS_TMP_VAR|IS_VAR|IS_CV) != IS_CONST) {\n\t\tZVAL_DEREF(val);\n\t}\n\n\tif (Z_TYPE_INFO_P(val) > IS_NULL) {\n\t\tZEND_VM_NEXT_OPCODE();\n\t} else {\n\t\tzval *result = EX_VAR(opline->result.var);\n\n\t\tif (EXPECTED(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EXPR)) {\n\t\t\tif (UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {\n\t\t\t\tSAVE_OPLINE();\n\t\t\t\tZVAL_UNDEFINED_OP1();\n\t\t\t\tif (UNEXPECTED(EG(exception) != NULL)) {\n\t\t\t\t\tHANDLE_EXCEPTION();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tZVAL_NULL(result);\n\t\t} else if (opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_ISSET) {\n\t\t\tZVAL_FALSE(result);\n\t\t} else {\n\t\t\tZEND_ASSERT(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EMPTY);\n\t\t\tZVAL_TRUE(result);\n\t\t}\n\n\t\tZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);\n\t}\n}\n",
    "target": 1,
    "idx": 1025526,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n\n    if (doc == NULL) return(-1);\n    if ((attr == NULL) || (attr->id == NULL)) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)\n        return(-1);\n\n    attr->atype = 0;\n    attr->id = NULL;\n\n    return(0);\n}\n\nvoid\nxmlFreeProp(xmlAttrPtr cur) {\n    xmlDictPtr dict = NULL;\n    if (cur == NULL) return;\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {\n\t    xmlRemoveID(cur->doc, cur);\n    }\n    if (cur->children != NULL) xmlFreeNodeList(cur->children);\n    DICT_FREE(cur->name)\n    xmlFree(cur);\n}\n\nvoid\nxmlFreePropList(xmlAttrPtr cur) {\n    xmlAttrPtr next;\n    if (cur == NULL) return;\n    while (cur != NULL) {\n        next = cur->next;\n        xmlFreeProp(cur);\n\tcur = next;\n    }\n}\n\nvoid\nxmlFreeNodeList(xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if (cur->doc != NULL) dict = cur->doc->dict;\n    while (1) {\n        while ((cur->children != NULL) &&\n               (cur->type != XML_DOCUMENT_NODE) &&\n               (cur->type != XML_HTML_DOCUMENT_NODE) &&\n               (cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\tif ((cur->type == XML_DOCUMENT_NODE) ||\n            (cur->type == XML_HTML_DOCUMENT_NODE)) {\n            xmlFreeDoc((xmlDocPtr) cur);\n        } else if (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlFreePropList(cur->properties);\n\t    if ((cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE) &&\n\t\t(cur->content != (xmlChar *) &(cur->properties))) {\n\t\tDICT_FREE(cur->content)\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * When a node is a text node or a comment, it uses a global static\n\t     * variable for the name of the node.\n\t     * Otherwise the node name might come from the document's\n\t     * dictionary\n\t     */\n\t    if ((cur->name != NULL) &&\n\t\t(cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name)\n\t    xmlFree(cur);\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\n\nvoid\nxmlFreeNode(xmlNodePtr cur) {\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return;\n\n    /* use xmlFreeDtd for DTD nodes */\n    if (cur->type == XML_DTD_NODE) {\n\txmlFreeDtd((xmlDtdPtr) cur);\n\treturn;\n    }\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNs((xmlNsPtr) cur);\n        return;\n    }\n    if (cur->type == XML_ATTRIBUTE_NODE) {\n\txmlFreeProp((xmlAttrPtr) cur);\n\treturn;\n    }\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue(cur);\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if (cur->type == XML_ENTITY_DECL) {\n        xmlEntityPtr ent = (xmlEntityPtr) cur;\n\tDICT_FREE(ent->SystemID);\n\tDICT_FREE(ent->ExternalID);\n    }\n    if ((cur->children != NULL) &&\n\t(cur->type != XML_ENTITY_REF_NODE))\n\txmlFreeNodeList(cur->children);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n        (cur->type == XML_XINCLUDE_START) ||\n        (cur->type == XML_XINCLUDE_END)) {\n        if (cur->properties != NULL)\n            xmlFreePropList(cur->properties);\n        if (cur->nsDef != NULL)\n            xmlFreeNsList(cur->nsDef);\n    } else if ((cur->content != NULL) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->content != (xmlChar *) &(cur->properties))) {\n        DICT_FREE(cur->content)\n    }\n\n    /*\n     * When a node is a text node or a comment, it uses a global static\n     * variable for the name of the node.\n     * Otherwise the node name might come from the document's dictionary\n     */\n    if ((cur->name != NULL) &&\n        (cur->type != XML_TEXT_NODE) &&\n        (cur->type != XML_COMMENT_NODE))\n\tDICT_FREE(cur->name)\n\n    xmlFree(cur);\n}\n\nstatic xmlNodePtr\nxmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n                    int hasTextDecl, int buildTree) {\n    xmlNodePtr root = NULL;\n    xmlNodePtr list = NULL;\n    xmlChar *rootName = BAD_CAST \"#root\";\n    int result;\n\n    if (buildTree) {\n        root = xmlNewDocNode(ctxt->myDoc, NULL, rootName, NULL);\n        if (root == NULL) {\n            xmlErrMemory(ctxt);\n            goto error;\n        }\n    }\n\n    if (xmlPushInput(ctxt, input) < 0)\n        goto error;\n\n    nameNsPush(ctxt, rootName, NULL, NULL, 0, 0);\n    spacePush(ctxt, -1);\n\n    if (buildTree)\n        nodePush(ctxt, root);\n\n    if (hasTextDecl) {\n        xmlDetectEncoding(ctxt);\n\n        /*\n         * Parse a possible text declaration first\n         */\n        if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n            (IS_BLANK_CH(NXT(5)))) {\n            xmlParseTextDecl(ctxt);\n            /*\n             * An XML-1.0 document can't reference an entity not XML-1.0\n             */\n            if ((xmlStrEqual(ctxt->version, BAD_CAST \"1.0\")) &&\n                (!xmlStrEqual(ctxt->input->version, BAD_CAST \"1.0\"))) {\n                xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,\n                               \"Version mismatch between document and \"\n                               \"entity\\n\");\n            }\n        }\n    }\n\n    xmlParseContentInternal(ctxt);\n\n    if (ctxt->input->cur < ctxt->input->end)\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n\n    if ((ctxt->wellFormed) ||\n        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n        if (root != NULL) {\n            xmlNodePtr cur;\n\n            /*\n             * Return the newly created nodeset after unlinking it from\n             * its pseudo parent.\n             */\n            cur = root->children;\n            list = cur;\n            while (cur != NULL) {\n                cur->parent = NULL;\n                cur = cur->next;\n            }\n            root->children = NULL;\n            root->last = NULL;\n        }\n    }\n\n    /*\n     * Read the rest of the stream in case of errors. We want\n     * to account for the whole entity size.\n     */\n    do {\n        ctxt->input->cur = ctxt->input->end;\n        xmlParserShrink(ctxt);\n        result = xmlParserGrow(ctxt);\n    } while (result > 0);\n\n    if (buildTree)\n        nodePop(ctxt);\n\n    namePop(ctxt);\n    spacePop(ctxt);\n\n    /* xmlPopInput would free the stream */\n    inputPop(ctxt);\n\nerror:\n    xmlFreeNode(root);\n\n    return(list);\n}\n\nstatic void\nxmlCtxtParseEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {\n    xmlParserInputPtr input;\n    xmlNodePtr list;\n    unsigned long consumed;\n    int isExternal;\n    int buildTree;\n    int oldMinNsIndex;\n    int oldNodelen, oldNodemem;\n\n    isExternal = (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY);\n    buildTree = (ctxt->node != NULL);\n\n    /*\n     * Recursion check\n     */\n    if (ent->flags & XML_ENT_EXPANDING) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        xmlHaltParser(ctxt);\n        goto error;\n    }\n\n    /*\n     * Load entity\n     */\n    input = xmlNewEntityInputStream(ctxt, ent);\n    if (input == NULL)\n        goto error;\n\n    /*\n     * When building a tree, we need to limit the scope of namespace\n     * declarations, so that entities don't reference xmlNs structs\n     * from the parent of a reference.\n     */\n    oldMinNsIndex = ctxt->nsdb->minNsIndex;\n    if (buildTree)\n        ctxt->nsdb->minNsIndex = ctxt->nsNr;\n\n    oldNodelen = ctxt->nodelen;\n    oldNodemem = ctxt->nodemem;\n    ctxt->nodelen = 0;\n    ctxt->nodemem = 0;\n\n    /*\n     * Parse content\n     *\n     * This initiates a recursive call chain:\n     *\n     * - xmlCtxtParseContent\n     * - xmlParseContentInternal\n     * - xmlParseReference\n     * - xmlCtxtParseEntity\n     *\n     * The nesting depth is limited by the maximum number of inputs,\n     * see xmlPushInput.\n     *\n     * It's possible to make this non-recursive (minNsIndex must be\n     * stored in the input struct) at the expense of code readability.\n     */\n\n    ent->flags |= XML_ENT_EXPANDING;\n\n    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);\n\n    ent->flags &= ~XML_ENT_EXPANDING;\n\n    ctxt->nsdb->minNsIndex = oldMinNsIndex;\n    ctxt->nodelen = oldNodelen;\n    ctxt->nodemem = oldNodemem;\n\n    /*\n     * Entity size accounting\n     */\n    consumed = input->consumed;\n    xmlSaturatedAddSizeT(&consumed, input->end - input->base);\n\n    if ((ent->flags & XML_ENT_CHECKED) == 0)\n        xmlSaturatedAdd(&ent->expandedSize, consumed);\n\n    if ((ent->flags & XML_ENT_PARSED) == 0) {\n        if (isExternal)\n            xmlSaturatedAdd(&ctxt->sizeentities, consumed);\n\n        ent->children = list;\n\n        while (list != NULL) {\n            list->parent = (xmlNodePtr) ent;\n            if (list->next == NULL)\n                ent->last = list;\n            list = list->next;\n        }\n    } else {\n        xmlFreeNodeList(list);\n    }\n\n    xmlFreeInputStream(input);\n\nerror:\n    ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n}\n\n\n\nint\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    size_t curBase;\n    size_t maxLength;\n    int end_in_lf = 0;\n\n    if ((ctxt == NULL) || (size < 0))\n        return(XML_ERR_ARGUMENT);\n    if (ctxt->disableSAX != 0)\n        return(ctxt->errNo);\n    if (ctxt->input == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt->input->flags |= XML_INPUT_PROGRESSIVE;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlCtxtInitializeLate(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n\n    curBase = ctxt->input->cur - ctxt->input->base;\n    maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                XML_MAX_HUGE_LENGTH :\n                XML_MAX_LOOKUP_LIMIT;\n    if (curBase > maxLength) {\n        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n                    \"Buffer size limit exceeded, try XML_PARSE_HUGE\\n\");\n        xmlHaltParser(ctxt);\n    }\n\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n            ctxt->instate = XML_PARSER_EOF;\n            xmlFinishDocument(ctxt);\n\t}\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}\n\nstatic int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlCtxtErrIO(reader->ctxt, reader->input->error, NULL);\n                    reader->mode = XML_TEXTREADER_MODE_ERROR;\n                    reader->state = XML_TEXTREADER_ERROR;\n                    return(-1);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}\n\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n\n\n// target function\nint\nxmlAddIDSafe(xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr,\n             int streaming, xmlIDPtr *id) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (id != NULL)\n        *id = NULL;\n\n    if (doc == NULL) {\n\treturn(-1);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(0);\n    }\n    if (attr == NULL) {\n\treturn(-1);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n        if (table == NULL)\n            return(-1);\n    } else {\n        ret = xmlHashLookup(table, value);\n        if (ret != NULL) {\n            /*\n             * Update the attribute to make entities work.\n             */\n            if (ret->attr != NULL) {\n                ret->attr->id = NULL;\n                ret->attr = attr;\n            }\n\t    attr->atype = XML_ATTRIBUTE_ID;\n            attr->id = ret;\n            return(0);\n        }\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL)\n\treturn(-1);\n    memset(ret, 0, sizeof(*ret));\n\n    /*\n     * fill the structure.\n     */\n    ret->doc = doc;\n    ret->value = xmlStrdup(value);\n    if (ret->value == NULL) {\n        xmlFreeID(ret);\n        return(-1);\n    }\n    if (streaming) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n        if (ret->name == NULL) {\n            xmlFreeID(ret);\n            return(-1);\n        }\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n\txmlFreeID(ret);\n\treturn(-1);\n    }\n\n    attr->atype = XML_ATTRIBUTE_ID;\n    attr->id = ret;\n\n    if (id != NULL)\n        *id = ret;\n    return(1);\n}\n",
    "target": 1,
    "idx": 1066446,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n#ifdef DEBUG_READER\n    fprintf(stderr, \"\\nREAD \");\n    DUMP_READER\n#endif\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\treader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n\t}\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    xmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))\n\txmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n#ifdef LIBXML_DOCB_ENABLED\n\t(reader->node->type == XML_DOCB_DOCUMENT_NODE) ||\n#endif\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    DUMP_READER\n\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return -1;\n\txmlXIncludeProcessNode(reader->xincctxt, reader->node);\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    xmlTextReaderEntPush(reader, reader->node);\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    xmlTextReaderValidatePush(reader);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n\n\n// target function\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n#ifdef DEBUG_READER\n    fprintf(stderr, \"\\nREAD \");\n    DUMP_READER\n#endif\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\treader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n\t}\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    xmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))\n\txmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n#ifdef LIBXML_DOCB_ENABLED\n\t(reader->node->type == XML_DOCB_DOCUMENT_NODE) ||\n#endif\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    DUMP_READER\n\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return -1;\n\txmlXIncludeProcessNode(reader->xincctxt, reader->node);\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    xmlTextReaderEntPush(reader, reader->node);\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    xmlTextReaderValidatePush(reader);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n",
    "target": 1,
    "idx": 1025210,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint __cil_verify_class(struct cil_tree_node *node)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_class *class = node->data;\n\n\tif (class->common != NULL) {\n\t\tstruct cil_class *common = class->common;\n\t\tstruct cil_tree_node *common_node = common->datum.nodes->head->data;\n\t\tstruct cil_tree_node *curr_com_perm = NULL;\n\n\t\tfor (curr_com_perm = common_node->cl_head;\n\t\t\tcurr_com_perm != NULL;\n\t\t\tcurr_com_perm = curr_com_perm->next) {\n\t\t\tstruct cil_perm *com_perm = curr_com_perm->data;\n\t\t\tstruct cil_tree_node *curr_class_perm = NULL;\n\n\t\t\tfor (curr_class_perm = node->cl_head;\n\t\t\t\tcurr_class_perm != NULL;\n\t\t\t\tcurr_class_perm = curr_class_perm->next) {\n\t\t\t\tstruct cil_perm *class_perm = curr_class_perm->data;\n\n\t\t\t\tif (com_perm->datum.name == class_perm->datum.name) {\n\t\t\t\t\tcil_log(CIL_ERR, \"Duplicate permissions between %s common and class declarations\\n\", class_perm->datum.name);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(node, CIL_ERR, \"Invalid class\");\n\treturn rc;\n}\n\nstatic int __verify_map_perm_classperms(__attribute__((unused)) hashtab_key_t k, hashtab_datum_t d, void *args)\n{\n\tstruct cil_verify_map_args *map_args = args;\n\tstruct cil_perm *cmp = (struct cil_perm *)d;\n\n\tmap_args->rc = __cil_verify_classperms(cmp->classperms, &cmp->datum, &map_args->class->datum, &cmp->datum, CIL_MAP_PERM, 0, 2);\n\n\treturn SEPOL_OK;\n}\n\nint hashtab_map(hashtab_t h,\n\t\tint (*apply) (hashtab_key_t k,\n\t\t\t      hashtab_datum_t d, void *args), void *args)\n{\n\tunsigned int i, ret;\n\thashtab_ptr_t cur;\n\n\tif (!h)\n\t\treturn SEPOL_OK;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur != NULL) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn SEPOL_OK;\n}\n\nint cil_symtab_map(symtab_t *symtab,\n\t\t\t\t   int (*apply) (hashtab_key_t k, hashtab_datum_t d, void *args),\n\t\t\t\t   void *args)\n{\n\treturn hashtab_map(symtab->table, apply, args);\n}\n\nstatic int __cil_verify_map_class(struct cil_tree_node *node)\n{\n\tstruct cil_class *mc = node->data;\n\tstruct cil_verify_map_args map_args;\n\n\tmap_args.class = mc;\n\tmap_args.node = node;\n\tmap_args.rc = SEPOL_OK;\n\n\tcil_symtab_map(&mc->perms, __verify_map_perm_classperms, &map_args);\n\n\tif (map_args.rc != SEPOL_OK) {\n\t\treturn SEPOL_ERR;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_pre_verify_helper(struct cil_tree_node *node, uint32_t *finished, __attribute__((unused)) void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (node->flavor == CIL_MACRO) {\n\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t} else if (node->flavor == CIL_BLOCK) {\n\t\tstruct cil_block *blk = node->data;\n\t\tif (blk->is_abstract == CIL_TRUE) {\n\t\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\t}\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\tswitch (node->flavor) {\n\tcase CIL_USER:\n\t\trc = __cil_verify_user_pre_eval(node);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase CIL_MAP_CLASS:\n\t\trc = __cil_verify_map_class(node);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSION:\n\t\trc = __cil_verify_classpermission(node);\n\t\tbreak;\n\tdefault:\n\t\trc = SEPOL_OK;\n\t\tbreak;\n\t}\n\nexit:\n\treturn rc;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nstatic int cil_pre_verify(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_verify extra_args;\n\n\textra_args.db = db;\n\n\trc = cil_tree_walk(db->ast->root, __cil_pre_verify_helper, NULL, NULL, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n}\n\nint cil_post_process(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_pre_verify(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_post_db(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed post db handling\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_post_verify(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n\t\t\n}\n\nint cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}\n\n\n// target function\nstatic void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}\n",
    "target": 1,
    "idx": 1031124,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n\n    if (doc == NULL) return(-1);\n    if ((attr == NULL) || (attr->id == NULL)) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)\n        return(-1);\n\n    attr->atype = 0;\n    attr->id = NULL;\n\n    return(0);\n}\n\nvoid\nxmlFreeProp(xmlAttrPtr cur) {\n    xmlDictPtr dict = NULL;\n    if (cur == NULL) return;\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {\n\t    xmlRemoveID(cur->doc, cur);\n    }\n    if (cur->children != NULL) xmlFreeNodeList(cur->children);\n    DICT_FREE(cur->name)\n    xmlFree(cur);\n}\n\nvoid\nxmlFreePropList(xmlAttrPtr cur) {\n    xmlAttrPtr next;\n    if (cur == NULL) return;\n    while (cur != NULL) {\n        next = cur->next;\n        xmlFreeProp(cur);\n\tcur = next;\n    }\n}\n\nvoid\nxmlFreeNodeList(xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if (cur->doc != NULL) dict = cur->doc->dict;\n    while (1) {\n        while ((cur->children != NULL) &&\n               (cur->type != XML_DOCUMENT_NODE) &&\n               (cur->type != XML_HTML_DOCUMENT_NODE) &&\n               (cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\tif ((cur->type == XML_DOCUMENT_NODE) ||\n            (cur->type == XML_HTML_DOCUMENT_NODE)) {\n            xmlFreeDoc((xmlDocPtr) cur);\n        } else if (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlFreePropList(cur->properties);\n\t    if ((cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE) &&\n\t\t(cur->content != (xmlChar *) &(cur->properties))) {\n\t\tDICT_FREE(cur->content)\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * When a node is a text node or a comment, it uses a global static\n\t     * variable for the name of the node.\n\t     * Otherwise the node name might come from the document's\n\t     * dictionary\n\t     */\n\t    if ((cur->name != NULL) &&\n\t\t(cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name)\n\t    xmlFree(cur);\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\n\nvoid\nxmlFreeNode(xmlNodePtr cur) {\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return;\n\n    /* use xmlFreeDtd for DTD nodes */\n    if (cur->type == XML_DTD_NODE) {\n\txmlFreeDtd((xmlDtdPtr) cur);\n\treturn;\n    }\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNs((xmlNsPtr) cur);\n        return;\n    }\n    if (cur->type == XML_ATTRIBUTE_NODE) {\n\txmlFreeProp((xmlAttrPtr) cur);\n\treturn;\n    }\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue(cur);\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if (cur->type == XML_ENTITY_DECL) {\n        xmlEntityPtr ent = (xmlEntityPtr) cur;\n\tDICT_FREE(ent->SystemID);\n\tDICT_FREE(ent->ExternalID);\n    }\n    if ((cur->children != NULL) &&\n\t(cur->type != XML_ENTITY_REF_NODE))\n\txmlFreeNodeList(cur->children);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n        (cur->type == XML_XINCLUDE_START) ||\n        (cur->type == XML_XINCLUDE_END)) {\n        if (cur->properties != NULL)\n            xmlFreePropList(cur->properties);\n        if (cur->nsDef != NULL)\n            xmlFreeNsList(cur->nsDef);\n    } else if ((cur->content != NULL) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->content != (xmlChar *) &(cur->properties))) {\n        DICT_FREE(cur->content)\n    }\n\n    /*\n     * When a node is a text node or a comment, it uses a global static\n     * variable for the name of the node.\n     * Otherwise the node name might come from the document's dictionary\n     */\n    if ((cur->name != NULL) &&\n        (cur->type != XML_TEXT_NODE) &&\n        (cur->type != XML_COMMENT_NODE))\n\tDICT_FREE(cur->name)\n\n    xmlFree(cur);\n}\n\nstatic xmlNodePtr\nxmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n                    int hasTextDecl, int buildTree) {\n    xmlNodePtr root = NULL;\n    xmlNodePtr list = NULL;\n    xmlChar *rootName = BAD_CAST \"#root\";\n    int result;\n\n    if (buildTree) {\n        root = xmlNewDocNode(ctxt->myDoc, NULL, rootName, NULL);\n        if (root == NULL) {\n            xmlErrMemory(ctxt);\n            goto error;\n        }\n    }\n\n    if (xmlPushInput(ctxt, input) < 0)\n        goto error;\n\n    nameNsPush(ctxt, rootName, NULL, NULL, 0, 0);\n    spacePush(ctxt, -1);\n\n    if (buildTree)\n        nodePush(ctxt, root);\n\n    if (hasTextDecl) {\n        xmlDetectEncoding(ctxt);\n\n        /*\n         * Parse a possible text declaration first\n         */\n        if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n            (IS_BLANK_CH(NXT(5)))) {\n            xmlParseTextDecl(ctxt);\n            /*\n             * An XML-1.0 document can't reference an entity not XML-1.0\n             */\n            if ((xmlStrEqual(ctxt->version, BAD_CAST \"1.0\")) &&\n                (!xmlStrEqual(ctxt->input->version, BAD_CAST \"1.0\"))) {\n                xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,\n                               \"Version mismatch between document and \"\n                               \"entity\\n\");\n            }\n        }\n    }\n\n    xmlParseContentInternal(ctxt);\n\n    if (ctxt->input->cur < ctxt->input->end)\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n\n    if ((ctxt->wellFormed) ||\n        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n        if (root != NULL) {\n            xmlNodePtr cur;\n\n            /*\n             * Return the newly created nodeset after unlinking it from\n             * its pseudo parent.\n             */\n            cur = root->children;\n            list = cur;\n            while (cur != NULL) {\n                cur->parent = NULL;\n                cur = cur->next;\n            }\n            root->children = NULL;\n            root->last = NULL;\n        }\n    }\n\n    /*\n     * Read the rest of the stream in case of errors. We want\n     * to account for the whole entity size.\n     */\n    do {\n        ctxt->input->cur = ctxt->input->end;\n        xmlParserShrink(ctxt);\n        result = xmlParserGrow(ctxt);\n    } while (result > 0);\n\n    if (buildTree)\n        nodePop(ctxt);\n\n    namePop(ctxt);\n    spacePop(ctxt);\n\n    /* xmlPopInput would free the stream */\n    inputPop(ctxt);\n\nerror:\n    xmlFreeNode(root);\n\n    return(list);\n}\n\nstatic void\nxmlCtxtParseEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {\n    xmlParserInputPtr input;\n    xmlNodePtr list;\n    unsigned long consumed;\n    int isExternal;\n    int buildTree;\n    int oldMinNsIndex;\n    int oldNodelen, oldNodemem;\n\n    isExternal = (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY);\n    buildTree = (ctxt->node != NULL);\n\n    /*\n     * Recursion check\n     */\n    if (ent->flags & XML_ENT_EXPANDING) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        xmlHaltParser(ctxt);\n        goto error;\n    }\n\n    /*\n     * Load entity\n     */\n    input = xmlNewEntityInputStream(ctxt, ent);\n    if (input == NULL)\n        goto error;\n\n    /*\n     * When building a tree, we need to limit the scope of namespace\n     * declarations, so that entities don't reference xmlNs structs\n     * from the parent of a reference.\n     */\n    oldMinNsIndex = ctxt->nsdb->minNsIndex;\n    if (buildTree)\n        ctxt->nsdb->minNsIndex = ctxt->nsNr;\n\n    oldNodelen = ctxt->nodelen;\n    oldNodemem = ctxt->nodemem;\n    ctxt->nodelen = 0;\n    ctxt->nodemem = 0;\n\n    /*\n     * Parse content\n     *\n     * This initiates a recursive call chain:\n     *\n     * - xmlCtxtParseContent\n     * - xmlParseContentInternal\n     * - xmlParseReference\n     * - xmlCtxtParseEntity\n     *\n     * The nesting depth is limited by the maximum number of inputs,\n     * see xmlPushInput.\n     *\n     * It's possible to make this non-recursive (minNsIndex must be\n     * stored in the input struct) at the expense of code readability.\n     */\n\n    ent->flags |= XML_ENT_EXPANDING;\n\n    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);\n\n    ent->flags &= ~XML_ENT_EXPANDING;\n\n    ctxt->nsdb->minNsIndex = oldMinNsIndex;\n    ctxt->nodelen = oldNodelen;\n    ctxt->nodemem = oldNodemem;\n\n    /*\n     * Entity size accounting\n     */\n    consumed = input->consumed;\n    xmlSaturatedAddSizeT(&consumed, input->end - input->base);\n\n    if ((ent->flags & XML_ENT_CHECKED) == 0)\n        xmlSaturatedAdd(&ent->expandedSize, consumed);\n\n    if ((ent->flags & XML_ENT_PARSED) == 0) {\n        if (isExternal)\n            xmlSaturatedAdd(&ctxt->sizeentities, consumed);\n\n        ent->children = list;\n\n        while (list != NULL) {\n            list->parent = (xmlNodePtr) ent;\n            if (list->next == NULL)\n                ent->last = list;\n            list = list->next;\n        }\n    } else {\n        xmlFreeNodeList(list);\n    }\n\n    xmlFreeInputStream(input);\n\nerror:\n    ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n}\n\n\n\nint\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    size_t curBase;\n    size_t maxLength;\n    int end_in_lf = 0;\n\n    if ((ctxt == NULL) || (size < 0))\n        return(XML_ERR_ARGUMENT);\n    if (ctxt->disableSAX != 0)\n        return(ctxt->errNo);\n    if (ctxt->input == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt->input->flags |= XML_INPUT_PROGRESSIVE;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlCtxtInitializeLate(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n\n    curBase = ctxt->input->cur - ctxt->input->base;\n    maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                XML_MAX_HUGE_LENGTH :\n                XML_MAX_LOOKUP_LIMIT;\n    if (curBase > maxLength) {\n        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n                    \"Buffer size limit exceeded, try XML_PARSE_HUGE\\n\");\n        xmlHaltParser(ctxt);\n    }\n\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n            ctxt->instate = XML_PARSER_EOF;\n            xmlFinishDocument(ctxt);\n\t}\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}\n\nstatic int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlCtxtErrIO(reader->ctxt, reader->input->error, NULL);\n                    reader->mode = XML_TEXTREADER_MODE_ERROR;\n                    reader->state = XML_TEXTREADER_ERROR;\n                    return(-1);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}\n\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n\n\n// target function\nint\nxmlAddIDSafe(xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr,\n             int streaming, xmlIDPtr *id) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (id != NULL)\n        *id = NULL;\n\n    if (doc == NULL) {\n\treturn(-1);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(0);\n    }\n    if (attr == NULL) {\n\treturn(-1);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n        if (table == NULL)\n            return(-1);\n    } else {\n        ret = xmlHashLookup(table, value);\n        if (ret != NULL) {\n            /*\n             * Update the attribute to make entities work.\n             */\n            if (ret->attr != NULL) {\n                ret->attr->id = NULL;\n                ret->attr = attr;\n            }\n\t    attr->atype = XML_ATTRIBUTE_ID;\n            attr->id = ret;\n            return(0);\n        }\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL)\n\treturn(-1);\n    memset(ret, 0, sizeof(*ret));\n\n    /*\n     * fill the structure.\n     */\n    ret->doc = doc;\n    ret->value = xmlStrdup(value);\n    if (ret->value == NULL) {\n        xmlFreeID(ret);\n        return(-1);\n    }\n    if (streaming) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n        if (ret->name == NULL) {\n            xmlFreeID(ret);\n            return(-1);\n        }\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n\txmlFreeID(ret);\n\treturn(-1);\n    }\n\n    attr->atype = XML_ATTRIBUTE_ID;\n    if (!streaming)\n        attr->id = ret;\n\n    if (id != NULL)\n        *id = ret;\n    return(1);\n}\n",
    "target": 1,
    "idx": 1066502,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint sc_file_valid(const sc_file_t *file) {\n\tif (file == NULL)\n\t\treturn 0;\n\treturn file->magic == SC_FILE_MAGIC;\n}\n\nvoid sc_file_free(sc_file_t *file)\n{\n\tunsigned int i;\n\tif (file == NULL || !sc_file_valid(file))\n\t\treturn;\n\tfile->magic = 0;\n\tfor (i = 0; i < SC_MAX_AC_OPS; i++)\n\t\tsc_file_clear_acl_entries(file, i);\n\tif (file->sec_attr)\n\t\tfree(file->sec_attr);\n\tif (file->prop_attr)\n\t\tfree(file->prop_attr);\n\tif (file->type_attr)\n\t\tfree(file->type_attr);\n\tif (file->encoded_content)\n\t\tfree(file->encoded_content);\n\tfree(file);\n}\n\nstatic int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii, nobjs;\n\n\t\tif (acl == NULL) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\n\t\tnobjs = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (nobjs < 1) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_DATA_OBJECT_NOT_FOUND,\n\t\t\t\t\"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii = 0; ii < nobjs; ii++) {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t}\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\nstatic int\nsc_pkcs15emu_oberthur_init(struct sc_pkcs15_card * p15card)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_auth_info auth_info;\n\tstruct sc_pkcs15_object   obj;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_path path;\n\tint rv, ii, tries_left;\n\tchar serial[0x10];\n\tunsigned char sopin_reference = 0x04;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_bin_to_hex(card->serialnr.value, card->serialnr.len, serial, sizeof(serial), 0);\n\tset_string(&p15card->tokeninfo->serial_number, serial);\n\n\tp15card->ops.parse_df = sc_awp_parse_df;\n\tp15card->ops.clear = sc_awp_clear;\n\n\tsc_log(ctx, \"Oberthur init: serial %s\", p15card->tokeninfo->serial_number);\n\n\tsc_format_path(AWP_PIN_DF, &path);\n\trv = sc_select_file(card, &path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot select PIN dir\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tsopin_reference = 0x84;\n\t\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\t}\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)\n\t\tLOG_TEST_RET(ctx, rv, \"Invalid state of SO-PIN\");\n\n\t/* add PIN */\n\tmemset(&auth_info, 0, sizeof(auth_info));\n\tmemset(&obj,  0, sizeof(obj));\n\n\tauth_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tauth_info.auth_method\t= SC_AC_CHV;\n\tauth_info.auth_id.len = 1;\n\tauth_info.auth_id.value[0] = 0xFF;\n\tauth_info.attrs.pin.min_length\t\t= 4;\n\tauth_info.attrs.pin.max_length\t\t= 64;\n\tauth_info.attrs.pin.stored_length\t= 64;\n\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tauth_info.attrs.pin.reference\t\t= sopin_reference;\n\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t| SC_PKCS15_PIN_FLAG_SO_PIN;\n\tauth_info.tries_left\t\t= tries_left;\n\tauth_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tstrncpy(obj.label, \"SO PIN\", SC_PKCS15_MAX_LABEL_SIZE-1);\n\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, 0x81, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv == SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\t/* add PIN */\n\t\tmemset(&auth_info, 0, sizeof(auth_info));\n\t\tmemset(&obj,  0, sizeof(obj));\n\n\t\tauth_info.auth_id.len = sizeof(PinDomainID) > sizeof(auth_info.auth_id.value)\n\t\t\t\t? sizeof(auth_info.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(auth_info.auth_id.value, PinDomainID, auth_info.auth_id.len);\n\t\tauth_info.auth_method\t= SC_AC_CHV;\n\n\t\tauth_info.attrs.pin.min_length\t\t= 4;\n\t\tauth_info.attrs.pin.max_length\t\t= 64;\n\t\tauth_info.attrs.pin.stored_length\t= 64;\n\t\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tauth_info.attrs.pin.reference\t\t= 0x81;\n\t\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\t\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_LOCAL;\n\t\tauth_info.tries_left\t\t= tries_left;\n\n\t\tstrncpy(obj.label, PIN_DOMAIN_LABEL, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\t\tif (sopin_reference == 0x84) {\n\t\t\t/*\n\t\t\t * auth_pin_reset_oberthur_style() in card-oberthur.c\n\t\t\t * always uses PUK with reference 0x84 for\n\t\t\t * unblocking of User PIN\n\t\t\t */\n\t\t\tobj.auth_id.len = 1;\n\t\t\tobj.auth_id.value[0] = 0xFF;\n\t\t}\n\n\t\tsc_format_path(AWP_PIN_DF, &auth_info.path);\n\t\tauth_info.path.type = SC_PATH_TYPE_PATH;\n\n\t\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\t\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\t}\n\telse if (rv != SC_ERROR_DATA_OBJECT_NOT_FOUND)    {\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot verify PIN\");\n\t}\n\n\tfor (ii=0; oberthur_infos[ii].name; ii++)   {\n\t\tsc_log(ctx, \"Oberthur init: read %s file\", oberthur_infos[ii].name);\n\t\tfree(oberthur_infos[ii].content);\n\t\trv = sc_oberthur_read_file(p15card, oberthur_infos[ii].path,\n\t\t\t\t&oberthur_infos[ii].content, &oberthur_infos[ii].len, 1);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: read oberthur file error\");\n\n\t\tsc_log(ctx,\n\t\t       \"Oberthur init: parse %s file, content length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       oberthur_infos[ii].name, oberthur_infos[ii].len);\n\t\trv = oberthur_infos[ii].parser(p15card, oberthur_infos[ii].content, oberthur_infos[ii].len,\n\t\t\t\toberthur_infos[ii].postpone_allowed);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: parse error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\nint\nsc_pkcs15emu_oberthur_init_ex(struct sc_pkcs15_card * p15card, struct sc_aid *aid)\n{\n\tint rv;\n\n\tLOG_FUNC_CALLED(p15card->card->ctx);\n\trv = oberthur_detect_card(p15card);\n\tif (!rv)\n\t\trv = sc_pkcs15emu_oberthur_init(p15card);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\n\nint\nsc_pkcs15_bind_synthetic(sc_pkcs15_card_t *p15card, struct sc_aid *aid)\n{\n\tsc_context_t\t\t*ctx = p15card->card->ctx;\n\tscconf_block\t\t*conf_block, **blocks, *blk;\n\tint\t\t\ti, r = SC_ERROR_WRONG_CARD;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tconf_block = NULL;\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\n\tif (!conf_block) {\n\t\t/* no conf file found => try builtin drivers  */\n\t\tsc_log(ctx, \"no conf file (or section), trying all builtin emulators\");\n\t\tfor (i = 0; builtin_emulators[i].name; i++) {\n\t\t\tsc_log(ctx, \"trying %s\", builtin_emulators[i].name);\n\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t/* we got a hit */\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* we have a conf file => let's use it */\n\t\tint builtin_enabled;\n\t\tconst scconf_list *list, *item;\n\n\t\tbuiltin_enabled = scconf_get_bool(conf_block, \"enable_builtin_emulation\", 1);\n\t\tlist = scconf_find_list(conf_block, \"builtin_emulators\"); /* FIXME: rename to enabled_emulators */\n\n\t\tif (builtin_enabled && list) {\n\t\t\t/* get the list of enabled emulation drivers */\n\t\t\tfor (item = list; item; item = item->next) {\n\t\t\t\t/* go through the list of builtin drivers */\n\t\t\t\tconst char *name = item->data;\n\n\t\t\t\tsc_log(ctx, \"trying %s\", name);\n\t\t\t\tfor (i = 0; builtin_emulators[i].name; i++)\n\t\t\t\t\tif (!strcmp(builtin_emulators[i].name, name)) {\n\t\t\t\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\t\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t\t\t\t/* we got a hit */\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (builtin_enabled) {\n\t\t\tsc_log(ctx, \"no emulator list in config file, trying all builtin emulators\");\n\t\t\tfor (i = 0; builtin_emulators[i].name; i++) {\n\t\t\t\tsc_log(ctx, \"trying %s\", builtin_emulators[i].name);\n\t\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t\t/* we got a hit */\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* search for 'emulate foo { ... }' entries in the conf file */\n\t\tsc_log(ctx, \"searching for 'emulate foo { ... }' blocks\");\n\t\tblocks = scconf_find_blocks(ctx->conf, conf_block, \"emulate\", NULL);\n\t\tsc_log(ctx, \"Blocks: %p\", blocks);\n\t\tfor (i = 0; blocks && (blk = blocks[i]) != NULL; i++) {\n\t\t\tconst char *name = blk->name->data;\n\t\t\tsc_log(ctx, \"trying %s\", name);\n\t\t\tr = parse_emu_block(p15card, aid, blk);\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tfree(blocks);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (blocks)\n\t\t\tfree(blocks);\n\t}\n\nout:\n\tif (r == SC_SUCCESS) {\n\t\tp15card->magic  = SC_PKCS15_CARD_MAGIC;\n\t\tp15card->flags |= SC_PKCS15_CARD_FLAG_EMULATED;\n\t} else {\n\t\tif (r != SC_ERROR_WRONG_CARD)\n\t\t\tsc_log(ctx, \"Failed to load card emulator: %s\", sc_strerror(r));\n\t}\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nint\nsc_pkcs15_bind(struct sc_card *card, struct sc_aid *aid,\n\t\tstruct sc_pkcs15_card **p15card_out)\n{\n\tstruct sc_pkcs15_card *p15card = NULL;\n\tstruct sc_context *ctx;\n\tscconf_block *conf_block = NULL;\n\tint r, emu_first, enable_emu;\n\tconst char *private_certificate;\n\n\tif (card == NULL || p15card_out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tctx = card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"application(aid:'%s')\", aid ? sc_dump_hex(aid->value, aid->len) : \"empty\");\n\n\tp15card = sc_pkcs15_card_new();\n\tif (p15card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tp15card->card = card;\n\tp15card->opts.use_file_cache = 0;\n\tp15card->opts.use_pin_cache = 1;\n\tp15card->opts.pin_cache_counter = 10;\n\tp15card->opts.pin_cache_ignore_user_consent = 0;\n\tif(0 == strcmp(ctx->app_name, \"tokend\")) {\n\t\tprivate_certificate = \"ignore\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else {\n\t\tprivate_certificate = \"protect\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t}\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\tif (conf_block) {\n\t\tp15card->opts.use_file_cache = scconf_get_bool(conf_block, \"use_file_caching\", p15card->opts.use_file_cache);\n\t\tp15card->opts.use_pin_cache = scconf_get_bool(conf_block, \"use_pin_caching\", p15card->opts.use_pin_cache);\n\t\tp15card->opts.pin_cache_counter = scconf_get_int(conf_block, \"pin_cache_counter\", p15card->opts.pin_cache_counter);\n\t\tp15card->opts.pin_cache_ignore_user_consent = scconf_get_bool(conf_block, \"pin_cache_ignore_user_consent\",\n\t\t\t\tp15card->opts.pin_cache_ignore_user_consent);\n\t\tprivate_certificate = scconf_get_str(conf_block, \"private_certificate\", private_certificate);\n\t}\n\tif (0 == strcmp(private_certificate, \"protect\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t} else if (0 == strcmp(private_certificate, \"ignore\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else if (0 == strcmp(private_certificate, \"declassify\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_DECLASSIFY;\n\t}\n\tsc_log(ctx, \"PKCS#15 options: use_file_cache=%d use_pin_cache=%d pin_cache_counter=%d pin_cache_ignore_user_consent=%d private_certificate=%d\",\n\t\t\tp15card->opts.use_file_cache, p15card->opts.use_pin_cache,p15card->opts.pin_cache_counter,\n\t\t\tp15card->opts.pin_cache_ignore_user_consent, p15card->opts.private_certificate);\n\n\tr = sc_lock(card);\n\tif (r) {\n\t\tsc_log(ctx, \"sc_lock() failed: %s\", sc_strerror(r));\n\t\tsc_pkcs15_card_free(p15card);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tenable_emu = scconf_get_bool(conf_block, \"enable_pkcs15_emulation\", 1);\n\tif (enable_emu) {\n\t\tsc_log(ctx, \"PKCS#15 emulation enabled\");\n\t\temu_first = scconf_get_bool(conf_block, \"try_emulation_first\", 0);\n\t\tif (emu_first || sc_pkcs15_is_emulation_only(card)) {\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\telse {\n\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t}\ndone:\n\t*p15card_out = p15card;\n\tsc_unlock(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerror:\n\tsc_unlock(card);\n\tsc_pkcs15_card_free(p15card);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\n\n// target function\nstatic int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\tif (acl == NULL) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t}\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n",
    "target": 1,
    "idx": 1028843,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n%  CloseBlob() closes a stream associated with the image.\n%\n%  The format of the CloseBlob method is:\n%\n%      MagickBooleanType CloseBlob(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType CloseBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    status;\n\n  /*\n    Close image file.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  blob_info=image->blob;\n  if ((blob_info == (BlobInfo *) NULL) || (blob_info->type == UndefinedStream))\n    return(MagickTrue);\n  status=SyncBlob(image);\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      if (blob_info->synchronize != MagickFalse)\n        status=fsync(fileno(blob_info->file_info.file));\n      status=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&status);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&status);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      if (blob_info->file_info.file != (FILE *) NULL)\n        {\n          if (blob_info->synchronize != MagickFalse)\n            status=fsync(fileno(blob_info->file_info.file));\n          status=ferror(blob_info->file_info.file);\n        }\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  blob_info->status=status < 0 ? MagickTrue : MagickFalse;\n  blob_info->size=GetBlobSize(image);\n  image->extent=blob_info->size;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->mode=UndefinedBlobMode;\n  if (blob_info->exempt != MagickFalse)\n    {\n      blob_info->type=UndefinedStream;\n      return(blob_info->status);\n    }\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    {\n      status=fclose(blob_info->file_info.file);\n      break;\n    }\n    case PipeStream:\n    {\n#if defined(MAGICKCORE_HAVE_PCLOSE)\n      status=pclose(blob_info->file_info.file);\n#endif\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      status=gzclose(blob_info->file_info.gzfile);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      BZ2_bzclose(blob_info->file_info.bzfile);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n\n\n\n\n\n\n\n\n\nvoid Magick::Image::ping(const Blob& blob_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=PingBlob(imageInfo(),blob_.data(),blob_.length(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\n\n// target function\n%  CloseBlob() closes a stream associated with the image.\n%\n%  The format of the CloseBlob method is:\n%\n%      MagickBooleanType CloseBlob(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType CloseBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    status;\n\n  /*\n    Close image file.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  blob_info=image->blob;\n  if (blob_info->type == UndefinedStream)\n    return(MagickTrue);\n  status=SyncBlob(image);\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      if (blob_info->synchronize != MagickFalse)\n        status=fsync(fileno(blob_info->file_info.file));\n      status=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&status);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&status);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      if (blob_info->file_info.file != (FILE *) NULL)\n        {\n          if (blob_info->synchronize != MagickFalse)\n            status=fsync(fileno(blob_info->file_info.file));\n          status=ferror(blob_info->file_info.file);\n        }\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  blob_info->status=status < 0 ? MagickTrue : MagickFalse;\n  blob_info->size=GetBlobSize(image);\n  image->extent=blob_info->size;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->mode=UndefinedBlobMode;\n  if (blob_info->exempt != MagickFalse)\n    {\n      blob_info->type=UndefinedStream;\n      return(blob_info->status);\n    }\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    {\n      status=fclose(blob_info->file_info.file);\n      break;\n    }\n    case PipeStream:\n    {\n#if defined(MAGICKCORE_HAVE_PCLOSE)\n      status=pclose(blob_info->file_info.file);\n#endif\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      status=gzclose(blob_info->file_info.gzfile);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      BZ2_bzclose(blob_info->file_info.bzfile);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n",
    "target": 1,
    "idx": 1008287,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic __inline int CRYPTO_DOWN_REF(volatile int *val, int *ret, void *lock)\n{\n    *ret = _InterlockedExchangeAdd(val, -1) - 1;\n    return 1;\n}\n\nvoid DH_free(DH *r)\n{\n    int i;\n\n    if (r == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(&r->references, &i, r->lock);\n    REF_PRINT_COUNT(\"DH\", r);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n\n    if (r->meth != NULL && r->meth->finish != NULL)\n        r->meth->finish(r);\n#if !defined(FIPS_MODE)\n# if !defined(OPENSSL_NO_ENGINE)\n    ENGINE_finish(r->engine);\n# endif\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DH, r, &r->ex_data);\n#endif\n\n    CRYPTO_THREAD_lock_free(r->lock);\n\n    ffc_params_cleanup(&r->params);\n    BN_clear_free(r->pub_key);\n    BN_clear_free(r->priv_key);\n    OPENSSL_free(r);\n}\n\nvoid evp_pkey_free_legacy(EVP_PKEY *x)\n{\n    if (x->ameth != NULL) {\n        if (x->ameth->pkey_free != NULL)\n            x->ameth->pkey_free(x);\n        x->pkey.ptr = NULL;\n    }\n# ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(x->engine);\n    x->engine = NULL;\n    ENGINE_finish(x->pmeth_engine);\n    x->pmeth_engine = NULL;\n# endif\n    x->type = EVP_PKEY_NONE;\n}\n\nstatic void evp_pkey_free_it(EVP_PKEY *x)\n{\n    /* internal function; x is never NULL */\n\n    evp_keymgmt_util_clear_operation_cache(x);\n#ifndef FIPS_MODE\n    evp_pkey_free_legacy(x);\n#endif\n\n    if (x->keymgmt != NULL) {\n        evp_keymgmt_freedata(x->keymgmt, x->keydata);\n        EVP_KEYMGMT_free(x->keymgmt);\n        x->keymgmt = NULL;\n        x->keydata = NULL;\n    }\n}\n\nvoid EVP_PKEY_free(EVP_PKEY *x)\n{\n    int i;\n\n    if (x == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(&x->references, &i, x->lock);\n    REF_PRINT_COUNT(\"EVP_PKEY\", x);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n    evp_pkey_free_it(x);\n    CRYPTO_THREAD_lock_free(x->lock);\n#ifndef FIPS_MODE\n    sk_X509_ATTRIBUTE_pop_free(x->attributes, X509_ATTRIBUTE_free);\n#endif\n    OPENSSL_free(x);\n}\n\nstatic int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey)\n{\n#ifndef OPENSSL_NO_DH\n    PACKET prime, generator, pub_key;\n    EVP_PKEY *peer_tmp = NULL;\n\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;\n\n    int check_bits = 0;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    peer_tmp = EVP_PKEY_new();\n    dh = DH_new();\n\n    if (peer_tmp == NULL || dh == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* TODO(size_t): Convert these calls */\n    p = BN_bin2bn(PACKET_data(&prime), (int)PACKET_remaining(&prime), NULL);\n    g = BN_bin2bn(PACKET_data(&generator), (int)PACKET_remaining(&generator),\n                  NULL);\n    bnpub_key = BN_bin2bn(PACKET_data(&pub_key),\n                          (int)PACKET_remaining(&pub_key), NULL);\n    if (p == NULL || g == NULL || bnpub_key == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* test non-zero pubkey */\n    if (BN_is_zero(bnpub_key)) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_pqg(dh, p, NULL, g)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    p = g = NULL;\n\n    if (DH_check_params(dh, &check_bits) == 0 || check_bits != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_key(dh, bnpub_key, NULL)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    bnpub_key = NULL;\n\n    if (EVP_PKEY_assign_DH(peer_tmp, dh) == 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n    dh = NULL;\n\n    if (!ssl_security(s, SSL_SECOP_TMP_DH, EVP_PKEY_security_bits(peer_tmp),\n                      0, EVP_PKEY_get0_DH(peer_tmp))) {\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_DH_KEY_TOO_SMALL);\n        goto err;\n    }\n\n    s->s3.peer_tmp = peer_tmp;\n\n    /*\n     * FIXME: This makes assumptions about which ciphersuites come with\n     * public keys. We should have a less ad-hoc way of doing this\n     */\n    if (s->s3.tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous DH, so no certificate or pkey. */\n\n    return 1;\n\n err:\n    BN_free(p);\n    BN_free(g);\n    BN_free(bnpub_key);\n    DH_free(dh);\n    EVP_PKEY_free(peer_tmp);\n\n    return 0;\n#else\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n             ERR_R_INTERNAL_ERROR);\n    return 0;\n#endif\n}\n\nMSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)\n{\n    long alg_k;\n    EVP_PKEY *pkey = NULL;\n    EVP_MD_CTX *md_ctx = NULL;\n    EVP_PKEY_CTX *pctx = NULL;\n    PACKET save_param_start, signature;\n\n    alg_k = s->s3.tmp.new_cipher->algorithm_mkey;\n\n    save_param_start = *pkt;\n\n#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)\n    EVP_PKEY_free(s->s3.peer_tmp);\n    s->s3.peer_tmp = NULL;\n#endif\n\n    if (alg_k & SSL_PSK) {\n        if (!tls_process_ske_psk_preamble(s, pkt)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    }\n\n    /* Nothing else to do for plain PSK or RSAPSK */\n    if (alg_k & (SSL_kPSK | SSL_kRSAPSK)) {\n    } else if (alg_k & SSL_kSRP) {\n        if (!tls_process_ske_srp(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {\n        if (!tls_process_ske_dhe(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        if (!tls_process_ske_ecdhe(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                 SSL_R_UNEXPECTED_MESSAGE);\n        goto err;\n    }\n\n    /* if it was signed, check the signature */\n    if (pkey != NULL) {\n        PACKET params;\n        const EVP_MD *md = NULL;\n        unsigned char *tbs;\n        size_t tbslen;\n        int rv;\n\n        /*\n         * |pkt| now points to the beginning of the signature, so the difference\n         * equals the length of the parameters.\n         */\n        if (!PACKET_get_sub_packet(&save_param_start, &params,\n                                   PACKET_remaining(&save_param_start) -\n                                   PACKET_remaining(pkt))) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (SSL_USE_SIGALGS(s)) {\n            unsigned int sigalg;\n\n            if (!PACKET_get_net_2(pkt, &sigalg)) {\n                SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                         SSL_R_LENGTH_TOO_SHORT);\n                goto err;\n            }\n            if (tls12_check_peer_sigalg(s, sigalg, pkey) <=0) {\n                /* SSLfatal() already called */\n                goto err;\n            }\n        } else if (!tls1_set_peer_legacy_sigalg(s, pkey)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (!tls1_lookup_md(s->ctx, s->s3.tmp.peer_sigalg, &md)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        if (SSL_USE_SIGALGS(s))\n            OSSL_TRACE1(TLS, \"USING TLSv1.2 HASH %s\\n\",\n                        md == NULL ? \"n/a\" : EVP_MD_name(md));\n\n        if (!PACKET_get_length_prefixed_2(pkt, &signature)\n            || PACKET_remaining(pkt) != 0) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        md_ctx = EVP_MD_CTX_new();\n        if (md_ctx == NULL) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        if (EVP_DigestVerifyInit(md_ctx, &pctx, md, NULL, pkey) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_EVP_LIB);\n            goto err;\n        }\n        if (SSL_USE_PSS(s)) {\n            if (EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PSS_PADDING) <= 0\n                || EVP_PKEY_CTX_set_rsa_pss_saltlen(pctx,\n                                                RSA_PSS_SALTLEN_DIGEST) <= 0) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_EVP_LIB);\n                goto err;\n            }\n        }\n        tbslen = construct_key_exchange_tbs(s, &tbs, PACKET_data(&params),\n                                            PACKET_remaining(&params));\n        if (tbslen == 0) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n\n        rv = EVP_DigestVerify(md_ctx, PACKET_data(&signature),\n                              PACKET_remaining(&signature), tbs, tbslen);\n        OPENSSL_free(tbs);\n        if (rv <= 0) {\n            SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_BAD_SIGNATURE);\n            goto err;\n        }\n        EVP_MD_CTX_free(md_ctx);\n        md_ctx = NULL;\n    } else {\n        /* aNULL, aSRP or PSK do not need public keys */\n        if (!(s->s3.tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))\n            && !(alg_k & SSL_PSK)) {\n            /* Might be wrong key type, check it */\n            if (ssl3_check_cert_and_algorithm(s)) {\n                SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                         SSL_R_BAD_DATA);\n            }\n            /* else this shouldn't happen, SSLfatal() already called */\n            goto err;\n        }\n        /* still data left over */\n        if (PACKET_remaining(pkt) != 0) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_EXTRA_DATA_IN_MESSAGE);\n            goto err;\n        }\n    }\n\n    return MSG_PROCESS_CONTINUE_READING;\n err:\n    EVP_MD_CTX_free(md_ctx);\n    return MSG_PROCESS_ERROR;\n}\n\nstatic SUB_STATE_RETURN read_state_machine(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n    int ret, mt;\n    size_t len = 0;\n    int (*transition) (SSL *s, int mt);\n    PACKET pkt;\n    MSG_PROCESS_RETURN(*process_message) (SSL *s, PACKET *pkt);\n    WORK_STATE(*post_process_message) (SSL *s, WORK_STATE wst);\n    size_t (*max_message_size) (SSL *s);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n\n    cb = get_callback(s);\n\n    if (s->server) {\n        transition = ossl_statem_server_read_transition;\n        process_message = ossl_statem_server_process_message;\n        max_message_size = ossl_statem_server_max_message_size;\n        post_process_message = ossl_statem_server_post_process_message;\n    } else {\n        transition = ossl_statem_client_read_transition;\n        process_message = ossl_statem_client_process_message;\n        max_message_size = ossl_statem_client_max_message_size;\n        post_process_message = ossl_statem_client_post_process_message;\n    }\n\n    if (st->read_state_first_init) {\n        s->first_packet = 1;\n        st->read_state_first_init = 0;\n    }\n\n    while (1) {\n        switch (st->read_state) {\n        case READ_STATE_HEADER:\n            /* Get the state the peer wants to move to */\n            if (SSL_IS_DTLS(s)) {\n                /*\n                 * In DTLS we get the whole message in one go - header and body\n                 */\n                ret = dtls_get_message(s, &mt, &len);\n            } else {\n                ret = tls_get_message_header(s, &mt);\n            }\n\n            if (ret == 0) {\n                /* Could be non-blocking IO */\n                return SUB_STATE_ERROR;\n            }\n\n            if (cb != NULL) {\n                /* Notify callback of an impending state change */\n                if (s->server)\n                    cb(s, SSL_CB_ACCEPT_LOOP, 1);\n                else\n                    cb(s, SSL_CB_CONNECT_LOOP, 1);\n            }\n            /*\n             * Validate that we are allowed to move to the new state and move\n             * to that state if so\n             */\n            if (!transition(s, mt))\n                return SUB_STATE_ERROR;\n\n            if (s->s3.tmp.message_size > max_message_size(s)) {\n                SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_READ_STATE_MACHINE,\n                         SSL_R_EXCESSIVE_MESSAGE_SIZE);\n                return SUB_STATE_ERROR;\n            }\n\n            /* dtls_get_message already did this */\n            if (!SSL_IS_DTLS(s)\n                    && s->s3.tmp.message_size > 0\n                    && !grow_init_buf(s, s->s3.tmp.message_size\n                                         + SSL3_HM_HEADER_LENGTH)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                         ERR_R_BUF_LIB);\n                return SUB_STATE_ERROR;\n            }\n\n            st->read_state = READ_STATE_BODY;\n            /* Fall through */\n\n        case READ_STATE_BODY:\n            if (!SSL_IS_DTLS(s)) {\n                /* We already got this above for DTLS */\n                ret = tls_get_message_body(s, &len);\n                if (ret == 0) {\n                    /* Could be non-blocking IO */\n                    return SUB_STATE_ERROR;\n                }\n            }\n\n            s->first_packet = 0;\n            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                return SUB_STATE_ERROR;\n            }\n            ret = process_message(s, &pkt);\n\n            /* Discard the packet data */\n            s->init_num = 0;\n\n            switch (ret) {\n            case MSG_PROCESS_ERROR:\n                check_fatal(s, SSL_F_READ_STATE_MACHINE);\n                return SUB_STATE_ERROR;\n\n            case MSG_PROCESS_FINISHED_READING:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n\n            case MSG_PROCESS_CONTINUE_PROCESSING:\n                st->read_state = READ_STATE_POST_PROCESS;\n                st->read_state_work = WORK_MORE_A;\n                break;\n\n            default:\n                st->read_state = READ_STATE_HEADER;\n                break;\n            }\n            break;\n\n        case READ_STATE_POST_PROCESS:\n            st->read_state_work = post_process_message(s, st->read_state_work);\n            switch (st->read_state_work) {\n            case WORK_ERROR:\n                check_fatal(s, SSL_F_READ_STATE_MACHINE);\n                /* Fall through */\n            case WORK_MORE_A:\n            case WORK_MORE_B:\n            case WORK_MORE_C:\n                return SUB_STATE_ERROR;\n\n            case WORK_FINISHED_CONTINUE:\n                st->read_state = READ_STATE_HEADER;\n                break;\n\n            case WORK_FINISHED_STOP:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n            }\n            break;\n\n        default:\n            /* Shouldn't happen */\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            return SUB_STATE_ERROR;\n        }\n    }\n}\n\nstatic int state_machine(SSL *s, int server)\n{\n    BUF_MEM *buf = NULL;\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n    OSSL_STATEM *st = &s->statem;\n    int ret = -1;\n    int ssret;\n\n    if (st->state == MSG_FLOW_ERROR) {\n        /* Shouldn't have been called if we're already in the error state */\n        return -1;\n    }\n\n    ERR_clear_error();\n    clear_sys_error();\n\n    cb = get_callback(s);\n\n    st->in_handshake++;\n    if (!SSL_in_init(s) || SSL_in_before(s)) {\n        /*\n         * If we are stateless then we already called SSL_clear() - don't do\n         * it again and clear the STATELESS flag itself.\n         */\n        if ((s->s3.flags & TLS1_FLAGS_STATELESS) == 0 && !SSL_clear(s))\n            return -1;\n    }\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        /*\n         * Notify SCTP BIO socket to enter handshake mode and prevent stream\n         * identifier other than 0.\n         */\n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,\n                 st->in_handshake, NULL);\n    }\n#endif\n\n    /* Initialise state machine */\n    if (st->state == MSG_FLOW_UNINITED\n            || st->state == MSG_FLOW_FINISHED) {\n        if (st->state == MSG_FLOW_UNINITED) {\n            st->hand_state = TLS_ST_BEFORE;\n            st->request_state = TLS_ST_BEFORE;\n        }\n\n        s->server = server;\n        if (cb != NULL) {\n            if (SSL_IS_FIRST_HANDSHAKE(s) || !SSL_IS_TLS13(s))\n                cb(s, SSL_CB_HANDSHAKE_START, 1);\n        }\n\n        /*\n         * Fatal errors in this block don't send an alert because we have\n         * failed to even initialise properly. Sending an alert is probably\n         * doomed to failure.\n         */\n\n        if (SSL_IS_DTLS(s)) {\n            if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00) &&\n                (server || (s->version & 0xff00) != (DTLS1_BAD_VER & 0xff00))) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n        } else {\n            if ((s->version >> 8) != SSL3_VERSION_MAJOR) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n        }\n\n        if (!ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) {\n            SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            goto end;\n        }\n\n        if (s->init_buf == NULL) {\n            if ((buf = BUF_MEM_new()) == NULL) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n            if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n            s->init_buf = buf;\n            buf = NULL;\n        }\n\n        if (!ssl3_setup_buffers(s)) {\n            SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            goto end;\n        }\n        s->init_num = 0;\n\n        /*\n         * Should have been reset by tls_process_finished, too.\n         */\n        s->s3.change_cipher_spec = 0;\n\n        /*\n         * Ok, we now need to push on a buffering BIO ...but not with\n         * SCTP\n         */\n#ifndef OPENSSL_NO_SCTP\n        if (!SSL_IS_DTLS(s) || !BIO_dgram_is_sctp(SSL_get_wbio(s)))\n#endif\n            if (!ssl_init_wbio_buffer(s)) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n\n        if ((SSL_in_before(s))\n                || s->renegotiate) {\n            if (!tls_setup_handshake(s)) {\n                /* SSLfatal() already called */\n                goto end;\n            }\n\n            if (SSL_IS_FIRST_HANDSHAKE(s))\n                st->read_state_first_init = 1;\n        }\n\n        st->state = MSG_FLOW_WRITING;\n        init_write_state_machine(s);\n    }\n\n    while (st->state != MSG_FLOW_FINISHED) {\n        if (st->state == MSG_FLOW_READING) {\n            ssret = read_state_machine(s);\n            if (ssret == SUB_STATE_FINISHED) {\n                st->state = MSG_FLOW_WRITING;\n                init_write_state_machine(s);\n            } else {\n                /* NBIO or error */\n                goto end;\n            }\n        } else if (st->state == MSG_FLOW_WRITING) {\n            ssret = write_state_machine(s);\n            if (ssret == SUB_STATE_FINISHED) {\n                st->state = MSG_FLOW_READING;\n                init_read_state_machine(s);\n            } else if (ssret == SUB_STATE_END_HANDSHAKE) {\n                st->state = MSG_FLOW_FINISHED;\n            } else {\n                /* NBIO or error */\n                goto end;\n            }\n        } else {\n            /* Error */\n            check_fatal(s, SSL_F_STATE_MACHINE);\n            SSLerr(SSL_F_STATE_MACHINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n            goto end;\n        }\n    }\n\n    ret = 1;\n\n end:\n    st->in_handshake--;\n\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        /*\n         * Notify SCTP BIO socket to leave handshake mode and allow stream\n         * identifier other than 0.\n         */\n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,\n                 st->in_handshake, NULL);\n    }\n#endif\n\n    BUF_MEM_free(buf);\n    if (cb != NULL) {\n        if (server)\n            cb(s, SSL_CB_ACCEPT_EXIT, ret);\n        else\n            cb(s, SSL_CB_CONNECT_EXIT, ret);\n    }\n    return ret;\n}\n\nint SSL_do_handshake(SSL *s)\n{\n    int ret = 1;\n\n    if (s->handshake_func == NULL) {\n        SSLerr(SSL_F_SSL_DO_HANDSHAKE, SSL_R_CONNECTION_TYPE_NOT_SET);\n        return -1;\n    }\n\n    ossl_statem_check_finish_init(s, -1);\n\n    s->method->ssl_renegotiate_check(s, 0);\n\n    if (SSL_in_init(s) || SSL_in_before(s)) {\n        if ((s->mode & SSL_MODE_ASYNC) && ASYNC_get_current_job() == NULL) {\n            struct ssl_async_args args;\n\n            args.s = s;\n\n            ret = ssl_start_async_job(s, &args, ssl_do_handshake_intern);\n        } else {\n            ret = s->handshake_func(s);\n        }\n    }\n    return ret;\n}\n\nint FuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n    SSL *client;\n    BIO *in;\n    BIO *out;\n    SSL_CTX *ctx;\n\n    if (len == 0)\n        return 0;\n\n    /*\n     * TODO: use the ossltest engine (optionally?) to disable crypto checks.\n     */\n\n    /* This only fuzzes the initial flow from the client so far. */\n    ctx = SSL_CTX_new(SSLv23_method());\n\n    client = SSL_new(ctx);\n    OPENSSL_assert(SSL_set_min_proto_version(client, 0) == 1);\n    OPENSSL_assert(SSL_set_cipher_list(client, \"ALL:eNULL:@SECLEVEL=0\") == 1);\n    SSL_set_tlsext_host_name(client, \"localhost\");\n    in = BIO_new(BIO_s_mem());\n    out = BIO_new(BIO_s_mem());\n    SSL_set_bio(client, in, out);\n    SSL_set_connect_state(client);\n    OPENSSL_assert((size_t)BIO_write(in, buf, len) == len);\n    if (SSL_do_handshake(client) == 1) {\n        /* Keep reading application data until error or EOF. */\n        uint8_t tmp[1024];\n        for (;;) {\n            if (SSL_read(client, tmp, sizeof(tmp)) <= 0) {\n                break;\n            }\n        }\n    }\n    SSL_free(client);\n    ERR_clear_error();\n    SSL_CTX_free(ctx);\n\n    return 0;\n}\n\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (EF->__msan_unpoison)\n    EF->__msan_unpoison(DataCopy, Size);\n  if (EF->__msan_unpoison_param)\n    EF->__msan_unpoison_param(2);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  {\n    ScopedEnableMsanInterceptorChecks S;\n    AllocTracer.Start(Options.TraceMalloc);\n    UnitStartTime = system_clock::now();\n    TPC.ResetMaps();\n    RunningUserCallback = true;\n    int Res = CB(DataCopy, Size);\n    RunningUserCallback = false;\n    UnitStopTime = system_clock::now();\n    (void)Res;\n    assert(Res == 0);\n    HasMoreMallocsThanFrees = AllocTracer.Stop();\n  }\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\n\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\n\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  if (EF->__msan_scoped_disable_interceptor_checks)\n    EF->__msan_scoped_disable_interceptor_checks();\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args, EF);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.LenControl = Flags.len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.IgnoreTimeouts = Flags.ignore_timeouts;\n  Options.IgnoreOOMs = Flags.ignore_ooms;\n  Options.IgnoreCrashes = Flags.ignore_crashes;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.ReduceDepth = Flags.reduce_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  Options.MallocLimitMb = Flags.malloc_limit_mb;\n  if (!Options.MallocLimitMb)\n    Options.MallocLimitMb = Options.RssLimitMb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool RunIndividualFiles = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !RunIndividualFiles || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n  if (Flags.focus_function)\n    Options.FocusFunction = Flags.focus_function;\n  if (Flags.data_flow_trace)\n    Options.DataFlowTrace = Flags.data_flow_trace;\n  if (Flags.features_dir)\n    Options.FeaturesDir = Flags.features_dir;\n  if (Flags.collect_data_flow)\n    Options.CollectDataFlow = Flags.collect_data_flow;\n  if (Flags.stop_file)\n    Options.StopFile = Flags.stop_file;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  if (Flags.collect_data_flow && !Flags.fork && !Flags.merge) {\n    if (RunIndividualFiles)\n      return CollectDataFlow(Flags.collect_data_flow, Flags.data_flow_trace,\n                        ReadCorpora({}, *Inputs));\n    else\n      return CollectDataFlow(Flags.collect_data_flow, Flags.data_flow_trace,\n                        ReadCorpora(*Inputs, {}));\n  }\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n  if (RunIndividualFiles) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.fork)\n    FuzzWithFork(F->GetMD().GetRand(), Options, Args, *Inputs, Flags.fork);\n\n  if (Flags.merge)\n    Merge(F, Options, Args, *Inputs, Flags.merge_control_file);\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis succeeded\\n\");\n    exit(0);\n  }\n\n  auto CorporaFiles = ReadCorpora(*Inputs, ParseSeedInuts(Flags.seed_inputs));\n  F->Loop(CorporaFiles);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\n\nATTRIBUTE_INTERFACE int main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}\n\n\n// target function\nstatic int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey)\n{\n#ifndef OPENSSL_NO_DH\n    PACKET prime, generator, pub_key;\n    EVP_PKEY *peer_tmp = NULL;\n\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;\n\n    int check_bits = 0;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    peer_tmp = EVP_PKEY_new();\n    dh = DH_new();\n\n    if (peer_tmp == NULL || dh == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* TODO(size_t): Convert these calls */\n    p = BN_bin2bn(PACKET_data(&prime), (int)PACKET_remaining(&prime), NULL);\n    g = BN_bin2bn(PACKET_data(&generator), (int)PACKET_remaining(&generator),\n                  NULL);\n    bnpub_key = BN_bin2bn(PACKET_data(&pub_key),\n                          (int)PACKET_remaining(&pub_key), NULL);\n    if (p == NULL || g == NULL || bnpub_key == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* test non-zero pubkey */\n    if (BN_is_zero(bnpub_key)) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_pqg(dh, p, NULL, g)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    p = g = NULL;\n\n    if (DH_check_params(dh, &check_bits) == 0 || check_bits != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_key(dh, bnpub_key, NULL)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    bnpub_key = NULL;\n\n    if (EVP_PKEY_assign_DH(peer_tmp, dh) == 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    if (!ssl_security(s, SSL_SECOP_TMP_DH, EVP_PKEY_security_bits(peer_tmp),\n                      0, dh)) {\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_DH_KEY_TOO_SMALL);\n        goto err;\n    }\n\n    s->s3.peer_tmp = peer_tmp;\n\n    /*\n     * FIXME: This makes assumptions about which ciphersuites come with\n     * public keys. We should have a less ad-hoc way of doing this\n     */\n    if (s->s3.tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous DH, so no certificate or pkey. */\n\n    return 1;\n\n err:\n    BN_free(p);\n    BN_free(g);\n    BN_free(bnpub_key);\n    DH_free(dh);\n    EVP_PKEY_free(peer_tmp);\n\n    return 0;\n#else\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n             ERR_R_INTERNAL_ERROR);\n    return 0;\n#endif\n}\n",
    "target": 1,
    "idx": 1020816,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic __inline int CRYPTO_DOWN_REF(volatile int *val, int *ret, void *lock)\n{\n    *ret = _InterlockedExchangeAdd(val, -1) - 1;\n    return 1;\n}\n\nvoid DH_free(DH *r)\n{\n    int i;\n\n    if (r == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(&r->references, &i, r->lock);\n    REF_PRINT_COUNT(\"DH\", r);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n\n    if (r->meth != NULL && r->meth->finish != NULL)\n        r->meth->finish(r);\n#if !defined(FIPS_MODE)\n# if !defined(OPENSSL_NO_ENGINE)\n    ENGINE_finish(r->engine);\n# endif\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DH, r, &r->ex_data);\n#endif\n\n    CRYPTO_THREAD_lock_free(r->lock);\n\n    ffc_params_cleanup(&r->params);\n    BN_clear_free(r->pub_key);\n    BN_clear_free(r->priv_key);\n    OPENSSL_free(r);\n}\n\nvoid evp_pkey_free_legacy(EVP_PKEY *x)\n{\n    if (x->ameth != NULL) {\n        if (x->ameth->pkey_free != NULL)\n            x->ameth->pkey_free(x);\n        x->pkey.ptr = NULL;\n    }\n# ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(x->engine);\n    x->engine = NULL;\n    ENGINE_finish(x->pmeth_engine);\n    x->pmeth_engine = NULL;\n# endif\n    x->type = EVP_PKEY_NONE;\n}\n\nstatic void evp_pkey_free_it(EVP_PKEY *x)\n{\n    /* internal function; x is never NULL */\n\n    evp_keymgmt_util_clear_operation_cache(x);\n#ifndef FIPS_MODE\n    evp_pkey_free_legacy(x);\n#endif\n\n    if (x->keymgmt != NULL) {\n        evp_keymgmt_freedata(x->keymgmt, x->keydata);\n        EVP_KEYMGMT_free(x->keymgmt);\n        x->keymgmt = NULL;\n        x->keydata = NULL;\n    }\n}\n\nvoid EVP_PKEY_free(EVP_PKEY *x)\n{\n    int i;\n\n    if (x == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(&x->references, &i, x->lock);\n    REF_PRINT_COUNT(\"EVP_PKEY\", x);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n    evp_pkey_free_it(x);\n    CRYPTO_THREAD_lock_free(x->lock);\n#ifndef FIPS_MODE\n    sk_X509_ATTRIBUTE_pop_free(x->attributes, X509_ATTRIBUTE_free);\n#endif\n    OPENSSL_free(x);\n}\n\nstatic int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey)\n{\n#ifndef OPENSSL_NO_DH\n    PACKET prime, generator, pub_key;\n    EVP_PKEY *peer_tmp = NULL;\n\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;\n\n    int check_bits = 0;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    peer_tmp = EVP_PKEY_new();\n    dh = DH_new();\n\n    if (peer_tmp == NULL || dh == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* TODO(size_t): Convert these calls */\n    p = BN_bin2bn(PACKET_data(&prime), (int)PACKET_remaining(&prime), NULL);\n    g = BN_bin2bn(PACKET_data(&generator), (int)PACKET_remaining(&generator),\n                  NULL);\n    bnpub_key = BN_bin2bn(PACKET_data(&pub_key),\n                          (int)PACKET_remaining(&pub_key), NULL);\n    if (p == NULL || g == NULL || bnpub_key == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* test non-zero pubkey */\n    if (BN_is_zero(bnpub_key)) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_pqg(dh, p, NULL, g)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    p = g = NULL;\n\n    if (DH_check_params(dh, &check_bits) == 0 || check_bits != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_key(dh, bnpub_key, NULL)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    bnpub_key = NULL;\n\n    if (EVP_PKEY_assign_DH(peer_tmp, dh) == 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n    dh = NULL;\n\n    if (!ssl_security(s, SSL_SECOP_TMP_DH, EVP_PKEY_security_bits(peer_tmp),\n                      0, EVP_PKEY_get0_DH(peer_tmp))) {\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_DH_KEY_TOO_SMALL);\n        goto err;\n    }\n\n    s->s3.peer_tmp = peer_tmp;\n\n    /*\n     * FIXME: This makes assumptions about which ciphersuites come with\n     * public keys. We should have a less ad-hoc way of doing this\n     */\n    if (s->s3.tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous DH, so no certificate or pkey. */\n\n    return 1;\n\n err:\n    BN_free(p);\n    BN_free(g);\n    BN_free(bnpub_key);\n    DH_free(dh);\n    EVP_PKEY_free(peer_tmp);\n\n    return 0;\n#else\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n             ERR_R_INTERNAL_ERROR);\n    return 0;\n#endif\n}\n\nMSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)\n{\n    long alg_k;\n    EVP_PKEY *pkey = NULL;\n    EVP_MD_CTX *md_ctx = NULL;\n    EVP_PKEY_CTX *pctx = NULL;\n    PACKET save_param_start, signature;\n\n    alg_k = s->s3.tmp.new_cipher->algorithm_mkey;\n\n    save_param_start = *pkt;\n\n#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)\n    EVP_PKEY_free(s->s3.peer_tmp);\n    s->s3.peer_tmp = NULL;\n#endif\n\n    if (alg_k & SSL_PSK) {\n        if (!tls_process_ske_psk_preamble(s, pkt)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    }\n\n    /* Nothing else to do for plain PSK or RSAPSK */\n    if (alg_k & (SSL_kPSK | SSL_kRSAPSK)) {\n    } else if (alg_k & SSL_kSRP) {\n        if (!tls_process_ske_srp(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {\n        if (!tls_process_ske_dhe(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        if (!tls_process_ske_ecdhe(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                 SSL_R_UNEXPECTED_MESSAGE);\n        goto err;\n    }\n\n    /* if it was signed, check the signature */\n    if (pkey != NULL) {\n        PACKET params;\n        const EVP_MD *md = NULL;\n        unsigned char *tbs;\n        size_t tbslen;\n        int rv;\n\n        /*\n         * |pkt| now points to the beginning of the signature, so the difference\n         * equals the length of the parameters.\n         */\n        if (!PACKET_get_sub_packet(&save_param_start, &params,\n                                   PACKET_remaining(&save_param_start) -\n                                   PACKET_remaining(pkt))) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (SSL_USE_SIGALGS(s)) {\n            unsigned int sigalg;\n\n            if (!PACKET_get_net_2(pkt, &sigalg)) {\n                SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                         SSL_R_LENGTH_TOO_SHORT);\n                goto err;\n            }\n            if (tls12_check_peer_sigalg(s, sigalg, pkey) <=0) {\n                /* SSLfatal() already called */\n                goto err;\n            }\n        } else if (!tls1_set_peer_legacy_sigalg(s, pkey)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (!tls1_lookup_md(s->ctx, s->s3.tmp.peer_sigalg, &md)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        if (SSL_USE_SIGALGS(s))\n            OSSL_TRACE1(TLS, \"USING TLSv1.2 HASH %s\\n\",\n                        md == NULL ? \"n/a\" : EVP_MD_name(md));\n\n        if (!PACKET_get_length_prefixed_2(pkt, &signature)\n            || PACKET_remaining(pkt) != 0) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        md_ctx = EVP_MD_CTX_new();\n        if (md_ctx == NULL) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        if (EVP_DigestVerifyInit(md_ctx, &pctx, md, NULL, pkey) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_EVP_LIB);\n            goto err;\n        }\n        if (SSL_USE_PSS(s)) {\n            if (EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PSS_PADDING) <= 0\n                || EVP_PKEY_CTX_set_rsa_pss_saltlen(pctx,\n                                                RSA_PSS_SALTLEN_DIGEST) <= 0) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_EVP_LIB);\n                goto err;\n            }\n        }\n        tbslen = construct_key_exchange_tbs(s, &tbs, PACKET_data(&params),\n                                            PACKET_remaining(&params));\n        if (tbslen == 0) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n\n        rv = EVP_DigestVerify(md_ctx, PACKET_data(&signature),\n                              PACKET_remaining(&signature), tbs, tbslen);\n        OPENSSL_free(tbs);\n        if (rv <= 0) {\n            SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_BAD_SIGNATURE);\n            goto err;\n        }\n        EVP_MD_CTX_free(md_ctx);\n        md_ctx = NULL;\n    } else {\n        /* aNULL, aSRP or PSK do not need public keys */\n        if (!(s->s3.tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))\n            && !(alg_k & SSL_PSK)) {\n            /* Might be wrong key type, check it */\n            if (ssl3_check_cert_and_algorithm(s)) {\n                SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                         SSL_R_BAD_DATA);\n            }\n            /* else this shouldn't happen, SSLfatal() already called */\n            goto err;\n        }\n        /* still data left over */\n        if (PACKET_remaining(pkt) != 0) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_EXTRA_DATA_IN_MESSAGE);\n            goto err;\n        }\n    }\n\n    return MSG_PROCESS_CONTINUE_READING;\n err:\n    EVP_MD_CTX_free(md_ctx);\n    return MSG_PROCESS_ERROR;\n}\n\nstatic SUB_STATE_RETURN read_state_machine(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n    int ret, mt;\n    size_t len = 0;\n    int (*transition) (SSL *s, int mt);\n    PACKET pkt;\n    MSG_PROCESS_RETURN(*process_message) (SSL *s, PACKET *pkt);\n    WORK_STATE(*post_process_message) (SSL *s, WORK_STATE wst);\n    size_t (*max_message_size) (SSL *s);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n\n    cb = get_callback(s);\n\n    if (s->server) {\n        transition = ossl_statem_server_read_transition;\n        process_message = ossl_statem_server_process_message;\n        max_message_size = ossl_statem_server_max_message_size;\n        post_process_message = ossl_statem_server_post_process_message;\n    } else {\n        transition = ossl_statem_client_read_transition;\n        process_message = ossl_statem_client_process_message;\n        max_message_size = ossl_statem_client_max_message_size;\n        post_process_message = ossl_statem_client_post_process_message;\n    }\n\n    if (st->read_state_first_init) {\n        s->first_packet = 1;\n        st->read_state_first_init = 0;\n    }\n\n    while (1) {\n        switch (st->read_state) {\n        case READ_STATE_HEADER:\n            /* Get the state the peer wants to move to */\n            if (SSL_IS_DTLS(s)) {\n                /*\n                 * In DTLS we get the whole message in one go - header and body\n                 */\n                ret = dtls_get_message(s, &mt, &len);\n            } else {\n                ret = tls_get_message_header(s, &mt);\n            }\n\n            if (ret == 0) {\n                /* Could be non-blocking IO */\n                return SUB_STATE_ERROR;\n            }\n\n            if (cb != NULL) {\n                /* Notify callback of an impending state change */\n                if (s->server)\n                    cb(s, SSL_CB_ACCEPT_LOOP, 1);\n                else\n                    cb(s, SSL_CB_CONNECT_LOOP, 1);\n            }\n            /*\n             * Validate that we are allowed to move to the new state and move\n             * to that state if so\n             */\n            if (!transition(s, mt))\n                return SUB_STATE_ERROR;\n\n            if (s->s3.tmp.message_size > max_message_size(s)) {\n                SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_READ_STATE_MACHINE,\n                         SSL_R_EXCESSIVE_MESSAGE_SIZE);\n                return SUB_STATE_ERROR;\n            }\n\n            /* dtls_get_message already did this */\n            if (!SSL_IS_DTLS(s)\n                    && s->s3.tmp.message_size > 0\n                    && !grow_init_buf(s, s->s3.tmp.message_size\n                                         + SSL3_HM_HEADER_LENGTH)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                         ERR_R_BUF_LIB);\n                return SUB_STATE_ERROR;\n            }\n\n            st->read_state = READ_STATE_BODY;\n            /* Fall through */\n\n        case READ_STATE_BODY:\n            if (!SSL_IS_DTLS(s)) {\n                /* We already got this above for DTLS */\n                ret = tls_get_message_body(s, &len);\n                if (ret == 0) {\n                    /* Could be non-blocking IO */\n                    return SUB_STATE_ERROR;\n                }\n            }\n\n            s->first_packet = 0;\n            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                return SUB_STATE_ERROR;\n            }\n            ret = process_message(s, &pkt);\n\n            /* Discard the packet data */\n            s->init_num = 0;\n\n            switch (ret) {\n            case MSG_PROCESS_ERROR:\n                check_fatal(s, SSL_F_READ_STATE_MACHINE);\n                return SUB_STATE_ERROR;\n\n            case MSG_PROCESS_FINISHED_READING:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n\n            case MSG_PROCESS_CONTINUE_PROCESSING:\n                st->read_state = READ_STATE_POST_PROCESS;\n                st->read_state_work = WORK_MORE_A;\n                break;\n\n            default:\n                st->read_state = READ_STATE_HEADER;\n                break;\n            }\n            break;\n\n        case READ_STATE_POST_PROCESS:\n            st->read_state_work = post_process_message(s, st->read_state_work);\n            switch (st->read_state_work) {\n            case WORK_ERROR:\n                check_fatal(s, SSL_F_READ_STATE_MACHINE);\n                /* Fall through */\n            case WORK_MORE_A:\n            case WORK_MORE_B:\n            case WORK_MORE_C:\n                return SUB_STATE_ERROR;\n\n            case WORK_FINISHED_CONTINUE:\n                st->read_state = READ_STATE_HEADER;\n                break;\n\n            case WORK_FINISHED_STOP:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n            }\n            break;\n\n        default:\n            /* Shouldn't happen */\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            return SUB_STATE_ERROR;\n        }\n    }\n}\n\nstatic int state_machine(SSL *s, int server)\n{\n    BUF_MEM *buf = NULL;\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n    OSSL_STATEM *st = &s->statem;\n    int ret = -1;\n    int ssret;\n\n    if (st->state == MSG_FLOW_ERROR) {\n        /* Shouldn't have been called if we're already in the error state */\n        return -1;\n    }\n\n    ERR_clear_error();\n    clear_sys_error();\n\n    cb = get_callback(s);\n\n    st->in_handshake++;\n    if (!SSL_in_init(s) || SSL_in_before(s)) {\n        /*\n         * If we are stateless then we already called SSL_clear() - don't do\n         * it again and clear the STATELESS flag itself.\n         */\n        if ((s->s3.flags & TLS1_FLAGS_STATELESS) == 0 && !SSL_clear(s))\n            return -1;\n    }\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        /*\n         * Notify SCTP BIO socket to enter handshake mode and prevent stream\n         * identifier other than 0.\n         */\n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,\n                 st->in_handshake, NULL);\n    }\n#endif\n\n    /* Initialise state machine */\n    if (st->state == MSG_FLOW_UNINITED\n            || st->state == MSG_FLOW_FINISHED) {\n        if (st->state == MSG_FLOW_UNINITED) {\n            st->hand_state = TLS_ST_BEFORE;\n            st->request_state = TLS_ST_BEFORE;\n        }\n\n        s->server = server;\n        if (cb != NULL) {\n            if (SSL_IS_FIRST_HANDSHAKE(s) || !SSL_IS_TLS13(s))\n                cb(s, SSL_CB_HANDSHAKE_START, 1);\n        }\n\n        /*\n         * Fatal errors in this block don't send an alert because we have\n         * failed to even initialise properly. Sending an alert is probably\n         * doomed to failure.\n         */\n\n        if (SSL_IS_DTLS(s)) {\n            if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00) &&\n                (server || (s->version & 0xff00) != (DTLS1_BAD_VER & 0xff00))) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n        } else {\n            if ((s->version >> 8) != SSL3_VERSION_MAJOR) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n        }\n\n        if (!ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) {\n            SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            goto end;\n        }\n\n        if (s->init_buf == NULL) {\n            if ((buf = BUF_MEM_new()) == NULL) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n            if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n            s->init_buf = buf;\n            buf = NULL;\n        }\n\n        if (!ssl3_setup_buffers(s)) {\n            SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            goto end;\n        }\n        s->init_num = 0;\n\n        /*\n         * Should have been reset by tls_process_finished, too.\n         */\n        s->s3.change_cipher_spec = 0;\n\n        /*\n         * Ok, we now need to push on a buffering BIO ...but not with\n         * SCTP\n         */\n#ifndef OPENSSL_NO_SCTP\n        if (!SSL_IS_DTLS(s) || !BIO_dgram_is_sctp(SSL_get_wbio(s)))\n#endif\n            if (!ssl_init_wbio_buffer(s)) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n\n        if ((SSL_in_before(s))\n                || s->renegotiate) {\n            if (!tls_setup_handshake(s)) {\n                /* SSLfatal() already called */\n                goto end;\n            }\n\n            if (SSL_IS_FIRST_HANDSHAKE(s))\n                st->read_state_first_init = 1;\n        }\n\n        st->state = MSG_FLOW_WRITING;\n        init_write_state_machine(s);\n    }\n\n    while (st->state != MSG_FLOW_FINISHED) {\n        if (st->state == MSG_FLOW_READING) {\n            ssret = read_state_machine(s);\n            if (ssret == SUB_STATE_FINISHED) {\n                st->state = MSG_FLOW_WRITING;\n                init_write_state_machine(s);\n            } else {\n                /* NBIO or error */\n                goto end;\n            }\n        } else if (st->state == MSG_FLOW_WRITING) {\n            ssret = write_state_machine(s);\n            if (ssret == SUB_STATE_FINISHED) {\n                st->state = MSG_FLOW_READING;\n                init_read_state_machine(s);\n            } else if (ssret == SUB_STATE_END_HANDSHAKE) {\n                st->state = MSG_FLOW_FINISHED;\n            } else {\n                /* NBIO or error */\n                goto end;\n            }\n        } else {\n            /* Error */\n            check_fatal(s, SSL_F_STATE_MACHINE);\n            SSLerr(SSL_F_STATE_MACHINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n            goto end;\n        }\n    }\n\n    ret = 1;\n\n end:\n    st->in_handshake--;\n\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        /*\n         * Notify SCTP BIO socket to leave handshake mode and allow stream\n         * identifier other than 0.\n         */\n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,\n                 st->in_handshake, NULL);\n    }\n#endif\n\n    BUF_MEM_free(buf);\n    if (cb != NULL) {\n        if (server)\n            cb(s, SSL_CB_ACCEPT_EXIT, ret);\n        else\n            cb(s, SSL_CB_CONNECT_EXIT, ret);\n    }\n    return ret;\n}\n\nint SSL_do_handshake(SSL *s)\n{\n    int ret = 1;\n\n    if (s->handshake_func == NULL) {\n        SSLerr(SSL_F_SSL_DO_HANDSHAKE, SSL_R_CONNECTION_TYPE_NOT_SET);\n        return -1;\n    }\n\n    ossl_statem_check_finish_init(s, -1);\n\n    s->method->ssl_renegotiate_check(s, 0);\n\n    if (SSL_in_init(s) || SSL_in_before(s)) {\n        if ((s->mode & SSL_MODE_ASYNC) && ASYNC_get_current_job() == NULL) {\n            struct ssl_async_args args;\n\n            args.s = s;\n\n            ret = ssl_start_async_job(s, &args, ssl_do_handshake_intern);\n        } else {\n            ret = s->handshake_func(s);\n        }\n    }\n    return ret;\n}\n\nint FuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n    SSL *client;\n    BIO *in;\n    BIO *out;\n    SSL_CTX *ctx;\n\n    if (len == 0)\n        return 0;\n\n    /*\n     * TODO: use the ossltest engine (optionally?) to disable crypto checks.\n     */\n\n    /* This only fuzzes the initial flow from the client so far. */\n    ctx = SSL_CTX_new(SSLv23_method());\n\n    client = SSL_new(ctx);\n    OPENSSL_assert(SSL_set_min_proto_version(client, 0) == 1);\n    OPENSSL_assert(SSL_set_cipher_list(client, \"ALL:eNULL:@SECLEVEL=0\") == 1);\n    SSL_set_tlsext_host_name(client, \"localhost\");\n    in = BIO_new(BIO_s_mem());\n    out = BIO_new(BIO_s_mem());\n    SSL_set_bio(client, in, out);\n    SSL_set_connect_state(client);\n    OPENSSL_assert((size_t)BIO_write(in, buf, len) == len);\n    if (SSL_do_handshake(client) == 1) {\n        /* Keep reading application data until error or EOF. */\n        uint8_t tmp[1024];\n        for (;;) {\n            if (SSL_read(client, tmp, sizeof(tmp)) <= 0) {\n                break;\n            }\n        }\n    }\n    SSL_free(client);\n    ERR_clear_error();\n    SSL_CTX_free(ctx);\n\n    return 0;\n}\n\n\n// target function\nstatic int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey)\n{\n#ifndef OPENSSL_NO_DH\n    PACKET prime, generator, pub_key;\n    EVP_PKEY *peer_tmp = NULL;\n\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;\n\n    int check_bits = 0;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    peer_tmp = EVP_PKEY_new();\n    dh = DH_new();\n\n    if (peer_tmp == NULL || dh == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* TODO(size_t): Convert these calls */\n    p = BN_bin2bn(PACKET_data(&prime), (int)PACKET_remaining(&prime), NULL);\n    g = BN_bin2bn(PACKET_data(&generator), (int)PACKET_remaining(&generator),\n                  NULL);\n    bnpub_key = BN_bin2bn(PACKET_data(&pub_key),\n                          (int)PACKET_remaining(&pub_key), NULL);\n    if (p == NULL || g == NULL || bnpub_key == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* test non-zero pubkey */\n    if (BN_is_zero(bnpub_key)) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_pqg(dh, p, NULL, g)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    p = g = NULL;\n\n    if (DH_check_params(dh, &check_bits) == 0 || check_bits != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_key(dh, bnpub_key, NULL)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    bnpub_key = NULL;\n\n    if (EVP_PKEY_assign_DH(peer_tmp, dh) == 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    if (!ssl_security(s, SSL_SECOP_TMP_DH, EVP_PKEY_security_bits(peer_tmp),\n                      0, dh)) {\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_DH_KEY_TOO_SMALL);\n        goto err;\n    }\n\n    s->s3.peer_tmp = peer_tmp;\n\n    /*\n     * FIXME: This makes assumptions about which ciphersuites come with\n     * public keys. We should have a less ad-hoc way of doing this\n     */\n    if (s->s3.tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous DH, so no certificate or pkey. */\n\n    return 1;\n\n err:\n    BN_free(p);\n    BN_free(g);\n    BN_free(bnpub_key);\n    DH_free(dh);\n    EVP_PKEY_free(peer_tmp);\n\n    return 0;\n#else\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n             ERR_R_INTERNAL_ERROR);\n    return 0;\n#endif\n}\n",
    "target": 1,
    "idx": 1021550,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\ngc_trace_clump(const gs_memory_t *mem, clump_t * cp, gc_state_t * pstate, gc_mark_stack * pmstack)\n{\n    gs_gc_root_t root;\n    void *comp;\n    int more = 0;\n    int min_trace = pstate->min_collect;\n\n    root.p = &comp;\n    if_debug_clump('6', mem, \"[6]marking from clump\", cp);\n    SCAN_CLUMP_OBJECTS(cp)\n        DO_ALL\n    {\n        if_debug2m('7', mem, \" [7]scanning/marking \"PRI_INTPTR\"(%lu)\\n\",\n                   (intptr_t)pre, (ulong)size);\n        if (pre->o_type == &st_refs) {\n            ref_packed *rp = (ref_packed *) (pre + 1);\n            char *end = (char *)rp + size;\n\n            root.ptype = ptr_ref_type;\n            while ((char *)rp < end) {\n                comp = rp;\n                if (r_is_packed(rp)) {\t/* No packed refs need tracing. */\n                    rp++;\n                } else {\n                    ref *const pref = (ref *)rp;\n\n                    if (r_space(pref) >= min_trace) {\n                        r_clear_attrs(pref, l_mark);\n                        more |= gc_trace(&root, pstate, pmstack);\n                    }\n                    rp += packed_per_ref;\n                }\n            }\n        } else if (!o_is_unmarked(pre)) {\n            if (!o_is_untraced(pre))\n                o_set_unmarked(pre);\n            if (pre->o_type != &st_free) {\n                struct_proc_clear_marks((*proc)) =\n                    pre->o_type->clear_marks;\n\n                root.ptype = ptr_struct_type;\n                comp = pre + 1;\n                if (proc != 0)\n                    (*proc) (mem, comp, size, pre->o_type);\n                more |= gc_trace(&root, pstate, pmstack);\n            }\n        }\n    }\n\n\n\nstatic int\ngs_vmreclaim(gs_dual_memory_t *dmem, bool global)\n{\n    /* HACK: we know the gs_dual_memory_t is embedded in a context state. */\n    i_ctx_t *i_ctx_p =\n        (i_ctx_t *)((char *)dmem - offset_of(i_ctx_t, memory));\n    gs_ref_memory_t *lmem = dmem->space_local;\n    int code = context_state_store(i_ctx_p);\n    gs_ref_memory_t *memories[5];\n    gs_ref_memory_t *mem;\n    int nmem, i;\n\n    if (code < 0)\n        return code;\n\n    memories[0] = dmem->space_system;\n    memories[1] = mem = dmem->space_global;\n    nmem = 2;\n    if (lmem != dmem->space_global)\n        memories[nmem++] = lmem;\n    for (i = nmem; --i >= 0;) {\n        mem = memories[i];\n        if (mem->stable_memory != (gs_memory_t *)mem)\n            memories[nmem++] = (gs_ref_memory_t *)mem->stable_memory;\n    }\n\n    /****** ABORT IF code < 0 ******/\n    for (i = nmem; --i >= 0; )\n        alloc_close_clump(memories[i]);\n\n    /* Prune the file list so it won't retain potentially collectible */\n    /* files. */\n\n    for (i = (global ? i_vm_system : i_vm_local);\n         i < countof(dmem->spaces_indexed);\n         ++i\n         ) {\n        gs_ref_memory_t *mem = dmem->spaces_indexed[i];\n\n        /* Always safe to substract 1 from i here, as i is always at\n         * least i_vm_system (1) or i_vm_local (2). */\n        if (mem == 0 || (mem == dmem->spaces_indexed[i - 1]))\n            continue;\n        if (mem->stable_memory != (gs_memory_t *)mem)\n            ialloc_gc_prepare((gs_ref_memory_t *)mem->stable_memory);\n        for (;; mem = &mem->saved->state) {\n            ialloc_gc_prepare(mem);\n            if (mem->saved == 0)\n                break;\n        }\n    }\n\n    /* Do the actual collection. */\n\n    {\n        void *ctxp = i_ctx_p;\n        gs_gc_root_t context_root, *r = &context_root;\n\n        gs_register_struct_root((gs_memory_t *)lmem, &r,\n                                &ctxp, \"i_ctx_p root\");\n        GS_RECLAIM(&dmem->spaces, global);\n        gs_unregister_root((gs_memory_t *)lmem, r, \"i_ctx_p root\");\n        i_ctx_p = ctxp;\n        dmem = &i_ctx_p->memory;\n    }\n\n    /* Update caches not handled by context_state_load. */\n\n    *systemdict = *ref_stack_index(&d_stack, ref_stack_count(&d_stack) - 1);\n\n    /* Update the cached value pointers in names. */\n\n    dicts_gc_cleanup();\n\n    /* Reopen the active clumps. */\n\n    for (i = 0; i < nmem; ++i)\n        alloc_open_clump(memories[i]);\n\n    /* Reload the context state.  Note this should be done\n       AFTER the clumps are reopened, since the context state\n       load could do allocations that must remain.\n       If it were done while the clumps were still closed,\n       we would lose those allocations when the clumps were opened */\n\n    code = context_state_load(i_ctx_p);\n    return code;\n}\n\nstatic int\nireclaim(gs_dual_memory_t * dmem, int space)\n{\n    bool global;\n    gs_ref_memory_t *mem = NULL;\n    int code;\n\n    if (space < 0) {\n        /* Determine which allocator exceeded the limit. */\n        int i;\n\n        for (i = 0; i < countof(dmem->spaces_indexed); i++) {\n            mem = dmem->spaces_indexed[i];\n            if (mem == 0)\n                continue;\n            if (mem->gc_status.requested > 0 ||\n                ((gs_ref_memory_t *)mem->stable_memory)->gc_status.requested > 0\n                )\n                break;\n        }\n        if (!mem) {\n            mem = dmem->space_global; /* just in case */\n        }\n    } else {\n        mem = dmem->spaces_indexed[space >> r_space_shift];\n    }\n    if_debug3m('0', (gs_memory_t *)mem, \"[0]GC called, space=%d, requestor=%d, requested=%ld\\n\",\n               space, mem->space, (long)mem->gc_status.requested);\n    global = mem->space != avm_local;\n    /* Since dmem may move, reset the request now. */\n    ialloc_reset_requested(dmem);\n    code = gs_vmreclaim(dmem, global);\n    if (code < 0)\n        return code;\n    ialloc_set_limit(mem);\n    if (space < 0) {\n        gs_memory_status_t stats;\n        size_t allocated;\n\n        /* If the ammount still allocated after the GC is complete */\n        /* exceeds the max_vm setting, then return a VMerror       */\n        gs_memory_status((gs_memory_t *) mem, &stats);\n        allocated = stats.allocated;\n        if (mem->stable_memory != (gs_memory_t *)mem) {\n            gs_memory_status(mem->stable_memory, &stats);\n            allocated += stats.allocated;\n        }\n        if (allocated >= mem->gc_status.max_vm) {\n            /* We can't satisfy this request within max_vm. */\n            return_error(gs_error_VMerror);\n        }\n    }\n    return 0;\n}\n\nint\ninterp_reclaim(i_ctx_t **pi_ctx_p, int space)\n{\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    gs_gc_root_t ctx_root, *r = &ctx_root;\n    int code;\n\n#ifdef DEBUG\n    if (gs_debug_c(gs_debug_flag_gc_disable))\n        return 0;\n#endif\n\n    gs_register_struct_root(imemory_system, &r,\n                            (void **)pi_ctx_p, \"interp_reclaim(pi_ctx_p)\");\n    code = (*idmemory->reclaim)(idmemory, space);\n    i_ctx_p = *pi_ctx_p;        /* may have moved */\n    gs_unregister_root(imemory_system, r, \"interp_reclaim(pi_ctx_p)\");\n    return code;\n}\n\nint\ngs_main_finit(gs_main_instance * minst, int exit_status, int env_code)\n{\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    gs_dual_memory_t dmem = {0};\n    int exit_code;\n    ref error_object;\n    char *tempnames = NULL;\n    gs_lib_ctx_core_t *core;\n\n    /* NB: need to free gs_name_table\n     */\n\n    /*\n     * Previous versions of this code closed the devices in the\n     * device list here.  Since these devices are now prototypes,\n     * they cannot be opened, so they do not need to be closed;\n     * alloc_restore_all will close dynamically allocated devices.\n     */\n    tempnames = gs_main_tempnames(minst);\n\n    /* by the time we get here, we *must* avoid any random redefinitions of\n     * operators etc, so we push systemdict onto the top of the dict stack.\n     * We do this in C to avoid running into any other re-defininitions in the\n     * Postscript world.\n     */\n    gs_finit_push_systemdict(i_ctx_p);\n\n    /* We have to disable BGPrint before we call interp_reclaim() to prevent the\n     * parent rendering thread initialising for the next page, whilst we are\n     * removing objects it may want to access - for example, the I/O device table.\n     * We also have to mess with the BeginPage/EndPage procs so that we don't\n     * trigger a spurious extra page to be emitted.\n     */\n    if (minst->init_done >= 2) {\n        gs_main_run_string(minst,\n            \"/BGPrint /GetDeviceParam .special_op \\\n            {{ <</BeginPage {pop} /EndPage {pop pop //false } \\\n              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \\\n              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \\\n              .systemvar exec\",\n            0 , &exit_code, &error_object);\n    }\n\n    /*\n     * Close the \"main\" device, because it may need to write out\n     * data before destruction. pdfwrite needs so.\n     */\n    if (minst->init_done >= 2) {\n        int code = 0;\n\n        if (idmemory->reclaim != 0) {\n            /* In extreme error conditions, these references can persist, despite the\n             * arrays themselves having been restored away.\n             */\n            gs_main_run_string(minst,\n                \"$error /dstack undef \\\n                 $error /estack undef \\\n                 $error /ostack undef\",\n                 0 , &exit_code, &error_object);\n\n            ref_stack_clear(&o_stack);\n            code = interp_reclaim(&minst->i_ctx_p, avm_global);\n\n            /* We ignore gs_error_VMerror because it comes from gs_vmreclaim()\n            calling context_state_load(), and we don't seem to depend on the\n            missing fields. */\n            if (code == gs_error_VMerror) {\n                if (exit_status == 0 || exit_status == gs_error_Quit) {\n                    exit_status = gs_error_VMerror;\n                }\n            }\n            else if (code < 0) {\n                ref error_name;\n                if (tempnames)\n                    free(tempnames);\n\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf2(imemory, \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\", err_str, code);\n                }\n                else {\n                    emprintf1(imemory, \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\", code);\n                }\n#ifdef MEMENTO\n                if (Memento_squeezing() && code != gs_error_VMerror ) return gs_error_Fatal;\n#endif\n                return gs_error_Fatal;\n            }\n            i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&\n            gx_device_is_null(i_ctx_p->pgs->device)) {\n            /* if the job replaced the device with the nulldevice, we we need to grestore\n               away that device, so the block below can properly dispense\n               with the default device.\n             */\n            int code = gs_grestoreall(i_ctx_p->pgs);\n            if (code < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {\n            gx_device *pdev = i_ctx_p->pgs->device;\n            const char * dname = pdev->dname;\n            gs_gc_root_t dev_root;\n            gs_gc_root_t *dev_root_ptr = &dev_root;\n            /* There is a chance that, during the call to gs_main_run_string(), the interpreter may\n             * decide to call the garbager - the device is in gc memory, and the only reference to it\n             * (in the gstate) has been removed, thus it can be destroyed by the garbager.\n             * Counter-intuitively, adjusting the reference count makes not difference to that.\n             * Register the device as a gc 'root' so it will be implicitely marked by garbager, and\n             * and thus surive until control returns here.\n             */\n            if (gs_register_struct_root(pdev->memory, &dev_root_ptr, (void **)&pdev, \"gs_main_finit\") < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n\n            /* make sure device doesn't isn't freed by .uninstalldevice */\n            rc_adjust(pdev, 1, \"gs_main_finit\");\n            /* deactivate the device just before we close it for the last time */\n            gs_main_run_string(minst,\n                /* we need to do the 'quit' so we don't loop for input (double quit) */\n                \".uninstallpagedevice serverdict \\\n                /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemvar exec\",\n                0 , &exit_code, &error_object);\n            code = gs_closedevice(pdev);\n            if (code < 0) {\n                ref error_name;\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf3(imemory, \"ERROR: %s (%d) on closing %s device.\\n\", err_str, code, dname);\n                }\n                else {\n                    emprintf2(imemory, \"UNKNOWN ERROR %d closing %s device.\\n\", code, dname);\n               }\n            }\n            gs_unregister_root(pdev->memory, dev_root_ptr, \"gs_main_finit\");\n            rc_decrement(pdev, \"gs_main_finit\");                /* device might be freed */\n            if (exit_status == 0 || exit_status == gs_error_Quit)\n                exit_status = code;\n        }\n\n      /* Flush stdout and stderr */\n      gs_main_run_string(minst,\n        \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\\n        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \\\n          systemdict /savedinitialgstate .forceundef\",\n        0 , &exit_code, &error_object);\n    }\n    gp_readline_finit(minst->readline_data);\n    gs_free_object(minst->heap, minst->saved_pages_initial_arg, \"gs_main_finit\");\n    i_ctx_p = minst->i_ctx_p;\t\t/* get current interp context */\n    if (gs_debug_c(':')) {\n        print_resource_usage(minst, &gs_imemory, \"Final\");\n        dmprintf1(minst->heap, \"%% Exiting instance \"PRI_INTPTR\"\\n\", (intptr_t)minst);\n    }\n    /* Do the equivalent of a restore \"past the bottom\". */\n    /* This will release all memory, close all open files, etc. */\n    if (minst->init_done >= 1) {\n        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;\n        i_plugin_holder *h = i_ctx_p->plugin_list;\n\n        dmem = *idmemory;\n        env_code = alloc_restore_all(i_ctx_p);\n        if (env_code < 0)\n            emprintf1(mem_raw,\n                      \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\",\n                      env_code);\n        i_iodev_finit(&dmem);\n        i_plugin_finit(mem_raw, h);\n    }\n\n    /* clean up redirected stdout */\n    core = minst->heap->gs_lib_ctx->core;\n    if (core->fstdout2\n        && (gp_get_file(core->fstdout2) != core->fstdout)\n        && (gp_get_file(core->fstdout2) != core->fstderr)) {\n        gp_fclose(core->fstdout2);\n        core->fstdout2 = NULL;\n    }\n\n    minst->heap->gs_lib_ctx->core->stdout_is_redirected = 0;\n    minst->heap->gs_lib_ctx->core->stdout_to_stderr = 0;\n    /* remove any temporary files, after ghostscript has closed files */\n    if (tempnames) {\n        char *p = tempnames;\n        while (*p) {\n            gp_unlink(minst->heap, p);\n            p += strlen(p) + 1;\n        }\n        free(tempnames);\n    }\n    gs_lib_finit(exit_status, env_code, minst->heap);\n\n    set_lib_path_length(minst, 0);\n    gs_free_object(minst->heap, minst->lib_path.container.value.refs, \"lib_path array\");\n    if (minst->init_done == 0 && i_ctx_p) {\n        /* This fixes leak if memento forces failure in gs_main_init1(). */\n        dmem = *idmemory;\n    }\n    ialloc_finit(&dmem);\n    return exit_status;\n}\n\nint\ngs_to_exit_with_code(const gs_memory_t *mem, int exit_status, int code)\n{\n    return gs_main_finit(get_minst_from_memory(mem), exit_status, code);\n}\n\nint\ngs_to_exit(const gs_memory_t *mem, int exit_status)\n{\n    return gs_to_exit_with_code(mem, exit_status, 0);\n}\n\nint\npsapi_exit(gs_lib_ctx_t *ctx)\n{\n    if (ctx == NULL)\n        return gs_error_Fatal;\n\n    gs_to_exit(ctx->memory, 0);\n    return 0;\n}\n\nGSDLLEXPORT int GSDLLAPI\ngsapi_exit(void *instance)\n{\n    gs_lib_ctx_t *ctx = (gs_lib_ctx_t *)instance;\n    if (instance == NULL)\n        return gs_error_Fatal;\n    gp_set_debug_mem_ptr(ctx->memory);\n    return psapi_exit(ctx);\n}\n\nint fuzz_gs_device(\n\tconst unsigned char *buf,\n\tsize_t size,\n\tint color_scheme,\n\tconst char *device_target,\n\tconst char *output_file\n)\n{\n\tint ret;\n\tvoid *gs = NULL;\n\tchar color_space[50];\n\tchar gs_device[50];\n\tchar gs_o[100];\n\t/*\n\t * We are expecting color_scheme to be in the [0:62] interval.\n\t * This corresponds to the color schemes defined here:\n\t * https://github.com/ArtifexSoftware/ghostpdl/blob/8c97d5adce0040ac38a1fb4d7954499c65f582ff/cups/libs/cups/raster.h#L102\n\t */\n\tsprintf(color_space, \"-dcupsColorSpace=%d\", color_scheme);\n\tsprintf(gs_device, \"-sDEVICE=%s\", device_target);\n\tsprintf(gs_o, \"-sOutputFile=%s\", output_file);\n\t/* Mostly stolen from cups-filters gstoraster. */\n\tchar *args[] = {\n\t\t\"gs\",\n\t\t\"-K1048576\",\n\t\t\"-r200x200\",\n\t\t\"-sBandListStorage=memory\",\n\t\t\"-dMaxBitmap=0\",\n\t\t\"-dBufferSpace=450k\",\n\t\t\"-dMediaPosition=1\",\n\t\tcolor_space,\n\t\t\"-dQUIET\",\n\t\t\"-dSAFER\",\n\t\t\"-dNOPAUSE\",\n\t\t\"-dBATCH\",\n\t\t\"-dNOINTERPOLATE\",\n\t\t\"-dNOMEDIAATTRS\",\n\t\t\"-sstdout=%%stderr\",\n\t\tgs_o,\n\t\tgs_device,\n\t\t\"-_\",\n\t};\n\tint argc = sizeof(args) / sizeof(args[0]);\n\n\t/* Stash buffers globally, for gs_stdin(). */\n\tg_data = buf;\n\tg_size = size;\n\n\tret = gsapi_new_instance(&gs, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"gsapi_new_instance: error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgsapi_set_stdio(gs, gs_stdin, gs_stdnull, gs_stdnull);\n\tret = gsapi_set_arg_encoding(gs, GS_ARG_ENCODING_UTF8);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"gsapi_set_arg_encoding: error %d\\n\", ret);\n\t\tgsapi_delete_instance(gs);\n\t\treturn ret;\n\t}\n\n\tret = gsapi_init_with_args(gs, argc, args);\n\tif (ret && ret != gs_error_Quit)\n\t\t/* Just keep going, to cleanup. */\n\t\tfprintf(stderr, \"gsapi_init_with_args: error %d\\n\", ret);\n\n\tret = gsapi_exit(gs);\n\tif (ret < 0 && ret != gs_error_Quit) {\n\t\tfprintf(stderr, \"gsapi_exit: error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgsapi_delete_instance(gs);\n\n\treturn 0;\n}\n\n\n// target function\nint\ngs_main_finit(gs_main_instance * minst, int exit_status, int env_code)\n{\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    gs_dual_memory_t dmem = {0};\n    int exit_code;\n    ref error_object;\n    char *tempnames = NULL;\n    gs_lib_ctx_core_t *core;\n\n    /* NB: need to free gs_name_table\n     */\n\n    /*\n     * Previous versions of this code closed the devices in the\n     * device list here.  Since these devices are now prototypes,\n     * they cannot be opened, so they do not need to be closed;\n     * alloc_restore_all will close dynamically allocated devices.\n     */\n    tempnames = gs_main_tempnames(minst);\n\n    /* by the time we get here, we *must* avoid any random redefinitions of\n     * operators etc, so we push systemdict onto the top of the dict stack.\n     * We do this in C to avoid running into any other re-defininitions in the\n     * Postscript world.\n     */\n    gs_finit_push_systemdict(i_ctx_p);\n\n    /* We have to disable BGPrint before we call interp_reclaim() to prevent the\n     * parent rendering thread initialising for the next page, whilst we are\n     * removing objects it may want to access - for example, the I/O device table.\n     * We also have to mess with the BeginPage/EndPage procs so that we don't\n     * trigger a spurious extra page to be emitted.\n     */\n    if (minst->init_done >= 2) {\n        gs_main_run_string(minst,\n            \"/BGPrint /GetDeviceParam .special_op \\\n            {{ <</BeginPage {pop} /EndPage {pop pop //false } \\\n              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \\\n              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \\\n              .systemvar exec\",\n            0 , &exit_code, &error_object);\n    }\n\n    /*\n     * Close the \"main\" device, because it may need to write out\n     * data before destruction. pdfwrite needs so.\n     */\n    if (minst->init_done >= 2) {\n        int code = 0;\n\n        if (idmemory->reclaim != 0) {\n            code = interp_reclaim(&minst->i_ctx_p, avm_global);\n\n            /* We ignore gs_error_VMerror because it comes from gs_vmreclaim()\n            calling context_state_load(), and we don't seem to depend on the\n            missing fields. */\n            if (code == gs_error_VMerror) {\n                if (exit_status == 0 || exit_status == gs_error_Quit) {\n                    exit_status = gs_error_VMerror;\n                }\n            }\n            else if (code < 0) {\n                ref error_name;\n                if (tempnames)\n                    free(tempnames);\n\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf2(imemory, \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\", err_str, code);\n                }\n                else {\n                    emprintf1(imemory, \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\", code);\n                }\n#ifdef MEMENTO\n                if (Memento_squeezing() && code != gs_error_VMerror ) return gs_error_Fatal;\n#endif\n                return gs_error_Fatal;\n            }\n            i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&\n            gx_device_is_null(i_ctx_p->pgs->device)) {\n            /* if the job replaced the device with the nulldevice, we we need to grestore\n               away that device, so the block below can properly dispense\n               with the default device.\n             */\n            int code = gs_grestoreall(i_ctx_p->pgs);\n            if (code < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {\n            gx_device *pdev = i_ctx_p->pgs->device;\n            const char * dname = pdev->dname;\n            gs_gc_root_t dev_root;\n            gs_gc_root_t *dev_root_ptr = &dev_root;\n            /* There is a chance that, during the call to gs_main_run_string(), the interpreter may\n             * decide to call the garbager - the device is in gc memory, and the only reference to it\n             * (in the gstate) has been removed, thus it can be destroyed by the garbager.\n             * Counter-intuitively, adjusting the reference count makes not difference to that.\n             * Register the device as a gc 'root' so it will be implicitely marked by garbager, and\n             * and thus surive until control returns here.\n             */\n            if (gs_register_struct_root(pdev->memory, &dev_root_ptr, (void **)&pdev, \"gs_main_finit\") < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n\n            /* make sure device doesn't isn't freed by .uninstalldevice */\n            rc_adjust(pdev, 1, \"gs_main_finit\");\n            /* deactivate the device just before we close it for the last time */\n            gs_main_run_string(minst,\n                /* we need to do the 'quit' so we don't loop for input (double quit) */\n                \".uninstallpagedevice serverdict \\\n                /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemvar exec\",\n                0 , &exit_code, &error_object);\n            code = gs_closedevice(pdev);\n            if (code < 0) {\n                ref error_name;\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf3(imemory, \"ERROR: %s (%d) on closing %s device.\\n\", err_str, code, dname);\n                }\n                else {\n                    emprintf2(imemory, \"UNKNOWN ERROR %d closing %s device.\\n\", code, dname);\n               }\n            }\n            gs_unregister_root(pdev->memory, dev_root_ptr, \"gs_main_finit\");\n            rc_decrement(pdev, \"gs_main_finit\");                /* device might be freed */\n            if (exit_status == 0 || exit_status == gs_error_Quit)\n                exit_status = code;\n        }\n\n      /* Flush stdout and stderr */\n      gs_main_run_string(minst,\n        \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\\n        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \\\n          systemdict /savedinitialgstate .forceundef\",\n        0 , &exit_code, &error_object);\n    }\n    gp_readline_finit(minst->readline_data);\n    gs_free_object(minst->heap, minst->saved_pages_initial_arg, \"gs_main_finit\");\n    i_ctx_p = minst->i_ctx_p;\t\t/* get current interp context */\n    if (gs_debug_c(':')) {\n        print_resource_usage(minst, &gs_imemory, \"Final\");\n        dmprintf1(minst->heap, \"%% Exiting instance \"PRI_INTPTR\"\\n\", (intptr_t)minst);\n    }\n    /* Do the equivalent of a restore \"past the bottom\". */\n    /* This will release all memory, close all open files, etc. */\n    if (minst->init_done >= 1) {\n        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;\n        i_plugin_holder *h = i_ctx_p->plugin_list;\n\n        dmem = *idmemory;\n        env_code = alloc_restore_all(i_ctx_p);\n        if (env_code < 0)\n            emprintf1(mem_raw,\n                      \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\",\n                      env_code);\n        i_iodev_finit(&dmem);\n        i_plugin_finit(mem_raw, h);\n    }\n\n    /* clean up redirected stdout */\n    core = minst->heap->gs_lib_ctx->core;\n    if (core->fstdout2\n        && (gp_get_file(core->fstdout2) != core->fstdout)\n        && (gp_get_file(core->fstdout2) != core->fstderr)) {\n        gp_fclose(core->fstdout2);\n        core->fstdout2 = NULL;\n    }\n\n    minst->heap->gs_lib_ctx->core->stdout_is_redirected = 0;\n    minst->heap->gs_lib_ctx->core->stdout_to_stderr = 0;\n    /* remove any temporary files, after ghostscript has closed files */\n    if (tempnames) {\n        char *p = tempnames;\n        while (*p) {\n            gp_unlink(minst->heap, p);\n            p += strlen(p) + 1;\n        }\n        free(tempnames);\n    }\n    gs_lib_finit(exit_status, env_code, minst->heap);\n\n    set_lib_path_length(minst, 0);\n    gs_free_object(minst->heap, minst->lib_path.container.value.refs, \"lib_path array\");\n    if (minst->init_done == 0 && i_ctx_p) {\n        /* This fixes leak if memento forces failure in gs_main_init1(). */\n        dmem = *idmemory;\n    }\n    ialloc_finit(&dmem);\n    return exit_status;\n}\n",
    "target": 1,
    "idx": 1055443,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n    Atomic(T* val) noexcept\n        : m_value(val)\n    {\n    }\n\n    ALWAYS_INLINE static FlatPtr lock(Atomic<FlatPtr>& atomic_var)\n    {\n        // This sets the lock bit atomically, preventing further modifications.\n        // This is important when e.g. copying a RefPtr where the source\n        // might be released and freed too quickly. This allows us\n        // to temporarily lock the pointer so we can add a reference, then\n        // unlock it\n        FlatPtr bits;\n        for (;;) {\n            bits = atomic_var.fetch_or(1, AK::MemoryOrder::memory_order_acq_rel);\n            if (!(bits & 1))\n                break;\n#ifdef KERNEL\n            Kernel::Processor::wait_check();\n#endif\n        }\n        VERIFY(!(bits & 1));\n        return bits;\n    }\n\n    [[nodiscard]] ALWAYS_INLINE FlatPtr add_ref_raw() const\n    {\n#ifdef KERNEL\n        // We don't want to be pre-empted while we have the lock bit set\n        Kernel::ScopedCritical critical;\n#endif\n        // This prevents a race condition between thread A and B:\n        // 1. Thread A copies RefPtr, e.g. through assignment or copy constructor,\n        //    gets the pointer from source, but is pre-empted before adding\n        //    another reference\n        // 2. Thread B calls clear, leak_ref, or release_nonnull on source, and\n        //    then drops the last reference, causing the object to be deleted\n        // 3. Thread A finishes step #1 by attempting to add a reference to\n        //    the object that was already deleted in step #2\n        FlatPtr bits = PtrTraits::lock(m_bits);\n        if (T* ptr = PtrTraits::as_ptr(bits))\n            ptr->ref();\n        PtrTraits::unlock(m_bits, bits);\n        return bits;\n    }\n\n    RefPtr(const OwnPtr<U>&) = delete;\n\n    String(NonnullRefPtr<StringImpl>&& impl)\n        : m_impl(move(impl))\n    {\n    }\n\nTriState abstract_relation(GlobalObject& global_object, bool left_first, Value lhs, Value rhs)\n{\n    Value x_primitive;\n    Value y_primitive;\n\n    if (left_first) {\n        x_primitive = lhs.to_primitive(global_object, Value::PreferredType::Number);\n        if (global_object.vm().exception())\n            return {};\n        y_primitive = rhs.to_primitive(global_object, Value::PreferredType::Number);\n        if (global_object.vm().exception())\n            return {};\n    } else {\n        y_primitive = lhs.to_primitive(global_object, Value::PreferredType::Number);\n        if (global_object.vm().exception())\n            return {};\n        x_primitive = rhs.to_primitive(global_object, Value::PreferredType::Number);\n        if (global_object.vm().exception())\n            return {};\n    }\n\n    if (x_primitive.is_string() && y_primitive.is_string()) {\n        auto x_string = x_primitive.as_string().string();\n        auto y_string = y_primitive.as_string().string();\n\n        Utf8View x_code_points { x_string };\n        Utf8View y_code_points { y_string };\n\n        if (x_code_points.starts_with(y_code_points))\n            return TriState::False;\n        if (y_code_points.starts_with(x_code_points))\n            return TriState::True;\n\n        for (auto k = x_code_points.begin(), l = y_code_points.begin();\n             k != x_code_points.end() && l != y_code_points.end();\n             ++k, ++l) {\n            if (*k != *l) {\n                if (*k < *l) {\n                    return TriState::True;\n                } else {\n                    return TriState::False;\n                }\n            }\n        }\n        VERIFY_NOT_REACHED();\n    }\n\n    if (x_primitive.is_bigint() && y_primitive.is_string()) {\n        auto& y_string = y_primitive.as_string().string();\n        if (!is_valid_bigint_value(y_string))\n            return TriState::Unknown;\n        if (x_primitive.as_bigint().big_integer() < Crypto::SignedBigInteger::from_base10(y_string))\n            return TriState::True;\n        else\n            return TriState::False;\n    }\n\n    if (x_primitive.is_string() && y_primitive.is_bigint()) {\n        auto& x_string = x_primitive.as_string().string();\n        if (!is_valid_bigint_value(x_string))\n            return TriState::Unknown;\n        if (Crypto::SignedBigInteger::from_base10(x_string) < y_primitive.as_bigint().big_integer())\n            return TriState::True;\n        else\n            return TriState::False;\n    }\n\n    auto x_numeric = x_primitive.to_numeric(global_object);\n    if (global_object.vm().exception())\n        return {};\n    auto y_numeric = y_primitive.to_numeric(global_object);\n    if (global_object.vm().exception())\n        return {};\n\n    if (x_numeric.is_nan() || y_numeric.is_nan())\n        return TriState::Unknown;\n\n    if (x_numeric.is_positive_infinity() || y_numeric.is_negative_infinity())\n        return TriState::False;\n\n    if (x_numeric.is_negative_infinity() || y_numeric.is_positive_infinity())\n        return TriState::True;\n\n    if (x_numeric.is_number() && y_numeric.is_number()) {\n        if (x_numeric.as_double() < y_numeric.as_double())\n            return TriState::True;\n        else\n            return TriState::False;\n    }\n\n    if (x_numeric.is_bigint() && y_numeric.is_bigint()) {\n        if (x_numeric.as_bigint().big_integer() < y_numeric.as_bigint().big_integer())\n            return TriState::True;\n        else\n            return TriState::False;\n    }\n\n    VERIFY((x_numeric.is_number() && y_numeric.is_bigint()) || (x_numeric.is_bigint() && y_numeric.is_number()));\n\n    bool x_lower_than_y;\n    if (x_numeric.is_number()) {\n        x_lower_than_y = x_numeric.is_integer()\n            ? Crypto::SignedBigInteger { x_numeric.to_i32(global_object) } < y_numeric.as_bigint().big_integer()\n            : (Crypto::SignedBigInteger { x_numeric.to_i32(global_object) } < y_numeric.as_bigint().big_integer() || Crypto::SignedBigInteger { x_numeric.to_i32(global_object) + 1 } < y_numeric.as_bigint().big_integer());\n    } else {\n        x_lower_than_y = y_numeric.is_integer()\n            ? x_numeric.as_bigint().big_integer() < Crypto::SignedBigInteger { y_numeric.to_i32(global_object) }\n            : (x_numeric.as_bigint().big_integer() < Crypto::SignedBigInteger { y_numeric.to_i32(global_object) } || x_numeric.as_bigint().big_integer() < Crypto::SignedBigInteger { y_numeric.to_i32(global_object) + 1 });\n    }\n    if (x_lower_than_y)\n        return TriState::True;\n    else\n        return TriState::False;\n}\n\nValue less_than(GlobalObject& global_object, Value lhs, Value rhs)\n{\n    TriState relation = abstract_relation(global_object, true, lhs, rhs);\n    if (relation == TriState::Unknown)\n        return Value(false);\n    return Value(relation == TriState::True);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nValue Interpreter::execute_statement(GlobalObject& global_object, const Statement& statement, ScopeType scope_type)\n{\n    if (!is<ScopeNode>(statement))\n        return statement.execute(*this, global_object);\n\n    auto& block = static_cast<const ScopeNode&>(statement);\n    enter_scope(block, scope_type, global_object);\n\n    for (auto& node : block.children()) {\n        auto value = node.execute(*this, global_object);\n        if (!value.is_empty())\n            vm().set_last_value({}, value);\n        if (vm().should_unwind()) {\n            if (!block.label().is_null() && vm().should_unwind_until(ScopeType::Breakable, block.label()))\n                vm().stop_unwind();\n            break;\n        }\n    }\n\n    if (scope_type == ScopeType::Function) {\n        bool did_return = vm().unwind_until() == ScopeType::Function;\n        if (!did_return)\n            vm().set_last_value({}, js_undefined());\n    }\n\n    if (vm().unwind_until() == scope_type)\n        vm().stop_unwind();\n\n    exit_scope(block);\n\n    return vm().last_value();\n}\n\nValue Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}\n\nvoid Interpreter::run(GlobalObject& global_object, const Program& program)\n{\n    auto& vm = this->vm();\n    VERIFY(!vm.exception());\n\n    VM::InterpreterExecutionScope scope(*this);\n\n    vm.set_last_value({}, {});\n\n    CallFrame global_call_frame;\n    global_call_frame.current_node = &program;\n    global_call_frame.this_value = &global_object;\n    static FlyString global_execution_context_name = \"(global execution context)\";\n    global_call_frame.function_name = global_execution_context_name;\n    global_call_frame.scope = &global_object;\n    VERIFY(!vm.exception());\n    global_call_frame.is_strict_mode = program.is_strict_mode();\n    vm.push_call_frame(global_call_frame, global_object);\n    VERIFY(!vm.exception());\n    program.execute(*this, global_object);\n\n    // Whatever the promise jobs or on_call_stack_emptied do should not affect the effective\n    // 'last value'.\n    auto last_value = vm.last_value();\n\n    vm.pop_call_frame();\n\n    // At this point we may have already run any queued promise jobs via on_call_stack_emptied,\n    // in which case this is a no-op.\n    vm.run_queued_promise_jobs();\n\n    vm.set_last_value({}, last_value.value_or(js_undefined()));\n}\n\n\n// target function\n    virtual bool put_by_index(u32 property_index, Value value) override\n    {\n        if (property_index >= m_array_length)\n            return Base::put_by_index(property_index, value);\n\n        if constexpr (sizeof(T) < 4) {\n            auto number = value.to_i32(global_object());\n            if (vm().exception())\n                return {};\n            data()[property_index] = number;\n        } else if constexpr (sizeof(T) == 4 || sizeof(T) == 8) {\n            auto number = value.to_double(global_object());\n            if (vm().exception())\n                return {};\n            data()[property_index] = number;\n        } else {\n            static_assert(DependentFalse<T>, \"TypedArray::put_by_index with unhandled type size\");\n        }\n        return true;\n    }\n    virtual Value get_by_index(u32 property_index) const override\n    {\n        if (property_index >= m_array_length)\n            return Base::get_by_index(property_index);\n\n        if constexpr (sizeof(T) < 4) {\n            return Value((i32)data()[property_index]);\n        } else if constexpr (sizeof(T) == 4 || sizeof(T) == 8) {\n            auto value = data()[property_index];\n            if constexpr (IsFloatingPoint<T>) {\n                return Value((double)value);\n            } else if constexpr (NumericLimits<T>::is_signed()) {\n                if (value > NumericLimits<i32>::max() || value < NumericLimits<i32>::min())\n                    return Value((double)value);\n            } else {\n                if (value > NumericLimits<i32>::max())\n                    return Value((double)value);\n            }\n            return Value((i32)value);\n        } else {\n            static_assert(DependentFalse<T>, \"TypedArray::get_by_index with unhandled type size\");\n        }\n    }\n    Span<T> data()\n    {\n        return { reinterpret_cast<T*>(m_viewed_array_buffer->buffer().data() + m_byte_offset), m_array_length };\n    }\n    virtual size_t element_size() const override { return sizeof(T); };\n    TypedArray(u32 array_length, Object& prototype)\n        : TypedArrayBase(prototype)\n    {\n        VERIFY(!Checked<u32>::multiplication_would_overflow(array_length, sizeof(T)));\n        m_viewed_array_buffer = ArrayBuffer::create(global_object(), array_length * sizeof(T));\n        if (array_length)\n            VERIFY(!data().is_null());\n        m_array_length = array_length;\n        m_byte_length = m_viewed_array_buffer->byte_length();\n    }\nvoid generate_implementation(const IDL::Interface& interface)\n{\n    StringBuilder builder;\n    SourceGenerator generator { builder };\n\n    generator.set(\"name\", interface.name);\n    generator.set(\"wrapper_class\", interface.wrapper_class);\n    generator.set(\"wrapper_base_class\", interface.wrapper_base_class);\n    generator.set(\"prototype_class\", interface.prototype_class);\n    generator.set(\"fully_qualified_name\", interface.fully_qualified_name);\n\n    generator.append(R\"~~~(\n#include <AK/FlyString.h>\n#include <LibJS/Runtime/Array.h>\n#include <LibJS/Runtime/Error.h>\n#include <LibJS/Runtime/Function.h>\n#include <LibJS/Runtime/GlobalObject.h>\n#include <LibJS/Runtime/Uint8ClampedArray.h>\n#include <LibJS/Runtime/Value.h>\n#include <LibWeb/Bindings/@prototype_class@.h>\n#include <LibWeb/Bindings/@wrapper_class@.h>\n#include <LibWeb/Bindings/CanvasRenderingContext2DWrapper.h>\n#include <LibWeb/Bindings/CommentWrapper.h>\n#include <LibWeb/Bindings/DOMImplementationWrapper.h>\n#include <LibWeb/Bindings/DocumentFragmentWrapper.h>\n#include <LibWeb/Bindings/DocumentTypeWrapper.h>\n#include <LibWeb/Bindings/DocumentWrapper.h>\n#include <LibWeb/Bindings/EventTargetWrapperFactory.h>\n#include <LibWeb/Bindings/EventWrapperFactory.h>\n#include <LibWeb/Bindings/HTMLCanvasElementWrapper.h>\n#include <LibWeb/Bindings/HTMLCollectionWrapper.h>\n#include <LibWeb/Bindings/HTMLFormElementWrapper.h>\n#include <LibWeb/Bindings/HTMLHeadElementWrapper.h>\n#include <LibWeb/Bindings/HTMLImageElementWrapper.h>\n#include <LibWeb/Bindings/HTMLTableCaptionElementWrapper.h>\n#include <LibWeb/Bindings/HTMLTableSectionElementWrapper.h>\n#include <LibWeb/Bindings/ImageDataWrapper.h>\n#include <LibWeb/Bindings/NodeWrapperFactory.h>\n#include <LibWeb/Bindings/TextWrapper.h>\n#include <LibWeb/Bindings/WindowObject.h>\n#include <LibWeb/DOM/Element.h>\n#include <LibWeb/DOM/EventListener.h>\n#include <LibWeb/HTML/HTMLElement.h>\n#include <LibWeb/Origin.h>\n\n// FIXME: This is a total hack until we can figure out the namespace for a given type somehow.\nusing namespace Web::CSS;\nusing namespace Web::DOM;\nusing namespace Web::HTML;\n\nnamespace Web::Bindings {\n\n@wrapper_class@* @wrapper_class@::create(JS::GlobalObject& global_object, @fully_qualified_name@& impl)\n{\n    return global_object.heap().allocate<@wrapper_class@>(global_object, global_object, impl);\n}\n\n)~~~\");\n\n    if (interface.wrapper_base_class == \"Wrapper\") {\n        generator.append(R\"~~~(\n@wrapper_class@::@wrapper_class@(JS::GlobalObject& global_object, @fully_qualified_name@& impl)\n    : Wrapper(static_cast<WindowObject&>(global_object).ensure_web_prototype<@prototype_class@>(\"@name@\"))\n    , m_impl(impl)\n{\n}\n)~~~\");\n    } else {\n        generator.append(R\"~~~(\n@wrapper_class@::@wrapper_class@(JS::GlobalObject& global_object, @fully_qualified_name@& impl)\n    : @wrapper_base_class@(global_object, impl)\n{\n    set_prototype(&static_cast<WindowObject&>(global_object).ensure_web_prototype<@prototype_class@>(\"@name@\"));\n}\n)~~~\");\n    }\n\n    generator.append(R\"~~~(\nvoid @wrapper_class@::initialize(JS::GlobalObject& global_object)\n{\n    @wrapper_base_class@::initialize(global_object);\n}\n\n@wrapper_class@::~@wrapper_class@()\n{\n}\n)~~~\");\n\n    if (should_emit_wrapper_factory(interface)) {\n        generator.append(R\"~~~(\n@wrapper_class@* wrap(JS::GlobalObject& global_object, @fully_qualified_name@& impl)\n{\n    return static_cast<@wrapper_class@*>(wrap_impl(global_object, impl));\n}\n)~~~\");\n    }\n\n    generator.append(R\"~~~(\n} // namespace Web::Bindings\n)~~~\");\n\n    outln(\"{}\", generator.as_string_view());\n}\nvoid generate_prototype_implementation(const IDL::Interface& interface)\n{\n    StringBuilder builder;\n    SourceGenerator generator { builder };\n\n    generator.set(\"name\", interface.name);\n    generator.set(\"parent_name\", interface.parent_name);\n    generator.set(\"prototype_class\", interface.prototype_class);\n    generator.set(\"prototype_base_class\", interface.prototype_base_class);\n    generator.set(\"wrapper_class\", interface.wrapper_class);\n    generator.set(\"constructor_class\", interface.constructor_class);\n    generator.set(\"prototype_class:snakecase\", interface.prototype_class.to_snakecase());\n    generator.set(\"fully_qualified_name\", interface.fully_qualified_name);\n\n    generator.append(R\"~~~(\n#include <AK/Function.h>\n#include <LibJS/Runtime/Array.h>\n#include <LibJS/Runtime/Error.h>\n#include <LibJS/Runtime/Function.h>\n#include <LibJS/Runtime/GlobalObject.h>\n#include <LibJS/Runtime/Uint8ClampedArray.h>\n#include <LibWeb/Bindings/@prototype_class@.h>\n#include <LibWeb/Bindings/@wrapper_class@.h>\n#include <LibWeb/Bindings/CSSStyleDeclarationWrapper.h>\n#include <LibWeb/Bindings/CSSStyleSheetWrapper.h>\n#include <LibWeb/Bindings/CanvasRenderingContext2DWrapper.h>\n#include <LibWeb/Bindings/CommentWrapper.h>\n#include <LibWeb/Bindings/DOMImplementationWrapper.h>\n#include <LibWeb/Bindings/DocumentFragmentWrapper.h>\n#include <LibWeb/Bindings/DocumentTypeWrapper.h>\n#include <LibWeb/Bindings/DocumentWrapper.h>\n#include <LibWeb/Bindings/EventTargetWrapperFactory.h>\n#include <LibWeb/Bindings/EventWrapper.h>\n#include <LibWeb/Bindings/EventWrapperFactory.h>\n#include <LibWeb/Bindings/ExceptionOrUtils.h>\n#include <LibWeb/Bindings/HTMLCanvasElementWrapper.h>\n#include <LibWeb/Bindings/HTMLCollectionWrapper.h>\n#include <LibWeb/Bindings/HTMLFormElementWrapper.h>\n#include <LibWeb/Bindings/HTMLHeadElementWrapper.h>\n#include <LibWeb/Bindings/HTMLImageElementWrapper.h>\n#include <LibWeb/Bindings/HTMLTableCaptionElementWrapper.h>\n#include <LibWeb/Bindings/HTMLTableSectionElementWrapper.h>\n#include <LibWeb/Bindings/ImageDataWrapper.h>\n#include <LibWeb/Bindings/NodeWrapperFactory.h>\n#include <LibWeb/Bindings/PerformanceTimingWrapper.h>\n#include <LibWeb/Bindings/RangeWrapper.h>\n#include <LibWeb/Bindings/StyleSheetListWrapper.h>\n#include <LibWeb/Bindings/TextWrapper.h>\n#include <LibWeb/Bindings/WindowObject.h>\n#include <LibWeb/DOM/Element.h>\n#include <LibWeb/DOM/EventListener.h>\n#include <LibWeb/DOM/Range.h>\n#include <LibWeb/DOM/Window.h>\n#include <LibWeb/HTML/EventHandler.h>\n#include <LibWeb/HTML/HTMLElement.h>\n#include <LibWeb/NavigationTiming/PerformanceTiming.h>\n#include <LibWeb/Origin.h>\n\n#if __has_include(<LibWeb/Bindings/@prototype_base_class@.h>)\n#    include <LibWeb/Bindings/@prototype_base_class@.h>\n#endif\n#if __has_include(<LibWeb/CSS/@name@.h>)\n#    include <LibWeb/CSS/@name@.h>\n#elif __has_include(<LibWeb/DOM/@name@.h>)\n#    include <LibWeb/DOM/@name@.h>\n#elif __has_include(<LibWeb/HTML/@name@.h>)\n#    include <LibWeb/HTML/@name@.h>\n#elif __has_include(<LibWeb/UIEvents/@name@.h>)\n#    include <LibWeb/UIEvents/@name@.h>\n#elif __has_include(<LibWeb/HighResolutionTime/@name@.h>)\n#    include <LibWeb/HighResolutionTime/@name@.h>\n#elif __has_include(<LibWeb/NavigationTiming/@name@.h>)\n#    include <LibWeb/NavigationTiming/@name@.h>\n#elif __has_include(<LibWeb/SVG/@name@.h>)\n#    include <LibWeb/SVG/@name@.h>\n#elif __has_include(<LibWeb/XHR/@name@.h>)\n#    include <LibWeb/XHR/@name@.h>\n#endif\n\n// FIXME: This is a total hack until we can figure out the namespace for a given type somehow.\nusing namespace Web::CSS;\nusing namespace Web::DOM;\nusing namespace Web::HTML;\nusing namespace Web::NavigationTiming;\nusing namespace Web::XHR;\n\nnamespace Web::Bindings {\n\n@prototype_class@::@prototype_class@(JS::GlobalObject& global_object)\n    : Object(*global_object.object_prototype())\n{\n)~~~\");\n\n    if (interface.name == \"DOMException\") {\n        // https://heycam.github.io/webidl/#es-DOMException-specialness\n        // Object.getPrototypeOf(DOMException.prototype) === Error.prototype\n        generator.append(R\"~~~(\n    set_prototype(global_object.error_prototype());\n)~~~\");\n    } else if (!interface.parent_name.is_empty()) {\n        generator.append(R\"~~~(\n    set_prototype(&static_cast<WindowObject&>(global_object).ensure_web_prototype<@prototype_base_class@>(\"@parent_name@\"));\n)~~~\");\n    }\n\n    generator.append(R\"~~~(\n}\n\n@prototype_class@::~@prototype_class@()\n{\n}\n\nvoid @prototype_class@::initialize(JS::GlobalObject& global_object)\n{\n    [[maybe_unused]] auto& vm = this->vm();\n    [[maybe_unused]] u8 default_attributes = JS::Attribute::Enumerable | JS::Attribute::Configurable;\n\n)~~~\");\n\n    for (auto& attribute : interface.attributes) {\n        auto attribute_generator = generator.fork();\n        attribute_generator.set(\"attribute.name\", attribute.name);\n        attribute_generator.set(\"attribute.getter_callback\", attribute.getter_callback_name);\n\n        if (attribute.readonly)\n            attribute_generator.set(\"attribute.setter_callback\", \"nullptr\");\n        else\n            attribute_generator.set(\"attribute.setter_callback\", attribute.setter_callback_name);\n\n        attribute_generator.append(R\"~~~(\n    define_native_property(\"@attribute.name@\", @attribute.getter_callback@, @attribute.setter_callback@, default_attributes);\n)~~~\");\n    }\n\n    for (auto& constant : interface.constants) {\n        auto constant_generator = generator.fork();\n        constant_generator.set(\"constant.name\", constant.name);\n        constant_generator.set(\"constant.value\", constant.value);\n\n        constant_generator.append(R\"~~~(\n    define_property(\"@constant.name@\", JS::Value((i32)@constant.value@), JS::Attribute::Enumerable);\n)~~~\");\n    }\n\n    for (auto& function : interface.functions) {\n        auto function_generator = generator.fork();\n        function_generator.set(\"function.name\", function.name);\n        function_generator.set(\"function.name:snakecase\", function.name.to_snakecase());\n        function_generator.set(\"function.length\", String::number(function.length()));\n\n        function_generator.append(R\"~~~(\n    define_native_function(\"@function.name@\", @function.name:snakecase@, @function.length@, default_attributes);\n)~~~\");\n    }\n\n    generator.append(R\"~~~(\n    Object::initialize(global_object);\n}\n)~~~\");\n\n    if (!interface.attributes.is_empty() || !interface.functions.is_empty()) {\n        generator.append(R\"~~~(\nstatic @fully_qualified_name@* impl_from(JS::VM& vm, JS::GlobalObject& global_object)\n{\n    auto* this_object = vm.this_value(global_object).to_object(global_object);\n    if (!this_object)\n        return {};\n)~~~\");\n\n        if (interface.name == \"EventTarget\") {\n            generator.append(R\"~~~(\n    if (is<WindowObject>(this_object)) {\n        return &static_cast<WindowObject*>(this_object)->impl();\n    }\n)~~~\");\n        }\n\n        generator.append(R\"~~~(\n    if (!is<@wrapper_class@>(this_object)) {\n        vm.throw_exception<JS::TypeError>(global_object, JS::ErrorType::NotA, \"@fully_qualified_name@\");\n        return nullptr;\n    }\n\n    return &static_cast<@wrapper_class@*>(this_object)->impl();\n}\n)~~~\");\n    }\n\n    auto generate_return_statement = [&](auto& return_type) {\n        auto scoped_generator = generator.fork();\n        scoped_generator.set(\"return_type\", return_type.name);\n\n        if (return_type.name == \"undefined\") {\n            scoped_generator.append(R\"~~~(\n    return JS::js_undefined();\n)~~~\");\n            return;\n        }\n\n        if (return_type.nullable) {\n            if (return_type.is_string()) {\n                scoped_generator.append(R\"~~~(\n    if (retval.is_null())\n        return JS::js_null();\n)~~~\");\n            } else {\n                scoped_generator.append(R\"~~~(\n    if (!retval)\n        return JS::js_null();\n)~~~\");\n            }\n        }\n\n        if (return_type.is_string()) {\n            scoped_generator.append(R\"~~~(\n    return JS::js_string(vm, retval);\n)~~~\");\n        } else if (return_type.name == \"ArrayFromVector\") {\n            // FIXME: Remove this fake type hack once it's no longer needed.\n            //        Basically once we have NodeList we can throw this out.\n            scoped_generator.append(R\"~~~(\n    auto* new_array = JS::Array::create(global_object);\n    for (auto& element : retval)\n        new_array->indexed_properties().append(wrap(global_object, element));\n\n    return new_array;\n)~~~\");\n        } else if (return_type.name == \"boolean\" || return_type.name == \"double\") {\n            scoped_generator.append(R\"~~~(\n    return JS::Value(retval);\n)~~~\");\n        } else if (return_type.name == \"short\" || return_type.name == \"unsigned short\" || return_type.name == \"long\" || return_type.name == \"unsigned long\") {\n            scoped_generator.append(R\"~~~(\n    return JS::Value((i32)retval);\n)~~~\");\n        } else if (return_type.name == \"Uint8ClampedArray\") {\n            scoped_generator.append(R\"~~~(\n    return retval;\n)~~~\");\n        } else if (return_type.name == \"EventHandler\") {\n            scoped_generator.append(R\"~~~(\n    return retval.callback.cell();\n)~~~\");\n        } else {\n            scoped_generator.append(R\"~~~(\n    return wrap(global_object, const_cast<@return_type@&>(*retval));\n)~~~\");\n        }\n    };\n\n    for (auto& attribute : interface.attributes) {\n        auto attribute_generator = generator.fork();\n        attribute_generator.set(\"attribute.getter_callback\", attribute.getter_callback_name);\n        attribute_generator.set(\"attribute.setter_callback\", attribute.setter_callback_name);\n        attribute_generator.set(\"attribute.name:snakecase\", attribute.name.to_snakecase());\n\n        if (attribute.extended_attributes.contains(\"ImplementedAs\")) {\n            auto implemented_as = attribute.extended_attributes.get(\"ImplementedAs\").value();\n            attribute_generator.set(\"attribute.cpp_getter_name\", implemented_as);\n        } else {\n            attribute_generator.set(\"attribute.cpp_getter_name\", attribute.name.to_snakecase());\n        }\n\n        if (attribute.extended_attributes.contains(\"Reflect\")) {\n            auto attribute_name = attribute.extended_attributes.get(\"Reflect\").value();\n            if (attribute_name.is_null())\n                attribute_name = attribute.name;\n            attribute_name = make_input_acceptable_cpp(attribute_name);\n\n            attribute_generator.set(\"attribute.reflect_name\", attribute_name);\n        } else {\n            attribute_generator.set(\"attribute.reflect_name\", attribute.name.to_snakecase());\n        }\n\n        attribute_generator.append(R\"~~~(\nJS_DEFINE_NATIVE_GETTER(@prototype_class@::@attribute.getter_callback@)\n{\n    auto* impl = impl_from(vm, global_object);\n    if (!impl)\n        return {};\n)~~~\");\n\n        if (attribute.extended_attributes.contains(\"ReturnNullIfCrossOrigin\")) {\n            attribute_generator.append(R\"~~~(\n    if (!impl->may_access_from_origin(static_cast<WindowObject&>(global_object).origin()))\n        return JS::js_null();\n)~~~\");\n        }\n\n        if (attribute.extended_attributes.contains(\"Reflect\")) {\n            if (attribute.type.name != \"boolean\") {\n                attribute_generator.append(R\"~~~(\n    auto retval = impl->attribute(HTML::AttributeNames::@attribute.reflect_name@);\n)~~~\");\n            } else {\n                attribute_generator.append(R\"~~~(\n    auto retval = impl->has_attribute(HTML::AttributeNames::@attribute.reflect_name@);\n)~~~\");\n            }\n        } else {\n            attribute_generator.append(R\"~~~(\n    auto retval = impl->@attribute.cpp_getter_name@();\n)~~~\");\n        }\n\n        generate_return_statement(attribute.type);\n\n        attribute_generator.append(R\"~~~(\n}\n)~~~\");\n\n        if (!attribute.readonly) {\n            attribute_generator.append(R\"~~~(\nJS_DEFINE_NATIVE_SETTER(@prototype_class@::@attribute.setter_callback@)\n{\n    auto* impl = impl_from(vm, global_object);\n    if (!impl)\n        return;\n)~~~\");\n\n            generate_to_cpp(generator, attribute, \"value\", \"\", \"cpp_value\", true, attribute.extended_attributes.contains(\"LegacyNullToEmptyString\"));\n\n            if (attribute.extended_attributes.contains(\"Reflect\")) {\n                if (attribute.type.name != \"boolean\") {\n                    attribute_generator.append(R\"~~~(\n    impl->set_attribute(HTML::AttributeNames::@attribute.reflect_name@, cpp_value);\n)~~~\");\n                } else {\n                    attribute_generator.append(R\"~~~(\n    if (!cpp_value)\n        impl->remove_attribute(HTML::AttributeNames::@attribute.reflect_name@);\n    else\n        impl->set_attribute(HTML::AttributeNames::@attribute.reflect_name@, String::empty());\n)~~~\");\n                }\n            } else {\n                attribute_generator.append(R\"~~~(\n    impl->set_@attribute.name:snakecase@(cpp_value);\n)~~~\");\n            }\n\n            attribute_generator.append(R\"~~~(\n}\n)~~~\");\n        }\n    }\n\n    // Implementation: Functions\n    for (auto& function : interface.functions) {\n        auto function_generator = generator.fork();\n        function_generator.set(\"function.name\", function.name);\n        function_generator.set(\"function.name:snakecase\", function.name.to_snakecase());\n\n        if (function.extended_attributes.contains(\"ImplementedAs\")) {\n            auto implemented_as = function.extended_attributes.get(\"ImplementedAs\").value();\n            function_generator.set(\"function.cpp_name\", implemented_as);\n        } else {\n            function_generator.set(\"function.cpp_name\", function.name.to_snakecase());\n        }\n\n        function_generator.append(R\"~~~(\nJS_DEFINE_NATIVE_FUNCTION(@prototype_class@::@function.name:snakecase@)\n{\n    auto* impl = impl_from(vm, global_object);\n    if (!impl)\n        return {};\n)~~~\");\n\n        generate_argument_count_check(generator, function);\n\n        StringBuilder arguments_builder;\n        generate_arguments(generator, function.parameters, arguments_builder);\n        function_generator.set(\".arguments\", arguments_builder.string_view());\n\n        function_generator.append(R\"~~~(\n    auto result = throw_dom_exception_if_needed(vm, global_object, [&] { return impl->@function.cpp_name@(@.arguments@); });\n    if (should_return_empty(result))\n        return JS::Value();\n\n    [[maybe_unused]] auto retval = result.release_value();\n)~~~\");\n\n        generate_return_statement(function.return_type);\n\n        function_generator.append(R\"~~~(\n}\n)~~~\");\n    }\n\n    generator.append(R\"~~~(\n} // namespace Web::Bindings\n)~~~\");\n\n    outln(\"{}\", generator.as_string_view());\n}\nRefPtr<ImageData> ImageData::create_with_size(JS::GlobalObject& global_object, int width, int height)\n{\n    if (width <= 0 || height <= 0)\n        return nullptr;\n\n    if (width > 16384 || height > 16384)\n        return nullptr;\n\n    dbgln(\"Creating ImageData with {}x{}\", width, height);\n\n    auto* data = JS::Uint8ClampedArray::create(global_object, width * height * 4);\n    if (!data)\n        return nullptr;\n\n    auto data_handle = JS::make_handle(data);\n\n    auto bitmap = Gfx::Bitmap::create_wrapper(Gfx::BitmapFormat::RGBA8888, Gfx::IntSize(width, height), 1, width * sizeof(u32), (u32*)data->data());\n    if (!bitmap)\n        return nullptr;\n    return adopt_ref(*new ImageData(bitmap.release_nonnull(), move(data_handle)));\n}\n",
    "target": 1,
    "idx": 1034584,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid UA_Session_detachFromSecureChannel(UA_Session *session) {\n    if(!session->header.channel)\n        return;\n    session->header.channel = NULL;\n    LIST_REMOVE(&session->header, pointers);\n}\n\nstatic void\nremoveSessionCallback(UA_Server *server, void *entry) {\n    session_list_entry *sentry = (session_list_entry*)entry;\n    UA_Session_deleteMembersCleanup(&sentry->session, server);\n    UA_free(sentry);\n}\n\nstatic void\nprocessDelayedCallbacks(UA_Server *server) {\n    UA_DelayedCallback *dc, *dc_tmp;\n    SLIST_FOREACH_SAFE(dc, &server->delayedCallbacks, next, dc_tmp) {\n        SLIST_REMOVE(&server->delayedCallbacks, dc, UA_DelayedCallback, next);\n        dc->callback(server, dc->data);\n        UA_free(dc);\n    }\n}\n\n\n// target function\nstatic UA_StatusCode\nremoveSession(UA_SessionManager *sm, session_list_entry *sentry) {\n    /* Deactivate the session */\n    sentry->session.activated = false;\n\n    /* Add a delayed callback to remove the session when the currently\n     * scheduled jobs have completed */\n    UA_StatusCode retval = UA_Server_delayedCallback(sm->server, removeSessionCallback, sentry);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING_SESSION(sm->server->config.logger, &sentry->session,\n                       \"Could not remove session with error code %s\",\n                       UA_StatusCode_name(retval));\n        return retval; /* Try again next time */\n    }\n\n    /* Detach the session and make the capacity available */\n    LIST_REMOVE(sentry, pointers);\n    UA_atomic_add(&sm->currentSessionCount, (UA_UInt32)-1);\n    return UA_STATUSCODE_GOOD;\n}\n",
    "target": 1,
    "idx": 1005577,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\n\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\n\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\n\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\n\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\n\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\n\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\n\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\n\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\n\nvoid gf_isom_delete_movie(GF_ISOFile *mov)\n{\n\tif (!mov) return;\n\n\t//these are our two main files\n\tif (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->editFileMap) {\n\t\tgf_isom_datamap_del(mov->editFileMap);\n\t}\n\tif (mov->finalName) gf_free(mov->finalName);\n#endif\n\n\tgf_isom_box_array_del(mov->TopBoxes);\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_box_array_del(mov->moof_list);\n\tif (mov->mfra)\n\t\tgf_isom_box_del((GF_Box*)mov->mfra);\n\tif (mov->sidx_pts_store)\n\t\tgf_free(mov->sidx_pts_store);\n\tif (mov->sidx_pts_next_store)\n\t\tgf_free(mov->sidx_pts_next_store);\n\n\tif (mov->main_sidx)\n\t\tgf_isom_box_del((GF_Box*)mov->main_sidx);\n\n\tif (mov->block_buffer)\n\t\tgf_free(mov->block_buffer);\n#endif\n\tif (mov->last_producer_ref_time)\n\t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);\n\tif (mov->fileName) gf_free(mov->fileName);\n\tgf_free(mov);\n}\n\nstatic int ExecuteFilesOnyByOne(int argc, char **argv) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n  for (int i = 1; i < argc; i++) {\n\n    int fd = open(argv[i], O_RDONLY);\n    if (fd == -1) continue;\n    ssize_t length = read(fd, buf, MAX_FILE);\n    if (length > 0) {\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      LLVMFuzzerTestOneInput(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n  }\n\n  free(buf);\n  return 0;\n\n}\n\nint main(int argc, char **argv) {\n\n  printf(\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for afl++.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before re-spawning the process (default: \"\n      \"INT_MAX)\\n\"\n      \"======================================================\\n\",\n      argv[0], argv[0]);\n\n  if (getenv(\"AFL_GDB\")) {\n\n    char cmd[64];\n    snprintf(cmd, sizeof(cmd), \"cat /proc/%d/maps\", getpid());\n    system(cmd);\n    fprintf(stderr, \"DEBUG: aflpp_driver pid is %d\\n\", getpid());\n    sleep(1);\n\n  }\n\n  output_file = stderr;\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize) {\n\n    fprintf(stderr, \"Running LLVMFuzzerInitialize ...\\n\");\n    LLVMFuzzerInitialize(&argc, &argv);\n    fprintf(stderr, \"continue...\\n\");\n\n  }\n\n  // Do any other expensive one-time initialization here.\n\n  uint8_t dummy_input[64] = {0};\n  memcpy(dummy_input, (void *)AFL_PERSISTENT, sizeof(AFL_PERSISTENT));\n  memcpy(dummy_input + 32, (void *)AFL_DEFER_FORKSVR,\n         sizeof(AFL_DEFER_FORKSVR));\n  int N = INT_MAX;\n  if (argc == 2 && argv[1][0] == '-')\n    N = atoi(argv[1] + 1);\n  else if (argc == 2 && (N = atoi(argv[1])) > 0)\n    printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n  else if (argc > 1) {\n\n    __afl_sharedmem_fuzzing = 0;\n    __afl_manual_init();\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  }\n\n  assert(N > 0);\n\n  //  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n  __afl_manual_init();\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n\n#ifdef _DEBUG\n    fprintf(stderr, \"CLIENT crc: %016llx len: %u\\n\",\n            hash64(__afl_fuzz_ptr, *__afl_fuzz_len, 0xa5b35705),\n            *__afl_fuzz_len);\n    fprintf(stderr, \"RECV:\");\n    for (int i = 0; i < *__afl_fuzz_len; i++)\n      fprintf(stderr, \"%02x\", __afl_fuzz_ptr[i]);\n    fprintf(stderr, \"\\n\");\n#endif\n    if (*__afl_fuzz_len) {\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len);\n\n    }\n\n  }\n\n  printf(\"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n\n}\n\n\n// target function\nGF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, u32 parent_type)\n{\n\tGF_Err e;\n\tGF_Box *a = NULL;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\t//always register boxes\n\t\tif (!parent->child_boxes) {\n\t\t\tparent->child_boxes = gf_list_new();\n\t\t\tif (!parent->child_boxes) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(parent->child_boxes, a);\n\t\tif (e) return e;\n\n\t\tif (parent->registry->add_rem_fn) {\n\t\t\te = parent->registry->add_rem_fn(parent, a, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\t\t//if the box is no longer present, consider it destroyed\n\t\t\t\tif (gf_list_find(parent->child_boxes, a) >=0) {\n\t\t\t\t\tgf_isom_box_del_parent(&parent->child_boxes, a);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n",
    "target": 1,
    "idx": 1032356,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nZIP_EXTERN int\nzip_source_open(zip_source_t *src) {\n    if (src->source_closed) {\n        return -1;\n    }\n    if (src->write_state == ZIP_SOURCE_WRITE_REMOVED) {\n        zip_error_set(&src->error, ZIP_ER_DELETED, 0);\n        return -1;\n    }\n\n    if (ZIP_SOURCE_IS_OPEN_READING(src)) {\n        if ((zip_source_supports(src) & ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_SEEK)) == 0) {\n            zip_error_set(&src->error, ZIP_ER_INUSE, 0);\n            return -1;\n        }\n    }\n    else {\n        if (ZIP_SOURCE_IS_LAYERED(src)) {\n            if (zip_source_open(src->src) < 0) {\n                zip_error_set_from_source(&src->error, src->src);\n                return -1;\n            }\n        }\n\n        if (_zip_source_call(src, NULL, 0, ZIP_SOURCE_OPEN) < 0) {\n            if (ZIP_SOURCE_IS_LAYERED(src)) {\n                zip_source_close(src->src);\n            }\n            return -1;\n        }\n    }\n\n    src->eof = false;\n    src->had_read_error = false;\n    _zip_error_clear(&src->error);\n    src->bytes_read = 0;\n    src->open_count++;\n\n    return 0;\n}\n\nZIP_EXTERN int\nzip_source_open(zip_source_t *src) {\n    if (src->source_closed) {\n        return -1;\n    }\n    if (src->write_state == ZIP_SOURCE_WRITE_REMOVED) {\n        zip_error_set(&src->error, ZIP_ER_DELETED, 0);\n        return -1;\n    }\n\n    if (ZIP_SOURCE_IS_OPEN_READING(src)) {\n        if ((zip_source_supports(src) & ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_SEEK)) == 0) {\n            zip_error_set(&src->error, ZIP_ER_INUSE, 0);\n            return -1;\n        }\n    }\n    else {\n        if (ZIP_SOURCE_IS_LAYERED(src)) {\n            if (zip_source_open(src->src) < 0) {\n                zip_error_set_from_source(&src->error, src->src);\n                return -1;\n            }\n        }\n\n        if (_zip_source_call(src, NULL, 0, ZIP_SOURCE_OPEN) < 0) {\n            if (ZIP_SOURCE_IS_LAYERED(src)) {\n                zip_source_close(src->src);\n            }\n            return -1;\n        }\n    }\n\n    src->eof = false;\n    src->had_read_error = false;\n    _zip_error_clear(&src->error);\n    src->bytes_read = 0;\n    src->open_count++;\n\n    return 0;\n}\n\nstatic void zip_check_torrentzip(zip_t *za, const zip_cdir_t *cdir) {\n    zip_uint32_t crc_should;\n    char buf[8+1];\n    char *end;\n\n    if (cdir == NULL) {\n        return;\n    }\n\n    if (_zip_string_length(cdir->comment) != TORRENTZIP_SIGNATURE_LENGTH + TORRENTZIP_CRC_LENGTH\n        || strncmp((const char *)cdir->comment->raw, TORRENTZIP_SIGNATURE, TORRENTZIP_SIGNATURE_LENGTH) != 0)\n        return;\n\n    memcpy(buf, cdir->comment->raw + TORRENTZIP_SIGNATURE_LENGTH, TORRENTZIP_CRC_LENGTH);\n    buf[TORRENTZIP_CRC_LENGTH] = '\\0';\n    errno = 0;\n    crc_should = strtoul(buf, &end, 16);\n    if ((crc_should == UINT_MAX && errno != 0) || (end && *end)) {\n        return;\n    }\n\n    {\n        zip_stat_t st;\n        zip_source_t* src_window;\n        zip_source_t* src_crc;\n\n        zip_stat_init(&st);\n        st.valid |= ZIP_STAT_SIZE | ZIP_STAT_CRC;\n        st.size = cdir->size;\n        st.crc = crc_should;\n        if ((src_window = _zip_source_window_new(za->src, cdir->offset, cdir->size, &st, NULL, NULL, 0, NULL))  == NULL) {\n            return;\n        }\n        if ((src_crc = zip_source_crc_create(src_window, 1, NULL)) == NULL) {\n            zip_source_free(src_window);\n            return;\n        }\n        if (zip_source_open(src_crc) != 0) {\n            zip_source_free(src_crc);\n            return;\n        }\n        zip_uint8_t buffer[512];\n        while (zip_source_read(src_crc, buffer, sizeof(buffer)) > 0) {\n        }\n        if (zip_source_stat(src_crc, &st) < 0) {\n            zip_source_free(src_crc);\n            return;\n        }\n        zip_source_free(src_crc);\n    }\n\n    /* TODO: if check consistency, check cdir entries for valid values */\n    za->flags |= ZIP_AFL_IS_TORRENTZIP;\n}\n\n\n\n\n\n\n// target function\nstatic void zip_check_torrentzip(zip_t *za, const zip_cdir_t *cdir) {\n    zip_uint32_t crc_should;\n    char buf[8+1];\n    char *end;\n\n    if (cdir == NULL) {\n        return;\n    }\n\n    if (_zip_string_length(cdir->comment) != TORRENTZIP_SIGNATURE_LENGTH + TORRENTZIP_CRC_LENGTH\n        || strncmp((const char *)cdir->comment->raw, TORRENTZIP_SIGNATURE, TORRENTZIP_SIGNATURE_LENGTH) != 0)\n        return;\n\n    memcpy(buf, cdir->comment->raw + TORRENTZIP_SIGNATURE_LENGTH, TORRENTZIP_CRC_LENGTH);\n    buf[TORRENTZIP_CRC_LENGTH] = '\\0';\n    errno = 0;\n    crc_should = strtoul(buf, &end, 16);\n    if ((crc_should == UINT_MAX && errno != 0) || (end && *end)) {\n        return;\n    }\n\n    {\n        zip_stat_t st;\n        zip_source_t* src_window;\n        zip_source_t* src_crc;\n\n        zip_stat_init(&st);\n        st.valid |= ZIP_STAT_SIZE | ZIP_STAT_CRC;\n        st.size = cdir->size;\n        st.crc = crc_should;\n        if ((src_window = _zip_source_window_new(za->src, cdir->offset, cdir->size, &st, NULL, NULL, 0, NULL))  == NULL) {\n            return;\n        }\n        if ((src_crc = zip_source_crc_create(src_window, 1, NULL)) == NULL) {\n            zip_source_free(src_window);\n            return;\n        }\n        zip_source_free(src_window);\n        if (zip_source_open(src_crc) != 0) {\n            zip_source_free(src_crc);\n            return;\n        }\n        zip_uint8_t buffer[512];\n        while (zip_source_read(src_crc, buffer, sizeof(buffer)) > 0) {\n        }\n        if (zip_source_stat(src_crc, &st) < 0) {\n            zip_source_free(src_crc);\n            return;\n        }\n        zip_source_free(src_crc);\n    }\n\n    /* TODO: if check consistency, check cdir entries for valid values */\n    za->flags |= ZIP_AFL_IS_TORRENTZIP;\n}\n",
    "target": 1,
    "idx": 1055365,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n\n\nint __cil_ordered_list_insert(struct cil_list *old, struct cil_list_item *ocurr, struct cil_list_item *nstart, struct cil_list_item *nstop)\n{\n\tstruct cil_list_item *ncurr = NULL;\n\n\tfor (ncurr = nstart; ncurr != nstop; ncurr = ncurr->next) {\n\t\tocurr = __cil_ordered_item_insert(old, ocurr, ncurr);\n\t\tif (ocurr == NULL) {\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\t}\n\treturn SEPOL_OK;\n}\n\nint __cil_ordered_lists_merge(struct cil_list *old, struct cil_list *new)\n{\n\tstruct cil_list_item *omatch = NULL;\n\tstruct cil_list_item *ofirst = old->head;\n\tstruct cil_list_item *ocurr = NULL;\n\tstruct cil_list_item *oprev = NULL;\n\tstruct cil_list_item *nmatch = NULL;\n\tstruct cil_list_item *nfirst = new->head;\n\tstruct cil_list_item *ncurr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (nfirst == NULL) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (ofirst == NULL) {\n\t\t/* First list added */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, NULL);\n\t\treturn rc;\n\t}\n\n\t/* Find a match between the new list and the old one */\n\tfor (nmatch = nfirst; nmatch; nmatch = nmatch->next) {\n\t\tomatch = __cil_ordered_find_match(nmatch, ofirst);\n\t\tif (omatch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nmatch) {\n\t\t/* List cannot be merged yet */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst && omatch != ofirst) {\n\t\t/* Potential ordering conflict--try again later */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst) {\n\t\t/* Prepend the beginning of the new list up to the first match to the old list */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, nmatch);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* In the overlapping protion, add items from the new list not in the old list */\n\tncurr = nmatch->next;\n\tocurr = omatch->next;\n\toprev = omatch;\n\twhile (ncurr && ocurr) {\n\t\tif (ncurr->data == ocurr->data) {\n\t\t\toprev = ocurr;\n\t\t\tocurr = ocurr->next;\n\t\t\tncurr = ncurr->next;\n\t\t} else {\n\t\t\t/* Handle gap in old: old = (A C)  new = (A B C) */\n\t\t\tnmatch = __cil_ordered_find_match(ocurr, ncurr->next);\n\t\t\tif (nmatch) {\n\t\t\t\trc = __cil_ordered_list_insert(old, oprev, ncurr, nmatch);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\toprev = ocurr;\n\t\t\t\tocurr = ocurr->next;\n\t\t\t\tncurr = nmatch->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handle gap in new: old = (A B C)  new = (A C) */\n\t\t\tomatch = __cil_ordered_find_match(ncurr, ocurr->next);\n\t\t\tif (omatch) {\n\t\t\t\t/* Nothing to insert, just skip */\n\t\t\t\toprev = omatch;\n\t\t\t\tocurr = omatch->next;\n\t\t\t\tncurr = ncurr->next;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ncurr) {\n\t\t/* Add the rest of the items from the new list */\n\t\trc = __cil_ordered_list_insert(old, old->tail, ncurr, NULL);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_ordered_lists_merge(struct cil_list *old, struct cil_list *new)\n{\n\tstruct cil_list_item *omatch = NULL;\n\tstruct cil_list_item *ofirst = old->head;\n\tstruct cil_list_item *ocurr = NULL;\n\tstruct cil_list_item *oprev = NULL;\n\tstruct cil_list_item *nmatch = NULL;\n\tstruct cil_list_item *nfirst = new->head;\n\tstruct cil_list_item *ncurr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (nfirst == NULL) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (ofirst == NULL) {\n\t\t/* First list added */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, NULL);\n\t\treturn rc;\n\t}\n\n\t/* Find a match between the new list and the old one */\n\tfor (nmatch = nfirst; nmatch; nmatch = nmatch->next) {\n\t\tomatch = __cil_ordered_find_match(nmatch, ofirst);\n\t\tif (omatch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nmatch) {\n\t\t/* List cannot be merged yet */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst && omatch != ofirst) {\n\t\t/* Potential ordering conflict--try again later */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst) {\n\t\t/* Prepend the beginning of the new list up to the first match to the old list */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, nmatch);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* In the overlapping protion, add items from the new list not in the old list */\n\tncurr = nmatch->next;\n\tocurr = omatch->next;\n\toprev = omatch;\n\twhile (ncurr && ocurr) {\n\t\tif (ncurr->data == ocurr->data) {\n\t\t\toprev = ocurr;\n\t\t\tocurr = ocurr->next;\n\t\t\tncurr = ncurr->next;\n\t\t} else {\n\t\t\t/* Handle gap in old: old = (A C)  new = (A B C) */\n\t\t\tnmatch = __cil_ordered_find_match(ocurr, ncurr->next);\n\t\t\tif (nmatch) {\n\t\t\t\trc = __cil_ordered_list_insert(old, oprev, ncurr, nmatch);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\toprev = ocurr;\n\t\t\t\tocurr = ocurr->next;\n\t\t\t\tncurr = nmatch->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handle gap in new: old = (A B C)  new = (A C) */\n\t\t\tomatch = __cil_ordered_find_match(ncurr, ocurr->next);\n\t\t\tif (omatch) {\n\t\t\t\t/* Nothing to insert, just skip */\n\t\t\t\toprev = omatch;\n\t\t\t\tocurr = omatch->next;\n\t\t\t\tncurr = ncurr->next;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ncurr) {\n\t\t/* Add the rest of the items from the new list */\n\t\trc = __cil_ordered_list_insert(old, old->tail, ncurr, NULL);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}\n\n\n// target function\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_tree_children_destroy(parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 1,
    "idx": 1028459,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid luaH_newkey (lua_State *L, Table *t, const TValue *key, TValue *value) {\n  Node *mp;\n  TValue aux;\n  if (l_unlikely(ttisnil(key)))\n    luaG_runerror(L, \"table index is nil\");\n  else if (ttisfloat(key)) {\n    lua_Number f = fltvalue(key);\n    lua_Integer k;\n    if (luaV_flttointeger(f, &k, F2Ieq)) {  /* does key fit in an integer? */\n      setivalue(&aux, k);\n      key = &aux;  /* insert it as an integer */\n    }\n    else if (l_unlikely(luai_numisnan(f)))\n      luaG_runerror(L, \"table index is NaN\");\n  }\n  if (ttisnil(value))\n    return;  /* do not insert nil values */\n  mp = mainpositionTV(t, key);\n  if (!isempty(gval(mp)) || isdummy(t)) {  /* main position is taken? */\n    Node *othern;\n    Node *f = getfreepos(t);  /* get a free place */\n    if (f == NULL) {  /* cannot find a free place? */\n      rehash(L, t, key);  /* grow table */\n      /* whatever called 'newkey' takes care of TM cache */\n      luaH_set(L, t, key, value);  /* insert key into grown table */\n      return;\n    }\n    lua_assert(!isdummy(t));\n    othern = mainpositionfromnode(t, mp);\n    if (othern != mp) {  /* is colliding node out of its main position? */\n      /* yes; move colliding node into free position */\n      while (othern + gnext(othern) != mp)  /* find previous */\n        othern += gnext(othern);\n      gnext(othern) = cast_int(f - othern);  /* rechain to point to 'f' */\n      *f = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      if (gnext(mp) != 0) {\n        gnext(f) += cast_int(mp - f);  /* correct 'next' */\n        gnext(mp) = 0;  /* now 'mp' is free */\n      }\n      setempty(gval(mp));\n    }\n    else {  /* colliding node is in its own main position */\n      /* new node will go into free position */\n      if (gnext(mp) != 0)\n        gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position */\n      else lua_assert(gnext(f) == 0);\n      gnext(mp) = cast_int(f - mp);\n      mp = f;\n    }\n  }\n  setnodekey(L, mp, key);\n  luaC_barrierback(L, obj2gco(t), key);\n  lua_assert(isempty(gval(mp)));\n  setobj2t(L, gval(mp), value);\n}\n\nvoid luaV_finishset (lua_State *L, const TValue *t, TValue *key,\n                     TValue *val, const TValue *slot) {\n  int loop;  /* counter to avoid infinite loops */\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    const TValue *tm;  /* '__newindex' metamethod */\n    if (slot != NULL) {  /* is 't' a table? */\n      Table *h = hvalue(t);  /* save 't' table */\n      lua_assert(isempty(slot));  /* slot must be empty */\n      tm = fasttm(L, h->metatable, TM_NEWINDEX);  /* get metamethod */\n      if (tm == NULL) {  /* no metamethod? */\n        luaH_finishset(L, h, key, slot, val);  /* set new value */\n        invalidateTMcache(h);\n        luaC_barrierback(L, obj2gco(h), val);\n        return;\n      }\n      /* else will try the metamethod */\n    }\n    else {  /* not a table; check metamethod */\n      tm = luaT_gettmbyobj(L, t, TM_NEWINDEX);\n      if (l_unlikely(notm(tm)))\n        luaG_typeerror(L, t, \"index\");\n    }\n    /* try the metamethod */\n    if (ttisfunction(tm)) {\n      luaT_callTM(L, tm, t, key, val);\n      return;\n    }\n    t = tm;  /* else repeat assignment over 'tm' */\n    if (luaV_fastget(L, t, key, slot, luaH_get)) {\n      luaV_finishfastset(L, t, slot, val);\n      return;  /* done */\n    }\n    /* else 'return luaV_finishset(L, t, key, val, slot)' (loop) */\n  }\n  luaG_runerror(L, \"'__newindex' chain too long; possible loop\");\n}\n\nvoid luaV_execute (lua_State *L, CallInfo *ci) {\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n  const Instruction *pc;\n  int trap;\n#if LUA_USE_JUMPTABLE\n#include \"ljumptab.h\"\n#endif\n startfunc:\n  trap = L->hookmask;\n returning:  /* trap already set */\n  cl = clLvalue(s2v(ci->func));\n  k = cl->p->k;\n  pc = ci->u.l.savedpc;\n  if (l_unlikely(trap)) {\n    if (pc == cl->p->code) {  /* first instruction (not resuming)? */\n      if (cl->p->is_vararg)\n        trap = 0;  /* hooks will start after VARARGPREP instruction */\n      else  /* check 'call' hook */\n        luaD_hookcall(L, ci);\n    }\n    ci->u.l.trap = 1;  /* assume trap is on, for now */\n  }\n  base = ci->func + 1;\n  /* main loop of interpreter */\n  for (;;) {\n    Instruction i;  /* instruction being executed */\n    StkId ra;  /* instruction's A register */\n    vmfetch();\n    #if 0\n      /* low-level line tracing for debugging Lua */\n      printf(\"line: %d\\n\", luaG_getfuncline(cl->p, pcRel(pc, cl->p)));\n    #endif\n    lua_assert(base == ci->func + 1);\n    lua_assert(base <= L->top && L->top < L->stack_last);\n    /* invalidate top for instructions not expecting it */\n    lua_assert(isIT(i) || (cast_void(L->top = base), 1));\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE) {\n        setobjs2s(L, ra, RB(i));\n        vmbreak;\n      }\n      vmcase(OP_LOADI) {\n        lua_Integer b = GETARG_sBx(i);\n        setivalue(s2v(ra), b);\n        vmbreak;\n      }\n      vmcase(OP_LOADF) {\n        int b = GETARG_sBx(i);\n        setfltvalue(s2v(ra), cast_num(b));\n        vmbreak;\n      }\n      vmcase(OP_LOADK) {\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADKX) {\n        TValue *rb;\n        rb = k + GETARG_Ax(*pc); pc++;\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADFALSE) {\n        setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LFALSESKIP) {\n        setbfvalue(s2v(ra));\n        pc++;  /* skip next instruction */\n        vmbreak;\n      }\n      vmcase(OP_LOADTRUE) {\n        setbtvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LOADNIL) {\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(s2v(ra++));\n        } while (b--);\n        vmbreak;\n      }\n      vmcase(OP_GETUPVAL) {\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v);\n        vmbreak;\n      }\n      vmcase(OP_SETUPVAL) {\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v, s2v(ra));\n        luaC_barrier(L, uv, s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_GETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_B(i)]->v;\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, upval, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETTABLE) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = vRC(i);\n        lua_Unsigned n;\n        if (ttisinteger(rc)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))\n            : luaV_fastget(L, rb, rc, slot, luaH_get)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETI) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        int c = GETARG_C(i);\n        if (luaV_fastgeti(L, rb, c, slot)) {\n          setobj2s(L, ra, slot);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishget(L, rb, &key, ra, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_GETFIELD) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_A(i)]->v;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, upval, slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, upval, rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABLE) {\n        const TValue *slot;\n        TValue *rb = vRB(i);  /* key (table is in 'ra') */\n        TValue *rc = RKC(i);  /* value */\n        lua_Unsigned n;\n        if (ttisinteger(rb)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))\n            : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETI) {\n        const TValue *slot;\n        int c = GETARG_B(i);\n        TValue *rc = RKC(i);\n        if (luaV_fastgeti(L, s2v(ra), c, slot)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishset(L, s2v(ra), &key, rc, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETFIELD) {\n        const TValue *slot;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_NEWTABLE) {\n        int b = GETARG_B(i);  /* log2(hash size) + 1 */\n        int c = GETARG_C(i);  /* array size */\n        Table *t;\n        if (b > 0)\n          b = 1 << (b - 1);  /* size is 2^(b - 1) */\n        lua_assert((!TESTARG_k(i)) == (GETARG_Ax(*pc) == 0));\n        if (TESTARG_k(i))  /* non-zero extra argument? */\n          c += GETARG_Ax(*pc) * (MAXARG_C + 1);  /* add it to size */\n        pc++;  /* skip extra argument */\n        L->top = ra + 1;  /* correct top in case of emergency GC */\n        t = luaH_new(L);  /* memory allocation */\n        sethvalue2s(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, c, b);  /* idem */\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_SELF) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        setobj2s(L, ra + 1, rb);\n        if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_ADDI) {\n        op_arithI(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_ADDK) {\n        op_arithK(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUBK) {\n        op_arithK(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MULK) {\n        op_arithK(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MODK) {\n        op_arithK(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POWK) {\n        op_arithfK(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIVK) {\n        op_arithfK(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIVK) {\n        op_arithK(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BANDK) {\n        op_bitwiseK(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BORK) {\n        op_bitwiseK(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXORK) {\n        op_bitwiseK(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHRI) {\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ib, -ic));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SHLI) {\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ic, ib));\n        }\n        vmbreak;\n      }\n      vmcase(OP_ADD) {\n        op_arith(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUB) {\n        op_arith(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MUL) {\n        op_arith(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MOD) {\n        op_arith(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POW) {\n        op_arithf(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIV) {  /* float division (always with floats) */\n        op_arithf(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIV) {  /* floor division */\n        op_arith(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BAND) {\n        op_bitwise(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BOR) {\n        op_bitwise(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXOR) {\n        op_bitwise(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHR) {\n        op_bitwise(L, luaV_shiftr);\n        vmbreak;\n      }\n      vmcase(OP_SHL) {\n        op_bitwise(L, luaV_shiftl);\n        vmbreak;\n      }\n      vmcase(OP_MMBIN) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *rb = vRB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        StkId result = RA(pi);\n        lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);\n        Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINI) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        int imm = GETARG_sB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINK) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *imm = KB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_UNM) {\n        TValue *rb = vRB(i);\n        lua_Number nb;\n        if (ttisinteger(rb)) {\n          lua_Integer ib = ivalue(rb);\n          setivalue(s2v(ra), intop(-, 0, ib));\n        }\n        else if (tonumberns(rb, nb)) {\n          setfltvalue(s2v(ra), luai_numunm(L, nb));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));\n        vmbreak;\n      }\n      vmcase(OP_BNOT) {\n        TValue *rb = vRB(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));\n        vmbreak;\n      }\n      vmcase(OP_NOT) {\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb))\n          setbtvalue(s2v(ra));\n        else\n          setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LEN) {\n        Protect(luaV_objlen(L, ra, vRB(i)));\n        vmbreak;\n      }\n      vmcase(OP_CONCAT) {\n        int n = GETARG_B(i);  /* number of elements to concatenate */\n        L->top = ra + n;  /* mark the end of concat operands */\n        ProtectNT(luaV_concat(L, n));\n        checkGC(L, L->top); /* 'luaV_concat' ensures correct top */\n        vmbreak;\n      }\n      vmcase(OP_CLOSE) {\n        Protect(luaF_close(L, ra, LUA_OK, 1));\n        vmbreak;\n      }\n      vmcase(OP_TBC) {\n        /* create new to-be-closed upvalue */\n        halfProtect(luaF_newtbcupval(L, ra));\n        vmbreak;\n      }\n      vmcase(OP_JMP) {\n        dojump(ci, i, 0);\n        vmbreak;\n      }\n      vmcase(OP_EQ) {\n        int cond;\n        TValue *rb = vRB(i);\n        Protect(cond = luaV_equalobj(L, s2v(ra), rb));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LT) {\n        op_order(L, l_lti, LTnum, lessthanothers);\n        vmbreak;\n      }\n      vmcase(OP_LE) {\n        op_order(L, l_lei, LEnum, lessequalothers);\n        vmbreak;\n      }\n      vmcase(OP_EQK) {\n        TValue *rb = KB(i);\n        /* basic types do not use '__eq'; we can use raw equality */\n        int cond = luaV_rawequalobj(s2v(ra), rb);\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_EQI) {\n        int cond;\n        int im = GETARG_sB(i);\n        if (ttisinteger(s2v(ra)))\n          cond = (ivalue(s2v(ra)) == im);\n        else if (ttisfloat(s2v(ra)))\n          cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));\n        else\n          cond = 0;  /* other types cannot be equal to a number */\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LTI) {\n        op_orderI(L, l_lti, luai_numlt, 0, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_LEI) {\n        op_orderI(L, l_lei, luai_numle, 0, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_GTI) {\n        op_orderI(L, l_gti, luai_numgt, 1, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_GEI) {\n        op_orderI(L, l_gei, luai_numge, 1, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_TEST) {\n        int cond = !l_isfalse(s2v(ra));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_TESTSET) {\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb) == GETARG_k(i))\n          pc++;\n        else {\n          setobj2s(L, ra, rb);\n          donextjump(ci);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CALL) {\n        CallInfo *newci;\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0)  /* fixed number of arguments? */\n          L->top = ra + b;  /* top signals number of arguments */\n        /* else previous instruction set top */\n        savepc(L);  /* in case of errors */\n        if ((newci = luaD_precall(L, ra, nresults)) == NULL)\n          updatetrap(ci);  /* C call; nothing else to be done */\n        else {  /* Lua call: run function in this same C frame */\n          ci = newci;\n          goto startfunc;\n        }\n        vmbreak;\n      }\n      vmcase(OP_TAILCALL) {\n        int b = GETARG_B(i);  /* number of arguments + 1 (function) */\n        int n;  /* number of results when calling a C function */\n        int nparams1 = GETARG_C(i);\n        /* delta is virtual 'func' - real 'func' (vararg functions) */\n        int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;\n        if (b != 0)\n          L->top = ra + b;\n        else  /* previous instruction set top */\n          b = cast_int(L->top - ra);\n        savepc(ci);  /* several calls here can raise errors */\n        if (TESTARG_k(i)) {\n          luaF_closeupval(L, base);  /* close upvalues from current call */\n          lua_assert(L->tbclist < base);  /* no pending tbc variables */\n          lua_assert(base == ci->func + 1);\n        }\n        if ((n = luaD_pretailcall(L, ci, ra, b, delta)) < 0)  /* Lua function? */\n          goto startfunc;  /* execute the callee */\n        else {  /* C function? */\n          ci->func -= delta;  /* restore 'func' (if vararg) */\n          luaD_poscall(L, ci, n);  /* finish caller */\n          updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n          goto ret;  /* caller returns after the tail call */\n        }\n      }\n      vmcase(OP_RETURN) {\n        int n = GETARG_B(i) - 1;  /* number of results */\n        int nparams1 = GETARG_C(i);\n        if (n < 0)  /* not fixed? */\n          n = cast_int(L->top - ra);  /* get what is available */\n        savepc(ci);\n        if (TESTARG_k(i)) {  /* may there be open upvalues? */\n          ci->u2.nres = n;  /* save number of returns */\n          if (L->top < ci->top)\n            L->top = ci->top;\n          luaF_close(L, base, CLOSEKTOP, 1);\n          updatetrap(ci);\n          updatestack(ci);\n        }\n        if (nparams1)  /* vararg function? */\n          ci->func -= ci->u.l.nextraargs + nparams1;\n        L->top = ra + n;  /* set call for 'luaD_poscall' */\n        luaD_poscall(L, ci, n);\n        updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n        goto ret;\n      }\n      vmcase(OP_RETURN0) {\n        if (l_unlikely(L->hookmask)) {\n          L->top = ra;\n          savepc(ci);\n          luaD_poscall(L, ci, 0);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres;\n          L->ci = ci->previous;  /* back to caller */\n          L->top = base - 1;\n          for (nres = ci->nresults; l_unlikely(nres > 0); nres--)\n            setnilvalue(s2v(L->top++));  /* all results are nil */\n        }\n        goto ret;\n      }\n      vmcase(OP_RETURN1) {\n        if (l_unlikely(L->hookmask)) {\n          L->top = ra + 1;\n          savepc(ci);\n          luaD_poscall(L, ci, 1);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          if (nres == 0)\n            L->top = base - 1;  /* asked for no results */\n          else {\n            setobjs2s(L, base - 1, ra);  /* at least this result */\n            L->top = base;\n            for (; l_unlikely(nres > 1); nres--)\n              setnilvalue(s2v(L->top++));  /* complete missing results */\n          }\n        }\n       ret:  /* return from a Lua function */\n        if (ci->callstatus & CIST_FRESH)\n          return;  /* end this frame */\n        else {\n          ci = ci->previous;\n          goto returning;  /* continue running caller in this frame */\n        }\n      }\n      vmcase(OP_FORLOOP) {\n        if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */\n          lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));\n          if (count > 0) {  /* still more iterations? */\n            lua_Integer step = ivalue(s2v(ra + 2));\n            lua_Integer idx = ivalue(s2v(ra));  /* internal index */\n            chgivalue(s2v(ra + 1), count - 1);  /* update counter */\n            idx = intop(+, idx, step);  /* add step to index */\n            chgivalue(s2v(ra), idx);  /* update internal index */\n            setivalue(s2v(ra + 3), idx);  /* and control variable */\n            pc -= GETARG_Bx(i);  /* jump back */\n          }\n        }\n        else if (floatforloop(ra))  /* float loop */\n          pc -= GETARG_Bx(i);  /* jump back */\n        updatetrap(ci);  /* allows a signal to break the loop */\n        vmbreak;\n      }\n      vmcase(OP_FORPREP) {\n        savestate(L, ci);  /* in case of errors */\n        if (forprep(L, ra))\n          pc += GETARG_Bx(i) + 1;  /* skip the loop */\n        vmbreak;\n      }\n      vmcase(OP_TFORPREP) {\n        /* create to-be-closed upvalue (if needed) */\n        halfProtect(luaF_newtbcupval(L, ra + 3));\n        pc += GETARG_Bx(i);\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));\n        goto l_tforcall;\n      }\n      vmcase(OP_TFORCALL) {\n       l_tforcall:\n        /* 'ra' has the iterator function, 'ra + 1' has the state,\n           'ra + 2' has the control variable, and 'ra + 3' has the\n           to-be-closed variable. The call will use the stack after\n           these values (starting at 'ra + 4')\n        */\n        /* push function, state, and control variable */\n        memcpy(ra + 4, ra, 3 * sizeof(*ra));\n        L->top = ra + 4 + 3;\n        ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */\n        updatestack(ci);  /* stack may have changed */\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));\n        goto l_tforloop;\n      }\n      vmcase(OP_TFORLOOP) {\n        l_tforloop:\n        if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */\n          setobjs2s(L, ra + 2, ra + 4);  /* save control variable */\n          pc -= GETARG_Bx(i);  /* jump back */\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETLIST) {\n        int n = GETARG_B(i);\n        unsigned int last = GETARG_C(i);\n        Table *h = hvalue(s2v(ra));\n        if (n == 0)\n          n = cast_int(L->top - ra) - 1;  /* get up to the top */\n        else\n          L->top = ci->top;  /* correct top in case of emergency GC */\n        last += n;\n        if (TESTARG_k(i)) {\n          last += GETARG_Ax(*pc) * (MAXARG_C + 1);\n          pc++;\n        }\n        if (last > luaH_realasize(h))  /* needs more space? */\n          luaH_resizearray(L, h, last);  /* preallocate it at once */\n        for (; n > 0; n--) {\n          TValue *val = s2v(ra + n);\n          setobj2t(L, &h->array[last - 1], val);\n          last--;\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CLOSURE) {\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        halfProtect(pushclosure(L, p, cl->upvals, base, ra));\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_VARARG) {\n        int n = GETARG_C(i) - 1;  /* required results */\n        Protect(luaT_getvarargs(L, ci, ra, n));\n        vmbreak;\n      }\n      vmcase(OP_VARARGPREP) {\n        ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));\n        if (l_unlikely(trap)) {  /* previous \"Protect\" updated trap */\n          luaD_hookcall(L, ci);\n          L->oldpc = 1;  /* next opcode will be seen as a \"new\" line */\n        }\n        updatebase(ci);  /* function has new base after adjustment */\n        vmbreak;\n      }\n      vmcase(OP_EXTRAARG) {\n        lua_assert(0);\n        vmbreak;\n      }\n    }\n  }\n}\n\nl_sinline void ccall (lua_State *L, StkId func, int nResults, int inc) {\n  CallInfo *ci;\n  L->nCcalls += inc;\n  if (l_unlikely(getCcalls(L) >= LUAI_MAXCCALLS))\n    luaE_checkcstack(L);\n  if ((ci = luaD_precall(L, func, nResults)) != NULL) {  /* Lua function? */\n    ci->callstatus = CIST_FRESH;  /* mark that it is a \"fresh\" execute */\n    luaV_execute(L, ci);  /* call it */\n  }\n  L->nCcalls -= inc;\n}\n\nvoid luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  ccall(L, func, nResults, nyci);\n}\n\nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  l_uint32 oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  /* chain new error handler */\n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;  /* restore old error handler */\n  L->nCcalls = oldnCcalls;\n  return lj.status;\n}\n\nint luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (l_unlikely(status != LUA_OK)) {  /* an error occurred? */\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    status = luaD_closeprotected(L, old_top, status);\n    luaD_seterrorobj(L, status, restorestack(L, old_top));\n    luaD_shrinkstack(L);   /* restore stack size in case of overflow */\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}\n\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,\n                        lua_KContext ctx, lua_KFunction k) {\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0;\n  else {\n    StkId o = index2stack(L, errfunc);\n    api_check(L, ttisfunction(s2v(o)), \"error handler must be a function\");\n    func = savestack(L, o);\n  }\n  c.func = L->top - (nargs+1);  /* function to be called */\n  if (k == NULL || !yieldable(L)) {  /* no continuation or no yieldable? */\n    c.nresults = nresults;  /* do a 'conventional' protected call */\n    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);\n  }\n  else {  /* prepare continuation (call is already protected by 'resume') */\n    CallInfo *ci = L->ci;\n    ci->u.c.k = k;  /* save continuation */\n    ci->u.c.ctx = ctx;  /* save context */\n    /* save information for error recovery */\n    ci->u2.funcidx = cast_int(savestack(L, c.func));\n    ci->u.c.old_errfunc = L->errfunc;\n    L->errfunc = func;\n    setoah(ci->callstatus, L->allowhook);  /* save value of 'allowhook' */\n    ci->callstatus |= CIST_YPCALL;  /* function can do error recovery */\n    luaD_call(L, c.func, nresults);  /* do the call */\n    ci->callstatus &= ~CIST_YPCALL;\n    L->errfunc = ci->u.c.old_errfunc;\n    status = LUA_OK;  /* if it is here, there were no errors */\n  }\n  adjustresults(L, nresults);\n  lua_unlock(L);\n  return status;\n}\n\nstatic int ExecuteFilesOnyByOne(int argc, char **argv) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n  for (int i = 1; i < argc; i++) {\n\n    int fd = open(argv[i], O_RDONLY);\n    if (fd == -1) continue;\n    ssize_t length = read(fd, buf, MAX_FILE);\n    if (length > 0) {\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      LLVMFuzzerTestOneInput(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n  }\n\n  free(buf);\n  return 0;\n\n}\n\nint main(int argc, char **argv) {\n\n  printf(\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for afl++.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before re-spawning the process (default: \"\n      \"1000)\\n\"\n      \"======================================================\\n\",\n      argv[0], argv[0]);\n\n  output_file = stderr;\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize) {\n\n    fprintf(stderr, \"Running LLVMFuzzerInitialize ...\\n\");\n    LLVMFuzzerInitialize(&argc, &argv);\n    fprintf(stderr, \"continue...\\n\");\n\n  }\n\n  // Do any other expensive one-time initialization here.\n\n  uint8_t dummy_input[64] = {0};\n  memcpy(dummy_input, (void *)AFL_PERSISTENT, sizeof(AFL_PERSISTENT));\n  memcpy(dummy_input + 32, (void *)AFL_DEFER_FORKSVR,\n         sizeof(AFL_DEFER_FORKSVR));\n  int N = INT_MAX;\n  if (argc == 2 && argv[1][0] == '-')\n    N = atoi(argv[1] + 1);\n  else if (argc == 2 && (N = atoi(argv[1])) > 0)\n    printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n  else if (argc > 1) {\n\n    __afl_sharedmem_fuzzing = 0;\n    __afl_manual_init();\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  }\n\n  assert(N > 0);\n\n  //  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n  __afl_manual_init();\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n\n#ifdef _DEBUG\n    fprintf(stderr, \"CLIENT crc: %016llx len: %u\\n\",\n            hash64(__afl_fuzz_ptr, *__afl_fuzz_len, 0xa5b35705),\n            *__afl_fuzz_len);\n    fprintf(stderr, \"RECV:\");\n    for (int i = 0; i < *__afl_fuzz_len; i++)\n      fprintf(stderr, \"%02x\", __afl_fuzz_ptr[i]);\n    fprintf(stderr, \"\\n\");\n#endif\n    if (*__afl_fuzz_len) {\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len);\n\n    }\n\n  }\n\n  printf(\"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n\n}\n\n\n// target function\nstatic void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n",
    "target": 1,
    "idx": 1044597,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic zend_always_inline uint32_t zend_gc_addref(zend_refcounted_h *p) {\n\tZEND_RC_MOD_CHECK(p);\n\treturn ++(p->refcount);\n}\n\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *var_ptr;\n\tzval *value;\n\n\tSAVE_OPLINE();\n\tvalue = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);\n\tvar_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);\n\n\tdo {\n\t\tif (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {\n\t\t\tzend_reference *ref = Z_REF_P(var_ptr);\n\t\t\tvar_ptr = Z_REFVAL_P(var_ptr);\n\t\t\tif (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {\n\t\t\t\tzend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tzend_binary_op(var_ptr, var_ptr, value OPLINE_CC);\n\t} while (0);\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), var_ptr);\n\t}\n\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op2.var));\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op1.var));\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\n\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)\n{\n\tzend_execute_data *execute_data;\n\tvoid *object_or_called_scope;\n\tuint32_t call_info;\n\n\tif (EG(exception) != NULL) {\n\t\treturn;\n\t}\n\n\tobject_or_called_scope = zend_get_this_object(EG(current_execute_data));\n\tif (EXPECTED(!object_or_called_scope)) {\n\t\tobject_or_called_scope = zend_get_called_scope(EG(current_execute_data));\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE;\n\t} else {\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE | ZEND_CALL_HAS_THIS;\n\t}\n\texecute_data = zend_vm_stack_push_call_frame(call_info,\n\t\t(zend_function*)op_array, 0, object_or_called_scope);\n\tif (EG(current_execute_data)) {\n\t\texecute_data->symbol_table = zend_rebuild_symbol_table();\n\t} else {\n\t\texecute_data->symbol_table = &EG(symbol_table);\n\t}\n\tEX(prev_execute_data) = EG(current_execute_data);\n\ti_init_code_execute_data(execute_data, op_array, return_value);\n\tZEND_OBSERVER_FCALL_BEGIN(execute_data);\n\tzend_execute_ex(execute_data);\n\t/* Observer end handlers are called from ZEND_RETURN */\n\tzend_vm_stack_free_call_frame(execute_data);\n}\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\n// target function\nZEND_API zend_result ZEND_FASTCALL div_function(zval *result, zval *op1, zval *op2) /* {{{ */\n{\n\tZVAL_DEREF(op1);\n\tZVAL_DEREF(op2);\n\n\tint retval = div_function_base(result, op1, op2);\n\tif (EXPECTED(retval == SUCCESS)) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (UNEXPECTED(retval == DIV_BY_ZERO)) {\n\t\tgoto div_by_zero;\n\t}\n\n\tZEND_TRY_BINARY_OBJECT_OPERATION(ZEND_DIV);\n\n\tzval op1_copy, op2_copy;\n\tif (UNEXPECTED(zendi_try_convert_scalar_to_number(op1, &op1_copy) == FAILURE)\n\t\t\t|| UNEXPECTED(zendi_try_convert_scalar_to_number(op2, &op2_copy) == FAILURE)) {\n\t\tzend_binop_error(\"/\", op1, op2);\n\t\tif (result != op1) {\n\t\t\tZVAL_UNDEF(result);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (result == op1) {\n\t\tzval_ptr_dtor(result);\n\t}\n\n\tretval = div_function_base(result, &op1_copy, &op2_copy);\n\tif (retval == SUCCESS) {\n\t\treturn SUCCESS;\n\t}\n\ndiv_by_zero:\n\tZEND_ASSERT(retval == DIV_BY_ZERO && \"TYPES_NOT_HANDLED should not occur here\");\n\tif (result != op1) {\n\t\tZVAL_UNDEF(result);\n\t}\n\tzend_throw_error(zend_ce_division_by_zero_error, \"Division by zero\");\n\treturn FAILURE;\n}\n",
    "target": 1,
    "idx": 1035876,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid gnutls_x509_crl_deinit(gnutls_x509_crl_t crl)\n{\n\tif (!crl)\n\t\treturn;\n\n\tif (crl->crl)\n\t\tasn1_delete_structure(&crl->crl);\n\tgnutls_free(crl->der.data);\n\n\tgnutls_free(crl);\n}\n\nint\ngnutls_pkcs12_simple_parse(gnutls_pkcs12_t p12,\n\t\t\t   const char *password,\n\t\t\t   gnutls_x509_privkey_t * key,\n\t\t\t   gnutls_x509_crt_t ** chain,\n\t\t\t   unsigned int *chain_len,\n\t\t\t   gnutls_x509_crt_t ** extra_certs,\n\t\t\t   unsigned int *extra_certs_len,\n\t\t\t   gnutls_x509_crl_t * crl, unsigned int flags)\n{\n\tgnutls_pkcs12_bag_t bag = NULL;\n\tgnutls_x509_crt_t *_extra_certs = NULL;\n\tunsigned int _extra_certs_len = 0;\n\tgnutls_x509_crt_t *_chain = NULL;\n\tunsigned int _chain_len = 0;\n\tint idx = 0;\n\tint ret;\n\tsize_t cert_id_size = 0;\n\tsize_t key_id_size = 0;\n\tuint8_t cert_id[20];\n\tuint8_t key_id[20];\n\tint privkey_ok = 0;\n\tunsigned int i;\n\tint elements_in_bag;\n\n\t*key = NULL;\n\n\tif (crl)\n\t\t*crl = NULL;\n\n\t/* find the first private key */\n\tfor (;;) {\n\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tif (password == NULL) {\n\t\t\t\tret =\n\t\t\t\t    gnutls_assert_val\n\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_PKCS8_ENCRYPTED_KEY:\n\t\t\t\tif (password == NULL) {\n\t\t\t\t\tret =\n\t\t\t\t\t    gnutls_assert_val\n\t\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* fallthrough */\n\t\t\tcase GNUTLS_BAG_PKCS8_KEY:\n\t\t\t\tif (*key != NULL) {\t/* too simple to continue */\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_init(key);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_import_pkcs8\n\t\t\t\t    (*key, &data, GNUTLS_X509_FMT_DER,\n\t\t\t\t     password,\n\t\t\t\t     type ==\n\t\t\t\t     GNUTLS_BAG_PKCS8_KEY ?\n\t\t\t\t     GNUTLS_PKCS_PLAIN : 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tkey_id_size = sizeof(key_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_privkey_get_key_id(*key, 0,\n\t\t\t\t\t\t\t\t   key_id,\n\t\t\t\t\t\t\t\t   &key_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tprivkey_ok = 1;\t/* break */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\n\t\tif (privkey_ok != 0)\t/* private key was found */\n\t\t\tbreak;\n\t}\n\n\tif (privkey_ok == 0) {\t/* no private key */\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t}\n\n\t/* now find the corresponding certificate \n\t */\n\tidx = 0;\n\tbag = NULL;\n\tfor (;;) {\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\t\t\tgnutls_x509_crt_t this_cert;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_CERTIFICATE:\n\t\t\t\tret = gnutls_x509_crt_init(&this_cert);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_import(this_cert,\n\t\t\t\t\t\t\t   &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* check if the key id match */\n\t\t\t\tcert_id_size = sizeof(cert_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_get_key_id(this_cert,\n\t\t\t\t\t\t\t       0, cert_id,\n\t\t\t\t\t\t\t       &cert_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (memcmp(cert_id, key_id, cert_id_size) != 0) {\t/* they don't match - skip the certificate */\n\t\t\t\t\t_extra_certs =\n\t\t\t\t\t\tgnutls_realloc_fast\n\t\t\t\t\t\t(_extra_certs,\n\t\t\t\t\t\t sizeof(_extra_certs\n\t\t\t\t\t\t\t[0]) *\n\t\t\t\t\t\t ++_extra_certs_len);\n\t\t\t\t\tif (!_extra_certs) {\n\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\tret =\n\t\t\t\t\t\t\tGNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\t_extra_certs\n\t\t\t\t\t\t[_extra_certs_len -\n\t\t\t\t\t\t 1] = this_cert;\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tif (chain && _chain_len == 0) {\n\t\t\t\t\t\t_chain =\n\t\t\t\t\t\t    gnutls_malloc(sizeof\n\t\t\t\t\t\t\t\t  (_chain\n\t\t\t\t\t\t\t\t   [0]) *\n\t\t\t\t\t\t\t\t  (++_chain_len));\n\t\t\t\t\t\tif (!_chain) {\n\t\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\t\tret =\n\t\t\t\t\t\t\t    GNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_chain[_chain_len - 1] =\n\t\t\t\t\t\t    this_cert;\n\t\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgnutls_x509_crt_deinit\n\t\t\t\t\t\t    (this_cert);\n\t\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_CRL:\n\t\t\t\tif (crl == NULL || *crl != NULL) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_crl_init(crl);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crl_import(*crl, &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t\t\t*crl = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_ENCRYPTED:\n\t\t\t\t/* XXX Bother to recurse one level down?  Unlikely to\n\t\t\t\t   use the same password anyway. */\n\t\t\tcase GNUTLS_BAG_EMPTY:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\t}\n\n\tif (chain != NULL) {\n\t\tif (_chain_len != 1) {\n\t\t\tret = GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret =\n\t\t    make_chain(&_chain, &_chain_len, &_extra_certs,\n\t\t\t       &_extra_certs_len, flags);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = 0;\n\n      done:\n\tif (bag)\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\n\tif (ret < 0) {\n\t\tif (*key) {\n\t\t\tgnutls_x509_privkey_deinit(*key);\n\t\t\t*key = NULL;\n\t\t}\n\t\tif (crl != NULL && *crl != NULL) {\n\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t*crl = NULL;\n\t\t}\n\t\tif (_extra_certs_len && _extra_certs != NULL) {\n\t\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\t\tgnutls_free(_extra_certs);\n\t\t}\n\t\tif (_chain_len && _chain != NULL) {\n\t\t\tfor (i = 0; i < _chain_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_chain[i]);\n\t\t\tgnutls_free(_chain);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tif (extra_certs && _extra_certs_len > 0) {\n\t\t*extra_certs = _extra_certs;\n\t\t*extra_certs_len = _extra_certs_len;\n\t} else {\n\t\tif (extra_certs) {\n\t\t\t*extra_certs = NULL;\n\t\t\t*extra_certs_len = 0;\n\t\t}\n\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\tgnutls_free(_extra_certs);\n\t}\n\n\tif (chain != NULL) {\n\t\t*chain = _chain;\n\t\t*chain_len = _chain_len;\n\t}\n\n\treturn ret;\n}\n\n\n// target function\nint\ngnutls_pkcs12_simple_parse(gnutls_pkcs12_t p12,\n\t\t\t   const char *password,\n\t\t\t   gnutls_x509_privkey_t * key,\n\t\t\t   gnutls_x509_crt_t ** chain,\n\t\t\t   unsigned int *chain_len,\n\t\t\t   gnutls_x509_crt_t ** extra_certs,\n\t\t\t   unsigned int *extra_certs_len,\n\t\t\t   gnutls_x509_crl_t * crl, unsigned int flags)\n{\n\tgnutls_pkcs12_bag_t bag = NULL;\n\tgnutls_x509_crt_t *_extra_certs = NULL;\n\tunsigned int _extra_certs_len = 0;\n\tgnutls_x509_crt_t *_chain = NULL;\n\tunsigned int _chain_len = 0;\n\tint idx = 0;\n\tint ret;\n\tsize_t cert_id_size = 0;\n\tsize_t key_id_size = 0;\n\tuint8_t cert_id[20];\n\tuint8_t key_id[20];\n\tint privkey_ok = 0;\n\tunsigned int i;\n\tint elements_in_bag;\n\n\t*key = NULL;\n\n\tif (crl)\n\t\t*crl = NULL;\n\n\t/* find the first private key */\n\tfor (;;) {\n\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tif (password == NULL) {\n\t\t\t\tret =\n\t\t\t\t    gnutls_assert_val\n\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_PKCS8_ENCRYPTED_KEY:\n\t\t\t\tif (password == NULL) {\n\t\t\t\t\tret =\n\t\t\t\t\t    gnutls_assert_val\n\t\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* fallthrough */\n\t\t\tcase GNUTLS_BAG_PKCS8_KEY:\n\t\t\t\tif (*key != NULL) {\t/* too simple to continue */\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_init(key);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_import_pkcs8\n\t\t\t\t    (*key, &data, GNUTLS_X509_FMT_DER,\n\t\t\t\t     password,\n\t\t\t\t     type ==\n\t\t\t\t     GNUTLS_BAG_PKCS8_KEY ?\n\t\t\t\t     GNUTLS_PKCS_PLAIN : 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tkey_id_size = sizeof(key_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_privkey_get_key_id(*key, 0,\n\t\t\t\t\t\t\t\t   key_id,\n\t\t\t\t\t\t\t\t   &key_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tprivkey_ok = 1;\t/* break */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\n\t\tif (privkey_ok != 0)\t/* private key was found */\n\t\t\tbreak;\n\t}\n\n\tif (privkey_ok == 0) {\t/* no private key */\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t}\n\n\t/* now find the corresponding certificate \n\t */\n\tidx = 0;\n\tbag = NULL;\n\tfor (;;) {\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\t\t\tgnutls_x509_crt_t this_cert;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_CERTIFICATE:\n\t\t\t\tret = gnutls_x509_crt_init(&this_cert);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_import(this_cert,\n\t\t\t\t\t\t\t   &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* check if the key id match */\n\t\t\t\tcert_id_size = sizeof(cert_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_get_key_id(this_cert,\n\t\t\t\t\t\t\t       0, cert_id,\n\t\t\t\t\t\t\t       &cert_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (memcmp(cert_id, key_id, cert_id_size) != 0) {\t/* they don't match - skip the certificate */\n\t\t\t\t\t_extra_certs =\n\t\t\t\t\t\tgnutls_realloc_fast\n\t\t\t\t\t\t(_extra_certs,\n\t\t\t\t\t\t sizeof(_extra_certs\n\t\t\t\t\t\t\t[0]) *\n\t\t\t\t\t\t ++_extra_certs_len);\n\t\t\t\t\tif (!_extra_certs) {\n\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\tret =\n\t\t\t\t\t\t\tGNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\t_extra_certs\n\t\t\t\t\t\t[_extra_certs_len -\n\t\t\t\t\t\t 1] = this_cert;\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tif (chain && _chain_len == 0) {\n\t\t\t\t\t\t_chain =\n\t\t\t\t\t\t    gnutls_malloc(sizeof\n\t\t\t\t\t\t\t\t  (_chain\n\t\t\t\t\t\t\t\t   [0]) *\n\t\t\t\t\t\t\t\t  (++_chain_len));\n\t\t\t\t\t\tif (!_chain) {\n\t\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\t\tret =\n\t\t\t\t\t\t\t    GNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_chain[_chain_len - 1] =\n\t\t\t\t\t\t    this_cert;\n\t\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgnutls_x509_crt_deinit\n\t\t\t\t\t\t    (this_cert);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_CRL:\n\t\t\t\tif (crl == NULL || *crl != NULL) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_crl_init(crl);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crl_import(*crl, &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_ENCRYPTED:\n\t\t\t\t/* XXX Bother to recurse one level down?  Unlikely to\n\t\t\t\t   use the same password anyway. */\n\t\t\tcase GNUTLS_BAG_EMPTY:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\t}\n\n\tif (chain != NULL) {\n\t\tif (_chain_len != 1) {\n\t\t\tret = GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret =\n\t\t    make_chain(&_chain, &_chain_len, &_extra_certs,\n\t\t\t       &_extra_certs_len, flags);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = 0;\n\n      done:\n\tif (bag)\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\n\tif (ret < 0) {\n\t\tif (*key) {\n\t\t\tgnutls_x509_privkey_deinit(*key);\n\t\t\t*key = NULL;\n\t\t}\n\t\tif (crl != NULL && *crl != NULL) {\n\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t*crl = NULL;\n\t\t}\n\t\tif (_extra_certs_len && _extra_certs != NULL) {\n\t\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\t\tgnutls_free(_extra_certs);\n\t\t}\n\t\tif (_chain_len && _chain != NULL) {\n\t\t\tfor (i = 0; i < _chain_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_chain[i]);\n\t\t\tgnutls_free(_chain);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tif (extra_certs && _extra_certs_len > 0) {\n\t\t*extra_certs = _extra_certs;\n\t\t*extra_certs_len = _extra_certs_len;\n\t} else {\n\t\tif (extra_certs) {\n\t\t\t*extra_certs = NULL;\n\t\t\t*extra_certs_len = 0;\n\t\t}\n\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\tgnutls_free(_extra_certs);\n\t}\n\n\tif (chain != NULL) {\n\t\t*chain = _chain;\n\t\t*chain_len = _chain_len;\n\t}\n\n\treturn ret;\n}\n",
    "target": 1,
    "idx": 1001304,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid\nUA_SecureChannel_deleteMembersCleanup(UA_SecureChannel *channel) {\n    /* Delete members */\n    UA_ByteString_deleteMembers(&channel->remoteCertificate);\n    UA_ByteString_deleteMembers(&channel->localNonce);\n    UA_ByteString_deleteMembers(&channel->remoteNonce);\n    UA_ChannelSecurityToken_deleteMembers(&channel->securityToken);\n    UA_ChannelSecurityToken_deleteMembers(&channel->nextSecurityToken);\n\n    /* Delete the channel context for the security policy */\n    if(channel->securityPolicy)\n        channel->securityPolicy->channelModule.deleteContext(channel->channelContext);\n\n    /* Detach from the connection and close the connection */\n    if(channel->connection) {\n        if(channel->connection->state != UA_CONNECTION_CLOSED)\n            channel->connection->close(channel->connection);\n        UA_Connection_detachSecureChannel(channel->connection);\n    }\n\n    /* Remove session pointers (not the sessions) and NULL the pointers back to\n     * the SecureChannel in the Session */\n    UA_SessionHeader *sh, *temp;\n    LIST_FOREACH_SAFE(sh, &channel->sessions, pointers, temp) {\n        sh->channel = NULL;\n        LIST_REMOVE(sh, pointers);\n    }\n\n    /* Remove the buffered chunks */\n    struct ChunkEntry *ch, *temp_ch;\n    LIST_FOREACH_SAFE(ch, &channel->chunks, pointers, temp_ch) {\n        UA_ByteString_deleteMembers(&ch->bytes);\n        LIST_REMOVE(ch, pointers);\n        UA_free(ch);\n    }\n}\n\nstatic void\nremoveSecureChannelCallback(UA_Server *server, void *entry) {\n    channel_list_entry *centry = (channel_list_entry*)entry;\n    UA_SecureChannel_deleteMembersCleanup(&centry->channel);\n    UA_free(entry);\n}\n\nstatic void\nprocessDelayedCallbacks(UA_Server *server) {\n    UA_DelayedCallback *dc, *dc_tmp;\n    SLIST_FOREACH_SAFE(dc, &server->delayedCallbacks, next, dc_tmp) {\n        SLIST_REMOVE(&server->delayedCallbacks, dc, UA_DelayedCallback, next);\n        dc->callback(server, dc->data);\n        UA_free(dc);\n    }\n}\n\n\n// target function\nstatic UA_StatusCode\nremoveSession(UA_SessionManager *sm, session_list_entry *sentry) {\n    /* Deactivate the session */\n    sentry->session.activated = false;\n\n    /* Add a delayed callback to remove the session when the currently\n     * scheduled jobs have completed */\n    UA_StatusCode retval = UA_Server_delayedCallback(sm->server, removeSessionCallback, sentry);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING_SESSION(sm->server->config.logger, &sentry->session,\n                       \"Could not remove session with error code %s\",\n                       UA_StatusCode_name(retval));\n        return retval; /* Try again next time */\n    }\n\n    /* Detach the session and make the capacity available */\n    LIST_REMOVE(sentry, pointers);\n    UA_atomic_add(&sm->currentSessionCount, (UA_UInt32)-1);\n    return UA_STATUSCODE_GOOD;\n}\n",
    "target": 1,
    "idx": 1005499,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint __cil_verify_class(struct cil_tree_node *node)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_class *class = node->data;\n\n\tif (class->common != NULL) {\n\t\tstruct cil_class *common = class->common;\n\t\tstruct cil_tree_node *common_node = common->datum.nodes->head->data;\n\t\tstruct cil_tree_node *curr_com_perm = NULL;\n\n\t\tfor (curr_com_perm = common_node->cl_head;\n\t\t\tcurr_com_perm != NULL;\n\t\t\tcurr_com_perm = curr_com_perm->next) {\n\t\t\tstruct cil_perm *com_perm = curr_com_perm->data;\n\t\t\tstruct cil_tree_node *curr_class_perm = NULL;\n\n\t\t\tfor (curr_class_perm = node->cl_head;\n\t\t\t\tcurr_class_perm != NULL;\n\t\t\t\tcurr_class_perm = curr_class_perm->next) {\n\t\t\t\tstruct cil_perm *class_perm = curr_class_perm->data;\n\n\t\t\t\tif (com_perm->datum.name == class_perm->datum.name) {\n\t\t\t\t\tcil_log(CIL_ERR, \"Duplicate permissions between %s common and class declarations\\n\", class_perm->datum.name);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(node, CIL_ERR, \"Invalid class\");\n\treturn rc;\n}\n\nstatic int __cil_verify_classpermission(struct cil_tree_node *node)\n{\n\tstruct cil_classpermission *cp = node->data;\n\n\treturn __cil_verify_classperms(cp->classperms, &cp->datum, NULL, &cp->datum, CIL_CLASSPERMISSION, 0, 2);\n}\n\nint __cil_pre_verify_helper(struct cil_tree_node *node, uint32_t *finished, __attribute__((unused)) void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (node->flavor == CIL_MACRO) {\n\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t} else if (node->flavor == CIL_BLOCK) {\n\t\tstruct cil_block *blk = node->data;\n\t\tif (blk->is_abstract == CIL_TRUE) {\n\t\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\t}\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\tswitch (node->flavor) {\n\tcase CIL_USER:\n\t\trc = __cil_verify_user_pre_eval(node);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase CIL_MAP_CLASS:\n\t\trc = __cil_verify_map_class(node);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSION:\n\t\trc = __cil_verify_classpermission(node);\n\t\tbreak;\n\tdefault:\n\t\trc = SEPOL_OK;\n\t\tbreak;\n\t}\n\nexit:\n\treturn rc;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nstatic int cil_pre_verify(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_verify extra_args;\n\n\textra_args.db = db;\n\n\trc = cil_tree_walk(db->ast->root, __cil_pre_verify_helper, NULL, NULL, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n}\n\nint cil_post_process(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_pre_verify(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_post_db(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed post db handling\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_post_verify(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n\t\t\n}\n\nint cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}\n\n\n// target function\nstatic void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_reset_classperms_list(cp->classperms);\n}\n",
    "target": 1,
    "idx": 1031065,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nlong int igraph_vector_ptr_size(const igraph_vector_ptr_t* v) {\n    IGRAPH_ASSERT(v != NULL);\n    /*  IGRAPH_ASSERT(v->stor_begin != NULL);       */ /* TODO */\n    return v->end - v->stor_begin;\n}\n\nvoid igraph_gml_tree_destroy(igraph_gml_tree_t *t) {\n\n    long int i, n = igraph_vector_ptr_size(&t->children);\n    for (i = 0; i < n; i++) {\n        int type = VECTOR(t->types)[i];\n        switch (type) {\n        case IGRAPH_I_GML_TREE_TREE:\n            igraph_gml_tree_destroy(VECTOR(t->children)[i]);\n            igraph_Free(VECTOR(t->names)[i]);\n            break;\n        case IGRAPH_I_GML_TREE_INTEGER:\n            igraph_Free(VECTOR(t->children)[i]);\n            igraph_Free(VECTOR(t->names)[i]);\n            break;\n        case IGRAPH_I_GML_TREE_REAL:\n            igraph_Free(VECTOR(t->children)[i]);\n            igraph_Free(VECTOR(t->names)[i]);\n            break;\n        case IGRAPH_I_GML_TREE_STRING:\n            igraph_Free(VECTOR(t->children)[i]);\n            igraph_Free(VECTOR(t->names)[i]);\n            break;\n        case IGRAPH_I_GML_TREE_DELETED:\n            break;\n        }\n    }\n    igraph_vector_ptr_destroy(&t->names);\n    igraph_vector_char_destroy(&t->types);\n    igraph_vector_ptr_destroy(&t->children);\n    igraph_Free(t);\n}\n\nvoid igraph_i_gml_parsedata_destroy(igraph_i_gml_parsedata_t* context) {\n    if (context->tree != 0) {\n        igraph_gml_tree_destroy(context->tree);\n        context->tree = 0;\n    }\n\n    if (context->scanner != 0) {\n        igraph_gml_yylex_destroy(context->scanner);\n        context->scanner = 0;\n    }\n}\n\nvoid IGRAPH_FINALLY_FREE(void) {\n    int p;\n    /*   printf(\"[X] Finally stack will be cleaned (contained %d elements)\\n\", igraph_i_finally_stack[0].all);  */\n    for (p = igraph_i_finally_stack[0].all - 1; p >= 0; p--) {\n        igraph_i_finally_stack[p].func(igraph_i_finally_stack[p].ptr);\n    }\n    igraph_i_finally_stack[0].all = 0;\n}\n\nvoid igraph_error_handler_ignore (const char *reason, const char *file,\n                                  int line, int igraph_errno) {\n    IGRAPH_UNUSED(reason);\n    IGRAPH_UNUSED(file);\n    IGRAPH_UNUSED(line);\n    IGRAPH_UNUSED(igraph_errno);\n\n    IGRAPH_FINALLY_FREE();\n}\n\nint igraph_error(const char *reason, const char *file, int line,\n                 int igraph_errno) {\n\n    if (igraph_i_error_handler) {\n        igraph_i_error_handler(reason, file, line, igraph_errno);\n#ifndef USING_R\n    }  else {\n        igraph_error_handler_abort(reason, file, line, igraph_errno);\n#endif\n    }\n    return igraph_errno;\n}\n\n\n// target function\nint igraph_read_graph_gml(igraph_t *graph, FILE *instream) {\n\n    long int i, p;\n    long int no_of_nodes = 0, no_of_edges = 0;\n    igraph_trie_t trie;\n    igraph_vector_t edges;\n    igraph_bool_t directed = IGRAPH_UNDIRECTED;\n    igraph_gml_tree_t *gtree;\n    long int gidx;\n    igraph_trie_t vattrnames;\n    igraph_trie_t eattrnames;\n    igraph_trie_t gattrnames;\n    igraph_vector_ptr_t gattrs = IGRAPH_VECTOR_PTR_NULL,\n                        vattrs = IGRAPH_VECTOR_PTR_NULL, eattrs = IGRAPH_VECTOR_PTR_NULL;\n    igraph_vector_ptr_t *attrs[3];\n    long int edgeptr = 0;\n    igraph_i_gml_parsedata_t context;\n\n    attrs[0] = &gattrs; attrs[1] = &vattrs; attrs[2] = &eattrs;\n\n    IGRAPH_CHECK(igraph_i_gml_parsedata_init(&context));\n    IGRAPH_FINALLY(igraph_i_gml_parsedata_destroy, &context);\n\n    igraph_gml_yylex_init_extra(&context, &context.scanner);\n\n    igraph_gml_yyset_in(instream, context.scanner);\n\n    i = igraph_gml_yyparse(&context);\n    if (i != 0) {\n        if (context.errmsg[0] != 0) {\n            IGRAPH_ERROR(context.errmsg, IGRAPH_PARSEERROR);\n        } else {\n            IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_PARSEERROR);\n        }\n    }\n\n    IGRAPH_VECTOR_INIT_FINALLY(&edges, 0);\n\n    /* Check version, if present, integer and not '1' then ignored */\n    i = igraph_gml_tree_find(context.tree, \"Version\", 0);\n    if (i >= 0 &&\n        igraph_gml_tree_type(context.tree, i) == IGRAPH_I_GML_TREE_INTEGER &&\n        igraph_gml_tree_get_integer(context.tree, i) != 1) {\n        igraph_gml_tree_destroy(context.tree);\n        IGRAPH_ERROR(\"Unknown GML version\", IGRAPH_UNIMPLEMENTED);\n        /* RETURN HERE!!!! */\n    }\n\n    /* get the graph */\n    gidx = igraph_gml_tree_find(context.tree, \"graph\", 0);\n    if (gidx == -1) {\n        IGRAPH_ERROR(\"No 'graph' object in GML file\", IGRAPH_PARSEERROR);\n    }\n    if (igraph_gml_tree_type(context.tree, gidx) !=\n        IGRAPH_I_GML_TREE_TREE) {\n        IGRAPH_ERROR(\"Invalid type for 'graph' object in GML file\", IGRAPH_PARSEERROR);\n    }\n    gtree = igraph_gml_tree_get_tree(context.tree, gidx);\n\n    IGRAPH_FINALLY(igraph_i_gml_destroy_attrs, attrs);\n    igraph_vector_ptr_init(&gattrs, 0);\n    igraph_vector_ptr_init(&vattrs, 0);\n    igraph_vector_ptr_init(&eattrs, 0);\n\n    IGRAPH_TRIE_INIT_FINALLY(&trie, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&vattrnames, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&eattrnames, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&gattrnames, 0);\n\n    /* Is is directed? */\n    i = igraph_gml_tree_find(gtree, \"directed\", 0);\n    if (i >= 0 && igraph_gml_tree_type(gtree, i) == IGRAPH_I_GML_TREE_INTEGER) {\n        if (igraph_gml_tree_get_integer(gtree, i) == 1) {\n            directed = IGRAPH_DIRECTED;\n        }\n    }\n\n    /* Now we go over all objects in the graph and collect the attribute names and\n       types. Plus we collect node ids. We also do some checks. */\n    for (i = 0; i < igraph_gml_tree_length(gtree); i++) {\n        long int j;\n        char cname[100];\n        const char *name = igraph_gml_tree_name(gtree, i);\n        if (!strcmp(name, \"node\")) {\n            igraph_gml_tree_t *node;\n            igraph_bool_t hasid;\n            no_of_nodes++;\n            if (igraph_gml_tree_type(gtree, i) != IGRAPH_I_GML_TREE_TREE) {\n                IGRAPH_ERROR(\"'node' is not a list\", IGRAPH_PARSEERROR);\n            }\n            node = igraph_gml_tree_get_tree(gtree, i);\n            hasid = 0;\n            for (j = 0; j < igraph_gml_tree_length(node); j++) {\n                const char *name = igraph_gml_tree_name(node, j);\n                long int trieid, triesize = igraph_trie_size(&vattrnames);\n                IGRAPH_CHECK(igraph_trie_get(&vattrnames, name, &trieid));\n                if (trieid == triesize) {\n                    /* new attribute */\n                    igraph_attribute_record_t *atrec = igraph_Calloc(1, igraph_attribute_record_t);\n                    int type = igraph_gml_tree_type(node, j);\n                    if (!atrec) {\n                        IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_ENOMEM);\n                    }\n                    IGRAPH_CHECK(igraph_vector_ptr_push_back(&vattrs, atrec));\n                    atrec->name = strdup(name);\n                    if (type == IGRAPH_I_GML_TREE_INTEGER || type == IGRAPH_I_GML_TREE_REAL) {\n                        atrec->type = IGRAPH_ATTRIBUTE_NUMERIC;\n                    } else {\n                        atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                    }\n                } else {\n                    /* already seen, should we update type? */\n                    igraph_attribute_record_t *atrec = VECTOR(vattrs)[trieid];\n                    int type1 = atrec->type;\n                    int type2 = igraph_gml_tree_type(node, j);\n                    if (type1 == IGRAPH_ATTRIBUTE_NUMERIC && type2 == IGRAPH_I_GML_TREE_STRING) {\n                        atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                    }\n                }\n                /* check id */\n                if (!hasid && !strcmp(name, \"id\")) {\n                    long int id;\n                    if (igraph_gml_tree_type(node, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer node id in GML file\", IGRAPH_PARSEERROR);\n                    }\n                    id = igraph_gml_tree_get_integer(node, j);\n                    snprintf(cname, sizeof(cname) / sizeof(char) -1, \"%li\", id);\n                    IGRAPH_CHECK(igraph_trie_get(&trie, cname, &id));\n                    hasid = 1;\n                }\n            }\n            if (!hasid) {\n                IGRAPH_ERROR(\"Node without 'id' while parsing GML file\", IGRAPH_PARSEERROR);\n            }\n        } else if (!strcmp(name, \"edge\")) {\n            igraph_gml_tree_t *edge;\n            igraph_bool_t has_source = 0, has_target = 0;\n            no_of_edges++;\n            if (igraph_gml_tree_type(gtree, i) != IGRAPH_I_GML_TREE_TREE) {\n                IGRAPH_ERROR(\"'edge' is not a list\", IGRAPH_PARSEERROR);\n            }\n            edge = igraph_gml_tree_get_tree(gtree, i);\n            has_source = has_target = 0;\n            for (j = 0; j < igraph_gml_tree_length(edge); j++) {\n                const char *name = igraph_gml_tree_name(edge, j);\n                if (!strcmp(name, \"source\")) {\n                    has_source = 1;\n                    if (igraph_gml_tree_type(edge, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer 'source' for an edge in GML file\",\n                                     IGRAPH_PARSEERROR);\n                    }\n                } else if (!strcmp(name, \"target\")) {\n                    has_target = 1;\n                    if (igraph_gml_tree_type(edge, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer 'source' for an edge in GML file\",\n                                     IGRAPH_PARSEERROR);\n                    }\n                } else {\n                    long int trieid, triesize = igraph_trie_size(&eattrnames);\n                    IGRAPH_CHECK(igraph_trie_get(&eattrnames, name, &trieid));\n                    if (trieid == triesize) {\n                        /* new attribute */\n                        igraph_attribute_record_t *atrec = igraph_Calloc(1, igraph_attribute_record_t);\n                        int type = igraph_gml_tree_type(edge, j);\n                        if (!atrec) {\n                            IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_ENOMEM);\n                        }\n                        IGRAPH_CHECK(igraph_vector_ptr_push_back(&eattrs, atrec));\n                        atrec->name = strdup(name);\n                        if (type == IGRAPH_I_GML_TREE_INTEGER || type == IGRAPH_I_GML_TREE_REAL) {\n                            atrec->type = IGRAPH_ATTRIBUTE_NUMERIC;\n                        } else {\n                            atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                        }\n                    } else {\n                        /* already seen, should we update type? */\n                        igraph_attribute_record_t *atrec = VECTOR(eattrs)[trieid];\n                        int type1 = atrec->type;\n                        int type2 = igraph_gml_tree_type(edge, j);\n                        if (type1 == IGRAPH_ATTRIBUTE_NUMERIC && type2 == IGRAPH_I_GML_TREE_STRING) {\n                            atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                        }\n                    }\n                }\n            } /* for */\n            if (!has_source) {\n                IGRAPH_ERROR(\"No 'source' for edge in GML file\", IGRAPH_PARSEERROR);\n            }\n            if (!has_target) {\n                IGRAPH_ERROR(\"No 'target' for edge in GML file\", IGRAPH_PARSEERROR);\n            }\n        } else {\n            /* anything to do? Maybe add as graph attribute.... */\n        }\n    }\n\n    /* check vertex id uniqueness */\n    if (igraph_trie_size(&trie) != no_of_nodes) {\n        IGRAPH_ERROR(\"Node 'id' not unique\", IGRAPH_PARSEERROR);\n    }\n\n    /* now we allocate the vectors and strvectors for the attributes */\n    for (i = 0; i < igraph_vector_ptr_size(&vattrs); i++) {\n        igraph_attribute_record_t *atrec = VECTOR(vattrs)[i];\n        int type = atrec->type;\n        if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n            igraph_vector_t *p = igraph_Calloc(1, igraph_vector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_vector_init(p, no_of_nodes));\n        } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n            igraph_strvector_t *p = igraph_Calloc(1, igraph_strvector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_strvector_init(p, no_of_nodes));\n        } else {\n            IGRAPH_WARNING(\"A composite attribute ignored\");\n        }\n    }\n\n    for (i = 0; i < igraph_vector_ptr_size(&eattrs); i++) {\n        igraph_attribute_record_t *atrec = VECTOR(eattrs)[i];\n        int type = atrec->type;\n        if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n            igraph_vector_t *p = igraph_Calloc(1, igraph_vector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_vector_init(p, no_of_edges));\n        } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n            igraph_strvector_t *p = igraph_Calloc(1, igraph_strvector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_strvector_init(p, no_of_edges));\n        } else {\n            IGRAPH_WARNING(\"A composite attribute ignored\");\n        }\n    }\n\n    /* Ok, now the edges, attributes too */\n    IGRAPH_CHECK(igraph_vector_resize(&edges, no_of_edges * 2));\n    p = -1;\n    while ( (p = igraph_gml_tree_find(gtree, \"edge\", p + 1)) != -1) {\n        igraph_gml_tree_t *edge;\n        long int from, to, fromidx = 0, toidx = 0;\n        char name[100];\n        long int j;\n        edge = igraph_gml_tree_get_tree(gtree, p);\n        for (j = 0; j < igraph_gml_tree_length(edge); j++) {\n            const char *n = igraph_gml_tree_name(edge, j);\n            if (!strcmp(n, \"source\")) {\n                fromidx = igraph_gml_tree_find(edge, \"source\", 0);\n            } else if (!strcmp(n, \"target\")) {\n                toidx = igraph_gml_tree_find(edge, \"target\", 0);\n            } else {\n                long int edgeid = edgeptr / 2;\n                long int trieidx;\n                igraph_attribute_record_t *atrec;\n                int type;\n                igraph_trie_get(&eattrnames, n, &trieidx);\n                atrec = VECTOR(eattrs)[trieidx];\n                type = atrec->type;\n                if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n                    igraph_vector_t *v = (igraph_vector_t *)atrec->value;\n                    IGRAPH_CHECK(igraph_i_gml_toreal(edge, j, VECTOR(*v) + edgeid));\n                } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n                    igraph_strvector_t *v = (igraph_strvector_t *)atrec->value;\n                    const char *value = igraph_i_gml_tostring(edge, j);\n                    IGRAPH_CHECK(igraph_strvector_set(v, edgeid, value));\n                }\n            }\n        }\n        from = igraph_gml_tree_get_integer(edge, fromidx);\n        to = igraph_gml_tree_get_integer(edge, toidx);\n        snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", from);\n        IGRAPH_CHECK(igraph_trie_get(&trie, name, &from));\n        snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", to);\n        IGRAPH_CHECK(igraph_trie_get(&trie, name, &to));\n        if (igraph_trie_size(&trie) != no_of_nodes) {\n            IGRAPH_ERROR(\"Unknown node id found at an edge\", IGRAPH_PARSEERROR);\n        }\n        VECTOR(edges)[edgeptr++] = from;\n        VECTOR(edges)[edgeptr++] = to;\n    }\n\n    /* and add vertex attributes */\n    for (i = 0; i < igraph_gml_tree_length(gtree); i++) {\n        const char *n;\n        char name[100];\n        long int j, k;\n        n = igraph_gml_tree_name(gtree, i);\n        if (!strcmp(n, \"node\")) {\n            igraph_gml_tree_t *node = igraph_gml_tree_get_tree(gtree, i);\n            long int iidx = igraph_gml_tree_find(node, \"id\", 0);\n            long int id = igraph_gml_tree_get_integer(node, iidx);\n            snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", id);\n            igraph_trie_get(&trie, name, &id);\n            for (j = 0; j < igraph_gml_tree_length(node); j++) {\n                const char *aname = igraph_gml_tree_name(node, j);\n                igraph_attribute_record_t *atrec;\n                int type;\n                igraph_trie_get(&vattrnames, aname, &k);\n                atrec = VECTOR(vattrs)[k];\n                type = atrec->type;\n                if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n                    igraph_vector_t *v = (igraph_vector_t *)atrec->value;\n                    IGRAPH_CHECK(igraph_i_gml_toreal(node, j, VECTOR(*v) + id));\n                } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n                    igraph_strvector_t *v = (igraph_strvector_t *)atrec->value;\n                    const char *value = igraph_i_gml_tostring(node, j);\n                    IGRAPH_CHECK(igraph_strvector_set(v, id, value));\n                }\n            }\n        }\n    }\n\n    igraph_trie_destroy(&trie);\n    igraph_trie_destroy(&gattrnames);\n    igraph_trie_destroy(&vattrnames);\n    igraph_trie_destroy(&eattrnames);\n    IGRAPH_FINALLY_CLEAN(4);\n\n    IGRAPH_CHECK(igraph_empty_attrs(graph, 0, directed, 0)); /* TODO */\n    IGRAPH_CHECK(igraph_add_vertices(graph, (igraph_integer_t) no_of_nodes,\n                                     &vattrs));\n    IGRAPH_CHECK(igraph_add_edges(graph, &edges, &eattrs));\n\n    igraph_i_gml_destroy_attrs(attrs);\n    igraph_vector_destroy(&edges);\n    igraph_i_gml_parsedata_destroy(&context);\n    IGRAPH_FINALLY_CLEAN(3);\n\n    return 0;\n}\n",
    "target": 1,
    "idx": 1029408,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n\n    if (doc == NULL) return(-1);\n    if ((attr == NULL) || (attr->id == NULL)) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)\n        return(-1);\n\n    attr->atype = 0;\n    attr->id = NULL;\n\n    return(0);\n}\n\nvoid\nxmlFreeProp(xmlAttrPtr cur) {\n    xmlDictPtr dict = NULL;\n    if (cur == NULL) return;\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {\n\t    xmlRemoveID(cur->doc, cur);\n    }\n    if (cur->children != NULL) xmlFreeNodeList(cur->children);\n    DICT_FREE(cur->name)\n    xmlFree(cur);\n}\n\nvoid\nxmlFreePropList(xmlAttrPtr cur) {\n    xmlAttrPtr next;\n    if (cur == NULL) return;\n    while (cur != NULL) {\n        next = cur->next;\n        xmlFreeProp(cur);\n\tcur = next;\n    }\n}\n\nvoid\nxmlFreeNode(xmlNodePtr cur) {\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return;\n\n    /* use xmlFreeDtd for DTD nodes */\n    if (cur->type == XML_DTD_NODE) {\n\txmlFreeDtd((xmlDtdPtr) cur);\n\treturn;\n    }\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNs((xmlNsPtr) cur);\n        return;\n    }\n    if (cur->type == XML_ATTRIBUTE_NODE) {\n\txmlFreeProp((xmlAttrPtr) cur);\n\treturn;\n    }\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue(cur);\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if (cur->type == XML_ENTITY_DECL) {\n        xmlEntityPtr ent = (xmlEntityPtr) cur;\n\tDICT_FREE(ent->SystemID);\n\tDICT_FREE(ent->ExternalID);\n    }\n    if ((cur->children != NULL) &&\n\t(cur->type != XML_ENTITY_REF_NODE))\n\txmlFreeNodeList(cur->children);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n        (cur->type == XML_XINCLUDE_START) ||\n        (cur->type == XML_XINCLUDE_END)) {\n        if (cur->properties != NULL)\n            xmlFreePropList(cur->properties);\n        if (cur->nsDef != NULL)\n            xmlFreeNsList(cur->nsDef);\n    } else if ((cur->content != NULL) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->content != (xmlChar *) &(cur->properties))) {\n        DICT_FREE(cur->content)\n    }\n\n    /*\n     * When a node is a text node or a comment, it uses a global static\n     * variable for the name of the node.\n     * Otherwise the node name might come from the document's dictionary\n     */\n    if ((cur->name != NULL) &&\n        (cur->type != XML_TEXT_NODE) &&\n        (cur->type != XML_COMMENT_NODE))\n\tDICT_FREE(cur->name)\n\n    xmlFree(cur);\n}\n\nxmlNodePtr\nxmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,\n                  int extended) {\n    xmlNodePtr ret;\n\n    if (node == NULL) return(NULL);\n    switch (node->type) {\n        case XML_TEXT_NODE:\n        case XML_CDATA_SECTION_NODE:\n        case XML_ELEMENT_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_ENTITY_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n\t    break;\n        case XML_ATTRIBUTE_NODE:\n\t\treturn((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n        case XML_NAMESPACE_DECL:\n\t    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_TREE_ENABLED\n\t    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n#endif /* LIBXML_TREE_ENABLED */\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_NOTATION_NODE:\n        case XML_DTD_NODE:\n        case XML_ELEMENT_DECL:\n        case XML_ATTRIBUTE_DECL:\n        case XML_ENTITY_DECL:\n            return(NULL);\n    }\n\n    /*\n     * Allocate a new node and fill the fields.\n     */\n    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n    if (ret == NULL)\n\treturn(NULL);\n    memset(ret, 0, sizeof(xmlNode));\n    ret->type = node->type;\n\n    ret->doc = doc;\n    ret->parent = parent;\n    if (node->name == xmlStringText)\n\tret->name = xmlStringText;\n    else if (node->name == xmlStringTextNoenc)\n\tret->name = xmlStringTextNoenc;\n    else if (node->name == xmlStringComment)\n\tret->name = xmlStringComment;\n    else if (node->name != NULL) {\n        if ((doc != NULL) && (doc->dict != NULL))\n\t    ret->name = xmlDictLookup(doc->dict, node->name, -1);\n\telse\n\t    ret->name = xmlStrdup(node->name);\n        if (ret->name == NULL)\n            goto error;\n    }\n    if ((node->type != XML_ELEMENT_NODE) &&\n\t(node->content != NULL) &&\n\t(node->type != XML_ENTITY_REF_NODE) &&\n\t(node->type != XML_XINCLUDE_END) &&\n\t(node->type != XML_XINCLUDE_START)) {\n\tret->content = xmlStrdup(node->content);\n        if (ret->content == NULL)\n            goto error;\n    }else{\n      if (node->type == XML_ELEMENT_NODE)\n        ret->line = node->line;\n    }\n    if (parent != NULL) {\n\txmlNodePtr tmp;\n\n\t/*\n\t * this is a tricky part for the node register thing:\n\t * in case ret does get coalesced in xmlAddChild\n\t * the deregister-node callback is called; so we register ret now already\n\t */\n\tif ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n\t    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n\n        /*\n         * Note that since ret->parent is already set, xmlAddChild will\n         * return early and not actually insert the node. It will only\n         * coalesce text nodes and unnecessarily call xmlSetTreeDoc.\n         * Assuming that the subtree to be copied always has its text\n         * nodes coalesced, the somewhat confusing call to xmlAddChild\n         * could be removed.\n         */\n        tmp = xmlAddChild(parent, ret);\n\t/* node could have coalesced */\n\tif (tmp != ret)\n\t    return(tmp);\n    }\n\n    if (!extended)\n\tgoto out;\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL)) {\n        ret->nsDef = xmlCopyNamespaceList(node->nsDef);\n        if (ret->nsDef == NULL)\n            goto error;\n    }\n\n    if ((node->type == XML_ELEMENT_NODE) && (node->ns != NULL)) {\n        xmlNsPtr ns;\n\n\tns = xmlSearchNs(doc, ret, node->ns->prefix);\n\tif (ns == NULL) {\n\t    /*\n\t     * Humm, we are copying an element whose namespace is defined\n\t     * out of the new tree scope. Search it in the original tree\n\t     * and add it at the top of the new tree.\n             *\n             * TODO: Searching the original tree seems unnecessary. We\n             * already have a namespace URI.\n\t     */\n\t    ns = xmlSearchNs(node->doc, node, node->ns->prefix);\n\t    if (ns != NULL) {\n\t        xmlNodePtr root = ret;\n\n\t\twhile (root->parent != NULL) root = root->parent;\n\t\tret->ns = xmlNewNs(root, ns->href, ns->prefix);\n            } else {\n                ret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n\t    }\n            if (ret->ns == NULL)\n                goto error;\n\t} else {\n\t    /*\n\t     * reference the existing namespace definition in our own tree.\n\t     */\n\t    ret->ns = ns;\n\t}\n    }\n    if ((node->type == XML_ELEMENT_NODE) && (node->properties != NULL)) {\n        ret->properties = xmlCopyPropList(ret, node->properties);\n        if (ret->properties == NULL)\n            goto error;\n    }\n    if (node->type == XML_ENTITY_REF_NODE) {\n\tif ((doc == NULL) || (node->doc != doc)) {\n\t    /*\n\t     * The copied node will go into a separate document, so\n\t     * to avoid dangling references to the ENTITY_DECL node\n\t     * we cannot keep the reference. Try to find it in the\n\t     * target document.\n\t     */\n\t    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n\t} else {\n            ret->children = node->children;\n\t}\n\tret->last = ret->children;\n    } else if ((node->children != NULL) && (extended != 2)) {\n        xmlNodePtr cur, insert;\n\n        cur = node->children;\n        insert = ret;\n        while (cur != NULL) {\n            xmlNodePtr copy = xmlStaticCopyNode(cur, doc, insert, 2);\n            if (copy == NULL)\n                goto error;\n\n            /* Check for coalesced text nodes */\n            if (insert->last != copy) {\n                if (insert->last == NULL) {\n                    insert->children = copy;\n                } else {\n                    copy->prev = insert->last;\n                    insert->last->next = copy;\n                }\n                insert->last = copy;\n            }\n\n            if ((cur->type != XML_ENTITY_REF_NODE) &&\n                (cur->children != NULL)) {\n                cur = cur->children;\n                insert = copy;\n                continue;\n            }\n\n            while (1) {\n                if (cur->next != NULL) {\n                    cur = cur->next;\n                    break;\n                }\n\n                cur = cur->parent;\n                insert = insert->parent;\n                if (cur == node) {\n                    cur = NULL;\n                    break;\n                }\n            }\n        }\n    }\n\nout:\n    /* if parent != NULL we already registered the node above */\n    if ((parent == NULL) &&\n        ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))\n\txmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n    return(ret);\n\nerror:\n    xmlFreeNode(ret);\n    return(NULL);\n}\n\nxmlNodePtr\nxmlDocCopyNode(xmlNodePtr node, xmlDocPtr doc, int extended) {\n    xmlNodePtr ret;\n\n    ret = xmlStaticCopyNode(node, doc, NULL, extended);\n    return(ret);\n}\n\nvoid\nxmlParseReference(xmlParserCtxtPtr ctxt) {\n    xmlEntityPtr ent = NULL;\n    const xmlChar *name;\n    xmlChar *val;\n\n    if (RAW != '&')\n        return;\n\n    /*\n     * Simple case of a CharRef\n     */\n    if (NXT(1) == '#') {\n\tint i = 0;\n\txmlChar out[16];\n\tint value = xmlParseCharRef(ctxt);\n\n\tif (value == 0)\n\t    return;\n\n        /*\n         * Just encode the value in UTF-8\n         */\n        COPY_BUF(out, i, value);\n        out[i] = 0;\n        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n            (!ctxt->disableSAX))\n            ctxt->sax->characters(ctxt->userData, out, i);\n\treturn;\n    }\n\n    /*\n     * We are seeing an entity reference\n     */\n    name = xmlParseEntityRefInternal(ctxt);\n    if (name != NULL)\n        ent = xmlLookupGeneralEntity(ctxt, name, /* isAttr */ 0);\n    if (ent == NULL) return;\n    if (!ctxt->wellFormed)\n\treturn;\n\n    /* special case of predefined entities */\n    if ((ent->name == NULL) ||\n        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\tval = ent->content;\n\tif (val == NULL) return;\n\t/*\n\t * inline the entity.\n\t */\n\tif ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));\n\treturn;\n    }\n\n    /*\n     * The first reference to the entity trigger a parsing phase\n     * where the ent->children is filled with the result from\n     * the parsing.\n     * Note: external parsed entities will not be loaded, it is not\n     * required for a non-validating parser, unless the parsing option\n     * of validating, or substituting entities were given. Doing so is\n     * far more secure as the parser will only process data coming from\n     * the document entity by default.\n     *\n     * FIXME: This doesn't work correctly since entities can be\n     * expanded with different namespace declarations in scope.\n     * For example:\n     *\n     * <!DOCTYPE doc [\n     *   <!ENTITY ent \"<ns:elem/>\">\n     * ]>\n     * <doc>\n     *   <decl1 xmlns:ns=\"urn:ns1\">\n     *     &ent;\n     *   </decl1>\n     *   <decl2 xmlns:ns=\"urn:ns2\">\n     *     &ent;\n     *   </decl2>\n     * </doc>\n     *\n     * Proposed fix:\n     *\n     * - Ignore current namespace declarations when parsing the\n     *   entity. If a prefix can't be resolved, don't report an error\n     *   but mark it as unresolved.\n     * - Try to resolve these prefixes when expanding the entity.\n     *   This will require a specialized version of xmlStaticCopyNode\n     *   which can also make use of the namespace hash table to avoid\n     *   quadratic behavior.\n     *\n     * Alternatively, we could simply reparse the entity on each\n     * expansion like we already do with custom SAX callbacks.\n     * External entity content should be cached in this case.\n     */\n    if ((ent->etype == XML_INTERNAL_GENERAL_ENTITY) ||\n        (((ctxt->options & XML_PARSE_NO_XXE) == 0) &&\n         ((ctxt->replaceEntities) ||\n          (ctxt->validate)))) {\n        if ((ent->flags & XML_ENT_PARSED) == 0) {\n            xmlCtxtParseEntity(ctxt, ent);\n        } else if (ent->children == NULL) {\n            /*\n             * Probably running in SAX mode and the callbacks don't\n             * build the entity content. Parse the entity again.\n             *\n             * This will also be triggered in normal tree builder mode\n             * if an entity happens to be empty, causing unnecessary\n             * reloads. It's hard to come up with a reliable check in\n             * which mode we're running.\n             */\n            xmlCtxtParseEntity(ctxt, ent);\n        }\n    }\n\n    /*\n     * We also check for amplification if entities aren't substituted.\n     * They might be expanded later.\n     */\n    if (xmlParserEntityCheck(ctxt, ent->expandedSize))\n        return;\n\n    if ((ctxt->sax == NULL) || (ctxt->disableSAX))\n        return;\n\n    if (ctxt->replaceEntities == 0) {\n\t/*\n\t * Create a reference\n\t */\n        if (ctxt->sax->reference != NULL)\n\t    ctxt->sax->reference(ctxt->userData, ent->name);\n    } else if ((ent->children != NULL) && (ctxt->node != NULL)) {\n        xmlNodePtr copy, cur;\n\n        /*\n         * Seems we are generating the DOM content, copy the tree\n\t */\n        cur = ent->children;\n\n        /*\n         * Handle first text node with SAX to coalesce text efficiently\n         */\n        if ((cur->type == XML_TEXT_NODE) ||\n            (cur->type == XML_CDATA_SECTION_NODE)) {\n            int len = xmlStrlen(cur->content);\n\n            if ((cur->type == XML_TEXT_NODE) ||\n                (ctxt->sax->cdataBlock == NULL)) {\n                if (ctxt->sax->characters != NULL)\n                    ctxt->sax->characters(ctxt, cur->content, len);\n            } else {\n                if (ctxt->sax->cdataBlock != NULL)\n                    ctxt->sax->cdataBlock(ctxt, cur->content, len);\n            }\n\n            cur = cur->next;\n        }\n\n        while (cur != NULL) {\n            xmlNodePtr last;\n\n            /*\n             * Handle last text node with SAX to coalesce text efficiently\n             */\n            if ((cur->next == NULL) &&\n                ((cur->type == XML_TEXT_NODE) ||\n                 (cur->type == XML_CDATA_SECTION_NODE))) {\n                int len = xmlStrlen(cur->content);\n\n                if ((cur->type == XML_TEXT_NODE) ||\n                    (ctxt->sax->cdataBlock == NULL)) {\n                    if (ctxt->sax->characters != NULL)\n                        ctxt->sax->characters(ctxt, cur->content, len);\n                } else {\n                    if (ctxt->sax->cdataBlock != NULL)\n                        ctxt->sax->cdataBlock(ctxt, cur->content, len);\n                }\n\n                break;\n            }\n\n            /*\n             * Reset coalesce buffer stats only for non-text nodes.\n             */\n            ctxt->nodemem = 0;\n            ctxt->nodelen = 0;\n\n            copy = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n\n            if (copy == NULL) {\n                xmlErrMemory(ctxt);\n                break;\n            }\n\n            if (ctxt->parseMode == XML_PARSE_READER) {\n                /* Needed for reader */\n                copy->extra = cur->extra;\n                /* Maybe needed for reader */\n                copy->_private = cur->_private;\n            }\n\n            copy->parent = ctxt->node;\n            last = ctxt->node->last;\n            if (last == NULL) {\n                ctxt->node->children = copy;\n            } else {\n                last->next = copy;\n                copy->prev = last;\n            }\n            ctxt->node->last = copy;\n\n            cur = cur->next;\n        }\n    }\n}\n\n\n\nint\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    size_t curBase;\n    size_t maxLength;\n    int end_in_lf = 0;\n\n    if ((ctxt == NULL) || (size < 0))\n        return(XML_ERR_ARGUMENT);\n    if (ctxt->disableSAX != 0)\n        return(ctxt->errNo);\n    if (ctxt->input == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt->input->flags |= XML_INPUT_PROGRESSIVE;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlCtxtInitializeLate(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n\n    curBase = ctxt->input->cur - ctxt->input->base;\n    maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                XML_MAX_HUGE_LENGTH :\n                XML_MAX_LOOKUP_LIMIT;\n    if (curBase > maxLength) {\n        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n                    \"Buffer size limit exceeded, try XML_PARSE_HUGE\\n\");\n        xmlHaltParser(ctxt);\n    }\n\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n            ctxt->instate = XML_PARSER_EOF;\n            xmlFinishDocument(ctxt);\n\t}\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}\n\nstatic int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlCtxtErrIO(reader->ctxt, reader->input->error, NULL);\n                    reader->mode = XML_TEXTREADER_MODE_ERROR;\n                    reader->state = XML_TEXTREADER_ERROR;\n                    return(-1);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}\n\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n    if (reader->state == XML_TEXTREADER_ERROR)\n        return(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n            if (val < 0) {\n                reader->mode = XML_TEXTREADER_MODE_ERROR;\n                reader->state = XML_TEXTREADER_ERROR;\n                return(-1);\n            }\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL) {\n                reader->mode = XML_TEXTREADER_MODE_ERROR;\n                reader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t    }\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\t    return(0);\n        } else {\n            reader->mode = XML_TEXTREADER_MODE_ERROR;\n            reader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n        }\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0) {\n            reader->mode = XML_TEXTREADER_MODE_ERROR;\n            reader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n        }\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n                reader->mode = XML_TEXTREADER_MODE_ERROR;\n                reader->state = XML_TEXTREADER_ERROR;\n\t        return(-1);\n            }\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\tif (xmlTextReaderValidateEntity(reader) < 0)\n            return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n\n\n// target function\nint\nxmlAddIDSafe(xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr,\n             int streaming, xmlIDPtr *id) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (id != NULL)\n        *id = NULL;\n\n    if (doc == NULL) {\n\treturn(-1);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(0);\n    }\n    if (attr == NULL) {\n\treturn(-1);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n        if (table == NULL)\n            return(-1);\n    } else {\n        ret = xmlHashLookup(table, value);\n        if (ret != NULL) {\n            /*\n             * Update the attribute to make entities work.\n             */\n            if (!streaming) {\n                if (ret->attr != NULL) {\n                    ret->attr->id = NULL;\n                    ret->attr = attr;\n                }\n                attr->id = ret;\n            }\n\t    attr->atype = XML_ATTRIBUTE_ID;\n            return(0);\n        }\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL)\n\treturn(-1);\n    memset(ret, 0, sizeof(*ret));\n\n    /*\n     * fill the structure.\n     */\n    ret->doc = doc;\n    ret->value = xmlStrdup(value);\n    if (ret->value == NULL) {\n        xmlFreeID(ret);\n        return(-1);\n    }\n    if (streaming) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n        if (ret->name == NULL) {\n            xmlFreeID(ret);\n            return(-1);\n        }\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n\txmlFreeID(ret);\n\treturn(-1);\n    }\n\n    attr->atype = XML_ATTRIBUTE_ID;\n    if (!streaming)\n        attr->id = ret;\n\n    if (id != NULL)\n        *id = ret;\n    return(1);\n}\n",
    "target": 1,
    "idx": 1066679,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nvips_foreign_load_matrix_load( VipsForeignLoad *load )\n{\n\tVipsForeignLoadMatrix *matrix = (VipsForeignLoadMatrix *) load;\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );\n\n\tint x, y;\n\n\tvips_image_pipelinev( load->real, VIPS_DEMAND_STYLE_THINSTRIP, NULL );\n\tvips_image_init_fields( load->real,\n\t\tload->out->Xsize, load->out->Ysize, 1, \n\t\tVIPS_FORMAT_DOUBLE, \n\t\tVIPS_CODING_NONE, VIPS_INTERPRETATION_B_W, 1.0, 1.0 );\n\n\tfor( y = 0; y < load->real->Ysize; y++ ) {\n\t\tchar *line;\n\t\tchar *p, *q;\n\n\t\tline = vips_sbuf_get_line_copy( matrix->sbuf );\n\n\t\tfor( x = 0, p = line; \n\t\t\t(q = vips_break_token( p, \" \\t\" )) &&\n\t\t\t\tx < load->out->Xsize;\n\t\t\tx++, p = q )\n\t\t\tif( vips_strtod( p, &matrix->linebuf[x] ) ) {\n\t\t\t\tvips_error( class->nickname, \n\t\t\t\t\t_( \"bad number \\\"%s\\\"\" ), p );\n\t\t\t\tg_free( line );\n\t\t\t\treturn( -1 );\n\t\t\t}\n\n\t\tg_free( line );\n\n\t\tif( x != load->out->Xsize ) {\n\t\t\tvips_error( class->nickname, \n\t\t\t\t_( \"line %d too short\" ), y );\n\t\t\treturn( -1 );\n\t\t}\n\n\t\tif( vips_image_write_line( load->real, y, \n\t\t\t(VipsPel *) matrix->linebuf ) )\n\t\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\ngboolean\nvips_buf_vappendf( VipsBuf *buf, const char *fmt, va_list ap )\n{\n\tint avail;\n\tchar *p;\n\n\tif( buf->full )\n\t\treturn( FALSE );\n\n\tavail = buf->mx - buf->i - 4;\n\tp = buf->base + buf->i;\n\t(void) vips_vsnprintf( p, avail, fmt, ap ); \n\tbuf->i += strlen( p );\n\n\tif( buf->i >= buf->mx - 4 ) {\n\t\tbuf->full = TRUE;\n\t\tstrcpy( buf->base + buf->mx - 4, \"...\" );\n\t\tbuf->i = buf->mx - 1;\n\t\treturn( FALSE );\n\t}\n\n\treturn( TRUE );\n}\nvoid \nvips_verror( const char *domain, const char *fmt, va_list ap )\n{\n#ifdef VIPS_DEBUG\n{\n\tchar txt[256];\n\tVipsBuf buf = VIPS_BUF_STATIC( txt );\n\tva_list ap2;\n\n\tvips_buf_appendf( &buf, \"%s: \", domain );\n\tva_copy( ap2, ap );\n\tvips_buf_vappendf( &buf, fmt, ap2 );\n\tvips_buf_appends( &buf, \"\\n\" );\n\tVIPS_DEBUG_MSG( \"vips_verror: %s\", vips_buf_all( &buf ) );\n}\n#endif /*VIPS_DEBUG*/\n\n\tg_mutex_lock( vips__global_lock );\n\tg_assert( vips_error_freeze_count >= 0 );\n\tif( !vips_error_freeze_count ) {\n\t\tif( domain ) \n\t\t\tvips_buf_appendf( &vips_error_buf, \"%s: \", domain );\n\t\tvips_buf_vappendf( &vips_error_buf, fmt, ap );\n\t\tvips_buf_appends( &vips_error_buf, \"\\n\" );\n\t}\n\tg_mutex_unlock( vips__global_lock );\n\n\tif( vips__fatal )\n\t\tvips_error_exit( \"vips__fatal\" );\n}\nvoid \nvips_error( const char *domain, const char *fmt, ... )\n{\t\n\tva_list ap;\n\n\tva_start( ap, fmt );\n\tvips_verror( domain, fmt, ap );\n\tva_end( ap );\n}\nstatic void *\nvips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\t/* If this start has failed before in another thread, we can fail now.\n\t */\n\tif( load->error )\n\t\treturn( NULL );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif /*DEBUG*/\n\n\t\t/* Read the image in. This may involve a long computation and\n\t\t * will finish with load->real holding the decompressed image. \n\t\t *\n\t\t * We want our caller to be able to see this computation on\n\t\t * @out, so eval signals on ->real need to appear on ->out.\n\t\t */\n\t\tload->real->progress_signal = load->out;\n\n\t\t/* Note the load object on the image. Loaders can use \n\t\t * this to signal invalidate if they hit a load error. See\n\t\t * vips_foreign_load_invalidate() below.\n\t\t */\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\t/* Load the image and check the result.\n\t\t *\n\t\t * ->header() read the header into @out, load will read the\n\t\t * image into @real. They must match exactly in size, bands,\n\t\t * format and coding for the copy to work.  \n\t\t *\n\t\t * Some versions of ImageMagick give different results between\n\t\t * Ping and Load for some formats, for example.\n\t\t *\n\t\t * If the load fails, we need to stop\n\t\t */\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) || \n\t\t\t!vips_foreign_load_iscompat( load->real, out ) ) {\n\t\t\tvips_operation_invalidate( VIPS_OPERATION( load ) ); \n\t\t\tload->error = TRUE;\n\n\t\t\treturn( NULL );\n\t\t}\n\n\t\t/* We have to tell vips that out depends on real. We've set\n\t\t * the demand hint below, but not given an input there.\n\t\t */\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\n\treturn( vips_region_new( load->real ) );\n}\nint\nvips__region_start( VipsRegion *region )\n{\n\tVipsImage *image = region->im;\n\n        if( !region->seq && image->start_fn ) {\n\t\tVIPS_GATE_START( \"vips__region_start: wait\" );\n\n                g_mutex_lock( image->sslock );\n\n\t\tVIPS_GATE_STOP( \"vips__region_start: wait\" );\n\n                region->seq = image->start_fn( image, \n\t\t\timage->client1, image->client2 );\n\n                g_mutex_unlock( image->sslock );\n \n                if( !region->seq ) {\n#ifdef DEBUG\n                        printf( \"vips__region_start: \"\n\t\t\t\t\"start function failed for image %s\",\n                                image->filename );\n#endif /*DEBUG*/\n\n                        return( -1 );\n                }\n        }\n\n        return( 0 );\n}\nstatic int\nvips_region_generate( VipsRegion *reg )\n{\n\tVipsImage *im = reg->im;\n\n\tgboolean stop;\n\n        /* Start new sequence, if necessary.\n         */\n        if( vips__region_start( reg ) )\n\t\treturn( -1 );\n\n\t/* Ask for evaluation.\n\t */\n\tstop = FALSE;\n\tif( im->generate_fn( reg, reg->seq, im->client1, im->client2, &stop ) )\n\t\treturn( -1 );\n\tif( stop ) {\n\t\tvips_error( \"vips_region_generate\", \n\t\t\t\"%s\", _( \"stop requested\" ) );\n\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\nint\nvips_region_fill( VipsRegion *reg, \n\tconst VipsRect *r, VipsRegionFillFn fn, void *a )\n{\n\tg_assert( reg->im->dtype == VIPS_IMAGE_PARTIAL );\n\tg_assert( reg->im->generate_fn );\n\n\t/* You'd think we could check reg and see if it already has some of \n\t * the pixels we need. If it does, we could copy them and only\n\t * generate the new ones. \n\t *\n\t * However, we usually have neighbouring regions on different threads,\n\t * so from the point of view of this thread, we will get no overlaps\n\t * on successive prepare requests. \n\t */\n\n\t/* Should have local memory.\n\t */\n\tif( vips_region_buffer( reg, r ) )\n\t\treturn( -1 );\n\n\t/* Evaluate into or, if we've not got calculated pixels.\n\t */\n\tif( !reg->buffer->done ) {\n\t\tif( fn( reg, a ) )\n\t\t\treturn( -1 );\n\n\t\t/* Publish our results.\n\t\t */\n\t\tif( reg->buffer )\n\t\t\tvips_buffer_done( reg->buffer );\n\t}\n\n\treturn( 0 );\n}\nstatic int\nvips_region_prepare_to_generate( VipsRegion *reg, \n\tVipsRegion *dest, const VipsRect *r, int x, int y )\n{\n\tVipsImage *im = reg->im;\n\tVipsPel *p;\n\n\tif( !im->generate_fn ) {\n\t\tvips_error( \"vips_region_prepare_to\",\n\t\t\t\"%s\", _( \"incomplete header\" ) );\n\t\treturn( -1 );\n\t}\n\n\tif( vips_region_region( reg, dest, r, x, y ) )\n\t\treturn( -1 );\n\n\t/* Remember where reg is pointing now.\n\t */\n\tp = VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top );\n\n\t/* Run sequence into reg.\n\t */\n\tif( vips_region_generate( reg ) )\n\t\treturn( -1 );\n\n\t/* The generate function may not have actually made any pixels ... it\n\t * might just have redirected reg to point somewhere else. If it has,\n\t * we need an extra copy operation.\n\t */\n\tif( VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top ) != p )\n\t\tvips_region_copy( reg, dest, r, x, y );\n\n\treturn( 0 );\n}\nstatic int\nvips_copy_gen( VipsRegion *or, void *seq, void *a, void *b, gboolean *stop )\n{\n\tVipsRegion *ir = (VipsRegion *) seq;\n\tVipsRect *r = &or->valid;\n\n\tif( vips_region_prepare( ir, r ) ||\n\t\tvips_region_region( or, ir, r, r->left, r->top ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}\nstatic int\nvips_region_generate( VipsRegion *reg )\n{\n\tVipsImage *im = reg->im;\n\n\tgboolean stop;\n\n        /* Start new sequence, if necessary.\n         */\n        if( vips__region_start( reg ) )\n\t\treturn( -1 );\n\n\t/* Ask for evaluation.\n\t */\n\tstop = FALSE;\n\tif( im->generate_fn( reg, reg->seq, im->client1, im->client2, &stop ) )\n\t\treturn( -1 );\n\tif( stop ) {\n\t\tvips_error( \"vips_region_generate\", \n\t\t\t\"%s\", _( \"stop requested\" ) );\n\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\nint\nvips_region_fill( VipsRegion *reg, \n\tconst VipsRect *r, VipsRegionFillFn fn, void *a )\n{\n\tg_assert( reg->im->dtype == VIPS_IMAGE_PARTIAL );\n\tg_assert( reg->im->generate_fn );\n\n\t/* You'd think we could check reg and see if it already has some of \n\t * the pixels we need. If it does, we could copy them and only\n\t * generate the new ones. \n\t *\n\t * However, we usually have neighbouring regions on different threads,\n\t * so from the point of view of this thread, we will get no overlaps\n\t * on successive prepare requests. \n\t */\n\n\t/* Should have local memory.\n\t */\n\tif( vips_region_buffer( reg, r ) )\n\t\treturn( -1 );\n\n\t/* Evaluate into or, if we've not got calculated pixels.\n\t */\n\tif( !reg->buffer->done ) {\n\t\tif( fn( reg, a ) )\n\t\t\treturn( -1 );\n\n\t\t/* Publish our results.\n\t\t */\n\t\tif( reg->buffer )\n\t\t\tvips_buffer_done( reg->buffer );\n\t}\n\n\treturn( 0 );\n}\nstatic int\nvips_region_prepare_to_generate( VipsRegion *reg, \n\tVipsRegion *dest, const VipsRect *r, int x, int y )\n{\n\tVipsImage *im = reg->im;\n\tVipsPel *p;\n\n\tif( !im->generate_fn ) {\n\t\tvips_error( \"vips_region_prepare_to\",\n\t\t\t\"%s\", _( \"incomplete header\" ) );\n\t\treturn( -1 );\n\t}\n\n\tif( vips_region_region( reg, dest, r, x, y ) )\n\t\treturn( -1 );\n\n\t/* Remember where reg is pointing now.\n\t */\n\tp = VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top );\n\n\t/* Run sequence into reg.\n\t */\n\tif( vips_region_generate( reg ) )\n\t\treturn( -1 );\n\n\t/* The generate function may not have actually made any pixels ... it\n\t * might just have redirected reg to point somewhere else. If it has,\n\t * we need an extra copy operation.\n\t */\n\tif( VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top ) != p )\n\t\tvips_region_copy( reg, dest, r, x, y );\n\n\treturn( 0 );\n}\nstatic int\nvips_cast_gen( VipsRegion *or, void *vseq, void *a, void *b, gboolean *stop )\n{\n\tVipsRegion *ir = (VipsRegion *) vseq;\n\tVipsCast *cast = (VipsCast *) b;\n\tVipsConversion *conversion = (VipsConversion *) b;\n\tVipsRect *r = &or->valid;\n\tint sz = VIPS_REGION_N_ELEMENTS( or );\n\n\tint x, y;\n\n\tif( vips_region_prepare( ir, r ) )\n\t\treturn( -1 );\n\n\tVIPS_GATE_START( \"vips_cast_gen: work\" );\n\n\tfor( y = 0; y < r->height; y++ ) {\n\t\tVipsPel *in = VIPS_REGION_ADDR( ir, r->left, r->top + y ); \n\t\tVipsPel *out = VIPS_REGION_ADDR( or, r->left, r->top + y ); \n\n\t\tswitch( ir->im->BandFmt ) { \n\t\tcase VIPS_FORMAT_UCHAR: \n\t\t\tBAND_SWITCH_INNER( unsigned char,\n\t\t\t\tINT_INT, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_CHAR: \n\t\t\tBAND_SWITCH_INNER( signed char,\n\t\t\t\tINT_INT_SIGNED, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_USHORT: \n\t\t\tBAND_SWITCH_INNER( unsigned short,\n\t\t\t\tINT_INT, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_SHORT: \n\t\t\tBAND_SWITCH_INNER( signed short,\n\t\t\t\tINT_INT_SIGNED, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_UINT: \n\t\t\tBAND_SWITCH_INNER( unsigned int,\n\t\t\t\tINT_INT, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_INT: \n\t\t\tBAND_SWITCH_INNER( signed int,\n\t\t\t\tINT_INT_SIGNED, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_FLOAT: \n\t\t\tBAND_SWITCH_INNER( float,\n\t\t\t\tCAST_FLOAT_INT, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_DOUBLE: \n\t\t\tBAND_SWITCH_INNER( double,\n\t\t\t\tCAST_FLOAT_INT, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_COMPLEX: \n\t\t\tBAND_SWITCH_INNER( float,\n\t\t\t\tCAST_COMPLEX_INT, \n\t\t\t\tCAST_COMPLEX_FLOAT, \n\t\t\t\tCAST_COMPLEX_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_DPCOMPLEX: \n\t\t\tBAND_SWITCH_INNER( double,\n\t\t\t\tCAST_COMPLEX_INT, \n\t\t\t\tCAST_COMPLEX_FLOAT, \n\t\t\t\tCAST_COMPLEX_COMPLEX );\n\t\t\tbreak; \n\n\t\tdefault: \n\t\t\tg_assert_not_reached(); \n\t\t} \n\t}\n\n\tVIPS_GATE_STOP( \"vips_cast_gen: work\" );\n\n\treturn( 0 );\n}\nstatic int\nvips_region_generate( VipsRegion *reg )\n{\n\tVipsImage *im = reg->im;\n\n\tgboolean stop;\n\n        /* Start new sequence, if necessary.\n         */\n        if( vips__region_start( reg ) )\n\t\treturn( -1 );\n\n\t/* Ask for evaluation.\n\t */\n\tstop = FALSE;\n\tif( im->generate_fn( reg, reg->seq, im->client1, im->client2, &stop ) )\n\t\treturn( -1 );\n\tif( stop ) {\n\t\tvips_error( \"vips_region_generate\", \n\t\t\t\"%s\", _( \"stop requested\" ) );\n\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\nint\nvips_region_fill( VipsRegion *reg, \n\tconst VipsRect *r, VipsRegionFillFn fn, void *a )\n{\n\tg_assert( reg->im->dtype == VIPS_IMAGE_PARTIAL );\n\tg_assert( reg->im->generate_fn );\n\n\t/* You'd think we could check reg and see if it already has some of \n\t * the pixels we need. If it does, we could copy them and only\n\t * generate the new ones. \n\t *\n\t * However, we usually have neighbouring regions on different threads,\n\t * so from the point of view of this thread, we will get no overlaps\n\t * on successive prepare requests. \n\t */\n\n\t/* Should have local memory.\n\t */\n\tif( vips_region_buffer( reg, r ) )\n\t\treturn( -1 );\n\n\t/* Evaluate into or, if we've not got calculated pixels.\n\t */\n\tif( !reg->buffer->done ) {\n\t\tif( fn( reg, a ) )\n\t\t\treturn( -1 );\n\n\t\t/* Publish our results.\n\t\t */\n\t\tif( reg->buffer )\n\t\t\tvips_buffer_done( reg->buffer );\n\t}\n\n\treturn( 0 );\n}\nstatic int\nvips_region_prepare_to_generate( VipsRegion *reg, \n\tVipsRegion *dest, const VipsRect *r, int x, int y )\n{\n\tVipsImage *im = reg->im;\n\tVipsPel *p;\n\n\tif( !im->generate_fn ) {\n\t\tvips_error( \"vips_region_prepare_to\",\n\t\t\t\"%s\", _( \"incomplete header\" ) );\n\t\treturn( -1 );\n\t}\n\n\tif( vips_region_region( reg, dest, r, x, y ) )\n\t\treturn( -1 );\n\n\t/* Remember where reg is pointing now.\n\t */\n\tp = VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top );\n\n\t/* Run sequence into reg.\n\t */\n\tif( vips_region_generate( reg ) )\n\t\treturn( -1 );\n\n\t/* The generate function may not have actually made any pixels ... it\n\t * might just have redirected reg to point somewhere else. If it has,\n\t * we need an extra copy operation.\n\t */\n\tif( VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top ) != p )\n\t\tvips_region_copy( reg, dest, r, x, y );\n\n\treturn( 0 );\n}\nstatic int\nvips_copy_gen( VipsRegion *or, void *seq, void *a, void *b, gboolean *stop )\n{\n\tVipsRegion *ir = (VipsRegion *) seq;\n\tVipsRect *r = &or->valid;\n\n\tif( vips_region_prepare( ir, r ) ||\n\t\tvips_region_region( or, ir, r, r->left, r->top ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}\nstatic int\nvips_region_generate( VipsRegion *reg )\n{\n\tVipsImage *im = reg->im;\n\n\tgboolean stop;\n\n        /* Start new sequence, if necessary.\n         */\n        if( vips__region_start( reg ) )\n\t\treturn( -1 );\n\n\t/* Ask for evaluation.\n\t */\n\tstop = FALSE;\n\tif( im->generate_fn( reg, reg->seq, im->client1, im->client2, &stop ) )\n\t\treturn( -1 );\n\tif( stop ) {\n\t\tvips_error( \"vips_region_generate\", \n\t\t\t\"%s\", _( \"stop requested\" ) );\n\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\nstatic int\nvips_region_prepare_to_generate( VipsRegion *reg, \n\tVipsRegion *dest, const VipsRect *r, int x, int y )\n{\n\tVipsImage *im = reg->im;\n\tVipsPel *p;\n\n\tif( !im->generate_fn ) {\n\t\tvips_error( \"vips_region_prepare_to\",\n\t\t\t\"%s\", _( \"incomplete header\" ) );\n\t\treturn( -1 );\n\t}\n\n\tif( vips_region_region( reg, dest, r, x, y ) )\n\t\treturn( -1 );\n\n\t/* Remember where reg is pointing now.\n\t */\n\tp = VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top );\n\n\t/* Run sequence into reg.\n\t */\n\tif( vips_region_generate( reg ) )\n\t\treturn( -1 );\n\n\t/* The generate function may not have actually made any pixels ... it\n\t * might just have redirected reg to point somewhere else. If it has,\n\t * we need an extra copy operation.\n\t */\n\tif( VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top ) != p )\n\t\tvips_region_copy( reg, dest, r, x, y );\n\n\treturn( 0 );\n}\nstatic int\nvips_region_prepare_to_generate( VipsRegion *reg, \n\tVipsRegion *dest, const VipsRect *r, int x, int y )\n{\n\tVipsImage *im = reg->im;\n\tVipsPel *p;\n\n\tif( !im->generate_fn ) {\n\t\tvips_error( \"vips_region_prepare_to\",\n\t\t\t\"%s\", _( \"incomplete header\" ) );\n\t\treturn( -1 );\n\t}\n\n\tif( vips_region_region( reg, dest, r, x, y ) )\n\t\treturn( -1 );\n\n\t/* Remember where reg is pointing now.\n\t */\n\tp = VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top );\n\n\t/* Run sequence into reg.\n\t */\n\tif( vips_region_generate( reg ) )\n\t\treturn( -1 );\n\n\t/* The generate function may not have actually made any pixels ... it\n\t * might just have redirected reg to point somewhere else. If it has,\n\t * we need an extra copy operation.\n\t */\n\tif( VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top ) != p )\n\t\tvips_region_copy( reg, dest, r, x, y );\n\n\treturn( 0 );\n}\nstatic int\nwbuffer_work_fn( VipsThreadState *state, void *a )\n{\n\tWriteThreadState *wstate = (WriteThreadState *) state;\n\n\tint result;\n\n\tVIPS_DEBUG_MSG( \"wbuffer_work_fn: thread %p, %d x %d\\n\", \n\t\tg_thread_self(), \n\t\tstate->pos.left, state->pos.top );\n\n\tresult = vips_region_prepare_to( state->reg, wstate->buf->region, \n\t\t&state->pos, state->pos.left, state->pos.top );\n\n\tVIPS_DEBUG_MSG( \"wbuffer_work_fn: thread %p result = %d\\n\", \n\t\tg_thread_self(), result );\n\n\t/* Tell the bg write thread we've left.\n\t */\n\tvips_semaphore_upn( &wstate->buf->nwrite, 1 );\n\n\treturn( result );\n}\nstatic void\nvips_thread_work_unit( VipsThread *thr )\n{\n\tVipsThreadpool *pool = thr->pool;\n\n\tif( thr->error )\n\t\treturn;\n\n\tVIPS_GATE_START( \"vips_thread_work_unit: wait\" ); \n\n\tg_mutex_lock( pool->allocate_lock );\n\n\tVIPS_GATE_STOP( \"vips_thread_work_unit: wait\" ); \n\n\t/* Has another worker signaled stop while we've been working?\n\t */\n\tif( pool->stop ) {\n\t\tg_mutex_unlock( pool->allocate_lock );\n\t\treturn;\n\t}\n\n\tif( vips_thread_allocate( thr ) ) {\n\t\tthr->error = TRUE;\n\t\tpool->error = TRUE;\n\t\tg_mutex_unlock( pool->allocate_lock );\n\t\treturn;\n\t}\n\n\t/* Have we just signalled stop?\n\t */\n\tif( pool->stop ) {\n\t\tg_mutex_unlock( pool->allocate_lock );\n\t\treturn;\n\t}\n\n\tg_mutex_unlock( pool->allocate_lock );\n\n\tif( thr->state->stall &&\n\t\tvips__stall ) { \n\t\t/* Sleep for 0.5s. Handy for stressing the seq system. Stall\n\t\t * is set by allocate funcs in various places. \n\t\t */\n\t\tg_usleep( 500000 ); \n\t\tthr->state->stall = FALSE;\n\t\tprintf( \"vips_thread_work_unit: \"\n\t\t\t\"stall done, releasing y = %d ...\\n\", thr->state->y ); \n\t}\n\n\t/* Process a work unit.\n\t */\n\tif( pool->work( thr->state, pool->a ) ) { \n\t\tthr->error = TRUE;\n\t\tpool->error = TRUE;\n\t}\n}\nstatic void *\nvips_thread_main_loop( void *a )\n{\n        VipsThread *thr = (VipsThread *) a;\n\tVipsThreadpool *pool = thr->pool;\n\n\tg_assert( pool == thr->pool );\n\n\tVIPS_GATE_START( \"vips_thread_main_loop: thread\" ); \n\n\t/* Process work units! Always tick, even if we are stopping, so the\n\t * main thread will wake up for exit. \n\t */\n\tfor(;;) {\n\t\tVIPS_GATE_START( \"vips_thread_work_unit: u\" ); \n\t\tvips_thread_work_unit( thr );\n\t\tVIPS_GATE_STOP( \"vips_thread_work_unit: u\" ); \n\t\tvips_semaphore_up( &pool->tick );\n\n\t\tif( pool->stop || \n\t\t\tpool->error )\n\t\t\tbreak;\n\t} \n\n\t/* We are exiting: tell the main thread. \n\t */\n\tvips_semaphore_up( &pool->finish );\n\n\tVIPS_GATE_STOP( \"vips_thread_main_loop: thread\" ); \n\n        return( NULL );\n}\nstatic void *\nvips_thread_run( gpointer data )\n{\n\tVipsThreadInfo *info = (VipsThreadInfo *) data;\n\n\tvoid *result;\n\n\t/* Set this to something (anything) to tag this thread as a vips \n\t * worker.\n\t */\n\tg_private_set( is_worker_key, data );\n\n\tif( vips__thread_profile ) \n\t\tvips__thread_profile_attach( info->domain );\n\n\tresult = info->func( info->data );\n\n\tg_free( info ); \n\n\tvips_thread_shutdown();\n\n\treturn( result ); \n}",
    "target": 0,
    "idx": 2020843
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void\nVariant_clear(UA_Variant *p, const UA_DataType *_) {\n    if(p->storageType != UA_VARIANT_DATA)\n        return;\n    if(p->type && p->data > UA_EMPTY_ARRAY_SENTINEL) {\n        if(p->arrayLength == 0)\n            p->arrayLength = 1;\n        UA_Array_delete(p->data, p->arrayLength, p->type);\n        p->data = NULL;\n    }\n    if((void*)p->arrayDimensions > UA_EMPTY_ARRAY_SENTINEL)\n        UA_free(p->arrayDimensions);\n}\nstatic void\nclear_noInit(void *p, const UA_DataType *type) {\n    uintptr_t ptr = (uintptr_t)p;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            clearJumpTable[fi]((void*)ptr, mt);\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            size_t length = *(size_t*)ptr;\n            ptr += sizeof(size_t);\n            UA_Array_delete(*(void**)ptr, length, mt);\n            ptr += sizeof(void*);\n        }\n    }\n}\nvoid\nUA_clear(void *p, const UA_DataType *type) {\n    clear_noInit(p, type);\n    memset(p, 0, type->memSize); /* init */\n}\nvoid\nUA_Array_delete(void *p, size_t size, const UA_DataType *type) {\n    if(!type->pointerFree) {\n        uintptr_t ptr = (uintptr_t)p;\n        for(size_t i = 0; i < size; ++i) {\n            UA_clear((void*)ptr, type);\n            ptr += type->memSize;\n        }\n    }\n    UA_free((void*)((uintptr_t)p & ~(uintptr_t)UA_EMPTY_ARRAY_SENTINEL));\n}\nstatic void\nclear_noInit(void *p, const UA_DataType *type) {\n    uintptr_t ptr = (uintptr_t)p;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            clearJumpTable[fi]((void*)ptr, mt);\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            size_t length = *(size_t*)ptr;\n            ptr += sizeof(size_t);\n            UA_Array_delete(*(void**)ptr, length, mt);\n            ptr += sizeof(void*);\n        }\n    }\n}\nvoid\nUA_clear(void *p, const UA_DataType *type) {\n    clear_noInit(p, type);\n    memset(p, 0, type->memSize); /* init */\n}\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copy_noInit(src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_clear(dst, type);\n    return retval;\n}\nUA_StatusCode\nUA_Array_copy(const void *src, size_t size,\n              void **dst, const UA_DataType *type) {\n    if(size == 0) {\n        if(src == NULL)\n            *dst = NULL;\n        else\n            *dst= UA_EMPTY_ARRAY_SENTINEL;\n        return UA_STATUSCODE_GOOD;\n    }\n\n    if(!type)\n        return UA_STATUSCODE_BADINTERNALERROR;\n\n    /* calloc, so we don't have to check retval in every iteration of copying */\n    *dst = UA_calloc(size, type->memSize);\n    if(!*dst)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n\n    if(type->pointerFree) {\n        memcpy(*dst, src, type->memSize * size);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)*dst;\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    for(size_t i = 0; i < size; ++i) {\n        retval |= UA_copy((void*)ptrs, (void*)ptrd, type);\n        ptrs += type->memSize;\n        ptrd += type->memSize;\n    }\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Array_delete(*dst, size, type);\n        *dst = NULL;\n    }\n    return retval;\n}\nstatic UA_StatusCode\nVariant_copy(UA_Variant const *src, UA_Variant *dst, const UA_DataType *_) {\n    size_t length = src->arrayLength;\n    if(UA_Variant_isScalar(src))\n        length = 1;\n    UA_StatusCode retval = UA_Array_copy(src->data, length,\n                                         &dst->data, src->type);\n    if(retval != UA_STATUSCODE_GOOD)\n        return retval;\n    dst->arrayLength = src->arrayLength;\n    dst->type = src->type;\n    if(src->arrayDimensions) {\n        retval = UA_Array_copy(src->arrayDimensions, src->arrayDimensionsSize,\n            (void**)&dst->arrayDimensions, &UA_TYPES[UA_TYPES_INT32]);\n        if(retval != UA_STATUSCODE_GOOD)\n            return retval;\n        dst->arrayDimensionsSize = src->arrayDimensionsSize;\n    }\n    return UA_STATUSCODE_GOOD;\n}\nstatic UA_StatusCode\nDataValue_copy(UA_DataValue const *src, UA_DataValue *dst,\n               const UA_DataType *_) {\n    memcpy(dst, src, sizeof(UA_DataValue));\n    UA_Variant_init(&dst->value);\n    UA_StatusCode retval = Variant_copy(&src->value, &dst->value, NULL);\n    if(retval != UA_STATUSCODE_GOOD)\n        DataValue_clear(dst, NULL);\n    return retval;\n}\nstatic UA_StatusCode\ncopy_noInit(const void *src, void *dst, const UA_DataType *type) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)dst;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            retval |= copyJumpTable[fi]((const void*)ptrs, (void*)ptrd, mt);\n            ptrs += mt->memSize;\n            ptrd += mt->memSize;\n        } else {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t *dst_size = (size_t*)ptrd;\n            const size_t size = *((const size_t*)ptrs);\n            ptrs += sizeof(size_t);\n            ptrd += sizeof(size_t);\n            retval |= UA_Array_copy(*(void* const*)ptrs, size, (void**)ptrd, mt);\n            if(retval == UA_STATUSCODE_GOOD)\n                *dst_size = size;\n            else\n                *dst_size = 0;\n            ptrs += sizeof(void*);\n            ptrd += sizeof(void*);\n        }\n    }\n    return retval;\n}\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copy_noInit(src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_clear(dst, type);\n    return retval;\n}\nstatic UA_Boolean tortureEncoding(const uint8_t *data, size_t size, size_t *newOffset) {\n    *newOffset = 0;\n    if (size <= 2)\n        return UA_FALSE;\n\n    // get some random type\n    uint16_t typeIndex = (uint16_t)(data[0] | data[1] << 8);\n    data += 2;\n    size -= 2;\n\n    if (typeIndex >= UA_TYPES_COUNT)\n        return UA_FALSE;\n\n    void *dst = UA_new(&UA_TYPES[typeIndex]);\n\n    if (!dst)\n        return UA_FALSE;\n\n    const UA_ByteString binary = {\n            size, //length\n            (UA_Byte *) (void *) data\n    };\n\n    UA_StatusCode ret = UA_decodeBinary(&binary, newOffset, dst, &UA_TYPES[typeIndex], NULL);\n\n    if (ret == UA_STATUSCODE_GOOD) {\n        // copy the datatype to test\n        void *dstCopy = UA_new(&UA_TYPES[typeIndex]);\n        if (!dstCopy)\n            return UA_FALSE;\n        UA_copy(dst, dstCopy, &UA_TYPES[typeIndex]);\n        UA_delete(dstCopy, &UA_TYPES[typeIndex]);\n\n        // now also test encoding\n        UA_ByteString encoded;\n        UA_ByteString_allocBuffer(&encoded, *newOffset);\n        const UA_Byte *end = &encoded.data[*newOffset];\n        UA_Byte *pos = encoded.data;\n        ret = UA_encodeBinary(dst, &UA_TYPES[typeIndex], &pos, &end, NULL, NULL);\n        if (ret == UA_STATUSCODE_GOOD) {\n            // do nothing\n        }\n        UA_ByteString_deleteMembers(&encoded);\n    }\n    UA_delete(dst, &UA_TYPES[typeIndex]);\n\n    return UA_TRUE;\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\n    if (!UA_memoryManager_setLimitFromLast4Bytes(data, size))\n        return 0;\n    size -= 4;\n\n    size_t offset;\n    if (!tortureEncoding(data, size, &offset)) {\n        return 0;\n    }\n    if (offset >= size)\n        return 0;\n\n\n    tortureExtensionObject(&data[offset], size-offset, &offset);\n\n\n    return 0;\n}\nint ExecuteFilesOnyByOne(int argc, char **argv) {\n  for (int i = 1; i < argc; i++) {\n    std::ifstream in(argv[i], std::ios::binary);\n    in.seekg(0, in.end);\n    size_t length = in.tellg();\n    in.seekg (0, in.beg);\n    std::cout << \"Reading \" << length << \" bytes from \" << argv[i] << std::endl;\n    // Allocate exactly length bytes so that we reliably catch buffer overflows.\n    std::vector<char> bytes(length);\n    in.read(bytes.data(), bytes.size());\n    assert(in);\n    LLVMFuzzerTestOneInput(reinterpret_cast<const uint8_t *>(bytes.data()),\n                           bytes.size());\n    std::cout << \"Execution successful\" << std::endl;\n  }\n  return 0;\n}\nint main(int argc, char **argv) {\n  fprintf(stderr,\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for AFL-fuzz.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s < INPUT_FILE\\n\"\n      \"or\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before \"\n      \"re-spawning the process (default: 1000)\\n\"\n      \"======================================================\\n\",\n          argv[0], argv[0], argv[0]);\n  if (LLVMFuzzerInitialize)\n    LLVMFuzzerInitialize(&argc, &argv);\n  // Do any other expensive one-time initialization here.\n\n  maybe_duplicate_stderr();\n  maybe_initialize_extra_stats();\n\n  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n    __afl_manual_init();\n\n  int N = 1000;\n  if (argc == 2 && argv[1][0] == '-')\n      N = atoi(argv[1] + 1);\n  else if(argc == 2 && (N = atoi(argv[1])) > 0)\n      fprintf(stderr, \"WARNING: using the deprecated call style `%s %d`\\n\",\n              argv[0], N);\n  else if (argc > 1)\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  assert(N > 0);\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  uint8_t dummy_input[1] = {0};\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  time_t unit_time_secs;\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n    ssize_t n_read = read(0, AflInputBuf, kMaxAflInputSize);\n    if (n_read > 0) {\n      // Copy AflInputBuf into a separate buffer to let asan find buffer\n      // overflows. Don't use unique_ptr/etc to avoid extra dependencies.\n      uint8_t *copy = new uint8_t[n_read];\n      memcpy(copy, AflInputBuf, n_read);\n\n      struct timeval unit_start_time;\n      CHECK_ERROR(gettimeofday(&unit_start_time, NULL) == 0,\n                  \"Calling gettimeofday failed\");\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(copy, n_read);\n\n      struct timeval unit_stop_time;\n      CHECK_ERROR(gettimeofday(&unit_stop_time, NULL) == 0,\n                  \"Calling gettimeofday failed\");\n\n      // Update slowest_unit_time_secs if we see a new max.\n      unit_time_secs = unit_stop_time.tv_sec - unit_start_time.tv_sec;\n      if (slowest_unit_time_secs < unit_time_secs)\n        slowest_unit_time_secs = unit_time_secs;\n\n      delete[] copy;\n    }\n  }\n  fprintf(stderr, \"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n}",
    "target": 0,
    "idx": 2011484
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static zend_never_inline ZEND_COLD zval *zend_wrong_assign_to_variable_reference(zval *variable_ptr, zval *value_ptr OPLINE_DC EXECUTE_DATA_DC)\n{\n\tzend_error(E_NOTICE, \"Only variables should be assigned by reference\");\n\tif (UNEXPECTED(EG(exception) != NULL)) {\n\t\treturn &EG(uninitialized_zval);\n\t}\n\n\t/* Use IS_TMP_VAR instead of IS_VAR to avoid ISREF check */\n\tZ_TRY_ADDREF_P(value_ptr);\n\treturn zend_assign_to_variable(variable_ptr, value_ptr, IS_TMP_VAR, EX_USES_STRICT_TYPES());\n}\nstatic zend_always_inline void zend_assign_to_property_reference(zval *container, uint32_t container_op_type, zval *prop_ptr, uint32_t prop_op_type, zval *value_ptr OPLINE_DC EXECUTE_DATA_DC)\n{\n\tzval variable, *variable_ptr = &variable;\n\tvoid **cache_addr = (prop_op_type == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_RETURNS_FUNCTION) : NULL;\n\n\tzend_fetch_property_address(variable_ptr, container, container_op_type, prop_ptr, prop_op_type,\n\t\tcache_addr, BP_VAR_W, 0, 0 OPLINE_CC EXECUTE_DATA_CC);\n\n\tif (EXPECTED(Z_TYPE_P(variable_ptr) == IS_INDIRECT)) {\n\t\tvariable_ptr = Z_INDIRECT_P(variable_ptr);\n\t\tif (/*OP_DATA_TYPE == IS_VAR &&*/\n\t\t\t\t   (opline->extended_value & ZEND_RETURNS_FUNCTION) &&\n\t\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\t\tvariable_ptr = zend_wrong_assign_to_variable_reference(\n\t\t\t\tvariable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC);\n\t\t} else {\n\t\t\tzend_property_info *prop_info = NULL;\n\n\t\t\tif (prop_op_type == IS_CONST) {\n\t\t\t\tprop_info = (zend_property_info *) CACHED_PTR_EX(cache_addr + 2);\n\t\t\t} else {\n\t\t\t\tZVAL_DEREF(container);\n\t\t\t\tprop_info = zend_object_fetch_property_type_info(Z_OBJ_P(container), variable_ptr);\n\t\t\t}\n\n\t\t\tif (UNEXPECTED(prop_info)) {\n\t\t\t\tvariable_ptr = zend_assign_to_typed_property_reference(prop_info, variable_ptr, value_ptr EXECUTE_DATA_CC);\n\t\t\t} else {\n\t\t\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t\t\t}\n\t\t}\n\t} else if (Z_ISERROR_P(variable_ptr)) {\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else {\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to overloaded object\");\n\t\tzval_ptr_dtor(&variable);\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n}\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\tCG(compiled_filename) = NULL; /* ??? */\n\tfuzzer_request_shutdown();\n\n\treturn (retval == SUCCESS) ? SUCCESS : FAILURE;\n}\nint LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n\tif (Size > MAX_SIZE) {\n\t\t/* Large inputs have a large impact on fuzzer performance,\n\t\t * but are unlikely to be necessary to reach new codepaths. */\n\t\treturn 0;\n\t}\n\n\tsteps_left = MAX_STEPS;\n\tfuzzer_do_request_from_buffer(\"/fuzzer.php\", (const char *) Data, Size, /* execute */ 1);\n\n\treturn 0;\n}",
    "target": 0,
    "idx": 2029899
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "void\nQPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    std::set<qpdf_offset_t> visited;\n    while (xref_offset) {\n        visited.insert(xref_offset);\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n        m->file->seek(xref_offset, SEEK_SET);\n        // Some files miss the mark a little with startxref. We could do a better job of searching\n        // in the neighborhood for something that looks like either an xref table or stream, but the\n        // simple heuristic of skipping whitespace can help with the xref table case and is harmless\n        // with the stream case.\n        bool done = false;\n        bool skipped_space = false;\n        while (!done) {\n            char ch;\n            if (1 == m->file->read(&ch, 1)) {\n                if (QUtil::is_space(ch)) {\n                    skipped_space = true;\n                } else {\n                    m->file->unreadCh(ch);\n                    done = true;\n                }\n            } else {\n                QTC::TC(\"qpdf\", \"QPDF eof skipping spaces before xref\", skipped_space ? 0 : 1);\n                done = true;\n            }\n        }\n\n        m->file->read(buf, sizeof(buf) - 1);\n        // The PDF spec says xref must be followed by a line terminator, but files exist in the wild\n        // where it is terminated by arbitrary whitespace.\n        if ((strncmp(buf, \"xref\", 4) == 0) && QUtil::is_space(buf[4])) {\n            if (skipped_space) {\n                QTC::TC(\"qpdf\", \"QPDF xref skipped space\");\n                warn(damagedPDF(\"\", 0, \"extraneous whitespace seen before xref\"));\n            }\n            QTC::TC(\n                \"qpdf\",\n                \"QPDF xref space\",\n                ((buf[4] == '\\n')       ? 0\n                     : (buf[4] == '\\r') ? 1\n                     : (buf[4] == ' ')  ? 2\n                                        : 9999));\n            int skip = 4;\n            // buf is null-terminated, and QUtil::is_space('\\0') is false, so this won't overrun.\n            while (QUtil::is_space(buf[skip])) {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n        } else {\n            xref_offset = read_xrefStream(xref_offset);\n        }\n        if (visited.count(xref_offset) != 0) {\n            QTC::TC(\"qpdf\", \"QPDF xref loop\");\n            throw damagedPDF(\"\", 0, \"loop detected following xref tables\");\n        }\n    }\n\n    if (!m->trailer.isInitialized()) {\n        throw damagedPDF(\"\", 0, \"unable to find trailer while reading xref\");\n    }\n    int size = m->trailer.getKey(\"/Size\").getIntValueAsInt();\n    int max_obj = 0;\n    if (!m->xref_table.empty()) {\n        max_obj = (*(m->xref_table.rbegin())).first.getObj();\n    }\n    if (!m->deleted_objects.empty()) {\n        max_obj = std::max(max_obj, *(m->deleted_objects.rbegin()));\n    }\n    if ((size < 1) || (size - 1 != max_obj)) {\n        QTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n        warn(damagedPDF(\n            \"\",\n            0,\n            (\"reported number of objects (\" + std::to_string(size) +\n             \") is not one plus the highest object number (\" + std::to_string(max_obj) + \")\")));\n    }\n\n    // We no longer need the deleted_objects table, so go ahead and clear it out to make sure we\n    // never depend on its being set.\n    m->deleted_objects.clear();\n\n    // Make sure we keep only the highest generation for any object.\n    QPDFObjGen last_og{-1, 0};\n    for (auto const& item: m->xref_table) {\n        auto id = item.first.getObj();\n        if (id == last_og.getObj() && id > 0)\n            removeObject(last_og);\n        last_og = item.first;\n    }\n}\nstd::vector<QPDFObjGen>\nQPDF::getCompressibleObjGens()\n{\n    // Return a list of objects that are allowed to be in object streams.  Walk through the objects\n    // by traversing the document from the root, including a traversal of the pages tree.  This\n    // makes that objects that are on the same page are more likely to be in the same object stream,\n    // which is slightly more efficient, particularly with linearized files.  This is better than\n    // iterating through the xref table since it avoids preserving orphaned items.\n\n    // Exclude encryption dictionary, if any\n    QPDFObjectHandle encryption_dict = m->trailer.getKey(\"/Encrypt\");\n    QPDFObjGen encryption_dict_og = encryption_dict.getObjGen();\n\n    const size_t max_obj = getObjectCount();\n    std::vector<bool> visited(max_obj, false);\n    std::vector<QPDFObjectHandle> queue;\n    queue.reserve(512);\n    queue.push_back(m->trailer);\n    std::vector<QPDFObjGen> result;\n    while (!queue.empty()) {\n        auto obj = queue.back();\n        queue.pop_back();\n        if (obj.getObjectID() > 0) {\n            QPDFObjGen og = obj.getObjGen();\n            const size_t id = toS(og.getObj() - 1);\n            if (id >= max_obj)\n                throw std::logic_error(\n                    \"unexpected object id encountered in getCompressibleObjGens\");\n            if (visited[id]) {\n                QTC::TC(\"qpdf\", \"QPDF loop detected traversing objects\");\n                continue;\n            }\n\n            // Check whether this is the current object. If not, remove it (which changes it into a\n            // direct null and therefore stops us from revisiting it) and move on to the next object\n            // in the queue.\n            auto upper = m->obj_cache.upper_bound(og);\n            if (upper != m->obj_cache.end() && upper->first.getObj() == og.getObj()) {\n                removeObject(og);\n                continue;\n            }\n\n            visited[id] = true;\n\n            if (og == encryption_dict_og) {\n                QTC::TC(\"qpdf\", \"QPDF exclude encryption dictionary\");\n            } else if (!(obj.isStream() ||\n                         (obj.isDictionaryOfType(\"/Sig\") && obj.hasKey(\"/ByteRange\") &&\n                          obj.hasKey(\"/Contents\")))) {\n                result.push_back(og);\n            }\n        }\n        if (obj.isStream()) {\n            QPDFObjectHandle dict = obj.getDict();\n            std::set<std::string> keys = dict.getKeys();\n            for (auto iter = keys.rbegin(); iter != keys.rend(); ++iter) {\n                std::string const& key = *iter;\n                QPDFObjectHandle value = dict.getKey(key);\n                if (key == \"/Length\") {\n                    // omit stream lengths\n                    if (value.isIndirect()) {\n                        QTC::TC(\"qpdf\", \"QPDF exclude indirect length\");\n                    }\n                } else {\n                    queue.push_back(value);\n                }\n            }\n        } else if (obj.isDictionary()) {\n            std::set<std::string> keys = obj.getKeys();\n            for (auto iter = keys.rbegin(); iter != keys.rend(); ++iter) {\n                queue.push_back(obj.getKey(*iter));\n            }\n        } else if (obj.isArray()) {\n            int n = obj.getArrayNItems();\n            for (int i = 1; i <= n; ++i) {\n                queue.push_back(obj.getArrayItem(n - i));\n            }\n        }\n    }\n\n    return result;\n}\nvoid\nQPDF::reconstruct_xref(QPDFExc& e)\n{\n    if (m->reconstructed_xref) {\n        // Avoid xref reconstruction infinite loops. This is getting very hard to reproduce because\n        // qpdf is throwing many fewer exceptions while parsing. Most situations are warnings now.\n        throw e;\n    }\n\n    m->reconstructed_xref = true;\n    // We may find more objects, which may contain dangling references.\n    m->fixed_dangling_refs = false;\n\n    warn(damagedPDF(\"\", 0, \"file is damaged\"));\n    warn(e);\n    warn(damagedPDF(\"\", 0, \"Attempting to reconstruct cross-reference table\"));\n\n    // Delete all references to type 1 (uncompressed) objects\n    std::set<QPDFObjGen> to_delete;\n    for (auto const& iter: m->xref_table) {\n        if (iter.second.getType() == 1) {\n            to_delete.insert(iter.first);\n        }\n    }\n    for (auto const& iter: to_delete) {\n        m->xref_table.erase(iter);\n    }\n\n    m->file->seek(0, SEEK_END);\n    qpdf_offset_t eof = m->file->tell();\n    m->file->seek(0, SEEK_SET);\n    qpdf_offset_t line_start = 0;\n    // Don't allow very long tokens here during recovery.\n    static size_t const MAX_LEN = 100;\n    while (m->file->tell() < eof) {\n        m->file->findAndSkipNextEOL();\n        qpdf_offset_t next_line_start = m->file->tell();\n        m->file->seek(line_start, SEEK_SET);\n        QPDFTokenizer::Token t1 = readToken(m->file, MAX_LEN);\n        qpdf_offset_t token_start = m->file->tell() - toO(t1.getValue().length());\n        if (token_start >= next_line_start) {\n            // don't process yet -- wait until we get to the line containing this token\n        } else if (t1.isInteger()) {\n            QPDFTokenizer::Token t2 = readToken(m->file, MAX_LEN);\n            if ((t2.isInteger()) && (readToken(m->file, MAX_LEN).isWord(\"obj\"))) {\n                int obj = QUtil::string_to_int(t1.getValue().c_str());\n                int gen = QUtil::string_to_int(t2.getValue().c_str());\n                insertReconstructedXrefEntry(obj, token_start, gen);\n            }\n        } else if (!m->trailer.isInitialized() && t1.isWord(\"trailer\")) {\n            QPDFObjectHandle t = readTrailer();\n            if (!t.isDictionary()) {\n                // Oh well.  It was worth a try.\n            } else {\n                setTrailer(t);\n            }\n        }\n        m->file->seek(next_line_start, SEEK_SET);\n        line_start = next_line_start;\n    }\n    m->deleted_objects.clear();\n\n    if (!m->trailer.isInitialized()) {\n        qpdf_offset_t max_offset{0};\n        // If there are any xref streams, take the last one to appear.\n        for (auto const& iter: m->xref_table) {\n            auto entry = iter.second;\n            if (entry.getType() != 1) {\n                continue;\n            }\n            auto oh = getObjectByObjGen(iter.first);\n            try {\n                if (!oh.isStreamOfType(\"/XRef\")) {\n                    continue;\n                }\n            } catch (std::exception&) {\n                continue;\n            }\n            auto offset = entry.getOffset();\n            if (offset > max_offset) {\n                max_offset = offset;\n                setTrailer(oh.getDict());\n            }\n        }\n        if (max_offset > 0) {\n            try {\n                read_xref(max_offset);\n            } catch (std::exception&) {\n                throw damagedPDF(\n                    \"\", 0, \"error decoding candidate xref stream while recovering damaged file\");\n            }\n            QTC::TC(\"qpdf\", \"QPDF recover xref stream\");\n        }\n    }\n\n    if (!m->trailer.isInitialized()) {\n        // We could check the last encountered object to see if it was an xref stream.  If so, we\n        // could try to get the trailer from there.  This may make it possible to recover files with\n        // bad startxref pointers even when they have object streams.\n\n        throw damagedPDF(\"\", 0, \"unable to find trailer dictionary while recovering damaged file\");\n    }\n\n    // We could iterate through the objects looking for streams and try to find objects inside of\n    // them, but it's probably not worth the trouble.  Acrobat can't recover files with any errors\n    // in an xref stream, and this would be a real long shot anyway.  If we wanted to do anything\n    // that involved looking at stream contents, we'd also have to call initializeEncryption() here.\n    // It's safe to call it more than once.\n}\nvoid\nQPDF::parse(char const* password)\n{\n    if (password) {\n        m->encp->provided_password = password;\n    }\n\n    // Find the header anywhere in the first 1024 bytes of the file.\n    PatternFinder hf(*this, &QPDF::findHeader);\n    if (!m->file->findFirst(\"%PDF-\", 0, 1024, hf)) {\n        QTC::TC(\"qpdf\", \"QPDF not a pdf file\");\n        warn(damagedPDF(\"\", 0, \"can't find PDF header\"));\n        // QPDFWriter writes files that usually require at least version 1.2 for /FlateDecode\n        m->pdf_version = \"1.2\";\n    }\n\n    // PDF spec says %%EOF must be found within the last 1024 bytes of/ the file.  We add an extra\n    // 30 characters to leave room for the startxref stuff.\n    m->file->seek(0, SEEK_END);\n    qpdf_offset_t end_offset = m->file->tell();\n    qpdf_offset_t start_offset = (end_offset > 1054 ? end_offset - 1054 : 0);\n    PatternFinder sf(*this, &QPDF::findStartxref);\n    qpdf_offset_t xref_offset = 0;\n    if (m->file->findLast(\"startxref\", start_offset, 0, sf)) {\n        xref_offset = QUtil::string_to_ll(readToken(m->file).getValue().c_str());\n    }\n\n    try {\n        if (xref_offset == 0) {\n            QTC::TC(\"qpdf\", \"QPDF can't find startxref\");\n            throw damagedPDF(\"\", 0, \"can't find startxref\");\n        }\n        try {\n            read_xref(xref_offset);\n        } catch (QPDFExc&) {\n            throw;\n        } catch (std::exception& e) {\n            throw damagedPDF(\"\", 0, std::string(\"error reading xref: \") + e.what());\n        }\n    } catch (QPDFExc& e) {\n        if (m->attempt_recovery) {\n            reconstruct_xref(e);\n            QTC::TC(\"qpdf\", \"QPDF reconstructed xref table\");\n        } else {\n            throw;\n        }\n    }\n\n    initializeEncryption();\n    m->parsed = true;\n}\nvoid\nQPDF::processInputSource(std::shared_ptr<InputSource> source, char const* password)\n{\n    m->file = source;\n    parse(password);\n}\nstd::shared_ptr<QPDF>\nFuzzHelper::getQpdf()\n{\n    auto is =\n        std::shared_ptr<InputSource>(new BufferInputSource(\"fuzz input\", &this->input_buffer));\n    auto qpdf = QPDF::create();\n    qpdf->processInputSource(is);\n    return qpdf;\n}\nvoid\nFuzzHelper::testWrite()\n{\n    // Write in various ways to exercise QPDFWriter\n\n    std::shared_ptr<QPDF> q;\n    std::shared_ptr<QPDFWriter> w;\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setDeterministicID(true);\n    w->setQDFMode(true);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setStaticID(true);\n    w->setLinearization(true);\n    w->setR6EncryptionParameters(\"u\", \"o\", true, true, true, true, true, true, qpdf_r3p_full, true);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setStaticID(true);\n    w->setObjectStreamMode(qpdf_o_disable);\n    w->setR3EncryptionParametersInsecure(\n        \"u\", \"o\", true, true, true, true, true, true, qpdf_r3p_full);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setDeterministicID(true);\n    w->setObjectStreamMode(qpdf_o_generate);\n    w->setLinearization(true);\n    doWrite(w);\n}\nvoid\nFuzzHelper::doChecks()\n{\n    // Get as much coverage as possible in parts of the library that\n    // might benefit from fuzzing.\n    testWrite();\n    testPages();\n    testOutlines();\n}\nvoid\nFuzzHelper::run()\n{\n    // The goal here is that you should be able to throw anything at\n    // libqpdf and it will respond without any memory errors and never\n    // do anything worse than throwing a QPDFExc or\n    // std::runtime_error. Throwing any other kind of exception,\n    // segfaulting, or having a memory error (when built with\n    // appropriate sanitizers) will all cause abnormal exit.\n    try {\n        doChecks();\n    } catch (QPDFExc const& e) {\n        std::cerr << \"QPDFExc: \" << e.what() << std::endl;\n    } catch (std::runtime_error const& e) {\n        std::cerr << \"runtime_error: \" << e.what() << std::endl;\n    }\n}\nextern \"C\" int\nLLVMFuzzerTestOneInput(unsigned char const* data, size_t size)\n{\n#ifndef _WIN32\n    // Used by jpeg library to work around false positives in memory\n    // sanitizer.\n    setenv(\"JSIMD_FORCENONE\", \"1\", 1);\n#endif\n    FuzzHelper f(data, size);\n    f.run();\n    return 0;\n}",
    "target": 0,
    "idx": 2065777
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "UA_Server *\nUA_Server_new() {\n    UA_ServerConfig config;\n    memset(&config, 0, sizeof(UA_ServerConfig));\n    /* Set a default logger and NodeStore for the initialization */\n    config.logger = UA_Log_Stdout_;\n    if(UA_STATUSCODE_GOOD != UA_Nodestore_HashMap(&config.nodestore)) {\n        return NULL;\n    }\n\n    return UA_Server_newWithConfig(&config);\n}\nUA_Server *\nUA_Server_newWithConfig(UA_ServerConfig *config) {\n    if(!config)\n        return NULL;\n    UA_Server *server = (UA_Server *)UA_calloc(1, sizeof(UA_Server));\n    if(!server) {\n        UA_ServerConfig_clean(config);\n        return NULL;\n    }\n    server->config = *config;\n    memset(config, 0, sizeof(UA_ServerConfig));\n    return UA_Server_init(server);\n}\nstatic void\nUA_NodeMap_delete(void *context) {\n    UA_NodeMap *ns = (UA_NodeMap*)context;\n    UA_UInt32 size = ns->size;\n    UA_NodeMapSlot *slots = ns->slots;\n    for(UA_UInt32 i = 0; i < size; ++i) {\n        if(slots[i].entry > UA_NODEMAP_TOMBSTONE) {\n            /* On debugging builds, check that all nodes were release */\n            UA_assert(slots[i].entry->refCount == 0);\n            /* Delete the node */\n            deleteNodeMapEntry(slots[i].entry);\n        }\n    }\n    UA_free(ns->slots);\n\n    /* Clean up the ReferenceTypes index array */\n    for(size_t i = 0; i < ns->referenceTypeCounter; i++)\n        UA_NodeId_clear(&ns->referenceTypeIds[i]);\n\n    UA_free(ns);\n}\nextern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    if(size <= 4)\n        return 0;\n\n    if(!UA_memoryManager_setLimitFromLast4Bytes(data, size))\n        return 0;\n    size -= 4;\n\n    UA_Connection c = createDummyConnection(RECEIVE_BUFFER_SIZE, NULL);\n    UA_Server *server = UA_Server_new();\n    if(!server) {\n        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,\n                     \"Could not create server instance using UA_Server_new\");\n        return 0;\n    }\n\n    UA_StatusCode retval = UA_ServerConfig_setDefault(UA_Server_getConfig(server));\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Server_delete(server);\n        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,\n                     \"Could not set the server config\");\n        return 0;\n    }\n\n    // we need to copy the message because it will be freed in the processing function\n    UA_ByteString msg = UA_ByteString();\n    retval = UA_ByteString_allocBuffer(&msg, size);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Server_delete(server);\n        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,\n                     \"Could not allocate message buffer\");\n        return 0;\n    }\n    memcpy(msg.data, data, size);\n\n    UA_Server_processBinaryMessage(server, &c, &msg);\n    // if we got an invalid chunk, the message is not deleted, so delete it here\n    UA_ByteString_deleteMembers(&msg);\n    UA_Server_run_shutdown(server);\n    UA_Server_delete(server);\n    c.close(&c);\n    return 0;\n}",
    "target": 0,
    "idx": 2025068
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "X509_EXTENSION *X509_EXTENSION_create_by_NID(X509_EXTENSION **ex, int nid,\n                                             int crit,\n                                             const ASN1_OCTET_STRING *data) {\n  const ASN1_OBJECT *obj;\n  X509_EXTENSION *ret;\n\n  obj = OBJ_nid2obj(nid);\n  if (obj == NULL) {\n    OPENSSL_PUT_ERROR(X509, X509_R_UNKNOWN_NID);\n    return NULL;\n  }\n  ret = X509_EXTENSION_create_by_OBJ(ex, obj, crit, data);\n  return ret;\n}\nint X509V3_EXT_add_nconf_sk(const CONF *conf, const X509V3_CTX *ctx,\n                            const char *section,\n                            STACK_OF(X509_EXTENSION) **sk) {\n  const STACK_OF(CONF_VALUE) *nval = NCONF_get_section(conf, section);\n  if (nval == NULL) {\n    return 0;\n  }\n  for (size_t i = 0; i < sk_CONF_VALUE_num(nval); i++) {\n    const CONF_VALUE *val = sk_CONF_VALUE_value(nval, i);\n    X509_EXTENSION *ext = X509V3_EXT_nconf(conf, ctx, val->name, val->value);\n    int ok = ext != NULL &&  //\n             (sk == NULL || X509v3_add_ext(sk, ext, -1) != NULL);\n    X509_EXTENSION_free(ext);\n    if (!ok) {\n      return 0;\n    }\n  }\n  return 1;\n}\nsize_t sk_num(const _STACK *sk) {\n  if (sk == NULL) {\n    return 0;\n  }\n  return sk->num;\n}\nvoid ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {\n  size_t i;\n  if (tt->flags & ASN1_TFLG_SK_MASK) {\n    STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\n    for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {\n      ASN1_VALUE *vtmp;\n      vtmp = sk_ASN1_VALUE_value(sk, i);\n      asn1_item_combine_free(&vtmp, ASN1_ITEM_ptr(tt->item), 0);\n    }\n    sk_ASN1_VALUE_free(sk);\n    *pval = NULL;\n  } else {\n    asn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),\n                           tt->flags & ASN1_TFLG_COMBINE);\n  }\n}\nvoid asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it,\n                            int combine) {\n  const ASN1_TEMPLATE *tt = NULL, *seqtt;\n  const ASN1_EXTERN_FUNCS *ef;\n  int i;\n  if (!pval) {\n    return;\n  }\n  if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {\n    return;\n  }\n\n  switch (it->itype) {\n    case ASN1_ITYPE_PRIMITIVE:\n      if (it->templates) {\n        ASN1_template_free(pval, it->templates);\n      } else {\n        ASN1_primitive_free(pval, it);\n      }\n      break;\n\n    case ASN1_ITYPE_MSTRING:\n      ASN1_primitive_free(pval, it);\n      break;\n\n    case ASN1_ITYPE_CHOICE: {\n      const ASN1_AUX *aux = it->funcs;\n      ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;\n      if (asn1_cb) {\n        i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\n        if (i == 2) {\n          return;\n        }\n      }\n      i = asn1_get_choice_selector(pval, it);\n      if ((i >= 0) && (i < it->tcount)) {\n        ASN1_VALUE **pchval;\n        tt = it->templates + i;\n        pchval = asn1_get_field_ptr(pval, tt);\n        ASN1_template_free(pchval, tt);\n      }\n      if (asn1_cb) {\n        asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\n      }\n      if (!combine) {\n        OPENSSL_free(*pval);\n        *pval = NULL;\n      }\n      break;\n    }\n\n    case ASN1_ITYPE_EXTERN:\n      ef = it->funcs;\n      if (ef && ef->asn1_ex_free) {\n        ef->asn1_ex_free(pval, it);\n      }\n      break;\n\n    case ASN1_ITYPE_SEQUENCE: {\n      if (!asn1_refcount_dec_and_test_zero(pval, it)) {\n        return;\n      }\n      const ASN1_AUX *aux = it->funcs;\n      ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;\n      if (asn1_cb) {\n        i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\n        if (i == 2) {\n          return;\n        }\n      }\n      asn1_enc_free(pval, it);\n      // If we free up as normal we will invalidate any ANY DEFINED BY\n      // field and we wont be able to determine the type of the field it\n      // defines. So free up in reverse order.\n      tt = it->templates + it->tcount - 1;\n      for (i = 0; i < it->tcount; tt--, i++) {\n        ASN1_VALUE **pseqval;\n        seqtt = asn1_do_adb(pval, tt, 0);\n        if (!seqtt) {\n          continue;\n        }\n        pseqval = asn1_get_field_ptr(pval, seqtt);\n        ASN1_template_free(pseqval, seqtt);\n      }\n      if (asn1_cb) {\n        asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\n      }\n      if (!combine) {\n        OPENSSL_free(*pval);\n        *pval = NULL;\n      }\n      break;\n    }\n  }\n}\nvoid ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {\n  size_t i;\n  if (tt->flags & ASN1_TFLG_SK_MASK) {\n    STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\n    for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {\n      ASN1_VALUE *vtmp;\n      vtmp = sk_ASN1_VALUE_value(sk, i);\n      asn1_item_combine_free(&vtmp, ASN1_ITEM_ptr(tt->item), 0);\n    }\n    sk_ASN1_VALUE_free(sk);\n    *pval = NULL;\n  } else {\n    asn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),\n                           tt->flags & ASN1_TFLG_COMBINE);\n  }\n}\nvoid asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it,\n                            int combine) {\n  const ASN1_TEMPLATE *tt = NULL, *seqtt;\n  const ASN1_EXTERN_FUNCS *ef;\n  int i;\n  if (!pval) {\n    return;\n  }\n  if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {\n    return;\n  }\n\n  switch (it->itype) {\n    case ASN1_ITYPE_PRIMITIVE:\n      if (it->templates) {\n        ASN1_template_free(pval, it->templates);\n      } else {\n        ASN1_primitive_free(pval, it);\n      }\n      break;\n\n    case ASN1_ITYPE_MSTRING:\n      ASN1_primitive_free(pval, it);\n      break;\n\n    case ASN1_ITYPE_CHOICE: {\n      const ASN1_AUX *aux = it->funcs;\n      ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;\n      if (asn1_cb) {\n        i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\n        if (i == 2) {\n          return;\n        }\n      }\n      i = asn1_get_choice_selector(pval, it);\n      if ((i >= 0) && (i < it->tcount)) {\n        ASN1_VALUE **pchval;\n        tt = it->templates + i;\n        pchval = asn1_get_field_ptr(pval, tt);\n        ASN1_template_free(pchval, tt);\n      }\n      if (asn1_cb) {\n        asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\n      }\n      if (!combine) {\n        OPENSSL_free(*pval);\n        *pval = NULL;\n      }\n      break;\n    }\n\n    case ASN1_ITYPE_EXTERN:\n      ef = it->funcs;\n      if (ef && ef->asn1_ex_free) {\n        ef->asn1_ex_free(pval, it);\n      }\n      break;\n\n    case ASN1_ITYPE_SEQUENCE: {\n      if (!asn1_refcount_dec_and_test_zero(pval, it)) {\n        return;\n      }\n      const ASN1_AUX *aux = it->funcs;\n      ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;\n      if (asn1_cb) {\n        i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\n        if (i == 2) {\n          return;\n        }\n      }\n      asn1_enc_free(pval, it);\n      // If we free up as normal we will invalidate any ANY DEFINED BY\n      // field and we wont be able to determine the type of the field it\n      // defines. So free up in reverse order.\n      tt = it->templates + it->tcount - 1;\n      for (i = 0; i < it->tcount; tt--, i++) {\n        ASN1_VALUE **pseqval;\n        seqtt = asn1_do_adb(pval, tt, 0);\n        if (!seqtt) {\n          continue;\n        }\n        pseqval = asn1_get_field_ptr(pval, seqtt);\n        ASN1_template_free(pseqval, seqtt);\n      }\n      if (asn1_cb) {\n        asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\n      }\n      if (!combine) {\n        OPENSSL_free(*pval);\n        *pval = NULL;\n      }\n      break;\n    }\n  }\n}\nvoid ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it) {\n  asn1_item_combine_free(&val, it, 0);\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len) {\n  bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(buf, len));\n  bssl::UniquePtr<CONF> conf(NCONF_new(nullptr));\n  if (NCONF_load_bio(conf.get(), bio.get(), nullptr)) {\n    // Run with and without |X509V3_CTX| information.\n    bssl::UniquePtr<X509> cert(X509_new());\n    X509V3_CTX ctx;\n    X509V3_set_ctx(&ctx, /*subject=*/cert.get(), /*issuer=*/cert.get(), nullptr,\n                   nullptr, 0);\n    X509V3_EXT_add_nconf(conf.get(), &ctx, \"default\", cert.get());\n\n    cert.reset(X509_new());\n    X509V3_EXT_add_nconf(conf.get(), nullptr, \"default\", cert.get());\n  }\n  return 0;\n}",
    "target": 0,
    "idx": 2055556
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "ATTRIBUTE_MALLOC\nBITCODE_TV\nbit_read_TV (Bit_Chain *restrict dat)\n{\n  unsigned int i;\n  unsigned int length;\n  unsigned char *chain;\n\n  CHK_OVERFLOW_PLUS (1,__FUNCTION__,NULL)\n  if (dat->from_version < R_13)\n    length = bit_read_RS (dat);\n  else\n    length = bit_read_BS (dat);\n  CHK_OVERFLOW_PLUS (length,__FUNCTION__,NULL)\n  chain = (unsigned char *)malloc (length + 1);\n  if (!chain)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"Out of memory\");\n      return NULL;\n    }\n  for (i = 0; i < length; i++)\n    chain[i] = bit_read_RC (dat);\n  // check if the string is already zero-terminated or not.\n  // only observed >=r2004 as writer app\n  if (length > 0 && dat->from_version > R_2000 && chain[length - 1] != '\\0')\n    LOG_HANDLE (\"TV-not-ZERO %u\\n \", length)\n  else if (length > 0 && dat->from_version <= R_2000 && chain[length - 1] == '\\0')\n    LOG_HANDLE (\"TV-ZERO %u\\n\", length)\n  // normally not needed, as the DWG since r2004 itself contains the ending \\0 as last char\n  chain[i] = '\\0';\n  return (char *)chain;\n}\nvoid\nbit_write_TV (Bit_Chain *restrict dat, BITCODE_TV restrict chain)\n{\n  int i;\n  int length = (chain && *chain) ? strlen ((const char *)chain) : 0;\n  if (dat->version <= R_2000 && length)\n    length++;\n  if (dat->from_version < R_13)\n    bit_write_RS (dat, length);\n  else\n    bit_write_BS (dat, length);\n  for (i = 0; i < length; i++)\n    bit_write_RC (dat, (unsigned char)chain[i]);\n}\nstatic int ishex (int c)\n{\n  return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')\n          || (c >= 'A' && c <= 'F'));\n}\nEXPORT void\ndwg_free_object (Dwg_Object *obj)\n{\n  int error = 0;\n  long unsigned int j;\n  Dwg_Data *dwg;\n  Bit_Chain *dat = &pdat;\n\n  if (obj && obj->parent)\n    {\n      dwg = obj->parent;\n      dat->version = dwg->header.version;\n      dat->from_version = dwg->header.from_version;\n    }\n  else\n    return;\n  if (obj->type == DWG_TYPE_FREED || obj->tio.object == NULL)\n    return;\n\n  PRE (R_13) {\n    free_preR13_object (obj);\n    return;\n  }\n\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      dwg_free_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      dwg_free_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      dwg_free_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      dwg_free_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      dwg_free_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      dwg_free_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      dwg_free_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      dwg_free_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      dwg_free_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      dwg_free_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      dwg_free_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      dwg_free_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      dwg_free_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      dwg_free_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      dwg_free_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      dwg_free_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      dwg_free_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      dwg_free_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      dwg_free_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      dwg_free_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      dwg_free_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      dwg_free_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      dwg_free_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      dwg_free_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      dwg_free_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      dwg_free_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      dwg_free__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      dwg_free_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      dwg_free_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      dwg_free_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      dwg_free_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      dwg_free_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      dwg_free_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      dwg_free_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      dwg_free_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      dwg_free_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      dwg_free__3DSOLID (dat, obj);\n      break; /* Check the type of the object */\n    case DWG_TYPE_BODY:\n      dwg_free_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      dwg_free_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      dwg_free_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      dwg_free_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      dwg_free_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      dwg_free_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      dwg_free_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      dwg_free_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      dwg_free_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      dwg_free_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      dwg_free_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      dwg_free_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      dwg_free_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      dwg_free_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      dwg_free_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      dwg_free_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      dwg_free_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      dwg_free_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      dwg_free_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      dwg_free_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      dwg_free_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      dwg_free_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      dwg_free_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      dwg_free_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      dwg_free_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      dwg_free_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VX_CONTROL:\n      dwg_free_VX_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VX_TABLE_RECORD:\n      dwg_free_VX_TABLE_RECORD (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      dwg_free_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      dwg_free_MLINESTYLE (dat, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      dwg_free_OLE2FRAME (dat, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      dwg_free_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      dwg_free_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      dwg_free_LWPOLYLINE (dat, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      dwg_free_HATCH (dat, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      dwg_free_XRECORD (dat, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      dwg_free_PLACEHOLDER (dat, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      dwg_free_OLEFRAME (dat, obj);\n      break;\n#ifdef DEBUG_VBA_PROJECT\n    case DWG_TYPE_VBA_PROJECT:\n      dwg_free_VBA_PROJECT (dat, obj);\n      break;\n#endif\n    case DWG_TYPE_LAYOUT:\n      dwg_free_LAYOUT (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      dwg_free_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      dwg_free_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type\n          && obj->fixedtype == DWG_TYPE_LAYOUT)\n        {\n          SINCE (R_13)\n          {\n            dwg_free_LAYOUT (dat, obj); // XXX avoid double-free, esp. in eed\n          }\n        }\n      else if ((error = dwg_free_variable_type (obj->parent, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)\n              dwg_free_UNKNOWN_ENT (dat, obj);\n          else if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)\n              dwg_free_UNKNOWN_OBJ (dat, obj);\n        }\n    }\n  /* With indxf the dxfname is dynamic, just the name is const */\n  if (dwg->opts & DWG_OPTS_IN)\n    FREE_IF (obj->dxfname);\n  /* With injson even the name is dynamic */\n  if (dwg->opts & DWG_OPTS_INJSON)\n    FREE_IF (obj->name);\n  obj->type = DWG_TYPE_FREED;\n}\nvoid\ndwg_free (Dwg_Data *dwg)\n{\n  BITCODE_BL i;\n  if (dwg)\n    {\n      pdat.version = dwg->header.version;\n      pdat.from_version = dwg->header.from_version;\n      if (dwg->opts)\n        {\n          loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n          pdat.opts = dwg->opts;\n        }\n#ifdef USE_TRACING\n      /* Before starting, set the logging level, but only do so once.  */\n      if (!env_var_checked_p)\n        {\n          char *probe = getenv (\"LIBREDWG_TRACE\");\n          if (probe)\n            loglevel = atoi (probe);\n          env_var_checked_p = 1;\n        }\n#endif /* USE_TRACING */\n      LOG_INFO (\"\\n============\\ndwg_free\\n\")\n      // copied table fields have duplicate pointers, but are freed only once\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (!dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      dwg_free_header_vars (dwg);\n      dwg_free_summaryinfo (dwg);\n      FREE_IF (dwg->thumbnail.chain);\n      if (dwg->header.section_infohdr.num_desc)\n        {\n          for (i = 0; i < dwg->header.section_infohdr.num_desc; ++i)\n            FREE_IF (dwg->header.section_info[i].sections);\n          FREE_IF (dwg->header.section_info);\n        }\n      dwg_free_appinfo (dwg);\n      dwg_free_filedeplist (dwg);\n      dwg_free_security (dwg);\n      dwg_free_acds (dwg);\n\n      FREE_IF (dwg->vbaproject.unknown_bits);\n      FREE_IF (dwg->revhistory.histories);\n      FREE_IF (dwg->appinfohistory.unknown_bits);\n      //FREE_IF (dwg->objfreespace...);\n      FREE_IF (dwg->Template.description);\n      FREE_IF (dwg->header.section);\n      for (i = 0; i < dwg->second_header.num_handlers; i++)\n        FREE_IF (dwg->second_header.handlers[i].data);\n      // auxheader has no strings\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      if (dwg->num_classes && dwg->dwg_class)\n        {\n          for (i = 0; i < dwg->num_classes; ++i)\n            {\n              FREE_IF (dwg->dwg_class[i].appname);\n              FREE_IF (dwg->dwg_class[i].cppname);\n              FREE_IF (dwg->dwg_class[i].dxfname);\n              if (dwg->header.from_version >= R_2007)\n                FREE_IF (dwg->dwg_class[i].dxfname_u);\n            }\n        }\n      FREE_IF (dwg->dwg_class);\n      if (dwg->object_ref)\n        {\n          LOG_HANDLE (\"free %d global refs\\n\", dwg->num_object_refs)\n          for (i = 0; i < dwg->num_object_refs; ++i)\n            {\n              //LOG_HANDLE (\"free ref %d\\n\", i)\n              FREE_IF (dwg->object_ref[i]);\n            }\n        }\n      FREE_IF (dwg->object_ref);\n      for (i = 0; i < dwg->num_acis_sab_hdl; ++i)\n        {\n          FREE_IF (dwg->acis_sab_hdl[i]);\n        }\n      FREE_IF (dwg->acis_sab_hdl);\n      FREE_IF (dwg->object);\n      if (dwg->object_map)\n        hash_free (dwg->object_map);\n      dwg->num_objects = dwg->num_classes = dwg->num_object_refs = 0;\n#undef FREE_IF\n    }\n}",
    "target": 0,
    "idx": 2034377
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "void dav1d_flush(Dav1dContext *const c) {\n    dav1d_data_unref_internal(&c->in);\n    if (c->out.p.frame_hdr)\n        dav1d_thread_picture_unref(&c->out);\n    if (c->cache.p.frame_hdr)\n        dav1d_thread_picture_unref(&c->cache);\n\n    c->drain = 0;\n    c->cached_error = 0;\n\n    for (int i = 0; i < 8; i++) {\n        if (c->refs[i].p.p.frame_hdr)\n            dav1d_thread_picture_unref(&c->refs[i].p);\n        dav1d_ref_dec(&c->refs[i].segmap);\n        dav1d_ref_dec(&c->refs[i].refmvs);\n        dav1d_cdf_thread_unref(&c->cdf[i]);\n    }\n    c->frame_hdr = NULL;\n    c->seq_hdr = NULL;\n    dav1d_ref_dec(&c->seq_hdr_ref);\n\n    c->mastering_display = NULL;\n    c->content_light = NULL;\n    c->itut_t35 = NULL;\n    dav1d_ref_dec(&c->mastering_display_ref);\n    dav1d_ref_dec(&c->content_light_ref);\n    dav1d_ref_dec(&c->itut_t35_ref);\n\n    dav1d_data_props_unref_internal(&c->cached_error_props);\n\n    if (c->n_fc == 1 && c->n_tc == 1) return;\n    atomic_store(c->flush, 1);\n\n    // stop running tasks in worker threads\n    if (c->n_tc > 1) {\n        pthread_mutex_lock(&c->task_thread.lock);\n        for (unsigned i = 0; i < c->n_tc; i++) {\n            Dav1dTaskContext *const tc = &c->tc[i];\n            while (!tc->task_thread.flushed) {\n                pthread_cond_wait(&tc->task_thread.td.cond, &c->task_thread.lock);\n            }\n        }\n        for (unsigned i = 0; i < c->n_fc; i++) {\n            c->fc[i].task_thread.task_head = NULL;\n            c->fc[i].task_thread.task_tail = NULL;\n            c->fc[i].task_thread.task_cur_prev = NULL;\n            c->fc[i].task_thread.pending_tasks.head = NULL;\n            c->fc[i].task_thread.pending_tasks.tail = NULL;\n            atomic_init(&c->fc[i].task_thread.pending_tasks.merge, 0);\n        }\n        atomic_init(&c->task_thread.first, 0);\n        c->task_thread.cur = c->n_fc;\n        atomic_store(&c->task_thread.reset_task_cur, UINT_MAX);\n        atomic_store(&c->task_thread.cond_signaled, 0);\n        pthread_mutex_unlock(&c->task_thread.lock);\n    }\n\n    // wait for threads to complete flushing\n    if (c->n_fc > 1) {\n        for (unsigned n = 0, next = c->frame_thread.next; n < c->n_fc; n++, next++) {\n            if (next == c->n_fc) next = 0;\n            Dav1dFrameContext *const f = &c->fc[next];\n            dav1d_decode_frame_exit(f, -1);\n            f->n_tile_data = 0;\n            f->task_thread.retval = 0;\n            Dav1dThreadPicture *out_delayed = &c->frame_thread.out_delayed[next];\n            if (out_delayed->p.frame_hdr) {\n                dav1d_thread_picture_unref(out_delayed);\n            }\n        }\n        c->frame_thread.next = 0;\n    }\n    atomic_store(c->flush, 0);\n}\nstatic COLD void close_internal(Dav1dContext **const c_out, int flush) {\n    Dav1dContext *const c = *c_out;\n    if (!c) return;\n\n    if (flush) dav1d_flush(c);\n\n    if (c->tc) {\n        struct TaskThreadData *ttd = &c->task_thread;\n        if (ttd->inited) {\n            pthread_mutex_lock(&ttd->lock);\n            for (unsigned n = 0; n < c->n_tc && c->tc[n].task_thread.td.inited; n++)\n                c->tc[n].task_thread.die = 1;\n            pthread_cond_broadcast(&ttd->cond);\n            pthread_mutex_unlock(&ttd->lock);\n            for (unsigned n = 0; n < c->n_tc; n++) {\n                Dav1dTaskContext *const pf = &c->tc[n];\n                if (!pf->task_thread.td.inited) break;\n                pthread_join(pf->task_thread.td.thread, NULL);\n                pthread_cond_destroy(&pf->task_thread.td.cond);\n                pthread_mutex_destroy(&pf->task_thread.td.lock);\n            }\n            pthread_cond_destroy(&ttd->delayed_fg.cond);\n            pthread_cond_destroy(&ttd->cond);\n            pthread_mutex_destroy(&ttd->lock);\n        }\n        dav1d_free_aligned(c->tc);\n    }\n\n    for (unsigned n = 0; c->fc && n < c->n_fc; n++) {\n        Dav1dFrameContext *const f = &c->fc[n];\n\n        // clean-up threading stuff\n        if (c->n_fc > 1) {\n            freep(&f->tile_thread.lowest_pixel_mem);\n            freep(&f->frame_thread.b);\n            dav1d_freep_aligned(&f->frame_thread.pal_idx);\n            dav1d_freep_aligned(&f->frame_thread.cf);\n            freep(&f->frame_thread.tile_start_off);\n            dav1d_freep_aligned(&f->frame_thread.pal);\n            freep(&f->frame_thread.cbi);\n        }\n        if (c->n_tc > 1) {\n            pthread_mutex_destroy(&f->task_thread.pending_tasks.lock);\n            pthread_cond_destroy(&f->task_thread.cond);\n            pthread_mutex_destroy(&f->task_thread.lock);\n        }\n        freep(&f->frame_thread.frame_progress);\n        freep(&f->task_thread.tasks);\n        freep(&f->task_thread.tile_tasks[0]);\n        dav1d_free_aligned(f->ts);\n        dav1d_free_aligned(f->ipred_edge[0]);\n        free(f->a);\n        free(f->tile);\n        free(f->lf.mask);\n        free(f->lf.lr_mask);\n        free(f->lf.level);\n        free(f->lf.tx_lpf_right_edge[0]);\n        free(f->lf.start_of_tile_row);\n        dav1d_refmvs_clear(&f->rf);\n        dav1d_free_aligned(f->lf.cdef_line_buf);\n        dav1d_free_aligned(f->lf.lr_line_buf);\n    }\n    dav1d_free_aligned(c->fc);\n    if (c->n_fc > 1 && c->frame_thread.out_delayed) {\n        for (unsigned n = 0; n < c->n_fc; n++)\n            if (c->frame_thread.out_delayed[n].p.frame_hdr)\n                dav1d_thread_picture_unref(&c->frame_thread.out_delayed[n]);\n        free(c->frame_thread.out_delayed);\n    }\n    for (int n = 0; n < c->n_tile_data; n++)\n        dav1d_data_unref_internal(&c->tile[n].data);\n    free(c->tile);\n    for (int n = 0; n < 8; n++) {\n        dav1d_cdf_thread_unref(&c->cdf[n]);\n        if (c->refs[n].p.p.frame_hdr)\n            dav1d_thread_picture_unref(&c->refs[n].p);\n        dav1d_ref_dec(&c->refs[n].refmvs);\n        dav1d_ref_dec(&c->refs[n].segmap);\n    }\n    dav1d_ref_dec(&c->seq_hdr_ref);\n    dav1d_ref_dec(&c->frame_hdr_ref);\n\n    dav1d_ref_dec(&c->mastering_display_ref);\n    dav1d_ref_dec(&c->content_light_ref);\n    dav1d_ref_dec(&c->itut_t35_ref);\n\n    dav1d_mem_pool_end(c->seq_hdr_pool);\n    dav1d_mem_pool_end(c->frame_hdr_pool);\n    dav1d_mem_pool_end(c->segmap_pool);\n    dav1d_mem_pool_end(c->refmvs_pool);\n    dav1d_mem_pool_end(c->cdf_pool);\n    dav1d_mem_pool_end(c->picture_pool);\n\n    dav1d_freep_aligned(c_out);\n}\nstatic void free_buffer(const uint8_t *const data, void *const user_data) {\n    struct pic_ctx_context *pic_ctx = user_data;\n    const int planes = pic_ctx->layout != DAV1D_PIXEL_LAYOUT_I400 ? 3 : 1;\n\n    for (int i = 0; i < planes; i++)\n        dav1d_ref_dec(&pic_ctx->plane_ref[i]);\n    free(pic_ctx);\n}\nstatic void free_plane_buffer(const uint8_t *const data, void *const user_data) {\n    struct plane_ctx_context *plane_ctx = user_data;\n\n    plane_ctx->allocator.release_picture_callback(&plane_ctx->pic,\n                                                  plane_ctx->allocator.cookie);\n    free(plane_ctx);\n}\nstatic int picture_alloc_with_edges(Dav1dContext *const c,\n                                    Dav1dPicture *const p,\n                                    const int w, const int h,\n                                    Dav1dSequenceHeader *const seq_hdr, Dav1dRef *const seq_hdr_ref,\n                                    Dav1dFrameHeader *const frame_hdr, Dav1dRef *const frame_hdr_ref,\n                                    Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,\n                                    Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,\n                                    Dav1dITUTT35 *const itut_t35, Dav1dRef *const itut_t35_ref,\n                                    const int bpc,\n                                    const Dav1dDataProps *const props,\n                                    Dav1dPicAllocator *const p_allocator,\n                                    const size_t extra, void **const extra_ptr)\n{\n    if (p->data[0]) {\n        dav1d_log(c, \"Picture already allocated!\\n\");\n        return -1;\n    }\n    assert(bpc > 0 && bpc <= 16);\n\n    struct pic_ctx_context *pic_ctx = malloc(extra + sizeof(struct pic_ctx_context));\n    if (pic_ctx == NULL)\n        return DAV1D_ERR(ENOMEM);\n    memset(pic_ctx, 0, sizeof(struct pic_ctx_context));\n\n    p->p.w = w;\n    p->p.h = h;\n    p->seq_hdr = seq_hdr;\n    p->frame_hdr = frame_hdr;\n    p->p.layout = seq_hdr->layout;\n    p->p.bpc = bpc;\n    dav1d_data_props_set_defaults(&p->m);\n    const int res = p_allocator->alloc_picture_callback(p, p_allocator->cookie);\n    if (res < 0) {\n        free(pic_ctx);\n        return res;\n    }\n\n    pic_ctx->layout = p->p.layout;\n\n    if (!(p->ref = dav1d_ref_wrap(p->data[0], free_buffer, pic_ctx))) {\n        p_allocator->release_picture_callback(p, p_allocator->cookie);\n        free(pic_ctx);\n        dav1d_log(c, \"Failed to wrap picture: %s\\n\", strerror(errno));\n        return DAV1D_ERR(ENOMEM);\n    }\n\n    struct plane_ctx_context *plane_ctx = malloc(sizeof(struct plane_ctx_context));\n    if (plane_ctx == NULL){\n        dav1d_ref_dec(&p->ref);\n        p_allocator->release_picture_callback(p, p_allocator->cookie);\n        return DAV1D_ERR(ENOMEM);\n    }\n\n    plane_ctx->allocator = *p_allocator;\n    plane_ctx->pic = *p;\n\n    pic_ctx->plane_ref[0] = dav1d_ref_wrap(p->data[0], free_plane_buffer, plane_ctx);\n    if (!pic_ctx->plane_ref[0]) {\n        dav1d_ref_dec(&p->ref);\n        p_allocator->release_picture_callback(p, p_allocator->cookie);\n        free(plane_ctx);\n        dav1d_log(c, \"Failed to wrap picture plane: %s\\n\", strerror(errno));\n        return DAV1D_ERR(ENOMEM);\n    }\n\n    const int planes = p->p.layout != DAV1D_PIXEL_LAYOUT_I400 ? 3 : 1;\n    for (int i = 1; i < planes; i++) {\n        pic_ctx->plane_ref[i] = pic_ctx->plane_ref[0];\n        dav1d_ref_inc(pic_ctx->plane_ref[i]);\n    }\n\n    p->seq_hdr_ref = seq_hdr_ref;\n    if (seq_hdr_ref) dav1d_ref_inc(seq_hdr_ref);\n\n    p->frame_hdr_ref = frame_hdr_ref;\n    if (frame_hdr_ref) dav1d_ref_inc(frame_hdr_ref);\n\n    dav1d_picture_copy_props(p, content_light, content_light_ref,\n                             mastering_display, mastering_display_ref,\n                             itut_t35, itut_t35_ref, props);\n\n    if (extra && extra_ptr)\n        *extra_ptr = &pic_ctx->extra_ptr;\n\n    return 0;\n}\nvoid dav1d_picture_copy_props(Dav1dPicture *const p,\n                              Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,\n                              Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,\n                              Dav1dITUTT35 *const itut_t35, Dav1dRef *const itut_t35_ref,\n                              const Dav1dDataProps *const props)\n{\n    dav1d_data_props_copy(&p->m, props);\n\n    dav1d_ref_dec(&p->content_light_ref);\n    p->content_light_ref = content_light_ref;\n    p->content_light = content_light;\n    if (content_light_ref) dav1d_ref_inc(content_light_ref);\n\n    dav1d_ref_dec(&p->mastering_display_ref);\n    p->mastering_display_ref = mastering_display_ref;\n    p->mastering_display = mastering_display;\n    if (mastering_display_ref) dav1d_ref_inc(mastering_display_ref);\n\n    dav1d_ref_dec(&p->itut_t35_ref);\n    p->itut_t35_ref = itut_t35_ref;\n    p->itut_t35 = itut_t35;\n    if (itut_t35_ref) dav1d_ref_inc(itut_t35_ref);\n}\nint dav1d_picture_alloc_copy(Dav1dContext *const c, Dav1dPicture *const dst, const int w,\n                             const Dav1dPicture *const src)\n{\n    struct pic_ctx_context *const pic_ctx = src->ref->user_data;\n    struct plane_ctx_context *const plane_ctx = pic_ctx->plane_ref[0]->user_data;\n    const int res = picture_alloc_with_edges(c, dst, w, src->p.h,\n                                             src->seq_hdr, src->seq_hdr_ref,\n                                             src->frame_hdr, src->frame_hdr_ref,\n                                             src->content_light, src->content_light_ref,\n                                             src->mastering_display, src->mastering_display_ref,\n                                             src->itut_t35, src->itut_t35_ref,\n                                             src->p.bpc, &src->m, &plane_ctx->allocator,\n                                             0, NULL);\n    return res;\n}\nvoid dav1d_picture_copy_props(Dav1dPicture *const p,\n                              Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,\n                              Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,\n                              Dav1dITUTT35 *const itut_t35, Dav1dRef *const itut_t35_ref,\n                              const Dav1dDataProps *const props)\n{\n    dav1d_data_props_copy(&p->m, props);\n\n    dav1d_ref_dec(&p->content_light_ref);\n    p->content_light_ref = content_light_ref;\n    p->content_light = content_light;\n    if (content_light_ref) dav1d_ref_inc(content_light_ref);\n\n    dav1d_ref_dec(&p->mastering_display_ref);\n    p->mastering_display_ref = mastering_display_ref;\n    p->mastering_display = mastering_display;\n    if (mastering_display_ref) dav1d_ref_inc(mastering_display_ref);\n\n    dav1d_ref_dec(&p->itut_t35_ref);\n    p->itut_t35_ref = itut_t35_ref;\n    p->itut_t35 = itut_t35;\n    if (itut_t35_ref) dav1d_ref_inc(itut_t35_ref);\n}\nint dav1d_picture_alloc_copy(Dav1dContext *const c, Dav1dPicture *const dst, const int w,\n                             const Dav1dPicture *const src)\n{\n    struct pic_ctx_context *const pic_ctx = src->ref->user_data;\n    struct plane_ctx_context *const plane_ctx = pic_ctx->plane_ref[0]->user_data;\n    const int res = picture_alloc_with_edges(c, dst, w, src->p.h,\n                                             src->seq_hdr, src->seq_hdr_ref,\n                                             src->frame_hdr, src->frame_hdr_ref,\n                                             src->content_light, src->content_light_ref,\n                                             src->mastering_display, src->mastering_display_ref,\n                                             src->itut_t35, src->itut_t35_ref,\n                                             src->p.bpc, &src->m, &plane_ctx->allocator,\n                                             0, NULL);\n    return res;\n}\nint dav1d_apply_grain(Dav1dContext *const c, Dav1dPicture *const out,\n                      const Dav1dPicture *const in)\n{\n    validate_input_or_ret(c != NULL, DAV1D_ERR(EINVAL));\n    validate_input_or_ret(out != NULL, DAV1D_ERR(EINVAL));\n    validate_input_or_ret(in != NULL, DAV1D_ERR(EINVAL));\n\n    if (!has_grain(in)) {\n        dav1d_picture_ref(out, in);\n        return 0;\n    }\n\n    int res = dav1d_picture_alloc_copy(c, out, in->p.w, in);\n    if (res < 0) goto error;\n\n    if (c->n_tc > 1) {\n        dav1d_task_delayed_fg(c, out, in);\n    } else {\n        switch (out->p.bpc) {\n#if CONFIG_8BPC\n        case 8:\n            dav1d_apply_grain_8bpc(&c->dsp[0].fg, out, in);\n            break;\n#endif\n#if CONFIG_16BPC\n        case 10:\n        case 12:\n            dav1d_apply_grain_16bpc(&c->dsp[(out->p.bpc >> 1) - 4].fg, out, in);\n            break;\n#endif\n        default: abort();\n        }\n    }\n\n    return 0;\n\nerror:\n    dav1d_picture_unref_internal(out);\n    return res;\n}\nstatic int output_image(Dav1dContext *const c, Dav1dPicture *const out)\n{\n    int res = 0;\n\n    Dav1dThreadPicture *const in = (c->all_layers || !c->max_spatial_id)\n                                   ? &c->out : &c->cache;\n    if (!c->apply_grain || !has_grain(&in->p)) {\n        dav1d_picture_move_ref(out, &in->p);\n        dav1d_thread_picture_unref(in);\n        goto end;\n    }\n\n    res = dav1d_apply_grain(c, out, &in->p);\n    dav1d_thread_picture_unref(in);\nend:\n    if (!c->all_layers && c->max_spatial_id && c->out.p.data[0]) {\n        dav1d_thread_picture_move_ref(in, &c->out);\n    }\n    return res;\n}\nstatic int drain_picture(Dav1dContext *const c, Dav1dPicture *const out) {\n    unsigned drain_count = 0;\n    int drained = 0;\n    do {\n        const unsigned next = c->frame_thread.next;\n        Dav1dFrameContext *const f = &c->fc[next];\n        pthread_mutex_lock(&c->task_thread.lock);\n        while (f->n_tile_data > 0)\n            pthread_cond_wait(&f->task_thread.cond,\n                              &f->task_thread.ttd->lock);\n        Dav1dThreadPicture *const out_delayed =\n            &c->frame_thread.out_delayed[next];\n        if (out_delayed->p.data[0] || atomic_load(&f->task_thread.error)) {\n            unsigned first = atomic_load(&c->task_thread.first);\n            if (first + 1U < c->n_fc)\n                atomic_fetch_add(&c->task_thread.first, 1U);\n            else\n                atomic_store(&c->task_thread.first, 0);\n            atomic_compare_exchange_strong(&c->task_thread.reset_task_cur,\n                                           &first, UINT_MAX);\n            if (c->task_thread.cur && c->task_thread.cur < c->n_fc)\n                c->task_thread.cur--;\n            drained = 1;\n        } else if (drained) {\n            pthread_mutex_unlock(&c->task_thread.lock);\n            break;\n        }\n        if (++c->frame_thread.next == c->n_fc)\n            c->frame_thread.next = 0;\n        pthread_mutex_unlock(&c->task_thread.lock);\n        const int error = f->task_thread.retval;\n        if (error) {\n            f->task_thread.retval = 0;\n            dav1d_data_props_copy(&c->cached_error_props, &out_delayed->p.m);\n            dav1d_thread_picture_unref(out_delayed);\n            return error;\n        }\n        if (out_delayed->p.data[0]) {\n            const unsigned progress =\n                atomic_load_explicit(&out_delayed->progress[1],\n                                     memory_order_relaxed);\n            if ((out_delayed->visible || c->output_invisible_frames) &&\n                progress != FRAME_ERROR)\n            {\n                dav1d_thread_picture_ref(&c->out, out_delayed);\n                c->event_flags |= dav1d_picture_get_event_flags(out_delayed);\n            }\n            dav1d_thread_picture_unref(out_delayed);\n            if (output_picture_ready(c, 0))\n                return output_image(c, out);\n        }\n    } while (++drain_count < c->n_fc);\n\n    if (output_picture_ready(c, 1))\n        return output_image(c, out);\n\n    return DAV1D_ERR(EAGAIN);\n}\nint dav1d_get_picture(Dav1dContext *const c, Dav1dPicture *const out)\n{\n    validate_input_or_ret(c != NULL, DAV1D_ERR(EINVAL));\n    validate_input_or_ret(out != NULL, DAV1D_ERR(EINVAL));\n\n    const int drain = c->drain;\n    c->drain = 1;\n\n    int res = gen_picture(c);\n    if (res < 0)\n        return res;\n\n    if (c->cached_error) {\n        const int res = c->cached_error;\n        c->cached_error = 0;\n        return res;\n    }\n\n    if (output_picture_ready(c, c->n_fc == 1))\n        return output_image(c, out);\n\n    if (c->n_fc > 1 && drain)\n        return drain_picture(c, out);\n\n    return DAV1D_ERR(EAGAIN);\n}\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    Dav1dSettings settings = { 0 };\n    Dav1dContext * ctx = NULL;\n    Dav1dPicture pic;\n    const uint8_t *ptr = data;\n    int have_seq_hdr = 0;\n    int err;\n\n    dav1d_version();\n\n    if (size < 32) goto end;\n#ifdef DAV1D_ALLOC_FAIL\n    unsigned h = djb_xor(ptr, 32);\n    unsigned seed = h;\n    unsigned probability = h > (RAND_MAX >> 5) ? RAND_MAX >> 5 : h;\n    int max_frame_delay = (h & 0xf) + 1;\n    int n_threads = ((h >> 4) & 0x7) + 1;\n    if (max_frame_delay > 5) max_frame_delay = 1;\n    if (n_threads > 3) n_threads = 1;\n#endif\n    ptr += 32; // skip ivf header\n\n    dav1d_default_settings(&settings);\n\n#ifdef DAV1D_MT_FUZZING\n    settings.max_frame_delay = settings.n_threads = 4;\n#elif defined(DAV1D_ALLOC_FAIL)\n    settings.max_frame_delay = max_frame_delay;\n    settings.n_threads = n_threads;\n    dav1d_setup_alloc_fail(seed, probability);\n#else\n    settings.max_frame_delay = settings.n_threads = 1;\n#endif\n#if defined(DAV1D_FUZZ_MAX_SIZE)\n    settings.frame_size_limit = DAV1D_FUZZ_MAX_SIZE;\n#endif\n\n    err = dav1d_open(&ctx, &settings);\n    if (err < 0) goto end;\n\n    while (ptr <= data + size - 12) {\n        Dav1dData buf;\n        uint8_t *p;\n\n        size_t frame_size = r32le(ptr);\n        ptr += 12;\n\n        if (frame_size > size || ptr > data + size - frame_size)\n            break;\n\n        if (!frame_size) continue;\n\n        if (!have_seq_hdr) {\n            Dav1dSequenceHeader seq = { 0 };\n            int err = dav1d_parse_sequence_header(&seq, ptr, frame_size);\n            // skip frames until we see a sequence header\n            if  (err != 0) {\n                ptr += frame_size;\n                continue;\n            }\n            have_seq_hdr = 1;\n        }\n\n        // copy frame data to a new buffer to catch reads past the end of input\n        p = dav1d_data_create(&buf, frame_size);\n        if (!p) goto cleanup;\n        memcpy(p, ptr, frame_size);\n        ptr += frame_size;\n\n        do {\n            if ((err = dav1d_send_data(ctx, &buf)) < 0) {\n                if (err != DAV1D_ERR(EAGAIN))\n                    break;\n            }\n            memset(&pic, 0, sizeof(pic));\n            err = dav1d_get_picture(ctx, &pic);\n            if (err == 0) {\n                dav1d_picture_unref(&pic);\n            } else if (err != DAV1D_ERR(EAGAIN)) {\n                break;\n            }\n        } while (buf.sz > 0);\n\n        if (buf.sz > 0)\n            dav1d_data_unref(&buf);\n    }\n\n    memset(&pic, 0, sizeof(pic));\n    if ((err = dav1d_get_picture(ctx, &pic)) == 0) {\n        /* Test calling dav1d_picture_unref() after dav1d_close() */\n        do {\n            Dav1dPicture pic2 = { 0 };\n            if ((err = dav1d_get_picture(ctx, &pic2)) == 0)\n                dav1d_picture_unref(&pic2);\n        } while (err != DAV1D_ERR(EAGAIN));\n\n        dav1d_close(&ctx);\n        dav1d_picture_unref(&pic);\n        return 0;\n    }\n\ncleanup:\n    dav1d_close(&ctx);\nend:\n    return 0;\n}",
    "target": 0,
    "idx": 2057927
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void\nfz_draw_clip_image_mask(fz_context *ctx, fz_device *devp, fz_image *image, fz_matrix in_ctm, fz_rect scissor)\n{\n\tfz_draw_device *dev = (fz_draw_device*)devp;\n\tfz_matrix local_ctm = fz_concat(in_ctm, dev->transform);\n\tfz_irect bbox;\n\tfz_pixmap *scaled = NULL;\n\tfz_pixmap *pixmap = NULL;\n\tint dx, dy;\n\tfz_draw_state *state = push_stack(ctx, dev, \"clip image mask\");\n\tfz_colorspace *model = state->dest->colorspace;\n\tfz_irect clip;\n\tfz_irect src_area;\n\n\tfz_var(pixmap);\n\n\tif (dev->top == 0 && dev->resolve_spots)\n\t\tstate = push_group_for_separations(ctx, dev, fz_default_color_params /* FIXME */, dev->default_cs);\n\n\tclip = fz_pixmap_bbox(ctx, state->dest);\n\tclip = fz_intersect_irect(clip, state->scissor);\n\n\tif (image->w == 0 || image->h == 0)\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (empty) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n\tlocal_ctm = fz_gridfit_matrix(devp->flags & FZ_DEVFLAG_GRIDFIT_AS_TILED, local_ctm);\n\n\tsrc_area = find_src_area_required(local_ctm, image, clip);\n\tif (fz_is_empty_irect(src_area))\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (empty source area) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n\tbbox = fz_irect_from_rect(fz_transform_rect(fz_unit_rect, local_ctm));\n\tbbox = fz_intersect_irect(bbox, state->scissor);\n\tif (!fz_is_infinite_rect(scissor))\n\t{\n\t\tfz_rect tscissor = fz_transform_rect(scissor, dev->transform);\n\t\tbbox = fz_intersect_irect(bbox, fz_irect_from_rect(tscissor));\n\t}\n\tif (!fz_is_valid_irect(bbox))\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (invalid) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\tdump_spaces(dev->top-1, \"Clip (image mask) begin\\n\");\n#endif\n\n\tfz_try(ctx)\n\t{\n\t\tpixmap = fz_get_pixmap_from_image(ctx, image, &src_area, &local_ctm, &dx, &dy);\n\n\t\tstate[1].mask = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\tfz_clear_pixmap(ctx, state[1].mask);\n\n\t\tstate[1].dest = fz_new_pixmap_with_bbox(ctx, model, bbox, state[0].dest->seps, state[0].dest->alpha);\n\t\tfz_copy_pixmap_rect(ctx, state[1].dest, state[0].dest, bbox, dev->default_cs);\n\t\tif (state[0].shape)\n\t\t{\n\t\t\tstate[1].shape = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].shape);\n\t\t}\n\t\tif (state[0].group_alpha)\n\t\t{\n\t\t\tstate[1].group_alpha = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].group_alpha);\n\t\t}\n\n\t\tstate[1].blendmode |= FZ_BLEND_ISOLATED;\n\t\tstate[1].scissor = bbox;\n\n\t\tif (!(devp->hints & FZ_DONT_INTERPOLATE_IMAGES) && ctx->tuning->image_scale(ctx->tuning->image_scale_arg, dx, dy, pixmap->w, pixmap->h))\n\t\t{\n\t\t\tint gridfit = !(dev->flags & FZ_DRAWDEV_FLAGS_TYPE3);\n\t\t\tscaled = fz_transform_pixmap(ctx, dev, pixmap, &local_ctm, state->dest->x, state->dest->y, dx, dy, gridfit, &clip);\n\t\t\tif (!scaled)\n\t\t\t{\n\t\t\t\tif (dx < 1)\n\t\t\t\t\tdx = 1;\n\t\t\t\tif (dy < 1)\n\t\t\t\t\tdy = 1;\n\t\t\t\tscaled = fz_scale_pixmap_cached(ctx, pixmap, pixmap->x, pixmap->y, dx, dy, NULL, dev->cache_x, dev->cache_y);\n\t\t\t}\n\t\t\tif (scaled)\n\t\t\t{\n\t\t\t\tfz_drop_pixmap(ctx, pixmap);\n\t\t\t\tpixmap = scaled;\n\t\t\t}\n\t\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top, \"\");\n\t\tfz_dump_blend(ctx, \"Creating imagemask: plotting \", pixmap);\n\t\tfz_dump_blend(ctx, \" onto \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n#endif\n\n\t\tfz_paint_image(ctx, state[1].mask, &bbox, state[1].shape, state[1].group_alpha, pixmap, local_ctm, 255, !(devp->hints & FZ_DONT_INTERPOLATE_IMAGES), 0);\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tfz_dump_blend(ctx, \" to get \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_pixmap(ctx, pixmap);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}\nvoid\nfz_clip_image_mask(fz_context *ctx, fz_device *dev, fz_image *image, fz_matrix ctm, fz_rect scissor)\n{\n\tfz_rect bbox = fz_transform_rect(fz_unit_rect, ctm);\n\tbbox = fz_intersect_rect(bbox, scissor);\n\tpush_clip_stack(ctx, dev, bbox, fz_device_container_stack_is_clip);\n\n\tif (dev->clip_image_mask)\n\t{\n\t\tfz_try(ctx)\n\t\t\tdev->clip_image_mask(ctx, dev, image, ctm, scissor);\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tfz_disable_device(ctx, dev);\n\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}\nstatic void\npdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tfz_matrix image_ctm;\n\tfz_rect bbox;\n\n\tif (pr->super.hidden)\n\t\treturn;\n\n\t/* PDF has images bottom-up, so flip them right side up here */\n\timage_ctm = fz_pre_scale(fz_pre_translate(gstate->ctm, 0, 1), 1, -1);\n\n\tbbox = fz_transform_rect(fz_unit_rect, image_ctm);\n\n\tif (image->mask && gstate->blendmode)\n\t{\n\t\t/* apply blend group even though we skip the soft mask */\n\t\tfz_begin_group(ctx, pr->dev, bbox, NULL, 0, 0, gstate->blendmode, 1);\n\t\tfz_clip_image_mask(ctx, pr->dev, image->mask, image_ctm, bbox);\n\t\tpdf_show_image_imp(ctx, pr, image, image_ctm, bbox);\n\t\tfz_pop_clip(ctx, pr->dev);\n\t\tfz_end_group(ctx, pr->dev);\n\t}\n\telse if (image->mask)\n\t{\n\t\tfz_clip_image_mask(ctx, pr->dev, image->mask, image_ctm, bbox);\n\t\tpdf_show_image_imp(ctx, pr, image, image_ctm, bbox);\n\t\tfz_pop_clip(ctx, pr->dev);\n\t}\n\telse\n\t{\n\t\tsoftmask_save softmask = { NULL };\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tgstate = pdf_begin_group(ctx, pr, bbox, &softmask);\n\t\t\tpdf_show_image_imp(ctx, pr, image, image_ctm, bbox);\n\t\t\tpdf_end_group(ctx, pr, &softmask);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tpdf_drop_obj(ctx, softmask.softmask);\n\t\t\tpdf_drop_obj(ctx, softmask.page_resources);\n\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}\nstatic void pdf_run_Do_image(fz_context *ctx, pdf_processor *proc, const char *name, fz_image *image)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_image(ctx, pr, image);\n}\nstatic void\npdf_process_Do(fz_context *ctx, pdf_processor *proc, pdf_csi *csi)\n{\n\tpdf_obj *xres, *xobj, *subtype;\n\n\txres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(XObject));\n\txobj = pdf_dict_gets(ctx, xres, csi->name);\n\tif (!xobj)\n\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find XObject resource '%s'\", csi->name);\n\tsubtype = pdf_dict_get(ctx, xobj, PDF_NAME(Subtype));\n\tif (pdf_name_eq(ctx, subtype, PDF_NAME(Form)))\n\t{\n\t\tpdf_obj *st = pdf_dict_get(ctx, xobj, PDF_NAME(Subtype2));\n\t\tif (st)\n\t\t\tsubtype = st;\n\t}\n\tif (!pdf_is_name(ctx, subtype))\n\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"no XObject subtype specified\");\n\n\tif (pdf_is_ocg_hidden(ctx, csi->doc, csi->rdb, proc->usage, pdf_dict_get(ctx, xobj, PDF_NAME(OC))))\n\t\treturn;\n\n\tif (pdf_name_eq(ctx, subtype, PDF_NAME(Form)))\n\t{\n\t\tif (proc->op_Do_form)\n\t\t\tproc->op_Do_form(ctx, proc, csi->name, xobj, csi->rdb);\n\t}\n\n\telse if (pdf_name_eq(ctx, subtype, PDF_NAME(Image)))\n\t{\n\t\tif (proc->op_Do_image)\n\t\t{\n\t\t\tfz_image *image = pdf_load_image(ctx, csi->doc, xobj);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_Do_image(ctx, proc, csi->name, image);\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_image(ctx, image);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n\n\telse if (!strcmp(pdf_to_name(ctx, subtype), \"PS\"))\n\t\tfz_warn(ctx, \"ignoring XObject with subtype PS\");\n\telse\n\t\tfz_warn(ctx, \"ignoring XObject with unknown subtype: '%s'\", pdf_to_name(ctx, subtype));\n}\nstatic void\npdf_process_keyword(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm, char *word)\n{\n\tfloat *s = csi->stack;\n\tchar csname[40];\n\tint key;\n\n\tkey = word[0];\n\tif (word[1])\n\t{\n\t\tkey |= word[1] << 8;\n\t\tif (word[2])\n\t\t{\n\t\t\tkey |= word[2] << 16;\n\t\t\tif (word[3])\n\t\t\t\tkey = 0;\n\t\t}\n\t}\n\n\tswitch (key)\n\t{\n\tdefault:\n\t\tif (!csi->xbalance)\n\t\t{\n\t\t\tif (is_known_bad_word(word))\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"unknown keyword: '%s'\", word);\n\t\t\telse\n\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"unknown keyword: '%s'\", word);\n\t\t}\n\t\tbreak;\n\n\t/* general graphics state */\n\tcase A('w'): if (proc->op_w) proc->op_w(ctx, proc, s[0]); break;\n\tcase A('j'): if (proc->op_j) proc->op_j(ctx, proc, fz_clampi(s[0], 0, 2)); break;\n\tcase A('J'): if (proc->op_J) proc->op_J(ctx, proc, fz_clampi(s[0], 0, 2)); break;\n\tcase A('M'): if (proc->op_M) proc->op_M(ctx, proc, s[0]); break;\n\tcase A('d'): if (proc->op_d) proc->op_d(ctx, proc, csi->obj, s[0]); break;\n\tcase B('r','i'): if (proc->op_ri) proc->op_ri(ctx, proc, csi->name); break;\n\tcase A('i'): if (proc->op_i) proc->op_i(ctx, proc, s[0]); break;\n\n\tcase B('g','s'):\n\t\t{\n\t\t\tpdf_obj *gsres, *gsobj;\n\t\t\tgsres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(ExtGState));\n\t\t\tgsobj = pdf_dict_gets(ctx, gsres, csi->name);\n\t\t\tif (!gsobj)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find ExtGState resource '%s'\", csi->name);\n\t\t\tif (proc->op_gs_begin)\n\t\t\t\tproc->op_gs_begin(ctx, proc, csi->name, gsobj);\n\t\t\tpdf_process_extgstate(ctx, proc, csi, gsobj);\n\t\t\tif (proc->op_gs_end)\n\t\t\t\tproc->op_gs_end(ctx, proc);\n\t\t}\n\t\tbreak;\n\n\t/* special graphics state */\n\tcase A('q'): pdf_process_gsave(ctx, proc, csi); break;\n\tcase A('Q'): pdf_process_grestore(ctx, proc, csi); break;\n\tcase B('c','m'): if (proc->op_cm) proc->op_cm(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\n\t/* path construction */\n\tcase A('m'): if (proc->op_m) proc->op_m(ctx, proc, s[0], s[1]); break;\n\tcase A('l'): if (proc->op_l) proc->op_l(ctx, proc, s[0], s[1]); break;\n\tcase A('c'): if (proc->op_c) proc->op_c(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\tcase A('v'): if (proc->op_v) proc->op_v(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('y'): if (proc->op_y) proc->op_y(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('h'): if (proc->op_h) proc->op_h(ctx, proc); break;\n\tcase B('r','e'): if (proc->op_re) proc->op_re(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\n\t/* path painting */\n\tcase A('S'): if (proc->op_S) proc->op_S(ctx, proc); break;\n\tcase A('s'): if (proc->op_s) proc->op_s(ctx, proc); break;\n\tcase A('F'): if (proc->op_F) proc->op_F(ctx, proc); break;\n\tcase A('f'): if (proc->op_f) proc->op_f(ctx, proc); break;\n\tcase B('f','*'): if (proc->op_fstar) proc->op_fstar(ctx, proc); break;\n\tcase A('B'): if (proc->op_B) proc->op_B(ctx, proc); break;\n\tcase B('B','*'): if (proc->op_Bstar) proc->op_Bstar(ctx, proc); break;\n\tcase A('b'): if (proc->op_b) proc->op_b(ctx, proc); break;\n\tcase B('b','*'): if (proc->op_bstar) proc->op_bstar(ctx, proc); break;\n\tcase A('n'): if (proc->op_n) proc->op_n(ctx, proc); break;\n\n\t/* path clipping */\n\tcase A('W'): if (proc->op_W) proc->op_W(ctx, proc); break;\n\tcase B('W','*'): if (proc->op_Wstar) proc->op_Wstar(ctx, proc); break;\n\n\t/* text objects */\n\tcase B('B','T'): csi->in_text = 1; if (proc->op_BT) proc->op_BT(ctx, proc); break;\n\tcase B('E','T'): csi->in_text = 0; if (proc->op_ET) proc->op_ET(ctx, proc); break;\n\n\t/* text state */\n\tcase B('T','c'): if (proc->op_Tc) proc->op_Tc(ctx, proc, s[0]); break;\n\tcase B('T','w'): if (proc->op_Tw) proc->op_Tw(ctx, proc, s[0]); break;\n\tcase B('T','z'): if (proc->op_Tz) proc->op_Tz(ctx, proc, s[0]); break;\n\tcase B('T','L'): if (proc->op_TL) proc->op_TL(ctx, proc, s[0]); break;\n\tcase B('T','r'): if (proc->op_Tr) proc->op_Tr(ctx, proc, s[0]); break;\n\tcase B('T','s'): if (proc->op_Ts) proc->op_Ts(ctx, proc, s[0]); break;\n\n\tcase B('T','f'):\n\t\tif (proc->op_Tf)\n\t\t{\n\t\t\tpdf_obj *fontres, *fontobj;\n\t\t\tpdf_font_desc *font;\n\t\t\tfontres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(Font));\n\t\t\tfontobj = pdf_dict_gets(ctx, fontres, csi->name);\n\t\t\tif (pdf_is_dict(ctx, fontobj))\n\t\t\t\tfont = pdf_try_load_font(ctx, csi->doc, csi->rdb, fontobj, csi->cookie);\n\t\t\telse\n\t\t\t\tfont = pdf_load_hail_mary_font(ctx, csi->doc);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_Tf(ctx, proc, csi->name, font, s[0]);\n\t\t\tfz_always(ctx)\n\t\t\t\tpdf_drop_font(ctx, font);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\t/* text positioning */\n\tcase B('T','d'): if (proc->op_Td) proc->op_Td(ctx, proc, s[0], s[1]); break;\n\tcase B('T','D'): if (proc->op_TD) proc->op_TD(ctx, proc, s[0], s[1]); break;\n\tcase B('T','m'): if (proc->op_Tm) proc->op_Tm(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\tcase B('T','*'): if (proc->op_Tstar) proc->op_Tstar(ctx, proc); break;\n\n\t/* text showing */\n\tcase B('T','J'): if (proc->op_TJ) proc->op_TJ(ctx, proc, csi->obj); break;\n\tcase B('T','j'):\n\t\tif (proc->op_Tj)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_Tj(ctx, proc, csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_Tj(ctx, proc, pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\tcase A('\\''):\n\t\tif (proc->op_squote)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_squote(ctx, proc, csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_squote(ctx, proc, pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\tcase A('\"'):\n\t\tif (proc->op_dquote)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_dquote(ctx, proc, s[0], s[1], csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_dquote(ctx, proc, s[0], s[1], pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\n\t/* type 3 fonts */\n\tcase B('d','0'): if (proc->op_d0) proc->op_d0(ctx, proc, s[0], s[1]); break;\n\tcase B('d','1'): if (proc->op_d1) proc->op_d1(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\n\t/* color */\n\tcase B('C','S'): pdf_process_CS(ctx, proc, csi, 1); break;\n\tcase B('c','s'): pdf_process_CS(ctx, proc, csi, 0); break;\n\tcase B('S','C'): pdf_process_SC(ctx, proc, csi, 1); break;\n\tcase B('s','c'): pdf_process_SC(ctx, proc, csi, 0); break;\n\tcase C('S','C','N'): pdf_process_SC(ctx, proc, csi, 1); break;\n\tcase C('s','c','n'): pdf_process_SC(ctx, proc, csi, 0); break;\n\n\tcase A('G'): if (proc->op_G) proc->op_G(ctx, proc, s[0]); break;\n\tcase A('g'): if (proc->op_g) proc->op_g(ctx, proc, s[0]); break;\n\tcase B('R','G'): if (proc->op_RG) proc->op_RG(ctx, proc, s[0], s[1], s[2]); break;\n\tcase B('r','g'): if (proc->op_rg) proc->op_rg(ctx, proc, s[0], s[1], s[2]); break;\n\tcase A('K'): if (proc->op_K) proc->op_K(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('k'): if (proc->op_k) proc->op_k(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\n\t/* shadings, images, xobjects */\n\tcase B('B','I'):\n\t\t{\n\t\t\tfz_image *img = parse_inline_image(ctx, csi, stm, csname, sizeof csname);\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tif (proc->op_BI)\n\t\t\t\t\tproc->op_BI(ctx, proc, img, csname[0] ? csname : NULL);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_image(ctx, img);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\tcase B('s','h'):\n\t\tif (proc->op_sh)\n\t\t{\n\t\t\tpdf_obj *shaderes, *shadeobj;\n\t\t\tfz_shade *shade;\n\t\t\tshaderes = pdf_dict_get(ctx, csi->rdb, PDF_NAME(Shading));\n\t\t\tshadeobj = pdf_dict_gets(ctx, shaderes, csi->name);\n\t\t\tif (!shadeobj)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find Shading resource '%s'\", csi->name);\n\t\t\tshade = pdf_load_shading(ctx, csi->doc, shadeobj);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_sh(ctx, proc, csi->name, shade);\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_shade(ctx, shade);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\tcase B('D','o'): pdf_process_Do(ctx, proc, csi); break;\n\n\t/* marked content */\n\tcase B('M','P'): if (proc->op_MP) proc->op_MP(ctx, proc, csi->name); break;\n\tcase B('D','P'): if (proc->op_DP) proc->op_DP(ctx, proc, csi->name, csi->obj, resolve_properties(ctx, csi, csi->obj)); break;\n\tcase C('B','M','C'): pdf_process_BMC(ctx, proc, csi, csi->name); break;\n\tcase C('B','D','C'): pdf_process_BDC(ctx, proc, csi); break;\n\tcase C('E','M','C'): pdf_process_EMC(ctx, proc, csi); break;\n\n\t/* compatibility */\n\tcase B('B','X'): ++csi->xbalance; if (proc->op_BX) proc->op_BX(ctx, proc); break;\n\tcase B('E','X'): --csi->xbalance; if (proc->op_EX) proc->op_EX(ctx, proc); break;\n\t}\n}\nstatic void\npdf_process_stream(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm)\n{\n\tpdf_document *doc = csi->doc;\n\tpdf_lexbuf *buf = csi->buf;\n\tfz_cookie *cookie = csi->cookie;\n\n\tpdf_token tok = PDF_TOK_ERROR;\n\tint in_text_array = 0;\n\tint syntax_errors = 0;\n\n\t/* make sure we have a clean slate if we come here from flush_text */\n\tpdf_clear_stack(ctx, csi);\n\n\tfz_var(in_text_array);\n\tfz_var(tok);\n\n\tif (cookie)\n\t{\n\t\tcookie->progress_max = -1;\n\t\tcookie->progress = 0;\n\t}\n\n\tdo\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\t/* Check the cookie */\n\t\t\t\tif (cookie)\n\t\t\t\t{\n\t\t\t\t\tif (cookie->abort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcookie->progress++;\n\t\t\t\t}\n\n\t\t\t\ttok = pdf_lex(ctx, stm, buf);\n\n\t\t\t\tif (in_text_array)\n\t\t\t\t{\n\t\t\t\t\tswitch(tok)\n\t\t\t\t\t{\n\t\t\t\t\tcase PDF_TOK_CLOSE_ARRAY:\n\t\t\t\t\t\tin_text_array = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\t\tpdf_array_push_real(ctx, csi->obj, buf->f);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\t\tpdf_array_push_int(ctx, csi->obj, buf->i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\t\tpdf_array_push_string(ctx, csi->obj, buf->scratch, buf->len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\t\tif (buf->scratch[0] == 'T' && (buf->scratch[1] == 'w' || buf->scratch[1] == 'c') && buf->scratch[2] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint n = pdf_array_len(ctx, csi->obj);\n\t\t\t\t\t\t\tif (n > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpdf_obj *o = pdf_array_get(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\tif (pdf_is_number(ctx, o))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcsi->stack[0] = pdf_to_real(ctx, o);\n\t\t\t\t\t\t\t\t\tpdf_array_delete(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Deliberate Fallthrough! */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in array\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse switch (tok)\n\t\t\t\t{\n\t\t\t\tcase PDF_TOK_ENDSTREAM:\n\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_ARRAY:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (csi->in_text)\n\t\t\t\t\t{\n\t\t\t\t\t\tin_text_array = 1;\n\t\t\t\t\t\tcsi->obj = pdf_new_array(ctx, doc, 4);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcsi->obj = pdf_parse_array(ctx, doc, stm, buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_DICT:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tcsi->obj = pdf_parse_dict(ctx, doc, stm, buf);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_NAME:\n\t\t\t\t\tif (csi->name[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\tcsi->obj = pdf_new_name(ctx, buf->scratch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_strlcpy(csi->name, buf->scratch, sizeof(csi->name));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->i;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->f;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\tif (buf->len <= sizeof(csi->string))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(csi->string, buf->scratch, buf->len);\n\t\t\t\t\t\tcsi->string_len = buf->len;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsi->obj = pdf_new_string(ctx, buf->scratch, buf->len);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\tpdf_clear_stack(ctx, csi);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in content stream\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (tok != PDF_TOK_EOF);\n\t\t}\n\t\tfz_always(ctx)\n\t\t{\n\t\t\tpdf_clear_stack(ctx, csi);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tint caught = fz_caught(ctx);\n\t\t\tif (cookie)\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t{\n\t\t\t\t\tcookie->incomplete++;\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t\t/* ignore minor errors */ ;\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* If we do catch an error, then reset ourselves to a base lexing state */\n\t\t\tin_text_array = 0;\n\t\t}\n\t}\n\twhile (tok != PDF_TOK_EOF);\n}\nvoid\npdf_process_contents(fz_context *ctx, pdf_processor *proc, pdf_document *doc, pdf_obj *rdb, pdf_obj *stmobj, fz_cookie *cookie)\n{\n\tpdf_csi csi;\n\tpdf_lexbuf buf;\n\tfz_stream *stm = NULL;\n\n\tif (!stmobj)\n\t\treturn;\n\n\tfz_var(stm);\n\n\tpdf_lexbuf_init(ctx, &buf, PDF_LEXBUF_SMALL);\n\tpdf_init_csi(ctx, &csi, doc, rdb, &buf, cookie);\n\n\tfz_try(ctx)\n\t{\n\t\tfz_defer_reap_start(ctx);\n\t\tstm = pdf_open_contents_stream(ctx, doc, stmobj);\n\t\tpdf_process_stream(ctx, proc, &csi, stm);\n\t\tpdf_process_end(ctx, proc, &csi);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_defer_reap_end(ctx);\n\t\tfz_drop_stream(ctx, stm);\n\t\tpdf_clear_stack(ctx, &csi);\n\t\tpdf_lexbuf_fin(ctx, &buf);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tproc->close_processor = NULL; /* aborted run, don't warn about unclosed processor */\n\t\tfz_rethrow(ctx);\n\t}\n}\nstatic void\npdf_run_page_contents_with_usage_imp(fz_context *ctx, pdf_document *doc, pdf_page *page, fz_device *dev, fz_matrix ctm, const char *usage, fz_cookie *cookie)\n{\n\tfz_matrix page_ctm;\n\tpdf_obj *resources;\n\tpdf_obj *contents;\n\tfz_rect mediabox;\n\tpdf_processor *proc = NULL;\n\tfz_default_colorspaces *default_cs = NULL;\n\tfz_colorspace *colorspace = NULL;\n\n\tfz_var(proc);\n\tfz_var(colorspace);\n\tfz_var(default_cs);\n\n\tif (cookie && page->super.incomplete)\n\t\tcookie->incomplete = 1;\n\n\tfz_try(ctx)\n\t{\n\t\tdefault_cs = pdf_load_default_colorspaces(ctx, doc, page);\n\t\tif (default_cs)\n\t\t\tfz_set_default_colorspaces(ctx, dev, default_cs);\n\n\t\tpdf_page_transform(ctx, page, &mediabox, &page_ctm);\n\t\tctm = fz_concat(page_ctm, ctm);\n\t\tmediabox = fz_transform_rect(mediabox, ctm);\n\n\t\tresources = pdf_page_resources(ctx, page);\n\t\tcontents = pdf_page_contents(ctx, page);\n\n\t\tif (page->transparency)\n\t\t{\n\t\t\tpdf_obj *group = pdf_page_group(ctx, page);\n\n\t\t\tif (group)\n\t\t\t{\n\t\t\t\tpdf_obj *cs = pdf_dict_get(ctx, group, PDF_NAME(CS));\n\t\t\t\tif (cs)\n\t\t\t\t{\n\t\t\t\t\tfz_try(ctx)\n\t\t\t\t\t\tcolorspace = pdf_load_colorspace(ctx, cs);\n\t\t\t\t\tfz_catch(ctx)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t\t\t\t\tfz_warn(ctx, \"Ignoring Page blending colorspace.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fz_is_valid_blend_colorspace(ctx, colorspace))\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"Ignoring invalid Page blending colorspace: %s.\", colorspace->name);\n\t\t\t\t\t\tfz_drop_colorspace(ctx, colorspace);\n\t\t\t\t\t\tcolorspace = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_default_output_intent(ctx, default_cs));\n\n\t\t\tfz_begin_group(ctx, dev, mediabox, colorspace, 1, 0, 0, 1);\n\t\t}\n\n\t\tproc = pdf_new_run_processor(ctx, dev, ctm, usage, NULL, default_cs, cookie);\n\t\tpdf_process_contents(ctx, proc, doc, resources, contents, cookie);\n\t\tpdf_close_processor(ctx, proc);\n\n\t\tif (page->transparency)\n\t\t{\n\t\t\tfz_end_group(ctx, dev);\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tpdf_drop_processor(ctx, proc);\n\t\tfz_drop_colorspace(ctx, colorspace);\n\t\tfz_drop_default_colorspaces(ctx, default_cs);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}\nvoid pdf_run_page_contents_with_usage(fz_context *ctx, pdf_page *page, fz_device *dev, fz_matrix ctm, const char *usage, fz_cookie *cookie)\n{\n\tpdf_document *doc = page->doc;\n\tint nocache;\n\n\tnocache = !!(dev->hints & FZ_NO_CACHE);\n\tif (nocache)\n\t\tpdf_mark_xref(ctx, doc);\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_run_page_contents_with_usage_imp(ctx, doc, page, dev, ctm, usage, cookie);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tif (nocache)\n\t\t\tpdf_clear_xref_to_mark(ctx, doc);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}\nvoid pdf_run_page_contents(fz_context *ctx, pdf_page *page, fz_device *dev, fz_matrix ctm, fz_cookie *cookie)\n{\n\tpdf_run_page_contents_with_usage(ctx, page, dev, ctm, \"View\", cookie);\n}\nvoid\nfz_run_page_contents(fz_context *ctx, fz_page *page, fz_device *dev, fz_matrix transform, fz_cookie *cookie)\n{\n\tif (page && page->run_page_contents)\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tpage->run_page_contents(ctx, page, dev, transform, cookie);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tdev->close_device = NULL; /* aborted run, don't warn about unclosed device */\n\t\t\tif (fz_caught(ctx) != FZ_ERROR_ABORT)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}\nvoid\nfz_run_page(fz_context *ctx, fz_page *page, fz_device *dev, fz_matrix transform, fz_cookie *cookie)\n{\n\tfz_run_page_contents(ctx, page, dev, transform, cookie);\n\tfz_run_page_annots(ctx, page, dev, transform, cookie);\n\tfz_run_page_widgets(ctx, page, dev, transform, cookie);\n}\nfz_pixmap *\nfz_new_pixmap_from_page_with_separations(fz_context *ctx, fz_page *page, fz_matrix ctm, fz_colorspace *cs, fz_separations *seps, int alpha)\n{\n\tfz_rect rect;\n\tfz_irect bbox;\n\tfz_pixmap *pix;\n\tfz_device *dev = NULL;\n\n\tfz_var(dev);\n\n\trect = fz_bound_page(ctx, page);\n\trect = fz_transform_rect(rect, ctm);\n\tbbox = fz_round_rect(rect);\n\n\tpix = fz_new_pixmap_with_bbox(ctx, cs, bbox, seps, alpha);\n\n\tfz_try(ctx)\n\t{\n\t\tif (alpha)\n\t\t\tfz_clear_pixmap(ctx, pix);\n\t\telse\n\t\t\tfz_clear_pixmap_with_value(ctx, pix, 0xFF);\n\n\t\tdev = fz_new_draw_device(ctx, ctm, pix);\n\t\tfz_run_page(ctx, page, dev, fz_identity, NULL);\n\t\tfz_close_device(ctx, dev);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_device(ctx, dev);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_drop_pixmap(ctx, pix);\n\t\tfz_rethrow(ctx);\n\t}\n\n\treturn pix;\n}\nfz_pixmap *\nfz_new_pixmap_from_page_number_with_separations(fz_context *ctx, fz_document *doc, int number, fz_matrix ctm, fz_colorspace *cs, fz_separations *seps, int alpha)\n{\n\tfz_page *page;\n\tfz_pixmap *pix = NULL;\n\n\tpage = fz_load_page(ctx, doc, number);\n\tfz_try(ctx)\n\t\tpix = fz_new_pixmap_from_page_with_separations(ctx, page, ctm, cs, seps, alpha);\n\tfz_always(ctx)\n\t\tfz_drop_page(ctx, page);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n\treturn pix;\n}\nfz_pixmap *\nfz_new_pixmap_from_page_number(fz_context *ctx, fz_document *doc, int number, fz_matrix ctm, fz_colorspace *cs, int alpha)\n{\n\treturn fz_new_pixmap_from_page_number_with_separations(ctx, doc, number, ctm, cs, NULL, alpha);\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n  fz_context *ctx;\n  fz_stream *stream;\n  fz_document *doc;\n  fz_pixmap *pix;\n\n  used = 0;\n\n  ctx = fz_new_context(&fz_alloc_ossfuzz, nullptr, FZ_STORE_DEFAULT);\n  stream = NULL;\n  doc = NULL;\n  pix = NULL;\n\n  fz_var(stream);\n  fz_var(doc);\n  fz_var(pix);\n\n  fz_try(ctx) {\n    fz_register_document_handlers(ctx);\n    stream = fz_open_memory(ctx, data, size);\n    doc = fz_open_document_with_stream(ctx, \"pdf\", stream);\n\n    for (int i = 0; i < fz_count_pages(ctx, doc); i++) {\n      pix = fz_new_pixmap_from_page_number(ctx, doc, i, fz_identity, fz_device_rgb(ctx), 0);\n      fz_drop_pixmap(ctx, pix);\n      pix = NULL;\n    }\n  }\n  fz_always(ctx) {\n    fz_drop_pixmap(ctx, pix);\n    fz_drop_document(ctx, doc);\n    fz_drop_stream(ctx, stream);\n  }\n  fz_catch(ctx) {\n  }\n\n  fz_drop_context(ctx);\n\n  return 0;\n}",
    "target": 0,
    "idx": 2036519
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nhtmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n    const unsigned char *cur;\n    unsigned char c;\n    unsigned int val;\n\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(0);\n\n    if (ctxt->token != 0) {\n\t*len = 0;\n\treturn(ctxt->token);\n    }\n\n    if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK) {\n        xmlParserGrow(ctxt);\n        if (ctxt->instate == XML_PARSER_EOF)\n            return(0);\n    }\n\n    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) {\n        xmlChar * guess;\n        xmlCharEncodingHandlerPtr handler;\n\n        /*\n         * Assume it's a fixed length encoding (1) with\n         * a compatible encoding for the ASCII set, since\n         * HTML constructs only use < 128 chars\n         */\n        if (*ctxt->input->cur < 0x80) {\n            *len = 1;\n            if ((*ctxt->input->cur == 0) &&\n                (ctxt->input->cur < ctxt->input->end)) {\n                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                                \"Char 0x%X out of allowed range\\n\", 0);\n                return(' ');\n            }\n            return(*ctxt->input->cur);\n        }\n\n        /*\n         * Humm this is bad, do an automatic flow conversion\n         */\n        guess = htmlFindEncoding(ctxt);\n        if (guess == NULL) {\n            xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n        } else {\n            handler = xmlFindCharEncodingHandler((const char *) guess);\n            if (handler != NULL) {\n                /*\n                 * Don't use UTF-8 encoder which isn't required and\n                 * can produce invalid UTF-8.\n                 */\n                if (!xmlStrEqual(BAD_CAST handler->name, BAD_CAST \"UTF-8\"))\n                    xmlSwitchToEncoding(ctxt, handler);\n            } else {\n                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n                             \"Unsupported encoding %s\", guess, NULL);\n            }\n            xmlFree(guess);\n        }\n        ctxt->input->flags |= XML_INPUT_HAS_ENCODING;\n    }\n\n    /*\n     * We are supposed to handle UTF8, check it's valid\n     * From rfc2044: encoding of the Unicode values on UTF-8:\n     *\n     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n     * 0000 0000-0000 007F   0xxxxxxx\n     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n     *\n     * Check for the 0x110000 limit too\n     */\n    cur = ctxt->input->cur;\n    c = *cur;\n    if (c & 0x80) {\n        size_t avail;\n\n        if ((c & 0x40) == 0)\n            goto encoding_error;\n\n        avail = ctxt->input->end - ctxt->input->cur;\n\n        if ((avail < 2) || ((cur[1] & 0xc0) != 0x80))\n            goto encoding_error;\n        if ((c & 0xe0) == 0xe0) {\n            if ((avail < 3) || ((cur[2] & 0xc0) != 0x80))\n                goto encoding_error;\n            if ((c & 0xf0) == 0xf0) {\n                if (((c & 0xf8) != 0xf0) ||\n                    (avail < 4) || ((cur[3] & 0xc0) != 0x80))\n                    goto encoding_error;\n                /* 4-byte code */\n                *len = 4;\n                val = (cur[0] & 0x7) << 18;\n                val |= (cur[1] & 0x3f) << 12;\n                val |= (cur[2] & 0x3f) << 6;\n                val |= cur[3] & 0x3f;\n                if (val < 0x10000)\n                    goto encoding_error;\n            } else {\n              /* 3-byte code */\n                *len = 3;\n                val = (cur[0] & 0xf) << 12;\n                val |= (cur[1] & 0x3f) << 6;\n                val |= cur[2] & 0x3f;\n                if (val < 0x800)\n                    goto encoding_error;\n            }\n        } else {\n          /* 2-byte code */\n            *len = 2;\n            val = (cur[0] & 0x1f) << 6;\n            val |= cur[1] & 0x3f;\n            if (val < 0x80)\n                goto encoding_error;\n        }\n        if (!IS_CHAR(val)) {\n            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                            \"Char 0x%X out of allowed range\\n\", val);\n        }\n        return(val);\n    } else {\n        if ((*ctxt->input->cur == 0) &&\n            (ctxt->input->cur < ctxt->input->end)) {\n            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                            \"Char 0x%X out of allowed range\\n\", 0);\n            *len = 1;\n            return(' ');\n        }\n        /* 1-byte code */\n        *len = 1;\n        return(*ctxt->input->cur);\n    }\n\nencoding_error:\n    {\n        char buffer[150];\n\n\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n\t    snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n\t} else {\n\t    snprintf(buffer, 149, \"Bytes: 0x%02X\\n\", ctxt->input->cur[0]);\n\t}\n\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n\t\t     \"Input is not proper UTF-8, indicate encoding !\\n\",\n\t\t     BAD_CAST buffer, NULL);\n    }\n\n    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0)\n        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n    *len = 1;\n    return(*ctxt->input->cur);\n}\nvoid\n__xmlRaiseError(xmlStructuredErrorFunc schannel,\n              xmlGenericErrorFunc channel, void *data, void *ctx,\n              void *nod, int domain, int code, xmlErrorLevel level,\n              const char *file, int line, const char *str1,\n              const char *str2, const char *str3, int int1, int col,\n\t      const char *msg, ...)\n{\n    xmlParserCtxtPtr ctxt = NULL;\n    xmlNodePtr node = (xmlNodePtr) nod;\n    char *str = NULL;\n    xmlParserInputPtr input = NULL;\n    xmlErrorPtr to = &xmlLastError;\n    xmlNodePtr baseptr = NULL;\n\n    if (code == XML_ERR_OK)\n        return;\n    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))\n        return;\n    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||\n        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||\n\t(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n\tctxt = (xmlParserCtxtPtr) ctx;\n\n        if (ctxt != NULL) {\n            if (level == XML_ERR_WARNING) {\n                if (ctxt->nbWarnings >= XML_MAX_ERRORS)\n                    return;\n                ctxt->nbWarnings += 1;\n            } else {\n                if (ctxt->nbErrors >= XML_MAX_ERRORS)\n                    return;\n                ctxt->nbErrors += 1;\n            }\n\n            if ((schannel == NULL) && (ctxt->sax != NULL) &&\n                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&\n                (ctxt->sax->serror != NULL)) {\n                schannel = ctxt->sax->serror;\n                data = ctxt->userData;\n            }\n        }\n    }\n    /*\n     * Check if structured error handler set\n     */\n    if (schannel == NULL) {\n\tschannel = xmlStructuredError;\n\t/*\n\t * if user has defined handler, change data ptr to user's choice\n\t */\n\tif (schannel != NULL)\n\t    data = xmlStructuredErrorContext;\n    }\n    /*\n     * Formatting the message\n     */\n    if (msg == NULL) {\n        str = (char *) xmlStrdup(BAD_CAST \"No error message provided\");\n    } else {\n        XML_GET_VAR_STR(msg, str);\n    }\n\n    /*\n     * specific processing if a parser context is provided\n     */\n    if (ctxt != NULL) {\n        if (file == NULL) {\n            input = ctxt->input;\n            if ((input != NULL) && (input->filename == NULL) &&\n                (ctxt->inputNr > 1)) {\n                input = ctxt->inputTab[ctxt->inputNr - 2];\n            }\n            if (input != NULL) {\n                file = input->filename;\n                line = input->line;\n                col = input->col;\n            }\n        }\n        to = &ctxt->lastError;\n    } else if ((node != NULL) && (file == NULL)) {\n\tint i;\n\n\tif ((node->doc != NULL) && (node->doc->URL != NULL)) {\n\t    baseptr = node;\n/*\t    file = (const char *) node->doc->URL; */\n\t}\n\tfor (i = 0;\n\t     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));\n\t     i++)\n\t     node = node->parent;\n        if ((baseptr == NULL) && (node != NULL) &&\n\t    (node->doc != NULL) && (node->doc->URL != NULL))\n\t    baseptr = node;\n\n\tif ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n\t    line = node->line;\n\tif ((line == 0) || (line == 65535))\n\t    line = xmlGetLineNo(node);\n    }\n\n    /*\n     * Save the information about the error\n     */\n    xmlResetError(to);\n    to->domain = domain;\n    to->code = code;\n    to->message = str;\n    to->level = level;\n    if (file != NULL)\n        to->file = (char *) xmlStrdup((const xmlChar *) file);\n    else if (baseptr != NULL) {\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t/*\n\t * We check if the error is within an XInclude section and,\n\t * if so, attempt to print out the href of the XInclude instead\n\t * of the usual \"base\" (doc->URL) for the node (bug 152623).\n\t */\n        xmlNodePtr prev = baseptr;\n        char *href = NULL;\n\tint inclcount = 0;\n\twhile (prev != NULL) {\n\t    if (prev->prev == NULL)\n\t        prev = prev->parent;\n\t    else {\n\t        prev = prev->prev;\n\t\tif (prev->type == XML_XINCLUDE_START) {\n\t\t    if (inclcount > 0) {\n                        --inclcount;\n                    } else {\n                        href = (char *) xmlGetProp(prev, BAD_CAST \"href\");\n                        if (href != NULL)\n\t\t            break;\n                    }\n\t\t} else if (prev->type == XML_XINCLUDE_END)\n\t\t    inclcount++;\n\t    }\n\t}\n        if (href != NULL)\n            to->file = href;\n\telse\n#endif\n\t    to->file = (char *) xmlStrdup(baseptr->doc->URL);\n\tif ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {\n\t    to->file = (char *) xmlStrdup(node->doc->URL);\n\t}\n    }\n    to->line = line;\n    if (str1 != NULL)\n        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);\n    if (str2 != NULL)\n        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);\n    if (str3 != NULL)\n        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);\n    to->int1 = int1;\n    to->int2 = col;\n    to->node = node;\n    to->ctxt = ctx;\n\n    if (to != &xmlLastError)\n        xmlCopyError(to,&xmlLastError);\n\n    if (schannel != NULL) {\n\tschannel(data, to);\n\treturn;\n    }\n\n    /*\n     * Find the callback channel if channel param is NULL\n     */\n    if ((ctxt != NULL) && (channel == NULL) &&\n        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {\n        if (level == XML_ERR_WARNING)\n\t    channel = ctxt->sax->warning;\n        else\n\t    channel = ctxt->sax->error;\n\tdata = ctxt->userData;\n    } else if (channel == NULL) {\n\tchannel = xmlGenericError;\n\tif (ctxt != NULL) {\n\t    data = ctxt;\n\t} else {\n\t    data = xmlGenericErrorContext;\n\t}\n    }\n    if (channel == NULL)\n        return;\n\n    if ((channel == xmlParserError) ||\n        (channel == xmlParserWarning) ||\n\t(channel == xmlParserValidityError) ||\n\t(channel == xmlParserValidityWarning))\n\txmlReportError(to, ctxt, str, NULL, NULL);\n    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||\n             (channel == xmlGenericErrorDefaultFunc))\n\txmlReportError(to, ctxt, str, channel, data);\n    else\n\tchannel(data, \"%s\", str);\n}\nstatic void\nhtmlParseCharDataInternal(htmlParserCtxtPtr ctxt, int readahead) {\n    xmlChar buf[HTML_PARSER_BIG_BUFFER_SIZE + 6];\n    int nbchar = 0;\n    int cur, l;\n\n    if (readahead)\n        buf[nbchar++] = readahead;\n\n    cur = CUR_CHAR(l);\n    while (((cur != '<') || (ctxt->token == '<')) &&\n           ((cur != '&') || (ctxt->token == '&')) &&\n\t   (cur != 0)) {\n\tif (!(IS_CHAR(cur))) {\n\t    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n\t                \"Invalid char in CDATA 0x%X\\n\", cur);\n\t} else {\n\t    COPY_BUF(l,buf,nbchar,cur);\n\t}\n\tNEXTL(l);\n\tif (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {\n            buf[nbchar] = 0;\n\n\t    /*\n\t     * Ok the segment is to be consumed as chars.\n\t     */\n\t    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t\tif (areBlanks(ctxt, buf, nbchar)) {\n\t\t    if (ctxt->keepBlanks) {\n\t\t\tif (ctxt->sax->characters != NULL)\n\t\t\t    ctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t\t    } else {\n\t\t\tif (ctxt->sax->ignorableWhitespace != NULL)\n\t\t\t    ctxt->sax->ignorableWhitespace(ctxt->userData,\n\t\t\t                                   buf, nbchar);\n\t\t    }\n\t\t} else {\n\t\t    htmlCheckParagraph(ctxt);\n\t\t    if (ctxt->sax->characters != NULL)\n\t\t\tctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t\t}\n\t    }\n\t    nbchar = 0;\n            SHRINK;\n\t}\n\tcur = CUR_CHAR(l);\n    }\n    if (ctxt->instate == XML_PARSER_EOF)\n        return;\n    if (nbchar != 0) {\n        buf[nbchar] = 0;\n\n\t/*\n\t * Ok the segment is to be consumed as chars.\n\t */\n\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t    if (areBlanks(ctxt, buf, nbchar)) {\n\t\tif (ctxt->keepBlanks) {\n\t\t    if (ctxt->sax->characters != NULL)\n\t\t\tctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t\t} else {\n\t\t    if (ctxt->sax->ignorableWhitespace != NULL)\n\t\t\tctxt->sax->ignorableWhitespace(ctxt->userData,\n\t\t\t                               buf, nbchar);\n\t\t}\n\t    } else {\n\t\thtmlCheckParagraph(ctxt);\n\t\tif (ctxt->sax->characters != NULL)\n\t\t    ctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t    }\n\t}\n    }\n}\nstatic void\nhtmlParseCharData(htmlParserCtxtPtr ctxt) {\n    htmlParseCharDataInternal(ctxt, 0);\n}\nstatic void\nhtmlParseContentInternal(htmlParserCtxtPtr ctxt) {\n    xmlChar *currentNode;\n    int depth;\n    const xmlChar *name;\n\n    depth = ctxt->nameNr;\n    if (depth <= 0) {\n        currentNode = NULL;\n    } else {\n        currentNode = xmlStrdup(ctxt->name);\n        if (currentNode == NULL) {\n            htmlErrMemory(ctxt, NULL);\n            return;\n        }\n    }\n    while (1) {\n        GROW;\n\n        if (ctxt->instate == XML_PARSER_EOF)\n            break;\n\n\t/*\n\t * Our tag or one of it's parent or children is ending.\n\t */\n        if ((CUR == '<') && (NXT(1) == '/')) {\n\t    if (htmlParseEndTag(ctxt) &&\n\t\t((currentNode != NULL) || (ctxt->nameNr == 0))) {\n\t\tif (currentNode != NULL)\n\t\t    xmlFree(currentNode);\n\n\t        depth = ctxt->nameNr;\n                if (depth <= 0) {\n                    currentNode = NULL;\n                } else {\n                    currentNode = xmlStrdup(ctxt->name);\n                    if (currentNode == NULL) {\n                        htmlErrMemory(ctxt, NULL);\n                        break;\n                    }\n                }\n\t    }\n\t    continue; /* while */\n        }\n\n\telse if ((CUR == '<') &&\n\t         ((IS_ASCII_LETTER(NXT(1))) ||\n\t\t  (NXT(1) == '_') || (NXT(1) == ':'))) {\n\t    name = htmlParseHTMLName_nonInvasive(ctxt);\n\t    if (name == NULL) {\n\t        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t\t \"htmlParseStartTag: invalid element name\\n\",\n\t\t\t NULL, NULL);\n\t        /* Dump the bogus tag like browsers do */\n\t        while ((CUR == 0) && (CUR != '>'))\n\t            NEXT;\n\n\t        htmlParserFinishElementParsing(ctxt);\n\t        if (currentNode != NULL)\n\t            xmlFree(currentNode);\n\n\t        currentNode = xmlStrdup(ctxt->name);\n                if (currentNode == NULL) {\n                    htmlErrMemory(ctxt, NULL);\n                    break;\n                }\n\t        depth = ctxt->nameNr;\n\t        continue;\n\t    }\n\n\t    if (ctxt->name != NULL) {\n\t        if (htmlCheckAutoClose(name, ctxt->name) == 1) {\n\t            htmlAutoClose(ctxt, name);\n\t            continue;\n\t        }\n\t    }\n\t}\n\n\t/*\n\t * Has this node been popped out during parsing of\n\t * the next element\n\t */\n        if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&\n\t    (!xmlStrEqual(currentNode, ctxt->name)))\n\t     {\n\t    htmlParserFinishElementParsing(ctxt);\n\t    if (currentNode != NULL) xmlFree(currentNode);\n\n\t    currentNode = xmlStrdup(ctxt->name);\n            if (currentNode == NULL) {\n                htmlErrMemory(ctxt, NULL);\n                break;\n            }\n\t    depth = ctxt->nameNr;\n\t    continue;\n\t}\n\n\tif ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST\"script\")) ||\n\t    (xmlStrEqual(currentNode, BAD_CAST\"style\")))) {\n\t    /*\n\t     * Handle SCRIPT/STYLE separately\n\t     */\n\t    htmlParseScript(ctxt);\n\t}\n\n        else if ((CUR == '<') && (NXT(1) == '!')) {\n            /*\n             * Sometimes DOCTYPE arrives in the middle of the document\n             */\n            if ((UPP(2) == 'D') && (UPP(3) == 'O') &&\n                (UPP(4) == 'C') && (UPP(5) == 'T') &&\n                (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n                (UPP(8) == 'E')) {\n                htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n                             \"Misplaced DOCTYPE declaration\\n\",\n                             BAD_CAST \"DOCTYPE\" , NULL);\n                htmlParseDocTypeDecl(ctxt);\n            }\n            /*\n             * First case :  a comment\n             */\n            else if ((NXT(2) == '-') && (NXT(3) == '-')) {\n                htmlParseComment(ctxt);\n            }\n            else {\n                htmlSkipBogusComment(ctxt);\n            }\n        }\n\n        /*\n         * Second case : a Processing Instruction.\n         */\n        else if ((CUR == '<') && (NXT(1) == '?')) {\n            htmlParsePI(ctxt);\n        }\n\n        /*\n         * Third case :  a sub-element.\n         */\n        else if ((CUR == '<') && IS_ASCII_LETTER(NXT(1))) {\n            htmlParseElementInternal(ctxt);\n            if (currentNode != NULL) xmlFree(currentNode);\n\n            currentNode = xmlStrdup(ctxt->name);\n            if (currentNode == NULL) {\n                htmlErrMemory(ctxt, NULL);\n                break;\n            }\n            depth = ctxt->nameNr;\n        }\n        else if (CUR == '<') {\n            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n                (ctxt->sax->characters != NULL))\n                ctxt->sax->characters(ctxt->userData, BAD_CAST \"<\", 1);\n            NEXT;\n        }\n\n        /*\n         * Fourth case : a reference. If if has not been resolved,\n         *    parsing returns it's Name, create the node\n         */\n        else if (CUR == '&') {\n            htmlParseReference(ctxt);\n        }\n\n        /*\n         * Fifth case : end of the resource\n         */\n        else if (CUR == 0) {\n            htmlAutoCloseOnEnd(ctxt);\n            break;\n        }\n\n        /*\n         * Last case, text. Note that References are handled directly.\n         */\n        else {\n            htmlParseCharData(ctxt);\n        }\n\n        SHRINK;\n        GROW;\n    }\n    if (currentNode != NULL) xmlFree(currentNode);\n}\nint\nhtmlParseDocument(htmlParserCtxtPtr ctxt) {\n    xmlDtdPtr dtd;\n\n    xmlInitParser();\n\n    if ((ctxt == NULL) || (ctxt->input == NULL)) {\n\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t     \"htmlParseDocument: context error\\n\", NULL, NULL);\n\treturn(XML_ERR_INTERNAL_ERROR);\n    }\n\n    /*\n     * SAX: beginning of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);\n\n    xmlDetectEncoding(ctxt);\n\n    /*\n     * Wipe out everything which is before the first '<'\n     */\n    SKIP_BLANKS;\n    if (CUR == 0) {\n\thtmlParseErr(ctxt, XML_ERR_DOCUMENT_EMPTY,\n\t             \"Document is empty\\n\", NULL, NULL);\n    }\n\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n\tctxt->sax->startDocument(ctxt->userData);\n\n\n    /*\n     * Parse possible comments and PIs before any content\n     */\n    while (((CUR == '<') && (NXT(1) == '!') &&\n            (NXT(2) == '-') && (NXT(3) == '-')) ||\n\t   ((CUR == '<') && (NXT(1) == '?'))) {\n        htmlParseComment(ctxt);\n        htmlParsePI(ctxt);\n\tSKIP_BLANKS;\n    }\n\n\n    /*\n     * Then possibly doc type declaration(s) and more Misc\n     * (doctypedecl Misc*)?\n     */\n    if ((CUR == '<') && (NXT(1) == '!') &&\n\t(UPP(2) == 'D') && (UPP(3) == 'O') &&\n\t(UPP(4) == 'C') && (UPP(5) == 'T') &&\n\t(UPP(6) == 'Y') && (UPP(7) == 'P') &&\n\t(UPP(8) == 'E')) {\n\thtmlParseDocTypeDecl(ctxt);\n    }\n    SKIP_BLANKS;\n\n    /*\n     * Parse possible comments and PIs before any content\n     */\n    while (((CUR == '<') && (NXT(1) == '!') &&\n            (NXT(2) == '-') && (NXT(3) == '-')) ||\n\t   ((CUR == '<') && (NXT(1) == '?'))) {\n        htmlParseComment(ctxt);\n        htmlParsePI(ctxt);\n\tSKIP_BLANKS;\n    }\n\n    /*\n     * Time to start parsing the tree itself\n     */\n    htmlParseContentInternal(ctxt);\n\n    /*\n     * autoclose\n     */\n    if (CUR == 0)\n\thtmlAutoCloseOnEnd(ctxt);\n\n\n    /*\n     * SAX: end of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n\n    if ((!(ctxt->options & HTML_PARSE_NODEFDTD)) && (ctxt->myDoc != NULL)) {\n\tdtd = xmlGetIntSubset(ctxt->myDoc);\n\tif (dtd == NULL)\n\t    ctxt->myDoc->intSubset =\n\t\txmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n\t\t    BAD_CAST \"-//W3C//DTD HTML 4.0 Transitional//EN\",\n\t\t    BAD_CAST \"http://www.w3.org/TR/REC-html40/loose.dtd\");\n    }\n    if (! ctxt->wellFormed) return(-1);\n    return(0);\n}\nstatic htmlDocPtr\nhtmlDoRead(htmlParserCtxtPtr ctxt, const char *URL, const char *encoding,\n          int options, int reuse)\n{\n    htmlDocPtr ret;\n\n    htmlCtxtUseOptions(ctxt, options);\n    ctxt->html = 1;\n    if (encoding != NULL) {\n        xmlCharEncodingHandlerPtr hdlr;\n\n\thdlr = xmlFindCharEncodingHandler(encoding);\n\tif (hdlr != NULL) {\n\t    xmlSwitchToEncoding(ctxt, hdlr);\n        }\n    }\n    if ((URL != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->filename == NULL))\n        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);\n    htmlParseDocument(ctxt);\n    ret = ctxt->myDoc;\n    ctxt->myDoc = NULL;\n    if (!reuse) {\n        if ((ctxt->dictNames) &&\n\t    (ret != NULL) &&\n\t    (ret->dict == ctxt->dict))\n\t    ctxt->dict = NULL;\n\txmlFreeParserCtxt(ctxt);\n    }\n    return (ret);\n}\nhtmlDocPtr\nhtmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)\n{\n    htmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n    ctxt = htmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL)\n        return (NULL);\n    return (htmlDoRead(ctxt, URL, encoding, options, 0));\n}\nint\nLLVMFuzzerTestOneInput(const char *data, size_t size) {\n    static const size_t maxChunkSize = 128;\n    htmlDocPtr doc;\n    htmlParserCtxtPtr ctxt;\n    xmlOutputBufferPtr out;\n    const char *docBuffer;\n    size_t maxAlloc, docSize, consumed, chunkSize;\n    int opts;\n\n    xmlFuzzDataInit(data, size);\n    opts = (int) xmlFuzzReadInt(4);\n    maxAlloc = xmlFuzzReadInt(4) % (size + 1);\n\n    docBuffer = xmlFuzzReadRemaining(&docSize);\n    if (docBuffer == NULL) {\n        xmlFuzzDataCleanup();\n        return(0);\n    }\n\n    /* Pull parser */\n\n    xmlFuzzMemSetLimit(maxAlloc);\n    doc = htmlReadMemory(docBuffer, docSize, NULL, NULL, opts);\n\n    /*\n     * Also test the serializer. Call htmlDocContentDumpOutput with our\n     * own buffer to avoid encoding the output. The HTML encoding is\n     * excruciatingly slow (see htmlEntityValueLookup).\n     */\n    out = xmlAllocOutputBuffer(NULL);\n    htmlDocContentDumpOutput(out, doc, NULL);\n    xmlOutputBufferClose(out);\n\n    xmlFreeDoc(doc);\n\n    /* Push parser */\n\n    xmlFuzzMemSetLimit(maxAlloc);\n    ctxt = htmlCreatePushParserCtxt(NULL, NULL, NULL, 0, NULL,\n                                    XML_CHAR_ENCODING_NONE);\n\n    if (ctxt != NULL) {\n        htmlCtxtUseOptions(ctxt, opts);\n\n        for (consumed = 0; consumed < docSize; consumed += chunkSize) {\n            chunkSize = docSize - consumed;\n            if (chunkSize > maxChunkSize)\n                chunkSize = maxChunkSize;\n            htmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);\n        }\n\n        htmlParseChunk(ctxt, NULL, 0, 1);\n        xmlFreeDoc(ctxt->myDoc);\n        htmlFreeParserCtxt(ctxt);\n    }\n\n    /* Cleanup */\n\n    xmlFuzzMemSetLimit(0);\n    xmlFuzzDataCleanup();\n    xmlResetLastError();\n\n    return(0);\n}",
    "target": 0,
    "idx": 2061337
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "void\nxmlParseReference(xmlParserCtxtPtr ctxt) {\n    xmlEntityPtr ent;\n    xmlChar *val;\n    int was_checked;\n    xmlNodePtr list = NULL;\n    xmlParserErrors ret = XML_ERR_OK;\n\n\n    if (RAW != '&')\n        return;\n\n    /*\n     * Simple case of a CharRef\n     */\n    if (NXT(1) == '#') {\n\tint i = 0;\n\txmlChar out[16];\n\tint value = xmlParseCharRef(ctxt);\n\n\tif (value == 0)\n\t    return;\n\n        /*\n         * Just encode the value in UTF-8\n         */\n        COPY_BUF(0, out, i, value);\n        out[i] = 0;\n        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n            (!ctxt->disableSAX))\n            ctxt->sax->characters(ctxt->userData, out, i);\n\treturn;\n    }\n\n    /*\n     * We are seeing an entity reference\n     */\n    ent = xmlParseEntityRef(ctxt);\n    if (ent == NULL) return;\n    if (!ctxt->wellFormed)\n\treturn;\n    was_checked = ent->flags & XML_ENT_PARSED;\n\n    /* special case of predefined entities */\n    if ((ent->name == NULL) ||\n        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\tval = ent->content;\n\tif (val == NULL) return;\n\t/*\n\t * inline the entity.\n\t */\n\tif ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));\n\treturn;\n    }\n\n    /*\n     * The first reference to the entity trigger a parsing phase\n     * where the ent->children is filled with the result from\n     * the parsing.\n     * Note: external parsed entities will not be loaded, it is not\n     * required for a non-validating parser, unless the parsing option\n     * of validating, or substituting entities were given. Doing so is\n     * far more secure as the parser will only process data coming from\n     * the document entity by default.\n     *\n     * FIXME: This doesn't work correctly since entities can be\n     * expanded with different namespace declarations in scope.\n     * For example:\n     *\n     * <!DOCTYPE doc [\n     *   <!ENTITY ent \"<ns:elem/>\">\n     * ]>\n     * <doc>\n     *   <decl1 xmlns:ns=\"urn:ns1\">\n     *     &ent;\n     *   </decl1>\n     *   <decl2 xmlns:ns=\"urn:ns2\">\n     *     &ent;\n     *   </decl2>\n     * </doc>\n     *\n     * Proposed fix:\n     *\n     * - Remove the ent->owner optimization which tries to avoid the\n     *   initial copy of the entity. Always make entities own the\n     *   subtree.\n     * - Ignore current namespace declarations when parsing the\n     *   entity. If a prefix can't be resolved, don't report an error\n     *   but mark it as unresolved.\n     * - Try to resolve these prefixes when expanding the entity.\n     *   This will require a specialized version of xmlStaticCopyNode\n     *   which can also make use of the namespace hash table to avoid\n     *   quadratic behavior.\n     *\n     * Alternatively, we could simply reparse the entity on each\n     * expansion like we already do with custom SAX callbacks.\n     * External entity content should be cached in this case.\n     */\n    if (((ent->flags & XML_ENT_PARSED) == 0) &&\n        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||\n         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {\n\tunsigned long oldsizeentcopy = ctxt->sizeentcopy;\n\n\t/*\n\t * This is a bit hackish but this seems the best\n\t * way to make sure both SAX and DOM entity support\n\t * behaves okay.\n\t */\n\tvoid *user_data;\n\tif (ctxt->userData == ctxt)\n\t    user_data = NULL;\n\telse\n\t    user_data = ctxt->userData;\n\n        /* Avoid overflow as much as possible */\n        ctxt->sizeentcopy = 0;\n\n        if (ent->flags & XML_ENT_EXPANDING) {\n            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n            xmlHaltParser(ctxt);\n            return;\n        }\n\n        ent->flags |= XML_ENT_EXPANDING;\n\n\t/*\n\t * Check that this entity is well formed\n\t * 4.3.2: An internal general parsed entity is well-formed\n\t * if its replacement text matches the production labeled\n\t * content.\n\t */\n\tif (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {\n\t    ctxt->depth++;\n\t    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,\n\t                                              user_data, &list);\n\t    ctxt->depth--;\n\n\t} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {\n\t    ctxt->depth++;\n\t    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,\n\t                                   user_data, ctxt->depth, ent->URI,\n\t\t\t\t\t   ent->ExternalID, &list);\n\t    ctxt->depth--;\n\t} else {\n\t    ret = XML_ERR_ENTITY_PE_INTERNAL;\n\t    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t \"invalid entity type found\\n\", NULL);\n\t}\n\n        ent->flags &= ~XML_ENT_EXPANDING;\n        ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n        ent->expandedSize = ctxt->sizeentcopy;\n\tif (ret == XML_ERR_ENTITY_LOOP) {\n            xmlHaltParser(ctxt);\n\t    xmlFreeNodeList(list);\n\t    return;\n\t}\n\tif (xmlParserEntityCheck(ctxt, oldsizeentcopy)) {\n\t    xmlFreeNodeList(list);\n\t    return;\n\t}\n\n\tif ((ret == XML_ERR_OK) && (list != NULL)) {\n            ent->children = list;\n            /*\n             * Prune it directly in the generated document\n             * except for single text nodes.\n             */\n            if ((ctxt->replaceEntities == 0) ||\n                (ctxt->parseMode == XML_PARSE_READER) ||\n                ((list->type == XML_TEXT_NODE) &&\n                 (list->next == NULL))) {\n                ent->owner = 1;\n                while (list != NULL) {\n                    list->parent = (xmlNodePtr) ent;\n                    if (list->doc != ent->doc)\n                        xmlSetTreeDoc(list, ent->doc);\n                    if (list->next == NULL)\n                        ent->last = list;\n                    list = list->next;\n                }\n                list = NULL;\n            } else {\n                ent->owner = 0;\n                while (list != NULL) {\n                    list->parent = (xmlNodePtr) ctxt->node;\n                    list->doc = ctxt->myDoc;\n                    if (list->next == NULL)\n                        ent->last = list;\n                    list = list->next;\n                }\n                list = ent->children;\n#ifdef LIBXML_LEGACY_ENABLED\n                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n                    xmlAddEntityReference(ent, list, NULL);\n#endif /* LIBXML_LEGACY_ENABLED */\n            }\n\t} else if ((ret != XML_ERR_OK) &&\n\t\t   (ret != XML_WAR_UNDECLARED_ENTITY)) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' failed to parse\\n\", ent->name);\n            if (ent->content != NULL)\n                ent->content[0] = 0;\n\t} else if (list != NULL) {\n\t    xmlFreeNodeList(list);\n\t    list = NULL;\n\t}\n\n        /* Prevent entity from being parsed and expanded twice (Bug 760367). */\n        was_checked = 0;\n    }\n\n    /*\n     * Now that the entity content has been gathered\n     * provide it to the application, this can take different forms based\n     * on the parsing modes.\n     */\n    if (ent->children == NULL) {\n\t/*\n\t * Probably running in SAX mode and the callbacks don't\n\t * build the entity content. So unless we already went\n\t * though parsing for first checking go though the entity\n\t * content to generate callbacks associated to the entity\n\t */\n\tif (was_checked != 0) {\n\t    void *user_data;\n\t    /*\n\t     * This is a bit hackish but this seems the best\n\t     * way to make sure both SAX and DOM entity support\n\t     * behaves okay.\n\t     */\n\t    if (ctxt->userData == ctxt)\n\t\tuser_data = NULL;\n\t    else\n\t\tuser_data = ctxt->userData;\n\n\t    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {\n\t\tctxt->depth++;\n\t\tret = xmlParseBalancedChunkMemoryInternal(ctxt,\n\t\t\t\t   ent->content, user_data, NULL);\n\t\tctxt->depth--;\n\t    } else if (ent->etype ==\n\t\t       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {\n\t        unsigned long oldsizeentities = ctxt->sizeentities;\n\n\t\tctxt->depth++;\n\t\tret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,\n\t\t\t   ctxt->sax, user_data, ctxt->depth,\n\t\t\t   ent->URI, ent->ExternalID, NULL);\n\t\tctxt->depth--;\n\n                /* Undo the change to sizeentities */\n                ctxt->sizeentities = oldsizeentities;\n\t    } else {\n\t\tret = XML_ERR_ENTITY_PE_INTERNAL;\n\t\txmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t     \"invalid entity type found\\n\", NULL);\n\t    }\n\t    if (ret == XML_ERR_ENTITY_LOOP) {\n\t\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\t\treturn;\n\t    }\n            if (xmlParserEntityCheck(ctxt, 0))\n                return;\n\t}\n\tif ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n\t    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {\n\t    /*\n\t     * Entity reference callback comes second, it's somewhat\n\t     * superfluous but a compatibility to historical behaviour\n\t     */\n\t    ctxt->sax->reference(ctxt->userData, ent->name);\n\t}\n\treturn;\n    }\n\n    /*\n     * We also check for amplification if entities aren't substituted.\n     * They might be expanded later.\n     */\n    if ((was_checked != 0) &&\n        (xmlParserEntityCheck(ctxt, ent->expandedSize)))\n        return;\n\n    /*\n     * If we didn't get any children for the entity being built\n     */\n    if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n\t(ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {\n\t/*\n\t * Create a node.\n\t */\n\tctxt->sax->reference(ctxt->userData, ent->name);\n\treturn;\n    }\n\n    if (ctxt->replaceEntities)  {\n\t/*\n\t * There is a problem on the handling of _private for entities\n\t * (bug 155816): Should we copy the content of the field from\n\t * the entity (possibly overwriting some value set by the user\n\t * when a copy is created), should we leave it alone, or should\n\t * we try to take care of different situations?  The problem\n\t * is exacerbated by the usage of this field by the xmlReader.\n\t * To fix this bug, we look at _private on the created node\n\t * and, if it's NULL, we copy in whatever was in the entity.\n\t * If it's not NULL we leave it alone.  This is somewhat of a\n\t * hack - maybe we should have further tests to determine\n\t * what to do.\n\t */\n\tif (ctxt->node != NULL) {\n\t    /*\n\t     * Seems we are generating the DOM content, do\n\t     * a simple tree copy for all references except the first\n\t     * In the first occurrence list contains the replacement.\n\t     */\n\t    if (((list == NULL) && (ent->owner == 0)) ||\n\t\t(ctxt->parseMode == XML_PARSE_READER)) {\n\t\txmlNodePtr nw = NULL, cur, firstChild = NULL;\n\n\t\t/*\n\t\t * when operating on a reader, the entities definitions\n\t\t * are always owning the entities subtree.\n\t\tif (ctxt->parseMode == XML_PARSE_READER)\n\t\t    ent->owner = 1;\n\t\t */\n\n\t\tcur = ent->children;\n\t\twhile (cur != NULL) {\n\t\t    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n\t\t    if (nw != NULL) {\n\t\t\tif (nw->_private == NULL)\n\t\t\t    nw->_private = cur->_private;\n\t\t\tif (firstChild == NULL){\n\t\t\t    firstChild = nw;\n\t\t\t}\n\t\t\tnw = xmlAddChild(ctxt->node, nw);\n\t\t    }\n\t\t    if (cur == ent->last) {\n\t\t\t/*\n\t\t\t * needed to detect some strange empty\n\t\t\t * node cases in the reader tests\n\t\t\t */\n\t\t\tif ((ctxt->parseMode == XML_PARSE_READER) &&\n\t\t\t    (nw != NULL) &&\n\t\t\t    (nw->type == XML_ELEMENT_NODE) &&\n\t\t\t    (nw->children == NULL))\n\t\t\t    nw->extra = 1;\n\n\t\t\tbreak;\n\t\t    }\n\t\t    cur = cur->next;\n\t\t}\n#ifdef LIBXML_LEGACY_ENABLED\n\t\tif (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n\t\t  xmlAddEntityReference(ent, firstChild, nw);\n#endif /* LIBXML_LEGACY_ENABLED */\n\t    } else if ((list == NULL) || (ctxt->inputNr > 0)) {\n\t\txmlNodePtr nw = NULL, cur, next, last,\n\t\t\t   firstChild = NULL;\n\n\t\t/*\n\t\t * Copy the entity child list and make it the new\n\t\t * entity child list. The goal is to make sure any\n\t\t * ID or REF referenced will be the one from the\n\t\t * document content and not the entity copy.\n\t\t */\n\t\tcur = ent->children;\n\t\tent->children = NULL;\n\t\tlast = ent->last;\n\t\tent->last = NULL;\n\t\twhile (cur != NULL) {\n\t\t    next = cur->next;\n\t\t    cur->next = NULL;\n\t\t    cur->parent = NULL;\n\t\t    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n\t\t    if (nw != NULL) {\n\t\t\tif (nw->_private == NULL)\n\t\t\t    nw->_private = cur->_private;\n\t\t\tif (firstChild == NULL){\n\t\t\t    firstChild = cur;\n\t\t\t}\n\t\t\txmlAddChild((xmlNodePtr) ent, nw);\n\t\t    }\n\t\t    xmlAddChild(ctxt->node, cur);\n\t\t    if (cur == last)\n\t\t\tbreak;\n\t\t    cur = next;\n\t\t}\n\t\tif (ent->owner == 0)\n\t\t    ent->owner = 1;\n#ifdef LIBXML_LEGACY_ENABLED\n\t\tif (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n\t\t  xmlAddEntityReference(ent, firstChild, nw);\n#endif /* LIBXML_LEGACY_ENABLED */\n\t    } else {\n\t\tconst xmlChar *nbktext;\n\n\t\t/*\n\t\t * the name change is to avoid coalescing of the\n\t\t * node with a possible previous text one which\n\t\t * would make ent->children a dangling pointer\n\t\t */\n\t\tnbktext = xmlDictLookup(ctxt->dict, BAD_CAST \"nbktext\",\n\t\t\t\t\t-1);\n\t\tif (ent->children->type == XML_TEXT_NODE)\n\t\t    ent->children->name = nbktext;\n\t\tif ((ent->last != ent->children) &&\n\t\t    (ent->last->type == XML_TEXT_NODE))\n\t\t    ent->last->name = nbktext;\n\t\txmlAddChildList(ctxt->node, ent->children);\n\t    }\n\n\t    /*\n\t     * This is to avoid a nasty side effect, see\n\t     * characters() in SAX.c\n\t     */\n\t    ctxt->nodemem = 0;\n\t    ctxt->nodelen = 0;\n\t    return;\n\t}\n    }\n}\nstatic xmlParserErrors\nxmlParseBalancedChunkMemoryInternal(xmlParserCtxtPtr oldctxt,\n\tconst xmlChar *string, void *user_data, xmlNodePtr *lst) {\n    xmlParserCtxtPtr ctxt;\n    xmlDocPtr newDoc = NULL;\n    xmlNodePtr newRoot;\n    xmlSAXHandlerPtr oldsax = NULL;\n    xmlNodePtr content = NULL;\n    xmlNodePtr last = NULL;\n    xmlParserErrors ret = XML_ERR_OK;\n#if 0\n    unsigned i;\n#endif\n\n    if (((oldctxt->depth > 40) && ((oldctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (oldctxt->depth >  100)) {\n\txmlFatalErrMsg(oldctxt, XML_ERR_ENTITY_LOOP,\n                       \"Maximum entity nesting depth exceeded\");\n\treturn(XML_ERR_ENTITY_LOOP);\n    }\n\n\n    if (lst != NULL)\n        *lst = NULL;\n    if (string == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt = xmlCreateDocParserCtxt(string);\n    if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);\n    ctxt->nbErrors = oldctxt->nbErrors;\n    ctxt->nbWarnings = oldctxt->nbWarnings;\n    if (user_data != NULL)\n\tctxt->userData = user_data;\n    else\n\tctxt->userData = ctxt;\n    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);\n    ctxt->dict = oldctxt->dict;\n    ctxt->input_id = oldctxt->input_id;\n    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST \"xml\", 3);\n    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST \"xmlns\", 5);\n    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);\n\n    /*\n     * Propagate namespaces down the entity\n     *\n     * This is disabled for now. The pre-2.12 code was already broken\n     * since the SAX handler was using xmlSearchNs which didn't see the\n     * namespaces added here.\n     *\n     * Making entities and namespaces work correctly requires additional\n     * changes, see xmlParseReference.\n     */\n#if 0\n    for (i = 0; i < oldctxt->nsdb->hashSize; i++) {\n        xmlParserNsBucket *bucket = &oldctxt->nsdb->hash[i];\n        xmlHashedString hprefix, huri;\n        const xmlChar **ns;\n        xmlParserNsExtra *extra;\n        unsigned nsIndex;\n\n        if ((bucket->hashValue != 0) &&\n            (bucket->index != INT_MAX)) {\n            nsIndex = bucket->index;\n            ns = &oldctxt->nsTab[nsIndex * 2];\n            extra = &oldctxt->nsdb->extra[nsIndex];\n\n            hprefix.name = ns[0];\n            hprefix.hashValue = bucket->hashValue;\n            huri.name = ns[1];\n            huri.hashValue = extra->uriHashValue;\n            xmlParserNsPush(ctxt, &hprefix, &huri, extra->saxData, 0);\n        }\n    }\n#endif\n\n    oldsax = ctxt->sax;\n    ctxt->sax = oldctxt->sax;\n    xmlDetectSAX2(ctxt);\n    ctxt->replaceEntities = oldctxt->replaceEntities;\n    ctxt->options = oldctxt->options;\n\n    ctxt->_private = oldctxt->_private;\n    if (oldctxt->myDoc == NULL) {\n\tnewDoc = xmlNewDoc(BAD_CAST \"1.0\");\n\tif (newDoc == NULL) {\n            ret = XML_ERR_INTERNAL_ERROR;\n            goto error;\n\t}\n\tnewDoc->properties = XML_DOC_INTERNAL;\n\tnewDoc->dict = ctxt->dict;\n\txmlDictReference(newDoc->dict);\n\tctxt->myDoc = newDoc;\n    } else {\n\tctxt->myDoc = oldctxt->myDoc;\n        content = ctxt->myDoc->children;\n\tlast = ctxt->myDoc->last;\n    }\n    newRoot = xmlNewDocNode(ctxt->myDoc, NULL, BAD_CAST \"pseudoroot\", NULL);\n    if (newRoot == NULL) {\n        ret = XML_ERR_INTERNAL_ERROR;\n        goto error;\n    }\n    ctxt->myDoc->children = NULL;\n    ctxt->myDoc->last = NULL;\n    xmlAddChild((xmlNodePtr) ctxt->myDoc, newRoot);\n    nodePush(ctxt, ctxt->myDoc->children);\n    ctxt->instate = XML_PARSER_CONTENT;\n    ctxt->depth = oldctxt->depth;\n\n    ctxt->validate = 0;\n    ctxt->loadsubset = oldctxt->loadsubset;\n    if ((oldctxt->validate) || (oldctxt->replaceEntities != 0)) {\n\t/*\n\t * ID/IDREF registration will be done in xmlValidateElement below\n\t */\n\tctxt->loadsubset |= XML_SKIP_IDS;\n    }\n    ctxt->dictNames = oldctxt->dictNames;\n    ctxt->attsDefault = oldctxt->attsDefault;\n    ctxt->attsSpecial = oldctxt->attsSpecial;\n\n    xmlParseContent(ctxt);\n    if ((RAW == '<') && (NXT(1) == '/')) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    } else if (RAW != 0) {\n\txmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n    }\n    if (ctxt->node != ctxt->myDoc->children) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    }\n\n    if (!ctxt->wellFormed) {\n\tret = (xmlParserErrors)ctxt->errNo;\n        oldctxt->errNo = ctxt->errNo;\n        oldctxt->wellFormed = 0;\n        xmlCopyError(&ctxt->lastError, &oldctxt->lastError);\n    } else {\n        ret = XML_ERR_OK;\n    }\n\n    if ((lst != NULL) && (ret == XML_ERR_OK)) {\n\txmlNodePtr cur;\n\n\t/*\n\t * Return the newly created nodeset after unlinking it from\n\t * they pseudo parent.\n\t */\n\tcur = ctxt->myDoc->children->children;\n\t*lst = cur;\n\twhile (cur != NULL) {\n#ifdef LIBXML_VALID_ENABLED\n\t    if ((oldctxt->validate) && (oldctxt->wellFormed) &&\n\t\t(oldctxt->myDoc) && (oldctxt->myDoc->intSubset) &&\n\t\t(cur->type == XML_ELEMENT_NODE)) {\n\t\toldctxt->valid &= xmlValidateElement(&oldctxt->vctxt,\n\t\t\toldctxt->myDoc, cur);\n\t    }\n#endif /* LIBXML_VALID_ENABLED */\n\t    cur->parent = NULL;\n\t    cur = cur->next;\n\t}\n\tctxt->myDoc->children->children = NULL;\n    }\n    if (ctxt->myDoc != NULL) {\n\txmlFreeNode(ctxt->myDoc->children);\n        ctxt->myDoc->children = content;\n        ctxt->myDoc->last = last;\n    }\n\n    /*\n     * Also record the size of the entity parsed\n     */\n    if (ctxt->input != NULL && oldctxt != NULL) {\n        unsigned long consumed = ctxt->input->consumed;\n\n        xmlSaturatedAddSizeT(&consumed, ctxt->input->cur - ctxt->input->base);\n\n        xmlSaturatedAdd(&oldctxt->sizeentcopy, consumed);\n        xmlSaturatedAdd(&oldctxt->sizeentcopy, ctxt->sizeentcopy);\n    }\n\n    oldctxt->nbErrors = ctxt->nbErrors;\n    oldctxt->nbWarnings = ctxt->nbWarnings;\n\nerror:\n    ctxt->sax = oldsax;\n    ctxt->dict = NULL;\n    ctxt->attsDefault = NULL;\n    ctxt->attsSpecial = NULL;\n    xmlFreeParserCtxt(ctxt);\n    if (newDoc != NULL) {\n\txmlFreeDoc(newDoc);\n    }\n\n    return(ret);\n}\nxmlNodePtr\nxmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,\n                  int extended) {\n    xmlNodePtr ret;\n\n    if (node == NULL) return(NULL);\n    switch (node->type) {\n        case XML_TEXT_NODE:\n        case XML_CDATA_SECTION_NODE:\n        case XML_ELEMENT_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_ENTITY_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n\t    break;\n        case XML_ATTRIBUTE_NODE:\n\t\treturn((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n        case XML_NAMESPACE_DECL:\n\t    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_TREE_ENABLED\n\t    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n#endif /* LIBXML_TREE_ENABLED */\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_NOTATION_NODE:\n        case XML_DTD_NODE:\n        case XML_ELEMENT_DECL:\n        case XML_ATTRIBUTE_DECL:\n        case XML_ENTITY_DECL:\n            return(NULL);\n    }\n\n    /*\n     * Allocate a new node and fill the fields.\n     */\n    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n    if (ret == NULL) {\n\txmlTreeErrMemory(\"copying node\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlNode));\n    ret->type = node->type;\n\n    ret->doc = doc;\n    ret->parent = parent;\n    if (node->name == xmlStringText)\n\tret->name = xmlStringText;\n    else if (node->name == xmlStringTextNoenc)\n\tret->name = xmlStringTextNoenc;\n    else if (node->name == xmlStringComment)\n\tret->name = xmlStringComment;\n    else if (node->name != NULL) {\n        if ((doc != NULL) && (doc->dict != NULL))\n\t    ret->name = xmlDictLookup(doc->dict, node->name, -1);\n\telse\n\t    ret->name = xmlStrdup(node->name);\n    }\n    if ((node->type != XML_ELEMENT_NODE) &&\n\t(node->content != NULL) &&\n\t(node->type != XML_ENTITY_REF_NODE) &&\n\t(node->type != XML_XINCLUDE_END) &&\n\t(node->type != XML_XINCLUDE_START)) {\n\tret->content = xmlStrdup(node->content);\n    }else{\n      if (node->type == XML_ELEMENT_NODE)\n        ret->line = node->line;\n    }\n    if (parent != NULL) {\n\txmlNodePtr tmp;\n\n\t/*\n\t * this is a tricky part for the node register thing:\n\t * in case ret does get coalesced in xmlAddChild\n\t * the deregister-node callback is called; so we register ret now already\n\t */\n\tif ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n\t    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n\n        /*\n         * Note that since ret->parent is already set, xmlAddChild will\n         * return early and not actually insert the node. It will only\n         * coalesce text nodes and unnecessarily call xmlSetTreeDoc.\n         * Assuming that the subtree to be copied always has its text\n         * nodes coalesced, the somewhat confusing call to xmlAddChild\n         * could be removed.\n         */\n        tmp = xmlAddChild(parent, ret);\n\t/* node could have coalesced */\n\tif (tmp != ret)\n\t    return(tmp);\n    }\n\n    if (!extended)\n\tgoto out;\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL))\n        ret->nsDef = xmlCopyNamespaceList(node->nsDef);\n\n    if (node->ns != NULL) {\n        xmlNsPtr ns;\n\n\tns = xmlSearchNs(doc, ret, node->ns->prefix);\n\tif (ns == NULL) {\n\t    /*\n\t     * Humm, we are copying an element whose namespace is defined\n\t     * out of the new tree scope. Search it in the original tree\n\t     * and add it at the top of the new tree.\n             *\n             * TODO: Searching the original tree seems unnecessary. We\n             * already have a namespace URI.\n\t     */\n\t    ns = xmlSearchNs(node->doc, node, node->ns->prefix);\n\t    if (ns != NULL) {\n\t        xmlNodePtr root = ret;\n\n\t\twhile (root->parent != NULL) root = root->parent;\n\t\tret->ns = xmlNewNs(root, ns->href, ns->prefix);\n            } else {\n                ret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n\t    }\n\t} else {\n\t    /*\n\t     * reference the existing namespace definition in our own tree.\n\t     */\n\t    ret->ns = ns;\n\t}\n    }\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->properties != NULL))\n        ret->properties = xmlCopyPropList(ret, node->properties);\n    if (node->type == XML_ENTITY_REF_NODE) {\n\tif ((doc == NULL) || (node->doc != doc)) {\n\t    /*\n\t     * The copied node will go into a separate document, so\n\t     * to avoid dangling references to the ENTITY_DECL node\n\t     * we cannot keep the reference. Try to find it in the\n\t     * target document.\n\t     */\n\t    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n\t} else {\n            ret->children = node->children;\n\t}\n\tret->last = ret->children;\n    } else if ((node->children != NULL) && (extended != 2)) {\n        xmlNodePtr cur, insert;\n\n        cur = node->children;\n        insert = ret;\n        while (cur != NULL) {\n            xmlNodePtr copy = xmlStaticCopyNode(cur, doc, insert, 2);\n            if (copy == NULL) {\n                xmlFreeNode(ret);\n                return(NULL);\n            }\n\n            /* Check for coalesced text nodes */\n            if (insert->last != copy) {\n                if (insert->last == NULL) {\n                    insert->children = copy;\n                } else {\n                    copy->prev = insert->last;\n                    insert->last->next = copy;\n                }\n                insert->last = copy;\n            }\n\n            if ((cur->type != XML_ENTITY_REF_NODE) &&\n                (cur->children != NULL)) {\n                cur = cur->children;\n                insert = copy;\n                continue;\n            }\n\n            while (1) {\n                if (cur->next != NULL) {\n                    cur = cur->next;\n                    break;\n                }\n\n                cur = cur->parent;\n                insert = insert->parent;\n                if (cur == node) {\n                    cur = NULL;\n                    break;\n                }\n            }\n        }\n    }\n\nout:\n    /* if parent != NULL we already registered the node above */\n    if ((parent == NULL) &&\n        ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))\n\txmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n    return(ret);\n}\nxmlNodePtr\nxmlDocCopyNode(xmlNodePtr node, xmlDocPtr doc, int extended) {\n    xmlNodePtr ret;\n\n    ret = xmlStaticCopyNode(node, doc, NULL, extended);\n    return(ret);\n}\nint\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    int end_in_lf = 0;\n\n    if (ctxt == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    if (ctxt->input == NULL)\n        return(-1);\n\n    ctxt->progressive = 1;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlDetectSAX2(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(ctxt->errNo);\n\n    if ((ctxt->input != NULL) &&\n         (((ctxt->input->end - ctxt->input->cur) > XML_MAX_LOOKUP_LIMIT) ||\n         ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"Huge input lookup\");\n        xmlHaltParser(ctxt);\n    }\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\tctxt->sax->endDocument(ctxt->userData);\n\t}\n\tctxt->instate = XML_PARSER_EOF;\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}\nstatic int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlGenericError(xmlGenericErrorContext,\n                                    \"xmlParserInputBufferRead failed\\n\");\n\t\t    reader->mode = XML_TEXTREADER_MODE_EOF;\n\t\t    reader->state = oldstate;\n\t\t    return(val);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}\nstatic int\nxmlTextReaderDoExpand(xmlTextReaderPtr reader) {\n    int val;\n\n    if ((reader == NULL) || (reader->node == NULL) || (reader->ctxt == NULL))\n        return(-1);\n    do {\n\tif (reader->ctxt->instate == XML_PARSER_EOF) return(1);\n\n        if (xmlTextReaderGetSuccessor(reader->node) != NULL)\n\t    return(1);\n\tif (reader->ctxt->nodeNr < reader->depth)\n\t    return(1);\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(1);\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t    reader->mode = XML_TEXTREADER_MODE_ERROR;\n\t    return(-1);\n\t}\n    } while(reader->mode != XML_TEXTREADER_MODE_EOF);\n    return(1);\n}\nxmlNodePtr\nxmlTextReaderExpand(xmlTextReaderPtr reader) {\n    if ((reader == NULL) || (reader->node == NULL))\n        return(NULL);\n    if (reader->doc != NULL)\n        return(reader->node);\n    if (reader->ctxt == NULL)\n        return(NULL);\n    if (xmlTextReaderDoExpand(reader) < 0)\n        return(NULL);\n    return(reader->node);\n}\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\treader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n\t}\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    xmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))\n\txmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return -1;\n\txmlXIncludeProcessNode(reader->xincctxt, reader->node);\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    xmlTextReaderValidatePush(reader);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\nint\nLLVMFuzzerTestOneInput(const char *data, size_t size) {\n    xmlDocPtr doc;\n    const char *docBuffer, *docUrl;\n    size_t maxAlloc, docSize;\n    int opts;\n\n    xmlFuzzDataInit(data, size);\n    opts = (int) xmlFuzzReadInt(4);\n    /*\n     * Disable options that are known to cause timeouts\n     */\n    opts &= ~XML_PARSE_XINCLUDE &\n            ~XML_PARSE_DTDVALID &\n            ~XML_PARSE_SAX1;\n    maxAlloc = xmlFuzzReadInt(4) % (size + 1);\n\n    xmlFuzzReadEntities();\n    docBuffer = xmlFuzzMainEntity(&docSize);\n    docUrl = xmlFuzzMainUrl();\n    if (docBuffer == NULL)\n        goto exit;\n\n    /* Pull parser */\n\n    xmlFuzzMemSetLimit(maxAlloc);\n    doc = xmlReadMemory(docBuffer, docSize, docUrl, NULL, opts);\n\n#ifdef LIBXML_OUTPUT_ENABLED\n    {\n        xmlChar *out;\n        int outSize;\n\n        /* Also test the serializer. */\n        xmlDocDumpMemory(doc, &out, &outSize);\n        xmlFree(out);\n    }\n#endif\n\n    xmlFreeDoc(doc);\n\n    /* Push parser */\n\n#ifdef LIBXML_PUSH_ENABLED\n    {\n        static const size_t maxChunkSize = 128;\n        xmlParserCtxtPtr ctxt;\n        size_t consumed, chunkSize;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, docUrl);\n        if (ctxt == NULL)\n            goto exit;\n        xmlCtxtUseOptions(ctxt, opts);\n\n        for (consumed = 0; consumed < docSize; consumed += chunkSize) {\n            chunkSize = docSize - consumed;\n            if (chunkSize > maxChunkSize)\n                chunkSize = maxChunkSize;\n            xmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);\n        }\n\n        xmlParseChunk(ctxt, NULL, 0, 1);\n        xmlFreeDoc(ctxt->myDoc);\n        xmlFreeParserCtxt(ctxt);\n    }\n#endif\n\n    /* Reader */\n\n#ifdef LIBXML_READER_ENABLED\n    {\n        xmlTextReaderPtr reader;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);\n        if (reader == NULL)\n            goto exit;\n        while (xmlTextReaderRead(reader) == 1) {\n            if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {\n                int i, n = xmlTextReaderAttributeCount(reader);\n                for (i=0; i<n; i++) {\n                    xmlTextReaderMoveToAttributeNo(reader, i);\n                    while (xmlTextReaderReadAttributeValue(reader) == 1);\n                }\n            }\n        }\n        xmlFreeTextReader(reader);\n    }\n#endif\n\nexit:\n    xmlFuzzMemSetLimit(0);\n    xmlFuzzDataCleanup();\n    xmlResetLastError();\n    return(0);\n}",
    "target": 0,
    "idx": 2062996
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "int yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* child;\n  RE_NODE* concat;\n\n  int result;\n\n  *result_re_ast = re_ast;\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  if (re_ast->root_node->type != RE_NODE_CONCAT)\n    return ERROR_SUCCESS;\n\n  child = re_ast->root_node->children_head;\n\n  while (child != NULL)\n  {\n    if (!child->greedy &&\n         child->type == RE_NODE_RANGE_ANY &&\n         child->prev_sibling != NULL &&\n         child->next_sibling != NULL &&\n        (child->start > YR_STRING_CHAINING_THRESHOLD ||\n         child->end > YR_STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      concat = yr_re_node_create(RE_NODE_CONCAT);\n\n      if (concat == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      concat->children_head = re_ast->root_node->children_head;\n      concat->children_tail = child->prev_sibling;\n\n      re_ast->root_node->children_head = child->next_sibling;\n\n      child->prev_sibling->next_sibling = NULL;\n      child->next_sibling->prev_sibling = NULL;\n\n      *min_gap = child->start;\n      *max_gap = child->end;\n\n      (*result_re_ast)->root_node = re_ast->root_node;\n      (*result_re_ast)->flags = re_ast->flags;\n      (*remainder_re_ast)->root_node = concat;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      yr_re_node_destroy(child);\n\n      return ERROR_SUCCESS;\n    }\n\n    child = child->next_sibling;\n  }\n\n  return ERROR_SUCCESS;\n}\nvoid test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\"a|b\", \"a\", \"a\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab{1,2}c\", \"abbbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_false_regexp(\"ab{1}c\", \"ac\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_false_regexp(\"ab{3}c\", \"abbbbc\");  // Issue #817\n  assert_false_regexp(\"ab{4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,4}\", \"abbbbc\", \"abbbb\");\n  assert_true_regexp(\"ab{3,4}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\"ab{3,5}\", \"abbbbb\", \"abbbbb\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbc\");\n  assert_false_regexp(\"ab{3,5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // Test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  // Test case for issue #682\n  assert_true_regexp(\"(a|\\\\b)[a]{1,}\", \"aaaa\", \"aaaa\");\n\n  // Test for integer overflow in repeat interval\n  assert_regexp_syntax_error(\"a{2977952116}\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  // Test case for issue #996\n  assert_error(\n      \"rule test {strings:$=/.{,}? /\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^D]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^D]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^F]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n       \"rule test { strings: $a = /abc[^F]/ condition: $a }\",\n       \"abcd\");\n}\nSIZED_STRING* yr_re_ast_extract_literal(\n    RE_AST* re_ast)\n{\n  SIZED_STRING* string;\n  RE_NODE* child;\n\n  int length = 0;\n\n  if (re_ast->root_node->type == RE_NODE_LITERAL)\n  {\n    length = 1;\n  }\n  else if (re_ast->root_node->type == RE_NODE_CONCAT)\n  {\n    child = re_ast->root_node->children_tail;\n\n    while (child != NULL && child->type == RE_NODE_LITERAL)\n    {\n      length++;\n      child = child->prev_sibling;\n    }\n\n    if (child != NULL)\n      return NULL;\n  }\n  else\n  {\n    return NULL;\n  }\n\n  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);\n\n  if (string == NULL)\n    return NULL;\n\n  string->length = length;\n\n  if (re_ast->root_node->type == RE_NODE_LITERAL)\n  {\n    string->c_string[0] = re_ast->root_node->value;\n  }\n  else\n  {\n    child = re_ast->root_node->children_tail;\n    while (child != NULL)\n    {\n      string->c_string[--length] = child->value;\n      child = child->prev_sibling;\n    }\n  }\n\n  return string;\n}\nstatic int _yr_parser_write_string(\n    const char* identifier,\n    int flags,\n    YR_COMPILER* compiler,\n    SIZED_STRING* str,\n    RE_AST* re_ast,\n    YR_STRING** string,\n    int* min_atom_quality,\n    int* num_atom)\n{\n  SIZED_STRING* literal_string;\n  YR_ATOM_LIST_ITEM* atom;\n  YR_ATOM_LIST_ITEM* atom_list = NULL;\n\n  int c, result;\n  int max_string_len;\n  bool free_literal = false;\n\n  *string = NULL;\n\n  result = yr_arena_allocate_struct(\n      compiler->strings_arena,\n      sizeof(YR_STRING),\n      (void**) string,\n      offsetof(YR_STRING, identifier),\n      offsetof(YR_STRING, string),\n      offsetof(YR_STRING, chained_to),\n      offsetof(YR_STRING, rule),\n      EOL);\n\n  if (result != ERROR_SUCCESS)\n    return result;\n\n  result = yr_arena_write_string(\n      compiler->sz_arena,\n      identifier,\n      &(*string)->identifier);\n\n  if (result != ERROR_SUCCESS)\n    return result;\n\n  if (flags & STRING_GFLAGS_HEXADECIMAL ||\n      flags & STRING_GFLAGS_REGEXP)\n  {\n    literal_string = yr_re_ast_extract_literal(re_ast);\n\n    if (literal_string != NULL)\n    {\n      flags |= STRING_GFLAGS_LITERAL;\n      free_literal = true;\n    }\n    else\n    {\n      // Non-literal strings can't be marked as fixed offset because once we\n      // find a string atom in the scanned data we don't know the offset where\n      // the string should start, as the non-literal strings can contain\n      // variable-length portions.\n\n      flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n    }\n  }\n  else\n  {\n    literal_string = str;\n    flags |= STRING_GFLAGS_LITERAL;\n  }\n\n  (*string)->g_flags = flags;\n  (*string)->chained_to = NULL;\n  (*string)->fixed_offset = UNDEFINED;\n  (*string)->rule = compiler->current_rule;\n\n  memset((*string)->matches, 0,\n         sizeof((*string)->matches));\n\n  memset((*string)->unconfirmed_matches, 0,\n         sizeof((*string)->unconfirmed_matches));\n\n  if (flags & STRING_GFLAGS_LITERAL)\n  {\n    (*string)->length = (uint32_t) literal_string->length;\n\n    result = yr_arena_write_data(\n        compiler->sz_arena,\n        literal_string->c_string,\n        literal_string->length + 1,   // +1 to include terminating NULL\n        (void**) &(*string)->string);\n\n    if (result == ERROR_SUCCESS)\n    {\n      result = yr_atoms_extract_from_string(\n          &compiler->atoms_config,\n          (uint8_t*) literal_string->c_string,\n          (int32_t) literal_string->length,\n          flags,\n          &atom_list,\n          min_atom_quality);\n    }\n  }\n  else\n  {\n    // Emit forwards code\n    result = yr_re_ast_emit_code(re_ast, compiler->re_code_arena, false);\n\n    // Emit backwards code\n    if (result == ERROR_SUCCESS)\n      result = yr_re_ast_emit_code(re_ast, compiler->re_code_arena, true);\n\n    if (result == ERROR_SUCCESS)\n      result = yr_atoms_extract_from_re(\n          &compiler->atoms_config,\n          re_ast,\n          flags,\n          &atom_list,\n          min_atom_quality);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    // Add the string to Aho-Corasick automaton.\n    result = yr_ac_add_string(\n        compiler->automaton,\n        *string,\n        atom_list,\n        compiler->matches_arena);\n  }\n\n  if (flags & STRING_GFLAGS_LITERAL)\n  {\n    if (flags & STRING_GFLAGS_WIDE)\n      max_string_len = (*string)->length * 2;\n    else\n      max_string_len = (*string)->length;\n\n    if (max_string_len <= YR_MAX_ATOM_LENGTH)\n      (*string)->g_flags |= STRING_GFLAGS_FITS_IN_ATOM;\n  }\n\n  atom = atom_list;\n  c = 0;\n\n  while (atom != NULL)\n  {\n    atom = atom->next;\n    c++;\n  }\n\n  (*num_atom) += c;\n\n  if (free_literal)\n    yr_free(literal_string);\n\n  if (atom_list != NULL)\n    yr_atoms_list_destroy(atom_list);\n\n  return result;\n}\nint yr_parser_reduce_string_declaration(\n    yyscan_t yyscanner,\n    int32_t string_flags,\n    const char* identifier,\n    SIZED_STRING* str,\n    YR_STRING** string)\n{\n  int min_atom_quality = YR_MIN_ATOM_QUALITY;\n  int min_atom_quality_aux = YR_MIN_ATOM_QUALITY;\n\n  int32_t min_gap;\n  int32_t max_gap;\n\n  char message[512];\n\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n  YR_STRING* aux_string;\n  YR_STRING* prev_string;\n\n  RE_AST* re_ast = NULL;\n  RE_AST* remainder_re_ast = NULL;\n\n  RE_ERROR re_error;\n\n  int result = ERROR_SUCCESS;\n\n  // Determine if a string with the same identifier was already defined\n  // by searching for the identifier in string_table.\n\n  *string = (YR_STRING*) yr_hash_table_lookup(\n      compiler->strings_table,\n      identifier,\n      NULL);\n\n  if (*string != NULL)\n  {\n    result = ERROR_DUPLICATED_STRING_IDENTIFIER;\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    goto _exit;\n  }\n\n  // Empty strings are not allowed\n\n  if (str->length == 0)\n  {\n    result = ERROR_EMPTY_STRING;\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    goto _exit;\n  }\n\n  if (str->flags & SIZED_STRING_FLAGS_NO_CASE)\n    string_flags |= STRING_GFLAGS_NO_CASE;\n\n  if (str->flags & SIZED_STRING_FLAGS_DOT_ALL)\n    string_flags |= STRING_GFLAGS_DOT_ALL;\n\n  if (strcmp(identifier,\"$\") == 0)\n    string_flags |= STRING_GFLAGS_ANONYMOUS;\n\n  if (!(string_flags & STRING_GFLAGS_WIDE) &&\n      !(string_flags & STRING_GFLAGS_XOR))\n    string_flags |= STRING_GFLAGS_ASCII;\n\n  // Hex strings are always handled as DOT_ALL regexps.\n\n  if (string_flags & STRING_GFLAGS_HEXADECIMAL)\n    string_flags |= STRING_GFLAGS_DOT_ALL;\n\n  // The STRING_GFLAGS_SINGLE_MATCH flag indicates that finding\n  // a single match for the string is enough. This is true in\n  // most cases, except when the string count (#) and string offset (@)\n  // operators are used. All strings are marked STRING_FLAGS_SINGLE_MATCH\n  // initially, and unmarked later if required.\n\n  string_flags |= STRING_GFLAGS_SINGLE_MATCH;\n\n  // The STRING_GFLAGS_FIXED_OFFSET indicates that the string doesn't\n  // need to be searched all over the file because the user is using the\n  // \"at\" operator. The string must be searched at a fixed offset in the\n  // file. All strings are marked STRING_GFLAGS_FIXED_OFFSET initially,\n  // and unmarked later if required.\n\n  string_flags |= STRING_GFLAGS_FIXED_OFFSET;\n\n  if (string_flags & STRING_GFLAGS_HEXADECIMAL ||\n      string_flags & STRING_GFLAGS_REGEXP)\n  {\n    if (string_flags & STRING_GFLAGS_HEXADECIMAL)\n      result = yr_re_parse_hex(str->c_string, &re_ast, &re_error);\n    else\n      result = yr_re_parse(str->c_string, &re_ast, &re_error);\n\n    if (result != ERROR_SUCCESS)\n    {\n      snprintf(\n          message,\n          sizeof(message),\n          \"invalid %s \\\"%s\\\": %s\",\n          (string_flags & STRING_GFLAGS_HEXADECIMAL) ?\n              \"hex string\" : \"regular expression\",\n          identifier,\n          re_error.message);\n\n      yr_compiler_set_error_extra_info(\n          compiler, message);\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_FAST_REGEXP)\n      string_flags |= STRING_GFLAGS_FAST_REGEXP;\n\n    // Regular expressions in the strings section can't mix greedy and ungreedy\n    // quantifiers like .* and .*?. That's because these regular expressions can\n    // be matched forwards and/or backwards depending on the atom found, and we\n    // need the regexp to be all-greedy or all-ungreedy to be able to properly\n    // calculate the length of the match.\n\n    if ((re_ast->flags & RE_FLAGS_GREEDY) &&\n        (re_ast->flags & RE_FLAGS_UNGREEDY))\n    {\n      result = ERROR_INVALID_REGULAR_EXPRESSION;\n\n      yr_compiler_set_error_extra_info(compiler,\n          \"greedy and ungreedy quantifiers can't be mixed in a regular \"\n          \"expression\");\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_GREEDY)\n      string_flags |= STRING_GFLAGS_GREEDY_REGEXP;\n\n    if (yr_re_ast_contains_dot_star(re_ast))\n    {\n      yywarning(\n          yyscanner,\n          \"%s contains .* or .+, consider using .{N} or .{1,N} with a reasonable value for N\",\n          identifier);\n    }\n\n    if (compiler->re_ast_callback != NULL)\n    {\n      compiler->re_ast_callback(\n          compiler->current_rule,\n          identifier,\n          re_ast,\n          compiler->re_ast_clbk_user_data);\n    }\n\n    result = yr_re_ast_split_at_chaining_point(\n        re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    result = _yr_parser_write_string(\n        identifier,\n        string_flags,\n        compiler,\n        NULL,\n        re_ast,\n        string,\n        &min_atom_quality,\n        &compiler->current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    if (remainder_re_ast != NULL)\n    {\n      (*string)->g_flags |= STRING_GFLAGS_CHAIN_TAIL | STRING_GFLAGS_CHAIN_PART;\n      (*string)->chain_gap_min = min_gap;\n      (*string)->chain_gap_max = max_gap;\n    }\n\n    // Use \"aux_string\" from now on, we want to keep the value of \"string\"\n    // because it will returned.\n\n    aux_string = *string;\n\n    while (remainder_re_ast != NULL)\n    {\n      // Destroy regexp pointed by 're_ast' before yr_re_split_at_chaining_point\n      // overwrites 're_ast' with another value.\n\n      yr_re_ast_destroy(re_ast);\n\n      result = yr_re_ast_split_at_chaining_point(\n          remainder_re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      prev_string = aux_string;\n\n      result = _yr_parser_write_string(\n          identifier,\n          string_flags,\n          compiler,\n          NULL,\n          re_ast,\n          &aux_string,\n          &min_atom_quality_aux,\n          &compiler->current_rule->num_atoms);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      if (min_atom_quality_aux < min_atom_quality)\n        min_atom_quality = min_atom_quality_aux;\n\n      aux_string->g_flags |= STRING_GFLAGS_CHAIN_PART;\n      aux_string->chain_gap_min = min_gap;\n      aux_string->chain_gap_max = max_gap;\n\n      prev_string->chained_to = aux_string;\n\n      // prev_string is now chained to aux_string, an string chained\n      // to another one can't have a fixed offset, only the head of the\n      // string chain can have a fixed offset.\n\n      prev_string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n    }\n  }\n  else\n  {\n    result = _yr_parser_write_string(\n        identifier,\n        string_flags,\n        compiler,\n        str,\n        NULL,\n        string,\n        &min_atom_quality,\n        &compiler->current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (!STRING_IS_ANONYMOUS(*string))\n  {\n    result = yr_hash_table_add(\n      compiler->strings_table,\n      identifier,\n      NULL,\n      *string);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (min_atom_quality < compiler->atoms_config.quality_warning_threshold)\n  {\n    yywarning(\n        yyscanner,\n        \"%s in rule %s is slowing down scanning\",\n        (*string)->identifier,\n        compiler->current_rule->identifier);\n  }\n\n_exit:\n\n  if (re_ast != NULL)\n    yr_re_ast_destroy(re_ast);\n\n  if (remainder_re_ast != NULL)\n    yr_re_ast_destroy(remainder_re_ast);\n\n  return result;\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  YR_RULES* rules;\n  YR_COMPILER* compiler;\n\n  char* buffer = (char*) malloc(size + 1);\n\n  if (!buffer)\n    return 0;\n\n  strncpy(buffer, (const char *) data, size);\n  buffer[size] = 0;\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    free(buffer);\n    return 0;\n  }\n\n  if (yr_compiler_add_string(compiler, (const char*) buffer, NULL) == 0)\n  {\n    if (yr_compiler_get_rules(compiler, &rules) == ERROR_SUCCESS)\n      yr_rules_destroy(rules);\n  }\n\n  yr_compiler_destroy(compiler);\n  free(buffer);\n\n  return 0;\n}\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  if (SMR.IsClient())\n    SMR.WriteByteArray(Data, Size);\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (EF->__msan_unpoison)\n    EF->__msan_unpoison(DataCopy, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  {\n    ScopedEnableMsanInterceptorChecks S;\n    AllocTracer.Start(Options.TraceMalloc);\n    UnitStartTime = system_clock::now();\n    TPC.ResetMaps();\n    RunningUserCallback = true;\n    int Res = CB(DataCopy, Size);\n    RunningUserCallback = false;\n    UnitStopTime = system_clock::now();\n    (void)Res;\n    assert(Res == 0);\n    HasMoreMallocsThanFrees = AllocTracer.Stop();\n  }\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  if (EF->__msan_scoped_disable_interceptor_checks)\n    EF->__msan_scoped_disable_interceptor_checks();\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.LenControl = Flags.len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.ReduceDepth = Flags.reduce_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  Options.MallocLimitMb = Flags.malloc_limit_mb;\n  if (!Options.MallocLimitMb)\n    Options.MallocLimitMb = Options.RssLimitMb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  Options.PrintUnstableStats = Flags.print_unstable_stats;\n  if (Flags.handle_unstable == TracePC::MinUnstable ||\n      Flags.handle_unstable == TracePC::ZeroUnstable)\n    Options.HandleUnstable = Flags.handle_unstable;\n  Options.DumpCoverage = Flags.dump_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n  if (Flags.focus_function)\n    Options.FocusFunction = Flags.focus_function;\n  if (Flags.data_flow_trace)\n    Options.DataFlowTrace = Flags.data_flow_trace;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n#if 0  // deprecated, to be removed.\n  if (auto Name = Flags.run_equivalence_server) {\n    SMR.Destroy(Name);\n    if (!SMR.Create(Name)) {\n       Printf(\"ERROR: can't create shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE SERVER UP\\n\");\n    while (true) {\n      SMR.WaitClient();\n      size_t Size = SMR.ReadByteArraySize();\n      SMR.WriteByteArray(nullptr, 0);\n      const Unit tmp(SMR.GetByteArray(), SMR.GetByteArray() + Size);\n      F->ExecuteCallback(tmp.data(), tmp.size());\n      SMR.PostServer();\n    }\n    return 0;\n  }\n\n  if (auto Name = Flags.use_equivalence_server) {\n    if (!SMR.Open(Name)) {\n      Printf(\"ERROR: can't open shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE CLIENT UP\\n\");\n  }\n#endif\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.merge) {\n    F->CrashResistantMerge(Args, *Inputs,\n                           Flags.load_coverage_summary,\n                           Flags.save_coverage_summary,\n                           Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis succeeded\\n\");\n    exit(0);\n  }\n\n  F->Loop(*Inputs);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\n__attribute__((visibility(\"default\"))) int main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}",
    "target": 0,
    "idx": 2011753
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "PIX *\npixReadMemBmp(const l_uint8  *cdata,\n              size_t          size)\n{\nl_uint8    pel[4];\nl_uint8   *cmapBuf, *fdata, *data;\nl_int16    bftype, depth, d;\nl_int32    offset, ihbytes, width, height, height_neg, xres, yres;\nl_int32    compression, imagebytes, fdatabytes, cmapbytes, ncolors, maxcolors;\nl_int32    fdatabpl, extrabytes, pixWpl, pixBpl, i, j, k;\nl_uint32  *line, *pixdata, *pword;\nl_int64    npixels;\nBMP_FH    *bmpfh;\n#if defined(__GNUC__)\nBMP_HEADER *bmph;\n#define bmpih (&bmph->bmpih)\n#else\nBMP_IH    *bmpih;\n#endif\nPIX       *pix, *pix1;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixReadMemBmp\");\n\n    if (!cdata)\n        return (PIX *)ERROR_PTR(\"cdata not defined\", procName, NULL);\n    if (size < sizeof(BMP_FH) + sizeof(BMP_IH))\n        return (PIX *)ERROR_PTR(\"bmf size error\", procName, NULL);\n\n        /* Verify this is an uncompressed bmp */\n    bmpfh = (BMP_FH *)cdata;\n    bftype = bmpfh->bfType[0] + ((l_int32)bmpfh->bfType[1] << 8);\n    if (bftype != BMP_ID)\n        return (PIX *)ERROR_PTR(\"not bmf format\", procName, NULL);\n#if defined(__GNUC__)\n    bmph = (BMP_HEADER *)bmpfh;\n#else\n    bmpih = (BMP_IH *)(cdata + BMP_FHBYTES);\n#endif\n    compression = convertOnBigEnd32(bmpih->biCompression);\n    if (compression != 0)\n        return (PIX *)ERROR_PTR(\"cannot read compressed BMP files\",\n                                procName, NULL);\n\n        /* Find the offset from the beginning of the file to the image data */\n    offset = bmpfh->bfOffBits[0];\n    offset += (l_int32)bmpfh->bfOffBits[1] << 8;\n    offset += (l_int32)bmpfh->bfOffBits[2] << 16;\n    offset += (l_uint32)bmpfh->bfOffBits[3] << 24;\n\n        /* Read the remaining useful data in the infoheader.\n         * Note that the first 4 bytes give the infoheader size. */\n    ihbytes = convertOnBigEnd32(*(l_uint32 *)(bmpih));\n    width = convertOnBigEnd32(bmpih->biWidth);\n    height = convertOnBigEnd32(bmpih->biHeight);\n    depth = convertOnBigEnd16(bmpih->biBitCount);\n    imagebytes = convertOnBigEnd32(bmpih->biSizeImage);\n    xres = convertOnBigEnd32(bmpih->biXPelsPerMeter);\n    yres = convertOnBigEnd32(bmpih->biYPelsPerMeter);\n\n        /* Some sanity checking.  We impose limits on the image\n         * dimensions, resolution and number of pixels.  We make sure the\n         * file is the correct size to hold the amount of uncompressed data\n         * that is specified in the header.  The number of colormap\n         * entries is checked: it can be either 0 (no cmap) or some\n         * number between 2 and 256.\n         * Note that the imagebytes for uncompressed images is either\n         * 0 or the size of the file data.  (The fact that it can\n         * be 0 is perhaps some legacy glitch). */\n    if (width < 1)\n        return (PIX *)ERROR_PTR(\"width < 1\", procName, NULL);\n    if (width > L_MAX_ALLOWED_WIDTH)\n        return (PIX *)ERROR_PTR(\"width too large\", procName, NULL);\n    if (height == 0 || height < -L_MAX_ALLOWED_HEIGHT ||\n        height > L_MAX_ALLOWED_HEIGHT)\n        return (PIX *)ERROR_PTR(\"invalid height\", procName, NULL);\n    if (xres < 0 || xres > L_MAX_ALLOWED_RES ||\n        yres < 0 || yres > L_MAX_ALLOWED_RES)\n        return (PIX *)ERROR_PTR(\"invalid resolution\", procName, NULL);\n    height_neg = 0;\n    if (height < 0) {\n        height_neg = 1;\n        height = -height;\n    }\n    if (ihbytes != 40 && ihbytes != 108 && ihbytes != 124) {\n        L_ERROR(\"invalid ihbytes = %d; not in {40, 108, 124}\\n\",\n                procName, ihbytes);\n        return NULL;\n    }\n    npixels = 1LL * width * height;\n    if (npixels > L_MAX_ALLOWED_PIXELS)\n        return (PIX *)ERROR_PTR(\"npixels too large\", procName, NULL);\n    if (depth != 1 && depth != 2 && depth != 4 && depth != 8 &&\n        depth != 16 && depth != 24 && depth != 32) {\n        L_ERROR(\"invalid depth = %d; not in {1, 2, 4, 8, 16, 24, 32}\\n\",\n                procName, depth);\n        return NULL;\n    }\n    fdatabpl = 4 * ((1LL * width * depth + 31)/32);\n    fdatabytes = fdatabpl * height;\n    if (imagebytes != 0 && imagebytes != fdatabytes) {\n        L_ERROR(\"invalid imagebytes = %d; not equal to fdatabytes = %d\\n\",\n                procName, imagebytes, fdatabytes);\n        return NULL;\n    }\n\n        /* In the original spec, BITMAPINFOHEADER is 40 bytes.\n         * There have been a number of revisions, to capture more information.\n         * For example, the fifth version, BITMAPV5HEADER, adds 84 bytes\n         * of ICC color profiles.  We use the size of the infoheader\n         * to accommodate these newer formats. */\n    cmapbytes = offset - BMP_FHBYTES - ihbytes;\n    ncolors = cmapbytes / sizeof(RGBA_QUAD);\n    if (ncolors < 0 || ncolors == 1)\n        return (PIX *)ERROR_PTR(\"invalid: cmap size < 0 or 1\", procName, NULL);\n    if (ncolors > 0 && depth > 8)\n        return (PIX *)ERROR_PTR(\"can't have cmap for d > 8\", procName, NULL);\n    maxcolors = (depth <= 8) ? 1 << depth : 256;\n    if (ncolors > maxcolors) {\n        L_ERROR(\"cmap too large for depth %d: ncolors = %d > maxcolors = %d\\n\",\n                procName, depth, ncolors, maxcolors);\n        return NULL;\n    }\n    if (size != 1LL * offset + 1LL * fdatabytes)\n        return (PIX *)ERROR_PTR(\"size incommensurate with image data\",\n                                procName,NULL);\n\n        /* Handle the colormap */\n    cmapBuf = NULL;\n    if (ncolors > 0) {\n        if ((cmapBuf = (l_uint8 *)LEPT_CALLOC(ncolors, sizeof(RGBA_QUAD)))\n                 == NULL)\n            return (PIX *)ERROR_PTR(\"cmapBuf alloc fail\", procName, NULL );\n\n            /* Read the colormap entry data from bmp. The RGBA_QUAD colormap\n             * entries are used for both bmp and leptonica colormaps. */\n        memcpy(cmapBuf, cdata + BMP_FHBYTES + ihbytes,\n               ncolors * sizeof(RGBA_QUAD));\n    }\n\n        /* Make a 32 bpp pix if depth is 24 bpp */\n    d = (depth == 24) ? 32 : depth;\n    if ((pix = pixCreate(width, height, d)) == NULL) {\n        LEPT_FREE(cmapBuf);\n        return (PIX *)ERROR_PTR( \"pix not made\", procName, NULL);\n    }\n    pixSetXRes(pix, (l_int32)((l_float32)xres / 39.37 + 0.5));  /* to ppi */\n    pixSetYRes(pix, (l_int32)((l_float32)yres / 39.37 + 0.5));  /* to ppi */\n    pixSetInputFormat(pix, IFF_BMP);\n    pixWpl = pixGetWpl(pix);\n    pixBpl = 4 * pixWpl;\n\n        /* Convert the bmp colormap to a pixcmap */\n    cmap = NULL;\n    if (ncolors > 0) {  /* import the colormap to the pix cmap */\n        cmap = pixcmapCreate(L_MIN(d, 8));\n        LEPT_FREE(cmap->array);  /* remove generated cmap array */\n        cmap->array  = (void *)cmapBuf;  /* and replace */\n        cmap->n = L_MIN(ncolors, 256);\n        for (i = 0; i < cmap->n; i++)   /* set all colors opaque */\n            pixcmapSetAlpha (cmap, i, 255);\n    }\n    pixSetColormap(pix, cmap);\n\n        /* Acquire the image data.  Image origin for bmp is at lower right. */\n    fdata = (l_uint8 *)cdata + offset;  /* start of the bmp image data */\n    pixdata = pixGetData(pix);\n    if (depth != 24) {  /* typ. 1 or 8 bpp */\n        data = (l_uint8 *)pixdata + pixBpl * (height - 1);\n        for (i = 0; i < height; i++) {\n            memcpy(data, fdata, fdatabpl);\n            fdata += fdatabpl;\n            data -= pixBpl;\n        }\n    } else {  /*  24 bpp file; 32 bpp pix\n             *  Note: for bmp files, pel[0] is blue, pel[1] is green,\n             *  and pel[2] is red.  This is opposite to the storage\n             *  in the pix, which puts the red pixel in the 0 byte,\n             *  the green in the 1 byte and the blue in the 2 byte.\n             *  Note also that all words are endian flipped after\n             *  assignment on L_LITTLE_ENDIAN platforms.\n             *\n             *  We can then make these assignments for little endians:\n             *      SET_DATA_BYTE(pword, 1, pel[0]);      blue\n             *      SET_DATA_BYTE(pword, 2, pel[1]);      green\n             *      SET_DATA_BYTE(pword, 3, pel[2]);      red\n             *  This looks like:\n             *          3  (R)     2  (G)        1  (B)        0\n             *      |-----------|------------|-----------|-----------|\n             *  and after byte flipping:\n             *           3          2  (B)     1  (G)        0  (R)\n             *      |-----------|------------|-----------|-----------|\n             *\n             *  For big endians we set:\n             *      SET_DATA_BYTE(pword, 2, pel[0]);      blue\n             *      SET_DATA_BYTE(pword, 1, pel[1]);      green\n             *      SET_DATA_BYTE(pword, 0, pel[2]);      red\n             *  This looks like:\n             *          0  (R)     1  (G)        2  (B)        3\n             *      |-----------|------------|-----------|-----------|\n             *  so in both cases we get the correct assignment in the PIX.\n             *\n             *  Can we do a platform-independent assignment?\n             *  Yes, set the bytes without using macros:\n             *      *((l_uint8 *)pword) = pel[2];           red\n             *      *((l_uint8 *)pword + 1) = pel[1];       green\n             *      *((l_uint8 *)pword + 2) = pel[0];       blue\n             *  For little endians, before flipping, this looks again like:\n             *          3  (R)     2  (G)        1  (B)        0\n             *      |-----------|------------|-----------|-----------|\n             */\n        extrabytes = fdatabpl - 3 * width;\n        line = pixdata + pixWpl * (height - 1);\n        for (i = 0; i < height; i++) {\n            for (j = 0; j < width; j++) {\n                pword = line + j;\n                memcpy(&pel, fdata, 3);\n                fdata += 3;\n                *((l_uint8 *)pword + COLOR_RED) = pel[2];\n                *((l_uint8 *)pword + COLOR_GREEN) = pel[1];\n                *((l_uint8 *)pword + COLOR_BLUE) = pel[0];\n                    /* should not use alpha byte, but for buggy readers,\n                     * set it to opaque  */\n                *((l_uint8 *)pword + L_ALPHA_CHANNEL) = 255;\n            }\n            if (extrabytes) {\n                for (k = 0; k < extrabytes; k++) {\n                    memcpy(&pel, fdata, 1);\n                    fdata++;\n                }\n            }\n            line -= pixWpl;\n        }\n    }\n\n    pixEndianByteSwap(pix);\n    if (height_neg)\n        pixFlipTB(pix, pix);\n\n        /* ----------------------------------------------\n         * The bmp colormap determines the values of black\n         * and white pixels for binary in the following way:\n         * (a) white = 0 [255], black = 1 [0]\n         *      255, 255, 255, 255, 0, 0, 0, 255\n         * (b) black = 0 [0], white = 1 [255]\n         *      0, 0, 0, 255, 255, 255, 255, 255\n         * We have no need for a 1 bpp pix with a colormap!\n         * Note: the alpha component here is 255 (opaque)\n         * ---------------------------------------------- */\n    if (depth == 1 && cmap) {\n        pix1 = pixRemoveColormap(pix, REMOVE_CMAP_TO_BINARY);\n        pixDestroy(&pix);\n        pix = pix1;  /* rename */\n    }\n\n    return pix;\n}\nPIX *\npixReadMem(const l_uint8  *data,\n           size_t          size)\n{\nl_int32   format, valid;\nPIX      *pix;\nPIXCMAP  *cmap;\n\n    PROCNAME(\"pixReadMem\");\n\n    if (!data)\n        return (PIX *)ERROR_PTR(\"data not defined\", procName, NULL);\n    if (size < 12)\n        return (PIX *)ERROR_PTR(\"size < 12\", procName, NULL);\n    pix = NULL;\n\n    findFileFormatBuffer(data, &format);\n    switch (format)\n    {\n    case IFF_BMP:\n        if ((pix = pixReadMemBmp(data, size)) == NULL )\n            return (PIX *)ERROR_PTR( \"bmp: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_JFIF_JPEG:\n        if ((pix = pixReadMemJpeg(data, size, 0, 1, NULL, 0)) == NULL)\n            return (PIX *)ERROR_PTR( \"jpeg: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_PNG:\n        if ((pix = pixReadMemPng(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"png: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_TIFF:\n    case IFF_TIFF_PACKBITS:\n    case IFF_TIFF_RLE:\n    case IFF_TIFF_G3:\n    case IFF_TIFF_G4:\n    case IFF_TIFF_LZW:\n    case IFF_TIFF_ZIP:\n            /* Reading page 0 by default */\n        if ((pix = pixReadMemTiff(data, size, 0)) == NULL)\n            return (PIX *)ERROR_PTR(\"tiff: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_PNM:\n        if ((pix = pixReadMemPnm(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"pnm: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_GIF:\n        if ((pix = pixReadMemGif(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"gif: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_JP2:\n        if ((pix = pixReadMemJp2k(data, size, 1, NULL, 0, 0)) == NULL)\n            return (PIX *)ERROR_PTR(\"jp2k: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_WEBP:\n        if ((pix = pixReadMemWebP(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"webp: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_PS:\n        L_ERROR(\"PostScript reading is not supported\\n\", procName);\n        return NULL;\n\n    case IFF_LPDF:\n        L_ERROR(\"Pdf reading is not supported\\n\", procName);\n        return NULL;\n\n    case IFF_SPIX:\n        if ((pix = pixReadMemSpix(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"spix: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_UNKNOWN:\n        return (PIX *)ERROR_PTR(\"Unknown format: no pix returned\",\n                procName, NULL);\n        break;\n    }\n\n        /* Set the input format.  For tiff reading from memory we lose\n         * the actual input format; for 1 bpp, default to G4.  Also\n         * verify that the colormap is valid.  */\n    if (pix) {\n        if (format == IFF_TIFF && pixGetDepth(pix) == 1)\n            format = IFF_TIFF_G4;\n        pixSetInputFormat(pix, format);\n        if ((cmap = pixGetColormap(pix))) {\n            pixcmapIsValid(cmap, &valid);\n            if (!valid) {\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"invalid colormap\", procName, NULL);\n            }\n        }\n        pixSetPadBits(pix, 0);\n    }\n    return pix;\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n  const int16_t angle = ReadInt16(&data, &size);\n  const int16_t x_center = ReadInt16(&data, &size);\n  const int16_t y_center = ReadInt16(&data, &size);\n\n  // Check for pnm format; this can cause timeouts.\n  // The format checker requires at least 12 bytes.\n  if (size < 12) return EXIT_SUCCESS;\n  int format;\n  findFileFormatBuffer(data, &format);\n  if (format == IFF_PNM) return EXIT_SUCCESS;\n\n  Pix* pix = pixReadMem(reinterpret_cast<const unsigned char*>(data), size);\n  if (pix == nullptr) {\n    return EXIT_SUCCESS;\n  }\n\n  // Never in production\n  if (DebugOutput) {\n    L_INFO(\"w = %d, h = %d, d = %d\\n\", \"fuzzer\",\n           pixGetWidth(pix), pixGetHeight(pix), pixGetDepth(pix));\n  }\n\n  constexpr float deg2rad = M_PI / 180.;\n  Pix* pix_rotated = pixRotateShear(pix, x_center, y_center, deg2rad * angle,\n                                    L_BRING_IN_WHITE);\n  if (pix_rotated) {\n    pixDestroy(&pix_rotated);\n  }\n\n  pixDestroy(&pix);\n  return EXIT_SUCCESS;\n}",
    "target": 0,
    "idx": 2019723
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "R_API void r_core_task_decref (RCoreTask *task) {\n\tif (!task) {\n\t\treturn;\n\t}\n\tTASK_SIGSET_T old_sigset;\n\tRCore *core = task->core;\n\ttasks_lock_enter (core, &old_sigset);\n\ttask->refcount--;\n\tif (task->refcount <= 0) {\n\t\ttask_free (task);\n\t}\n\ttasks_lock_leave (core, &old_sigset);\n}\nR_API void r_list_delete(RList *list, RListIter *iter) {\n\tr_return_if_fail (list && iter);\n\tr_list_split_iter (list, iter);\n\tif (list->free && iter->data) {\n\t\tlist->free (iter->data);\n\t}\n\titer->data = NULL;\n\tR_FREE (iter);\n}\nR_API void r_list_purge(RList *list) {\n\tRListIter *it;\n\n\tr_return_if_fail (list);\n\n\tit = list->head;\n\twhile (it) {\n\t\tRListIter *next = it->n;\n\t\tr_list_delete (list, it);\n\t\tit = next;\n\t}\n\tlist->head = list->tail = NULL;\n}\nR_API void r_list_free(RList *list) {\n\tif (list) {\n\t\tr_list_purge (list);\n\t\tR_FREE (list);\n\t}\n}\nR_API RCore *r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn NULL;\n\t}\n\tr_core_task_break_all (c);\n\tr_core_task_join (c, NULL, -1);\n\tr_core_wait (c);\n\t/* TODO: it leaks as shit */\n\t//update_sdb (c);\n\t// avoid double free\n\tr_core_free_autocomplete (c);\n\tr_event_free (c->ev);\n\tR_FREE (c->cmdlog);\n\tr_th_lock_free (c->lock);\n\tR_FREE (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tR_FREE (c->panels_tmpcfg);\n\tR_FREE (c->cmdqueue);\n\tR_FREE (c->lastcmd);\n\tr_list_free (c->visual.tabs);\n\tR_FREE (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\t// TODO: sync or not? sdb_sync (c->sdb);\n\t// TODO: sync all dbs?\n\t//r_core_file_free (c->file);\n\t//c->file = NULL;\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_list_free (c->tasks);\n\tr_list_free (c->tasks_queue);\n\tr_list_free (c->oneshot_queue);\n\tr_th_lock_free (c->tasks_lock);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tc->assembler = r_asm_free (c->assembler);\n\tc->print = r_print_free (c->print);\n\tc->bin = r_bin_free (c->bin); // XXX segfaults rabin2 -c\n\tc->lang = r_lang_free (c->lang); // XXX segfaults\n\tc->dbg = r_debug_free (c->dbg);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\t/* after r_config_free, the value of I.teefile is trashed */\n\t/* rconfig doesnt knows how to deinitialize vars, so we\n\tshould probably need to add a r_config_free_payload callback */\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; // HACK\n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tR_FREE (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tR_FREE (c->times);\n\treturn NULL;\n}\nR_API RCore *r_core_free(RCore *c) {\n\t// must wait all threads first\n\tif (c) {\n\t\tr_core_fini (c);\n\t\tfree (c);\n\t}\n\treturn NULL;\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n\tRCore *r;\n\tchar path[128];\n\n\tr = r_core_new();\n\n\tr_core_cmdf(r, \"o malloc://%d\", Size);\n\tr_io_write_at(r->io, 0, Data, Size);\n\n\tr_core_cmd0(r, \"oba 0\");\n\tr_core_cmd0(r, \"ia\");\n\n\tr_core_free(r);\n\treturn 0;\n}\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  if (SMR.IsClient())\n    SMR.WriteByteArray(Data, Size);\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (EF->__msan_unpoison)\n    EF->__msan_unpoison(DataCopy, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  {\n    ScopedEnableMsanInterceptorChecks S;\n    AllocTracer.Start(Options.TraceMalloc);\n    UnitStartTime = system_clock::now();\n    TPC.ResetMaps();\n    RunningUserCallback = true;\n    int Res = CB(DataCopy, Size);\n    RunningUserCallback = false;\n    UnitStopTime = system_clock::now();\n    (void)Res;\n    assert(Res == 0);\n    HasMoreMallocsThanFrees = AllocTracer.Stop();\n  }\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  if (EF->__msan_scoped_disable_interceptor_checks)\n    EF->__msan_scoped_disable_interceptor_checks();\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.LenControl = Flags.len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.ReduceDepth = Flags.reduce_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  Options.MallocLimitMb = Flags.malloc_limit_mb;\n  if (!Options.MallocLimitMb)\n    Options.MallocLimitMb = Options.RssLimitMb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  Options.PrintUnstableStats = Flags.print_unstable_stats;\n  if (Flags.handle_unstable == TracePC::MinUnstable ||\n      Flags.handle_unstable == TracePC::ZeroUnstable)\n    Options.HandleUnstable = Flags.handle_unstable;\n  Options.DumpCoverage = Flags.dump_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n  if (Flags.focus_function)\n    Options.FocusFunction = Flags.focus_function;\n  if (Flags.data_flow_trace)\n    Options.DataFlowTrace = Flags.data_flow_trace;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n#if 0  // deprecated, to be removed.\n  if (auto Name = Flags.run_equivalence_server) {\n    SMR.Destroy(Name);\n    if (!SMR.Create(Name)) {\n       Printf(\"ERROR: can't create shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE SERVER UP\\n\");\n    while (true) {\n      SMR.WaitClient();\n      size_t Size = SMR.ReadByteArraySize();\n      SMR.WriteByteArray(nullptr, 0);\n      const Unit tmp(SMR.GetByteArray(), SMR.GetByteArray() + Size);\n      F->ExecuteCallback(tmp.data(), tmp.size());\n      SMR.PostServer();\n    }\n    return 0;\n  }\n\n  if (auto Name = Flags.use_equivalence_server) {\n    if (!SMR.Open(Name)) {\n      Printf(\"ERROR: can't open shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE CLIENT UP\\n\");\n  }\n#endif\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.merge) {\n    F->CrashResistantMerge(Args, *Inputs,\n                           Flags.load_coverage_summary,\n                           Flags.save_coverage_summary,\n                           Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis succeeded\\n\");\n    exit(0);\n  }\n\n  F->Loop(*Inputs);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\n__attribute__((visibility(\"default\"))) int main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}",
    "target": 0,
    "idx": 2011359
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "int gx_device_subclass(gx_device *dev_to_subclass, gx_device *new_prototype, unsigned int private_data_size)\n{\n    gx_device *child_dev;\n    void *psubclass_data;\n    gs_memory_struct_type_t *a_std, *b_std = NULL;\n    int dynamic = dev_to_subclass->stype_is_dynamic;\n    char *ptr, *ptr1;\n\n    /* If this happens we are stuffed, as there is no way to get hold\n     * of the original device's stype structure, which means we cannot\n     * allocate a replacement structure. Abort if so.\n     * Also abort if the new_prototype device struct is too large.\n     */\n    if (!dev_to_subclass->stype ||\n        dev_to_subclass->stype->ssize < new_prototype->params_size)\n        return_error(gs_error_VMerror);\n\n    /* We make a 'stype' structure for our new device, and copy the old stype into it\n     * This means our new device will always have the 'stype_is_dynamic' flag set\n     */\n    a_std = (gs_memory_struct_type_t *)\n        gs_alloc_bytes_immovable(dev_to_subclass->memory->non_gc_memory, sizeof(*a_std),\n                                 \"gs_device_subclass(stype)\");\n    if (!a_std)\n        return_error(gs_error_VMerror);\n    *a_std = *dev_to_subclass->stype;\n    a_std->ssize = dev_to_subclass->params_size;\n\n    if (!dynamic) {\n        b_std = (gs_memory_struct_type_t *)\n            gs_alloc_bytes_immovable(dev_to_subclass->memory->non_gc_memory, sizeof(*b_std),\n                                     \"gs_device_subclass(stype)\");\n        if (!b_std)\n            return_error(gs_error_VMerror);\n    }\n\n    /* Allocate a device structure for the new child device */\n    child_dev = gs_alloc_struct_immovable(dev_to_subclass->memory->stable_memory, gx_device, a_std,\n                                        \"gs_device_subclass(device)\");\n    if (child_dev == 0) {\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, a_std, \"gs_device_subclass(stype)\");\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, b_std, \"gs_device_subclass(stype)\");\n        return_error(gs_error_VMerror);\n    }\n\n    /* Make sure all methods are filled in, note this won't work for a forwarding device\n     * so forwarding devices will have to be filled in before being subclassed. This doesn't fill\n     * in the fill_rectangle proc, that gets done in the ultimate device's open proc.\n     */\n    gx_device_fill_in_procs(dev_to_subclass);\n    memcpy(child_dev, dev_to_subclass, dev_to_subclass->stype->ssize);\n    child_dev->stype = a_std;\n    child_dev->stype_is_dynamic = 1;\n\n    /* At this point, the only counted reference to the child is from its parent, and we need it to use the right allocator */\n    rc_init(child_dev, dev_to_subclass->memory->stable_memory, 1);\n\n    psubclass_data = (void *)gs_alloc_bytes(dev_to_subclass->memory->non_gc_memory, private_data_size, \"subclass memory for subclassing device\");\n    if (psubclass_data == 0){\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, b_std, \"gs_device_subclass(stype)\");\n        /* We *don't* want to run the finalize routine. This would free the stype and\n         * properly handle the icc_struct and PageList, but for devices with a custom\n         * finalize (eg psdcmyk) it might also free memory it had allocated, and we're\n         * still pointing at that memory in the parent.\n         */\n        a_std->finalize = NULL;\n        gs_set_object_type(dev_to_subclass->memory->stable_memory, child_dev, a_std);\n        gs_free_object(dev_to_subclass->memory->stable_memory, child_dev, \"free subclass memory for subclassing device\");\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, a_std, \"gs_device_subclass(stype)\");\n        return_error(gs_error_VMerror);\n    }\n    memset(psubclass_data, 0x00, private_data_size);\n\n    gx_copy_device_procs(dev_to_subclass, child_dev, new_prototype);\n    dev_to_subclass->finalize = new_prototype->finalize;\n    dev_to_subclass->dname = new_prototype->dname;\n    if (dev_to_subclass->icc_struct)\n        rc_increment(dev_to_subclass->icc_struct);\n    if (dev_to_subclass->PageList)\n        rc_increment(dev_to_subclass->PageList);\n    if (dev_to_subclass->NupControl)\n        rc_increment(dev_to_subclass->NupControl);\n\n    dev_to_subclass->page_procs = new_prototype->page_procs;\n    gx_subclass_fill_in_page_procs(dev_to_subclass);\n\n    /* In case the new device we're creating has already been initialised, copy\n     * its additional data.\n     */\n    ptr = ((char *)dev_to_subclass) + sizeof(gx_device);\n    ptr1 = ((char *)new_prototype) + sizeof(gx_device);\n    memcpy(ptr, ptr1, new_prototype->params_size - sizeof(gx_device));\n\n    /* If the original device's stype structure was dynamically allocated, we need\n     * to 'fixup' the contents, it's procs need to point to the new device's procs\n     * for instance.\n     */\n    if (dynamic) {\n        if (new_prototype->stype) {\n            b_std = (gs_memory_struct_type_t *)dev_to_subclass->stype;\n            *b_std = *new_prototype->stype;\n            b_std->ssize = a_std->ssize;\n            dev_to_subclass->stype_is_dynamic = 1;\n        } else {\n            gs_free_const_object(child_dev->memory->non_gc_memory, dev_to_subclass->stype,\n                             \"unsubclass\");\n            dev_to_subclass->stype = NULL;\n            b_std = (gs_memory_struct_type_t *)new_prototype->stype;\n            dev_to_subclass->stype_is_dynamic = 0;\n        }\n    }\n    else {\n        *b_std = *new_prototype->stype;\n        b_std->ssize = a_std->ssize;\n        dev_to_subclass->stype_is_dynamic = 1;\n    }\n    dev_to_subclass->stype = b_std;\n    /* We have to patch up the \"type\" parameters that the memory manage/garbage\n     * collector will use, as well.\n     */\n    gs_set_object_type(child_dev->memory, dev_to_subclass, b_std);\n\n    dev_to_subclass->subclass_data = psubclass_data;\n    dev_to_subclass->child = child_dev;\n    if (child_dev->parent) {\n        dev_to_subclass->parent = child_dev->parent;\n        child_dev->parent->child = dev_to_subclass;\n    }\n    if (child_dev->child) {\n        child_dev->child->parent = child_dev;\n    }\n    child_dev->parent = dev_to_subclass;\n\n    return 0;\n}\nvoid gx_device_unsubclass(gx_device *dev)\n{\n    generic_subclass_data *psubclass_data;\n    gx_device *parent, *child;\n    gs_memory_struct_type_t *a_std = 0, *b_std = 0;\n    int dynamic, ref_count;\n    gs_memory_t *rcmem;\n\n    /* This should not happen... */\n    if (!dev)\n        return;\n\n    ref_count = dev->rc.ref_count;\n    rcmem = dev->rc.memory;\n\n    child = dev->child;\n    psubclass_data = (generic_subclass_data *)dev->subclass_data;\n    parent = dev->parent;\n    dynamic = dev->stype_is_dynamic;\n\n    /* We need to account for the fact that we are removing ourselves from\n     * the device chain after a clist device has been pushed, due to a\n     * compositor action. Since we patched the clist 'composite'\n     * method (and target device) when it was pushed.\n     * A point to note; we *don't* want to change the forwarding device's\n     * 'target', because when we copy the child up to replace 'this' device\n     * we do still want the forwarding device to point here. NB its the *child*\n     * device that goes away.\n     */\n    if (psubclass_data != NULL && psubclass_data->forwarding_dev != NULL && psubclass_data->saved_compositor_method)\n        psubclass_data->forwarding_dev->procs.composite = psubclass_data->saved_compositor_method;\n\n    /* If ths device's stype is dynamically allocated, keep a copy of it\n     * in case we might need it.\n     */\n    if (dynamic) {\n        a_std = (gs_memory_struct_type_t *)dev->stype;\n        if (child)\n            *a_std = *child->stype;\n    }\n\n    /* If ths device has any private storage, free it now */\n    if (psubclass_data)\n        gs_free_object(dev->memory->non_gc_memory, psubclass_data, \"gx_device_unsubclass\");\n\n    /* Copy the child device into ths device's memory */\n    if (child) {\n        b_std = (gs_memory_struct_type_t *)dev->stype;\n        rc_decrement(dev->icc_struct, \"unsubclass device\");\n        rc_increment(child->icc_struct);\n        memcpy(dev, child, child->stype->ssize);\n        /* Patch back the 'stype' in the memory manager */\n        gs_set_object_type(child->memory, dev, b_std);\n\n        dev->stype = b_std;\n        /* The reference count of the subclassing device may have been\n         * changed (eg graphics states pointing to it) after we subclassed\n         * the device. We need to ensure that we do not overwrite this\n         * when we copy back the subclassed device.\n         */\n        dev->rc.ref_count = ref_count;\n        dev->rc.memory = rcmem;\n\n        /* If we have a chain of devices, make sure the chain beyond the\n         * device we're unsubclassing doesn't get broken, we need to\n         * detach the lower chain and reattach it at the new highest level.\n         */\n        if (child->child)\n            child->child->parent = dev;\n        child->parent->child = child->child;\n    }\n\n    /* How can we have a subclass device with no child ? Simples; when we\n     * hit the end of job restore, the devices are not freed in device\n     * chain order. To make sure we don't end up following stale pointers,\n     * when a device is freed we remove it from the chain and update\n     * any dangling pointers to NULL. When we later free the remaining\n     * devices it's possible that their child pointer can then be NULL.\n     */\n    if (child) {\n        /* We cannot afford to free the child device if its stype is not\n         * dynamic because we can't 'null' the finalise routine, and we\n         * cannot permit the device to be finalised because we have copied\n         * it up one level, not discarded it. (This shouldn't happen! Child\n         * devices are always created with a dynamic stype.) If this ever\n         * happens garbage collecton will eventually clean up the memory.\n         */\n        if (child->stype_is_dynamic) {\n            /* Make sure that nothing will try to follow the device chain,\n             * just security here. */\n            child->parent = NULL;\n            child->child = NULL;\n\n            /* We *don't* want to run the finalize routine. This would free\n             * the stype and properly handle the icc_struct and PageList,\n             * but for devices with a custom finalize (eg psdcmyk) it might\n             * also free memory it had allocated, and we're still pointing\n             * at that memory in the parent. The indirection through a\n             * variable is just to get rid of const warnings.\n             */\n            b_std = (gs_memory_struct_type_t *)child->stype;\n            gs_free_const_object(dev->memory->non_gc_memory, b_std, \"gs_device_unsubclass(stype)\");\n            /* Make this into a generic device */\n            child->stype = &st_device;\n            child->stype_is_dynamic = false;\n\n            /* We can't simply discard the child device, because there may be references to it elsewhere,\n               but equally, we really don't want it doing anything, so set the procs so actions are just discarded.\n             */\n            gx_copy_device_procs(child, (gx_device *)&gs_null_device, (gx_device *)&gs_null_device);\n\n            /* Having changed the stype, we need to make sure the memory\n             * manager uses it. It keeps a copy in its own data structure,\n             * and would use that copy, which would mean it would call the\n             * finalize routine that we just patched out.\n             */\n            gs_set_object_type(dev->memory->stable_memory, child, child->stype);\n            child->finalize = NULL;\n            /* Now (finally) free the child memory */\n            rc_decrement(child, \"gx_device_unsubclass(device)\");\n        }\n    }\n    dev->parent = parent;\n\n    /* If this device has a dynamic stype, we wnt to keep using it, but we copied\n     * the stype pointer from the child when we copied the rest of the device. So\n     * we update the stype pointer with the saved pointer to this device's stype.\n     */\n    if (dynamic) {\n        dev->stype = a_std;\n        dev->stype_is_dynamic = 1;\n    } else {\n        dev->stype_is_dynamic = 0;\n    }\n}\nvoid default_subclass_finalize(const gs_memory_t *cmem, void *vptr)\n{\n    gx_device * const dev = (gx_device *)vptr;\n    generic_subclass_data *psubclass_data = (generic_subclass_data *)dev->subclass_data;\n    (void)cmem; /* unused */\n\n    discard(gs_closedevice(dev));\n\n    if (dev->finalize)\n        dev->finalize(dev);\n\n    rc_decrement(dev->child, \"de-reference child device\");\n\n    if (psubclass_data) {\n        gs_free_object(dev->memory->non_gc_memory, psubclass_data, \"gx_epo_finalize(suclass data)\");\n        dev->subclass_data = NULL;\n    }\n    if (dev->stype_is_dynamic)\n        gs_free_const_object(dev->memory->non_gc_memory, dev->stype,\n                             \"default_subclass_finalize\");\n    if (dev->parent)\n        dev->parent->child = dev->child;\n    if (dev->child)\n        dev->child->parent = dev->parent;\n    if (dev->icc_struct)\n        rc_decrement(dev->icc_struct, \"finalize subclass device\");\n    if (dev->PageList)\n        rc_decrement(dev->PageList, \"finalize subclass device\");\n    if (dev->NupControl)\n        rc_decrement(dev->NupControl, \"finalize subclass device\");\n}\nstatic void\ngc_objects_set_reloc(gc_state_t * gcst, clump_t * cp)\n{\n    size_t reloc = 0;\n    clump_head_t *chead = cp->chead;\n    byte *pfree = (byte *) & chead->free;\t/* most recent free object */\n\n    if_debug_clump('6', gcst->heap, \"[6]setting reloc for clump\", cp);\n    gc_init_reloc(cp);\n    SCAN_CLUMP_OBJECTS(cp)\n        DO_ALL\n        struct_proc_finalize((*finalize));\n    const struct_shared_procs_t *procs =\n    pre->o_type->shared;\n\n    if ((procs == 0 ? o_is_unmarked(pre) :\n         !(*procs->set_reloc) (pre, reloc, size))\n        ) {\t\t\t/* Free object */\n        reloc += sizeof(obj_header_t) + obj_align_round(size);\n        if ((finalize = pre->o_type->finalize) != 0) {\n            if_debug2m('u', gcst->heap, \"[u]GC finalizing %s \"PRI_INTPTR\"\\n\",\n                       struct_type_name_string(pre->o_type),\n                       (intptr_t)(pre + 1));\n            (*finalize) (gcst->cur_mem, pre + 1);\n        }\n        pfree = (byte *) pre;\n        pre->o_back = (pfree - (byte *) chead) >> obj_back_shift;\n        pre->o_nreloc = reloc;\n        if_debug3m('7', gcst->heap, \" [7]at \"PRI_INTPTR\", unmarked %lu, new reloc = %u\\n\",\n                   (intptr_t)pre, (ulong) size, (unsigned int)reloc);\n    } else {\t\t\t/* Useful object */\n        debug_check_object(pre, cp, gcst);\n        pre->o_back = ((byte *) pre - pfree) >> obj_back_shift;\n    }\n    END_OBJECTS_SCAN\n#ifdef DEBUG\n    if (reloc != 0) {\n        if_debug1m('6', gcst->heap, \"[6]freed %u\", (unsigned int)reloc);\n        if_debug_clump('6', gcst->heap, \" in\", cp);\n    }\n#endif\n}\nstatic int\ngs_vmreclaim(gs_dual_memory_t *dmem, bool global)\n{\n    /* HACK: we know the gs_dual_memory_t is embedded in a context state. */\n    i_ctx_t *i_ctx_p =\n        (i_ctx_t *)((char *)dmem - offset_of(i_ctx_t, memory));\n    gs_ref_memory_t *lmem = dmem->space_local;\n    int code = context_state_store(i_ctx_p);\n    gs_ref_memory_t *memories[5];\n    gs_ref_memory_t *mem;\n    int nmem, i;\n\n    if (code < 0)\n        return code;\n\n    memories[0] = dmem->space_system;\n    memories[1] = mem = dmem->space_global;\n    nmem = 2;\n    if (lmem != dmem->space_global)\n        memories[nmem++] = lmem;\n    for (i = nmem; --i >= 0;) {\n        mem = memories[i];\n        if (mem->stable_memory != (gs_memory_t *)mem)\n            memories[nmem++] = (gs_ref_memory_t *)mem->stable_memory;\n    }\n\n    /****** ABORT IF code < 0 ******/\n    for (i = nmem; --i >= 0; )\n        alloc_close_clump(memories[i]);\n\n    /* Prune the file list so it won't retain potentially collectible */\n    /* files. */\n\n    for (i = (global ? i_vm_system : i_vm_local);\n         i < countof(dmem->spaces_indexed);\n         ++i\n         ) {\n        gs_ref_memory_t *mem = dmem->spaces_indexed[i];\n\n        /* Always safe to substract 1 from i here, as i is always at\n         * least i_vm_system (1) or i_vm_local (2). */\n        if (mem == 0 || (mem == dmem->spaces_indexed[i - 1]))\n            continue;\n        if (mem->stable_memory != (gs_memory_t *)mem)\n            ialloc_gc_prepare((gs_ref_memory_t *)mem->stable_memory);\n        for (;; mem = &mem->saved->state) {\n            ialloc_gc_prepare(mem);\n            if (mem->saved == 0)\n                break;\n        }\n    }\n\n    /* Do the actual collection. */\n\n    {\n        void *ctxp = i_ctx_p;\n        gs_gc_root_t context_root, *r = &context_root;\n\n        gs_register_struct_root((gs_memory_t *)lmem, &r,\n                                &ctxp, \"i_ctx_p root\");\n        GS_RECLAIM(&dmem->spaces, global);\n        gs_unregister_root((gs_memory_t *)lmem, r, \"i_ctx_p root\");\n        i_ctx_p = ctxp;\n        dmem = &i_ctx_p->memory;\n    }\n\n    /* Update caches not handled by context_state_load. */\n\n    *systemdict = *ref_stack_index(&d_stack, ref_stack_count(&d_stack) - 1);\n\n    /* Update the cached value pointers in names. */\n\n    dicts_gc_cleanup();\n\n    /* Reopen the active clumps. */\n\n    for (i = 0; i < nmem; ++i)\n        alloc_open_clump(memories[i]);\n\n    /* Reload the context state.  Note this should be done\n       AFTER the clumps are reopened, since the context state\n       load could do allocations that must remain.\n       If it were done while the clumps were still closed,\n       we would lose those allocations when the clumps were opened */\n\n    code = context_state_load(i_ctx_p);\n    return code;\n}\nstatic int\nireclaim(gs_dual_memory_t * dmem, int space)\n{\n    bool global;\n    gs_ref_memory_t *mem = NULL;\n    int code;\n\n    if (space < 0) {\n        /* Determine which allocator exceeded the limit. */\n        int i;\n\n        for (i = 0; i < countof(dmem->spaces_indexed); i++) {\n            mem = dmem->spaces_indexed[i];\n            if (mem == 0)\n                continue;\n            if (mem->gc_status.requested > 0 ||\n                ((gs_ref_memory_t *)mem->stable_memory)->gc_status.requested > 0\n                )\n                break;\n        }\n        if (!mem) {\n            mem = dmem->space_global; /* just in case */\n        }\n    } else {\n        mem = dmem->spaces_indexed[space >> r_space_shift];\n    }\n    if_debug3m('0', (gs_memory_t *)mem, \"[0]GC called, space=%d, requestor=%d, requested=%ld\\n\",\n               space, mem->space, (long)mem->gc_status.requested);\n    global = mem->space != avm_local;\n    /* Since dmem may move, reset the request now. */\n    ialloc_reset_requested(dmem);\n    code = gs_vmreclaim(dmem, global);\n    if (code < 0)\n        return code;\n    ialloc_set_limit(mem);\n    if (space < 0) {\n        gs_memory_status_t stats;\n        size_t allocated;\n\n        /* If the ammount still allocated after the GC is complete */\n        /* exceeds the max_vm setting, then return a VMerror       */\n        gs_memory_status((gs_memory_t *) mem, &stats);\n        allocated = stats.allocated;\n        if (mem->stable_memory != (gs_memory_t *)mem) {\n            gs_memory_status(mem->stable_memory, &stats);\n            allocated += stats.allocated;\n        }\n        if (allocated >= mem->gc_status.max_vm) {\n            /* We can't satisfy this request within max_vm. */\n            return_error(gs_error_VMerror);\n        }\n    }\n    return 0;\n}\nint\ninterp_reclaim(i_ctx_t **pi_ctx_p, int space)\n{\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    gs_gc_root_t ctx_root, *r = &ctx_root;\n    int code;\n\n#ifdef DEBUG\n    if (gs_debug_c(gs_debug_flag_gc_disable))\n        return 0;\n#endif\n\n    gs_register_struct_root(imemory_system, &r,\n                            (void **)pi_ctx_p, \"interp_reclaim(pi_ctx_p)\");\n    code = (*idmemory->reclaim)(idmemory, space);\n    i_ctx_p = *pi_ctx_p;        /* may have moved */\n    gs_unregister_root(imemory_system, r, \"interp_reclaim(pi_ctx_p)\");\n    return code;\n}\nint\ngs_main_finit(gs_main_instance * minst, int exit_status, int env_code)\n{\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    gs_dual_memory_t dmem = {0};\n    int exit_code;\n    ref error_object;\n    char *tempnames = NULL;\n    gs_lib_ctx_core_t *core;\n\n    /* NB: need to free gs_name_table\n     */\n\n    /*\n     * Previous versions of this code closed the devices in the\n     * device list here.  Since these devices are now prototypes,\n     * they cannot be opened, so they do not need to be closed;\n     * alloc_restore_all will close dynamically allocated devices.\n     */\n    tempnames = gs_main_tempnames(minst);\n\n    /* by the time we get here, we *must* avoid any random redefinitions of\n     * operators etc, so we push systemdict onto the top of the dict stack.\n     * We do this in C to avoid running into any other re-defininitions in the\n     * Postscript world.\n     */\n    gs_finit_push_systemdict(i_ctx_p);\n\n    /* We have to disable BGPrint before we call interp_reclaim() to prevent the\n     * parent rendering thread initialising for the next page, whilst we are\n     * removing objects it may want to access - for example, the I/O device table.\n     * We also have to mess with the BeginPage/EndPage procs so that we don't\n     * trigger a spurious extra page to be emitted.\n     */\n    if (minst->init_done >= 2) {\n        gs_main_run_string(minst,\n            \"/BGPrint /GetDeviceParam .special_op \\\n            {{ <</BeginPage {pop} /EndPage {pop pop //false } \\\n              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \\\n              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \\\n              .systemvar exec\",\n            0 , &exit_code, &error_object);\n    }\n\n    /*\n     * Close the \"main\" device, because it may need to write out\n     * data before destruction. pdfwrite needs so.\n     */\n    if (minst->init_done >= 2) {\n        int code = 0;\n\n        if (idmemory->reclaim != 0) {\n            code = interp_reclaim(&minst->i_ctx_p, avm_global);\n\n            /* We ignore gs_error_VMerror because it comes from gs_vmreclaim()\n            calling context_state_load(), and we don't seem to depend on the\n            missing fields. */\n            if (code == gs_error_VMerror) {\n                if (exit_status == 0 || exit_status == gs_error_Quit) {\n                    exit_status = gs_error_VMerror;\n                }\n            }\n            else if (code < 0) {\n                ref error_name;\n                if (tempnames)\n                    free(tempnames);\n\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf2(imemory, \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\", err_str, code);\n                }\n                else {\n                    emprintf1(imemory, \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\", code);\n                }\n#ifdef MEMENTO\n                if (Memento_squeezing() && code != gs_error_VMerror ) return gs_error_Fatal;\n#endif\n                return gs_error_Fatal;\n            }\n            i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&\n            gx_device_is_null(i_ctx_p->pgs->device)) {\n            /* if the job replaced the device with the nulldevice, we we need to grestore\n               away that device, so the block below can properly dispense\n               with the default device.\n             */\n            int code = gs_grestoreall(i_ctx_p->pgs);\n            if (code < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {\n            gx_device *pdev = i_ctx_p->pgs->device;\n            const char * dname = pdev->dname;\n            gs_gc_root_t dev_root;\n            gs_gc_root_t *dev_root_ptr = &dev_root;\n            /* There is a chance that, during the call to gs_main_run_string(), the interpreter may\n             * decide to call the garbager - the device is in gc memory, and the only reference to it\n             * (in the gstate) has been removed, thus it can be destroyed by the garbager.\n             * Counter-intuitively, adjusting the reference count makes not difference to that.\n             * Register the device as a gc 'root' so it will be implicitely marked by garbager, and\n             * and thus surive until control returns here.\n             */\n            if (gs_register_struct_root(pdev->memory, &dev_root_ptr, (void **)&pdev, \"gs_main_finit\") < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n\n            /* make sure device doesn't isn't freed by .uninstalldevice */\n            rc_adjust(pdev, 1, \"gs_main_finit\");\n            /* deactivate the device just before we close it for the last time */\n            gs_main_run_string(minst,\n                /* we need to do the 'quit' so we don't loop for input (double quit) */\n                \".uninstallpagedevice serverdict \\\n                /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemvar exec\",\n                0 , &exit_code, &error_object);\n            code = gs_closedevice(pdev);\n            if (code < 0) {\n                ref error_name;\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf3(imemory, \"ERROR: %s (%d) on closing %s device.\\n\", err_str, code, dname);\n                }\n                else {\n                    emprintf2(imemory, \"UNKNOWN ERROR %d closing %s device.\\n\", code, dname);\n               }\n            }\n            gs_unregister_root(pdev->memory, dev_root_ptr, \"gs_main_finit\");\n            rc_decrement(pdev, \"gs_main_finit\");                /* device might be freed */\n            if (exit_status == 0 || exit_status == gs_error_Quit)\n                exit_status = code;\n        }\n\n      /* Flush stdout and stderr */\n      gs_main_run_string(minst,\n        \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\\n        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \\\n          systemdict /savedinitialgstate .forceundef\",\n        0 , &exit_code, &error_object);\n    }\n    gp_readline_finit(minst->readline_data);\n    gs_free_object(minst->heap, minst->saved_pages_initial_arg, \"gs_main_finit\");\n    i_ctx_p = minst->i_ctx_p;\t\t/* get current interp context */\n    if (gs_debug_c(':')) {\n        print_resource_usage(minst, &gs_imemory, \"Final\");\n        dmprintf1(minst->heap, \"%% Exiting instance \"PRI_INTPTR\"\\n\", (intptr_t)minst);\n    }\n    /* Do the equivalent of a restore \"past the bottom\". */\n    /* This will release all memory, close all open files, etc. */\n    if (minst->init_done >= 1) {\n        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;\n        i_plugin_holder *h = i_ctx_p->plugin_list;\n\n        dmem = *idmemory;\n        env_code = alloc_restore_all(i_ctx_p);\n        if (env_code < 0)\n            emprintf1(mem_raw,\n                      \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\",\n                      env_code);\n        i_iodev_finit(&dmem);\n        i_plugin_finit(mem_raw, h);\n    }\n\n    /* clean up redirected stdout */\n    core = minst->heap->gs_lib_ctx->core;\n    if (core->fstdout2\n        && (gp_get_file(core->fstdout2) != core->fstdout)\n        && (gp_get_file(core->fstdout2) != core->fstderr)) {\n        gp_fclose(core->fstdout2);\n        core->fstdout2 = NULL;\n    }\n\n    minst->heap->gs_lib_ctx->core->stdout_is_redirected = 0;\n    minst->heap->gs_lib_ctx->core->stdout_to_stderr = 0;\n    /* remove any temporary files, after ghostscript has closed files */\n    if (tempnames) {\n        char *p = tempnames;\n        while (*p) {\n            gp_unlink(minst->heap, p);\n            p += strlen(p) + 1;\n        }\n        free(tempnames);\n    }\n    gs_lib_finit(exit_status, env_code, minst->heap);\n\n    set_lib_path_length(minst, 0);\n    gs_free_object(minst->heap, minst->lib_path.container.value.refs, \"lib_path array\");\n    if (minst->init_done == 0 && i_ctx_p) {\n        /* This fixes leak if memento forces failure in gs_main_init1(). */\n        dmem = *idmemory;\n    }\n    ialloc_finit(&dmem);\n    return exit_status;\n}\nint\ngs_to_exit_with_code(const gs_memory_t *mem, int exit_status, int code)\n{\n    return gs_main_finit(get_minst_from_memory(mem), exit_status, code);\n}\nint\ngs_to_exit(const gs_memory_t *mem, int exit_status)\n{\n    return gs_to_exit_with_code(mem, exit_status, 0);\n}\nint\npsapi_exit(gs_lib_ctx_t *ctx)\n{\n    if (ctx == NULL)\n        return gs_error_Fatal;\n\n    gs_to_exit(ctx->memory, 0);\n    return 0;\n}\nGSDLLEXPORT int GSDLLAPI\ngsapi_exit(void *instance)\n{\n    gs_lib_ctx_t *ctx = (gs_lib_ctx_t *)instance;\n    if (instance == NULL)\n        return gs_error_Fatal;\n    gp_set_debug_mem_ptr(ctx->memory);\n    return psapi_exit(ctx);\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\t/* Avoid PDF files */\n\tif (size == 0 || is_pdf(data, size)) {\n\t\treturn 0;\n\t}\n\n\t/* \n\t * Modulo the possibilities: https://github.com/ArtifexSoftware/ghostpdl/blob/8c97d5adce0040ac38a1fb4d7954499c65f582ff/cups/libs/cups/raster.h#L102\n\t   This enables the fuzzer to explore all color schemes\n\t */\n\tint color_scheme = ((int)data[0] % 63);\n\tdata++;\n\tsize--;\n\n\tgs_to_raster_fuzz(data, size, color_scheme);\n\treturn 0;\n}",
    "target": 0,
    "idx": 2048305
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static int parser_conf_file(const char *cfg, struct mk_rconf *fconf,\n                            struct flb_config *config)\n{\n    flb_sds_t name;\n    flb_sds_t format;\n    flb_sds_t regex;\n    flb_sds_t time_fmt;\n    flb_sds_t time_key;\n    flb_sds_t time_offset;\n    flb_sds_t types_str;\n    flb_sds_t tmp_str;\n    int time_keep;\n    int time_strict;\n    int types_len;\n    struct mk_list *head;\n    struct mk_list *decoders = NULL;\n    struct mk_rconf_section *section;\n    struct flb_parser_types *types = NULL;\n\n    /* Read all [PARSER] sections */\n    mk_list_foreach(head, &fconf->sections) {\n        name = NULL;\n        format = NULL;\n        regex = NULL;\n        time_fmt = NULL;\n        time_key = NULL;\n        time_offset = NULL;\n        types_str = NULL;\n        tmp_str = NULL;\n\n        section = mk_list_entry(head, struct mk_rconf_section, _head);\n        if (strcasecmp(section->name, \"PARSER\") != 0) {\n            continue;\n        }\n\n        /* Name */\n        name = get_parser_key(\"Name\", config, section);\n        if (!name) {\n            flb_error(\"[parser] no parser 'name' found in file '%s'\", cfg);\n            goto fconf_error;\n        }\n\n        /* Format */\n        format = get_parser_key(\"Format\", config, section);\n        if (!format) {\n            flb_error(\"[parser] no parser 'format' found for '%s' in file '%s'\",\n                      name, cfg);\n            goto fconf_error;\n        }\n\n        /* Regex (if 'format' == 'regex') */\n        regex = get_parser_key(\"Regex\", config, section);\n        if (!regex && strcmp(format, \"regex\") == 0) {\n            flb_error(\"[parser] no parser 'regex' found for '%s' in file '%s\", name, cfg);\n            goto fconf_error;\n        }\n\n        /* Time_Format */\n        time_fmt = get_parser_key(\"Time_Format\", config, section);\n\n        /* Time_Key */\n        time_key = get_parser_key(\"Time_Key\", config, section);\n\n        /* Time_Keep */\n        time_keep = FLB_FALSE;\n        tmp_str = get_parser_key(\"Time_Keep\", config, section);\n        if (tmp_str) {\n            time_keep = flb_utils_bool(tmp_str);\n            flb_sds_destroy(tmp_str);\n        }\n\n        /* Time_Strict */\n        time_strict = FLB_TRUE;\n        tmp_str = get_parser_key(\"Time_Strict\", config, section);\n        if (tmp_str) {\n            time_strict = flb_utils_bool(tmp_str);\n            flb_sds_destroy(tmp_str);\n        }\n\n        /* Time_Offset (UTC offset) */\n        time_offset = get_parser_key(\"Time_Offset\", config, section);\n\n        /* Types */\n        types_str = get_parser_key(\"Types\", config, section);\n        if (types_str) {\n            types_len = proc_types_str(types_str, &types);\n        }\n        else {\n            types_len = 0;\n        }\n\n        /* Decoders */\n        decoders = flb_parser_decoder_list_create(section);\n\n        /* Create the parser context */\n        if (!flb_parser_create(name, format, regex,\n                               time_fmt, time_key, time_offset, time_keep, time_strict,\n                               types, types_len, decoders, config)) {\n            goto fconf_error;\n        }\n\n        flb_debug(\"[parser] new parser registered: %s\", name);\n\n        flb_sds_destroy(name);\n        flb_sds_destroy(format);\n\n        if (regex) {\n            flb_sds_destroy(regex);\n        }\n        if (time_fmt) {\n            flb_sds_destroy(time_fmt);\n        }\n        if (time_key) {\n            flb_sds_destroy(time_key);\n        }\n        if (time_offset) {\n            flb_sds_destroy(time_offset);\n        }\n        if (types_str) {\n            flb_sds_destroy(types_str);\n        }\n        decoders = NULL;\n    }\n\n    return 0;\n\n fconf_error:\n    flb_sds_destroy(name);\n    flb_sds_destroy(format);\n    if (regex) {\n        flb_sds_destroy(regex);\n    }\n    if (time_fmt) {\n        flb_sds_destroy(time_fmt);\n    }\n    if (time_key) {\n        flb_sds_destroy(time_key);\n    }\n    if (time_offset) {\n        flb_sds_destroy(time_offset);\n    }\n    if (types_str) {\n        flb_sds_destroy(types_str);\n    }\n    if (decoders) {\n        flb_parser_decoder_list_destroy(decoders);\n    }\n    return -1;\n}\nstatic int multiline_parser_conf_file(const char *cfg, struct mk_rconf *fconf,\n                                      struct flb_config *config)\n{\n    flb_sds_t name;\n    int type;\n    flb_sds_t match_string;\n    int negate;\n    flb_sds_t key_content;\n    flb_sds_t key_pattern;\n    flb_sds_t key_group;\n    flb_sds_t parser;\n    flb_sds_t tmp;\n    int flush_timeout;\n    struct mk_list *head;\n    struct mk_rconf_section *section;\n    struct flb_ml *ml;\n\n    /* Read all [PARSER] sections */\n    mk_list_foreach(head, &fconf->sections) {\n        name = NULL;\n        type = -1;\n        match_string = NULL;\n        negate = FLB_FALSE;\n        key_content = NULL;\n        key_pattern = NULL;\n        key_group = NULL;\n        parser = NULL;\n        flush_timeout = -1;\n\n        section = mk_list_entry(head, struct mk_rconf_section, _head);\n        if (strcasecmp(section->name, \"MULTILINE_PARSER\") != 0) {\n            continue;\n        }\n\n        /* name */\n        name = get_parser_key(\"name\", config, section);\n        if (!name) {\n            flb_error(\"[multiline_parser] no 'name' defined in file '%s'\", cfg);\n            goto fconf_error;\n        }\n\n        /* type */\n        tmp = get_parser_key(\"type\", config, section);\n        if (!tmp) {\n            flb_error(\"[multiline_parser] no 'type' defined in file '%s'\", cfg);\n            goto fconf_error;\n        }\n        else {\n            type = flb_ml_type_lookup(tmp);\n            if (type == -1) {\n                flb_error(\"[multiline_parser] invalid type '%s'\", tmp);\n                flb_sds_destroy(tmp);\n                goto fconf_error;\n            }\n            flb_sds_destroy(tmp);\n        }\n\n        /* match_string */\n        match_string = get_parser_key(\"match_string\", config, section);\n\n        /* negate */\n        tmp = get_parser_key(\"negate\", config, section);\n        if (tmp) {\n            negate = flb_utils_bool(tmp);\n            flb_sds_destroy(tmp);\n        }\n\n        /* key_content */\n        key_content = get_parser_key(\"key_content\", config, section);\n\n        /* key_pattern */\n        key_pattern = get_parser_key(\"key_pattern\", config, section);\n\n        /* key_group */\n        key_group = get_parser_key(\"key_group\", config, section);\n\n        /* parser */\n        parser = get_parser_key(\"parser\", config, section);\n\n        /* flush_timeout */\n        tmp = get_parser_key(\"flush_timeout\", config, section);\n        if (tmp) {\n            flush_timeout = atoi(tmp);\n        }\n\n        ml = flb_ml_create(config, name, type, match_string, negate,\n                           flush_timeout, key_content, key_group, key_pattern,\n                           NULL, parser);\n\n        flb_sds_destroy(name);\n        flb_sds_destroy(match_string);\n        flb_sds_destroy(key_content);\n        flb_sds_destroy(key_pattern);\n        flb_sds_destroy(key_group);\n    }\n\n    return 0;\n\n fconf_error:\n    flb_sds_destroy(name);\n    flb_sds_destroy(match_string);\n    flb_sds_destroy(key_content);\n    flb_sds_destroy(key_pattern);\n    flb_sds_destroy(key_group);\n\n    return -1;\n}\nint flb_parser_conf_file(const char *file, struct flb_config *config)\n{\n    int ret;\n    char tmp[PATH_MAX + 1];\n    const char *cfg = NULL;\n    struct mk_rconf *fconf;\n    struct stat st;\n\n#ifndef FLB_HAVE_STATIC_CONF\n    ret = stat(file, &st);\n    if (ret == -1 && errno == ENOENT) {\n        /* Try to resolve the real path (if exists) */\n        if (file[0] == '/') {\n            flb_utils_error(FLB_ERR_CFG_PARSER_FILE);\n            return -1;\n        }\n\n        if (config->conf_path) {\n            snprintf(tmp, PATH_MAX, \"%s%s\", config->conf_path, file);\n            cfg = tmp;\n        }\n    }\n    else {\n        cfg = file;\n    }\n\n    fconf = mk_rconf_open(cfg);\n#else\n    fconf = flb_config_static_open(file);\n#endif\n\n    if (!fconf) {\n        return -1;\n    }\n\n    /* process [PARSER]'s sections */\n    ret = parser_conf_file(cfg, fconf, config);\n    if (ret == -1) {\n        mk_rconf_free(fconf);\n        return -1;\n    }\n\n    ret = multiline_parser_conf_file(cfg, fconf, config);\n    if (ret == -1) {\n        mk_rconf_free(fconf);\n        return -1;\n    }\n\n    mk_rconf_free(fconf);\n    return 0;\n}\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    /* Limit the size of the config files to 32KB. */\n    if (size > 32768) {\n        return 0;\n    }\n\n    /* Write the config file to a location we know OSS-Fuzz has */\n    char filename[256];\n    sprintf(filename, \"/tmp/libfuzzer.%d\", getpid());\n    FILE *fp = fopen(filename, \"wb\");\n    if (!fp) {\n        return 0;\n    }\n    fwrite(conf_file, strlen(conf_file), 1, fp);\n    fclose(fp);\n\n\n    /* Now parse random data based on the config files */\n    struct flb_config *config = NULL;\n    config = flb_config_init();\n    int ret = flb_parser_conf_file(filename, config);\n    if (ret == 0) {\n        struct mk_list *head = NULL;\n        mk_list_foreach(head, &config->parsers) {\n            size_t out_size;\n            char *out_buf = NULL;\n            struct flb_parser *parser = NULL;\n            struct flb_time out_time;\n            parser = mk_list_entry(head, struct flb_parser, _head);\n            flb_parser_do(parser, data, size, &out_buf,\n                          &out_size, &out_time);\n            if (out_buf != NULL) {\n                free(out_buf);\n            }\n        }\n    }\n    flb_parser_exit(config);\n    flb_config_exit(config);\n\n    if (size > 100) {\n        /* Now let's do a second run where we also call flb_config_set_property */\n        config = flb_config_init();\n        ret = flb_parser_conf_file(filename, config);\n        char *key_1 = get_null_terminated(15, &data, &size);\n        char *val_1 = get_null_terminated(15, &data, &size);\n        char *key_2 = get_null_terminated(15, &data, &size);\n        char *val_2 = get_null_terminated(15, &data, &size);\n        char *progname = get_null_terminated(15, &data, &size);\n\n        flb_config_set_property(config, key_1, val_1);\n        flb_config_set_property(config, key_2, val_2);\n        flb_config_set_program_name(config, progname);\n        set_log_level_from_env(config);\n\n        struct mk_list prop;\n        flb_kv_init(&prop);\n        flb_kv_item_create(&prop, key_1, val_1);\n        flb_config_prop_get(progname, &prop);\n        flb_slist_entry_get(&prop, (int)data[0]);\n        flb_slist_dump(&prop);\n        \n        if (ret == 0) {\n            struct mk_list *head = NULL;\n            mk_list_foreach(head, &config->parsers) {\n                size_t out_size;\n                char *out_buf = NULL;\n                struct flb_parser *parser = NULL;\n                struct flb_time out_time;\n                \n                parser = mk_list_entry(head, struct flb_parser, _head);\n                flb_parser_do(parser, data, size, &out_buf,\n                              &out_size, &out_time);\n                if (out_buf != NULL) {\n                    free(out_buf);\n                }\n            }\n        }\n        flb_parser_exit(config);\n        flb_config_exit(config);\n        flb_free(key_1);\n        flb_free(val_1);\n        flb_free(key_2);\n        flb_free(val_2);\n        flb_free(progname);\n        flb_kv_release(&prop);\n    }\n\n    /* clean up the file */\n    unlink(filename);\n\n    /* finally try to parser a random file */\n    fp = fopen(filename, \"wb\");\n    if (!fp) {\n        return 0;\n    }\n    fwrite(data, size, 1, fp);\n    fclose(fp);\n\n    config = NULL;\n    config = flb_config_init();\n    flb_parser_conf_file(filename, config);\n    flb_parser_exit(config);\n    flb_config_exit(config);\n\n    /* Cleanup written config file */\n    unlink(filename);\n\n    return 0;\n}",
    "target": 0,
    "idx": 2034960
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static int\nxmlXIncludeLoadFallback(xmlXIncludeCtxtPtr ctxt, xmlNodePtr fallback, int nr) {\n    xmlXIncludeCtxtPtr newctxt;\n    int ret = 0;\n    int oldNbErrors = ctxt->nbErrors;\n\n    if ((fallback == NULL) || (fallback->type == XML_NAMESPACE_DECL) ||\n        (ctxt == NULL))\n\treturn(-1);\n    if (fallback->children != NULL) {\n\t/*\n\t * It's possible that the fallback also has 'includes'\n\t * (Bug 129969), so we re-process the fallback just in case\n\t */\n\tnewctxt = xmlXIncludeNewContext(ctxt->doc);\n\tif (newctxt == NULL)\n\t    return (-1);\n\tnewctxt->_private = ctxt->_private;\n\tnewctxt->base = xmlStrdup(ctxt->base);\t/* Inherit the base from the existing context */\n\txmlXIncludeSetFlags(newctxt, ctxt->parseFlags);\n        newctxt->incTotal = ctxt->incTotal;\n        if (xmlXIncludeDoProcess(newctxt, ctxt->doc, fallback, 1) < 0)\n            ret = -1;\n        ctxt->incTotal = newctxt->incTotal;\n\tif (ctxt->nbErrors > oldNbErrors)\n\t    ret = -1;\n\txmlXIncludeFreeContext(newctxt);\n\n\tctxt->incTab[nr]->inc = xmlDocCopyNodeList(ctxt->doc,\n\t                                           fallback->children);\n    } else {\n        ctxt->incTab[nr]->inc = NULL;\n    }\n    ctxt->incTab[nr]->fallback = 1;\n    return(ret);\n}\nstatic int\nxmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur, end, list, tmp;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n\n    list = ctxt->incTab[nr]->inc;\n    ctxt->incTab[nr]->inc = NULL;\n\n    /*\n     * Check against the risk of generating a multi-rooted document\n     */\n    if ((cur->parent != NULL) &&\n\t(cur->parent->type != XML_ELEMENT_NODE)) {\n\tint nb_elem = 0;\n\n\ttmp = list;\n\twhile (tmp != NULL) {\n\t    if (tmp->type == XML_ELEMENT_NODE)\n\t\tnb_elem++;\n\t    tmp = tmp->next;\n\t}\n\tif (nb_elem > 1) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_MULTIPLE_ROOT,\n\t\t       \"XInclude error: would result in multiple root nodes\\n\",\n\t\t\t   NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    end = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(cur, end);\n\t}\n\txmlUnlinkNode(cur);\n\txmlFreeNode(cur);\n    } else {\n        xmlNodePtr child, next;\n\n\t/*\n\t * Change the current node as an XInclude start one, and add an\n\t * XInclude end one\n\t */\n        if (ctxt->incTab[nr]->fallback)\n            xmlUnsetProp(cur, BAD_CAST \"href\");\n\tcur->type = XML_XINCLUDE_START;\n        /* Remove fallback children */\n        for (child = cur->children; child != NULL; child = next) {\n            next = child->next;\n            xmlUnlinkNode(child);\n            xmlFreeNode(child);\n        }\n\tend = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);\n\tif (end == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_BUILD_FAILED,\n\t\t\t   \"failed to build node\\n\", NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n\tend->type = XML_XINCLUDE_END;\n\txmlAddNextSibling(cur, end);\n\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    cur = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(end, cur);\n\t}\n    }\n\n\n    return(0);\n}\nstatic void\nxmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {\n    int format = ctxt->format;\n    xmlNodePtr tmp, root, unformattedNode = NULL;\n    xmlAttrPtr attr;\n    xmlChar *start, *end;\n    xmlOutputBufferPtr buf;\n\n    if (cur == NULL) return;\n    buf = ctxt->buf;\n\n    root = cur;\n    while (1) {\n        switch (cur->type) {\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n\t    xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);\n\t    break;\n\n        case XML_DTD_NODE:\n            xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);\n            break;\n\n        case XML_DOCUMENT_FRAG_NODE:\n            if (cur->children != NULL) {\n                cur = cur->children;\n                continue;\n            }\n\t    break;\n\n        case XML_ELEMENT_DECL:\n            xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);\n            break;\n\n        case XML_ATTRIBUTE_DECL:\n            xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);\n            break;\n\n        case XML_ENTITY_DECL:\n            xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);\n            break;\n\n        case XML_ELEMENT_NODE:\n\t    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n\t\txmlOutputBufferWrite(buf, ctxt->indent_size *\n\t\t\t\t     (ctxt->level > ctxt->indent_nr ?\n\t\t\t\t      ctxt->indent_nr : ctxt->level),\n\t\t\t\t     ctxt->indent);\n\n            xmlOutputBufferWrite(buf, 1, \"<\");\n            if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n                xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);\n                xmlOutputBufferWrite(buf, 1, \":\");\n            }\n            xmlOutputBufferWriteString(buf, (const char *)cur->name);\n            if (cur->nsDef)\n                xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);\n            for (attr = cur->properties; attr != NULL; attr = attr->next)\n                xmlAttrDumpOutput(ctxt, attr);\n\n            if (cur->children == NULL) {\n                if ((ctxt->options & XML_SAVE_NO_EMPTY) == 0) {\n                    if (ctxt->format == 2)\n                        xmlOutputBufferWriteWSNonSig(ctxt, 0);\n                    xmlOutputBufferWrite(buf, 2, \"/>\");\n                } else {\n                    if (ctxt->format == 2)\n                        xmlOutputBufferWriteWSNonSig(ctxt, 1);\n                    xmlOutputBufferWrite(buf, 3, \"></\");\n                    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n                        xmlOutputBufferWriteString(buf,\n                                (const char *)cur->ns->prefix);\n                        xmlOutputBufferWrite(buf, 1, \":\");\n                    }\n                    xmlOutputBufferWriteString(buf, (const char *)cur->name);\n                    if (ctxt->format == 2)\n                        xmlOutputBufferWriteWSNonSig(ctxt, 0);\n                    xmlOutputBufferWrite(buf, 1, \">\");\n                }\n            } else {\n                if (ctxt->format == 1) {\n                    tmp = cur->children;\n                    while (tmp != NULL) {\n                        if ((tmp->type == XML_TEXT_NODE) ||\n                            (tmp->type == XML_CDATA_SECTION_NODE) ||\n                            (tmp->type == XML_ENTITY_REF_NODE)) {\n                            ctxt->format = 0;\n                            unformattedNode = cur;\n                            break;\n                        }\n                        tmp = tmp->next;\n                    }\n                }\n                if (ctxt->format == 2)\n                    xmlOutputBufferWriteWSNonSig(ctxt, 1);\n                xmlOutputBufferWrite(buf, 1, \">\");\n                if (ctxt->format == 1) xmlOutputBufferWrite(buf, 1, \"\\n\");\n                if (ctxt->level >= 0) ctxt->level++;\n                cur = cur->children;\n                continue;\n            }\n\n            break;\n\n        case XML_TEXT_NODE:\n\t    if (cur->content == NULL)\n                break;\n\t    if (cur->name != xmlStringTextNoenc) {\n                xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);\n\t    } else {\n\t\t/*\n\t\t * Disable escaping, needed for XSLT\n\t\t */\n\t\txmlOutputBufferWriteString(buf, (const char *) cur->content);\n\t    }\n\t    break;\n\n        case XML_PI_NODE:\n\t    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n\t\txmlOutputBufferWrite(buf, ctxt->indent_size *\n\t\t\t\t     (ctxt->level > ctxt->indent_nr ?\n\t\t\t\t      ctxt->indent_nr : ctxt->level),\n\t\t\t\t     ctxt->indent);\n\n            if (cur->content != NULL) {\n                xmlOutputBufferWrite(buf, 2, \"<?\");\n                xmlOutputBufferWriteString(buf, (const char *)cur->name);\n                if (cur->content != NULL) {\n                    if (ctxt->format == 2)\n                        xmlOutputBufferWriteWSNonSig(ctxt, 0);\n                    else\n                        xmlOutputBufferWrite(buf, 1, \" \");\n                    xmlOutputBufferWriteString(buf,\n                            (const char *)cur->content);\n                }\n                xmlOutputBufferWrite(buf, 2, \"?>\");\n            } else {\n                xmlOutputBufferWrite(buf, 2, \"<?\");\n                xmlOutputBufferWriteString(buf, (const char *)cur->name);\n                if (ctxt->format == 2)\n                    xmlOutputBufferWriteWSNonSig(ctxt, 0);\n                xmlOutputBufferWrite(buf, 2, \"?>\");\n            }\n            break;\n\n        case XML_COMMENT_NODE:\n\t    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n\t\txmlOutputBufferWrite(buf, ctxt->indent_size *\n\t\t\t\t     (ctxt->level > ctxt->indent_nr ?\n\t\t\t\t      ctxt->indent_nr : ctxt->level),\n\t\t\t\t     ctxt->indent);\n\n            if (cur->content != NULL) {\n                xmlOutputBufferWrite(buf, 4, \"<!--\");\n                xmlOutputBufferWriteString(buf, (const char *)cur->content);\n                xmlOutputBufferWrite(buf, 3, \"-->\");\n            }\n            break;\n\n        case XML_ENTITY_REF_NODE:\n            xmlOutputBufferWrite(buf, 1, \"&\");\n            xmlOutputBufferWriteString(buf, (const char *)cur->name);\n            xmlOutputBufferWrite(buf, 1, \";\");\n            break;\n\n        case XML_CDATA_SECTION_NODE:\n            if (cur->content == NULL || *cur->content == '\\0') {\n                xmlOutputBufferWrite(buf, 12, \"<![CDATA[]]>\");\n            } else {\n                start = end = cur->content;\n                while (*end != '\\0') {\n                    if ((*end == ']') && (*(end + 1) == ']') &&\n                        (*(end + 2) == '>')) {\n                        end = end + 2;\n                        xmlOutputBufferWrite(buf, 9, \"<![CDATA[\");\n                        xmlOutputBufferWrite(buf, end - start,\n                                (const char *)start);\n                        xmlOutputBufferWrite(buf, 3, \"]]>\");\n                        start = end;\n                    }\n                    end++;\n                }\n                if (start != end) {\n                    xmlOutputBufferWrite(buf, 9, \"<![CDATA[\");\n                    xmlOutputBufferWriteString(buf, (const char *)start);\n                    xmlOutputBufferWrite(buf, 3, \"]]>\");\n                }\n            }\n            break;\n\n        case XML_ATTRIBUTE_NODE:\n            xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);\n            break;\n\n        case XML_NAMESPACE_DECL:\n            xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);\n            break;\n\n        default:\n            break;\n        }\n\n        while (1) {\n            if (cur == root)\n                return;\n            if ((ctxt->format == 1) &&\n                (cur->type != XML_XINCLUDE_START) &&\n                (cur->type != XML_XINCLUDE_END))\n                xmlOutputBufferWrite(buf, 1, \"\\n\");\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n\n            cur = cur->parent;\n\n            if (cur->type == XML_ELEMENT_NODE) {\n                if (ctxt->level > 0) ctxt->level--;\n                if ((xmlIndentTreeOutput) && (ctxt->format == 1))\n                    xmlOutputBufferWrite(buf, ctxt->indent_size *\n                                         (ctxt->level > ctxt->indent_nr ?\n                                          ctxt->indent_nr : ctxt->level),\n                                         ctxt->indent);\n\n                xmlOutputBufferWrite(buf, 2, \"</\");\n                if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n                    xmlOutputBufferWriteString(buf,\n                            (const char *)cur->ns->prefix);\n                    xmlOutputBufferWrite(buf, 1, \":\");\n                }\n\n                xmlOutputBufferWriteString(buf, (const char *)cur->name);\n                if (ctxt->format == 2)\n                    xmlOutputBufferWriteWSNonSig(ctxt, 0);\n                xmlOutputBufferWrite(buf, 1, \">\");\n\n                if (cur == unformattedNode) {\n                    ctxt->format = format;\n                    unformattedNode = NULL;\n                }\n            }\n        }\n    }\n}\nstatic int\nxmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {\n#ifdef LIBXML_HTML_ENABLED\n    xmlDtdPtr dtd;\n    int is_xhtml = 0;\n#endif\n    const xmlChar *oldenc = cur->encoding;\n    const xmlChar *oldctxtenc = ctxt->encoding;\n    const xmlChar *encoding = ctxt->encoding;\n    xmlCharEncodingOutputFunc oldescape = ctxt->escape;\n    xmlCharEncodingOutputFunc oldescapeAttr = ctxt->escapeAttr;\n    xmlOutputBufferPtr buf = ctxt->buf;\n    xmlCharEncoding enc;\n    int switched_encoding = 0;\n\n    xmlInitParser();\n\n    if ((cur->type != XML_HTML_DOCUMENT_NODE) &&\n        (cur->type != XML_DOCUMENT_NODE))\n\t return(-1);\n\n    if (ctxt->encoding != NULL) {\n        cur->encoding = BAD_CAST ctxt->encoding;\n    } else if (cur->encoding != NULL) {\n\tencoding = cur->encoding;\n    }\n\n    if (((cur->type == XML_HTML_DOCUMENT_NODE) &&\n         ((ctxt->options & XML_SAVE_AS_XML) == 0) &&\n         ((ctxt->options & XML_SAVE_XHTML) == 0)) ||\n        (ctxt->options & XML_SAVE_AS_HTML)) {\n#ifdef LIBXML_HTML_ENABLED\n        if (encoding != NULL)\n\t    htmlSetMetaEncoding(cur, (const xmlChar *) encoding);\n        if (encoding == NULL)\n\t    encoding = htmlGetMetaEncoding(cur);\n        if (encoding == NULL)\n\t    encoding = BAD_CAST \"HTML\";\n\tif ((encoding != NULL) && (oldctxtenc == NULL) &&\n\t    (buf->encoder == NULL) && (buf->conv == NULL)) {\n\t    if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n\t\tcur->encoding = oldenc;\n\t\treturn(-1);\n\t    }\n\t}\n        if (ctxt->options & XML_SAVE_FORMAT)\n\t    htmlDocContentDumpFormatOutput(buf, cur,\n\t                                   (const char *)encoding, 1);\n\telse\n\t    htmlDocContentDumpFormatOutput(buf, cur,\n\t                                   (const char *)encoding, 0);\n\tif (ctxt->encoding != NULL)\n\t    cur->encoding = oldenc;\n\treturn(0);\n#else\n        return(-1);\n#endif\n    } else if ((cur->type == XML_DOCUMENT_NODE) ||\n               (ctxt->options & XML_SAVE_AS_XML) ||\n               (ctxt->options & XML_SAVE_XHTML)) {\n\tenc = xmlParseCharEncoding((const char*) encoding);\n\tif ((encoding != NULL) && (oldctxtenc == NULL) &&\n\t    (buf->encoder == NULL) && (buf->conv == NULL) &&\n\t    ((ctxt->options & XML_SAVE_NO_DECL) == 0)) {\n\t    if ((enc != XML_CHAR_ENCODING_UTF8) &&\n\t\t(enc != XML_CHAR_ENCODING_NONE) &&\n\t\t(enc != XML_CHAR_ENCODING_ASCII)) {\n\t\t/*\n\t\t * we need to switch to this encoding but just for this\n\t\t * document since we output the XMLDecl the conversion\n\t\t * must be done to not generate not well formed documents.\n\t\t */\n\t\tif (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n\t\t    cur->encoding = oldenc;\n\t\t    return(-1);\n\t\t}\n\t\tswitched_encoding = 1;\n\t    }\n\t    if (ctxt->escape == xmlEscapeEntities)\n\t\tctxt->escape = NULL;\n\t    if (ctxt->escapeAttr == xmlEscapeEntities)\n\t\tctxt->escapeAttr = NULL;\n\t}\n\n\n\t/*\n\t * Save the XML declaration\n\t */\n\tif ((ctxt->options & XML_SAVE_NO_DECL) == 0) {\n\t    xmlOutputBufferWrite(buf, 14, \"<?xml version=\");\n\t    if (cur->version != NULL)\n\t\txmlBufWriteQuotedString(buf->buffer, cur->version);\n\t    else\n\t\txmlOutputBufferWrite(buf, 5, \"\\\"1.0\\\"\");\n\t    if (encoding != NULL) {\n\t\txmlOutputBufferWrite(buf, 10, \" encoding=\");\n\t\txmlBufWriteQuotedString(buf->buffer, (xmlChar *) encoding);\n\t    }\n\t    switch (cur->standalone) {\n\t\tcase 0:\n\t\t    xmlOutputBufferWrite(buf, 16, \" standalone=\\\"no\\\"\");\n\t\t    break;\n\t\tcase 1:\n\t\t    xmlOutputBufferWrite(buf, 17, \" standalone=\\\"yes\\\"\");\n\t\t    break;\n\t    }\n\t    xmlOutputBufferWrite(buf, 3, \"?>\\n\");\n\t}\n\n#ifdef LIBXML_HTML_ENABLED\n        if (ctxt->options & XML_SAVE_XHTML)\n            is_xhtml = 1;\n\tif ((ctxt->options & XML_SAVE_NO_XHTML) == 0) {\n\t    dtd = xmlGetIntSubset(cur);\n\t    if (dtd != NULL) {\n\t\tis_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);\n\t\tif (is_xhtml < 0) is_xhtml = 0;\n\t    }\n\t}\n#endif\n\tif (cur->children != NULL) {\n\t    xmlNodePtr child = cur->children;\n\n\t    while (child != NULL) {\n\t\tctxt->level = 0;\n#ifdef LIBXML_HTML_ENABLED\n\t\tif (is_xhtml)\n\t\t    xhtmlNodeDumpOutput(ctxt, child);\n\t\telse\n#endif\n\t\t    xmlNodeDumpOutputInternal(ctxt, child);\n                if ((child->type != XML_XINCLUDE_START) &&\n                    (child->type != XML_XINCLUDE_END))\n                    xmlOutputBufferWrite(buf, 1, \"\\n\");\n\t\tchild = child->next;\n\t    }\n\t}\n    }\n\n    /*\n     * Restore the state of the saving context at the end of the document\n     */\n    if ((switched_encoding) && (oldctxtenc == NULL)) {\n\txmlSaveClearEncoding(ctxt);\n\tctxt->escape = oldescape;\n\tctxt->escapeAttr = oldescapeAttr;\n    }\n    cur->encoding = oldenc;\n    return(0);\n}\nvoid\nxmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc, xmlChar **doc_txt_ptr,\n\t\tint * doc_txt_len, const char * txt_encoding,\n\t\tint format) {\n    xmlSaveCtxt ctxt;\n    int                         dummy = 0;\n    xmlOutputBufferPtr          out_buff = NULL;\n    xmlCharEncodingHandlerPtr   conv_hdlr = NULL;\n\n    if (doc_txt_len == NULL) {\n        doc_txt_len = &dummy;   /*  Continue, caller just won't get length */\n    }\n\n    if (doc_txt_ptr == NULL) {\n        *doc_txt_len = 0;\n        return;\n    }\n\n    *doc_txt_ptr = NULL;\n    *doc_txt_len = 0;\n\n    if (out_doc == NULL) {\n        /*  No document, no output  */\n        return;\n    }\n\n    /*\n     *  Validate the encoding value, if provided.\n     *  This logic is copied from xmlSaveFileEnc.\n     */\n\n    if (txt_encoding == NULL)\n\ttxt_encoding = (const char *) out_doc->encoding;\n    if (txt_encoding != NULL) {\n\tconv_hdlr = xmlFindCharEncodingHandler(txt_encoding);\n\tif ( conv_hdlr == NULL ) {\n\t    xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, (xmlNodePtr) out_doc,\n\t\t       txt_encoding);\n\t    return;\n\t}\n    }\n\n    if ((out_buff = xmlAllocOutputBuffer(conv_hdlr)) == NULL ) {\n        xmlSaveErrMemory(\"creating buffer\");\n        return;\n    }\n\n    memset(&ctxt, 0, sizeof(ctxt));\n    ctxt.buf = out_buff;\n    ctxt.level = 0;\n    ctxt.format = format ? 1 : 0;\n    ctxt.encoding = (const xmlChar *) txt_encoding;\n    xmlSaveCtxtInit(&ctxt);\n    ctxt.options |= XML_SAVE_AS_XML;\n    xmlDocContentDumpOutput(&ctxt, out_doc);\n    xmlOutputBufferFlush(out_buff);\n    if (out_buff->conv != NULL) {\n\t*doc_txt_len = xmlBufUse(out_buff->conv);\n\t*doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->conv), *doc_txt_len);\n    } else {\n\t*doc_txt_len = xmlBufUse(out_buff->buffer);\n\t*doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->buffer),*doc_txt_len);\n    }\n    (void)xmlOutputBufferClose(out_buff);\n\n    if ((*doc_txt_ptr == NULL) && (*doc_txt_len > 0)) {\n        *doc_txt_len = 0;\n        xmlSaveErrMemory(\"creating output\");\n    }\n\n    return;\n}\nvoid\nxmlDocDumpMemory(xmlDocPtr cur, xmlChar**mem, int *size) {\n    xmlDocDumpFormatMemoryEnc(cur, mem, size, NULL, 0);\n}\nint\nLLVMFuzzerTestOneInput(const char *data, size_t size) {\n    static const size_t maxChunkSize = 128;\n    xmlDocPtr doc;\n    xmlParserCtxtPtr ctxt;\n    xmlTextReaderPtr reader;\n    xmlChar *out;\n    const char *docBuffer;\n    size_t docSize, consumed, chunkSize;\n    int opts, outSize;\n\n    xmlFuzzDataInit(data, size);\n    opts = xmlFuzzReadInt();\n    /* XML_PARSE_HUGE still causes timeouts. */\n    opts &= ~XML_PARSE_HUGE;\n\n    xmlFuzzReadEntities();\n    docBuffer = xmlFuzzMainEntity(&docSize);\n    if (docBuffer == NULL) {\n        xmlFuzzDataCleanup();\n        return(0);\n    }\n\n    /* Pull parser */\n\n    doc = xmlReadMemory(docBuffer, docSize, NULL, NULL, opts);\n    if (opts & XML_PARSE_XINCLUDE)\n        xmlXIncludeProcessFlags(doc, opts);\n    /* Also test the serializer. */\n    xmlDocDumpMemory(doc, &out, &outSize);\n    xmlFree(out);\n    xmlFreeDoc(doc);\n\n    /* Push parser */\n\n    ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, NULL);\n    xmlCtxtUseOptions(ctxt, opts);\n\n    for (consumed = 0; consumed < docSize; consumed += chunkSize) {\n        chunkSize = docSize - consumed;\n        if (chunkSize > maxChunkSize)\n            chunkSize = maxChunkSize;\n        xmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);\n    }\n\n    xmlParseChunk(ctxt, NULL, 0, 1);\n    if (opts & XML_PARSE_XINCLUDE)\n        xmlXIncludeProcessFlags(ctxt->myDoc, opts);\n    xmlFreeDoc(ctxt->myDoc);\n    xmlFreeParserCtxt(ctxt);\n\n    /* Reader */\n\n    reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);\n    while (xmlTextReaderRead(reader) == 1) {\n        if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {\n            int i, n = xmlTextReaderAttributeCount(reader);\n            for (i=0; i<n; i++) {\n                xmlTextReaderMoveToAttributeNo(reader, i);\n                while (xmlTextReaderReadAttributeValue(reader) == 1);\n            }\n        }\n    }\n    xmlFreeTextReader(reader);\n\n    /* Cleanup */\n\n    xmlFuzzDataCleanup();\n\n    return(0);\n}",
    "target": 0,
    "idx": 2025014
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\nxmlAddIDSafe(xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr,\n             int streaming, xmlIDPtr *id) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (id != NULL)\n        *id = NULL;\n\n    if (doc == NULL) {\n\treturn(-1);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(0);\n    }\n    if (attr == NULL) {\n\treturn(-1);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n        if (table == NULL)\n            return(-1);\n    } else {\n        ret = xmlHashLookup(table, value);\n        if (ret != NULL) {\n            /*\n             * Update the attribute to make entities work.\n             */\n            if (ret->attr != NULL) {\n                ret->attr->id = NULL;\n                ret->attr = attr;\n            }\n\t    attr->atype = XML_ATTRIBUTE_ID;\n            attr->id = ret;\n            return(0);\n        }\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL)\n\treturn(-1);\n    memset(ret, 0, sizeof(*ret));\n\n    /*\n     * fill the structure.\n     */\n    ret->doc = doc;\n    ret->value = xmlStrdup(value);\n    if (ret->value == NULL) {\n        xmlFreeID(ret);\n        return(-1);\n    }\n    if (streaming) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n        if (ret->name == NULL) {\n            xmlFreeID(ret);\n            return(-1);\n        }\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n\txmlFreeID(ret);\n\treturn(-1);\n    }\n\n    attr->atype = XML_ATTRIBUTE_ID;\n    if (!streaming)\n        attr->id = ret;\n\n    if (id != NULL)\n        *id = ret;\n    return(1);\n}\nint\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n\n    if (doc == NULL) return(-1);\n    if ((attr == NULL) || (attr->id == NULL)) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)\n        return(-1);\n\n    attr->atype = 0;\n    attr->id = NULL;\n\n    return(0);\n}\nvoid\nxmlFreeProp(xmlAttrPtr cur) {\n    xmlDictPtr dict = NULL;\n    if (cur == NULL) return;\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {\n\t    xmlRemoveID(cur->doc, cur);\n    }\n    if (cur->children != NULL) xmlFreeNodeList(cur->children);\n    DICT_FREE(cur->name)\n    xmlFree(cur);\n}\nvoid\nxmlFreePropList(xmlAttrPtr cur) {\n    xmlAttrPtr next;\n    if (cur == NULL) return;\n    while (cur != NULL) {\n        next = cur->next;\n        xmlFreeProp(cur);\n\tcur = next;\n    }\n}\nvoid\nxmlFreeNodeList(xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if (cur->doc != NULL) dict = cur->doc->dict;\n    while (1) {\n        while ((cur->children != NULL) &&\n               (cur->type != XML_DOCUMENT_NODE) &&\n               (cur->type != XML_HTML_DOCUMENT_NODE) &&\n               (cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\tif ((cur->type == XML_DOCUMENT_NODE) ||\n            (cur->type == XML_HTML_DOCUMENT_NODE)) {\n            xmlFreeDoc((xmlDocPtr) cur);\n        } else if (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlFreePropList(cur->properties);\n\t    if ((cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE) &&\n\t\t(cur->content != (xmlChar *) &(cur->properties))) {\n\t\tDICT_FREE(cur->content)\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * When a node is a text node or a comment, it uses a global static\n\t     * variable for the name of the node.\n\t     * Otherwise the node name might come from the document's\n\t     * dictionary\n\t     */\n\t    if ((cur->name != NULL) &&\n\t\t(cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name)\n\t    xmlFree(cur);\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\nvoid\nxmlFreeNode(xmlNodePtr cur) {\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return;\n\n    /* use xmlFreeDtd for DTD nodes */\n    if (cur->type == XML_DTD_NODE) {\n\txmlFreeDtd((xmlDtdPtr) cur);\n\treturn;\n    }\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNs((xmlNsPtr) cur);\n        return;\n    }\n    if (cur->type == XML_ATTRIBUTE_NODE) {\n\txmlFreeProp((xmlAttrPtr) cur);\n\treturn;\n    }\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue(cur);\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if (cur->type == XML_ENTITY_DECL) {\n        xmlEntityPtr ent = (xmlEntityPtr) cur;\n\tDICT_FREE(ent->SystemID);\n\tDICT_FREE(ent->ExternalID);\n    }\n    if ((cur->children != NULL) &&\n\t(cur->type != XML_ENTITY_REF_NODE))\n\txmlFreeNodeList(cur->children);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n        (cur->type == XML_XINCLUDE_START) ||\n        (cur->type == XML_XINCLUDE_END)) {\n        if (cur->properties != NULL)\n            xmlFreePropList(cur->properties);\n        if (cur->nsDef != NULL)\n            xmlFreeNsList(cur->nsDef);\n    } else if ((cur->content != NULL) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->content != (xmlChar *) &(cur->properties))) {\n        DICT_FREE(cur->content)\n    }\n\n    /*\n     * When a node is a text node or a comment, it uses a global static\n     * variable for the name of the node.\n     * Otherwise the node name might come from the document's dictionary\n     */\n    if ((cur->name != NULL) &&\n        (cur->type != XML_TEXT_NODE) &&\n        (cur->type != XML_COMMENT_NODE))\n\tDICT_FREE(cur->name)\n\n    xmlFree(cur);\n}\nstatic xmlNodePtr\nxmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n                    int hasTextDecl, int buildTree) {\n    xmlNodePtr root = NULL;\n    xmlNodePtr list = NULL;\n    xmlChar *rootName = BAD_CAST \"#root\";\n    int result;\n\n    if (buildTree) {\n        root = xmlNewDocNode(ctxt->myDoc, NULL, rootName, NULL);\n        if (root == NULL) {\n            xmlErrMemory(ctxt);\n            goto error;\n        }\n    }\n\n    if (xmlPushInput(ctxt, input) < 0)\n        goto error;\n\n    nameNsPush(ctxt, rootName, NULL, NULL, 0, 0);\n    spacePush(ctxt, -1);\n\n    if (buildTree)\n        nodePush(ctxt, root);\n\n    if (hasTextDecl) {\n        xmlDetectEncoding(ctxt);\n\n        /*\n         * Parse a possible text declaration first\n         */\n        if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n            (IS_BLANK_CH(NXT(5)))) {\n            xmlParseTextDecl(ctxt);\n            /*\n             * An XML-1.0 document can't reference an entity not XML-1.0\n             */\n            if ((xmlStrEqual(ctxt->version, BAD_CAST \"1.0\")) &&\n                (!xmlStrEqual(ctxt->input->version, BAD_CAST \"1.0\"))) {\n                xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,\n                               \"Version mismatch between document and \"\n                               \"entity\\n\");\n            }\n        }\n    }\n\n    xmlParseContentInternal(ctxt);\n\n    if (ctxt->input->cur < ctxt->input->end)\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n\n    if ((ctxt->wellFormed) ||\n        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n        if (root != NULL) {\n            xmlNodePtr cur;\n\n            /*\n             * Return the newly created nodeset after unlinking it from\n             * its pseudo parent.\n             */\n            cur = root->children;\n            list = cur;\n            while (cur != NULL) {\n                cur->parent = NULL;\n                cur = cur->next;\n            }\n            root->children = NULL;\n            root->last = NULL;\n        }\n    }\n\n    /*\n     * Read the rest of the stream in case of errors. We want\n     * to account for the whole entity size.\n     */\n    do {\n        ctxt->input->cur = ctxt->input->end;\n        xmlParserShrink(ctxt);\n        result = xmlParserGrow(ctxt);\n    } while (result > 0);\n\n    if (buildTree)\n        nodePop(ctxt);\n\n    namePop(ctxt);\n    spacePop(ctxt);\n\n    /* xmlPopInput would free the stream */\n    inputPop(ctxt);\n\nerror:\n    xmlFreeNode(root);\n\n    return(list);\n}\nstatic void\nxmlCtxtParseEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {\n    xmlParserInputPtr input;\n    xmlNodePtr list;\n    unsigned long consumed;\n    int isExternal;\n    int buildTree;\n    int oldMinNsIndex;\n    int oldNodelen, oldNodemem;\n\n    isExternal = (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY);\n    buildTree = (ctxt->node != NULL);\n\n    /*\n     * Recursion check\n     */\n    if (ent->flags & XML_ENT_EXPANDING) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        xmlHaltParser(ctxt);\n        goto error;\n    }\n\n    /*\n     * Load entity\n     */\n    input = xmlNewEntityInputStream(ctxt, ent);\n    if (input == NULL)\n        goto error;\n\n    /*\n     * When building a tree, we need to limit the scope of namespace\n     * declarations, so that entities don't reference xmlNs structs\n     * from the parent of a reference.\n     */\n    oldMinNsIndex = ctxt->nsdb->minNsIndex;\n    if (buildTree)\n        ctxt->nsdb->minNsIndex = ctxt->nsNr;\n\n    oldNodelen = ctxt->nodelen;\n    oldNodemem = ctxt->nodemem;\n    ctxt->nodelen = 0;\n    ctxt->nodemem = 0;\n\n    /*\n     * Parse content\n     *\n     * This initiates a recursive call chain:\n     *\n     * - xmlCtxtParseContent\n     * - xmlParseContentInternal\n     * - xmlParseReference\n     * - xmlCtxtParseEntity\n     *\n     * The nesting depth is limited by the maximum number of inputs,\n     * see xmlPushInput.\n     *\n     * It's possible to make this non-recursive (minNsIndex must be\n     * stored in the input struct) at the expense of code readability.\n     */\n\n    ent->flags |= XML_ENT_EXPANDING;\n\n    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);\n\n    ent->flags &= ~XML_ENT_EXPANDING;\n\n    ctxt->nsdb->minNsIndex = oldMinNsIndex;\n    ctxt->nodelen = oldNodelen;\n    ctxt->nodemem = oldNodemem;\n\n    /*\n     * Entity size accounting\n     */\n    consumed = input->consumed;\n    xmlSaturatedAddSizeT(&consumed, input->end - input->base);\n\n    if ((ent->flags & XML_ENT_CHECKED) == 0)\n        xmlSaturatedAdd(&ent->expandedSize, consumed);\n\n    if ((ent->flags & XML_ENT_PARSED) == 0) {\n        if (isExternal)\n            xmlSaturatedAdd(&ctxt->sizeentities, consumed);\n\n        ent->children = list;\n\n        while (list != NULL) {\n            list->parent = (xmlNodePtr) ent;\n            if (list->next == NULL)\n                ent->last = list;\n            list = list->next;\n        }\n    } else {\n        xmlFreeNodeList(list);\n    }\n\n    xmlFreeInputStream(input);\n\nerror:\n    ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n}\nint\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    size_t curBase;\n    size_t maxLength;\n    int end_in_lf = 0;\n\n    if ((ctxt == NULL) || (size < 0))\n        return(XML_ERR_ARGUMENT);\n    if (ctxt->disableSAX != 0)\n        return(ctxt->errNo);\n    if (ctxt->input == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt->input->flags |= XML_INPUT_PROGRESSIVE;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlCtxtInitializeLate(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n\n    curBase = ctxt->input->cur - ctxt->input->base;\n    maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                XML_MAX_HUGE_LENGTH :\n                XML_MAX_LOOKUP_LIMIT;\n    if (curBase > maxLength) {\n        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n                    \"Buffer size limit exceeded, try XML_PARSE_HUGE\\n\");\n        xmlHaltParser(ctxt);\n    }\n\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n            ctxt->instate = XML_PARSER_EOF;\n            xmlFinishDocument(ctxt);\n\t}\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}\nstatic int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlCtxtErrIO(reader->ctxt, reader->input->error, NULL);\n                    reader->mode = XML_TEXTREADER_MODE_ERROR;\n                    reader->state = XML_TEXTREADER_ERROR;\n                    return(-1);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\nint\nLLVMFuzzerTestOneInput(const char *data, size_t size) {\n    xmlParserCtxtPtr ctxt;\n    xmlDocPtr doc;\n    const char *docBuffer, *docUrl;\n    size_t maxAlloc, docSize;\n    int opts;\n\n    xmlFuzzDataInit(data, size);\n    opts = (int) xmlFuzzReadInt(4);\n    /*\n     * Disable options that are known to cause timeouts\n     */\n    opts &= ~XML_PARSE_XINCLUDE &\n            ~XML_PARSE_DTDVALID &\n            ~XML_PARSE_SAX1;\n    maxAlloc = xmlFuzzReadInt(4) % (size + 100);\n\n    xmlFuzzReadEntities();\n    docBuffer = xmlFuzzMainEntity(&docSize);\n    docUrl = xmlFuzzMainUrl();\n    if (docBuffer == NULL)\n        goto exit;\n\n    /* Pull parser */\n\n    xmlFuzzMemSetLimit(maxAlloc);\n    ctxt = xmlNewParserCtxt();\n    if (ctxt != NULL) {\n        doc = xmlCtxtReadMemory(ctxt, docBuffer, docSize, docUrl, NULL, opts);\n        xmlFuzzCheckMallocFailure(\"xmlCtxtReadMemory\",\n                                  doc == NULL &&\n                                  ctxt->errNo == XML_ERR_NO_MEMORY);\n\n        if (doc != NULL) {\n#ifdef LIBXML_OUTPUT_ENABLED\n            xmlBufferPtr buffer;\n            xmlSaveCtxtPtr save;\n\n            /* Also test the serializer. */\n            buffer = xmlBufferCreate();\n            save = xmlSaveToBuffer(buffer, NULL, 0);\n            if (save != NULL) {\n                int errNo;\n\n                xmlSaveDoc(save, doc);\n                errNo = xmlSaveFinish(save);\n                xmlFuzzCheckMallocFailure(\"xmlSaveDoc\",\n                                          errNo == XML_ERR_NO_MEMORY);\n            }\n            xmlBufferFree(buffer);\n#endif\n            xmlFreeDoc(doc);\n        }\n\n        xmlFreeParserCtxt(ctxt);\n    }\n\n    /* Push parser */\n\n#ifdef LIBXML_PUSH_ENABLED\n    {\n        static const size_t maxChunkSize = 128;\n        size_t consumed, chunkSize;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, docUrl);\n        if (ctxt != NULL) {\n            xmlCtxtUseOptions(ctxt, opts);\n\n            for (consumed = 0; consumed < docSize; consumed += chunkSize) {\n                chunkSize = docSize - consumed;\n                if (chunkSize > maxChunkSize)\n                    chunkSize = maxChunkSize;\n                xmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);\n            }\n\n            xmlParseChunk(ctxt, NULL, 0, 1);\n            xmlFuzzCheckMallocFailure(\"xmlParseChunk\",\n                                      ctxt->errNo == XML_ERR_NO_MEMORY);\n            xmlFreeDoc(ctxt->myDoc);\n            xmlFreeParserCtxt(ctxt);\n        }\n    }\n#endif\n\n    /* Reader */\n\n#ifdef LIBXML_READER_ENABLED\n    {\n        xmlTextReaderPtr reader;\n        const xmlError *error;\n        int j;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);\n        if (reader != NULL) {\n            while (xmlTextReaderRead(reader) == 1) {\n                if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {\n                    int i, n = xmlTextReaderAttributeCount(reader);\n                    for (i=0; i<n; i++) {\n                        xmlTextReaderMoveToAttributeNo(reader, i);\n                        while (xmlTextReaderReadAttributeValue(reader) == 1);\n                    }\n                }\n            }\n            for (j = 0; j < 10; j++)\n                xmlTextReaderRead(reader);\n            error = xmlTextReaderGetLastError(reader);\n            xmlFuzzCheckMallocFailure(\"xmlTextReaderRead\",\n                                      error->code == XML_ERR_NO_MEMORY);\n            xmlFreeTextReader(reader);\n        }\n    }\n#endif\n\nexit:\n    xmlFuzzMemSetLimit(0);\n    xmlFuzzDataCleanup();\n    xmlResetLastError();\n    return(0);\n}\nstatic int ExecuteFilesOnyByOne(int argc, char **argv,\n                                int (*callback)(const uint8_t *data,\n                                                size_t         size)) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n\n  __asan_poison_memory_region(buf, MAX_FILE);\n  ssize_t prev_length = 0;\n\n  for (int i = 1; i < argc; i++) {\n\n    int fd = 0;\n\n    if (strcmp(argv[i], \"-\") != 0) { fd = open(argv[i], O_RDONLY); }\n\n    if (fd == -1) { continue; }\n\n#ifndef __HAIKU__\n    ssize_t length = syscall(SYS_read, fd, buf, MAX_FILE);\n#else\n    ssize_t length = _kern_read(fd, buf, MAX_FILE);\n#endif  // HAIKU\n\n    if (length > 0) {\n\n      if (length < prev_length) {\n\n        __asan_poison_memory_region(buf + length, prev_length - length);\n\n      } else {\n\n        __asan_unpoison_memory_region(buf + prev_length, length - prev_length);\n\n      }\n\n      prev_length = length;\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      callback(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n    if (fd > 0) { close(fd); }\n\n  }\n\n  free(buf);\n  return 0;\n\n}\n__attribute__((weak)) int main(int argc, char **argv) {\n\n  // Enable if LLVMFuzzerTestOneInput() has the weak attribute\n  /*\n    if (!LLVMFuzzerTestOneInput) {\n\n      fprintf(stderr, \"Error: function LLVMFuzzerTestOneInput() not found!\\n\");\n      abort();\n\n    }\n\n  */\n\n  if (argc < 2 || strncmp(argv[1], \"-h\", 2) == 0)\n    printf(\n        \"============================== INFO ================================\\n\"\n        \"This binary is built for afl++.\\n\"\n        \"To run the target function on individual input(s) execute:\\n\"\n        \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n        \"To fuzz with afl-fuzz execute:\\n\"\n        \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n        \"afl-fuzz will run N iterations before re-spawning the process \"\n        \"(default: \"\n        \"INT_MAX)\\n\"\n        \"For stdin input processing, pass '-' as single command line option.\\n\"\n        \"For file input processing, pass '@@' as single command line option.\\n\"\n        \"To use with afl-cmin or afl-cmin.bash pass '-' as single command line \"\n        \"option\\n\"\n        \"===================================================================\\n\",\n        argv[0], argv[0]);\n\n  return LLVMFuzzerRunDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n\n}",
    "target": 0,
    "idx": 2066446
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\nxmlAddIDSafe(xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr,\n             int streaming, xmlIDPtr *id) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (id != NULL)\n        *id = NULL;\n\n    if (doc == NULL) {\n\treturn(-1);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(0);\n    }\n    if (attr == NULL) {\n\treturn(-1);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n        if (table == NULL)\n            return(-1);\n    } else {\n        ret = xmlHashLookup(table, value);\n        if (ret != NULL) {\n            /*\n             * Update the attribute to make entities work.\n             */\n            if (!streaming) {\n                if (ret->attr != NULL) {\n                    ret->attr->id = NULL;\n                    ret->attr = attr;\n                }\n                attr->id = ret;\n            }\n\t    attr->atype = XML_ATTRIBUTE_ID;\n            return(0);\n        }\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL)\n\treturn(-1);\n    memset(ret, 0, sizeof(*ret));\n\n    /*\n     * fill the structure.\n     */\n    ret->doc = doc;\n    ret->value = xmlStrdup(value);\n    if (ret->value == NULL) {\n        xmlFreeID(ret);\n        return(-1);\n    }\n    if (streaming) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n        if (ret->name == NULL) {\n            xmlFreeID(ret);\n            return(-1);\n        }\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n\txmlFreeID(ret);\n\treturn(-1);\n    }\n\n    attr->atype = XML_ATTRIBUTE_ID;\n    if (!streaming)\n        attr->id = ret;\n\n    if (id != NULL)\n        *id = ret;\n    return(1);\n}\nint\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n\n    if (doc == NULL) return(-1);\n    if ((attr == NULL) || (attr->id == NULL)) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)\n        return(-1);\n\n    attr->atype = 0;\n    attr->id = NULL;\n\n    return(0);\n}\nvoid\nxmlFreeProp(xmlAttrPtr cur) {\n    xmlDictPtr dict = NULL;\n    if (cur == NULL) return;\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {\n\t    xmlRemoveID(cur->doc, cur);\n    }\n    if (cur->children != NULL) xmlFreeNodeList(cur->children);\n    DICT_FREE(cur->name)\n    xmlFree(cur);\n}\nvoid\nxmlFreePropList(xmlAttrPtr cur) {\n    xmlAttrPtr next;\n    if (cur == NULL) return;\n    while (cur != NULL) {\n        next = cur->next;\n        xmlFreeProp(cur);\n\tcur = next;\n    }\n}\nvoid\nxmlFreeNodeList(xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if (cur->doc != NULL) dict = cur->doc->dict;\n    while (1) {\n        while ((cur->children != NULL) &&\n               (cur->type != XML_DOCUMENT_NODE) &&\n               (cur->type != XML_HTML_DOCUMENT_NODE) &&\n               (cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\tif ((cur->type == XML_DOCUMENT_NODE) ||\n            (cur->type == XML_HTML_DOCUMENT_NODE)) {\n            xmlFreeDoc((xmlDocPtr) cur);\n        } else if (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlFreePropList(cur->properties);\n\t    if ((cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE) &&\n\t\t(cur->content != (xmlChar *) &(cur->properties))) {\n\t\tDICT_FREE(cur->content)\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * When a node is a text node or a comment, it uses a global static\n\t     * variable for the name of the node.\n\t     * Otherwise the node name might come from the document's\n\t     * dictionary\n\t     */\n\t    if ((cur->name != NULL) &&\n\t\t(cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name)\n\t    xmlFree(cur);\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\nvoid\nxmlFreeNode(xmlNodePtr cur) {\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return;\n\n    /* use xmlFreeDtd for DTD nodes */\n    if (cur->type == XML_DTD_NODE) {\n\txmlFreeDtd((xmlDtdPtr) cur);\n\treturn;\n    }\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNs((xmlNsPtr) cur);\n        return;\n    }\n    if (cur->type == XML_ATTRIBUTE_NODE) {\n\txmlFreeProp((xmlAttrPtr) cur);\n\treturn;\n    }\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue(cur);\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if (cur->type == XML_ENTITY_DECL) {\n        xmlEntityPtr ent = (xmlEntityPtr) cur;\n\tDICT_FREE(ent->SystemID);\n\tDICT_FREE(ent->ExternalID);\n    }\n    if ((cur->children != NULL) &&\n\t(cur->type != XML_ENTITY_REF_NODE))\n\txmlFreeNodeList(cur->children);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n        (cur->type == XML_XINCLUDE_START) ||\n        (cur->type == XML_XINCLUDE_END)) {\n        if (cur->properties != NULL)\n            xmlFreePropList(cur->properties);\n        if (cur->nsDef != NULL)\n            xmlFreeNsList(cur->nsDef);\n    } else if ((cur->content != NULL) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->content != (xmlChar *) &(cur->properties))) {\n        DICT_FREE(cur->content)\n    }\n\n    /*\n     * When a node is a text node or a comment, it uses a global static\n     * variable for the name of the node.\n     * Otherwise the node name might come from the document's dictionary\n     */\n    if ((cur->name != NULL) &&\n        (cur->type != XML_TEXT_NODE) &&\n        (cur->type != XML_COMMENT_NODE))\n\tDICT_FREE(cur->name)\n\n    xmlFree(cur);\n}\nstatic xmlNodePtr\nxmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n                    int hasTextDecl, int buildTree) {\n    xmlNodePtr root = NULL;\n    xmlNodePtr list = NULL;\n    xmlChar *rootName = BAD_CAST \"#root\";\n    int result;\n\n    if (buildTree) {\n        root = xmlNewDocNode(ctxt->myDoc, NULL, rootName, NULL);\n        if (root == NULL) {\n            xmlErrMemory(ctxt);\n            goto error;\n        }\n    }\n\n    if (xmlPushInput(ctxt, input) < 0)\n        goto error;\n\n    nameNsPush(ctxt, rootName, NULL, NULL, 0, 0);\n    spacePush(ctxt, -1);\n\n    if (buildTree)\n        nodePush(ctxt, root);\n\n    if (hasTextDecl) {\n        xmlDetectEncoding(ctxt);\n\n        /*\n         * Parse a possible text declaration first\n         */\n        if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n            (IS_BLANK_CH(NXT(5)))) {\n            xmlParseTextDecl(ctxt);\n            /*\n             * An XML-1.0 document can't reference an entity not XML-1.0\n             */\n            if ((xmlStrEqual(ctxt->version, BAD_CAST \"1.0\")) &&\n                (!xmlStrEqual(ctxt->input->version, BAD_CAST \"1.0\"))) {\n                xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,\n                               \"Version mismatch between document and \"\n                               \"entity\\n\");\n            }\n        }\n    }\n\n    xmlParseContentInternal(ctxt);\n\n    if (ctxt->input->cur < ctxt->input->end)\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n\n    if ((ctxt->wellFormed) ||\n        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n        if (root != NULL) {\n            xmlNodePtr cur;\n\n            /*\n             * Return the newly created nodeset after unlinking it from\n             * its pseudo parent.\n             */\n            cur = root->children;\n            list = cur;\n            while (cur != NULL) {\n                cur->parent = NULL;\n                cur = cur->next;\n            }\n            root->children = NULL;\n            root->last = NULL;\n        }\n    }\n\n    /*\n     * Read the rest of the stream in case of errors. We want\n     * to account for the whole entity size.\n     */\n    do {\n        ctxt->input->cur = ctxt->input->end;\n        xmlParserShrink(ctxt);\n        result = xmlParserGrow(ctxt);\n    } while (result > 0);\n\n    if (buildTree)\n        nodePop(ctxt);\n\n    namePop(ctxt);\n    spacePop(ctxt);\n\n    /* xmlPopInput would free the stream */\n    inputPop(ctxt);\n\nerror:\n    xmlFreeNode(root);\n\n    return(list);\n}\nstatic void\nxmlCtxtParseEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {\n    xmlParserInputPtr input;\n    xmlNodePtr list;\n    unsigned long consumed;\n    int isExternal;\n    int buildTree;\n    int oldMinNsIndex;\n    int oldNodelen, oldNodemem;\n\n    isExternal = (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY);\n    buildTree = (ctxt->node != NULL);\n\n    /*\n     * Recursion check\n     */\n    if (ent->flags & XML_ENT_EXPANDING) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        xmlHaltParser(ctxt);\n        goto error;\n    }\n\n    /*\n     * Load entity\n     */\n    input = xmlNewEntityInputStream(ctxt, ent);\n    if (input == NULL)\n        goto error;\n\n    /*\n     * When building a tree, we need to limit the scope of namespace\n     * declarations, so that entities don't reference xmlNs structs\n     * from the parent of a reference.\n     */\n    oldMinNsIndex = ctxt->nsdb->minNsIndex;\n    if (buildTree)\n        ctxt->nsdb->minNsIndex = ctxt->nsNr;\n\n    oldNodelen = ctxt->nodelen;\n    oldNodemem = ctxt->nodemem;\n    ctxt->nodelen = 0;\n    ctxt->nodemem = 0;\n\n    /*\n     * Parse content\n     *\n     * This initiates a recursive call chain:\n     *\n     * - xmlCtxtParseContent\n     * - xmlParseContentInternal\n     * - xmlParseReference\n     * - xmlCtxtParseEntity\n     *\n     * The nesting depth is limited by the maximum number of inputs,\n     * see xmlPushInput.\n     *\n     * It's possible to make this non-recursive (minNsIndex must be\n     * stored in the input struct) at the expense of code readability.\n     */\n\n    ent->flags |= XML_ENT_EXPANDING;\n\n    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);\n\n    ent->flags &= ~XML_ENT_EXPANDING;\n\n    ctxt->nsdb->minNsIndex = oldMinNsIndex;\n    ctxt->nodelen = oldNodelen;\n    ctxt->nodemem = oldNodemem;\n\n    /*\n     * Entity size accounting\n     */\n    consumed = input->consumed;\n    xmlSaturatedAddSizeT(&consumed, input->end - input->base);\n\n    if ((ent->flags & XML_ENT_CHECKED) == 0)\n        xmlSaturatedAdd(&ent->expandedSize, consumed);\n\n    if ((ent->flags & XML_ENT_PARSED) == 0) {\n        if (isExternal)\n            xmlSaturatedAdd(&ctxt->sizeentities, consumed);\n\n        ent->children = list;\n\n        while (list != NULL) {\n            list->parent = (xmlNodePtr) ent;\n            if (list->next == NULL)\n                ent->last = list;\n            list = list->next;\n        }\n    } else {\n        xmlFreeNodeList(list);\n    }\n\n    xmlFreeInputStream(input);\n\nerror:\n    ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n}\nint\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    size_t curBase;\n    size_t maxLength;\n    int end_in_lf = 0;\n\n    if ((ctxt == NULL) || (size < 0))\n        return(XML_ERR_ARGUMENT);\n    if (ctxt->disableSAX != 0)\n        return(ctxt->errNo);\n    if (ctxt->input == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt->input->flags |= XML_INPUT_PROGRESSIVE;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlCtxtInitializeLate(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n\n    curBase = ctxt->input->cur - ctxt->input->base;\n    maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                XML_MAX_HUGE_LENGTH :\n                XML_MAX_LOOKUP_LIMIT;\n    if (curBase > maxLength) {\n        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n                    \"Buffer size limit exceeded, try XML_PARSE_HUGE\\n\");\n        xmlHaltParser(ctxt);\n    }\n\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n            ctxt->instate = XML_PARSER_EOF;\n            xmlFinishDocument(ctxt);\n\t}\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}\nstatic int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlCtxtErrIO(reader->ctxt, reader->input->error, NULL);\n                    reader->mode = XML_TEXTREADER_MODE_ERROR;\n                    reader->state = XML_TEXTREADER_ERROR;\n                    return(-1);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\nint\nLLVMFuzzerTestOneInput(const char *data, size_t size) {\n    xmlParserCtxtPtr ctxt;\n    xmlDocPtr doc;\n    const char *docBuffer, *docUrl;\n    size_t maxAlloc, docSize;\n    int opts;\n\n    xmlFuzzDataInit(data, size);\n    opts = (int) xmlFuzzReadInt(4);\n    /*\n     * Disable options that are known to cause timeouts\n     */\n    opts &= ~XML_PARSE_XINCLUDE &\n            ~XML_PARSE_DTDVALID &\n            ~XML_PARSE_SAX1;\n    maxAlloc = xmlFuzzReadInt(4) % (size + 100);\n\n    xmlFuzzReadEntities();\n    docBuffer = xmlFuzzMainEntity(&docSize);\n    docUrl = xmlFuzzMainUrl();\n    if (docBuffer == NULL)\n        goto exit;\n\n    /* Pull parser */\n\n    xmlFuzzMemSetLimit(maxAlloc);\n    ctxt = xmlNewParserCtxt();\n    if (ctxt != NULL) {\n        doc = xmlCtxtReadMemory(ctxt, docBuffer, docSize, docUrl, NULL, opts);\n        xmlFuzzCheckMallocFailure(\"xmlCtxtReadMemory\",\n                                  doc == NULL &&\n                                  ctxt->errNo == XML_ERR_NO_MEMORY);\n\n        if (doc != NULL) {\n#ifdef LIBXML_OUTPUT_ENABLED\n            xmlBufferPtr buffer;\n            xmlSaveCtxtPtr save;\n\n            /* Also test the serializer. */\n            buffer = xmlBufferCreate();\n            save = xmlSaveToBuffer(buffer, NULL, 0);\n            if (save != NULL) {\n                int errNo;\n\n                xmlSaveDoc(save, doc);\n                errNo = xmlSaveFinish(save);\n                xmlFuzzCheckMallocFailure(\"xmlSaveDoc\",\n                                          errNo == XML_ERR_NO_MEMORY);\n            }\n            xmlBufferFree(buffer);\n#endif\n            xmlFreeDoc(doc);\n        }\n\n        xmlFreeParserCtxt(ctxt);\n    }\n\n    /* Push parser */\n\n#ifdef LIBXML_PUSH_ENABLED\n    {\n        static const size_t maxChunkSize = 128;\n        size_t consumed, chunkSize;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, docUrl);\n        if (ctxt != NULL) {\n            xmlCtxtUseOptions(ctxt, opts);\n\n            for (consumed = 0; consumed < docSize; consumed += chunkSize) {\n                chunkSize = docSize - consumed;\n                if (chunkSize > maxChunkSize)\n                    chunkSize = maxChunkSize;\n                xmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);\n            }\n\n            xmlParseChunk(ctxt, NULL, 0, 1);\n            xmlFuzzCheckMallocFailure(\"xmlParseChunk\",\n                                      ctxt->errNo == XML_ERR_NO_MEMORY);\n            xmlFreeDoc(ctxt->myDoc);\n            xmlFreeParserCtxt(ctxt);\n        }\n    }\n#endif\n\n    /* Reader */\n\n#ifdef LIBXML_READER_ENABLED\n    {\n        xmlTextReaderPtr reader;\n        const xmlError *error;\n        int j;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);\n        if (reader != NULL) {\n            while (xmlTextReaderRead(reader) == 1) {\n                if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {\n                    int i, n = xmlTextReaderAttributeCount(reader);\n                    for (i=0; i<n; i++) {\n                        xmlTextReaderMoveToAttributeNo(reader, i);\n                        while (xmlTextReaderReadAttributeValue(reader) == 1);\n                    }\n                }\n            }\n            for (j = 0; j < 10; j++)\n                xmlTextReaderRead(reader);\n            error = xmlTextReaderGetLastError(reader);\n            xmlFuzzCheckMallocFailure(\"xmlTextReaderRead\",\n                                      error->code == XML_ERR_NO_MEMORY);\n            xmlFreeTextReader(reader);\n        }\n    }\n#endif\n\nexit:\n    xmlFuzzMemSetLimit(0);\n    xmlFuzzDataCleanup();\n    xmlResetLastError();\n    return(0);\n}",
    "target": 0,
    "idx": 2066502
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii, nobjs;\n\n\t\tif (acl == NULL) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\n\t\tnobjs = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (nobjs < 1) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_DATA_OBJECT_NOT_FOUND,\n\t\t\t\t\"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii = 0; ii < nobjs; ii++) {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t}\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\nint sc_file_valid(const sc_file_t *file) {\n\tif (file == NULL)\n\t\treturn 0;\n\treturn file->magic == SC_FILE_MAGIC;\n}\nvoid sc_file_free(sc_file_t *file)\n{\n\tunsigned int i;\n\tif (file == NULL || !sc_file_valid(file))\n\t\treturn;\n\tfile->magic = 0;\n\tfor (i = 0; i < SC_MAX_AC_OPS; i++)\n\t\tsc_file_clear_acl_entries(file, i);\n\tif (file->sec_attr)\n\t\tfree(file->sec_attr);\n\tif (file->prop_attr)\n\t\tfree(file->prop_attr);\n\tif (file->type_attr)\n\t\tfree(file->type_attr);\n\tif (file->encoded_content)\n\t\tfree(file->encoded_content);\n\tfree(file);\n}\nstatic int\nsc_pkcs15emu_oberthur_init(struct sc_pkcs15_card * p15card)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_auth_info auth_info;\n\tstruct sc_pkcs15_object   obj;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_path path;\n\tint rv, ii, tries_left;\n\tchar serial[0x10];\n\tunsigned char sopin_reference = 0x04;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_bin_to_hex(card->serialnr.value, card->serialnr.len, serial, sizeof(serial), 0);\n\tset_string(&p15card->tokeninfo->serial_number, serial);\n\n\tp15card->ops.parse_df = sc_awp_parse_df;\n\tp15card->ops.clear = sc_awp_clear;\n\n\tsc_log(ctx, \"Oberthur init: serial %s\", p15card->tokeninfo->serial_number);\n\n\tsc_format_path(AWP_PIN_DF, &path);\n\trv = sc_select_file(card, &path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot select PIN dir\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tsopin_reference = 0x84;\n\t\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\t}\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)\n\t\tLOG_TEST_RET(ctx, rv, \"Invalid state of SO-PIN\");\n\n\t/* add PIN */\n\tmemset(&auth_info, 0, sizeof(auth_info));\n\tmemset(&obj,  0, sizeof(obj));\n\n\tauth_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tauth_info.auth_method\t= SC_AC_CHV;\n\tauth_info.auth_id.len = 1;\n\tauth_info.auth_id.value[0] = 0xFF;\n\tauth_info.attrs.pin.min_length\t\t= 4;\n\tauth_info.attrs.pin.max_length\t\t= 64;\n\tauth_info.attrs.pin.stored_length\t= 64;\n\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tauth_info.attrs.pin.reference\t\t= sopin_reference;\n\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t| SC_PKCS15_PIN_FLAG_SO_PIN;\n\tauth_info.tries_left\t\t= tries_left;\n\tauth_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tstrncpy(obj.label, \"SO PIN\", SC_PKCS15_MAX_LABEL_SIZE-1);\n\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, 0x81, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv == SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\t/* add PIN */\n\t\tmemset(&auth_info, 0, sizeof(auth_info));\n\t\tmemset(&obj,  0, sizeof(obj));\n\n\t\tauth_info.auth_id.len = sizeof(PinDomainID) > sizeof(auth_info.auth_id.value)\n\t\t\t\t? sizeof(auth_info.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(auth_info.auth_id.value, PinDomainID, auth_info.auth_id.len);\n\t\tauth_info.auth_method\t= SC_AC_CHV;\n\n\t\tauth_info.attrs.pin.min_length\t\t= 4;\n\t\tauth_info.attrs.pin.max_length\t\t= 64;\n\t\tauth_info.attrs.pin.stored_length\t= 64;\n\t\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tauth_info.attrs.pin.reference\t\t= 0x81;\n\t\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\t\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_LOCAL;\n\t\tauth_info.tries_left\t\t= tries_left;\n\n\t\tstrncpy(obj.label, PIN_DOMAIN_LABEL, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\t\tif (sopin_reference == 0x84) {\n\t\t\t/*\n\t\t\t * auth_pin_reset_oberthur_style() in card-oberthur.c\n\t\t\t * always uses PUK with reference 0x84 for\n\t\t\t * unblocking of User PIN\n\t\t\t */\n\t\t\tobj.auth_id.len = 1;\n\t\t\tobj.auth_id.value[0] = 0xFF;\n\t\t}\n\n\t\tsc_format_path(AWP_PIN_DF, &auth_info.path);\n\t\tauth_info.path.type = SC_PATH_TYPE_PATH;\n\n\t\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\t\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\t}\n\telse if (rv != SC_ERROR_DATA_OBJECT_NOT_FOUND)    {\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot verify PIN\");\n\t}\n\n\tfor (ii=0; oberthur_infos[ii].name; ii++)   {\n\t\tsc_log(ctx, \"Oberthur init: read %s file\", oberthur_infos[ii].name);\n\t\tfree(oberthur_infos[ii].content);\n\t\trv = sc_oberthur_read_file(p15card, oberthur_infos[ii].path,\n\t\t\t\t&oberthur_infos[ii].content, &oberthur_infos[ii].len, 1);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: read oberthur file error\");\n\n\t\tsc_log(ctx,\n\t\t       \"Oberthur init: parse %s file, content length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       oberthur_infos[ii].name, oberthur_infos[ii].len);\n\t\trv = oberthur_infos[ii].parser(p15card, oberthur_infos[ii].content, oberthur_infos[ii].len,\n\t\t\t\toberthur_infos[ii].postpone_allowed);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: parse error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\nint\nsc_pkcs15emu_oberthur_init_ex(struct sc_pkcs15_card * p15card, struct sc_aid *aid)\n{\n\tint rv;\n\n\tLOG_FUNC_CALLED(p15card->card->ctx);\n\trv = oberthur_detect_card(p15card);\n\tif (!rv)\n\t\trv = sc_pkcs15emu_oberthur_init(p15card);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\nint\nsc_pkcs15_bind_synthetic(sc_pkcs15_card_t *p15card, struct sc_aid *aid)\n{\n\tsc_context_t\t\t*ctx = p15card->card->ctx;\n\tscconf_block\t\t*conf_block, **blocks, *blk;\n\tint\t\t\ti, r = SC_ERROR_WRONG_CARD;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tconf_block = NULL;\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\n\tif (!conf_block) {\n\t\t/* no conf file found => try builtin drivers  */\n\t\tsc_log(ctx, \"no conf file (or section), trying all builtin emulators\");\n\t\tfor (i = 0; builtin_emulators[i].name; i++) {\n\t\t\tsc_log(ctx, \"trying %s\", builtin_emulators[i].name);\n\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t/* we got a hit */\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* we have a conf file => let's use it */\n\t\tint builtin_enabled;\n\t\tconst scconf_list *list, *item;\n\n\t\tbuiltin_enabled = scconf_get_bool(conf_block, \"enable_builtin_emulation\", 1);\n\t\tlist = scconf_find_list(conf_block, \"builtin_emulators\"); /* FIXME: rename to enabled_emulators */\n\n\t\tif (builtin_enabled && list) {\n\t\t\t/* get the list of enabled emulation drivers */\n\t\t\tfor (item = list; item; item = item->next) {\n\t\t\t\t/* go through the list of builtin drivers */\n\t\t\t\tconst char *name = item->data;\n\n\t\t\t\tsc_log(ctx, \"trying %s\", name);\n\t\t\t\tfor (i = 0; builtin_emulators[i].name; i++)\n\t\t\t\t\tif (!strcmp(builtin_emulators[i].name, name)) {\n\t\t\t\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\t\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t\t\t\t/* we got a hit */\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (builtin_enabled) {\n\t\t\tsc_log(ctx, \"no emulator list in config file, trying all builtin emulators\");\n\t\t\tfor (i = 0; builtin_emulators[i].name; i++) {\n\t\t\t\tsc_log(ctx, \"trying %s\", builtin_emulators[i].name);\n\t\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t\t/* we got a hit */\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* search for 'emulate foo { ... }' entries in the conf file */\n\t\tsc_log(ctx, \"searching for 'emulate foo { ... }' blocks\");\n\t\tblocks = scconf_find_blocks(ctx->conf, conf_block, \"emulate\", NULL);\n\t\tsc_log(ctx, \"Blocks: %p\", blocks);\n\t\tfor (i = 0; blocks && (blk = blocks[i]) != NULL; i++) {\n\t\t\tconst char *name = blk->name->data;\n\t\t\tsc_log(ctx, \"trying %s\", name);\n\t\t\tr = parse_emu_block(p15card, aid, blk);\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tfree(blocks);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (blocks)\n\t\t\tfree(blocks);\n\t}\n\nout:\n\tif (r == SC_SUCCESS) {\n\t\tp15card->magic  = SC_PKCS15_CARD_MAGIC;\n\t\tp15card->flags |= SC_PKCS15_CARD_FLAG_EMULATED;\n\t} else {\n\t\tif (r != SC_ERROR_WRONG_CARD)\n\t\t\tsc_log(ctx, \"Failed to load card emulator: %s\", sc_strerror(r));\n\t}\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\nint\nsc_pkcs15_bind(struct sc_card *card, struct sc_aid *aid,\n\t\tstruct sc_pkcs15_card **p15card_out)\n{\n\tstruct sc_pkcs15_card *p15card = NULL;\n\tstruct sc_context *ctx;\n\tscconf_block *conf_block = NULL;\n\tint r, emu_first, enable_emu;\n\tconst char *private_certificate;\n\n\tif (card == NULL || p15card_out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tctx = card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"application(aid:'%s')\", aid ? sc_dump_hex(aid->value, aid->len) : \"empty\");\n\n\tp15card = sc_pkcs15_card_new();\n\tif (p15card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tp15card->card = card;\n\tp15card->opts.use_file_cache = 0;\n\tp15card->opts.use_pin_cache = 1;\n\tp15card->opts.pin_cache_counter = 10;\n\tp15card->opts.pin_cache_ignore_user_consent = 0;\n\tif(0 == strcmp(ctx->app_name, \"tokend\")) {\n\t\tprivate_certificate = \"ignore\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else {\n\t\tprivate_certificate = \"protect\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t}\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\tif (conf_block) {\n\t\tp15card->opts.use_file_cache = scconf_get_bool(conf_block, \"use_file_caching\", p15card->opts.use_file_cache);\n\t\tp15card->opts.use_pin_cache = scconf_get_bool(conf_block, \"use_pin_caching\", p15card->opts.use_pin_cache);\n\t\tp15card->opts.pin_cache_counter = scconf_get_int(conf_block, \"pin_cache_counter\", p15card->opts.pin_cache_counter);\n\t\tp15card->opts.pin_cache_ignore_user_consent = scconf_get_bool(conf_block, \"pin_cache_ignore_user_consent\",\n\t\t\t\tp15card->opts.pin_cache_ignore_user_consent);\n\t\tprivate_certificate = scconf_get_str(conf_block, \"private_certificate\", private_certificate);\n\t}\n\tif (0 == strcmp(private_certificate, \"protect\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t} else if (0 == strcmp(private_certificate, \"ignore\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else if (0 == strcmp(private_certificate, \"declassify\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_DECLASSIFY;\n\t}\n\tsc_log(ctx, \"PKCS#15 options: use_file_cache=%d use_pin_cache=%d pin_cache_counter=%d pin_cache_ignore_user_consent=%d private_certificate=%d\",\n\t\t\tp15card->opts.use_file_cache, p15card->opts.use_pin_cache,p15card->opts.pin_cache_counter,\n\t\t\tp15card->opts.pin_cache_ignore_user_consent, p15card->opts.private_certificate);\n\n\tr = sc_lock(card);\n\tif (r) {\n\t\tsc_log(ctx, \"sc_lock() failed: %s\", sc_strerror(r));\n\t\tsc_pkcs15_card_free(p15card);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tenable_emu = scconf_get_bool(conf_block, \"enable_pkcs15_emulation\", 1);\n\tif (enable_emu) {\n\t\tsc_log(ctx, \"PKCS#15 emulation enabled\");\n\t\temu_first = scconf_get_bool(conf_block, \"try_emulation_first\", 0);\n\t\tif (emu_first || sc_pkcs15_is_emulation_only(card)) {\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\telse {\n\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t}\ndone:\n\t*p15card_out = p15card;\n\tsc_unlock(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerror:\n\tsc_unlock(card);\n\tsc_pkcs15_card_free(p15card);\n\tLOG_FUNC_RETURN(ctx, r);\n}\nint LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size)\n{\n    struct sc_context *ctx = NULL;\n    struct sc_card *card = NULL;\n    struct sc_pkcs15_card *p15card = NULL;\n    struct sc_reader *reader;\n    struct sc_pkcs15_object *obj;\n\n    sc_establish_context(&ctx, \"fuzz\");\n    if (!ctx)\n        return 0;\n    /* copied from sc_release_context() */\n    while (list_size(&ctx->readers)) {\n        sc_reader_t *rdr = (sc_reader_t *) list_get_at(&ctx->readers, 0);\n        _sc_delete_reader(ctx, rdr);\n    }\n    if (ctx->reader_driver->ops->finish != NULL)\n        ctx->reader_driver->ops->finish(ctx);\n\n    ctx->reader_driver = sc_get_fuzz_driver();\n\n    fuzz_add_reader(ctx, Data, Size);\n\n    reader = sc_ctx_get_reader(ctx, 0);\n    sc_connect_card(reader, &card);\n    sc_pkcs15_bind(card, NULL, &p15card);\n\n    if (p15card) {\n        const uint8_t *in, *param;\n        uint16_t in_len, param_len;\n        fuzz_get_chunk(reader, &in, &in_len);\n        fuzz_get_chunk(reader, &param, &param_len);\n        for (obj = p15card->obj_list; obj != NULL; obj = obj->next) {\n            u8 buf[0xFFFF];\n            size_t i;\n\n            int decipher_flags[] = {SC_ALGORITHM_RSA_RAW,\n                SC_ALGORITHM_RSA_PAD_PKCS1, SC_ALGORITHM_RSA_PAD_ANSI,\n                SC_ALGORITHM_RSA_PAD_ISO9796};\n            for (i = 0; i < sizeof decipher_flags/sizeof *decipher_flags; i++) {\n                sc_pkcs15_decipher(p15card, obj, decipher_flags[i],\n                        in, in_len, buf, sizeof buf);\n            }\n\n            i = sizeof buf;\n            sc_pkcs15_derive(p15card, obj, 0,\n                    in, in_len, buf, &i);\n\n            int wrap_flags[] = {0, SC_ALGORITHM_AES_ECB, SC_ALGORITHM_AES_CBC_PAD,\n                SC_ALGORITHM_AES_CBC};\n            for (i = 0; i < sizeof wrap_flags/sizeof *wrap_flags; i++) {\n                /* see `pkcs15_create_secret_key` in\n                 * `src/pkcs11/framework-pkc15.c` for creating a temporary\n                 * secret key for wrapping/unwrapping */\n                unsigned long l = sizeof buf;\n                struct sc_pkcs15_object target_key;\n                struct sc_pkcs15_skey_info skey_info;\n                uint16_t len;\n                memset(&target_key, 0, sizeof target_key);\n                memset(&skey_info, 0, sizeof skey_info);\n                target_key.type = SC_PKCS15_TYPE_SKEY;\n                target_key.flags = 2; /* TODO not sure what these mean */\n                target_key.session_object = 1;\n                target_key.data = &skey_info;\n                skey_info.usage = SC_PKCS15_PRKEY_USAGE_UNWRAP | SC_PKCS15_PRKEY_USAGE_WRAP\n                    | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n                skey_info.native = 0; /* card can not use this */\n                skey_info.access_flags = 0; /* looks like not needed */\n                skey_info.key_type = 0x1fUL; /* CKK_AES */\n                skey_info.value_len = 128;\n                fuzz_get_chunk(reader, (const u8 **) &skey_info.data.value, &len);\n                skey_info.data.len = len;\n\n                sc_pkcs15_unwrap(p15card, obj, &target_key, wrap_flags[i],\n                        in, in_len, param, param_len);\n                sc_pkcs15_wrap(p15card, obj, &target_key, wrap_flags[i],\n                        buf, &l, in, in_len);\n            }\n\n            int signature_flags[] = {SC_ALGORITHM_RSA_RAW,\n                SC_ALGORITHM_RSA_PAD_PKCS1, SC_ALGORITHM_RSA_PAD_ANSI,\n                SC_ALGORITHM_RSA_PAD_ISO9796,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA1,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA256,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA384,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA512,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA224,\n                SC_ALGORITHM_ECDSA_RAW, SC_ALGORITHM_ECDSA_HASH_SHA1,\n                SC_ALGORITHM_ECDSA_HASH_SHA224, SC_ALGORITHM_ECDSA_HASH_SHA256,\n                SC_ALGORITHM_ECDSA_HASH_SHA384, SC_ALGORITHM_ECDSA_HASH_SHA512,\n                SC_ALGORITHM_GOSTR3410_RAW, SC_ALGORITHM_GOSTR3410_HASH_GOSTR3411,\n                SC_ALGORITHM_GOSTR3410_HASHES,\n            };\n            for (i = 0; i < sizeof signature_flags/sizeof *signature_flags; i++) {\n                sc_pkcs15_compute_signature(p15card, obj, signature_flags[i],\n                        in, in_len, buf, sizeof buf);\n            }\n\n            if (obj->type == SC_PKCS15_TYPE_AUTH_PIN) {\n                sc_pkcs15_verify_pin(p15card, obj, in, in_len);\n                sc_pkcs15_change_pin(p15card, obj, in, in_len, param, param_len);\n                sc_pkcs15_unblock_pin(p15card, obj, in, in_len, param, param_len);\n                sc_pkcs15_get_pin_info(p15card, obj);\n            }\n        }\n        sc_pkcs15_card_free(p15card);\n    }\n\n    sc_disconnect_card(card);\n    sc_release_context(ctx);\n\n    return 0;\n}",
    "target": 0,
    "idx": 2028843
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nparse_odp_action(const char *s, const struct simap *port_names,\n                 struct ofpbuf *actions)\n{\n    {\n        uint32_t port;\n        int n;\n\n        if (ovs_scan(s, \"%\"SCNi32\"%n\", &port, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_OUTPUT, port);\n            return n;\n        }\n    }\n\n    {\n        uint32_t max_len;\n        int n;\n\n        if (ovs_scan(s, \"trunc(%\"SCNi32\")%n\", &max_len, &n)) {\n            struct ovs_action_trunc *trunc;\n\n            trunc = nl_msg_put_unspec_uninit(actions,\n                     OVS_ACTION_ATTR_TRUNC, sizeof *trunc);\n            trunc->max_len = max_len;\n            return n;\n        }\n    }\n\n    if (port_names) {\n        int len = strcspn(s, delimiters);\n        struct simap_node *node;\n\n        node = simap_find_len(port_names, s, len);\n        if (node) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_OUTPUT, node->data);\n            return len;\n        }\n    }\n\n    {\n        uint32_t recirc_id;\n        int n = -1;\n\n        if (ovs_scan(s, \"recirc(%\"PRIu32\")%n\", &recirc_id, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_RECIRC, recirc_id);\n            return n;\n        }\n    }\n\n    if (!strncmp(s, \"userspace(\", 10)) {\n        return parse_odp_userspace_action(s, actions);\n    }\n\n    if (!strncmp(s, \"set(\", 4)) {\n        size_t start_ofs;\n        int retval;\n        struct nlattr mask[1024 / sizeof(struct nlattr)];\n        struct ofpbuf maskbuf = OFPBUF_STUB_INITIALIZER(mask);\n        struct nlattr *nested, *key;\n        size_t size;\n\n        start_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_SET);\n        retval = parse_odp_key_mask_attr(s + 4, port_names, actions, &maskbuf);\n        if (retval < 0) {\n            ofpbuf_uninit(&maskbuf);\n            return retval;\n        }\n        if (s[retval + 4] != ')') {\n            ofpbuf_uninit(&maskbuf);\n            return -EINVAL;\n        }\n\n        nested = ofpbuf_at_assert(actions, start_ofs, sizeof *nested);\n        key = nested + 1;\n\n        size = nl_attr_get_size(mask);\n        if (size == nl_attr_get_size(key)) {\n            /* Change to masked set action if not fully masked. */\n            if (!is_all_ones(mask + 1, size)) {\n                /* Remove padding of eariler key payload  */\n                actions->size -= NLA_ALIGN(key->nla_len) - key->nla_len;\n\n                /* Put mask payload right after key payload */\n                key->nla_len += size;\n                ofpbuf_put(actions, mask + 1, size);\n\n                /* 'actions' may have been reallocated by ofpbuf_put(). */\n                nested = ofpbuf_at_assert(actions, start_ofs, sizeof *nested);\n                nested->nla_type = OVS_ACTION_ATTR_SET_MASKED;\n\n                key = nested + 1;\n                /* Add new padding as needed */\n                ofpbuf_put_zeros(actions, NLA_ALIGN(key->nla_len) -\n                                          key->nla_len);\n            }\n        }\n        ofpbuf_uninit(&maskbuf);\n\n        nl_msg_end_nested(actions, start_ofs);\n        return retval + 5;\n    }\n\n    {\n        struct ovs_action_push_vlan push;\n        int tpid = ETH_TYPE_VLAN;\n        int vid, pcp;\n        int cfi = 1;\n        int n = -1;\n\n        if (ovs_scan(s, \"push_vlan(vid=%i,pcp=%i)%n\", &vid, &pcp, &n)\n            || ovs_scan(s, \"push_vlan(vid=%i,pcp=%i,cfi=%i)%n\",\n                        &vid, &pcp, &cfi, &n)\n            || ovs_scan(s, \"push_vlan(tpid=%i,vid=%i,pcp=%i)%n\",\n                        &tpid, &vid, &pcp, &n)\n            || ovs_scan(s, \"push_vlan(tpid=%i,vid=%i,pcp=%i,cfi=%i)%n\",\n                        &tpid, &vid, &pcp, &cfi, &n)) {\n            push.vlan_tpid = htons(tpid);\n            push.vlan_tci = htons((vid << VLAN_VID_SHIFT)\n                                  | (pcp << VLAN_PCP_SHIFT)\n                                  | (cfi ? VLAN_CFI : 0));\n            nl_msg_put_unspec(actions, OVS_ACTION_ATTR_PUSH_VLAN,\n                              &push, sizeof push);\n\n            return n;\n        }\n    }\n\n    if (!strncmp(s, \"pop_vlan\", 8)) {\n        nl_msg_put_flag(actions, OVS_ACTION_ATTR_POP_VLAN);\n        return 8;\n    }\n\n    {\n        unsigned long long int meter_id;\n        int n = -1;\n\n        if (sscanf(s, \"meter(%lli)%n\", &meter_id, &n) > 0 && n > 0) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_METER, meter_id);\n            return n;\n        }\n    }\n\n    {\n        double percentage;\n        int n = -1;\n\n        if (ovs_scan(s, \"sample(sample=%lf%%,actions(%n\", &percentage, &n)\n            && percentage >= 0. && percentage <= 100.0) {\n            size_t sample_ofs, actions_ofs;\n            double probability;\n\n            probability = floor(UINT32_MAX * (percentage / 100.0) + .5);\n            sample_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_SAMPLE);\n            nl_msg_put_u32(actions, OVS_SAMPLE_ATTR_PROBABILITY,\n                           (probability <= 0 ? 0\n                            : probability >= UINT32_MAX ? UINT32_MAX\n                            : probability));\n\n            actions_ofs = nl_msg_start_nested(actions,\n                                              OVS_SAMPLE_ATTR_ACTIONS);\n            int retval = parse_action_list(s + n, port_names, actions);\n            if (retval < 0)\n                return retval;\n\n            n += retval;\n            nl_msg_end_nested(actions, actions_ofs);\n            nl_msg_end_nested(actions, sample_ofs);\n\n            return s[n + 1] == ')' ? n + 2 : -EINVAL;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"clone(\", 6)) {\n            size_t actions_ofs;\n            int n = 6;\n\n            actions_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_CLONE);\n            int retval = parse_action_list(s + n, port_names, actions);\n            if (retval < 0) {\n                return retval;\n            }\n            n += retval;\n            nl_msg_end_nested(actions, actions_ofs);\n            return n + 1;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"push_nsh(\", 9)) {\n            int retval = parse_odp_push_nsh_action(s, actions);\n            if (retval < 0) {\n                return retval;\n            }\n            return retval + 1;\n        }\n    }\n\n    {\n        int n;\n        if (ovs_scan(s, \"pop_nsh()%n\", &n)) {\n            nl_msg_put_flag(actions, OVS_ACTION_ATTR_POP_NSH);\n            return n;\n        }\n    }\n\n    {\n        uint32_t port;\n        int n;\n\n        if (ovs_scan(s, \"tnl_pop(%\"SCNi32\")%n\", &port, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_TUNNEL_POP, port);\n            return n;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"ct_clear\", 8)) {\n            nl_msg_put_flag(actions, OVS_ACTION_ATTR_CT_CLEAR);\n            return 8;\n        }\n    }\n\n    {\n        int retval;\n\n        retval = parse_conntrack_action(s, actions);\n        if (retval) {\n            return retval;\n        }\n    }\n\n    {\n        struct ovs_action_push_tnl data;\n        int n;\n\n        n = ovs_parse_tnl_push(s, &data);\n        if (n > 0) {\n            odp_put_tnl_push_action(actions, &data);\n            return n;\n        } else if (n < 0) {\n            return n;\n        }\n    }\n    return -EINVAL;\n}\nint\nodp_actions_from_string(const char *s, const struct simap *port_names,\n                        struct ofpbuf *actions)\n{\n    size_t old_size;\n\n    if (!strcasecmp(s, \"drop\")) {\n        return 0;\n    }\n\n    old_size = actions->size;\n    for (;;) {\n        int retval;\n\n        s += strspn(s, delimiters);\n        if (!*s) {\n            return 0;\n        }\n\n        retval = parse_odp_action(s, port_names, actions);\n        if (retval < 0 || !strchr(delimiters, s[retval])) {\n            actions->size = old_size;\n            return -retval;\n        }\n        s += retval;\n    }\n\n    return 0;\n}\nstatic int\nparse_actions(const char *in)\n{\n    struct ofpbuf odp_actions;\n    struct ds out;\n    int error;\n\n    /* Convert string to OVS DP actions. */\n    ofpbuf_init(&odp_actions, 0);\n    error = odp_actions_from_string(in, NULL, &odp_actions);\n    if (error) {\n        printf(\"odp_actions_from_string: error\\n\");\n        goto next;\n    }\n\n    /* Convert odp_actions back to string. */\n    ds_init(&out);\n    format_odp_actions(&out, odp_actions.data, odp_actions.size, NULL);\n    puts(ds_cstr(&out));\n    ds_destroy(&out);\n\nnext:\n    ofpbuf_uninit(&odp_actions);\n    return 0;\n}\nint\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    /* Bail out if we cannot construct at least a 1 char string. */\n    const char *input = (const char *) data;\n    if (size < 2 || input[size - 1] != '\\0' || strchr(input, '\\n')) {\n        return 0;\n    }\n\n    /* Disable logging to avoid write to disk. */\n    static bool isInit = false;\n    if (!isInit) {\n        vlog_set_verbosity(\"off\");\n        isInit = true;\n    }\n\n    /* Parse keys and wc keys. */\n    parse_keys(false, input);\n    parse_keys(true, input);\n\n    /* Parse actions. */\n    parse_actions(input);\n\n    return 0;\n}\nint ExecuteFilesOnyByOne(int argc, char **argv) {\n  for (int i = 1; i < argc; i++) {\n    std::ifstream in(argv[i]);\n    in.seekg(0, in.end);\n    size_t length = in.tellg();\n    in.seekg (0, in.beg);\n    std::cout << \"Reading \" << length << \" bytes from \" << argv[i] << std::endl;\n    // Allocate exactly length bytes so that we reliably catch buffer overflows.\n    std::vector<char> bytes(length);\n    in.read(bytes.data(), bytes.size());\n    assert(in);\n    LLVMFuzzerTestOneInput(reinterpret_cast<const uint8_t *>(bytes.data()),\n                           bytes.size());\n    std::cout << \"Execution successful\" << std::endl;\n  }\n  return 0;\n}\nint main(int argc, char **argv) {\n  fprintf(stderr,\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for AFL-fuzz.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s < INPUT_FILE\\n\"\n      \"or\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before \"\n      \"re-spawning the process (default: 1000)\\n\"\n      \"======================================================\\n\",\n          argv[0], argv[0], argv[0]);\n  if (LLVMFuzzerInitialize)\n    LLVMFuzzerInitialize(&argc, &argv);\n  // Do any other expensive one-time initialization here.\n\n  maybe_duplicate_stderr();\n  maybe_initialize_extra_stats();\n\n  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n    __afl_manual_init();\n\n  int N = 1000;\n  if (argc == 2 && argv[1][0] == '-')\n      N = atoi(argv[1] + 1);\n  else if(argc == 2 && (N = atoi(argv[1])) > 0)\n      fprintf(stderr, \"WARNING: using the deprecated call style `%s %d`\\n\",\n              argv[0], N);\n  else if (argc > 1)\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  assert(N > 0);\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  uint8_t dummy_input[1] = {0};\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  time_t unit_time_secs;\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n    ssize_t n_read = read(0, AflInputBuf, kMaxAflInputSize);\n    if (n_read > 0) {\n      // Copy AflInputBuf into a separate buffer to let asan find buffer\n      // overflows. Don't use unique_ptr/etc to avoid extra dependencies.\n      uint8_t *copy = new uint8_t[n_read];\n      memcpy(copy, AflInputBuf, n_read);\n\n      struct timeval unit_start_time;\n      CHECK_ERROR(gettimeofday(&unit_start_time, NULL) == 0,\n                  \"Calling gettimeofday failed\");\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(copy, n_read);\n\n      struct timeval unit_stop_time;\n      CHECK_ERROR(gettimeofday(&unit_stop_time, NULL) == 0,\n                  \"Calling gettimeofday failed\");\n\n      // Update slowest_unit_time_secs if we see a new max.\n      unit_time_secs = unit_stop_time.tv_sec - unit_start_time.tv_sec;\n      if (slowest_unit_time_secs < unit_time_secs)\n        slowest_unit_time_secs = unit_time_secs;\n\n      delete[] copy;\n    }\n  }\n  fprintf(stderr, \"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n}",
    "target": 0,
    "idx": 2010796
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nauthentic_emu_update_tokeninfo(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_tokeninfo *tinfo)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tunsigned char buffer[8];\n\tint rv,len;\n\n\tsc_format_path(AUTHENTIC_CACHE_TIMESTAMP_PATH, &path);\n\trv = sc_select_file(p15card->card, &path, &file);\n\tif (!rv) {\n\t\trv = sc_get_challenge(p15card->card, buffer, sizeof(buffer));\n\t\tif (rv < 0) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get challenge error\");\n\t\t}\n\n\t\tlen = file->size > sizeof(buffer) ? sizeof(buffer) : file->size;\n\t\trv = sc_update_binary(p15card->card, 0, buffer, len, 0);\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Update binary error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\nstatic int\nsc_pkcs15init_update_tokeninfo(struct sc_pkcs15_card *p15card, struct sc_profile *profile)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char\t*buf = NULL;\n\tsize_t\t\tsize;\n\tint\t\trv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\t/* set lastUpdate field */\n\tif (p15card->tokeninfo->last_update.gtime != NULL)   {\n\t\tfree(p15card->tokeninfo->last_update.gtime);\n\t\tp15card->tokeninfo->last_update.gtime = NULL;\n\t}\n\trv = sc_pkcs15_get_generalized_time(ctx, &p15card->tokeninfo->last_update.gtime);\n\tLOG_TEST_RET(ctx, rv, \"Cannot allocate generalized time string\");\n\n\tif (profile->ops->emu_update_tokeninfo)\n\t\treturn profile->ops->emu_update_tokeninfo(profile, p15card, p15card->tokeninfo);\n\n\tif (!p15card->file_tokeninfo)   {\n\t\tsc_log(ctx, \"No TokenInfo to update\");\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\n\trv = sc_pkcs15_encode_tokeninfo(ctx, p15card->tokeninfo, &buf, &size);\n\tif (rv >= 0)\n\t\trv = sc_pkcs15init_update_file(profile, p15card, p15card->file_tokeninfo, buf, size);\n\tif (buf)\n\t\tfree(buf);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\nstatic int\nsc_pkcs15init_update_lastupdate(struct sc_pkcs15_card *p15card, struct sc_profile *profile)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tint\t\tr;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (p15card->tokeninfo->last_update.path.len)    {\n\t\tstatic const struct sc_asn1_entry c_asn1_last_update[2] = {\n\t\t        { \"generalizedTime\",    SC_ASN1_GENERALIZEDTIME, SC_ASN1_TAG_GENERALIZEDTIME,   SC_ASN1_OPTIONAL, NULL, NULL },\n\t\t\t{ NULL, 0, 0, 0, NULL, NULL }\n\t\t};\n\t\tstruct sc_asn1_entry asn1_last_update[2];\n\t\tsize_t lupdate_len;\n\t\tstruct sc_file *file = NULL;\n\t\tstruct sc_pkcs15_last_update *last_update = &p15card->tokeninfo->last_update;\n\t\tunsigned char *buf = NULL;\n\t\tsize_t buflen;\n\n\t\t/* update 'lastUpdate' file */\n\t\tif (last_update->gtime != NULL)\n\t\t\tfree(last_update->gtime);\n\t\tr = sc_pkcs15_get_generalized_time(ctx, &last_update->gtime);\n\t\tLOG_TEST_RET(ctx, r, \"Cannot allocate generalized time string\");\n\n\t\tsc_copy_asn1_entry(c_asn1_last_update, asn1_last_update);\n\t\tlupdate_len = strlen(last_update->gtime);\n\t\tsc_format_asn1_entry(asn1_last_update + 0, last_update->gtime, &lupdate_len, 1);\n\n\t\tr = sc_asn1_encode(ctx, asn1_last_update, &buf, &buflen);\n\t\tLOG_TEST_RET(ctx, r, \"select object path failed\");\n\n\t\tr = sc_select_file(p15card->card, &last_update->path, &file);\n\t\tif (r < 0)\n\t\t\tfree(buf);\n\t\tLOG_TEST_RET(ctx, r, \"select object path failed\");\n\n\t\tr = sc_pkcs15init_update_file(profile, p15card, file, buf, buflen);\n\t\tsc_file_free(file);\n\t\tif (buf)\n\t\t\tfree(buf);\n\t\tLOG_TEST_RET(ctx, r, \"Cannot update 'LastUpdate' file\");\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tr = sc_pkcs15init_update_tokeninfo(p15card, profile);\n\tLOG_FUNC_RETURN(ctx, r);\n}\nvoid\nsc_pkcs15init_unbind(struct sc_profile *profile)\n{\n\tint r;\n\tstruct sc_context *ctx = profile->card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Pksc15init Unbind: %i:%p:%i\", profile->dirty, profile->p15_data, profile->pkcs15.do_last_update);\n\tif (profile->dirty != 0 && profile->p15_data != NULL && profile->pkcs15.do_last_update) {\n\t\tr = sc_pkcs15init_update_lastupdate(profile->p15_data, profile);\n\t\tif (r < 0)\n\t\t\tsc_log(ctx, \"Failed to update TokenInfo: %s\", sc_strerror(r));\n\t}\n\tif (profile->dll)\n\t\tsc_dlclose(profile->dll);\n\tsc_profile_free(profile);\n}\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    sc_context_t          *ctx = NULL;\n    sc_card_t             *card = NULL;\n    struct sc_pkcs15_card *p15card = NULL;\n    struct sc_profile     *profile = NULL;\n    struct sc_reader      *reader = NULL;\n    const uint8_t         *reader_data = NULL;\n    size_t                 reader_data_size = 0;\n    uint8_t               *buf = NULL;\n    uint16_t               len = size < 256 ? size : 256;\n    unsigned char         *pin = NULL;\n    unsigned char         *so_pin = NULL;\n    unsigned char         *puk = NULL;\n    unsigned char         *so_puk = NULL;\n    struct sc_pkcs15_card *tmp_p15_data = NULL;\n\n#ifdef FUZZING_ENABLED\n    fclose(stdout);\n#endif\n\n    if (size == 0)\n        return 0;\n\n    if (!fuzz_get_reader_data(data, size, &reader_data, &reader_data_size)) {\n        return 0;\n    }\n\n    /* Establish context for fuzz app*/\n    sc_establish_context(&ctx, \"fuzz\");\n    if (!ctx)\n        return 0;\n\n    if (fuzz_connect_card(ctx, &card, &reader, reader_data, reader_data_size) != SC_SUCCESS)\n        goto end;\n\n    /* Load profile and bind with card */\n    fuzz_pkcs15init_bind(card, &profile, data, size - reader_data_size);\n\n    if(!profile)\n        goto end;\n\n    pin = malloc(11);\n    so_pin = malloc(9);\n    puk = malloc(9);\n    so_puk = malloc(9);\n    buf = malloc(len * sizeof(char));\n    if (!pin || !so_pin || !puk || !so_puk || !buf)\n        goto end_release;\n\n    memcpy(pin, \"123456\\0\", 7);\n    memcpy(so_pin, \"12345678\\0\", 9);\n    memcpy(puk, \"12345678\\0\", 9);\n    memcpy(so_puk, \"12345678\\0\", 9);\n    memcpy(buf, data, len);\n\n    /* test pkcs15-init functionality*/\n    do_init_app(profile, p15card, card, so_pin, so_puk);\n\n    if (!sc_pkcs15_bind(card, NULL, &p15card)) { /* First and only sc_pkcs15_bind calling, is omitted in next cases*/\n        do_store_pin(profile, p15card, card, pin, so_pin);\n    }\n\n    /* sc_pkcs15_bind failed, no point in testing next cases */\n    if (!p15card)\n        goto end_release;\n\n    do_store_data_object(profile, p15card, card, buf, len);\n    do_generate_key(profile, p15card, card);\n    do_generate_skey(profile, p15card, card);\n    do_store_secret_key(profile, p15card, card, buf);\n\n    sc_pkcs15init_finalize_card(card, profile);\n    sc_pkcs15init_sanity_check(p15card, profile);\n\n    do_erase(profile, card);\n\nend_release:\n    free(pin);\n    free(puk);\n    free(so_pin);\n    free(so_puk);\n    free(buf);\n\nend:\n\tif (profile) {\n\t\ttmp_p15_data = profile->p15_data;\n\t\tsc_pkcs15init_unbind(profile);\n\t\tif (tmp_p15_data != p15card)\n\t\t\tsc_pkcs15_unbind(tmp_p15_data);\n\t}\n\tif (p15card) {\n\t\tsc_pkcs15_unbind(p15card);\n\t}\n    if (card)\n\t    sc_disconnect_card(card);\n    sc_release_context(ctx);\n        \n    return 0;\n}",
    "target": 0,
    "idx": 2064898
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static UA_StatusCode\nremoveSession(UA_SessionManager *sm, session_list_entry *sentry) {\n    /* Detach the Session from the SecureChannel */\n    UA_Session_detachFromSecureChannel(&sentry->session);\n\n    /* Deactivate the session */\n    sentry->session.activated = false;\n\n    /* Add a delayed callback to remove the session when the currently\n     * scheduled jobs have completed */\n    UA_StatusCode retval = UA_Server_delayedCallback(sm->server, removeSessionCallback, sentry);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING_SESSION(sm->server->config.logger, &sentry->session,\n                       \"Could not remove session with error code %s\",\n                       UA_StatusCode_name(retval));\n        return retval; /* Try again next time */\n    }\n\n    /* Detach the session from the session manager and make the capacity\n     * available */\n    LIST_REMOVE(sentry, pointers);\n    UA_atomic_add(&sm->currentSessionCount, (UA_UInt32)-1);\n    return UA_STATUSCODE_GOOD;\n}\nvoid UA_Session_detachFromSecureChannel(UA_Session *session) {\n    if(!session->header.channel)\n        return;\n    session->header.channel = NULL;\n    LIST_REMOVE(&session->header, pointers);\n}\nvoid UA_Session_deleteMembersCleanup(UA_Session *session, UA_Server* server) {\n    UA_Session_detachFromSecureChannel(session);\n    UA_ApplicationDescription_deleteMembers(&session->clientDescription);\n    UA_NodeId_deleteMembers(&session->header.authenticationToken);\n    UA_NodeId_deleteMembers(&session->sessionId);\n    UA_String_deleteMembers(&session->sessionName);\n    UA_ByteString_deleteMembers(&session->serverNonce);\n    struct ContinuationPointEntry *cp, *temp;\n    LIST_FOREACH_SAFE(cp, &session->continuationPoints, pointers, temp) {\n        LIST_REMOVE(cp, pointers);\n        UA_ByteString_deleteMembers(&cp->identifier);\n        UA_BrowseDescription_deleteMembers(&cp->browseDescription);\n        UA_free(cp);\n    }\n#ifdef UA_ENABLE_SUBSCRIPTIONS\n    UA_Subscription *currents, *temps;\n    LIST_FOREACH_SAFE(currents, &session->serverSubscriptions, listEntry, temps) {\n        LIST_REMOVE(currents, listEntry);\n        UA_Subscription_deleteMembers(currents, server);\n        UA_free(currents);\n    }\n    UA_PublishResponseEntry *entry;\n    while((entry = UA_Session_getPublishReq(session))) {\n        UA_Session_removePublishReq(session,entry);\n        UA_PublishResponse_deleteMembers(&entry->response);\n        UA_free(entry);\n    }\n#endif\n}\nstatic void\nremoveSessionCallback(UA_Server *server, void *entry) {\n    session_list_entry *sentry = (session_list_entry*)entry;\n    UA_Session_deleteMembersCleanup(&sentry->session, server);\n    UA_free(sentry);\n}\nstatic void\nprocessDelayedCallbacks(UA_Server *server) {\n    UA_DelayedCallback *dc, *dc_tmp;\n    SLIST_FOREACH_SAFE(dc, &server->delayedCallbacks, next, dc_tmp) {\n        SLIST_REMOVE(&server->delayedCallbacks, dc, UA_DelayedCallback, next);\n        dc->callback(server, dc->data);\n        UA_free(dc);\n    }\n}\nUA_StatusCode\nUA_Server_run_shutdown(UA_Server *server) {\n    /* Stop the netowrk layer */\n    for(size_t i = 0; i < server->config.networkLayersSize; ++i) {\n        UA_ServerNetworkLayer *nl = &server->config.networkLayers[i];\n        nl->stop(nl, server);\n    }\n\n#ifndef UA_ENABLE_MULTITHREADING\n    /* Process remaining delayed callbacks */\n    processDelayedCallbacks(server);\n#else\n    /* Shut down the workers */\n    if(server->workers) {\n        UA_LOG_INFO(server->config.logger, UA_LOGCATEGORY_SERVER,\n                    \"Shutting down %u worker thread(s)\",\n                    server->config.nThreads);\n        for(size_t i = 0; i < server->config.nThreads; ++i)\n            server->workers[i].running = false;\n        pthread_cond_broadcast(&server->dispatchQueue_condition);\n        for(size_t i = 0; i < server->config.nThreads; ++i)\n            pthread_join(server->workers[i].thr, NULL);\n        UA_free(server->workers);\n        server->workers = NULL;\n    }\n\n    /* Execute the remaining callbacks in the dispatch queue.\n     * This also executes the delayed callbacks. */\n    emptyDispatchQueue(server);\n    \n#endif\n\n    /* Stop multicast discovery */\n#ifdef UA_ENABLE_DISCOVERY_MULTICAST\n    if(server->config.applicationDescription.applicationType ==\n       UA_APPLICATIONTYPE_DISCOVERYSERVER)\n        stopMulticastDiscoveryServer(server);\n#endif\n\n    return UA_STATUSCODE_GOOD;\n}\nextern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    UA_Connection c = createDummyConnection(65535, NULL);\n    UA_ServerConfig *config = UA_ServerConfig_new_default();\n    UA_Server *server = UA_Server_new(config);\n    if (server == NULL) {\n        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,\n                     \"Could not create server instance using UA_Server_new\");\n        return 1;\n    }\n\n    // we need to copy the message because it will be freed in the processing function\n    UA_ByteString msg = UA_ByteString();\n    UA_StatusCode retval = UA_ByteString_allocBuffer(&msg, size);\n    if(retval != UA_STATUSCODE_GOOD)\n        return (int)retval;\n    memcpy(msg.data, data, size);\n\n    UA_Server_processBinaryMessage(server, &c, &msg);\n    // if we got an invalid chunk, the message is not deleted, so delete it here\n    UA_ByteString_deleteMembers(&msg);\n    UA_Server_run_shutdown(server);\n    UA_Server_delete(server);\n    UA_ServerConfig_delete(config);\n    c.close(&c);\n    UA_Connection_deleteMembers(&c);\n    return 0;\n}\nint ExecuteFilesOnyByOne(int argc, char **argv) {\n  for (int i = 1; i < argc; i++) {\n    std::ifstream in(argv[i]);\n    in.seekg(0, in.end);\n    size_t length = in.tellg();\n    in.seekg (0, in.beg);\n    std::cout << \"Reading \" << length << \" bytes from \" << argv[i] << std::endl;\n    // Allocate exactly length bytes so that we reliably catch buffer overflows.\n    std::vector<char> bytes(length);\n    in.read(bytes.data(), bytes.size());\n    assert(in);\n    LLVMFuzzerTestOneInput(reinterpret_cast<const uint8_t *>(bytes.data()),\n                           bytes.size());\n    std::cout << \"Execution successfull\" << std::endl;\n  }\n  return 0;\n}\nint main(int argc, char **argv) {\n  fprintf(stderr,\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for AFL-fuzz.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s < INPUT_FILE\\n\"\n      \"or\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before \"\n      \"re-spawning the process (default: 1000)\\n\"\n      \"======================================================\\n\",\n          argv[0], argv[0], argv[0]);\n  if (LLVMFuzzerInitialize)\n    LLVMFuzzerInitialize(&argc, &argv);\n  // Do any other expensive one-time initialization here.\n\n  maybe_duplicate_stderr();\n  maybe_initialize_extra_stats();\n\n  __afl_manual_init();\n\n  int N = 1000;\n  if (argc == 2 && argv[1][0] == '-')\n      N = atoi(argv[1] + 1);\n  else if(argc == 2 && (N = atoi(argv[1])) > 0)\n      fprintf(stderr, \"WARNING: using the deprecated call style `%s %d`\\n\",\n              argv[0], N);\n  else if (argc > 1)\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  assert(N > 0);\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  uint8_t dummy_input[1] = {0};\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  time_t unit_time_secs;\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n    ssize_t n_read = read(0, AflInputBuf, kMaxAflInputSize);\n    if (n_read > 0) {\n      // Copy AflInputBuf into a separate buffer to let asan find buffer\n      // overflows. Don't use unique_ptr/etc to avoid extra dependencies.\n      uint8_t *copy = new uint8_t[n_read];\n      memcpy(copy, AflInputBuf, n_read);\n\n      struct timeval unit_start_time;\n      CHECK_ERROR(gettimeofday(&unit_start_time, NULL) == 0,\n                  \"Calling gettimeofday failed\");\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(copy, n_read);\n\n      struct timeval unit_stop_time;\n      CHECK_ERROR(gettimeofday(&unit_stop_time, NULL) == 0,\n                  \"Calling gettimeofday failed\");\n\n      // Update slowest_unit_time_secs if we see a new max.\n      unit_time_secs = unit_stop_time.tv_sec - unit_start_time.tv_sec;\n      if (slowest_unit_time_secs < unit_time_secs)\n        slowest_unit_time_secs = unit_time_secs;\n\n      delete[] copy;\n    }\n  }\n  fprintf(stderr, \"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n}",
    "target": 0,
    "idx": 2005577
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "GF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, u32 parent_type)\n{\n\tGF_Err e;\n\tGF_Box *a = NULL;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\t//always register boxes\n\t\tif (!parent->child_boxes) {\n\t\t\tparent->child_boxes = gf_list_new();\n\t\t\tif (!parent->child_boxes) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(parent->child_boxes, a);\n\t\tif (e) return e;\n\n\t\tif (parent->registry->add_rem_fn) {\n\t\t\te = parent->registry->add_rem_fn(parent, a, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\t\t//if the box is no longer present, consider it destroyed\n\t\t\t\tif (gf_list_find(parent->child_boxes, a) >=0) {\n\t\t\t\t\tgf_isom_box_del_parent(&parent->child_boxes, a);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\nvoid gf_isom_delete_movie(GF_ISOFile *mov)\n{\n\tif (!mov) return;\n\n\t//these are our two main files\n\tif (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->editFileMap) {\n\t\tgf_isom_datamap_del(mov->editFileMap);\n\t}\n\tif (mov->finalName) gf_free(mov->finalName);\n#endif\n\n\tgf_isom_box_array_del(mov->TopBoxes);\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_box_array_del(mov->moof_list);\n\tif (mov->mfra)\n\t\tgf_isom_box_del((GF_Box*)mov->mfra);\n\tif (mov->sidx_pts_store)\n\t\tgf_free(mov->sidx_pts_store);\n\tif (mov->sidx_pts_next_store)\n\t\tgf_free(mov->sidx_pts_next_store);\n\n\tif (mov->main_sidx)\n\t\tgf_isom_box_del((GF_Box*)mov->main_sidx);\n\n\tif (mov->block_buffer)\n\t\tgf_free(mov->block_buffer);\n#endif\n\tif (mov->last_producer_ref_time)\n\t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);\n\tif (mov->fileName) gf_free(mov->fileName);\n\tgf_free(mov);\n}\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    char filename[256];\n    sprintf(filename, \"/tmp/libfuzzer.%d\", getpid());\n\n    FILE *fp = fopen(filename, \"wb\");\n    if (!fp) {\n        return 0;\n    }\n    fwrite(data, size, 1, fp);\n    fclose(fp);\n\n    GF_ISOFile *movie = NULL;\n    movie = gf_isom_open_file(filename, GF_ISOM_OPEN_READ_DUMP, NULL);\n    if (movie != NULL) {\n        gf_isom_close(movie);\n    }\n    unlink(filename);\n    return 0;\n}\nstatic int ExecuteFilesOnyByOne(int argc, char **argv) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n  for (int i = 1; i < argc; i++) {\n\n    int fd = open(argv[i], O_RDONLY);\n    if (fd == -1) continue;\n    ssize_t length = read(fd, buf, MAX_FILE);\n    if (length > 0) {\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      LLVMFuzzerTestOneInput(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n  }\n\n  free(buf);\n  return 0;\n\n}\nint main(int argc, char **argv) {\n\n  printf(\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for afl++.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before re-spawning the process (default: \"\n      \"INT_MAX)\\n\"\n      \"======================================================\\n\",\n      argv[0], argv[0]);\n\n  if (getenv(\"AFL_GDB\")) {\n\n    char cmd[64];\n    snprintf(cmd, sizeof(cmd), \"cat /proc/%d/maps\", getpid());\n    system(cmd);\n    fprintf(stderr, \"DEBUG: aflpp_driver pid is %d\\n\", getpid());\n    sleep(1);\n\n  }\n\n  output_file = stderr;\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize) {\n\n    fprintf(stderr, \"Running LLVMFuzzerInitialize ...\\n\");\n    LLVMFuzzerInitialize(&argc, &argv);\n    fprintf(stderr, \"continue...\\n\");\n\n  }\n\n  // Do any other expensive one-time initialization here.\n\n  uint8_t dummy_input[64] = {0};\n  memcpy(dummy_input, (void *)AFL_PERSISTENT, sizeof(AFL_PERSISTENT));\n  memcpy(dummy_input + 32, (void *)AFL_DEFER_FORKSVR,\n         sizeof(AFL_DEFER_FORKSVR));\n  int N = INT_MAX;\n  if (argc == 2 && argv[1][0] == '-')\n    N = atoi(argv[1] + 1);\n  else if (argc == 2 && (N = atoi(argv[1])) > 0)\n    printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n  else if (argc > 1) {\n\n    __afl_sharedmem_fuzzing = 0;\n    __afl_manual_init();\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  }\n\n  assert(N > 0);\n\n  //  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n  __afl_manual_init();\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n\n#ifdef _DEBUG\n    fprintf(stderr, \"CLIENT crc: %016llx len: %u\\n\",\n            hash64(__afl_fuzz_ptr, *__afl_fuzz_len, 0xa5b35705),\n            *__afl_fuzz_len);\n    fprintf(stderr, \"RECV:\");\n    for (int i = 0; i < *__afl_fuzz_len; i++)\n      fprintf(stderr, \"%02x\", __afl_fuzz_ptr[i]);\n    fprintf(stderr, \"\\n\");\n#endif\n    if (*__afl_fuzz_len) {\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len);\n\n    }\n\n  }\n\n  printf(\"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n\n}",
    "target": 0,
    "idx": 2032356
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n\tgboolean prefixedChoice = (gboolean)*data;\n\tgchar *copy;\n\tgchar **lines;\n\tgchar **head;\n\n\tif (size < 1) return 0;\n\n\ttest_server();\n\n\tcopy = g_strndup((const gchar *)data+1, size-1);\n\tlines = g_strsplit(copy, \"\\r\\n\", -1);\n\thead = lines;\n\n\tfor (; *lines != NULL; lines++) {\n\t\tgchar *prefixedLine;\n\t\tint disconnected;\n\t\tif (prefixedChoice) {\n\t\t\tprefixedLine = g_strdup_printf(\":user %s\\n\", *lines);\n\t\t} else {\n\t\t\tprefixedLine = g_strdup_printf(\"%s\\n\", *lines);\n\t\t}\n\t\tserver_ref(server);\n\t\tsignal_emit(\"server incoming\", 2, server, prefixedLine);\n\t\tdisconnected = server->disconnected;\n\t\t/*\n\t\tif (disconnected) {\n\t\t        server_connect_unref(server->connrec);\n\t\t}\n\t\t*/\n\t\tserver_unref(server);\n\t\tif (disconnected) {\n\t\t\t/* reconnect */\n\t\t\ttest_server();\n\t\t}\n\t\tg_free(prefixedLine);\n\t}\n\n\tg_strfreev(head);\n\tg_free(copy);\n\tserver_disconnect(server);\n\treturn 0;\n}\nvoid *module_check_cast(void *object, int type_pos, const char *id)\n{\n\treturn object == NULL || module_find_id(id,\n\t\tG_STRUCT_MEMBER(int, object, type_pos)) == -1 ? NULL : object;\n}\nvoid server_connect_unref(SERVER_CONNECT_REC *conn)\n{\n\tg_return_if_fail(IS_SERVER_CONNECT(conn));\n\n\tif (--conn->refcount > 0)\n\t\treturn;\n\tif (conn->refcount < 0) {\n\t\tg_warning(\"Connection '%s' refcount = %d\",\n\t\t\t  conn->tag, conn->refcount);\n\t}\n\n        CHAT_PROTOCOL(conn)->destroy_server_connect(conn);\n\n\tif (conn->connect_handle != NULL)\n\t\tnet_disconnect(conn->connect_handle);\n\n\tg_free_not_null(conn->proxy);\n\tg_free_not_null(conn->proxy_string);\n\tg_free_not_null(conn->proxy_string_after);\n\tg_free_not_null(conn->proxy_password);\n\n\tg_free_not_null(conn->tag);\n\tg_free_not_null(conn->address);\n\tg_free_not_null(conn->chatnet);\n\n\tg_free_not_null(conn->own_ip4);\n\tg_free_not_null(conn->own_ip6);\n\n\tg_free_not_null(conn->password);\n\tg_free_not_null(conn->nick);\n\tg_free_not_null(conn->username);\n\tg_free_not_null(conn->realname);\n\n\tg_free_not_null(conn->tls_cert);\n\tg_free_not_null(conn->tls_pkey);\n\tg_free_not_null(conn->tls_pass);\n\tg_free_not_null(conn->tls_cafile);\n\tg_free_not_null(conn->tls_capath);\n\tg_free_not_null(conn->tls_ciphers);\n\tg_free_not_null(conn->tls_pinned_cert);\n\tg_free_not_null(conn->tls_pinned_pubkey);\n\n\tg_free_not_null(conn->channels);\n\tg_free_not_null(conn->away_reason);\n\n\tconn->type = 0;\n\tg_free(conn);\n}\nint server_unref(SERVER_REC *server)\n{\n\tint chans;\n\n\tg_return_val_if_fail(IS_SERVER(server), FALSE);\n\n\tif (--server->refcount > 0)\n\t\treturn TRUE;\n\n\tif (g_slist_find(servers, server) != NULL) {\n\t\tg_warning(\"Non-referenced server wasn't disconnected\");\n\t\tserver_disconnect(server);\n\t\treturn TRUE;\n\t}\n\n\t/* close all channels */\n\tchans = server_remove_channels(server);\n\n\t/* since module initialisation uses server connected, only let\n\t   them know that the object got destroyed if the server was\n\t   disconnected */\n\tif (server->disconnected) {\n\t\tsignal_emit(\"server destroyed\", 1, server);\n\t}\n\n\tif (server->handle != NULL) {\n\t\tif (!chans || server->connection_lost)\n\t\t\tnet_sendbuffer_destroy(server->handle, TRUE);\n\t\telse {\n\t\t\t/* we were on some channels, try to let the server\n\t\t\t   disconnect so that our quit message is guaranteed\n\t\t\t   to get displayed */\n\t\t\tnet_disconnect_later(net_sendbuffer_handle(server->handle));\n\t\t\tnet_sendbuffer_destroy(server->handle, FALSE);\n\t\t}\n\t\tserver->handle = NULL;\n\t}\n\n        MODULE_DATA_DEINIT(server);\n\tserver_connect_unref(server->connrec);\n\tif (server->rawlog != NULL) rawlog_destroy(server->rawlog);\n\tg_free(server->version);\n\tg_free(server->away_reason);\n\tg_free(server->nick);\n\tg_free(server->tag);\n\tg_hash_table_destroy(server->current_incoming_meta);\n\n\tserver->type = 0;\n\tg_free(server);\n        return FALSE;\n}\nint LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n\tgboolean prefixedChoice = (gboolean)*data;\n\tgchar *copy;\n\tgchar **lines;\n\tgchar **head;\n\n\tif (size < 1) return 0;\n\n\ttest_server();\n\n\tcopy = g_strndup((const gchar *)data+1, size-1);\n\tlines = g_strsplit(copy, \"\\r\\n\", -1);\n\thead = lines;\n\n\tfor (; *lines != NULL; lines++) {\n\t\tgchar *prefixedLine;\n\t\tint disconnected;\n\t\tif (prefixedChoice) {\n\t\t\tprefixedLine = g_strdup_printf(\":user %s\\n\", *lines);\n\t\t} else {\n\t\t\tprefixedLine = g_strdup_printf(\"%s\\n\", *lines);\n\t\t}\n\t\tserver_ref(server);\n\t\tsignal_emit(\"server incoming\", 2, server, prefixedLine);\n\t\tdisconnected = server->disconnected;\n\t\t/*\n\t\tif (disconnected) {\n\t\t        server_connect_unref(server->connrec);\n\t\t}\n\t\t*/\n\t\tserver_unref(server);\n\t\tif (disconnected) {\n\t\t\t/* reconnect */\n\t\t\ttest_server();\n\t\t}\n\t\tg_free(prefixedLine);\n\t}\n\n\tg_strfreev(head);\n\tg_free(copy);\n\tserver_disconnect(server);\n\treturn 0;\n}",
    "target": 0,
    "idx": 2033444
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "ZEND_API zend_result ZEND_FASTCALL div_function(zval *result, zval *op1, zval *op2) /* {{{ */\n{\n\tZVAL_DEREF(op1);\n\tZVAL_DEREF(op2);\n\n\tint retval = div_function_base(result, op1, op2);\n\tif (EXPECTED(retval == SUCCESS)) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (UNEXPECTED(retval == DIV_BY_ZERO)) {\n\t\tgoto div_by_zero;\n\t}\n\n\tZEND_TRY_BINARY_OBJECT_OPERATION(ZEND_DIV);\n\n\tzval result_copy, op1_copy, op2_copy;\n\tif (UNEXPECTED(zendi_try_convert_scalar_to_number(op1, &op1_copy) == FAILURE)\n\t\t\t|| UNEXPECTED(zendi_try_convert_scalar_to_number(op2, &op2_copy) == FAILURE)) {\n\t\tzend_binop_error(\"/\", op1, op2);\n\t\tif (result != op1) {\n\t\t\tZVAL_UNDEF(result);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tretval = div_function_base(&result_copy, &op1_copy, &op2_copy);\n\tif (retval == SUCCESS) {\n\t\tif (result == op1) {\n\t\t\tzval_ptr_dtor(result);\n\t\t}\n\t\tZVAL_COPY_VALUE(result, &result_copy);\n\t\treturn SUCCESS;\n\t}\n\ndiv_by_zero:\n\tZEND_ASSERT(retval == DIV_BY_ZERO && \"TYPES_NOT_HANDLED should not occur here\");\n\tif (result != op1) {\n\t\tZVAL_UNDEF(result);\n\t}\n\tzend_throw_error(zend_ce_division_by_zero_error, \"Division by zero\");\n\treturn FAILURE;\n}\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\tCG(compiled_filename) = NULL; /* ??? */\n\tfuzzer_request_shutdown();\n\n\treturn (retval == SUCCESS) ? SUCCESS : FAILURE;\n}\nint LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n\tif (Size > MAX_SIZE) {\n\t\t/* Large inputs have a large impact on fuzzer performance,\n\t\t * but are unlikely to be necessary to reach new codepaths. */\n\t\treturn 0;\n\t}\n\n\tsteps_left = MAX_STEPS;\n\tfuzzer_do_request_from_buffer(\"/fuzzer.php\", (const char *) Data, Size, /* execute */ 1);\n\n\treturn 0;\n}",
    "target": 0,
    "idx": 2035876
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\ngnutls_pkcs12_simple_parse(gnutls_pkcs12_t p12,\n\t\t\t   const char *password,\n\t\t\t   gnutls_x509_privkey_t * key,\n\t\t\t   gnutls_x509_crt_t ** chain,\n\t\t\t   unsigned int *chain_len,\n\t\t\t   gnutls_x509_crt_t ** extra_certs,\n\t\t\t   unsigned int *extra_certs_len,\n\t\t\t   gnutls_x509_crl_t * crl, unsigned int flags)\n{\n\tgnutls_pkcs12_bag_t bag = NULL;\n\tgnutls_x509_crt_t *_extra_certs = NULL;\n\tunsigned int _extra_certs_len = 0;\n\tgnutls_x509_crt_t *_chain = NULL;\n\tunsigned int _chain_len = 0;\n\tint idx = 0;\n\tint ret;\n\tsize_t cert_id_size = 0;\n\tsize_t key_id_size = 0;\n\tuint8_t cert_id[20];\n\tuint8_t key_id[20];\n\tint privkey_ok = 0;\n\tunsigned int i;\n\tint elements_in_bag;\n\n\t*key = NULL;\n\n\tif (crl)\n\t\t*crl = NULL;\n\n\t/* find the first private key */\n\tfor (;;) {\n\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tif (password == NULL) {\n\t\t\t\tret =\n\t\t\t\t    gnutls_assert_val\n\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_PKCS8_ENCRYPTED_KEY:\n\t\t\t\tif (password == NULL) {\n\t\t\t\t\tret =\n\t\t\t\t\t    gnutls_assert_val\n\t\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* fallthrough */\n\t\t\tcase GNUTLS_BAG_PKCS8_KEY:\n\t\t\t\tif (*key != NULL) {\t/* too simple to continue */\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_init(key);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_import_pkcs8\n\t\t\t\t    (*key, &data, GNUTLS_X509_FMT_DER,\n\t\t\t\t     password,\n\t\t\t\t     type ==\n\t\t\t\t     GNUTLS_BAG_PKCS8_KEY ?\n\t\t\t\t     GNUTLS_PKCS_PLAIN : 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tkey_id_size = sizeof(key_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_privkey_get_key_id(*key, 0,\n\t\t\t\t\t\t\t\t   key_id,\n\t\t\t\t\t\t\t\t   &key_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tprivkey_ok = 1;\t/* break */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\n\t\tif (privkey_ok != 0)\t/* private key was found */\n\t\t\tbreak;\n\t}\n\n\tif (privkey_ok == 0) {\t/* no private key */\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t}\n\n\t/* now find the corresponding certificate \n\t */\n\tidx = 0;\n\tbag = NULL;\n\tfor (;;) {\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\t\t\tgnutls_x509_crt_t this_cert;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_CERTIFICATE:\n\t\t\t\tret = gnutls_x509_crt_init(&this_cert);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_import(this_cert,\n\t\t\t\t\t\t\t   &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* check if the key id match */\n\t\t\t\tcert_id_size = sizeof(cert_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_get_key_id(this_cert,\n\t\t\t\t\t\t\t       0, cert_id,\n\t\t\t\t\t\t\t       &cert_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (memcmp(cert_id, key_id, cert_id_size) != 0) {\t/* they don't match - skip the certificate */\n\t\t\t\t\t_extra_certs =\n\t\t\t\t\t\tgnutls_realloc_fast\n\t\t\t\t\t\t(_extra_certs,\n\t\t\t\t\t\t sizeof(_extra_certs\n\t\t\t\t\t\t\t[0]) *\n\t\t\t\t\t\t ++_extra_certs_len);\n\t\t\t\t\tif (!_extra_certs) {\n\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\tret =\n\t\t\t\t\t\t\tGNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\t_extra_certs\n\t\t\t\t\t\t[_extra_certs_len -\n\t\t\t\t\t\t 1] = this_cert;\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tif (chain && _chain_len == 0) {\n\t\t\t\t\t\t_chain =\n\t\t\t\t\t\t    gnutls_malloc(sizeof\n\t\t\t\t\t\t\t\t  (_chain\n\t\t\t\t\t\t\t\t   [0]) *\n\t\t\t\t\t\t\t\t  (++_chain_len));\n\t\t\t\t\t\tif (!_chain) {\n\t\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\t\tret =\n\t\t\t\t\t\t\t    GNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_chain[_chain_len - 1] =\n\t\t\t\t\t\t    this_cert;\n\t\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgnutls_x509_crt_deinit\n\t\t\t\t\t\t    (this_cert);\n\t\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_CRL:\n\t\t\t\tif (crl == NULL || *crl != NULL) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_crl_init(crl);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crl_import(*crl, &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t\t\t*crl = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_ENCRYPTED:\n\t\t\t\t/* XXX Bother to recurse one level down?  Unlikely to\n\t\t\t\t   use the same password anyway. */\n\t\t\tcase GNUTLS_BAG_EMPTY:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\t}\n\n\tif (chain != NULL) {\n\t\tif (_chain_len != 1) {\n\t\t\tret = GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret =\n\t\t    make_chain(&_chain, &_chain_len, &_extra_certs,\n\t\t\t       &_extra_certs_len, flags);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = 0;\n\n      done:\n\tif (bag)\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\n\tif (ret < 0) {\n\t\tif (*key) {\n\t\t\tgnutls_x509_privkey_deinit(*key);\n\t\t\t*key = NULL;\n\t\t}\n\t\tif (crl != NULL && *crl != NULL) {\n\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t*crl = NULL;\n\t\t}\n\t\tif (_extra_certs_len && _extra_certs != NULL) {\n\t\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\t\tgnutls_free(_extra_certs);\n\t\t}\n\t\tif (_chain_len && _chain != NULL) {\n\t\t\tfor (i = 0; i < _chain_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_chain[i]);\n\t\t\tgnutls_free(_chain);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tif (extra_certs && _extra_certs_len > 0) {\n\t\t*extra_certs = _extra_certs;\n\t\t*extra_certs_len = _extra_certs_len;\n\t} else {\n\t\tif (extra_certs) {\n\t\t\t*extra_certs = NULL;\n\t\t\t*extra_certs_len = 0;\n\t\t}\n\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\tgnutls_free(_extra_certs);\n\t}\n\n\tif (chain != NULL) {\n\t\t*chain = _chain;\n\t\t*chain_len = _chain_len;\n\t}\n\n\treturn ret;\n}\nvoid gnutls_x509_crl_deinit(gnutls_x509_crl_t crl)\n{\n\tif (!crl)\n\t\treturn;\n\n\tif (crl->crl)\n\t\tasn1_delete_structure(&crl->crl);\n\tgnutls_free(crl->der.data);\n\n\tgnutls_free(crl);\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    gnutls_datum_t raw = {(unsigned char*)data, (unsigned int)size};\n    gnutls_pkcs12_t p12;\n    gnutls_x509_privkey_t key;\n    gnutls_x509_crt_t *chain;\n    gnutls_x509_crt_t *extras;\n    gnutls_x509_crl_t crl;\n    unsigned int chain_len = 0, extras_len = 0;\n    unsigned int i;\n    int ret;\n\n    raw.data = (unsigned char *)data;\n    raw.size = size;\n\n    ret = gnutls_pkcs12_init(&p12);\n    assert(ret >= 0);\n\n    ret = gnutls_pkcs12_import(p12, &raw, GNUTLS_X509_FMT_DER, 0);\n    if (ret < 0) {\n        goto cleanup;\n    }\n\n    /* catch crashes */\n    gnutls_pkcs12_verify_mac(p12, \"1234\");\n\n    ret = gnutls_pkcs12_simple_parse(p12, \"1234\", &key, &chain, &chain_len, &extras, &extras_len, &crl, 0);\n    if (ret >= 0) {\n    \tgnutls_x509_privkey_deinit(key);\n    \tif (crl)\n\t    \tgnutls_x509_crl_deinit(crl);\n\tif (extras_len > 0) {\n\t\tfor (i=0;i<extras_len;i++)\n\t\t\tgnutls_x509_crt_deinit(extras[i]);\n\t\tgnutls_free(extras);\n\t}\n\tif (chain_len > 0) {\n\t\tfor (i=0;i<chain_len;i++)\n\t\t\tgnutls_x509_crt_deinit(chain[i]);\n\t\tgnutls_free(chain);\n\t}\n    }\n\n cleanup:\n    gnutls_pkcs12_deinit(p12);\n    return 0;\n}\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  assert(InFuzzingThread());\n  if (SMR.IsClient())\n    SMR.WriteByteArray(Data, Size);\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  AllocTracer.Start(Options.TraceMalloc);\n  UnitStartTime = system_clock::now();\n  TPC.ResetMaps();\n  RunningCB = true;\n  int Res = CB(DataCopy, Size);\n  RunningCB = false;\n  UnitStopTime = system_clock::now();\n  (void)Res;\n  assert(Res == 0);\n  HasMoreMallocsThanFrees = AllocTracer.Stop();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\nsize_t Fuzzer::RunOne(const uint8_t *Data, size_t Size) {\n  if (!Size) return 0;\n  TotalNumberOfRuns++;\n\n  ExecuteCallback(Data, Size);\n\n  size_t NumUpdatesBefore = Corpus.NumFeatureUpdates();\n  TPC.CollectFeatures([&](size_t Feature) {\n    Corpus.AddFeature(Feature, Size, Options.Shrink);\n  });\n  size_t NumUpdatesAfter = Corpus.NumFeatureUpdates();\n\n  auto TimeOfUnit =\n      duration_cast<seconds>(UnitStopTime - UnitStartTime).count();\n  if (!(TotalNumberOfRuns & (TotalNumberOfRuns - 1)) &&\n      secondsSinceProcessStartUp() >= 2)\n    PrintStats(\"pulse \");\n  if (TimeOfUnit > TimeOfLongestUnitInSeconds * 1.1 &&\n      TimeOfUnit >= Options.ReportSlowUnits) {\n    TimeOfLongestUnitInSeconds = TimeOfUnit;\n    Printf(\"Slowest unit: %zd s:\\n\", TimeOfLongestUnitInSeconds);\n    WriteUnitToFileWithPrefix({Data, Data + Size}, \"slow-unit-\");\n  }\n  return NumUpdatesAfter - NumUpdatesBefore;\n}\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->RunOne(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  const std::vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  const size_t kMaxSaneLen = 1 << 20;\n  const size_t kMinDefaultLen = 64;\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.ExperimentalLenControl = Flags.experimental_len_control;\n  if (Flags.experimental_len_control && Flags.max_len == 64)\n    Options.MaxLen = 1 << 20;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseIndirCalls = Flags.use_indir_calls;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  std::vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  Options.DumpCoverage = Flags.dump_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  SetSignalHandler(Options);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n  if (auto Name = Flags.run_equivalence_server) {\n    SMR.Destroy(Name);\n    if (!SMR.Create(Name)) {\n       Printf(\"ERROR: can't create shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE SERVER UP\\n\");\n    while (true) {\n      SMR.WaitClient();\n      size_t Size = SMR.ReadByteArraySize();\n      SMR.WriteByteArray(nullptr, 0);\n      F->RunOne(SMR.GetByteArray(), Size);\n      SMR.PostServer();\n    }\n    return 0;\n  }\n\n  if (auto Name = Flags.use_equivalence_server) {\n    if (!SMR.Open(Name)) {\n      Printf(\"ERROR: can't open shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE CLIENT UP\\n\");\n  }\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.merge) {\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kMaxSaneLen);\n    if (Flags.merge_control_file)\n      F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    else\n      F->CrashResistantMerge(Args, *Inputs,\n                             Flags.load_coverage_summary,\n                             Flags.save_coverage_summary);\n    exit(0);\n  }\n\n  size_t TemporaryMaxLen = Options.MaxLen ? Options.MaxLen : kMaxSaneLen;\n\n  UnitVector InitialCorpus;\n  for (auto &Inp : *Inputs) {\n    Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n    ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                           TemporaryMaxLen, /*ExitOnError=*/false);\n  }\n\n  if (Flags.analyze_dict) {\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis suceeded\\n\");\n    exit(0);\n  }\n\n  if (Options.MaxLen == 0) {\n    size_t MaxLen = 0;\n    for (auto &U : InitialCorpus)\n      MaxLen = std::max(U.size(), MaxLen);\n    F->SetMaxInputLen(std::min(std::max(kMinDefaultLen, MaxLen), kMaxSaneLen));\n  }\n\n  if (InitialCorpus.empty()) {\n    InitialCorpus.push_back(Unit({'\\n'}));  // Valid ASCII input.\n    if (Options.Verbosity)\n      Printf(\"INFO: A corpus is not provided, starting from an empty corpus\\n\");\n  }\n  F->ShuffleAndMinimize(&InitialCorpus);\n  InitialCorpus.clear();  // Don't need this memory any more.\n  F->Loop();\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\nint main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}",
    "target": 0,
    "idx": 2001304
  }
]