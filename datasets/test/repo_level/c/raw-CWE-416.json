[
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void cil_reset_class(struct cil_class *class)\n{\n\tif (class->common != NULL) {\n\t\tstruct cil_class *common = class->common;\n\t\tcil_symtab_map(&class->perms, __class_reset_perm_values, &common->num_perms);\n\t\t/* during a re-resolve, we need to reset the common, so a classcommon\n\t\t * statement isn't seen as a duplicate */\n\t\tclass->num_perms -= common->num_perms;\n\t\tclass->common = NULL; /* Must make this NULL or there will be an error when re-resolving */\n\t}\n\tclass->ordered = CIL_FALSE;\n}\n",
    "target": 1,
    "idx": 1028467,
    "stack_trace": [
      {
        "function_name": "__class_reset_perm_values",
        "function_body": "static int __class_reset_perm_values(__attribute__((unused)) hashtab_key_t k, hashtab_datum_t d, void *args)\n{\n\tstruct cil_perm *perm = (struct cil_perm *)d;\n\n\tperm->value -= *((int *)args);\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_reset_ast.c",
        "crashing_line": "\tperm->value -= *((int *)args);",
        "crashing_line_number": 17
      },
      {
        "function_name": "hashtab_map",
        "function_body": "int hashtab_map(hashtab_t h,\n\t\tint (*apply) (hashtab_key_t k,\n\t\t\t      hashtab_datum_t d, void *args), void *args)\n{\n\tunsigned int i, ret;\n\thashtab_ptr_t cur;\n\n\tif (!h)\n\t\treturn SEPOL_OK;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur != NULL) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/hashtab.c",
        "crashing_line": "\t\t\tret = apply(cur->key, cur->datum, args);",
        "crashing_line_number": 234
      },
      {
        "function_name": "cil_symtab_map",
        "function_body": "int cil_symtab_map(symtab_t *symtab,\n\t\t\t\t   int (*apply) (hashtab_key_t k, hashtab_datum_t d, void *args),\n\t\t\t\t   void *args)\n{\n\treturn hashtab_map(symtab->table, apply, args);\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_symtab.c",
        "crashing_line": "\treturn hashtab_map(symtab->table, apply, args);",
        "crashing_line_number": 133
      },
      {
        "function_name": "cil_reset_class",
        "function_body": "static void cil_reset_class(struct cil_class *class)\n{\n\tif (class->common != NULL) {\n\t\t/* Must assume that the common has been destroyed */\n\t\tint num_common_perms = class->num_perms - class->perms.nprim;\n\t\tcil_symtab_map(&class->perms, __class_reset_perm_values, &num_common_perms);\n\t\t/* during a re-resolve, we need to reset the common, so a classcommon\n\t\t * statement isn't seen as a duplicate */\n\t\tclass->num_perms = class->perms.nprim;\n\t\tclass->common = NULL; /* Must make this NULL or there will be an error when re-resolving */\n\t}\n\tclass->ordered = CIL_FALSE;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_reset_ast.c",
        "crashing_line": "\t\tint num_common_perms = class->num_perms - class->perms.nprim;",
        "crashing_line_number": 26
      },
      {
        "function_name": "__cil_reset_node",
        "function_body": "int __cil_reset_node(struct cil_tree_node *node,  __attribute__((unused)) uint32_t *finished, __attribute__((unused)) void *extra_args)\n{\n\tswitch (node->flavor) {\n\tcase CIL_CLASS:\n\t\tcil_reset_class(node->data);\n\t\tbreak;\n\tcase CIL_PERM:\n\tcase CIL_MAP_PERM:\n\t\tcil_reset_perm(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSION:\n\t\tcil_reset_classpermission(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSIONSET:\n\t\tcil_reset_classpermissionset(node->data);\n\t\tbreak;\n\tcase CIL_CLASSMAPPING:\n\t\tcil_reset_classmapping(node->data);\n\t\tbreak;\n\tcase CIL_TYPEALIAS:\n\tcase CIL_SENSALIAS:\n\tcase CIL_CATALIAS:\n\t\tcil_reset_alias(node->data);\n\t\tbreak;\n\tcase CIL_USERRANGE:\n\t\tcil_reset_userrange(node->data);\n\t\tbreak;\n\tcase CIL_USERLEVEL:\n\t\tcil_reset_userlevel(node->data);\n\t\tbreak;\n\tcase CIL_USER:\n\t\tcil_reset_user(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTE:\n\t\tcil_reset_userattr(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTESET:\n\t\tcil_reset_userattributeset(node->data);\n\t\tbreak;\n\tcase CIL_SELINUXUSERDEFAULT:\n\tcase CIL_SELINUXUSER:\n\t\tcil_reset_selinuxuser(node->data);\n\t\tbreak;\n\tcase CIL_ROLE:\n\t\tcil_reset_role(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTE:\n\t\tcil_reset_roleattr(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTESET:\n\t\tcil_reset_roleattributeset(node->data);\n\t\tbreak;\n\tcase CIL_TYPE:\n\t\tcil_reset_type(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTE:\n\t\tcil_reset_typeattr(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTESET:\n\t\tcil_reset_typeattributeset(node->data);\n\t\tbreak;\n\tcase CIL_RANGETRANSITION:\n\t\tcil_reset_rangetransition(node->data);\n\t\tbreak;\n\tcase CIL_AVRULE:\n\t\tcil_reset_avrule(node->data);\n\t\tbreak;\n\tcase CIL_SENS:\n\t\tcil_reset_sens(node->data);\n\t\tbreak;\n\tcase CIL_CAT:\n\t\tcil_reset_cat(node->data);\n\t\tbreak;\n\tcase CIL_SENSCAT:\n\t\tcil_reset_senscat(node->data);\n\t\tbreak;\n\tcase CIL_CATSET:\n\t\tcil_reset_catset(node->data);\n\t\tbreak;\n\tcase CIL_LEVEL:\n\t\tcil_reset_level(node->data);\n\t\tbreak;\n\tcase CIL_LEVELRANGE:\n\t\tcil_reset_levelrange(node->data);\n\t\tbreak;\n\tcase CIL_CONTEXT:\n\t\tcil_reset_context(node->data);\n\t\tbreak;\n\tcase CIL_SIDCONTEXT:\n\t\tcil_reset_sidcontext(node->data);\n\t\tbreak;\n\tcase CIL_FILECON:\n\t\tcil_reset_filecon(node->data);\n\t\tbreak;\n\tcase CIL_IBPKEYCON:\n\t\tcil_reset_ibpkeycon(node->data);\n\t\tbreak;\n\tcase CIL_IBENDPORTCON:\n\t\tcil_reset_ibendportcon(node->data);\n\t\tbreak;\n\tcase CIL_PORTCON:\n\t\tcil_reset_portcon(node->data);\n\t\tbreak;\n\tcase CIL_NODECON:\n\t\tcil_reset_nodecon(node->data);\n\t\tbreak;\n\tcase CIL_GENFSCON:\n\t\tcil_reset_genfscon(node->data);\n\t\tbreak;\n\tcase CIL_NETIFCON:\n\t\tcil_reset_netifcon(node->data);\n\t\tbreak;\n\tcase CIL_PIRQCON:\n\t\tcil_reset_pirqcon(node->data);\n\t\tbreak;\n\tcase CIL_IOMEMCON:\n\t\tcil_reset_iomemcon(node->data);\n\t\tbreak;\n\tcase CIL_IOPORTCON:\n\t\tcil_reset_ioportcon(node->data);\n\t\tbreak;\n\tcase CIL_PCIDEVICECON:\n\t\tcil_reset_pcidevicecon(node->data);\n\t\tbreak;\n\tcase CIL_DEVICETREECON:\n\t\tcil_reset_devicetreecon(node->data);\n\t\tbreak;\n\tcase CIL_FSUSE:\n\t\tcil_reset_fsuse(node->data);\n\t\tbreak;\n\tcase CIL_SID:\n\t\tcil_reset_sid(node->data);\n\t\tbreak;\n\tcase CIL_CONSTRAIN:\n\tcase CIL_MLSCONSTRAIN:\n\t\tcil_reset_constrain(node->data);\n\t\tbreak;\n\tcase CIL_VALIDATETRANS:\n\tcase CIL_MLSVALIDATETRANS:\n\t\tcil_reset_validatetrans(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTUSER:\n\tcase CIL_DEFAULTROLE:\n\tcase CIL_DEFAULTTYPE:\n\t\tcil_reset_default(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTRANGE:\n\t\tcil_reset_defaultrange(node->data);\n\t\tbreak;\n\tcase CIL_BOOLEANIF:\n\t\tcil_reset_booleanif(node->data);\n\t\tbreak;\n\tcase CIL_TUNABLEIF:\n\tcase CIL_CALL:\n\t\tbreak; /* Not effected by optional block disabling */\n\tcase CIL_MACRO:\n\tcase CIL_SIDORDER:\n\tcase CIL_CLASSORDER:\n\tcase CIL_CATORDER:\n\tcase CIL_SENSITIVITYORDER:\n\tcase CIL_EXPANDTYPEATTRIBUTE:\n\t\tbreak; /* Nothing to reset */\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_reset_ast.c",
        "crashing_line": "\tcase CIL_CLASS:",
        "crashing_line_number": 416
      },
      {
        "function_name": "cil_tree_walk_core",
        "function_body": "int cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\t\t\trc = (*process_node)(node, &finished, extra_args);",
        "crashing_line_number": 272
      },
      {
        "function_name": "cil_tree_walk",
        "function_body": "int cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 316
      },
      {
        "function_name": "cil_tree_walk_core",
        "function_body": "int cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 284
      },
      {
        "function_name": "cil_tree_walk",
        "function_body": "int cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 316
      },
      {
        "function_name": "cil_reset_ast",
        "function_body": "int cil_reset_ast(struct cil_tree_node *current)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_tree_walk(current, __cil_reset_node, NULL, NULL, NULL);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to reset AST\\n\");\n\t\treturn SEPOL_ERR;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_reset_ast.c",
        "crashing_line": "",
        "crashing_line_number": 585
      },
      {
        "function_name": "cil_resolve_ast",
        "function_body": "int __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_tree_children_destroy(parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_resolve_ast.c",
        "crashing_line": "",
        "crashing_line_number": 4019
      },
      {
        "function_name": "cil_compile",
        "function_body": "int cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil.c",
        "crashing_line": "\trc = cil_resolve_ast(db, db->ast->root);",
        "crashing_line_number": 550
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "  p=GetStringInfoDatum(comment);\n  (void) SetImageProperty(image,\"comment\",(const char *) p,exception);\n  comment=DestroyStringInfo(comment);\n  return(TRUE);\n}\n\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *icc_profile,\n    *profile;\n\n  /*\n    Read color profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,ICC_PROFILE) != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < (ssize_t) (length-12); i++)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  if (i != (ssize_t) length)\n    {\n      profile=DestroyStringInfo(profile);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=NULL;\n  icc_profile=(StringInfo *) GetImageProfile(image,\"icc\");\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(icc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"icc\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: ICC, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[MagickPathExtent];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *iptc_profile,\n    *profile;\n\n  /*\n    Determine length of binary data stored here.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  /*\n    Validate that this was written as a Photoshop resource format slug.\n  */\n  for (i=0; i < 10; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  magick[10]='\\0';\n  length-=10;\n  if (length <= 10)\n    return(TRUE);\n  if (LocaleCompare(magick,\"Photoshop \") != 0)\n    {\n      /*\n        Not a IPTC profile, return.\n      */\n      for (i=0; i < (ssize_t) length; i++)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  /*\n    Remove the version number.\n  */\n  for (i=0; i < 4; i++)\n    if (GetCharacter(jpeg_info) == EOF)\n      break;\n  if (length <= 11)\n    return(TRUE);\n  length-=4;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  error_manager->profile=NULL;\n  if (i != (ssize_t) length)\n    {\n      profile=DestroyStringInfo(profile);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  /* The IPTC profile is actually an 8bim */\n  iptc_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  if (iptc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(iptc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n",
    "target": 1,
    "idx": 1015827,
    "stack_trace": [
      {
        "function_name": "DestroyStringInfo",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/string.c",
        "crashing_line": "",
        "crashing_line_number": 853
      },
      {
        "function_name": "ReadJPEGImage",
        "function_body": "",
        "file_path": "/src/imagemagick/coders/jpeg.c",
        "crashing_line": "",
        "crashing_line_number": 1197
      },
      {
        "function_name": "ReadImage",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/constitute.c",
        "crashing_line": "",
        "crashing_line_number": 547
      },
      {
        "function_name": "BlobToImage",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/blob.c",
        "crashing_line": "",
        "crashing_line_number": 475
      },
      {
        "function_name": "ReadJNXImage",
        "function_body": "",
        "file_path": "/src/imagemagick/coders/jnx.c",
        "crashing_line": "",
        "crashing_line_number": 306
      },
      {
        "function_name": "ReadImage",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/constitute.c",
        "crashing_line": "",
        "crashing_line_number": 547
      },
      {
        "function_name": "BlobToImage",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/blob.c",
        "crashing_line": "",
        "crashing_line_number": 475
      },
      {
        "function_name": "read",
        "function_body": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}",
        "file_path": "/src/imagemagick/Magick++/lib/Image.cpp",
        "crashing_line": "",
        "crashing_line_number": 4028
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "void pj_set_ctx( projPJ pj, projCtx ctx )\n\n{\n    pj->ctx = ctx;\n}\nprojCtx pj_ctx_alloc()\n\n{\n    projCtx ctx = (projCtx_t *) malloc(sizeof(projCtx_t));\n    memcpy( ctx, pj_get_default_ctx(), sizeof(projCtx_t) );\n    ctx->last_errno = 0;\n\n    return ctx;\n}\nvoid pj_ctx_set_errno( projCtx ctx, int new_errno )\n\n{\n    ctx->last_errno = new_errno;\n    if (ctx!=pj_get_default_ctx())\n        return;\n    if( new_errno == 0 )\n        return;\n    pj_errno = new_errno;\n    errno = new_errno;\n}\nvoid pj_ctx_set_fileapi( projCtx ctx, projFileAPI *fileapi )\n\n{\n    ctx->fileapi = fileapi;\n}\n",
    "target": 1,
    "idx": 1003569,
    "stack_trace": [
      {
        "function_name": "pj_projection_specific_setup_geos",
        "function_body": "",
        "file_path": "/src/proj.4/src/PJ_geos.c",
        "crashing_line": "",
        "crashing_line_number": 202
      },
      {
        "function_name": "pj_init_ctx",
        "function_body": "",
        "file_path": "/src/proj.4/src/pj_init.c",
        "crashing_line": "",
        "crashing_line_number": 715
      },
      {
        "function_name": "pj_init_plus_ctx",
        "function_body": "",
        "file_path": "/src/proj.4/src/pj_init.c",
        "crashing_line": "",
        "crashing_line_number": 409
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static zend_never_inline ZEND_COLD bool zend_wrong_assign_to_variable_reference(zval *variable_ptr, zval *value_ptr OPLINE_DC EXECUTE_DATA_DC)\n{\n\tzend_error(E_NOTICE, \"Only variables should be assigned by reference\");\n\tif (UNEXPECTED(EG(exception) != NULL)) {\n\t\treturn 0;\n\t}\n\n\t/* Use IS_TMP_VAR instead of IS_VAR to avoid ISREF check */\n\tZ_TRY_ADDREF_P(value_ptr);\n\tvalue_ptr = zend_assign_to_variable(variable_ptr, value_ptr, IS_TMP_VAR, EX_USES_STRICT_TYPES());\n\n\treturn 1;\n}\nstatic zend_always_inline void zend_assign_to_property_reference(zval *container, uint32_t container_op_type, zval *prop_ptr, uint32_t prop_op_type, zval *value_ptr OPLINE_DC EXECUTE_DATA_DC)\n{\n\tzval variable, *variable_ptr = &variable;\n\tvoid **cache_addr = (prop_op_type == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_RETURNS_FUNCTION) : NULL;\n\n\tzend_fetch_property_address(variable_ptr, container, container_op_type, prop_ptr, prop_op_type,\n\t\tcache_addr, BP_VAR_W, 0, 0 OPLINE_CC EXECUTE_DATA_CC);\n\n\tif (EXPECTED(Z_TYPE_P(variable_ptr) == IS_INDIRECT)) {\n\t\tvariable_ptr = Z_INDIRECT_P(variable_ptr);\n\t\tif (/*OP_DATA_TYPE == IS_VAR &&*/\n\t\t\t\t   (opline->extended_value & ZEND_RETURNS_FUNCTION) &&\n\t\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\t\tif (UNEXPECTED(!zend_wrong_assign_to_variable_reference(\n\t\t\t\t\tvariable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {\n\t\t\t\tvariable_ptr = &EG(uninitialized_zval);\n\t\t\t}\n\t\t} else {\n\t\t\tzend_property_info *prop_info = NULL;\n\n\t\t\tif (prop_op_type == IS_CONST) {\n\t\t\t\tprop_info = (zend_property_info *) CACHED_PTR_EX(cache_addr + 2);\n\t\t\t} else {\n\t\t\t\tZVAL_DEREF(container);\n\t\t\t\tprop_info = zend_object_fetch_property_type_info(Z_OBJ_P(container), variable_ptr);\n\t\t\t}\n\n\t\t\tif (UNEXPECTED(prop_info)) {\n\t\t\t\tvariable_ptr = zend_assign_to_typed_property_reference(prop_info, variable_ptr, value_ptr EXECUTE_DATA_CC);\n\t\t\t} else {\n\t\t\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t\t\t}\n\t\t}\n\t} else if (Z_ISERROR_P(variable_ptr)) {\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else {\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to overloaded object\");\n\t\tzval_ptr_dtor(&variable);\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n}\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *variable_ptr;\n\tzval *value_ptr;\n\n\tSAVE_OPLINE();\n\tvalue_ptr = _get_zval_ptr_ptr_var(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);\n\n\tif (IS_VAR == IS_VAR &&\n\t           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {\n\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to an array dimension of an object\");\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else if (IS_VAR == IS_VAR &&\n\t           opline->extended_value == ZEND_RETURNS_FUNCTION &&\n\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\tif (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {\n\t\t\tvariable_ptr = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op2.var));\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op1.var));\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *variable_ptr;\n\tzval *value_ptr;\n\n\tSAVE_OPLINE();\n\tvalue_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);\n\n\tif (IS_VAR == IS_VAR &&\n\t           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {\n\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to an array dimension of an object\");\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else if (IS_CV == IS_VAR &&\n\t           opline->extended_value == ZEND_RETURNS_FUNCTION &&\n\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\tif (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {\n\t\t\tvariable_ptr = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op1.var));\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *variable_ptr;\n\tzval *value_ptr;\n\n\tSAVE_OPLINE();\n\tvalue_ptr = _get_zval_ptr_ptr_var(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = EX_VAR(opline->op1.var);\n\n\tif (IS_CV == IS_VAR &&\n\t           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {\n\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to an array dimension of an object\");\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else if (IS_VAR == IS_VAR &&\n\t           opline->extended_value == ZEND_RETURNS_FUNCTION &&\n\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\tif (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {\n\t\t\tvariable_ptr = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op2.var));\n\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *variable_ptr;\n\tzval *value_ptr;\n\n\tSAVE_OPLINE();\n\tvalue_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = EX_VAR(opline->op1.var);\n\n\tif (IS_CV == IS_VAR &&\n\t           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {\n\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to an array dimension of an object\");\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else if (IS_CV == IS_VAR &&\n\t           opline->extended_value == ZEND_RETURNS_FUNCTION &&\n\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\tif (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {\n\t\t\tvariable_ptr = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n\n\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\n",
    "target": 1,
    "idx": 1029899,
    "stack_trace": [
      {
        "function_name": "ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER",
        "function_body": "static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *variable_ptr;\n\tzval *value_ptr;\n\n\tSAVE_OPLINE();\n\tvalue_ptr = _get_zval_ptr_ptr_var(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);\n\n\tif (IS_VAR == IS_VAR &&\n\t           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {\n\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to an array dimension of an object\");\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else if (IS_VAR == IS_VAR &&\n\t           opline->extended_value == ZEND_RETURNS_FUNCTION &&\n\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\tvariable_ptr = zend_wrong_assign_to_variable_reference(\n\t\t\tvariable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC);\n\t} else {\n\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op2.var));\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op1.var));\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}",
        "file_path": "/src/php-src/Zend/zend_vm_execute.h",
        "crashing_line": "\t}",
        "crashing_line_number": 26953
      },
      {
        "function_name": "fuzzer_execute_ex",
        "function_body": "static void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-execute.c",
        "crashing_line": "\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {",
        "crashing_line_number": 40
      },
      {
        "function_name": "zend_execute",
        "function_body": "ZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)\n{\n\tzend_execute_data *execute_data;\n\tvoid *object_or_called_scope;\n\tuint32_t call_info;\n\n\tif (EG(exception) != NULL) {\n\t\treturn;\n\t}\n\n\tobject_or_called_scope = zend_get_this_object(EG(current_execute_data));\n\tif (EXPECTED(!object_or_called_scope)) {\n\t\tobject_or_called_scope = zend_get_called_scope(EG(current_execute_data));\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE;\n\t} else {\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE | ZEND_CALL_HAS_THIS;\n\t}\n\texecute_data = zend_vm_stack_push_call_frame(call_info,\n\t\t(zend_function*)op_array, 0, object_or_called_scope);\n\tif (EG(current_execute_data)) {\n\t\texecute_data->symbol_table = zend_rebuild_symbol_table();\n\t} else {\n\t\texecute_data->symbol_table = &EG(symbol_table);\n\t}\n\tEX(prev_execute_data) = EG(current_execute_data);\n\ti_init_code_execute_data(execute_data, op_array, return_value);\n\tZEND_OBSERVER_FCALL_BEGIN(execute_data);\n\tzend_execute_ex(execute_data);\n\t/* Observer end handlers are called from ZEND_RETURN */\n\tzend_vm_stack_free_call_frame(execute_data);\n}",
        "file_path": "/src/php-src/Zend/zend_vm_execute.h",
        "crashing_line": "",
        "crashing_line_number": 58875
      },
      {
        "function_name": "fuzzer_do_request_from_buffer",
        "function_body": "int fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-sapi.c",
        "crashing_line": "\t\t\t\tzend_execute(op_array, NULL);",
        "crashing_line_number": 259
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size)\n{\n    int (* decode_entries[])(struct sc_pkcs15_card *, struct sc_pkcs15_object *,\n            const u8 **nbuf, size_t *nbufsize) = {\n        sc_pkcs15_decode_prkdf_entry, sc_pkcs15_decode_pukdf_entry,\n        sc_pkcs15_decode_skdf_entry, sc_pkcs15_decode_cdf_entry,\n        sc_pkcs15_decode_dodf_entry, sc_pkcs15_decode_aodf_entry\n    };\n    size_t i;\n\n    if (!ctx)\n        sc_establish_context(&ctx, \"fuzz\");\n    if (!p15card) {\n        card.ctx = ctx;\n        p15card = sc_pkcs15_card_new();\n        if (p15card) {\n            p15card->card = &card;\n        }\n    }\n\n    for (i = 0; i < sizeof decode_entries/sizeof *decode_entries; i++) {\n        struct sc_pkcs15_object *obj;\n        const u8 *p = Data;\n        size_t len = Size;\n        obj = calloc(1, sizeof *obj);\n        while (SC_SUCCESS == decode_entries[i](p15card, obj, &p, &len)) {\n            sc_pkcs15_free_object(obj);\n        }\n        sc_pkcs15_free_object(obj);\n    }\n\n    struct sc_pkcs15_pubkey *pubkey = calloc(1, sizeof *pubkey);\n    sc_pkcs15_decode_pubkey(ctx, pubkey, Data, Size);\n    sc_pkcs15_free_pubkey(pubkey);\n\n    struct sc_pkcs15_tokeninfo *tokeninfo = sc_pkcs15_tokeninfo_new();\n    sc_pkcs15_parse_tokeninfo(ctx, tokeninfo, Data, Size);\n    sc_pkcs15_free_tokeninfo(tokeninfo);\n\n    sc_pkcs15_parse_unusedspace(Data, Size, p15card);\n\n    return 0;\n}\n",
    "target": 1,
    "idx": 1017170,
    "stack_trace": [
      {
        "function_name": "sc_pkcs15_free_object",
        "function_body": "void\nsc_pkcs15_free_object(struct sc_pkcs15_object *obj)\n{\n\tif (!obj)\n\t\treturn;\n\tswitch (obj->type & SC_PKCS15_TYPE_CLASS_MASK) {\n\tcase SC_PKCS15_TYPE_PRKEY:\n\t\tsc_pkcs15_free_prkey_info((sc_pkcs15_prkey_info_t *)obj->data);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PUBKEY:\n\t\tsc_pkcs15_free_pubkey_info((sc_pkcs15_pubkey_info_t *)obj->data);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_CERT:\n\t\tsc_pkcs15_free_cert_info((sc_pkcs15_cert_info_t *)obj->data);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_DATA_OBJECT:\n\t\tsc_pkcs15_free_data_info((sc_pkcs15_data_info_t *)obj->data);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_AUTH:\n\t\tsc_pkcs15_free_auth_info((sc_pkcs15_auth_info_t *)obj->data);\n\t\tbreak;\n\tdefault:\n\t\tfree(obj->data);\n\t}\n\n\tsc_pkcs15_free_object_content(obj);\n\n\tfree(obj);\n}",
        "file_path": "/src/opensc/src/libopensc/pkcs15.c",
        "crashing_line": "\tswitch (obj->type & SC_PKCS15_TYPE_CLASS_MASK) {",
        "crashing_line_number": 1882
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static inline int read_and_check_crc(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n\n    int ret;\n    ret = read_data(ctx, 4);\n    if(ret) return ret;\n\n    ctx->current_chunk.crc = read_u32(ctx->data);\n\n    if(ctx->cur_actual_crc != ctx->current_chunk.crc)\n    {\n        if(is_critical_chunk(&ctx->current_chunk))\n        {\n            if(ctx->crc_action_critical == SPNG_CRC_USE) return 0;\n        }\n        else\n        {\n            if(ctx->crc_action_ancillary == SPNG_CRC_USE) return 0;\n            if(ctx->crc_action_ancillary == SPNG_CRC_DISCARD) return SPNG_CRC_DISCARD;\n        }\n\n        return SPNG_ECHUNK_CRC;\n    }\n\n    return 0;\n}\nstatic inline int read_header(spng_ctx *ctx, int *discard)\n{\n    if(ctx == NULL) return 1;\n\n    int ret;\n    struct spng_chunk chunk = { 0 };\n\n    ret = read_and_check_crc(ctx);\n    if(ret)\n    {\n        if(ret == SPNG_CRC_DISCARD)\n        {\n            if(discard != NULL) *discard = 1;\n        }\n        else return ret;\n    }\n\n    ret = read_data(ctx, 8);\n    if(ret) return ret;\n\n    chunk.offset = ctx->bytes_read - 8;\n\n    chunk.length = read_u32(ctx->data);\n\n    memcpy(&chunk.type, ctx->data + 4, 4);\n\n    if(chunk.length > png_u32max) return SPNG_ECHUNK_SIZE;\n\n    ctx->cur_chunk_bytes_left = chunk.length;\n\n    ctx->cur_actual_crc = crc32(0, NULL, 0);\n    ctx->cur_actual_crc = crc32(ctx->cur_actual_crc, chunk.type, 4);\n\n    memcpy(&ctx->current_chunk, &chunk, sizeof(struct spng_chunk));\n\n    return 0;\n}\nstatic int read_chunks_before_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n    if(ctx->data == NULL) return 1;\n    if(!ctx->valid_state) return SPNG_EBADSTATE;\n\n    int ret, discard = 0;\n    const unsigned char *data;\n    struct spng_chunk chunk;\n\n    chunk.offset = 8;\n    chunk.length = 13;\n    size_t sizeof_sig_ihdr = 29;\n\n    ret = read_data(ctx, sizeof_sig_ihdr);\n    if(ret) return ret;\n\n    data = ctx->data;\n\n    uint8_t signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n    if(memcmp(data, signature, sizeof(signature))) return SPNG_ESIGNATURE;\n\n    chunk.length = read_u32(data + 8);\n    memcpy(&chunk.type, data + 12, 4);\n\n    if(chunk.length != 13) return SPNG_EIHDR_SIZE;\n    if(memcmp(chunk.type, type_ihdr, 4)) return SPNG_ENOIHDR;\n\n    ctx->cur_actual_crc = crc32(0, NULL, 0);\n    ctx->cur_actual_crc = crc32(ctx->cur_actual_crc, data + 12, 17);\n\n    ctx->ihdr.width = read_u32(data + 16);\n    ctx->ihdr.height = read_u32(data + 20);\n    memcpy(&ctx->ihdr.bit_depth, data + 24, 1);\n    memcpy(&ctx->ihdr.color_type, data + 25, 1);\n    memcpy(&ctx->ihdr.compression_method, data + 26, 1);\n    memcpy(&ctx->ihdr.filter_method, data + 27, 1);\n    memcpy(&ctx->ihdr.interlace_method, data + 28, 1);\n\n    if(!ctx->max_width) ctx->max_width = png_u32max;\n    if(!ctx->max_height) ctx->max_height = png_u32max;\n\n    ret = check_ihdr(&ctx->ihdr, ctx->max_width, ctx->max_height);\n    if(ret) return ret;\n\n    ctx->file.ihdr = 1;\n    ctx->stored.ihdr = 1;\n\n    struct spng_chunk_bitfield stored;\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(!memcmp(chunk.type, type_idat, 4))\n        {\n            memcpy(&ctx->first_idat, &chunk, sizeof(struct spng_chunk));\n            return 0;\n        }\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        data = ctx->data;\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        if(is_critical_chunk(&chunk)) /* Critical chunk */\n        {\n            if(!memcmp(chunk.type, type_plte, 4))\n            {\n                if(chunk.length % 3 != 0) return SPNG_ECHUNK_SIZE;\n\n                ctx->plte.n_entries = chunk.length / 3;\n\n                if(check_plte(&ctx->plte, &ctx->ihdr)) return SPNG_ECHUNK_SIZE; /* XXX: EPLTE? */\n\n                size_t i;\n                for(i=0; i < ctx->plte.n_entries; i++)\n                {\n                    memcpy(&ctx->plte.entries[i].red,   data + i * 3, 1);\n                    memcpy(&ctx->plte.entries[i].green, data + i * 3 + 1, 1);\n                    memcpy(&ctx->plte.entries[i].blue,  data + i * 3 + 2, 1);\n                }\n\n                ctx->plte_offset = chunk.offset;\n\n                ctx->file.plte = 1;\n            }\n            else if(!memcmp(chunk.type, type_iend, 4)) return SPNG_ECHUNK_POS;\n            else if(!memcmp(chunk.type, type_ihdr, 4)) return SPNG_ECHUNK_POS;\n            else return SPNG_ECHUNK_UNKNOWN_CRITICAL;\n        }\n        else if(!memcmp(chunk.type, type_chrm, 4)) /* Ancillary chunks */\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.chrm) return SPNG_EDUP_CHRM;\n\n            if(chunk.length != 32) return SPNG_ECHUNK_SIZE;\n\n            ctx->chrm_int.white_point_x = read_u32(data);\n            ctx->chrm_int.white_point_y = read_u32(data + 4);\n            ctx->chrm_int.red_x = read_u32(data + 8);\n            ctx->chrm_int.red_y = read_u32(data + 12);\n            ctx->chrm_int.green_x = read_u32(data + 16);\n            ctx->chrm_int.green_y = read_u32(data + 20);\n            ctx->chrm_int.blue_x = read_u32(data + 24);\n            ctx->chrm_int.blue_y = read_u32(data + 28);\n\n            if(check_chrm_int(&ctx->chrm_int)) return SPNG_ECHRM;\n\n            ctx->file.chrm = 1;\n            ctx->stored.chrm = 1;\n        }\n        else if(!memcmp(chunk.type, type_gama, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.gama) return SPNG_EDUP_GAMA;\n\n            if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n            ctx->gama = read_u32(data);\n\n            if(!ctx->gama) return SPNG_EGAMA;\n            if(ctx->gama > png_u32max) return SPNG_EGAMA;\n\n            ctx->file.gama = 1;\n            ctx->stored.gama = 1;\n        }\n        else if(!memcmp(chunk.type, type_iccp, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.iccp) return SPNG_EDUP_ICCP;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_sbit, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.sbit) return SPNG_EDUP_SBIT;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 3) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1 , 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n            }\n            else if(ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 1, 1);\n            }\n            else if(ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1, 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 3, 1);\n            }\n\n            if(check_sbit(&ctx->sbit, &ctx->ihdr)) return SPNG_ESBIT;\n\n            ctx->file.sbit = 1;\n            ctx->stored.sbit = 1;\n        }\n        else if(!memcmp(chunk.type, type_srgb, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.srgb) return SPNG_EDUP_SRGB;\n\n            if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->srgb_rendering_intent, data, 1);\n\n            if(ctx->srgb_rendering_intent > 3) return SPNG_ESRGB;\n\n            ctx->file.srgb = 1;\n            ctx->stored.srgb = 1;\n        }\n        else if(!memcmp(chunk.type, type_bkgd, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.bkgd) return SPNG_EDUP_BKGD;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0 || ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.red = read_u16(data) & mask;\n                ctx->bkgd.green = read_u16(data + 2) & mask;\n                ctx->bkgd.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_EBKGD_NO_PLTE;\n\n                memcpy(&ctx->bkgd.plte_index, data, 1);\n                if(ctx->bkgd.plte_index >= ctx->plte.n_entries) return SPNG_EBKGD_PLTE_IDX;\n            }\n\n            ctx->file.bkgd = 1;\n            ctx->stored.bkgd = 1;\n        }\n        else if(!memcmp(chunk.type, type_trns, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.trns) return SPNG_EDUP_TRNS;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.red = read_u16(data) & mask;\n                ctx->trns.green = read_u16(data + 2) & mask;\n                ctx->trns.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length > ctx->plte.n_entries) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_ETRNS_NO_PLTE;\n\n                size_t k;\n                for(k=0; k < chunk.length; k++)\n                {\n                    memcpy(&ctx->trns.type3_alpha[k], data + k, 1);\n                }\n                ctx->trns.n_type3_entries = chunk.length;\n            }\n            else return SPNG_ETRNS_COLOR_TYPE;\n\n            ctx->file.trns = 1;\n            ctx->stored.trns = 1;\n        }\n        else if(!memcmp(chunk.type, type_hist, 4))\n        {\n            if(!ctx->file.plte) return SPNG_EHIST_NO_PLTE;\n            if(chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.hist) return SPNG_EDUP_HIST;\n\n            if( (chunk.length / 2) != (ctx->plte.n_entries) ) return SPNG_ECHUNK_SIZE;\n\n            size_t k;\n            for(k=0; k < (chunk.length / 2); k++)\n            {\n                ctx->hist.frequency[k] = read_u16(data + k*2);\n            }\n\n            ctx->file.hist = 1;\n            ctx->stored.hist = 1;\n        }\n        else if(!memcmp(chunk.type, type_phys, 4))\n        {\n            if(ctx->file.phys) return SPNG_EDUP_PHYS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->phys.ppu_x = read_u32(data);\n            ctx->phys.ppu_y = read_u32(data + 4);\n            memcpy(&ctx->phys.unit_specifier, data + 8, 1);\n\n            if(check_phys(&ctx->phys)) return SPNG_EPHYS;\n\n            ctx->file.phys = 1;\n            ctx->stored.phys = 1;\n        }\n        else if(!memcmp(chunk.type, type_splt, 4))\n        {\n            if(ctx->user.splt) continue; /* XXX: should check profile names for uniqueness */\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            ctx->file.splt = 1;\n\n            if(!ctx->stored.splt)\n            {\n                ctx->n_splt = 1;\n                ctx->splt_list = spng__calloc(ctx, 1, sizeof(struct spng_splt));\n                if(ctx->splt_list == NULL) return SPNG_EMEM;\n            }\n            else\n            {\n                ctx->n_splt++;\n                if(ctx->n_splt < 1) return SPNG_EOVERFLOW;\n                if(sizeof(struct spng_splt) > SIZE_MAX / ctx->n_splt) return SPNG_EOVERFLOW;\n\n                void *buf = spng__realloc(ctx, ctx->splt_list, ctx->n_splt * sizeof(struct spng_splt));\n                if(buf == NULL) return SPNG_EMEM;\n                ctx->splt_list = buf;\n                memset(&ctx->splt_list[ctx->n_splt - 1], 0, sizeof(struct spng_splt));\n            }\n\n            uint32_t i = ctx->n_splt - 1;\n\n            size_t keyword_len = chunk.length > 80 ? 80 : chunk.length;\n            char *keyword_nul = memchr(data, '\\0', keyword_len);\n            if(keyword_nul == NULL) return SPNG_ESPLT_NAME;\n\n            memcpy(&ctx->splt_list[i].name, data, keyword_len);\n\n            if(check_png_keyword(ctx->splt_list[i].name)) return SPNG_ESPLT_NAME;\n\n            keyword_len = strlen(ctx->splt_list[i].name);\n\n            if( (chunk.length - keyword_len - 1) ==  0) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->splt_list[i].sample_depth, data + keyword_len + 1, 1);\n\n            if(ctx->n_splt > 1)\n            {\n                uint32_t j;\n                for(j=0; j < i; j++)\n                {\n                    if(!strcmp(ctx->splt_list[j].name, ctx->splt_list[i].name)) return SPNG_ESPLT_DUP_NAME;\n                }\n            }\n\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                if( (chunk.length - keyword_len - 2) % 10 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 10;\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                if( (chunk.length - keyword_len - 2) % 6 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 6;\n            }\n            else return SPNG_ESPLT_DEPTH;\n\n            if(ctx->splt_list[i].n_entries == 0) return SPNG_ECHUNK_SIZE;\n            if(sizeof(struct spng_splt_entry) > SIZE_MAX / ctx->splt_list[i].n_entries) return SPNG_EOVERFLOW;\n\n            ctx->splt_list[i].entries = spng__malloc(ctx, sizeof(struct spng_splt_entry) * ctx->splt_list[i].n_entries);\n            if(ctx->splt_list[i].entries == NULL) return SPNG_EMEM;\n\n            const unsigned char *splt = data + keyword_len + 2;\n\n            size_t k;\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    ctx->splt_list[i].entries[k].red = read_u16(splt + k * 10);\n                    ctx->splt_list[i].entries[k].green = read_u16(splt + k * 10 + 2);\n                    ctx->splt_list[i].entries[k].blue = read_u16(splt + k * 10 + 4);\n                    ctx->splt_list[i].entries[k].alpha = read_u16(splt + k * 10 + 6);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 10 + 8);\n                }\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    uint8_t red, green, blue, alpha;\n                    memcpy(&red,   splt + k * 6, 1);\n                    memcpy(&green, splt + k * 6 + 1, 1);\n                    memcpy(&blue,  splt + k * 6 + 2, 1);\n                    memcpy(&alpha, splt + k * 6 + 3, 1);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 6 + 4);\n\n                    ctx->splt_list[i].entries[k].red = red;\n                    ctx->splt_list[i].entries[k].green = green;\n                    ctx->splt_list[i].entries[k].blue = blue;\n                    ctx->splt_list[i].entries[k].alpha = alpha;\n                }\n            }\n\n            ctx->stored.splt = 1;\n        }\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n            if(ctx->file.time) return SPNG_EDUP_TIME;\n\n            if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_offs, 4))\n        {\n            if(ctx->file.offs) return SPNG_EDUP_OFFS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->offs.x = read_s32(data);\n            ctx->offs.y = read_s32(data + 4);\n            memcpy(&ctx->offs.unit_specifier, data + 8, 1);\n\n            if(check_offs(&ctx->offs)) return SPNG_EOFFS;\n\n            ctx->file.offs = 1;\n            ctx->stored.offs = 1;\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n    }\n\n    return ret;\n}\nstatic int read_chunks_after_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n\n    int ret, discard = 0;\n    int prev_was_idat = 1;\n    struct spng_chunk chunk;\n    const unsigned char *data;\n    struct spng_chunk_bitfield stored;\n\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    memcpy(&chunk, &ctx->last_idat, sizeof(struct spng_chunk));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        data = ctx->data;\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        /* Critical chunk */\n        if(is_critical_chunk(&chunk))\n        {\n            if(!memcmp(chunk.type, type_iend, 4)) return 0;\n            else if(!memcmp(chunk.type, type_idat, 4) && prev_was_idat) continue; /* ignore extra IDATs */\n            else return SPNG_ECHUNK_POS; /* critical chunk after last IDAT that isn't IEND */\n        }\n\n        prev_was_idat = 0;\n\n        if(!memcmp(chunk.type, type_chrm, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_gama, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_iccp, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_sbit, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_srgb, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_bkgd, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_hist, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_trns, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_phys, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_splt, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_offs, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n           if(ctx->file.time) return SPNG_EDUP_TIME;\n\n           if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n    }\n\n    return ret;\n}\n",
    "target": 1,
    "idx": 1016081,
    "stack_trace": [
      {
        "function_name": "read_chunks_after_idat",
        "function_body": "static int read_chunks_after_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n\n    int ret, discard = 0;\n    int prev_was_idat = 1;\n    struct spng_chunk chunk;\n    const unsigned char *data;\n    struct spng_chunk_bitfield stored;\n\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    memcpy(&chunk, &ctx->last_idat, sizeof(struct spng_chunk));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(is_critical_chunk(&chunk))\n        {\n            if(!memcmp(chunk.type, type_iend, 4))\n            {\n                if(chunk.length) return SPNG_ECHUNK_CRC;\n\n                ret = read_and_check_crc(ctx);\n                if(ret == -SPNG_CRC_DISCARD) ret = 0;\n\n                return ret;\n            }\n            else if(!memcmp(chunk.type, type_idat, 4) && prev_was_idat)\n            {/* ignore extra IDATs */\n                ret = discard_chunk_bytes(ctx, chunk.length);\n                if(ret) return ret;\n\n                continue;\n            }\n            else return SPNG_ECHUNK_POS; /* critical chunk after last IDAT that isn't IEND */\n        }\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        data = ctx->data;\n\n        prev_was_idat = 0;\n\n        if(!memcmp(chunk.type, type_chrm, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_gama, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_iccp, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_sbit, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_srgb, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_bkgd, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_hist, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_trns, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_phys, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_splt, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_offs, 4)) return SPNG_ECHUNK_POS;\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n           if(ctx->file.time) return SPNG_EDUP_TIME;\n\n           if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n    }\n\n    return ret;\n}",
        "file_path": "/src/libspng/build/../spng.c",
        "crashing_line": "            ctx->stored.time = 1;",
        "crashing_line_number": 1577
      },
      {
        "function_name": "spng_decode_image",
        "function_body": "int spng_decode_image(spng_ctx *ctx, unsigned char *out, size_t out_size, int fmt, int flags)\n{\n    if(ctx == NULL) return 1;\n    if(out == NULL) return 1;\n\n    int ret;\n    size_t out_size_required, out_width;\n\n    ret = spng_decoded_image_size(ctx, fmt, &out_size_required);\n    if(ret) return ret;\n    if(out_size < out_size_required) return SPNG_EBUFSIZ;\n\n    out_width = out_size_required / ctx->ihdr.height;\n\n    uint8_t channels = 1; /* grayscale or indexed_color */\n\n    if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) channels = 3;\n    else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA) channels = 2;\n    else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA) channels = 4;\n\n    uint8_t bytes_per_pixel;\n\n    if(ctx->ihdr.bit_depth < 8) bytes_per_pixel = 1;\n    else bytes_per_pixel = channels * (ctx->ihdr.bit_depth / 8);\n\n    z_stream stream;\n    stream.zalloc = spng__zalloc;\n    stream.zfree = spng__zfree;\n    stream.opaque = ctx;\n\n    if(inflateInit(&stream) != Z_OK) return SPNG_EZLIB;\n\n    int apply_trns = 0;\n    if(flags & SPNG_DECODE_USE_TRNS && ctx->stored.trns) apply_trns = 1;\n\n    int apply_gamma = 0;\n    if(flags & SPNG_DECODE_USE_GAMA && ctx->stored.gama) apply_gamma = 1;\n\n    int use_sbit = 0;\n    if(flags & SPNG_DECODE_USE_SBIT && ctx->stored.sbit) use_sbit = 1;\n\n    int indexed = 0;\n    if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED) indexed = 1;\n\n    int do_scaling = 1;\n    if(indexed) do_scaling = 0;\n\n    int interlaced = 0;\n    if(ctx->ihdr.interlace_method) interlaced = 1;\n\n    int pass;\n    uint8_t filter = 0, next_filter = 0;\n    uint32_t i, k, scanline_idx, width;\n    uint8_t r_8, g_8, b_8, a_8, gray_8;\n    uint16_t r_16, g_16, b_16, a_16, gray_16;\n    r_8=0; g_8=0; b_8=0; a_8=0; gray_8=0;\n    r_16=0; g_16=0; b_16=0; a_16=0; gray_16=0;\n    unsigned char *pixel;\n    size_t pixel_offset = 0;\n    size_t pixel_size = 4; /* SPNG_FMT_RGBA8 */\n    unsigned processing_depth = ctx->ihdr.bit_depth;\n    unsigned depth_target = 8; /* FMT_RGBA8 */\n\n    if(indexed) processing_depth = 8;\n\n    if(fmt == SPNG_FMT_RGBA16)\n    {\n        depth_target = 16;\n        pixel_size = 8;\n    }\n\n    struct spng_subimage sub[7];\n    memset(sub, 0, sizeof(struct spng_subimage) * 7);\n\n    size_t scanline_width;\n\n    ret = calculate_subimages(sub, &scanline_width, &ctx->ihdr, channels);\n    if(ret) return ret;\n\n    unsigned char *row = NULL;\n    unsigned char *scanline = spng__malloc(ctx, scanline_width);\n    unsigned char *prev_scanline = spng__malloc(ctx, scanline_width);\n\n    if(interlaced) row = spng__malloc(ctx, out_width);\n    else row = out;\n\n    if(scanline == NULL || prev_scanline == NULL || row == NULL)\n    {\n        ret = SPNG_EMEM;\n        goto decode_err;\n    }\n\n    uint16_t *gamma_lut = NULL;\n\n    if(apply_gamma)\n    {\n        float file_gamma = (float)ctx->gama / 100000.0f;\n        float max;\n\n        uint32_t lut_entries;\n\n        if(fmt == SPNG_FMT_RGBA8)\n        {\n            lut_entries = 256;\n            max = 255.0f;\n\n            gamma_lut = ctx->gamma_lut8;\n        }\n        else /* SPNG_FMT_RGBA16 */\n        {\n            lut_entries = 65536;\n            max = 65535.0f;\n\n            ctx->gamma_lut = spng__malloc(ctx, lut_entries * sizeof(uint16_t));\n            if(ctx->gamma_lut == NULL)\n            {\n                ret = SPNG_EMEM;\n                goto decode_err;\n            }\n            gamma_lut = ctx->gamma_lut;\n        }\n\n        float screen_gamma = 2.2f;\n        float exponent = file_gamma * screen_gamma;\n\n        if(FP_ZERO == fpclassify(exponent))\n        {\n            ret = SPNG_EGAMA;\n            goto decode_err;\n        }\n\n        exponent = 1.0f / exponent;\n\n        for(i=0; i < lut_entries; i++)\n        {\n            float c = pow((float)i / max, exponent) * max;\n            c = fmin(c, max);\n\n            gamma_lut[i] = (uint16_t)c;\n        }\n    }\n\n    struct spng_sbit sb;\n\n    sb.red_bits = ctx->ihdr.bit_depth;\n    sb.green_bits = ctx->ihdr.bit_depth;\n    sb.blue_bits = ctx->ihdr.bit_depth;\n    sb.alpha_bits = ctx->ihdr.bit_depth;\n    sb.grayscale_bits = ctx->ihdr.bit_depth;\n\n    if(indexed)\n    {\n        sb.red_bits = 8;\n        sb.green_bits = 8;\n        sb.blue_bits = 8;\n        sb.alpha_bits = 8;\n    }\n\n    if(use_sbit)\n    {\n        if(ctx->ihdr.color_type == 0)\n        {\n            sb.grayscale_bits = ctx->sbit.grayscale_bits;\n            sb.alpha_bits = ctx->ihdr.bit_depth;\n        }\n        else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 3)\n        {\n            sb.red_bits = ctx->sbit.red_bits;\n            sb.green_bits = ctx->sbit.green_bits;\n            sb.blue_bits = ctx->sbit.blue_bits;\n            sb.alpha_bits = ctx->ihdr.bit_depth;\n        }\n        else if(ctx->ihdr.color_type == 4)\n        {\n            sb.grayscale_bits = ctx->sbit.grayscale_bits;\n            sb.alpha_bits = ctx->sbit.alpha_bits;\n        }\n        else /* == 6 */\n        {\n            sb.red_bits = ctx->sbit.red_bits;\n            sb.green_bits = ctx->sbit.green_bits;\n            sb.blue_bits = ctx->sbit.blue_bits;\n            sb.alpha_bits = ctx->sbit.alpha_bits;\n        }\n    }\n\n    if(ctx->ihdr.bit_depth == 16 && fmt == SPNG_FMT_RGBA8)\n    {/* in this case samples are scaled down by 8bits */\n        sb.red_bits -= 8;\n        sb.green_bits -= 8;\n        sb.blue_bits -= 8;\n        sb.alpha_bits -= 8;\n        sb.grayscale_bits -= 8;\n\n        processing_depth = 8;\n    }\n\n    /* Prevent infinite loops in sample_to_target() */\n    if(!depth_target || depth_target > 16 ||\n       !processing_depth || processing_depth > 16 ||\n       !sb.grayscale_bits || sb.grayscale_bits > processing_depth ||\n       !sb.alpha_bits || sb.alpha_bits > processing_depth ||\n       !sb.red_bits || sb.red_bits > processing_depth ||\n       !sb.green_bits || sb.green_bits > processing_depth ||\n       !sb.blue_bits || sb.blue_bits > processing_depth)\n    {\n        ret = SPNG_ESBIT;\n        goto decode_err;\n    }\n\n    if(sb.red_bits == sb.green_bits &&\n       sb.green_bits == sb.blue_bits &&\n       sb.blue_bits == sb.alpha_bits &&\n       sb.alpha_bits == processing_depth &&\n       processing_depth == depth_target) do_scaling = 0;\n\n    struct spng_plte_entry16 plte[256];\n\n    /* Pre-process palette entries */\n    if(indexed)\n    {\n        for(i=0; i < ctx->plte.n_entries; i++)\n        {\n            if(apply_trns && i < ctx->trns.n_type3_entries)\n                ctx->plte.entries[i].alpha = ctx->trns.type3_alpha[i];\n            else\n                ctx->plte.entries[i].alpha = 255;\n\n            plte[i].red = sample_to_target(ctx->plte.entries[i].red, 8, sb.red_bits, depth_target);\n            plte[i].green = sample_to_target(ctx->plte.entries[i].green, 8, sb.green_bits, depth_target);\n            plte[i].blue = sample_to_target(ctx->plte.entries[i].blue, 8, sb.blue_bits, depth_target);\n            plte[i].alpha = sample_to_target(ctx->plte.entries[i].alpha, 8, sb.alpha_bits, depth_target);\n\n            if(apply_gamma)\n            {\n                plte[i].red = gamma_lut[plte[i].red];\n                plte[i].green = gamma_lut[plte[i].green];\n                plte[i].blue = gamma_lut[plte[i].blue];\n            }\n        }\n\n        apply_trns = 0;\n        apply_gamma = 0;\n    }\n\n    unsigned char trns_px[8];\n\n    if(apply_trns && ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR)\n    {\n        if(ctx->ihdr.bit_depth == 16)\n        {\n            memcpy(trns_px, &ctx->trns.red, 2);\n            memcpy(trns_px + 2, &ctx->trns.green, 2);\n            memcpy(trns_px + 4, &ctx->trns.blue, 2);\n        }\n        else\n        {\n            trns_px[0] = ctx->trns.red;\n            trns_px[1] = ctx->trns.green;\n            trns_px[2] = ctx->trns.blue;\n        }\n    }\n\n    stream.avail_in = 0;\n    stream.next_in = ctx->data;\n\n    for(pass=0; pass < 7; pass++)\n    {\n        /* Skip empty passes */\n        if(sub[pass].width == 0 || sub[pass].height == 0) continue;\n\n        scanline_width = sub[pass].scanline_width;\n\n        /* prev_scanline is all zeros for the first scanline */\n        memset(prev_scanline, 0, scanline_width);\n\n        /* Read the first filter byte, offsetting all reads by 1 byte.\n           The scanlines will be aligned with the start of the array with\n           the next scanline's filter byte at the end,\n           the last scanline will end up being 1 byte \"shorter\". */\n        ret = read_scanline_bytes(ctx, &stream, &filter, 1);\n        if(ret) goto decode_err;\n\n        for(scanline_idx=0; scanline_idx < sub[pass].height; scanline_idx++)\n        {\n            /* The last scanline is 1 byte \"shorter\" */\n            if(scanline_idx == (sub[pass].height - 1))\n                ret = read_scanline_bytes(ctx, &stream, scanline, scanline_width - 1);\n            else\n                ret = read_scanline_bytes(ctx, &stream, scanline, scanline_width);\n\n            if(ret) goto decode_err;\n\n            memcpy(&next_filter, scanline + scanline_width - 1, 1);\n\n            ret = defilter_scanline(prev_scanline, scanline, scanline_width - 1, bytes_per_pixel, filter);\n            if(ret) goto decode_err;\n\n            filter = next_filter;\n\n            pixel_offset = 0;\n            width = sub[pass].width;\n\n            for(k=0; k < width; k++)\n            {\n                pixel = row + pixel_offset;\n                pixel_offset += pixel_size;\n\n\n                if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR)\n                {\n                    if(ctx->ihdr.bit_depth == 16)\n                    {\n                        r_16 = read_u16(scanline + (k * 6));\n                        g_16 = read_u16(scanline + (k * 6) + 2);\n                        b_16 = read_u16(scanline + (k * 6) + 4);\n\n                        a_16 = 65535;\n                    }\n                    else /* == 8 */\n                    {\n                        if(fmt == SPNG_FMT_RGBA8)\n                        {\n                            memcpy(pixel, scanline + (k * 3), 3);\n                            pixel[3] = 255;\n                            continue;\n                        }\n\n                        memcpy(&r_8, scanline + (k * 3), 1);\n                        memcpy(&g_8, scanline + (k * 3) + 1, 1);\n                        memcpy(&b_8, scanline + (k * 3) + 2, 1);\n\n                        a_8 = 255;\n                    }\n                }\n                else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED)\n                {\n                    uint8_t entry = 0;\n\n                    if(ctx->ihdr.bit_depth == 8)\n                    {\n                        memcpy(&entry, scanline + k, 1);\n                    }\n                    else\n                    {\n                        memcpy(&entry, scanline + k / (8 / ctx->ihdr.bit_depth), 1);\n\n                        uint8_t mask = (1 << ctx->ihdr.bit_depth) - 1;\n                        uint8_t samples_per_byte = 8 / ctx->ihdr.bit_depth;\n                        uint8_t max_shift_amount = 8 - ctx->ihdr.bit_depth;\n                        uint8_t shift_amount = max_shift_amount - ((k % samples_per_byte) * ctx->ihdr.bit_depth);\n\n                        entry = entry & (mask << shift_amount);\n                        entry = entry >> shift_amount;\n                    }\n\n                    if(entry >= ctx->plte.n_entries)\n                    {\n                        ret = SPNG_EPLTE_IDX;\n                        goto decode_err;\n                    }\n\n                    if(fmt == SPNG_FMT_RGBA8)\n                    {\n                        pixel[0] = plte[entry].red;\n                        pixel[1] = plte[entry].green;\n                        pixel[2] = plte[entry].blue;\n                        pixel[3] = plte[entry].alpha;\n\n                        continue;\n                    }\n                    else\n                    {\n                        r_16 = plte[entry].red;\n                        g_16 = plte[entry].green;\n                        b_16 = plte[entry].blue;\n                        a_16 = plte[entry].alpha;\n\n                        memcpy(pixel, &r_16, 2);\n                        memcpy(pixel + 2, &g_16, 2);\n                        memcpy(pixel + 4, &b_16, 2);\n                        memcpy(pixel + 6, &a_16, 2);\n\n                        continue;\n                    }\n                }\n                else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA)\n                {\n                    if(ctx->ihdr.bit_depth == 16)\n                    {\n                        r_16 = read_u16(scanline + (k * 8));\n                        g_16 = read_u16(scanline + (k * 8) + 2);\n                        b_16 = read_u16(scanline + (k * 8) + 4);\n                        a_16 = read_u16(scanline + (k * 8) + 6);\n                    }\n                    else /* == 8 */\n                    {\n                        if(fmt == SPNG_FMT_RGBA8)\n                        {\n                            memcpy(row, scanline, scanline_width - 1);\n                            break;\n                        }\n\n                        memcpy(&r_8, scanline + (k * 4), 1);\n                        memcpy(&g_8, scanline + (k * 4) + 1, 1);\n                        memcpy(&b_8, scanline + (k * 4) + 2, 1);\n                        memcpy(&a_8, scanline + (k * 4) + 3, 1);\n                    }\n                }\n                else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE)\n                {\n                    if(ctx->ihdr.bit_depth == 16)\n                    {\n                        gray_16 = read_u16(scanline + (k * 2));\n\n                        if(apply_trns && ctx->trns.gray == gray_16) a_16 = 0;\n                        else a_16 = 65535;\n\n                        r_16 = gray_16;\n                        g_16 = gray_16;\n                        b_16 = gray_16;\n                    }\n                    else /* <= 8 */\n                    {\n                        memcpy(&gray_8, scanline + k / (8 / ctx->ihdr.bit_depth), 1);\n\n                        uint16_t mask16 = (1 << ctx->ihdr.bit_depth) - 1;\n                        uint8_t mask = mask16; /* avoid shift by width */\n                        uint8_t samples_per_byte = 8 / ctx->ihdr.bit_depth;\n                        uint8_t max_shift_amount = 8 - ctx->ihdr.bit_depth;\n                        uint8_t shift_amount = max_shift_amount - ((k % samples_per_byte) * ctx->ihdr.bit_depth);\n\n                        gray_8 = gray_8 & (mask << shift_amount);\n                        gray_8 = gray_8 >> shift_amount;\n\n                        if(apply_trns && ctx->trns.gray == gray_8) a_8 = 0;\n                        else a_8 = 255;\n\n                        r_8 = gray_8; g_8 = gray_8; b_8 = gray_8;\n                    }\n                }\n                else if(ctx->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA)\n                {\n                    if(ctx->ihdr.bit_depth == 16)\n                    {\n                        gray_16 = read_u16(scanline + (k * 4));\n                        a_16 = read_u16(scanline + (k * 4) + 2);\n\n                        r_16 = gray_16;\n                        g_16 = gray_16;\n                        b_16 = gray_16;\n                    }\n                    else /* == 8 */\n                    {\n                        memcpy(&gray_8, scanline + (k * 2), 1);\n                        memcpy(&a_8, scanline + (k * 2) + 1, 1);\n\n                        r_8 = gray_8;\n                        g_8 = gray_8;\n                        b_8 = gray_8;\n                    }\n                }\n\n\n                if(fmt == SPNG_FMT_RGBA8)\n                {\n                    if(ctx->ihdr.bit_depth == 16)\n                    {\n                        r_8 = r_16 >> 8;\n                        g_8 = g_16 >> 8;\n                        b_8 = b_16 >> 8;\n                        a_8 = a_16 >> 8;\n                    }\n\n                    memcpy(pixel, &r_8, 1);\n                    memcpy(pixel + 1, &g_8, 1);\n                    memcpy(pixel + 2, &b_8, 1);\n                    memcpy(pixel + 3, &a_8, 1);\n                }\n                else if(fmt == SPNG_FMT_RGBA16)\n                {\n                    if(ctx->ihdr.bit_depth != 16)\n                    {\n                        r_16 = r_8;\n                        g_16 = g_8;\n                        b_16 = b_8;\n                        a_16 = a_8;\n                    }\n\n                    memcpy(pixel, &r_16, 2);\n                    memcpy(pixel + 2, &g_16, 2);\n                    memcpy(pixel + 4, &b_16, 2);\n                    memcpy(pixel + 6, &a_16, 2);\n                }\n            }/* for(k=0; k < sub[pass].width; k++) */\n\n            if(apply_trns) trns_row(row, scanline, trns_px, width, fmt, ctx->ihdr.color_type, ctx->ihdr.bit_depth);\n\n            if(do_scaling) scale_row(row, width, fmt, processing_depth, &sb);\n\n            if(apply_gamma) gamma_correct_row(row, width, fmt, gamma_lut);\n\n            /* prev_scanline is always defiltered */\n            memcpy(prev_scanline, scanline, scanline_width);\n\n            if(interlaced)\n            {\n                const unsigned int adam7_x_start[7] = { 0, 4, 0, 2, 0, 1, 0 };\n                const unsigned int adam7_y_start[7] = { 0, 0, 4, 0, 2, 0, 1 };\n                const unsigned int adam7_x_delta[7] = { 8, 8, 4, 4, 2, 2, 1 };\n                const unsigned int adam7_y_delta[7] = { 8, 8, 8, 4, 4, 2, 2 };\n\n                for(k=0; k < width; k++)\n                {\n                    size_t ioffset = ((adam7_y_start[pass] + scanline_idx * adam7_y_delta[pass]) *\n                                      ctx->ihdr.width + adam7_x_start[pass] + k * adam7_x_delta[pass]) * pixel_size;\n\n                    memcpy((unsigned char*)out + ioffset, row + k * pixel_size, pixel_size);\n                }\n            }\n            else\n            {/* avoid creating an invalid reference */\n                if(scanline_idx != (sub[pass].height - 1) ) row += out_width;\n            }\n\n        }/* for(scanline_idx=0; scanline_idx < sub[pass].height; scanline_idx++) */\n    }/* for(pass=0; pass < 7; pass++) */\n\n    if(ctx->cur_chunk_bytes_left) /* zlib stream ended before an IDAT chunk boundary */\n    {/* discard the rest of the chunk */\n        ret = discard_chunk_bytes(ctx, ctx->cur_chunk_bytes_left);\n    }\n\ndecode_err:\n\n    inflateEnd(&stream);\n    if(interlaced) spng__free(ctx, row);\n    spng__free(ctx, scanline);\n    spng__free(ctx, prev_scanline);\n\n    if(ret)\n    {\n        ctx->valid_state = 0;\n        return ret;\n    }\n\n    memcpy(&ctx->last_idat, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n    ret = read_chunks_after_idat(ctx);\n\n    if(ret) ctx->valid_state = 0;\n\n    return ret;\n}",
        "file_path": "/src/libspng/build/../spng.c",
        "crashing_line": "decode_err:",
        "crashing_line_number": 2260
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "void\nQPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    std::set<qpdf_offset_t> visited;\n    while (xref_offset) {\n        visited.insert(xref_offset);\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n        m->file->seek(xref_offset, SEEK_SET);\n        // Some files miss the mark a little with startxref. We could do a better job of searching\n        // in the neighborhood for something that looks like either an xref table or stream, but the\n        // simple heuristic of skipping whitespace can help with the xref table case and is harmless\n        // with the stream case.\n        bool done = false;\n        bool skipped_space = false;\n        while (!done) {\n            char ch;\n            if (1 == m->file->read(&ch, 1)) {\n                if (QUtil::is_space(ch)) {\n                    skipped_space = true;\n                } else {\n                    m->file->unreadCh(ch);\n                    done = true;\n                }\n            } else {\n                QTC::TC(\"qpdf\", \"QPDF eof skipping spaces before xref\", skipped_space ? 0 : 1);\n                done = true;\n            }\n        }\n\n        m->file->read(buf, sizeof(buf) - 1);\n        // The PDF spec says xref must be followed by a line terminator, but files exist in the wild\n        // where it is terminated by arbitrary whitespace.\n        if ((strncmp(buf, \"xref\", 4) == 0) && QUtil::is_space(buf[4])) {\n            if (skipped_space) {\n                QTC::TC(\"qpdf\", \"QPDF xref skipped space\");\n                warn(damagedPDF(\"\", 0, \"extraneous whitespace seen before xref\"));\n            }\n            QTC::TC(\n                \"qpdf\",\n                \"QPDF xref space\",\n                ((buf[4] == '\\n')       ? 0\n                     : (buf[4] == '\\r') ? 1\n                     : (buf[4] == ' ')  ? 2\n                                        : 9999));\n            int skip = 4;\n            // buf is null-terminated, and QUtil::is_space('\\0') is false, so this won't overrun.\n            while (QUtil::is_space(buf[skip])) {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n        } else {\n            xref_offset = read_xrefStream(xref_offset);\n        }\n        if (visited.count(xref_offset) != 0) {\n            QTC::TC(\"qpdf\", \"QPDF xref loop\");\n            throw damagedPDF(\"\", 0, \"loop detected following xref tables\");\n        }\n    }\n\n    if (!m->trailer.isInitialized()) {\n        throw damagedPDF(\"\", 0, \"unable to find trailer while reading xref\");\n    }\n    int size = m->trailer.getKey(\"/Size\").getIntValueAsInt();\n    int max_obj = 0;\n    if (!m->xref_table.empty()) {\n        max_obj = (*(m->xref_table.rbegin())).first.getObj();\n    }\n    if (!m->deleted_objects.empty()) {\n        max_obj = std::max(max_obj, *(m->deleted_objects.rbegin()));\n    }\n    if ((size < 1) || (size - 1 != max_obj)) {\n        QTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n        warn(damagedPDF(\n            \"\",\n            0,\n            (\"reported number of objects (\" + std::to_string(size) +\n             \") is not one plus the highest object number (\" + std::to_string(max_obj) + \")\")));\n    }\n\n    // We no longer need the deleted_objects table, so go ahead and clear it out to make sure we\n    // never depend on its being set.\n    m->deleted_objects.clear();\n\n    // Make sure we keep only the highest generation for any object.\n    QPDFObjGen last_og{-1, 0};\n    for (auto const& og: m->xref_table) {\n        if (og.first.getObj() == last_og.getObj())\n            removeObject(last_og);\n        last_og = og.first;\n    }\n}\nstd::vector<QPDFObjGen>\nQPDF::getCompressibleObjGens()\n{\n    // Return a list of objects that are allowed to be in object streams.  Walk through the objects\n    // by traversing the document from the root, including a traversal of the pages tree.  This\n    // makes that objects that are on the same page are more likely to be in the same object stream,\n    // which is slightly more efficient, particularly with linearized files.  This is better than\n    // iterating through the xref table since it avoids preserving orphaned items.\n\n    // Exclude encryption dictionary, if any\n    QPDFObjectHandle encryption_dict = m->trailer.getKey(\"/Encrypt\");\n    QPDFObjGen encryption_dict_og = encryption_dict.getObjGen();\n\n    const size_t max_obj = getObjectCount();\n    std::vector<bool> visited(max_obj, false);\n    std::vector<QPDFObjectHandle> queue;\n    queue.reserve(512);\n    queue.push_back(m->trailer);\n    std::vector<QPDFObjGen> result;\n    while (!queue.empty()) {\n        auto obj = queue.back();\n        queue.pop_back();\n        if (obj.isIndirect()) {\n            QPDFObjGen og = obj.getObjGen();\n            const size_t id = toS(og.getObj() - 1);\n            if (id >= max_obj)\n                throw std::logic_error(\n                    \"unexpected object id encountered in getCompressibleObjGens\");\n            if (visited[id]) {\n                QTC::TC(\"qpdf\", \"QPDF loop detected traversing objects\");\n                continue;\n            }\n\n            // Check whether this is the current object. If not, remove it (which changes it into a\n            // direct null and therefore stops us from revisiting it) and move on to the next object\n            // in the queue.\n            auto upper = m->obj_cache.upper_bound(og);\n            if (upper != m->obj_cache.end() && upper->first.getObj() == og.getObj()) {\n                removeObject(og);\n                continue;\n            }\n\n            visited[id] = true;\n\n            if (og == encryption_dict_og) {\n                QTC::TC(\"qpdf\", \"QPDF exclude encryption dictionary\");\n            } else if (!(obj.isStream() ||\n                         (obj.isDictionaryOfType(\"/Sig\") && obj.hasKey(\"/ByteRange\") &&\n                          obj.hasKey(\"/Contents\")))) {\n                result.push_back(og);\n            }\n        }\n        if (obj.isStream()) {\n            QPDFObjectHandle dict = obj.getDict();\n            std::set<std::string> keys = dict.getKeys();\n            for (auto iter = keys.rbegin(); iter != keys.rend(); ++iter) {\n                std::string const& key = *iter;\n                QPDFObjectHandle value = dict.getKey(key);\n                if (key == \"/Length\") {\n                    // omit stream lengths\n                    if (value.isIndirect()) {\n                        QTC::TC(\"qpdf\", \"QPDF exclude indirect length\");\n                    }\n                } else {\n                    queue.push_back(value);\n                }\n            }\n        } else if (obj.isDictionary()) {\n            std::set<std::string> keys = obj.getKeys();\n            for (auto iter = keys.rbegin(); iter != keys.rend(); ++iter) {\n                queue.push_back(obj.getKey(*iter));\n            }\n        } else if (obj.isArray()) {\n            int n = obj.getArrayNItems();\n            for (int i = 1; i <= n; ++i) {\n                queue.push_back(obj.getArrayItem(n - i));\n            }\n        }\n    }\n\n    return result;\n}\n",
    "target": 1,
    "idx": 1065777,
    "stack_trace": [
      {
        "function_name": "read_xref",
        "function_body": "        size_t\n        read(char* buffer, size_t length) override\n        {\n            throwException();\n            return 0;\n        }",
        "file_path": "/src/qpdf/libqpdf/QPDF.cc",
        "crashing_line": "",
        "crashing_line_number": 715
      },
      {
        "function_name": "reconstruct_xref",
        "function_body": "void\nQPDF::reconstruct_xref(QPDFExc& e)\n{\n    if (m->reconstructed_xref) {\n        // Avoid xref reconstruction infinite loops. This is getting very hard to reproduce because\n        // qpdf is throwing many fewer exceptions while parsing. Most situations are warnings now.\n        throw e;\n    }\n\n    m->reconstructed_xref = true;\n    // We may find more objects, which may contain dangling references.\n    m->fixed_dangling_refs = false;\n\n    warn(damagedPDF(\"\", 0, \"file is damaged\"));\n    warn(e);\n    warn(damagedPDF(\"\", 0, \"Attempting to reconstruct cross-reference table\"));\n\n    // Delete all references to type 1 (uncompressed) objects\n    std::set<QPDFObjGen> to_delete;\n    for (auto const& iter: m->xref_table) {\n        if (iter.second.getType() == 1) {\n            to_delete.insert(iter.first);\n        }\n    }\n    for (auto const& iter: to_delete) {\n        m->xref_table.erase(iter);\n    }\n\n    m->file->seek(0, SEEK_END);\n    qpdf_offset_t eof = m->file->tell();\n    m->file->seek(0, SEEK_SET);\n    qpdf_offset_t line_start = 0;\n    // Don't allow very long tokens here during recovery.\n    static size_t const MAX_LEN = 100;\n    while (m->file->tell() < eof) {\n        m->file->findAndSkipNextEOL();\n        qpdf_offset_t next_line_start = m->file->tell();\n        m->file->seek(line_start, SEEK_SET);\n        QPDFTokenizer::Token t1 = readToken(m->file, MAX_LEN);\n        qpdf_offset_t token_start = m->file->tell() - toO(t1.getValue().length());\n        if (token_start >= next_line_start) {\n            // don't process yet -- wait until we get to the line containing this token\n        } else if (t1.isInteger()) {\n            QPDFTokenizer::Token t2 = readToken(m->file, MAX_LEN);\n            if ((t2.isInteger()) && (readToken(m->file, MAX_LEN).isWord(\"obj\"))) {\n                int obj = QUtil::string_to_int(t1.getValue().c_str());\n                int gen = QUtil::string_to_int(t2.getValue().c_str());\n                insertReconstructedXrefEntry(obj, token_start, gen);\n            }\n        } else if (!m->trailer.isInitialized() && t1.isWord(\"trailer\")) {\n            QPDFObjectHandle t = readTrailer();\n            if (!t.isDictionary()) {\n                // Oh well.  It was worth a try.\n            } else {\n                setTrailer(t);\n            }\n        }\n        m->file->seek(next_line_start, SEEK_SET);\n        line_start = next_line_start;\n    }\n    m->deleted_objects.clear();\n\n    if (!m->trailer.isInitialized()) {\n        qpdf_offset_t max_offset{0};\n        // If there are any xref streams, take the last one to appear.\n        for (auto const& iter: m->xref_table) {\n            auto entry = iter.second;\n            if (entry.getType() != 1) {\n                continue;\n            }\n            auto oh = getObjectByObjGen(iter.first);\n            try {\n                if (!oh.isStreamOfType(\"/XRef\")) {\n                    continue;\n                }\n            } catch (std::exception&) {\n                continue;\n            }\n            auto offset = entry.getOffset();\n            if (offset > max_offset) {\n                max_offset = offset;\n                setTrailer(oh.getDict());\n            }\n        }\n        if (max_offset > 0) {\n            try {\n                read_xref(max_offset);\n            } catch (std::exception&) {\n                throw damagedPDF(\n                    \"\", 0, \"error decoding candidate xref stream while recovering damaged file\");\n            }\n            QTC::TC(\"qpdf\", \"QPDF recover xref stream\");\n        }\n    }\n\n    if (!m->trailer.isInitialized()) {\n        // We could check the last encountered object to see if it was an xref stream.  If so, we\n        // could try to get the trailer from there.  This may make it possible to recover files with\n        // bad startxref pointers even when they have object streams.\n\n        throw damagedPDF(\"\", 0, \"unable to find trailer dictionary while recovering damaged file\");\n    }\n\n    // We could iterate through the objects looking for streams and try to find objects inside of\n    // them, but it's probably not worth the trouble.  Acrobat can't recover files with any errors\n    // in an xref stream, and this would be a real long shot anyway.  If we wanted to do anything\n    // that involved looking at stream contents, we'd also have to call initializeEncryption() here.\n    // It's safe to call it more than once.\n}",
        "file_path": "/src/qpdf/libqpdf/QPDF.cc",
        "crashing_line": "                read_xref(max_offset);",
        "crashing_line_number": 601
      },
      {
        "function_name": "parse",
        "function_body": "void\nQPDF::parse(char const* password)\n{\n    if (password) {\n        m->encp->provided_password = password;\n    }\n\n    // Find the header anywhere in the first 1024 bytes of the file.\n    PatternFinder hf(*this, &QPDF::findHeader);\n    if (!m->file->findFirst(\"%PDF-\", 0, 1024, hf)) {\n        QTC::TC(\"qpdf\", \"QPDF not a pdf file\");\n        warn(damagedPDF(\"\", 0, \"can't find PDF header\"));\n        // QPDFWriter writes files that usually require at least version 1.2 for /FlateDecode\n        m->pdf_version = \"1.2\";\n    }\n\n    // PDF spec says %%EOF must be found within the last 1024 bytes of/ the file.  We add an extra\n    // 30 characters to leave room for the startxref stuff.\n    m->file->seek(0, SEEK_END);\n    qpdf_offset_t end_offset = m->file->tell();\n    qpdf_offset_t start_offset = (end_offset > 1054 ? end_offset - 1054 : 0);\n    PatternFinder sf(*this, &QPDF::findStartxref);\n    qpdf_offset_t xref_offset = 0;\n    if (m->file->findLast(\"startxref\", start_offset, 0, sf)) {\n        xref_offset = QUtil::string_to_ll(readToken(m->file).getValue().c_str());\n    }\n\n    try {\n        if (xref_offset == 0) {\n            QTC::TC(\"qpdf\", \"QPDF can't find startxref\");\n            throw damagedPDF(\"\", 0, \"can't find startxref\");\n        }\n        try {\n            read_xref(xref_offset);\n        } catch (QPDFExc&) {\n            throw;\n        } catch (std::exception& e) {\n            throw damagedPDF(\"\", 0, std::string(\"error reading xref: \") + e.what());\n        }\n    } catch (QPDFExc& e) {\n        if (m->attempt_recovery) {\n            reconstruct_xref(e);\n            QTC::TC(\"qpdf\", \"QPDF reconstructed xref table\");\n        } else {\n            throw;\n        }\n    }\n\n    initializeEncryption();\n    m->parsed = true;\n}",
        "file_path": "/src/qpdf/libqpdf/QPDF.cc",
        "crashing_line": "            reconstruct_xref(e);",
        "crashing_line_number": 464
      },
      {
        "function_name": "processInputSource",
        "function_body": "void\nQPDF::processInputSource(std::shared_ptr<InputSource> source, char const* password)\n{\n    m->file = source;\n    parse(password);\n}",
        "file_path": "/src/qpdf/libqpdf/QPDF.cc",
        "crashing_line": "    parse(password);",
        "crashing_line_number": 274
      },
      {
        "function_name": "getQpdf",
        "function_body": "std::shared_ptr<QPDF>\nFuzzHelper::getQpdf()\n{\n    auto is =\n        std::shared_ptr<InputSource>(new BufferInputSource(\"fuzz input\", &this->input_buffer));\n    auto qpdf = QPDF::create();\n    qpdf->processInputSource(is);\n    return qpdf;\n}",
        "file_path": "/src/qpdf/fuzz/qpdf_fuzzer.cc",
        "crashing_line": "    qpdf->processInputSource(is);",
        "crashing_line_number": 59
      },
      {
        "function_name": "testWrite",
        "function_body": "void\nFuzzHelper::testWrite()\n{\n    // Write in various ways to exercise QPDFWriter\n\n    std::shared_ptr<QPDF> q;\n    std::shared_ptr<QPDFWriter> w;\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setDeterministicID(true);\n    w->setQDFMode(true);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setStaticID(true);\n    w->setLinearization(true);\n    w->setR6EncryptionParameters(\"u\", \"o\", true, true, true, true, true, true, qpdf_r3p_full, true);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setStaticID(true);\n    w->setObjectStreamMode(qpdf_o_disable);\n    w->setR3EncryptionParametersInsecure(\n        \"u\", \"o\", true, true, true, true, true, true, qpdf_r3p_full);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setDeterministicID(true);\n    w->setObjectStreamMode(qpdf_o_generate);\n    w->setLinearization(true);\n    doWrite(w);\n}",
        "file_path": "/src/qpdf/fuzz/qpdf_fuzzer.cc",
        "crashing_line": "    q = getQpdf();",
        "crashing_line_number": 92
      },
      {
        "function_name": "doChecks",
        "function_body": "void\nFuzzHelper::doChecks()\n{\n    // Get as much coverage as possible in parts of the library that\n    // might benefit from fuzzing.\n    testWrite();\n    testPages();\n    testOutlines();\n}",
        "file_path": "/src/qpdf/fuzz/qpdf_fuzzer.cc",
        "crashing_line": "    testWrite();",
        "crashing_line_number": 176
      },
      {
        "function_name": "run",
        "function_body": "void\nFuzzHelper::run()\n{\n    // The goal here is that you should be able to throw anything at\n    // libqpdf and it will respond without any memory errors and never\n    // do anything worse than throwing a QPDFExc or\n    // std::runtime_error. Throwing any other kind of exception,\n    // segfaulting, or having a memory error (when built with\n    // appropriate sanitizers) will all cause abnormal exit.\n    try {\n        doChecks();\n    } catch (QPDFExc const& e) {\n        std::cerr << \"QPDFExc: \" << e.what() << std::endl;\n    } catch (std::runtime_error const& e) {\n        std::cerr << \"runtime_error: \" << e.what() << std::endl;\n    }\n}",
        "file_path": "/src/qpdf/fuzz/qpdf_fuzzer.cc",
        "crashing_line": "        doChecks();",
        "crashing_line_number": 191
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static void\nxmlXIncludeFreeRef(xmlXIncludeRefPtr ref) {\n    if (ref == NULL)\n\treturn;\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Freeing ref\\n\");\n#endif\n    if (ref->doc != NULL) {\n#ifdef DEBUG_XINCLUDE\n\txmlGenericError(xmlGenericErrorContext, \"Freeing doc %s\\n\", ref->URI);\n#endif\n\txmlFreeDoc(ref->doc);\n    }\n    if (ref->URI != NULL)\n\txmlFree(ref->URI);\n    if (ref->fragment != NULL)\n\txmlFree(ref->fragment);\n    if (ref->xptr != NULL)\n\txmlXPathFreeObject(ref->xptr);\n    xmlFree(ref);\n}\nstatic int\nxmlXIncludeLoadDoc(xmlXIncludeCtxtPtr ctxt, const xmlChar *url, int nr) {\n    xmlDocPtr doc;\n    xmlURIPtr uri;\n    xmlChar *URL;\n    xmlChar *fragment = NULL;\n    int i = 0;\n#ifdef LIBXML_XPTR_ENABLED\n    int saveFlags;\n#endif\n\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Loading doc %s:%d\\n\", url, nr);\n#endif\n    /*\n     * Check the URL and remove any fragment identifier\n     */\n    uri = xmlParseURI((const char *)url);\n    if (uri == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_HREF_URI,\n\t\t       \"invalid value URI %s\\n\", url);\n\treturn(-1);\n    }\n    if (uri->fragment != NULL) {\n\tfragment = (xmlChar *) uri->fragment;\n\turi->fragment = NULL;\n    }\n    if ((ctxt->incTab != NULL) && (ctxt->incTab[nr] != NULL) &&\n        (ctxt->incTab[nr]->fragment != NULL)) {\n\tif (fragment != NULL) xmlFree(fragment);\n\tfragment = xmlStrdup(ctxt->incTab[nr]->fragment);\n    }\n    URL = xmlSaveUri(uri);\n    xmlFreeURI(uri);\n    if (URL == NULL) {\n        if (ctxt->incTab != NULL)\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t   XML_XINCLUDE_HREF_URI,\n\t\t\t   \"invalid value URI %s\\n\", url);\n\telse\n\t    xmlXIncludeErr(ctxt, NULL,\n\t\t\t   XML_XINCLUDE_HREF_URI,\n\t\t\t   \"invalid value URI %s\\n\", url);\n\tif (fragment != NULL)\n\t    xmlFree(fragment);\n\treturn(-1);\n    }\n\n    /*\n     * Handling of references to the local document are done\n     * directly through ctxt->doc.\n     */\n    if ((URL[0] == 0) || (URL[0] == '#') ||\n\t((ctxt->doc != NULL) && (xmlStrEqual(URL, ctxt->doc->URL)))) {\n\tdoc = NULL;\n        goto loaded;\n    }\n\n    /*\n     * Prevent reloading twice the document.\n     */\n    for (i = 0; i < ctxt->incNr; i++) {\n\tif ((xmlStrEqual(URL, ctxt->incTab[i]->URI)) &&\n\t    (ctxt->incTab[i]->doc != NULL)) {\n\t    doc = ctxt->incTab[i]->doc;\n#ifdef DEBUG_XINCLUDE\n\t    printf(\"Already loaded %s\\n\", URL);\n#endif\n\t    goto loaded;\n\t}\n    }\n\n    /*\n     * Load it.\n     */\n#ifdef DEBUG_XINCLUDE\n    printf(\"loading %s\\n\", URL);\n#endif\n#ifdef LIBXML_XPTR_ENABLED\n    /*\n     * If this is an XPointer evaluation, we want to assure that\n     * all entities have been resolved prior to processing the\n     * referenced document\n     */\n    saveFlags = ctxt->parseFlags;\n    if (fragment != NULL) {\t/* if this is an XPointer eval */\n\tctxt->parseFlags |= XML_PARSE_NOENT;\n    }\n#endif\n\n    doc = xmlXIncludeParseFile(ctxt, (const char *)URL);\n#ifdef LIBXML_XPTR_ENABLED\n    ctxt->parseFlags = saveFlags;\n#endif\n    if (doc == NULL) {\n\txmlFree(URL);\n\tif (fragment != NULL)\n\t    xmlFree(fragment);\n\treturn(-1);\n    }\n    ctxt->incTab[nr]->doc = doc;\n    /*\n     * It's possible that the requested URL has been mapped to a\n     * completely different location (e.g. through a catalog entry).\n     * To check for this, we compare the URL with that of the doc\n     * and change it if they disagree (bug 146988).\n     */\n   if (!xmlStrEqual(URL, doc->URL)) {\n       xmlFree(URL);\n       URL = xmlStrdup(doc->URL);\n   }\n    for (i = nr + 1; i < ctxt->incNr; i++) {\n\tif (xmlStrEqual(URL, ctxt->incTab[i]->URI)) {\n\t    ctxt->incTab[nr]->count++;\n#ifdef DEBUG_XINCLUDE\n\t    printf(\"Increasing %s count since reused\\n\", URL);\n#endif\n            break;\n\t}\n    }\n\n    /*\n     * Make sure we have all entities fixed up\n     */\n    xmlXIncludeMergeEntities(ctxt, ctxt->doc, doc);\n\n    /*\n     * We don't need the DTD anymore, free up space\n    if (doc->intSubset != NULL) {\n\txmlUnlinkNode((xmlNodePtr) doc->intSubset);\n\txmlFreeNode((xmlNodePtr) doc->intSubset);\n\tdoc->intSubset = NULL;\n    }\n    if (doc->extSubset != NULL) {\n\txmlUnlinkNode((xmlNodePtr) doc->extSubset);\n\txmlFreeNode((xmlNodePtr) doc->extSubset);\n\tdoc->extSubset = NULL;\n    }\n     */\n    xmlXIncludeRecurseDoc(ctxt, doc, URL);\n\nloaded:\n    if (fragment == NULL) {\n\t/*\n\t * Add the top children list as the replacement copy.\n\t */\n\tif (doc == NULL)\n\t{\n\t    /* Hopefully a DTD declaration won't be copied from\n\t     * the same document */\n\t    ctxt->incTab[nr]->inc = xmlCopyNodeList(ctxt->doc->children);\n\t} else {\n\t    ctxt->incTab[nr]->inc = xmlXIncludeCopyNodeList(ctxt, ctxt->doc,\n\t\t                                       doc, doc->children);\n\t}\n    }\n#ifdef LIBXML_XPTR_ENABLED\n    else {\n\t/*\n\t * Computes the XPointer expression and make a copy used\n\t * as the replacement copy.\n\t */\n\txmlXPathObjectPtr xptr;\n\txmlXPathContextPtr xptrctxt;\n\txmlNodeSetPtr set;\n\n\tif (doc == NULL) {\n\t    xptrctxt = xmlXPtrNewContext(ctxt->doc, ctxt->incTab[nr]->ref,\n\t\t                         NULL);\n\t} else {\n\t    xptrctxt = xmlXPtrNewContext(doc, NULL, NULL);\n\t}\n\tif (xptrctxt == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_XPTR_FAILED,\n\t\t\t   \"could not create XPointer context\\n\", NULL);\n\t    xmlFree(URL);\n\t    xmlFree(fragment);\n\t    return(-1);\n\t}\n\txptr = xmlXPtrEval(fragment, xptrctxt);\n\tif (xptr == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_XPTR_FAILED,\n\t\t\t   \"XPointer evaluation failed: #%s\\n\",\n\t\t\t   fragment);\n\t    xmlXPathFreeContext(xptrctxt);\n\t    xmlFree(URL);\n\t    xmlFree(fragment);\n\t    return(-1);\n\t}\n\tswitch (xptr->type) {\n\t    case XPATH_UNDEFINED:\n\t    case XPATH_BOOLEAN:\n\t    case XPATH_NUMBER:\n\t    case XPATH_STRING:\n#ifdef LIBXML_XPTR_LOCS_ENABLED\n\t    case XPATH_POINT:\n#endif\n\t    case XPATH_USERS:\n\t    case XPATH_XSLT_TREE:\n\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t       \"XPointer is not a range: #%s\\n\",\n\t\t\t       fragment);\n                xmlXPathFreeObject(xptr);\n\t\txmlXPathFreeContext(xptrctxt);\n\t\txmlFree(URL);\n\t\txmlFree(fragment);\n\t\treturn(-1);\n\t    case XPATH_NODESET:\n\t        if ((xptr->nodesetval == NULL) ||\n\t\t    (xptr->nodesetval->nodeNr <= 0)) {\n                    xmlXPathFreeObject(xptr);\n\t\t    xmlXPathFreeContext(xptrctxt);\n\t\t    xmlFree(URL);\n\t\t    xmlFree(fragment);\n\t\t    return(-1);\n\t\t}\n\n#ifdef LIBXML_XPTR_LOCS_ENABLED\n\t    case XPATH_RANGE:\n\t    case XPATH_LOCATIONSET:\n\t\tbreak;\n#endif\n\t}\n\tset = xptr->nodesetval;\n\tif (set != NULL) {\n\t    for (i = 0;i < set->nodeNr;i++) {\n\t\tif (set->nodeTab[i] == NULL)\n\t\t    continue;\n\t\tswitch (set->nodeTab[i]->type) {\n\t\t    case XML_ELEMENT_NODE:\n\t\t    case XML_TEXT_NODE:\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t    case XML_ENTITY_NODE:\n\t\t    case XML_PI_NODE:\n\t\t    case XML_COMMENT_NODE:\n\t\t    case XML_DOCUMENT_NODE:\n\t\t    case XML_HTML_DOCUMENT_NODE:\n\t\t\tcontinue;\n\n\t\t    case XML_ATTRIBUTE_NODE:\n\t\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t\t       \"XPointer selects an attribute: #%s\\n\",\n\t\t\t\t       fragment);\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tcontinue;\n\t\t    case XML_NAMESPACE_DECL:\n\t\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t\t       \"XPointer selects a namespace: #%s\\n\",\n\t\t\t\t       fragment);\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tcontinue;\n\t\t    case XML_DOCUMENT_TYPE_NODE:\n\t\t    case XML_DOCUMENT_FRAG_NODE:\n\t\t    case XML_NOTATION_NODE:\n\t\t    case XML_DTD_NODE:\n\t\t    case XML_ELEMENT_DECL:\n\t\t    case XML_ATTRIBUTE_DECL:\n\t\t    case XML_ENTITY_DECL:\n\t\t    case XML_XINCLUDE_START:\n\t\t    case XML_XINCLUDE_END:\n\t\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t\t   \"XPointer selects unexpected nodes: #%s\\n\",\n\t\t\t\t       fragment);\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tcontinue; /* for */\n\t\t}\n\t    }\n\t}\n\tif (doc == NULL) {\n\t    ctxt->incTab[nr]->xptr = xptr;\n\t    ctxt->incTab[nr]->inc = NULL;\n\t} else {\n\t    ctxt->incTab[nr]->inc =\n\t\txmlXIncludeCopyXPointer(ctxt, ctxt->doc, doc, xptr);\n\t    xmlXPathFreeObject(xptr);\n\t}\n\txmlXPathFreeContext(xptrctxt);\n\txmlFree(fragment);\n    }\n#endif\n\n    /*\n     * Do the xml:base fixup if needed\n     */\n    if ((doc != NULL) && (URL != NULL) &&\n        (!(ctxt->parseFlags & XML_PARSE_NOBASEFIX)) &&\n\t(!(doc->parseFlags & XML_PARSE_NOBASEFIX))) {\n\txmlNodePtr node;\n\txmlChar *base;\n\txmlChar *curBase;\n\n\t/*\n\t * The base is only adjusted if \"necessary\", i.e. if the xinclude node\n\t * has a base specified, or the URL is relative\n\t */\n\tbase = xmlGetNsProp(ctxt->incTab[nr]->ref, BAD_CAST \"base\",\n\t\t\tXML_XML_NAMESPACE);\n\tif (base == NULL) {\n\t    /*\n\t     * No xml:base on the xinclude node, so we check whether the\n\t     * URI base is different than (relative to) the context base\n\t     */\n\t    curBase = xmlBuildRelativeURI(URL, ctxt->base);\n\t    if (curBase == NULL) {\t/* Error return */\n\t        xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_HREF_URI,\n\t\t       \"trying to build relative URI from %s\\n\", URL);\n\t    } else {\n\t\t/* If the URI doesn't contain a slash, it's not relative */\n\t        if (!xmlStrchr(curBase, '/'))\n\t\t    xmlFree(curBase);\n\t\telse\n\t\t    base = curBase;\n\t    }\n\t}\n\tif (base != NULL) {\t/* Adjustment may be needed */\n\t    node = ctxt->incTab[nr]->inc;\n\t    while (node != NULL) {\n\t\t/* Only work on element nodes */\n\t\tif (node->type == XML_ELEMENT_NODE) {\n\t\t    curBase = xmlNodeGetBase(node->doc, node);\n\t\t    /* If no current base, set it */\n\t\t    if (curBase == NULL) {\n\t\t\txmlNodeSetBase(node, base);\n\t\t    } else {\n\t\t\t/*\n\t\t\t * If the current base is the same as the\n\t\t\t * URL of the document, then reset it to be\n\t\t\t * the specified xml:base or the relative URI\n\t\t\t */\n\t\t\tif (xmlStrEqual(curBase, node->doc->URL)) {\n\t\t\t    xmlNodeSetBase(node, base);\n\t\t\t} else {\n\t\t\t    /*\n\t\t\t     * If the element already has an xml:base\n\t\t\t     * set, then relativise it if necessary\n\t\t\t     */\n\t\t\t    xmlChar *xmlBase;\n\t\t\t    xmlBase = xmlGetNsProp(node,\n\t\t\t\t\t    BAD_CAST \"base\",\n\t\t\t\t\t    XML_XML_NAMESPACE);\n\t\t\t    if (xmlBase != NULL) {\n\t\t\t\txmlChar *relBase;\n\t\t\t\trelBase = xmlBuildURI(xmlBase, base);\n\t\t\t\tif (relBase == NULL) { /* error */\n\t\t\t\t    xmlXIncludeErr(ctxt,\n\t\t\t\t\t\tctxt->incTab[nr]->ref,\n\t\t\t\t\t\tXML_XINCLUDE_HREF_URI,\n\t\t\t\t\t\"trying to rebuild base from %s\\n\",\n\t\t\t\t\t\txmlBase);\n\t\t\t\t} else {\n\t\t\t\t    xmlNodeSetBase(node, relBase);\n\t\t\t\t    xmlFree(relBase);\n\t\t\t\t}\n\t\t\t\txmlFree(xmlBase);\n\t\t\t    }\n\t\t\t}\n\t\t\txmlFree(curBase);\n\t\t    }\n\t\t}\n\t        node = node->next;\n\t    }\n\t    xmlFree(base);\n\t}\n    }\n    if ((nr < ctxt->incNr) && (ctxt->incTab[nr]->doc != NULL) &&\n\t(ctxt->incTab[nr]->count <= 1)) {\n#ifdef DEBUG_XINCLUDE\n        printf(\"freeing %s\\n\", ctxt->incTab[nr]->doc->URL);\n#endif\n\txmlFreeDoc(ctxt->incTab[nr]->doc);\n\tctxt->incTab[nr]->doc = NULL;\n    }\n    xmlFree(URL);\n    return(0);\n}\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * TODO: The phases must run separately for recursive inclusions.\n     *\n     * - Phase 1 should start with top-level XInclude nodes, load documents,\n     *   execute XPointer expressions, then process only the result nodes\n     *   (not whole document, see bug #324081) and only for phase 1\n     *   recursively. We will need a backreference from xmlNodes to\n     *   xmlIncludeRefs to detect references that were already visited.\n     *   This can also be used for proper cycle detection, see bug #344240.\n     *\n     * - Phase 2 should visit all top-level XInclude nodes and expand\n     *   possible subreferences in the replacement recursively.\n     *\n     * - Phase 3 should finally replace the top-level XInclude nodes.\n     *   It could also be run together with phase 2.\n     */\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   ((cur->type == XML_DOCUMENT_NODE) ||\n                    (cur->type == XML_ELEMENT_NODE))) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n            (ctxt->incTab[i]->xptr != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}\n",
    "target": 1,
    "idx": 1052554,
    "stack_trace": [
      {
        "function_name": "xmlXIncludeCopyXPointer",
        "function_body": "static xmlNodePtr\nxmlXIncludeCopyXPointer(xmlXIncludeCtxtPtr ctxt, xmlDocPtr target,\n\t                xmlDocPtr source, xmlXPathObjectPtr obj) {\n    xmlNodePtr list = NULL, last = NULL;\n    int i;\n\n    if (source == NULL)\n\tsource = ctxt->doc;\n    if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||\n\t(obj == NULL))\n\treturn(NULL);\n    switch (obj->type) {\n        case XPATH_NODESET: {\n\t    xmlNodeSetPtr set = obj->nodesetval;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->nodeNr;i++) {\n\t\tif (set->nodeTab[i] == NULL)\n\t\t    continue;\n\t\tswitch (set->nodeTab[i]->type) {\n\t\t    case XML_TEXT_NODE:\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t    case XML_ELEMENT_NODE:\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t    case XML_ENTITY_NODE:\n\t\t    case XML_PI_NODE:\n\t\t    case XML_COMMENT_NODE:\n\t\t    case XML_DOCUMENT_NODE:\n\t\t    case XML_HTML_DOCUMENT_NODE:\n\t\t    case XML_XINCLUDE_END:\n\t\t\tbreak;\n\t\t    case XML_XINCLUDE_START: {\n\t                xmlNodePtr tmp, cur = set->nodeTab[i];\n\n\t\t\tcur = cur->next;\n\t\t\twhile (cur != NULL) {\n\t\t\t    switch(cur->type) {\n\t\t\t\tcase XML_TEXT_NODE:\n\t\t\t\tcase XML_CDATA_SECTION_NODE:\n\t\t\t\tcase XML_ELEMENT_NODE:\n\t\t\t\tcase XML_ENTITY_REF_NODE:\n\t\t\t\tcase XML_ENTITY_NODE:\n\t\t\t\tcase XML_PI_NODE:\n\t\t\t\tcase XML_COMMENT_NODE:\n\t\t\t\t    tmp = xmlXIncludeCopyNode(ctxt, target,\n\t\t\t\t\t\t\t      source, cur);\n\t\t\t\t    if (last == NULL) {\n\t\t\t\t\tlist = last = tmp;\n\t\t\t\t    } else {\n\t\t\t\t\tlast = xmlAddNextSibling(last, tmp);\n\t\t\t\t    }\n\t\t\t\t    cur = cur->next;\n\t\t\t\t    continue;\n\t\t\t\tdefault:\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t    }\n\t\t    case XML_ATTRIBUTE_NODE:\n\t\t    case XML_NAMESPACE_DECL:\n\t\t    case XML_DOCUMENT_TYPE_NODE:\n\t\t    case XML_DOCUMENT_FRAG_NODE:\n\t\t    case XML_NOTATION_NODE:\n\t\t    case XML_DTD_NODE:\n\t\t    case XML_ELEMENT_DECL:\n\t\t    case XML_ATTRIBUTE_DECL:\n\t\t    case XML_ENTITY_DECL:\n\t\t\tcontinue; /* for */\n\t\t}\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t                              set->nodeTab[i]);\n\t\telse {\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t\t                set->nodeTab[i]));\n\t\t    if (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n#ifdef LIBXML_XPTR_LOCS_ENABLED\n\tcase XPATH_LOCATIONSET: {\n\t    xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->locNr;i++) {\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t                                  set->locTab[i]);\n\t\telse\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t\t                    set->locTab[i]));\n\t\tif (last != NULL) {\n\t\t    while (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tcase XPATH_RANGE:\n\t    return(xmlXIncludeCopyRange(ctxt, target, source, obj));\n\tcase XPATH_POINT:\n\t    /* points are ignored in XInclude */\n\t    break;\n#endif\n\tdefault:\n\t    break;\n    }\n    return(list);\n}",
        "file_path": "/src/libxml2/xinclude.c",
        "crashing_line": "\t\t    case XML_ELEMENT_NODE:",
        "crashing_line_number": 1162
      },
      {
        "function_name": "xmlXIncludeIncludeNode",
        "function_body": "static int\nxmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur, end, list, tmp;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n\n    list = ctxt->incTab[nr]->inc;\n    ctxt->incTab[nr]->inc = NULL;\n    ctxt->incTab[nr]->emptyFb = 0;\n\n    /*\n     * Check against the risk of generating a multi-rooted document\n     */\n    if ((cur->parent != NULL) &&\n\t(cur->parent->type != XML_ELEMENT_NODE)) {\n\tint nb_elem = 0;\n\n\ttmp = list;\n\twhile (tmp != NULL) {\n\t    if (tmp->type == XML_ELEMENT_NODE)\n\t\tnb_elem++;\n\t    tmp = tmp->next;\n\t}\n\tif (nb_elem > 1) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_MULTIPLE_ROOT,\n\t\t       \"XInclude error: would result in multiple root nodes\\n\",\n\t\t\t   NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    end = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(cur, end);\n\t}\n        /*\n         * FIXME: xmlUnlinkNode doesn't coalesce text nodes.\n         */\n\txmlUnlinkNode(cur);\n\txmlFreeNode(cur);\n    } else {\n        xmlNodePtr child, next;\n\n\t/*\n\t * Change the current node as an XInclude start one, and add an\n\t * XInclude end one\n\t */\n        if (ctxt->incTab[nr]->fallback)\n            xmlUnsetProp(cur, BAD_CAST \"href\");\n\tcur->type = XML_XINCLUDE_START;\n        /* Remove fallback children */\n        for (child = cur->children; child != NULL; child = next) {\n            next = child->next;\n            xmlUnlinkNode(child);\n            xmlFreeNode(child);\n        }\n\tend = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);\n\tif (end == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_BUILD_FAILED,\n\t\t\t   \"failed to build node\\n\", NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n\tend->type = XML_XINCLUDE_END;\n\txmlAddNextSibling(cur, end);\n\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    cur = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(end, cur);\n\t}\n    }\n\n\n    return(0);\n}",
        "file_path": "/src/libxml2/xinclude.c",
        "crashing_line": "",
        "crashing_line_number": 2231
      },
      {
        "function_name": "xmlXIncludeDoProcess",
        "function_body": "static int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * TODO: The phases must run separately for recursive inclusions.\n     *\n     * - Phase 1 should start with top-level XInclude nodes, load documents,\n     *   execute XPointer expressions, then process only the result nodes\n     *   (not whole document, see bug #324081) and only for phase 1\n     *   recursively. We will need a backreference from xmlNodes to\n     *   xmlIncludeRefs to detect references that were already visited.\n     *   This can also be used for proper cycle detection, see bug #344240.\n     *\n     * - Phase 2 should visit all top-level XInclude nodes and expand\n     *   possible subreferences in the replacement recursively.\n     *\n     * - Phase 3 should finally replace the top-level XInclude nodes.\n     *   It could also be run together with phase 2.\n     */\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   ((cur->type == XML_DOCUMENT_NODE) ||\n                    (cur->type == XML_ELEMENT_NODE))) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}",
        "file_path": "/src/libxml2/xinclude.c",
        "crashing_line": "",
        "crashing_line_number": 2506
      },
      {
        "function_name": "xmlXIncludeProcessTreeFlagsData",
        "function_body": "int\nxmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {\n    xmlXIncludeCtxtPtr ctxt;\n    int ret = 0;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n        (tree->doc == NULL))\n        return(-1);\n\n    ctxt = xmlXIncludeNewContext(tree->doc);\n    if (ctxt == NULL)\n        return(-1);\n    ctxt->_private = data;\n    ctxt->base = xmlStrdup((xmlChar *)tree->doc->URL);\n    xmlXIncludeSetFlags(ctxt, flags);\n    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree, 0);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n        ret = -1;\n\n    xmlXIncludeFreeContext(ctxt);\n    return(ret);\n}",
        "file_path": "/src/libxml2/xinclude.c",
        "crashing_line": "",
        "crashing_line_number": 2559
      },
      {
        "function_name": "xmlXIncludeProcessFlagsData",
        "function_body": "int\nxmlXIncludeProcessFlagsData(xmlDocPtr doc, int flags, void *data) {\n    xmlNodePtr tree;\n\n    if (doc == NULL)\n\treturn(-1);\n    tree = xmlDocGetRootElement(doc);\n    if (tree == NULL)\n\treturn(-1);\n    return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));\n}",
        "file_path": "/src/libxml2/xinclude.c",
        "crashing_line": "",
        "crashing_line_number": 2588
      },
      {
        "function_name": "xmlXIncludeProcessFlags",
        "function_body": "int\nxmlXIncludeProcessFlags(xmlDocPtr doc, int flags) {\n    return xmlXIncludeProcessFlagsData(doc, flags, NULL);\n}",
        "file_path": "/src/libxml2/xinclude.c",
        "crashing_line": "",
        "crashing_line_number": 2603
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "ATTRIBUTE_MALLOC\nBITCODE_TV\nbit_read_TV (Bit_Chain *restrict dat)\n{\n  unsigned int i;\n  unsigned int length;\n  unsigned char *chain;\n\n  CHK_OVERFLOW_PLUS (1,__FUNCTION__,NULL)\n  length = bit_read_BS (dat);\n  CHK_OVERFLOW_PLUS (length,__FUNCTION__,NULL)\n  chain = (unsigned char *)malloc (length + 1);\n  if (!chain)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"Out of memory\");\n      return NULL;\n    }\n  for (i = 0; i < length; i++)\n    chain[i] = bit_read_RC (dat);\n  // check if the string is already zero-terminated or not.\n  // only observed >=r2004 as writer app\n  if (length > 0 && dat->from_version > R_2000 && chain[length - 1] != '\\0')\n    LOG_HANDLE (\"TV-not-ZERO %u\\n \", length)\n  else if (length > 0 && dat->from_version <= R_2000 && chain[length - 1] == '\\0')\n    LOG_HANDLE (\"TV-ZERO %u\\n\", length)\n  // normally not needed, as the DWG since r2004 itself contains the ending \\0 as last char\n  chain[i] = '\\0';\n  return (char *)chain;\n}\nvoid\nbit_write_TV (Bit_Chain *restrict dat, BITCODE_TV restrict chain)\n{\n  int i;\n  int length = (chain && *chain) ? strlen ((const char *)chain) : 0;\n  if (dat->version <= R_2000 && length)\n    length++;\n  bit_write_BS (dat, length);\n  for (i = 0; i < length; i++)\n    bit_write_RC (dat, (unsigned char)chain[i]);\n}\nstatic int ishex (int c)\n{\n  return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')\n          || (c >= 'A' && c <= 'F'));\n}\nEXPORT void\ndwg_free_object (Dwg_Object *obj)\n{\n  int error = 0;\n  long unsigned int j;\n  Dwg_Data *dwg;\n  Bit_Chain *dat = &pdat;\n\n  if (obj && obj->parent)\n    {\n      dwg = obj->parent;\n      dat->version = dwg->header.version;\n      dat->from_version = dwg->header.from_version;\n    }\n  else\n    return;\n  if (obj->type == DWG_TYPE_FREED || obj->tio.object == NULL)\n    return;\n\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      dwg_free_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      dwg_free_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      dwg_free_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      dwg_free_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      dwg_free_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      dwg_free_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      dwg_free_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      dwg_free_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      dwg_free_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      dwg_free_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      dwg_free_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      dwg_free_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      dwg_free_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      dwg_free_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      dwg_free_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      dwg_free_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      dwg_free_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      dwg_free_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      dwg_free_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      dwg_free_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      dwg_free_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      dwg_free_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      dwg_free_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      dwg_free_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      dwg_free_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      dwg_free_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      dwg_free__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      dwg_free_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      dwg_free_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      dwg_free_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      dwg_free_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      dwg_free_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      dwg_free_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      dwg_free_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      dwg_free_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      dwg_free_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      dwg_free__3DSOLID (dat, obj);\n      break; /* Check the type of the object */\n    case DWG_TYPE_BODY:\n      dwg_free_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      dwg_free_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      dwg_free_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      dwg_free_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      dwg_free_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      dwg_free_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      dwg_free_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      dwg_free_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      dwg_free_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      dwg_free_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      dwg_free_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      dwg_free_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      dwg_free_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      dwg_free_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      dwg_free_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      dwg_free_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      dwg_free_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      dwg_free_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      dwg_free_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      dwg_free_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      dwg_free_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      dwg_free_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      dwg_free_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      dwg_free_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      dwg_free_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      dwg_free_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VX_CONTROL:\n      dwg_free_VX_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VX_TABLE_RECORD:\n      dwg_free_VX_TABLE_RECORD (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      dwg_free_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      dwg_free_MLINESTYLE (dat, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      dwg_free_OLE2FRAME (dat, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      dwg_free_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      dwg_free_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      dwg_free_LWPOLYLINE (dat, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      dwg_free_HATCH (dat, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      dwg_free_XRECORD (dat, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      dwg_free_PLACEHOLDER (dat, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      dwg_free_OLEFRAME (dat, obj);\n      break;\n#ifdef DEBUG_VBA_PROJECT\n    case DWG_TYPE_VBA_PROJECT:\n      dwg_free_VBA_PROJECT (dat, obj);\n      break;\n#endif\n    case DWG_TYPE_LAYOUT:\n      dwg_free_LAYOUT (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      dwg_free_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      dwg_free_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type\n          && obj->fixedtype == DWG_TYPE_LAYOUT)\n        {\n          SINCE (R_13)\n          {\n            dwg_free_LAYOUT (dat, obj); // XXX avoid double-free, esp. in eed\n          }\n        }\n      else if ((error = dwg_free_variable_type (obj->parent, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)\n              dwg_free_UNKNOWN_ENT (dat, obj);\n          else if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)\n              dwg_free_UNKNOWN_OBJ (dat, obj);\n        }\n    }\n  /* With indxf the dxfname is dynamic, just the name is const */\n  if (dwg->opts & DWG_OPTS_IN)\n    FREE_IF (obj->dxfname);\n  /* With injson even the name is dynamic */\n  if (dwg->opts & DWG_OPTS_INJSON)\n    FREE_IF (obj->name);\n  obj->type = DWG_TYPE_FREED;\n}\n",
    "target": 1,
    "idx": 1034377,
    "stack_trace": [
      {
        "function_name": "dwg_free_object",
        "function_body": "EXPORT void\ndwg_free_object (Dwg_Object *obj)\n{\n  int error = 0;\n  long unsigned int j;\n  Dwg_Data *dwg;\n  Bit_Chain *dat = &pdat;\n\n  if (obj && obj->parent)\n    {\n      dwg = obj->parent;\n      dat->version = dwg->header.version;\n      dat->from_version = dwg->header.from_version;\n    }\n  else\n    return;\n  if (obj->type == DWG_TYPE_FREED || obj->tio.object == NULL)\n    return;\n\n  PRE (R_13) {\n    free_preR13_object (obj);\n    return;\n  }\n\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      dwg_free_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      dwg_free_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      dwg_free_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      dwg_free_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      dwg_free_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      dwg_free_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      dwg_free_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      dwg_free_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      dwg_free_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      dwg_free_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      dwg_free_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      dwg_free_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      dwg_free_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      dwg_free_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      dwg_free_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      dwg_free_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      dwg_free_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      dwg_free_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      dwg_free_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      dwg_free_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      dwg_free_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      dwg_free_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      dwg_free_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      dwg_free_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      dwg_free_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      dwg_free_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      dwg_free__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      dwg_free_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      dwg_free_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      dwg_free_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      dwg_free_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      dwg_free_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      dwg_free_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      dwg_free_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      dwg_free_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      dwg_free_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      dwg_free__3DSOLID (dat, obj);\n      break; /* Check the type of the object */\n    case DWG_TYPE_BODY:\n      dwg_free_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      dwg_free_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      dwg_free_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      dwg_free_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      dwg_free_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      dwg_free_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      dwg_free_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      dwg_free_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      dwg_free_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      dwg_free_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      dwg_free_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      dwg_free_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      dwg_free_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      dwg_free_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      dwg_free_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      dwg_free_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      dwg_free_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      dwg_free_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      dwg_free_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      dwg_free_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      dwg_free_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      dwg_free_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      dwg_free_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      dwg_free_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      dwg_free_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      dwg_free_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VX_CONTROL:\n      dwg_free_VX_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VX_TABLE_RECORD:\n      dwg_free_VX_TABLE_RECORD (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      dwg_free_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      dwg_free_MLINESTYLE (dat, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      dwg_free_OLE2FRAME (dat, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      dwg_free_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      dwg_free_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      dwg_free_LWPOLYLINE (dat, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      dwg_free_HATCH (dat, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      dwg_free_XRECORD (dat, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      dwg_free_PLACEHOLDER (dat, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      dwg_free_OLEFRAME (dat, obj);\n      break;\n#ifdef DEBUG_VBA_PROJECT\n    case DWG_TYPE_VBA_PROJECT:\n      dwg_free_VBA_PROJECT (dat, obj);\n      break;\n#endif\n    case DWG_TYPE_LAYOUT:\n      dwg_free_LAYOUT (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      dwg_free_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      dwg_free_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type\n          && obj->fixedtype == DWG_TYPE_LAYOUT)\n        {\n          SINCE (R_13)\n          {\n            dwg_free_LAYOUT (dat, obj); // XXX avoid double-free, esp. in eed\n          }\n        }\n      else if ((error = dwg_free_variable_type (obj->parent, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)\n              dwg_free_UNKNOWN_ENT (dat, obj);\n          else if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)\n              dwg_free_UNKNOWN_OBJ (dat, obj);\n        }\n    }\n  /* With indxf the dxfname is dynamic, just the name is const */\n  if (dwg->opts & DWG_OPTS_IN)\n    FREE_IF (obj->dxfname);\n  /* With injson even the name is dynamic */\n  if (dwg->opts & DWG_OPTS_INJSON)\n    FREE_IF (obj->name);\n  obj->type = DWG_TYPE_FREED;\n}",
        "file_path": "/src/libredwg/src/free.c",
        "crashing_line": "    case DWG_TYPE_DIMENSION_DIAMETER:",
        "crashing_line_number": 863
      },
      {
        "function_name": "dwg_free",
        "function_body": "void\ndwg_free (Dwg_Data *dwg)\n{\n  BITCODE_BL i;\n  if (dwg)\n    {\n      pdat.version = dwg->header.version;\n      pdat.from_version = dwg->header.from_version;\n      if (dwg->opts)\n        {\n          loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n          pdat.opts = dwg->opts;\n        }\n#ifdef USE_TRACING\n      /* Before starting, set the logging level, but only do so once.  */\n      if (!env_var_checked_p)\n        {\n          char *probe = getenv (\"LIBREDWG_TRACE\");\n          if (probe)\n            loglevel = atoi (probe);\n          env_var_checked_p = 1;\n        }\n#endif /* USE_TRACING */\n      LOG_INFO (\"\\n============\\ndwg_free\\n\")\n      // copied table fields have duplicate pointers, but are freed only once\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (!dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      dwg_free_header_vars (dwg);\n      dwg_free_summaryinfo (dwg);\n      FREE_IF (dwg->thumbnail.chain);\n      if (dwg->header.section_infohdr.num_desc)\n        {\n          for (i = 0; i < dwg->header.section_infohdr.num_desc; ++i)\n            FREE_IF (dwg->header.section_info[i].sections);\n          FREE_IF (dwg->header.section_info);\n        }\n      dwg_free_appinfo (dwg);\n      dwg_free_filedeplist (dwg);\n      dwg_free_security (dwg);\n      dwg_free_acds (dwg);\n\n      FREE_IF (dwg->vbaproject.unknown_bits);\n      FREE_IF (dwg->revhistory.histories);\n      FREE_IF (dwg->appinfohistory.unknown_bits);\n      //FREE_IF (dwg->objfreespace...);\n      FREE_IF (dwg->Template.description);\n      FREE_IF (dwg->header.section);\n      for (i = 0; i < dwg->second_header.num_handlers; i++)\n        FREE_IF (dwg->second_header.handlers[i].data);\n      // auxheader has no strings\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      if (dwg->num_classes && dwg->dwg_class)\n        {\n          for (i = 0; i < dwg->num_classes; ++i)\n            {\n              FREE_IF (dwg->dwg_class[i].appname);\n              FREE_IF (dwg->dwg_class[i].cppname);\n              FREE_IF (dwg->dwg_class[i].dxfname);\n              if (dwg->header.from_version >= R_2007)\n                FREE_IF (dwg->dwg_class[i].dxfname_u);\n            }\n        }\n      FREE_IF (dwg->dwg_class);\n      if (dwg->object_ref)\n        {\n          LOG_HANDLE (\"free %d global refs\\n\", dwg->num_object_refs)\n          for (i = 0; i < dwg->num_object_refs; ++i)\n            {\n              //LOG_HANDLE (\"free ref %d\\n\", i)\n              FREE_IF (dwg->object_ref[i]);\n            }\n        }\n      FREE_IF (dwg->object_ref);\n      for (i = 0; i < dwg->num_acis_sab_hdl; ++i)\n        {\n          FREE_IF (dwg->acis_sab_hdl[i]);\n        }\n      FREE_IF (dwg->acis_sab_hdl);\n      FREE_IF (dwg->object);\n      if (dwg->object_map)\n        hash_free (dwg->object_map);\n      dwg->num_objects = dwg->num_classes = dwg->num_object_refs = 0;\n#undef FREE_IF\n    }\n}",
        "file_path": "/src/libredwg/src/free.c",
        "crashing_line": "",
        "crashing_line_number": 1266
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "Array::Array(Object& prototype)\n    : Object(prototype)\n{\n    auto& vm = this->vm();\n    define_native_property(vm.names.length, length_getter, length_setter, Attribute::Writable);\n}\nArray::~Array()\n{\n}\nArrayPrototype::ArrayPrototype(GlobalObject& global_object)\n    : Object(*global_object.object_prototype())\n{\n}\nvoid ArrayPrototype::initialize(GlobalObject& global_object)\n{\n    auto& vm = this->vm();\n    Object::initialize(global_object);\n    u8 attr = Attribute::Writable | Attribute::Configurable;\n\n    define_native_function(vm.names.filter, filter, 1, attr);\n    define_native_function(vm.names.forEach, for_each, 1, attr);\n    define_native_function(vm.names.map, map, 1, attr);\n    define_native_function(vm.names.pop, pop, 0, attr);\n    define_native_function(vm.names.push, push, 1, attr);\n    define_native_function(vm.names.shift, shift, 0, attr);\n    define_native_function(vm.names.toString, to_string, 0, attr);\n    define_native_function(vm.names.toLocaleString, to_locale_string, 0, attr);\n    define_native_function(vm.names.unshift, unshift, 1, attr);\n    define_native_function(vm.names.join, join, 1, attr);\n    define_native_function(vm.names.concat, concat, 1, attr);\n    define_native_function(vm.names.slice, slice, 2, attr);\n    define_native_function(vm.names.indexOf, index_of, 1, attr);\n    define_native_function(vm.names.reduce, reduce, 1, attr);\n    define_native_function(vm.names.reduceRight, reduce_right, 1, attr);\n    define_native_function(vm.names.reverse, reverse, 0, attr);\n    define_native_function(vm.names.sort, sort, 1, attr);\n    define_native_function(vm.names.lastIndexOf, last_index_of, 1, attr);\n    define_native_function(vm.names.includes, includes, 1, attr);\n    define_native_function(vm.names.find, find, 1, attr);\n    define_native_function(vm.names.findIndex, find_index, 1, attr);\n    define_native_function(vm.names.some, some, 1, attr);\n    define_native_function(vm.names.every, every, 1, attr);\n    define_native_function(vm.names.splice, splice, 2, attr);\n    define_native_function(vm.names.fill, fill, 1, attr);\n    define_native_function(vm.names.values, values, 0, attr);\n    define_native_function(vm.names.flat, flat, 0, attr);\n    define_property(vm.names.length, Value(0), Attribute::Configurable);\n\n    // Use define_property here instead of define_native_function so that\n    // Object.is(Array.prototype[Symbol.iterator], Array.prototype.values)\n    // evaluates to true\n    define_property(vm.well_known_symbol_iterator(), get(vm.names.values), attr);\n}\n",
    "target": 1,
    "idx": 1030921,
    "stack_trace": [
      {
        "function_name": "operator->",
        "function_body": "",
        "file_path": "/src/serenity/Meta/Lagom/build/../../../AK/NonnullOwnPtr.h",
        "crashing_line": "",
        "crashing_line_number": 125
      },
      {
        "function_name": "array_like_size",
        "function_body": "    size_t array_like_size() const { return m_storage->array_like_size(); }",
        "file_path": "/src/serenity/Meta/Lagom/build/../../../Userland/Libraries/LibJS/Runtime/IndexedProperties.h",
        "crashing_line": "    size_t array_like_size() const { return m_storage->array_like_size(); }",
        "crashing_line_number": 165
      },
      {
        "function_name": "append",
        "function_body": "    void append(Value value, PropertyAttributes attributes = default_attributes) { put(nullptr, array_like_size(), value, attributes, false); }",
        "file_path": "/src/serenity/Meta/Lagom/build/../../../Userland/Libraries/LibJS/Runtime/IndexedProperties.h",
        "crashing_line": "    void append(Value value, PropertyAttributes attributes = default_attributes) { put(nullptr, array_like_size(), value, attributes, false); }",
        "crashing_line_number": 158
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 1913
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 573
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 570
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 133
      },
      {
        "function_name": "execute_statement",
        "function_body": "Value Interpreter::execute_statement(GlobalObject& global_object, const Statement& statement, ScopeType scope_type)\n{\n    if (!is<ScopeNode>(statement))\n        return statement.execute(*this, global_object);\n\n    auto& block = static_cast<const ScopeNode&>(statement);\n    enter_scope(block, scope_type, global_object);\n\n    if (block.children().is_empty())\n        vm().set_last_value({}, js_undefined());\n\n    for (auto& node : block.children()) {\n        vm().set_last_value({}, node.execute(*this, global_object));\n        if (vm().should_unwind()) {\n            if (!block.label().is_null() && vm().should_unwind_until(ScopeType::Breakable, block.label()))\n                vm().stop_unwind();\n            break;\n        }\n    }\n\n    bool did_return = vm().unwind_until() == ScopeType::Function;\n\n    if (vm().unwind_until() == scope_type)\n        vm().unwind(ScopeType::None);\n\n    exit_scope(block);\n\n    return did_return ? vm().last_value() : js_undefined();\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/Interpreter.cpp",
        "crashing_line": "        vm().set_last_value({}, node.execute(*this, global_object));",
        "crashing_line_number": 168
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    interpreter.enter_node(*this);\n    ScopeGuard exit_node { [&] { interpreter.exit_node(*this); } };\n\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "    return interpreter.execute_statement(global_object, *this, ScopeType::Block);",
        "crashing_line_number": 109
      },
      {
        "function_name": "run",
        "function_body": "Value Interpreter::run(GlobalObject& global_object, const Program& program)\n{\n    auto& vm = this->vm();\n    VERIFY(!vm.exception());\n\n    VM::InterpreterExecutionScope scope(*this);\n\n    CallFrame global_call_frame;\n    global_call_frame.this_value = &global_object;\n    static FlyString global_execution_context_name = \"(global execution context)\";\n    global_call_frame.function_name = global_execution_context_name;\n    global_call_frame.scope = &global_object;\n    VERIFY(!vm.exception());\n    global_call_frame.is_strict_mode = program.is_strict_mode();\n    vm.push_call_frame(global_call_frame, global_object);\n    VERIFY(!vm.exception());\n    auto result = program.execute(*this, global_object);\n    vm.pop_call_frame();\n    return result;\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/Interpreter.cpp",
        "crashing_line": "    auto result = program.execute(*this, global_object);",
        "crashing_line_number": 73
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "MRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n    ptrdiff_t voff = -1;\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {\n      voff = argv - mrb->c->stbase;\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend(mrb, n + argc + 3);\n    if (argc >= 15) {\n      ci->stack[n+1] = mrb_ary_new_from_values(mrb, argc, argv);\n      ci->stack[n+2] = blk;\n      argc = 15;\n    }\n    else {\n      if (argc > 0)\n        stack_copy(ci->stack+n+1, argv, argc);\n      ci->stack[n+argc+1] = blk;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      uint16_t ac = (uint16_t)argc;\n      m = prepare_missing(mrb, self, mid, &c, (uint32_t)n, &ac, mrb_nil_value(), 0);\n      argc = (mrb_int)ac;\n      mid = MRB_SYM(method_missing);\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, (uint16_t)argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    if (voff >= 0) {\n      argv = mrb->c->stbase + voff;\n    }\n    ci->stack[0] = self;\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\nMRB_API mrb_value\nmrb_yield_with_class(mrb_state *mrb, mrb_value b, mrb_int argc, const mrb_value *argv, mrb_value self, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_sym mid = mrb->c->ci->mid;\n  mrb_callinfo *ci;\n  mrb_value val;\n  mrb_int n;\n\n  check_block(mrb, b);\n  ci = mrb->c->ci;\n  n = mrb_ci_nregs(ci);\n  p = mrb_proc_ptr(b);\n  ci = cipush(mrb, n, CINFO_SKIP, c, p, mid, 0 /* dummy */);\n  ci->nk = 0;\n  if (argc >= CALL_MAXARGS) {\n    ci->n = 15;\n    n = 3;\n  }\n  else {\n    ci->n = (uint8_t)argc;\n    n = argc + 2;\n  }\n  mrb_stack_extend(mrb, n);\n  mrb->c->ci->stack[0] = self;\n  if (ci->n == 15) {\n    mrb->c->ci->stack[1] = mrb_ary_new_from_values(mrb, argc, argv);\n    argc = 1;\n  }\n  else if (argc > 0) {\n    stack_copy(mrb->c->ci->stack+1, argv, argc);\n  }\n  mrb->c->ci->stack[argc+1] = mrb_nil_value(); /* clear blk */\n\n  if (MRB_PROC_CFUNC_P(p)) {\n    ci->cci = CINFO_DIRECT;\n    val = MRB_PROC_CFUNC(p)(mrb, self);\n    cipop(mrb);\n  }\n  else {\n    val = mrb_run(mrb, p, self);\n  }\n  return val;\n}\n",
    "target": 1,
    "idx": 1047213,
    "stack_trace": [
      {
        "function_name": "stack_copy",
        "function_body": "static inline void\nstack_copy(mrb_value *dst, const mrb_value *src, size_t size)\n{\n  memcpy(dst, src, sizeof(mrb_value)*size);\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "  memcpy(dst, src, sizeof(mrb_value)*size);",
        "crashing_line_number": 101
      },
      {
        "function_name": "mrb_funcall_with_block",
        "function_body": "MRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend_adjust(mrb, n + argc + 3, &argv);\n    if (argc >= 15) {\n      ci->stack[n+1] = mrb_ary_new_from_values(mrb, argc, argv);\n      ci->stack[n+2] = blk;\n      argc = 15;\n    }\n    else {\n      if (argc > 0)\n        stack_copy(ci->stack+n+1, argv, argc);\n      ci->stack[n+argc+1] = blk;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      uint16_t ac = (uint16_t)argc;\n      m = prepare_missing(mrb, self, mid, &c, (uint32_t)n, &ac, mrb_nil_value(), 0);\n      argc = (mrb_int)ac;\n      mid = MRB_SYM(method_missing);\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, (uint16_t)argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    ci->stack[0] = self;\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "    }",
        "crashing_line_number": 535
      },
      {
        "function_name": "mrb_instance_new",
        "function_body": "mrb_value\nmrb_instance_new(mrb_state *mrb, mrb_value cv)\n{\n  mrb_value obj, blk;\n  const mrb_value *argv;\n  mrb_int argc;\n  mrb_sym init;\n\n  mrb_get_args(mrb, \"*!&\", &argv, &argc, &blk);\n  obj = mrb_instance_alloc(mrb, cv);\n  init = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, init, mrb_do_nothing)) {\n    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);\n  }\n  return obj;\n}",
        "file_path": "/src/mruby/src/class.c",
        "crashing_line": "    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);",
        "crashing_line_number": 1976
      },
      {
        "function_name": "mrb_funcall_with_block",
        "function_body": "MRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend_adjust(mrb, n + argc + 3, &argv);\n    if (argc >= 15) {\n      ci->stack[n+1] = mrb_ary_new_from_values(mrb, argc, argv);\n      ci->stack[n+2] = blk;\n      argc = 15;\n    }\n    else {\n      if (argc > 0)\n        stack_copy(ci->stack+n+1, argv, argc);\n      ci->stack[n+argc+1] = blk;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      uint16_t ac = (uint16_t)argc;\n      m = prepare_missing(mrb, self, mid, &c, (uint32_t)n, &ac, mrb_nil_value(), 0);\n      argc = (mrb_int)ac;\n      mid = MRB_SYM(method_missing);\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, (uint16_t)argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    ci->stack[0] = self;\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "      if (!MRB_PROC_CFUNC_P(p)) {",
        "crashing_line_number": 560
      },
      {
        "function_name": "mrb_funcall_argv",
        "function_body": "MRB_API mrb_value\nmrb_funcall_argv(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv)\n{\n  return mrb_funcall_with_block(mrb, self, mid, argc, argv, mrb_nil_value());\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "",
        "crashing_line_number": 576
      },
      {
        "function_name": "mrb_make_exception",
        "function_body": "MRB_API mrb_value\nmrb_make_exception(mrb_state *mrb, mrb_int argc, const mrb_value *argv)\n{\n  mrb_value mesg;\n  int n;\n\n  mesg = mrb_nil_value();\n  switch (argc) {\n    case 0:\n    break;\n    case 1:\n      if (mrb_nil_p(argv[0]))\n        break;\n      if (mrb_string_p(argv[0])) {\n        mesg = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, argv[0]);\n        break;\n      }\n      n = 0;\n      goto exception_call;\n\n    case 2:\n    case 3:\n      n = 1;\nexception_call:\n      {\n        mrb_sym exc = MRB_SYM(exception);\n        if (mrb_respond_to(mrb, argv[0], exc)) {\n          mesg = mrb_funcall_argv(mrb, argv[0], exc, n, argv+1);\n        }\n        else {\n          /* undef */\n          mrb_raise(mrb, E_TYPE_ERROR, \"exception class/object expected\");\n        }\n      }\n\n      break;\n    default:\n      mrb_argnum_error(mrb, argc, 0, 3);\n      break;\n  }\n  if (argc > 0) {\n    if (!mrb_obj_is_kind_of(mrb, mesg, mrb->eException_class))\n      mrb_raise(mrb, mrb->eException_class, \"exception object expected\");\n    if (argc > 2)\n      set_backtrace(mrb, mesg, argv[2]);\n  }\n\n  return mesg;\n}",
        "file_path": "/src/mruby/src/error.c",
        "crashing_line": "          mesg = mrb_funcall_argv(mrb, argv[0], exc, n, argv+1);",
        "crashing_line_number": 497
      },
      {
        "function_name": "mrb_f_raise",
        "function_body": "MRB_API mrb_value\nmrb_f_raise(mrb_state *mrb, mrb_value self)\n{\n  mrb_value a[2], exc;\n  mrb_int argc;\n\n  argc = mrb_get_args(mrb, \"|oo\", &a[0], &a[1]);\n  mrb->c->ci->mid = 0;\n  switch (argc) {\n  case 0:\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"\");\n    break;\n  case 1:\n    if (mrb_string_p(a[0])) {\n      a[1] = a[0];\n      argc = 2;\n      a[0] = mrb_obj_value(E_RUNTIME_ERROR);\n    }\n    /* fall through */\n  default:\n    exc = mrb_make_exception(mrb, argc, a);\n    mrb_exc_raise(mrb, exc);\n    break;\n  }\n  return mrb_nil_value();            /* not reached */\n}",
        "file_path": "/src/mruby/src/kernel.c",
        "crashing_line": "    exc = mrb_make_exception(mrb, argc, a);",
        "crashing_line_number": 385
      },
      {
        "function_name": "mrb_vm_run",
        "function_body": "MRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "  if (!c->stbase) {",
        "crashing_line_number": 1130
      },
      {
        "function_name": "FuzzRB",
        "function_body": "int FuzzRB(const uint8_t *Data, size_t size) {\n\tmrb_value v;\n\tmrb_state *mrb = mrb_open();\n\tif (!mrb)\n\t\treturn 0;\n\n\tchar *code = (char *)malloc(size+1);\n\tif (!code)\n\t\treturn 0;\n\tmemcpy(code, Data, size);\n\tcode[size] = '\\0';\n\n\tif (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n\t\t// With libFuzzer binary run this to generate an RB file x.rb:\n\t\t// PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n\t\tstd::ofstream of(dump_path);\n\t\tof.write(code, size);\n\t}\n\tv = mrb_load_string(mrb, code);\n\tmrb_close(mrb);\n\n\tfree(code);\n\treturn 0;\n}",
        "file_path": "/src/mruby/oss-fuzz/mruby_proto_fuzzer.cpp",
        "crashing_line": "\tv = mrb_load_string(mrb, code);",
        "crashing_line_number": 33
      },
      {
        "function_name": "TestOneProtoInput",
        "function_body": "",
        "file_path": "/src/mruby/oss-fuzz/mruby_proto_fuzzer.cpp",
        "crashing_line": "",
        "crashing_line_number": 43
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void\nfz_draw_clip_image_mask(fz_context *ctx, fz_device *devp, fz_image *image, fz_matrix in_ctm, fz_rect scissor)\n{\n\tfz_draw_device *dev = (fz_draw_device*)devp;\n\tfz_matrix local_ctm = fz_concat(in_ctm, dev->transform);\n\tfz_irect bbox;\n\tfz_pixmap *scaled = NULL;\n\tfz_pixmap *pixmap = NULL;\n\tint dx, dy;\n\tfz_draw_state *state = push_stack(ctx, dev, \"clip image mask\");\n\tfz_colorspace *model = state->dest->colorspace;\n\tfz_irect clip;\n\tfz_irect src_area;\n\n\tfz_var(pixmap);\n\n\tif (dev->top == 0 && dev->resolve_spots)\n\t\tstate = push_group_for_separations(ctx, dev, fz_default_color_params /* FIXME */, dev->default_cs);\n\n\tclip = fz_pixmap_bbox(ctx, state->dest);\n\tclip = fz_intersect_irect(clip, state->scissor);\n\n\tif (image->w == 0 || image->h == 0)\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (empty) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n\tlocal_ctm = fz_gridfit_matrix(devp->flags & FZ_DEVFLAG_GRIDFIT_AS_TILED, local_ctm);\n\n\tsrc_area = find_src_area_required(local_ctm, image, clip);\n\tif (fz_is_empty_irect(src_area))\n\t\treturn;\n\n\tbbox = fz_irect_from_rect(fz_transform_rect(fz_unit_rect, local_ctm));\n\tbbox = fz_intersect_irect(bbox, state->scissor);\n\tif (!fz_is_infinite_rect(scissor))\n\t{\n\t\tfz_rect tscissor = fz_transform_rect(scissor, dev->transform);\n\t\tbbox = fz_intersect_irect(bbox, fz_irect_from_rect(tscissor));\n\t}\n\tif (!fz_is_valid_irect(bbox))\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (invalid) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\tdump_spaces(dev->top-1, \"Clip (image mask) begin\\n\");\n#endif\n\n\tfz_try(ctx)\n\t{\n\t\tpixmap = fz_get_pixmap_from_image(ctx, image, &src_area, &local_ctm, &dx, &dy);\n\n\t\tstate[1].mask = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\tfz_clear_pixmap(ctx, state[1].mask);\n\n\t\tstate[1].dest = fz_new_pixmap_with_bbox(ctx, model, bbox, state[0].dest->seps, state[0].dest->alpha);\n\t\tfz_copy_pixmap_rect(ctx, state[1].dest, state[0].dest, bbox, dev->default_cs);\n\t\tif (state[0].shape)\n\t\t{\n\t\t\tstate[1].shape = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].shape);\n\t\t}\n\t\tif (state[0].group_alpha)\n\t\t{\n\t\t\tstate[1].group_alpha = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].group_alpha);\n\t\t}\n\n\t\tstate[1].blendmode |= FZ_BLEND_ISOLATED;\n\t\tstate[1].scissor = bbox;\n\n\t\tif (!(devp->hints & FZ_DONT_INTERPOLATE_IMAGES) && ctx->tuning->image_scale(ctx->tuning->image_scale_arg, dx, dy, pixmap->w, pixmap->h))\n\t\t{\n\t\t\tint gridfit = !(dev->flags & FZ_DRAWDEV_FLAGS_TYPE3);\n\t\t\tscaled = fz_transform_pixmap(ctx, dev, pixmap, &local_ctm, state->dest->x, state->dest->y, dx, dy, gridfit, &clip);\n\t\t\tif (!scaled)\n\t\t\t{\n\t\t\t\tif (dx < 1)\n\t\t\t\t\tdx = 1;\n\t\t\t\tif (dy < 1)\n\t\t\t\t\tdy = 1;\n\t\t\t\tscaled = fz_scale_pixmap_cached(ctx, pixmap, pixmap->x, pixmap->y, dx, dy, NULL, dev->cache_x, dev->cache_y);\n\t\t\t}\n\t\t\tif (scaled)\n\t\t\t{\n\t\t\t\tfz_drop_pixmap(ctx, pixmap);\n\t\t\t\tpixmap = scaled;\n\t\t\t}\n\t\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top, \"\");\n\t\tfz_dump_blend(ctx, \"Creating imagemask: plotting \", pixmap);\n\t\tfz_dump_blend(ctx, \" onto \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n#endif\n\n\t\tfz_paint_image(ctx, state[1].mask, &bbox, state[1].shape, state[1].group_alpha, pixmap, local_ctm, 255, !(devp->hints & FZ_DONT_INTERPOLATE_IMAGES), 0);\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tfz_dump_blend(ctx, \" to get \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_pixmap(ctx, pixmap);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}\n",
    "target": 1,
    "idx": 1036463,
    "stack_trace": [
      {
        "function_name": "fz_paint_pixmap_with_mask",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/draw-paint.c",
        "crashing_line": "",
        "crashing_line_number": 2369
      },
      {
        "function_name": "fz_draw_pop_clip",
        "function_body": "static void\nfz_draw_pop_clip(fz_context *ctx, fz_device *devp)\n{\n\tfz_draw_device *dev = (fz_draw_device*)devp;\n\tfz_draw_state *state;\n\n\tif (dev->top == 0)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"unexpected pop clip\");\n\n\tstate = pop_stack(ctx, dev, \"clip\");\n\n\t/* We can get here with state[1].mask == NULL if the clipping actually\n\t * resolved to a rectangle earlier.\n\t */\n\tif (state[1].mask)\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top, \"\");\n\t\tfz_dump_blend(ctx, \"Clipping \", state[1].dest);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n\t\tfz_dump_blend(ctx, \" onto \", state[0].dest);\n\t\tif (state[0].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[0].shape);\n\t\tif (state[0].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[0].group_alpha);\n\t\tfz_dump_blend(ctx, \" with \", state[1].mask);\n#endif\n\n\t\tfz_paint_pixmap_with_mask(state[0].dest, state[1].dest, state[1].mask);\n\t\tif (state[0].shape != state[1].shape)\n\t\t{\n\t\t\tfz_paint_pixmap_with_mask(state[0].shape, state[1].shape, state[1].mask);\n\t\t\tfz_drop_pixmap(ctx, state[1].shape);\n\t\t\tstate[1].shape = NULL;\n\t\t}\n\t\tif (state[0].group_alpha != state[1].group_alpha)\n\t\t{\n\t\t\tfz_paint_pixmap_with_mask(state[0].group_alpha, state[1].group_alpha, state[1].mask);\n\t\t\tfz_drop_pixmap(ctx, state[1].group_alpha);\n\t\t\tstate[1].group_alpha = NULL;\n\t\t}\n\t\tfz_drop_pixmap(ctx, state[1].mask);\n\t\tstate[1].mask = NULL;\n\t\tfz_drop_pixmap(ctx, state[1].dest);\n\t\tstate[1].dest = NULL;\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tfz_dump_blend(ctx, \" to get \", state[0].dest);\n\t\tif (state[0].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[0].shape);\n\t\tif (state[0].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[0].group_alpha);\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\telse\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top, \"Clip end\\n\");\n#endif\n\t}\n}",
        "file_path": "/src/mupdf/source/fitz/draw-device.c",
        "crashing_line": "\t\tif (state[0].shape)",
        "crashing_line_number": 2081
      },
      {
        "function_name": "fz_pop_clip",
        "function_body": "void\nfz_pop_clip(fz_context *ctx, fz_device *dev)\n{\n\tpop_clip_stack(ctx, dev, fz_device_container_stack_is_clip);\n\n\tif (dev->pop_clip)\n\t{\n\t\tfz_try(ctx)\n\t\t\tdev->pop_clip(ctx, dev);\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tfz_disable_device(ctx, dev);\n\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}",
        "file_path": "/src/mupdf/source/fitz/device.c",
        "crashing_line": "\t\t\tdev->pop_clip(ctx, dev);",
        "crashing_line_number": 299
      },
      {
        "function_name": "pdf_show_path",
        "function_body": "static void\npdf_show_path(fz_context *ctx, pdf_run_processor *pr, int doclose, int dofill, int dostroke, int even_odd)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tfz_path *path;\n\tfz_rect bbox;\n\tsoftmask_save softmask = { NULL };\n\tint knockout_group = 0;\n\n\tif (dostroke) {\n\t\tif (pr->dev->flags & (FZ_DEVFLAG_STROKECOLOR_UNDEFINED | FZ_DEVFLAG_LINEJOIN_UNDEFINED | FZ_DEVFLAG_LINEWIDTH_UNDEFINED))\n\t\t\tpr->dev->flags |= FZ_DEVFLAG_UNCACHEABLE;\n\t\telse if (gstate->stroke_state->dash_len != 0 && pr->dev->flags & (FZ_DEVFLAG_STARTCAP_UNDEFINED | FZ_DEVFLAG_DASHCAP_UNDEFINED | FZ_DEVFLAG_ENDCAP_UNDEFINED))\n\t\t\tpr->dev->flags |= FZ_DEVFLAG_UNCACHEABLE;\n\t\telse if (gstate->stroke_state->linejoin == FZ_LINEJOIN_MITER && (pr->dev->flags & FZ_DEVFLAG_MITERLIMIT_UNDEFINED))\n\t\t\tpr->dev->flags |= FZ_DEVFLAG_UNCACHEABLE;\n\t}\n\tif (dofill) {\n\t\tif (pr->dev->flags & FZ_DEVFLAG_FILLCOLOR_UNDEFINED)\n\t\t\tpr->dev->flags |= FZ_DEVFLAG_UNCACHEABLE;\n\t}\n\n\tpath = pr->path;\n\tpr->path = fz_new_path(ctx);\n\n\tfz_try(ctx)\n\t{\n\t\tif (doclose)\n\t\t\tfz_closepath(ctx, path);\n\n\t\tbbox = fz_bound_path(ctx, path, (dostroke ? gstate->stroke_state : NULL), gstate->ctm);\n\n\t\tif (pr->super.hidden)\n\t\t\tdostroke = dofill = 0;\n\n\t\tif (dofill || dostroke)\n\t\t\tgstate = pdf_begin_group(ctx, pr, bbox, &softmask);\n\n\t\tif (dofill && dostroke)\n\t\t{\n\t\t\t/* We may need to push a knockout group */\n\t\t\tif (gstate->stroke.alpha == 0)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't do anything */\n\t\t\t}\n\t\t\telse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't show up */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tknockout_group = 1;\n\t\t\t\tfz_begin_group(ctx, pr->dev, bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (dofill)\n\t\t{\n\t\t\tswitch (gstate->fill.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_fill_path(ctx, pr->dev, path, even_odd, gstate->ctm,\n\t\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, gstate->fill.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->fill.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, gstate->ctm, bbox);\n\t\t\t\t\tgstate = pdf_show_pattern(ctx, pr, gstate->fill.pattern, gstate->fill.gstate_num, bbox, PDF_FILL);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->fill.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, gstate->ctm, bbox);\n\t\t\t\t\t/* The cluster and page 2 of patterns.pdf shows that fz_fill_shade should NOT be called with gstate->ctm. */\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, gstate->fill.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dostroke)\n\t\t{\n\t\t\tswitch (gstate->stroke.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, gstate->ctm,\n\t\t\t\t\tgstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, gstate->stroke.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->stroke.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, gstate->ctm, bbox);\n\t\t\t\t\tgstate = pdf_show_pattern(ctx, pr, gstate->stroke.pattern, gstate->stroke.gstate_num, bbox, PDF_STROKE);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->stroke.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, gstate->ctm, bbox);\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, gstate->stroke.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (knockout_group)\n\t\t\tfz_end_group(ctx, pr->dev);\n\n\t\tif (dofill || dostroke)\n\t\t\tpdf_end_group(ctx, pr, &softmask);\n\n\t\tif (pr->clip)\n\t\t{\n\t\t\tgstate->clip_depth++;\n\t\t\tfz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, gstate->ctm, bbox);\n\t\t\tpr->clip = 0;\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_path(ctx, path);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, softmask.softmask);\n\t\tpdf_drop_obj(ctx, softmask.page_resources);\n\t\tfz_rethrow(ctx);\n\t}\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-op-run.c",
        "crashing_line": "\t\t\t\t\tfz_pop_clip(ctx, pr->dev);",
        "crashing_line_number": 640
      },
      {
        "function_name": "pdf_run_fstar",
        "function_body": "static void pdf_run_fstar(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_path(ctx, pr, 0, 1, 0, 1);\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-op-run.c",
        "crashing_line": "\tpdf_show_path(ctx, pr, 0, 1, 0, 1);",
        "crashing_line_number": 1589
      },
      {
        "function_name": "pdf_process_stream",
        "function_body": "static void\npdf_process_stream(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm)\n{\n\tpdf_document *doc = csi->doc;\n\tpdf_lexbuf *buf = csi->buf;\n\tfz_cookie *cookie = csi->cookie;\n\n\tpdf_token tok = PDF_TOK_ERROR;\n\tint in_text_array = 0;\n\tint syntax_errors = 0;\n\n\t/* make sure we have a clean slate if we come here from flush_text */\n\tpdf_clear_stack(ctx, csi);\n\n\tfz_var(in_text_array);\n\tfz_var(tok);\n\n\tif (cookie)\n\t{\n\t\tcookie->progress_max = -1;\n\t\tcookie->progress = 0;\n\t}\n\n\tdo\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\t/* Check the cookie */\n\t\t\t\tif (cookie)\n\t\t\t\t{\n\t\t\t\t\tif (cookie->abort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcookie->progress++;\n\t\t\t\t}\n\n\t\t\t\ttok = pdf_lex(ctx, stm, buf);\n\n\t\t\t\tif (in_text_array)\n\t\t\t\t{\n\t\t\t\t\tswitch(tok)\n\t\t\t\t\t{\n\t\t\t\t\tcase PDF_TOK_CLOSE_ARRAY:\n\t\t\t\t\t\tin_text_array = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\t\tpdf_array_push_real(ctx, csi->obj, buf->f);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\t\tpdf_array_push_int(ctx, csi->obj, buf->i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\t\tpdf_array_push_string(ctx, csi->obj, buf->scratch, buf->len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\t\tif (buf->scratch[0] == 'T' && (buf->scratch[1] == 'w' || buf->scratch[1] == 'c') && buf->scratch[2] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint n = pdf_array_len(ctx, csi->obj);\n\t\t\t\t\t\t\tif (n > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpdf_obj *o = pdf_array_get(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\tif (pdf_is_number(ctx, o))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcsi->stack[0] = pdf_to_real(ctx, o);\n\t\t\t\t\t\t\t\t\tpdf_array_delete(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Deliberate Fallthrough! */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in array\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse switch (tok)\n\t\t\t\t{\n\t\t\t\tcase PDF_TOK_ENDSTREAM:\n\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_ARRAY:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (csi->in_text)\n\t\t\t\t\t{\n\t\t\t\t\t\tin_text_array = 1;\n\t\t\t\t\t\tcsi->obj = pdf_new_array(ctx, doc, 4);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcsi->obj = pdf_parse_array(ctx, doc, stm, buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_DICT:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tcsi->obj = pdf_parse_dict(ctx, doc, stm, buf);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_NAME:\n\t\t\t\t\tif (csi->name[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\tcsi->obj = pdf_new_name(ctx, buf->scratch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_strlcpy(csi->name, buf->scratch, sizeof(csi->name));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->i;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->f;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\tif (buf->len <= sizeof(csi->string))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(csi->string, buf->scratch, buf->len);\n\t\t\t\t\t\tcsi->string_len = buf->len;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsi->obj = pdf_new_string(ctx, buf->scratch, buf->len);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\tpdf_clear_stack(ctx, csi);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in content stream\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (tok != PDF_TOK_EOF);\n\t\t}\n\t\tfz_always(ctx)\n\t\t{\n\t\t\tpdf_clear_stack(ctx, csi);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tint caught = fz_caught(ctx);\n\t\t\tif (cookie)\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t{\n\t\t\t\t\tcookie->incomplete++;\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t\t/* ignore minor errors */ ;\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* If we do catch an error, then reset ourselves to a base lexing state */\n\t\t\tin_text_array = 0;\n\t\t}\n\t}\n\twhile (tok != PDF_TOK_EOF);\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-interpret.c",
        "crashing_line": "\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);",
        "crashing_line_number": 948
      },
      {
        "function_name": "pdf_process_contents",
        "function_body": "void\npdf_process_contents(fz_context *ctx, pdf_processor *proc, pdf_document *doc, pdf_obj *rdb, pdf_obj *stmobj, fz_cookie *cookie)\n{\n\tpdf_csi csi;\n\tpdf_lexbuf buf;\n\tfz_stream *stm = NULL;\n\n\tif (!stmobj)\n\t\treturn;\n\n\tfz_var(stm);\n\n\tpdf_lexbuf_init(ctx, &buf, PDF_LEXBUF_SMALL);\n\tpdf_init_csi(ctx, &csi, doc, rdb, &buf, cookie);\n\n\tfz_try(ctx)\n\t{\n\t\tfz_defer_reap_start(ctx);\n\t\tstm = pdf_open_contents_stream(ctx, doc, stmobj);\n\t\tpdf_process_stream(ctx, proc, &csi, stm);\n\t\tpdf_process_end(ctx, proc, &csi);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_defer_reap_end(ctx);\n\t\tfz_drop_stream(ctx, stm);\n\t\tpdf_clear_stack(ctx, &csi);\n\t\tpdf_lexbuf_fin(ctx, &buf);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tproc->close_processor = NULL; /* aborted run, don't warn about unclosed processor */\n\t\tfz_rethrow(ctx);\n\t}\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-interpret.c",
        "crashing_line": "\t\tpdf_process_stream(ctx, proc, &csi, stm);",
        "crashing_line_number": 1042
      },
      {
        "function_name": "pdf_run_xobject",
        "function_body": "static void\npdf_run_xobject(fz_context *ctx, pdf_run_processor *proc, pdf_obj *xobj, pdf_obj *page_resources, fz_matrix transform, int is_smask)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = NULL;\n\tint oldtop = 0;\n\tint oldbot = -1;\n\tsoftmask_save softmask = { NULL };\n\tint gparent_save;\n\tfz_matrix gparent_save_ctm;\n\tpdf_obj *resources;\n\tfz_rect xobj_bbox;\n\tfz_matrix xobj_matrix;\n\tint transparency = 0;\n\tpdf_document *doc;\n\tfz_colorspace *cs = NULL;\n\tfz_default_colorspaces *save_default_cs = NULL;\n\tfz_default_colorspaces *xobj_default_cs = NULL;\n\n\t/* Avoid infinite recursion */\n\tif (xobj == NULL || pdf_mark_obj(ctx, xobj))\n\t\treturn;\n\n\tfz_var(cs);\n\tfz_var(xobj_default_cs);\n\n\tgparent_save = pr->gparent;\n\tpr->gparent = pr->gtop;\n\toldtop = pr->gtop;\n\n\tsave_default_cs = pr->default_cs;\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_gsave(ctx, pr);\n\n\t\tgstate = pr->gstate + pr->gtop;\n\n\t\txobj_bbox = pdf_xobject_bbox(ctx, xobj);\n\t\txobj_matrix = pdf_xobject_matrix(ctx, xobj);\n\t\ttransparency = pdf_xobject_transparency(ctx, xobj);\n\n\t\t/* apply xobject's transform matrix */\n\t\ttransform = fz_concat(xobj_matrix, transform);\n\t\tgstate->ctm = fz_concat(transform, gstate->ctm);\n\n\t\t/* The gparent is updated with the modified ctm */\n\t\tgparent_save_ctm = pr->gstate[pr->gparent].ctm;\n\t\tpr->gstate[pr->gparent].ctm = gstate->ctm;\n\n\t\t/* apply soft mask, create transparency group and reset state */\n\t\tif (transparency)\n\t\t{\n\t\t\tint isolated = pdf_xobject_isolated(ctx, xobj);\n\n\t\t\tfz_rect bbox = fz_transform_rect(xobj_bbox, gstate->ctm);\n\n\t\t\tgstate = begin_softmask(ctx, pr, &softmask);\n\n\t\t\tif (isolated)\n\t\t\t\tcs = pdf_xobject_colorspace(ctx, xobj);\n\t\t\tfz_begin_group(ctx, pr->dev, bbox,\n\t\t\t\t\tcs,\n\t\t\t\t\t(is_smask ? 1 : isolated),\n\t\t\t\t\tpdf_xobject_knockout(ctx, xobj),\n\t\t\t\t\tgstate->blendmode, gstate->fill.alpha);\n\n\t\t\tgstate->blendmode = 0;\n\t\t\tgstate->stroke.alpha = 1;\n\t\t\tgstate->fill.alpha = 1;\n\t\t}\n\n\t\tpdf_gsave(ctx, pr); /* Save here so the clippath doesn't persist */\n\n\t\t/* clip to the bounds */\n\t\tfz_moveto(ctx, pr->path, xobj_bbox.x0, xobj_bbox.y0);\n\t\tfz_lineto(ctx, pr->path, xobj_bbox.x1, xobj_bbox.y0);\n\t\tfz_lineto(ctx, pr->path, xobj_bbox.x1, xobj_bbox.y1);\n\t\tfz_lineto(ctx, pr->path, xobj_bbox.x0, xobj_bbox.y1);\n\t\tfz_closepath(ctx, pr->path);\n\t\tpr->clip = 1;\n\t\tpdf_show_path(ctx, pr, 0, 0, 0, 0);\n\n\t\t/* run contents */\n\n\t\tresources = pdf_xobject_resources(ctx, xobj);\n\t\tif (!resources)\n\t\t\tresources = page_resources;\n\n\t\tfz_try(ctx)\n\t\t\txobj_default_cs = pdf_update_default_colorspaces(ctx, pr->default_cs, resources);\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tif (fz_caught(ctx) != FZ_ERROR_TRYLATER)\n\t\t\t\tfz_rethrow(ctx);\n\t\t\tif (pr->cookie)\n\t\t\t\tpr->cookie->incomplete = 1;\n\t\t}\n\t\tif (xobj_default_cs != save_default_cs)\n\t\t{\n\t\t\tfz_set_default_colorspaces(ctx, pr->dev, xobj_default_cs);\n\t\t\tpr->default_cs = xobj_default_cs;\n\t\t}\n\n\t\tdoc = pdf_get_bound_document(ctx, xobj);\n\n\t\toldbot = pr->gbot;\n\t\tpr->gbot = pr->gtop;\n\n\t\tpdf_process_contents(ctx, (pdf_processor*)pr, doc, resources, xobj, pr->cookie);\n\n\t\t/* Undo any gstate mismatches due to the pdf_process_contents call */\n\t\tif (oldbot != -1)\n\t\t{\n\t\t\twhile (pr->gtop > pr->gbot)\n\t\t\t{\n\t\t\t\tpdf_grestore(ctx, pr);\n\t\t\t}\n\t\t\tpr->gbot = oldbot;\n\t\t}\n\n\t\tpdf_grestore(ctx, pr); /* Remove the state we pushed for the clippath */\n\n\t\t/* wrap up transparency stacks */\n\t\tif (transparency)\n\t\t{\n\t\t\tfz_end_group(ctx, pr->dev);\n\t\t\tend_softmask(ctx, pr, &softmask);\n\t\t}\n\n\t\tpr->gstate[pr->gparent].ctm = gparent_save_ctm;\n\t\tpr->gparent = gparent_save;\n\n\t\twhile (oldtop < pr->gtop)\n\t\t\tpdf_grestore(ctx, pr);\n\n\t\tif (xobj_default_cs != save_default_cs)\n\t\t{\n\t\t\tfz_set_default_colorspaces(ctx, pr->dev, save_default_cs);\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tpr->default_cs = save_default_cs;\n\t\tfz_drop_default_colorspaces(ctx, xobj_default_cs);\n\t\tfz_drop_colorspace(ctx, cs);\n\t\tpdf_unmark_obj(ctx, xobj);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, softmask.softmask);\n\t\tpdf_drop_obj(ctx, softmask.page_resources);\n\t\t/* Note: Any SYNTAX errors should have been swallowed\n\t\t * by pdf_process_contents, but in case any escape from other\n\t\t * functions, recast the error type here to be safe. */\n\t\tif (fz_caught(ctx) == FZ_ERROR_SYNTAX)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"syntax error in xobject\");\n\t\tfz_rethrow(ctx);\n\t}\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-op-run.c",
        "crashing_line": "\t\tpdf_process_contents(ctx, (pdf_processor*)pr, doc, resources, xobj, pr->cookie);",
        "crashing_line_number": 1270
      },
      {
        "function_name": "pdf_run_Do_form",
        "function_body": "static void pdf_run_Do_form(fz_context *ctx, pdf_processor *proc, const char *name, pdf_obj *xobj, pdf_obj *page_resources)\n{\n\tpdf_run_xobject(ctx, (pdf_run_processor*)proc, xobj, page_resources, fz_identity, 0);\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-op-run.c",
        "crashing_line": "\tpdf_run_xobject(ctx, (pdf_run_processor*)proc, xobj, page_resources, fz_identity, 0);",
        "crashing_line_number": 1933
      },
      {
        "function_name": "pdf_process_Do",
        "function_body": "static void\npdf_process_Do(fz_context *ctx, pdf_processor *proc, pdf_csi *csi)\n{\n\tpdf_obj *xres, *xobj, *subtype;\n\n\txres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(XObject));\n\txobj = pdf_dict_gets(ctx, xres, csi->name);\n\tif (!xobj)\n\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find XObject resource '%s'\", csi->name);\n\tsubtype = pdf_dict_get(ctx, xobj, PDF_NAME(Subtype));\n\tif (pdf_name_eq(ctx, subtype, PDF_NAME(Form)))\n\t{\n\t\tpdf_obj *st = pdf_dict_get(ctx, xobj, PDF_NAME(Subtype2));\n\t\tif (st)\n\t\t\tsubtype = st;\n\t}\n\tif (!pdf_is_name(ctx, subtype))\n\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"no XObject subtype specified\");\n\n\tif (pdf_is_ocg_hidden(ctx, csi->doc, csi->rdb, proc->usage, pdf_dict_get(ctx, xobj, PDF_NAME(OC))))\n\t\treturn;\n\n\tif (pdf_name_eq(ctx, subtype, PDF_NAME(Form)))\n\t{\n\t\tif (proc->op_Do_form)\n\t\t\tproc->op_Do_form(ctx, proc, csi->name, xobj, csi->rdb);\n\t}\n\n\telse if (pdf_name_eq(ctx, subtype, PDF_NAME(Image)))\n\t{\n\t\tif (proc->op_Do_image)\n\t\t{\n\t\t\tfz_image *image = pdf_load_image(ctx, csi->doc, xobj);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_Do_image(ctx, proc, csi->name, image);\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_image(ctx, image);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n\n\telse if (!strcmp(pdf_to_name(ctx, subtype), \"PS\"))\n\t\tfz_warn(ctx, \"ignoring XObject with subtype PS\");\n\telse\n\t\tfz_warn(ctx, \"ignoring XObject with unknown subtype: '%s'\", pdf_to_name(ctx, subtype));\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-interpret.c",
        "crashing_line": "\t\t\tproc->op_Do_form(ctx, proc, csi->name, xobj, csi->rdb);",
        "crashing_line_number": 334
      },
      {
        "function_name": "pdf_process_keyword",
        "function_body": "static void\npdf_process_keyword(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm, char *word)\n{\n\tfloat *s = csi->stack;\n\tchar csname[40];\n\tint key;\n\n\tkey = word[0];\n\tif (word[1])\n\t{\n\t\tkey |= word[1] << 8;\n\t\tif (word[2])\n\t\t{\n\t\t\tkey |= word[2] << 16;\n\t\t\tif (word[3])\n\t\t\t\tkey = 0;\n\t\t}\n\t}\n\n\tswitch (key)\n\t{\n\tdefault:\n\t\tif (!csi->xbalance)\n\t\t{\n\t\t\tif (is_known_bad_word(word))\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"unknown keyword: '%s'\", word);\n\t\t\telse\n\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"unknown keyword: '%s'\", word);\n\t\t}\n\t\tbreak;\n\n\t/* general graphics state */\n\tcase A('w'): if (proc->op_w) proc->op_w(ctx, proc, s[0]); break;\n\tcase A('j'): if (proc->op_j) proc->op_j(ctx, proc, fz_clampi(s[0], 0, 2)); break;\n\tcase A('J'): if (proc->op_J) proc->op_J(ctx, proc, fz_clampi(s[0], 0, 2)); break;\n\tcase A('M'): if (proc->op_M) proc->op_M(ctx, proc, s[0]); break;\n\tcase A('d'): if (proc->op_d) proc->op_d(ctx, proc, csi->obj, s[0]); break;\n\tcase B('r','i'): if (proc->op_ri) proc->op_ri(ctx, proc, csi->name); break;\n\tcase A('i'): if (proc->op_i) proc->op_i(ctx, proc, s[0]); break;\n\n\tcase B('g','s'):\n\t\t{\n\t\t\tpdf_obj *gsres, *gsobj;\n\t\t\tgsres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(ExtGState));\n\t\t\tgsobj = pdf_dict_gets(ctx, gsres, csi->name);\n\t\t\tif (!gsobj)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find ExtGState resource '%s'\", csi->name);\n\t\t\tif (proc->op_gs_begin)\n\t\t\t\tproc->op_gs_begin(ctx, proc, csi->name, gsobj);\n\t\t\tpdf_process_extgstate(ctx, proc, csi, gsobj);\n\t\t\tif (proc->op_gs_end)\n\t\t\t\tproc->op_gs_end(ctx, proc);\n\t\t}\n\t\tbreak;\n\n\t/* special graphics state */\n\tcase A('q'): pdf_process_gsave(ctx, proc, csi); break;\n\tcase A('Q'): pdf_process_grestore(ctx, proc, csi); break;\n\tcase B('c','m'): if (proc->op_cm) proc->op_cm(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\n\t/* path construction */\n\tcase A('m'): if (proc->op_m) proc->op_m(ctx, proc, s[0], s[1]); break;\n\tcase A('l'): if (proc->op_l) proc->op_l(ctx, proc, s[0], s[1]); break;\n\tcase A('c'): if (proc->op_c) proc->op_c(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\tcase A('v'): if (proc->op_v) proc->op_v(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('y'): if (proc->op_y) proc->op_y(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('h'): if (proc->op_h) proc->op_h(ctx, proc); break;\n\tcase B('r','e'): if (proc->op_re) proc->op_re(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\n\t/* path painting */\n\tcase A('S'): if (proc->op_S) proc->op_S(ctx, proc); break;\n\tcase A('s'): if (proc->op_s) proc->op_s(ctx, proc); break;\n\tcase A('F'): if (proc->op_F) proc->op_F(ctx, proc); break;\n\tcase A('f'): if (proc->op_f) proc->op_f(ctx, proc); break;\n\tcase B('f','*'): if (proc->op_fstar) proc->op_fstar(ctx, proc); break;\n\tcase A('B'): if (proc->op_B) proc->op_B(ctx, proc); break;\n\tcase B('B','*'): if (proc->op_Bstar) proc->op_Bstar(ctx, proc); break;\n\tcase A('b'): if (proc->op_b) proc->op_b(ctx, proc); break;\n\tcase B('b','*'): if (proc->op_bstar) proc->op_bstar(ctx, proc); break;\n\tcase A('n'): if (proc->op_n) proc->op_n(ctx, proc); break;\n\n\t/* path clipping */\n\tcase A('W'): if (proc->op_W) proc->op_W(ctx, proc); break;\n\tcase B('W','*'): if (proc->op_Wstar) proc->op_Wstar(ctx, proc); break;\n\n\t/* text objects */\n\tcase B('B','T'): csi->in_text = 1; if (proc->op_BT) proc->op_BT(ctx, proc); break;\n\tcase B('E','T'): csi->in_text = 0; if (proc->op_ET) proc->op_ET(ctx, proc); break;\n\n\t/* text state */\n\tcase B('T','c'): if (proc->op_Tc) proc->op_Tc(ctx, proc, s[0]); break;\n\tcase B('T','w'): if (proc->op_Tw) proc->op_Tw(ctx, proc, s[0]); break;\n\tcase B('T','z'): if (proc->op_Tz) proc->op_Tz(ctx, proc, s[0]); break;\n\tcase B('T','L'): if (proc->op_TL) proc->op_TL(ctx, proc, s[0]); break;\n\tcase B('T','r'): if (proc->op_Tr) proc->op_Tr(ctx, proc, s[0]); break;\n\tcase B('T','s'): if (proc->op_Ts) proc->op_Ts(ctx, proc, s[0]); break;\n\n\tcase B('T','f'):\n\t\tif (proc->op_Tf)\n\t\t{\n\t\t\tpdf_obj *fontres, *fontobj;\n\t\t\tpdf_font_desc *font;\n\t\t\tfontres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(Font));\n\t\t\tfontobj = pdf_dict_gets(ctx, fontres, csi->name);\n\t\t\tif (pdf_is_dict(ctx, fontobj))\n\t\t\t\tfont = pdf_try_load_font(ctx, csi->doc, csi->rdb, fontobj, csi->cookie);\n\t\t\telse\n\t\t\t\tfont = pdf_load_hail_mary_font(ctx, csi->doc);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_Tf(ctx, proc, csi->name, font, s[0]);\n\t\t\tfz_always(ctx)\n\t\t\t\tpdf_drop_font(ctx, font);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\t/* text positioning */\n\tcase B('T','d'): if (proc->op_Td) proc->op_Td(ctx, proc, s[0], s[1]); break;\n\tcase B('T','D'): if (proc->op_TD) proc->op_TD(ctx, proc, s[0], s[1]); break;\n\tcase B('T','m'): if (proc->op_Tm) proc->op_Tm(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\tcase B('T','*'): if (proc->op_Tstar) proc->op_Tstar(ctx, proc); break;\n\n\t/* text showing */\n\tcase B('T','J'): if (proc->op_TJ) proc->op_TJ(ctx, proc, csi->obj); break;\n\tcase B('T','j'):\n\t\tif (proc->op_Tj)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_Tj(ctx, proc, csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_Tj(ctx, proc, pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\tcase A('\\''):\n\t\tif (proc->op_squote)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_squote(ctx, proc, csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_squote(ctx, proc, pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\tcase A('\"'):\n\t\tif (proc->op_dquote)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_dquote(ctx, proc, s[0], s[1], csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_dquote(ctx, proc, s[0], s[1], pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\n\t/* type 3 fonts */\n\tcase B('d','0'): if (proc->op_d0) proc->op_d0(ctx, proc, s[0], s[1]); break;\n\tcase B('d','1'): if (proc->op_d1) proc->op_d1(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\n\t/* color */\n\tcase B('C','S'): pdf_process_CS(ctx, proc, csi, 1); break;\n\tcase B('c','s'): pdf_process_CS(ctx, proc, csi, 0); break;\n\tcase B('S','C'): pdf_process_SC(ctx, proc, csi, 1); break;\n\tcase B('s','c'): pdf_process_SC(ctx, proc, csi, 0); break;\n\tcase C('S','C','N'): pdf_process_SC(ctx, proc, csi, 1); break;\n\tcase C('s','c','n'): pdf_process_SC(ctx, proc, csi, 0); break;\n\n\tcase A('G'): if (proc->op_G) proc->op_G(ctx, proc, s[0]); break;\n\tcase A('g'): if (proc->op_g) proc->op_g(ctx, proc, s[0]); break;\n\tcase B('R','G'): if (proc->op_RG) proc->op_RG(ctx, proc, s[0], s[1], s[2]); break;\n\tcase B('r','g'): if (proc->op_rg) proc->op_rg(ctx, proc, s[0], s[1], s[2]); break;\n\tcase A('K'): if (proc->op_K) proc->op_K(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('k'): if (proc->op_k) proc->op_k(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\n\t/* shadings, images, xobjects */\n\tcase B('B','I'):\n\t\t{\n\t\t\tfz_image *img = parse_inline_image(ctx, csi, stm, csname, sizeof csname);\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tif (proc->op_BI)\n\t\t\t\t\tproc->op_BI(ctx, proc, img, csname[0] ? csname : NULL);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_image(ctx, img);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\tcase B('s','h'):\n\t\tif (proc->op_sh)\n\t\t{\n\t\t\tpdf_obj *shaderes, *shadeobj;\n\t\t\tfz_shade *shade;\n\t\t\tshaderes = pdf_dict_get(ctx, csi->rdb, PDF_NAME(Shading));\n\t\t\tshadeobj = pdf_dict_gets(ctx, shaderes, csi->name);\n\t\t\tif (!shadeobj)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find Shading resource '%s'\", csi->name);\n\t\t\tshade = pdf_load_shading(ctx, csi->doc, shadeobj);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_sh(ctx, proc, csi->name, shade);\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_shade(ctx, shade);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\tcase B('D','o'): pdf_process_Do(ctx, proc, csi); break;\n\n\t/* marked content */\n\tcase B('M','P'): if (proc->op_MP) proc->op_MP(ctx, proc, csi->name); break;\n\tcase B('D','P'): if (proc->op_DP) proc->op_DP(ctx, proc, csi->name, csi->obj, resolve_properties(ctx, csi, csi->obj)); break;\n\tcase C('B','M','C'): pdf_process_BMC(ctx, proc, csi, csi->name); break;\n\tcase C('B','D','C'): pdf_process_BDC(ctx, proc, csi); break;\n\tcase C('E','M','C'): pdf_process_EMC(ctx, proc, csi); break;\n\n\t/* compatibility */\n\tcase B('B','X'): ++csi->xbalance; if (proc->op_BX) proc->op_BX(ctx, proc); break;\n\tcase B('E','X'): --csi->xbalance; if (proc->op_EX) proc->op_EX(ctx, proc); break;\n\t}\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-interpret.c",
        "crashing_line": "\tcase B('D','o'): pdf_process_Do(ctx, proc, csi); break;",
        "crashing_line_number": 773
      },
      {
        "function_name": "pdf_process_stream",
        "function_body": "static void\npdf_process_stream(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm)\n{\n\tpdf_document *doc = csi->doc;\n\tpdf_lexbuf *buf = csi->buf;\n\tfz_cookie *cookie = csi->cookie;\n\n\tpdf_token tok = PDF_TOK_ERROR;\n\tint in_text_array = 0;\n\tint syntax_errors = 0;\n\n\t/* make sure we have a clean slate if we come here from flush_text */\n\tpdf_clear_stack(ctx, csi);\n\n\tfz_var(in_text_array);\n\tfz_var(tok);\n\n\tif (cookie)\n\t{\n\t\tcookie->progress_max = -1;\n\t\tcookie->progress = 0;\n\t}\n\n\tdo\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\t/* Check the cookie */\n\t\t\t\tif (cookie)\n\t\t\t\t{\n\t\t\t\t\tif (cookie->abort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcookie->progress++;\n\t\t\t\t}\n\n\t\t\t\ttok = pdf_lex(ctx, stm, buf);\n\n\t\t\t\tif (in_text_array)\n\t\t\t\t{\n\t\t\t\t\tswitch(tok)\n\t\t\t\t\t{\n\t\t\t\t\tcase PDF_TOK_CLOSE_ARRAY:\n\t\t\t\t\t\tin_text_array = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\t\tpdf_array_push_real(ctx, csi->obj, buf->f);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\t\tpdf_array_push_int(ctx, csi->obj, buf->i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\t\tpdf_array_push_string(ctx, csi->obj, buf->scratch, buf->len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\t\tif (buf->scratch[0] == 'T' && (buf->scratch[1] == 'w' || buf->scratch[1] == 'c') && buf->scratch[2] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint n = pdf_array_len(ctx, csi->obj);\n\t\t\t\t\t\t\tif (n > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpdf_obj *o = pdf_array_get(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\tif (pdf_is_number(ctx, o))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcsi->stack[0] = pdf_to_real(ctx, o);\n\t\t\t\t\t\t\t\t\tpdf_array_delete(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Deliberate Fallthrough! */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in array\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse switch (tok)\n\t\t\t\t{\n\t\t\t\tcase PDF_TOK_ENDSTREAM:\n\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_ARRAY:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (csi->in_text)\n\t\t\t\t\t{\n\t\t\t\t\t\tin_text_array = 1;\n\t\t\t\t\t\tcsi->obj = pdf_new_array(ctx, doc, 4);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcsi->obj = pdf_parse_array(ctx, doc, stm, buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_DICT:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tcsi->obj = pdf_parse_dict(ctx, doc, stm, buf);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_NAME:\n\t\t\t\t\tif (csi->name[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\tcsi->obj = pdf_new_name(ctx, buf->scratch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_strlcpy(csi->name, buf->scratch, sizeof(csi->name));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->i;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->f;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\tif (buf->len <= sizeof(csi->string))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(csi->string, buf->scratch, buf->len);\n\t\t\t\t\t\tcsi->string_len = buf->len;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsi->obj = pdf_new_string(ctx, buf->scratch, buf->len);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\tpdf_clear_stack(ctx, csi);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in content stream\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (tok != PDF_TOK_EOF);\n\t\t}\n\t\tfz_always(ctx)\n\t\t{\n\t\t\tpdf_clear_stack(ctx, csi);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tint caught = fz_caught(ctx);\n\t\t\tif (cookie)\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t{\n\t\t\t\t\tcookie->incomplete++;\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t\t/* ignore minor errors */ ;\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* If we do catch an error, then reset ourselves to a base lexing state */\n\t\t\tin_text_array = 0;\n\t\t}\n\t}\n\twhile (tok != PDF_TOK_EOF);\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-interpret.c",
        "crashing_line": "\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);",
        "crashing_line_number": 948
      },
      {
        "function_name": "pdf_process_contents",
        "function_body": "void\npdf_process_contents(fz_context *ctx, pdf_processor *proc, pdf_document *doc, pdf_obj *rdb, pdf_obj *stmobj, fz_cookie *cookie)\n{\n\tpdf_csi csi;\n\tpdf_lexbuf buf;\n\tfz_stream *stm = NULL;\n\n\tif (!stmobj)\n\t\treturn;\n\n\tfz_var(stm);\n\n\tpdf_lexbuf_init(ctx, &buf, PDF_LEXBUF_SMALL);\n\tpdf_init_csi(ctx, &csi, doc, rdb, &buf, cookie);\n\n\tfz_try(ctx)\n\t{\n\t\tfz_defer_reap_start(ctx);\n\t\tstm = pdf_open_contents_stream(ctx, doc, stmobj);\n\t\tpdf_process_stream(ctx, proc, &csi, stm);\n\t\tpdf_process_end(ctx, proc, &csi);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_defer_reap_end(ctx);\n\t\tfz_drop_stream(ctx, stm);\n\t\tpdf_clear_stack(ctx, &csi);\n\t\tpdf_lexbuf_fin(ctx, &buf);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tproc->close_processor = NULL; /* aborted run, don't warn about unclosed processor */\n\t\tfz_rethrow(ctx);\n\t}\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-interpret.c",
        "crashing_line": "\t\tpdf_process_stream(ctx, proc, &csi, stm);",
        "crashing_line_number": 1042
      },
      {
        "function_name": "pdf_run_page_contents_with_usage_imp",
        "function_body": "static void\npdf_run_page_contents_with_usage_imp(fz_context *ctx, pdf_document *doc, pdf_page *page, fz_device *dev, fz_matrix ctm, const char *usage, fz_cookie *cookie)\n{\n\tfz_matrix page_ctm;\n\tpdf_obj *resources;\n\tpdf_obj *contents;\n\tfz_rect mediabox;\n\tpdf_processor *proc = NULL;\n\tfz_default_colorspaces *default_cs = NULL;\n\tfz_colorspace *colorspace = NULL;\n\n\tfz_var(proc);\n\tfz_var(colorspace);\n\tfz_var(default_cs);\n\n\tif (cookie && page->super.incomplete)\n\t\tcookie->incomplete = 1;\n\n\tfz_try(ctx)\n\t{\n\t\tdefault_cs = pdf_load_default_colorspaces(ctx, doc, page);\n\t\tif (default_cs)\n\t\t\tfz_set_default_colorspaces(ctx, dev, default_cs);\n\n\t\tpdf_page_transform(ctx, page, &mediabox, &page_ctm);\n\t\tctm = fz_concat(page_ctm, ctm);\n\t\tmediabox = fz_transform_rect(mediabox, ctm);\n\n\t\tresources = pdf_page_resources(ctx, page);\n\t\tcontents = pdf_page_contents(ctx, page);\n\n\t\tif (page->transparency)\n\t\t{\n\t\t\tpdf_obj *group = pdf_page_group(ctx, page);\n\n\t\t\tif (group)\n\t\t\t{\n\t\t\t\tpdf_obj *cs = pdf_dict_get(ctx, group, PDF_NAME(CS));\n\t\t\t\tif (cs)\n\t\t\t\t{\n\t\t\t\t\tfz_try(ctx)\n\t\t\t\t\t\tcolorspace = pdf_load_colorspace(ctx, cs);\n\t\t\t\t\tfz_catch(ctx)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t\t\t\t\tfz_warn(ctx, \"Ignoring Page blending colorspace.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fz_is_valid_blend_colorspace(ctx, colorspace))\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"Ignoring invalid Page blending colorspace: %s.\", colorspace->name);\n\t\t\t\t\t\tfz_drop_colorspace(ctx, colorspace);\n\t\t\t\t\t\tcolorspace = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_default_output_intent(ctx, default_cs));\n\n\t\t\tfz_begin_group(ctx, dev, mediabox, colorspace, 1, 0, 0, 1);\n\t\t}\n\n\t\tproc = pdf_new_run_processor(ctx, dev, ctm, usage, NULL, default_cs, cookie);\n\t\tpdf_process_contents(ctx, proc, doc, resources, contents, cookie);\n\t\tpdf_close_processor(ctx, proc);\n\n\t\tif (page->transparency)\n\t\t{\n\t\t\tfz_end_group(ctx, dev);\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tpdf_drop_processor(ctx, proc);\n\t\tfz_drop_colorspace(ctx, colorspace);\n\t\tfz_drop_default_colorspaces(ctx, default_cs);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-run.c",
        "crashing_line": "\t\tpdf_process_contents(ctx, proc, doc, resources, contents, cookie);",
        "crashing_line_number": 132
      },
      {
        "function_name": "pdf_run_page_contents_with_usage",
        "function_body": "void pdf_run_page_contents_with_usage(fz_context *ctx, pdf_page *page, fz_device *dev, fz_matrix ctm, const char *usage, fz_cookie *cookie)\n{\n\tpdf_document *doc = page->doc;\n\tint nocache;\n\n\tnocache = !!(dev->hints & FZ_NO_CACHE);\n\tif (nocache)\n\t\tpdf_mark_xref(ctx, doc);\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_run_page_contents_with_usage_imp(ctx, doc, page, dev, ctm, usage, cookie);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tif (nocache)\n\t\t\tpdf_clear_xref_to_mark(ctx, doc);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-run.c",
        "crashing_line": "\t\tpdf_run_page_contents_with_usage_imp(ctx, doc, page, dev, ctm, usage, cookie);",
        "crashing_line_number": 163
      },
      {
        "function_name": "pdf_run_page_contents",
        "function_body": "void pdf_run_page_contents(fz_context *ctx, pdf_page *page, fz_device *dev, fz_matrix ctm, fz_cookie *cookie)\n{\n\tpdf_run_page_contents_with_usage(ctx, page, dev, ctm, \"View\", cookie);\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-run.c",
        "crashing_line": "\tpdf_run_page_contents_with_usage(ctx, page, dev, ctm, \"View\", cookie);",
        "crashing_line_number": 178
      },
      {
        "function_name": "fz_run_page_contents",
        "function_body": "void\nfz_run_page_contents(fz_context *ctx, fz_page *page, fz_device *dev, fz_matrix transform, fz_cookie *cookie)\n{\n\tif (page && page->run_page_contents)\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tpage->run_page_contents(ctx, page, dev, transform, cookie);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tdev->close_device = NULL; /* aborted run, don't warn about unclosed device */\n\t\t\tif (fz_caught(ctx) != FZ_ERROR_ABORT)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}",
        "file_path": "/src/mupdf/source/fitz/document.c",
        "crashing_line": "\t\t\tpage->run_page_contents(ctx, page, dev, transform, cookie);",
        "crashing_line_number": 580
      },
      {
        "function_name": "fz_run_page",
        "function_body": "void\nfz_run_page(fz_context *ctx, fz_page *page, fz_device *dev, fz_matrix transform, fz_cookie *cookie)\n{\n\tfz_run_page_contents(ctx, page, dev, transform, cookie);\n\tfz_run_page_annots(ctx, page, dev, transform, cookie);\n\tfz_run_page_widgets(ctx, page, dev, transform, cookie);\n}",
        "file_path": "/src/mupdf/source/fitz/document.c",
        "crashing_line": "\tfz_run_page_contents(ctx, page, dev, transform, cookie);",
        "crashing_line_number": 630
      },
      {
        "function_name": "fz_new_pixmap_from_page_with_separations",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/util.c",
        "crashing_line": "",
        "crashing_line_number": 197
      },
      {
        "function_name": "fz_new_pixmap_from_page_number_with_separations",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/util.c",
        "crashing_line": "",
        "crashing_line_number": 227
      },
      {
        "function_name": "fz_new_pixmap_from_page_number",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/util.c",
        "crashing_line": "",
        "crashing_line_number": 216
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void zend_emit_jmp_null(znode *obj_node)\n{\n\tuint32_t jmp_null_opnum = get_next_op_number();\n\tzend_emit_op(NULL, ZEND_JMP_NULL, obj_node, NULL);\n\tzend_stack_push(&CG(short_circuiting_opnums), &jmp_null_opnum);\n}\n",
    "target": 1,
    "idx": 1024436,
    "stack_trace": [
      {
        "function_name": "zend_gc_delref",
        "function_body": "static zend_always_inline uint32_t zend_gc_delref(zend_refcounted_h *p) {\n\tZEND_ASSERT(p->refcount > 0);\n\tZEND_RC_MOD_CHECK(p);\n\treturn --(p->refcount);\n}",
        "file_path": "/src/php-src/Zend/zend_types.h",
        "crashing_line": "\tZEND_ASSERT(p->refcount > 0);",
        "crashing_line_number": 1162
      },
      {
        "function_name": "zval_delref_p",
        "function_body": "static zend_always_inline uint32_t zval_delref_p(zval* pz) {\n\tZEND_ASSERT(Z_REFCOUNTED_P(pz));\n\treturn GC_DELREF(Z_COUNTED_P(pz));\n}",
        "file_path": "/src/php-src/Zend/zend_types.h",
        "crashing_line": "\treturn GC_DELREF(Z_COUNTED_P(pz));",
        "crashing_line_number": 1198
      },
      {
        "function_name": "zval_ptr_dtor_nogc",
        "function_body": "static zend_always_inline void zval_ptr_dtor_nogc(zval *zval_ptr)\n{\n\tif (Z_REFCOUNTED_P(zval_ptr) && !Z_DELREF_P(zval_ptr)) {\n\t\trc_dtor_func(Z_COUNTED_P(zval_ptr));\n\t}\n}",
        "file_path": "/src/php-src/Zend/zend_variables.h",
        "crashing_line": "\tif (Z_REFCOUNTED_P(zval_ptr) && !Z_DELREF_P(zval_ptr)) {",
        "crashing_line_number": 34
      },
      {
        "function_name": "destroy_op_array",
        "function_body": "ZEND_API void destroy_op_array(zend_op_array *op_array)\n{\n\tuint32_t i;\n\n\tif (op_array->static_variables) {\n\t\tHashTable *ht = ZEND_MAP_PTR_GET(op_array->static_variables_ptr);\n\t\tif (ht && !(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {\n\t\t\tif (GC_DELREF(ht) == 0) {\n\t\t\t\tzend_array_destroy(ht);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((op_array->fn_flags & ZEND_ACC_HEAP_RT_CACHE)\n\t && ZEND_MAP_PTR(op_array->run_time_cache)) {\n\t\tefree(ZEND_MAP_PTR(op_array->run_time_cache));\n\t}\n\n\tif (op_array->function_name) {\n\t\tzend_string_release_ex(op_array->function_name, 0);\n\t}\n\n\tif (!op_array->refcount || --(*op_array->refcount) > 0) {\n\t\treturn;\n\t}\n\n\tefree_size(op_array->refcount, sizeof(*(op_array->refcount)));\n\n\tif (op_array->vars) {\n\t\ti = op_array->last_var;\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tzend_string_release_ex(op_array->vars[i], 0);\n\t\t}\n\t\tefree(op_array->vars);\n\t}\n\n\tif (op_array->literals) {\n\t\tzval *literal = op_array->literals;\n\t\tzval *end = literal + op_array->last_literal;\n\t \twhile (literal < end) {\n\t\t\tzval_ptr_dtor_nogc(literal);\n\t\t\tliteral++;\n\t\t}\n\t\tif (ZEND_USE_ABS_CONST_ADDR\n\t\t || !(op_array->fn_flags & ZEND_ACC_DONE_PASS_TWO)) {\n\t\t\tefree(op_array->literals);\n\t\t}\n\t}\n\tefree(op_array->opcodes);\n\n\tif (op_array->doc_comment) {\n\t\tzend_string_release_ex(op_array->doc_comment, 0);\n\t}\n\tif (op_array->attributes) {\n\t\tzend_hash_release(op_array->attributes);\n\t}\n\tif (op_array->live_range) {\n\t\tefree(op_array->live_range);\n\t}\n\tif (op_array->try_catch_array) {\n\t\tefree(op_array->try_catch_array);\n\t}\n\tif (zend_extension_flags & ZEND_EXTENSIONS_HAVE_OP_ARRAY_DTOR) {\n\t\tif (op_array->fn_flags & ZEND_ACC_DONE_PASS_TWO) {\n\t\t\tzend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_op_array_dtor_handler, op_array);\n\t\t}\n\t}\n\tif (op_array->arg_info) {\n\t\tuint32_t num_args = op_array->num_args;\n\t\tzend_arg_info *arg_info = op_array->arg_info;\n\n\t\tif (op_array->fn_flags & ZEND_ACC_HAS_RETURN_TYPE) {\n\t\t\targ_info--;\n\t\t\tnum_args++;\n\t\t}\n\t\tif (op_array->fn_flags & ZEND_ACC_VARIADIC) {\n\t\t\tnum_args++;\n\t\t}\n\t\tfor (i = 0 ; i < num_args; i++) {\n\t\t\tif (arg_info[i].name) {\n\t\t\t\tzend_string_release_ex(arg_info[i].name, 0);\n\t\t\t}\n\t\t\tzend_type_release(arg_info[i].type, /* persistent */ 0);\n\t\t}\n\t\tefree(arg_info);\n\t}\n}",
        "file_path": "/src/php-src/Zend/zend_opcode.c",
        "crashing_line": "\t\t\tzval_ptr_dtor_nogc(literal);",
        "crashing_line_number": 489
      },
      {
        "function_name": "fuzzer_do_request",
        "function_body": "int fuzzer_do_request(zend_file_handle *file_handle, char *filename)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\tSG(headers_sent) = 1;\n\tSG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_op_array *op_array = zend_compile_file(file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\t\t/*retval = php_execute_script(file_handle);*/\n\t} zend_end_try();",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-sapi.c",
        "crashing_line": "\t\t\tdestroy_op_array(op_array);",
        "crashing_line_number": 227
      },
      {
        "function_name": "fuzzer_do_request_from_buffer",
        "function_body": "int fuzzer_do_request_from_buffer(char *filename, char *data, size_t data_len)\n{\n\tzend_file_handle file_handle;\n\tfile_handle.filename = filename;\n\tfile_handle.free_filename = 0;\n\tfile_handle.opened_path = NULL;\n\tfile_handle.handle.stream.handle = NULL;\n\tfile_handle.handle.stream.reader = (zend_stream_reader_t)_php_stream_read;\n\tfile_handle.handle.stream.fsizer = NULL;\n\tfile_handle.handle.stream.isatty = 0;\n\tfile_handle.handle.stream.closer   = NULL;\n\tfile_handle.buf = data;\n\tfile_handle.len = data_len;\n\tfile_handle.type = ZEND_HANDLE_STREAM;\n\n\treturn fuzzer_do_request(&file_handle, filename);\n}",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-sapi.c",
        "crashing_line": "\treturn fuzzer_do_request(&file_handle, filename);",
        "crashing_line_number": 269
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static void\ncompact_list (\n  FriBidiRun *list\n)\n{\n  fribidi_assert (list);\n\n  if (list->next)\n    for_run_list (list, list)\n      if (RL_TYPE (list->prev) == RL_TYPE (list)\n\t  && RL_LEVEL (list->prev) == RL_LEVEL (list)\n          && RL_BRACKET_TYPE(list) == FRIBIDI_NO_BRACKET /* Don't join brackets! */\n          && RL_BRACKET_TYPE(list->prev) == FRIBIDI_NO_BRACKET\n          )\n      list = merge_with_prev (list);\n}\nstatic void\ncompact_neutrals (\n  FriBidiRun *list\n)\n{\n  fribidi_assert (list);\n\n  if (list->next)\n    {\n      for_run_list (list, list)\n      {\n\tif (RL_LEVEL (list->prev) == RL_LEVEL (list)\n\t    &&\n\t    ((RL_TYPE (list->prev) == RL_TYPE (list)\n\t      || (FRIBIDI_IS_NEUTRAL (RL_TYPE (list->prev))\n\t\t  && FRIBIDI_IS_NEUTRAL (RL_TYPE (list)))))\n            && RL_BRACKET_TYPE(list) == FRIBIDI_NO_BRACKET /* Don't join brackets! */\n            && RL_BRACKET_TYPE(list->prev) == FRIBIDI_NO_BRACKET\n            )\n\t  list = merge_with_prev (list);\n      }\n    }\n}\n",
    "target": 1,
    "idx": 1034696,
    "stack_trace": [
      {
        "function_name": "merge_with_prev",
        "function_body": "",
        "file_path": "/work/build/../../src/fribidi/lib/fribidi-bidi.c",
        "crashing_line": "",
        "crashing_line_number": 93
      },
      {
        "function_name": "compact_list",
        "function_body": "static void\ncompact_list (\n  FriBidiRun *list\n)\n{\n  fribidi_assert (list);\n\n  if (list->next)\n    for_run_list (list, list)\n      if (RL_TYPE (list->prev) == RL_TYPE (list)\n\t  && RL_LEVEL (list->prev) == RL_LEVEL (list)\n          && RL_ISOLATE_LEVEL (list->prev) == RL_ISOLATE_LEVEL (list)\n          && RL_BRACKET_TYPE(list) == FRIBIDI_NO_BRACKET /* Don't join brackets! */\n          && RL_BRACKET_TYPE(list->prev) == FRIBIDI_NO_BRACKET\n          )\n      list = merge_with_prev (list);\n}",
        "file_path": "/work/build/../../src/fribidi/lib/fribidi-bidi.c",
        "crashing_line": "          )",
        "crashing_line_number": 113
      },
      {
        "function_name": "fribidi_get_par_embedding_levels_ex",
        "function_body": "FRIBIDI_ENTRY FriBidiLevel\nfribidi_get_par_embedding_levels_ex (\n  /* input */\n  const FriBidiCharType *bidi_types,\n  const FriBidiBracketType *bracket_types,\n  const FriBidiStrIndex len,\n  /* input and output */\n  FriBidiParType *pbase_dir,\n  /* output */\n  FriBidiLevel *embedding_levels\n)\n{\n  FriBidiLevel base_level, max_level = 0;\n  FriBidiParType base_dir;\n  FriBidiRun *main_run_list = NULL, *explicits_list = NULL, *pp;\n  fribidi_boolean status = false;\n  int max_iso_level = 0;\n\n  if UNLIKELY\n    (!len)\n    {\n      status = true;\n      goto out;\n    }\n\n  DBG (\"in fribidi_get_par_embedding_levels\");\n\n  fribidi_assert (bidi_types);\n  fribidi_assert (pbase_dir);\n  fribidi_assert (embedding_levels);\n\n  /* Determinate character types */\n  {\n    /* Get run-length encoded character types */\n    main_run_list = run_list_encode_bidi_types (bidi_types, bracket_types, len);\n    if UNLIKELY\n      (!main_run_list) goto out;\n  }\n\n  /* Find base level */\n  /* If no strong base_dir was found, resort to the weak direction\n     that was passed on input. */\n  base_level = FRIBIDI_DIR_TO_LEVEL (*pbase_dir);\n  if (!FRIBIDI_IS_STRONG (*pbase_dir))\n    /* P2. P3. Search for first strong character and use its direction as\n       base direction */\n    {\n      int valid_isolate_count = 0;\n      for_run_list (pp, main_run_list)\n        {\n          if (RL_TYPE(pp) == FRIBIDI_TYPE_PDI)\n            {\n              /* Ignore if there is no matching isolate */\n              if (valid_isolate_count>0)\n                valid_isolate_count--;\n            }\n          else if (FRIBIDI_IS_ISOLATE(RL_TYPE(pp)))\n            valid_isolate_count++;\n          else if (valid_isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (pp)))\n            {\n              base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (pp));\n              *pbase_dir = FRIBIDI_LEVEL_TO_DIR (base_level);\n              break;\n            }\n        }\n    }\n  base_dir = FRIBIDI_LEVEL_TO_DIR (base_level);\n  DBG2 (\"  base level : %c\", fribidi_char_from_level (base_level));\n  DBG2 (\"  base dir   : %s\", fribidi_get_bidi_type_name (base_dir));\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* Explicit Levels and Directions */\n  DBG (\"explicit levels and directions\");\n  {\n    FriBidiLevel level, new_level = 0;\n    int isolate_level = 0;\n    FriBidiCharType override, new_override;\n    FriBidiStrIndex i;\n    int stack_size, over_pushed, first_interval;\n    int valid_isolate_count = 0;\n    int isolate_overflow = 0;\n    int isolate = 0; /* The isolate status flag */\n    struct\n    {\n      FriBidiCharType override;\t/* only LTR, RTL and ON are valid */\n      FriBidiLevel level;\n      int isolate;\n      int isolate_level;\n    } status_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n    FriBidiRun temp_link;\n    FriBidiRun *run_per_isolate_level[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n    int prev_isolate_level = 0; /* When running over the isolate levels, remember the previous level */\n\n    memset(run_per_isolate_level, 0, sizeof(run_per_isolate_level[0])\n           * FRIBIDI_BIDI_MAX_RESOLVED_LEVELS);\n\n/* explicits_list is a list like main_run_list, that holds the explicit\n   codes that are removed from main_run_list, to reinsert them later by\n   calling the shadow_run_list.\n*/\n    explicits_list = new_run_list ();\n    if UNLIKELY\n      (!explicits_list) goto out;\n\n    /* X1. Begin by setting the current embedding level to the paragraph\n       embedding level. Set the directional override status to neutral,\n       and directional isolate status to false.\n\n       Process each character iteratively, applying rules X2 through X8.\n       Only embedding levels from 0 to 123 are valid in this phase. */\n\n    level = base_level;\n    override = FRIBIDI_TYPE_ON;\n    /* stack */\n    stack_size = 0;\n    over_pushed = 0;\n    first_interval = 0;\n    valid_isolate_count = 0;\n    isolate_overflow = 0;\n\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType this_type = RL_TYPE (pp);\n      RL_ISOLATE_LEVEL (pp) = isolate_level;\n\n      if (FRIBIDI_IS_EXPLICIT_OR_BN (this_type))\n\t{\n\t  if (FRIBIDI_IS_STRONG (this_type))\n\t    {\t\t\t/* LRE, RLE, LRO, RLO */\n\t      /* 1. Explicit Embeddings */\n\t      /*   X2. With each RLE, compute the least greater odd\n\t         embedding level. */\n\t      /*   X3. With each LRE, compute the least greater even\n\t         embedding level. */\n\t      /* 2. Explicit Overrides */\n\t      /*   X4. With each RLO, compute the least greater odd\n\t         embedding level. */\n\t      /*   X5. With each LRO, compute the least greater even\n\t         embedding level. */\n\t      new_override = FRIBIDI_EXPLICIT_TO_OVERRIDE_DIR (this_type);\n\t      for (i = RL_LEN (pp); i; i--)\n\t\t{\n\t\t  new_level =\n\t\t    ((level + FRIBIDI_DIR_TO_LEVEL (this_type) + 2) & ~1) -\n\t\t    FRIBIDI_DIR_TO_LEVEL (this_type);\n                  isolate = 0;\n\t\t  PUSH_STATUS;\n\t\t}\n\t    }\n\t  else if (this_type == FRIBIDI_TYPE_PDF)\n\t    {\n\t      /* 3. Terminating Embeddings and overrides */\n\t      /*   X7. With each PDF, determine the matching embedding or\n\t         override code. */\n              for (i = RL_LEN (pp); i; i--)\n                {\n                  if (stack_size && status_stack[stack_size-1].isolate != 0)\n                    break;\n                  POP_STATUS;\n                }\n\t    }\n\n\t  /* X9. Remove all RLE, LRE, RLO, LRO, PDF, and BN codes. */\n\t  /* Remove element and add it to explicits_list */\n\t  RL_LEVEL (pp) = FRIBIDI_SENTINEL;\n\t  temp_link.next = pp->next;\n\t  move_node_before (pp, explicits_list);\n\t  pp = &temp_link;\n\t}\n      else if (this_type == FRIBIDI_TYPE_PDI)\n        /* X6a. pop the direction of the stack */\n        {\n          for (i = RL_LEN (pp); i; i--)\n            {\n              if (isolate_overflow > 0)\n                {\n                  isolate_overflow--;\n                  RL_LEVEL (pp) = level;\n                }\n\n              else if (valid_isolate_count > 0)\n                {\n                  /* Pop away all LRE,RLE,LRO, RLO levels\n                     from the stack, as these are implicitly\n                     terminated by the PDI */\n                  while (stack_size && !status_stack[stack_size-1].isolate)\n                    POP_STATUS;\n                  over_pushed = 0; /* The PDI resets the overpushed! */\n                  POP_STATUS;\n                  if (isolate_level>0)\n                    isolate_level--;\n                  valid_isolate_count--;\n                  RL_LEVEL (pp) = level;\n                  RL_ISOLATE_LEVEL (pp) = isolate_level;\n                }\n              else\n                {\n                  /* Ignore isolated PDI's by turning them into ON's */\n                  RL_TYPE (pp) = FRIBIDI_TYPE_ON;\n                  RL_LEVEL (pp) = level;\n                }\n            }\n        }\n      else if (FRIBIDI_IS_ISOLATE(this_type))\n        {\n          /* TBD support RL_LEN > 1 */\n          new_override = FRIBIDI_TYPE_ON;\n          isolate = 1;\n          if (this_type == FRIBIDI_TYPE_LRI)\n            new_level = level + 2 - (level%2);\n          else if (this_type == FRIBIDI_TYPE_RLI)\n            new_level = level + 1 + (level%2);\n          else if (this_type == FRIBIDI_TYPE_FSI)\n            {\n              /* Search for a local strong character until we\n                 meet the corresponding PDI or the end of the\n                 paragraph */\n              FriBidiRun *fsi_pp;\n              int isolate_count = 0;\n              int fsi_base_level = 0;\n              for_run_list (fsi_pp, pp)\n                {\n                  if (RL_TYPE(fsi_pp) == FRIBIDI_TYPE_PDI)\n                    {\n                      isolate_count--;\n                      if (valid_isolate_count < 0)\n                        break;\n                    }\n                  else if (FRIBIDI_IS_ISOLATE(RL_TYPE(fsi_pp)))\n                    isolate_count++;\n                  else if (isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (fsi_pp)))\n                    {\n                      fsi_base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (fsi_pp));\n                      break;\n                    }\n                }\n\n              /* Same behavior like RLI and LRI above */\n              if (FRIBIDI_LEVEL_IS_RTL (fsi_base_level))\n                new_level = level + 1 + (level%2);\n              else\n                new_level = level + 2 - (level%2);\n            }\n\n\t  RL_LEVEL (pp) = level;\n          RL_ISOLATE_LEVEL (pp) = isolate_level;\n          if (isolate_level < FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL-1)\n              isolate_level++;\n\n\t  if (!FRIBIDI_IS_NEUTRAL (override))\n\t    RL_TYPE (pp) = override;\n\n          if (new_level <= FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL)\n            {\n              valid_isolate_count++;\n              PUSH_STATUS;\n              level = new_level;\n            }\n          else\n            isolate_overflow += 1;\n        }\n      else if (this_type == FRIBIDI_TYPE_BS)\n\t{\n\t  /* X8. All explicit directional embeddings and overrides are\n\t     completely terminated at the end of each paragraph. Paragraph\n\t     separators are not included in the embedding. */\n\t  break;\n\t}\n      else\n\t{\n\t  /* X6. For all types besides RLE, LRE, RLO, LRO, and PDF:\n\t     a. Set the level of the current character to the current\n\t     embedding level.\n\t     b. Whenever the directional override status is not neutral,\n\t     reset the current character type to the directional override\n\t     status. */\n\t  RL_LEVEL (pp) = level;\n\t  if (!FRIBIDI_IS_NEUTRAL (override))\n\t    RL_TYPE (pp) = override;\n\t}\n    }\n\n    /* Build the isolate_level connections */\n    prev_isolate_level = 0;\n    for_run_list (pp, main_run_list)\n    {\n      int isolate_level = RL_ISOLATE_LEVEL (pp);\n      int i;\n\n      /* When going from an upper to a lower level, zero out all higher levels\n         in order not erroneous connections! */\n      if (isolate_level<prev_isolate_level)\n        for (i=isolate_level+1; i<=prev_isolate_level; i++)\n          run_per_isolate_level[i]=0;\n      prev_isolate_level = isolate_level;\n      \n      if (run_per_isolate_level[isolate_level])\n        {\n          run_per_isolate_level[isolate_level]->next_isolate = pp;\n          pp->prev_isolate = run_per_isolate_level[isolate_level];\n        }\n      run_per_isolate_level[isolate_level] = pp;\n    }\n\n    /* Implementing X8. It has no effect on a single paragraph! */\n    level = base_level;\n    override = FRIBIDI_TYPE_ON;\n    stack_size = 0;\n    over_pushed = 0;\n  }\n  /* X10. The remaining rules are applied to each run of characters at the\n     same level. For each run, determine the start-of-level-run (sor) and\n     end-of-level-run (eor) type, either L or R. This depends on the\n     higher of the two levels on either side of the boundary (at the start\n     or end of the paragraph, the level of the 'other' run is the base\n     embedding level). If the higher level is odd, the type is R, otherwise\n     it is L. */\n  /* Resolving Implicit Levels can be done out of X10 loop, so only change\n     of Resolving Weak Types and Resolving Neutral Types is needed. */\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_bidi_string (bidi_types, len);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 4. Resolving weak types. Also calculate the maximum isolate level */\n  max_iso_level = 0;\n  DBG (\"4a. resolving weak types\");\n  {\n    int last_strong_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n    FriBidiCharType prev_type_orig;\n    fribidi_boolean w4;\n\n    last_strong_stack[0] = base_dir;\n\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiCharType prev_type, this_type, next_type;\n      FriBidiRun *ppp_prev, *ppp_next;\n      int iso_level;\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      this_type = RL_TYPE (pp);\n      iso_level = RL_ISOLATE_LEVEL(pp);\n\n      if (iso_level > max_iso_level)\n        max_iso_level = iso_level;\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = RL_TYPE(ppp_prev);\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = RL_TYPE(ppp_next);\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_STRONG (prev_type))\n\tlast_strong_stack[iso_level] = prev_type;\n\n      /* W1. NSM\n         Examine each non-spacing mark (NSM) in the level run, and change the\n         type of the NSM to the type of the previous character. If the NSM\n         is at the start of the level run, it will get the type of sor. */\n      /* Implementation note: it is important that if the previous character\n         is not sor, then we should merge this run with the previous,\n         because of rules like W5, that we assume all of a sequence of\n         adjacent ETs are in one FriBidiRun. */\n      if (this_type == FRIBIDI_TYPE_NSM)\n\t{\n          /* New rule in Unicode 6.3 */\n          if (FRIBIDI_IS_ISOLATE (RL_TYPE (pp->prev)))\n              RL_TYPE(pp) = FRIBIDI_TYPE_ON;\n\n\t  if (RL_LEVEL (ppp_prev) == RL_LEVEL (pp))\n            {\n              if (ppp_prev == pp->prev)\n                pp = merge_with_prev (pp);\n            }\n\t  else\n\t    RL_TYPE (pp) = prev_type;\n\n\t  if (prev_type == next_type && RL_LEVEL (pp) == RL_LEVEL (pp->next))\n\t    {\n              if (ppp_next == pp->next)\n                pp = merge_with_prev (pp->next);\n\t    }\n\t  continue;\t\t/* As we know the next condition cannot be true. */\n\t}\n\n      /* W2: European numbers. */\n      if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_AL)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_AN;\n\n\t  /* Resolving dependency of loops for rules W1 and W2, so we\n\t     can merge them in one loop. */\n\t  if (next_type == FRIBIDI_TYPE_NSM)\n\t    RL_TYPE (ppp_next) = FRIBIDI_TYPE_AN;\n\t}\n    }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n    /* The last iso level is used to invalidate the the last strong values when going from\n       a higher to a lower iso level. When this occur, all \"last_strong\" values are\n       set to the base_dir. */\n    last_strong_stack[0] = base_dir;\n\n    DBG (\"4b. resolving weak types. W4 and W5\");\n\n    /* Resolving dependency of loops for rules W4 and W5, W5 may\n       want to prevent W4 to take effect in the next turn, do this\n       through \"w4\". */\n    w4 = true;\n    /* Resolving dependency of loops for rules W4 and W5 with W7,\n       W7 may change an EN to L but it sets the prev_type_orig if needed,\n       so W4 and W5 in next turn can still do their works. */\n    prev_type_orig = FRIBIDI_TYPE_ON;\n\n    /* Each isolate level has its own memory of the last strong character */\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiCharType prev_type, this_type, next_type;\n      int iso_level;\n      FriBidiRun *ppp_prev, *ppp_next;\n\n      this_type = RL_TYPE (pp);\n      iso_level = RL_ISOLATE_LEVEL(pp);\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = RL_TYPE(ppp_prev);\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = RL_TYPE(ppp_next);\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_STRONG (prev_type))\n\tlast_strong_stack[iso_level] = prev_type;\n\n      /* W2 ??? */\n\n      /* W3: Change ALs to R. */\n      if (this_type == FRIBIDI_TYPE_AL)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_RTL;\n\t  w4 = true;\n\t  prev_type_orig = FRIBIDI_TYPE_ON;\n\t  continue;\n\t}\n\n      /* W4. A single european separator changes to a european number.\n         A single common separator between two numbers of the same type\n         changes to that type. */\n      if (w4\n\t  && RL_LEN (pp) == 1 && FRIBIDI_IS_ES_OR_CS (this_type)\n\t  && FRIBIDI_IS_NUMBER (prev_type_orig)\n\t  && prev_type_orig == next_type\n\t  && (prev_type_orig == FRIBIDI_TYPE_EN\n\t      || this_type == FRIBIDI_TYPE_CS))\n\t{\n\t  RL_TYPE (pp) = prev_type;\n\t  this_type = RL_TYPE (pp);\n\t}\n      w4 = true;\n\n      /* W5. A sequence of European terminators adjacent to European\n         numbers changes to All European numbers. */\n      if (this_type == FRIBIDI_TYPE_ET\n\t  && (prev_type_orig == FRIBIDI_TYPE_EN\n\t      || next_type == FRIBIDI_TYPE_EN))\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_EN;\n\t  w4 = false;\n\t  this_type = RL_TYPE (pp);\n\t}\n\n      /* W6. Otherwise change separators and terminators to other neutral. */\n      if (FRIBIDI_IS_NUMBER_SEPARATOR_OR_TERMINATOR (this_type))\n\tRL_TYPE (pp) = FRIBIDI_TYPE_ON;\n\n      /* W7. Change european numbers to L. */\n      if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_LTR)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_LTR;\n\t  prev_type_orig = (RL_LEVEL (pp) == RL_LEVEL (pp->next) ?\n\t\t\t    FRIBIDI_TYPE_EN : FRIBIDI_TYPE_ON);\n\t}\n      else\n\tprev_type_orig = PREV_TYPE_OR_SOR (pp->next);\n    }\n  }\n\n  compact_neutrals (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 5. Resolving Neutral Types */\n\n  DBG (\"5. resolving neutral types - N0\");\n  {\n    /*  BD16 - Build list of all pairs*/\n    int num_iso_levels = max_iso_level + 1;\n    FriBidiPairingNode *pairing_nodes = NULL;\n    FriBidiRun *local_bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL][LOCAL_BRACKET_SIZE];\n    FriBidiRun **bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];\n    int bracket_stack_size[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];\n    int last_level = RL_LEVEL(main_run_list);\n    int last_iso_level = 0;\n\n    memset(bracket_stack, 0, sizeof(bracket_stack[0])*num_iso_levels);\n    memset(bracket_stack_size, 0, sizeof(bracket_stack_size[0])*num_iso_levels);\n\n    /* populate the bracket_size. The first LOCAL_BRACKET_SIZE entries\n       of the stack are one the stack. Allocate the rest of the entries.\n     */\n    {\n      int iso_level;\n      for (iso_level=0; iso_level < LOCAL_BRACKET_SIZE; iso_level++)\n        bracket_stack[iso_level] = local_bracket_stack[iso_level];\n\n      for (iso_level=LOCAL_BRACKET_SIZE; iso_level < num_iso_levels; iso_level++)\n        bracket_stack[iso_level] = fribidi_malloc (sizeof (bracket_stack[0])\n                                                       * FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS);\n    }\n\n    /* Build the bd16 pair stack. */\n    for_run_list (pp, main_run_list)\n      {\n        int level = RL_LEVEL(pp);\n        int iso_level = RL_ISOLATE_LEVEL(pp);\n        FriBidiBracketType brack_prop = RL_BRACKET_TYPE(pp);\n\n        /* Interpret the isolating run sequence as such that they\n           end at a change in the level, unless the iso_level has been\n           raised. */\n        if (level != last_level && last_iso_level == iso_level)\n          bracket_stack_size[last_iso_level] = 0;\n\n        if (brack_prop!= FRIBIDI_NO_BRACKET\n            && RL_TYPE(pp)==FRIBIDI_TYPE_ON)\n          {\n            if (FRIBIDI_IS_BRACKET_OPEN(brack_prop))\n              {\n                if (bracket_stack_size[iso_level]==FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS)\n                  break;\n\n                /* push onto the pair stack */\n                bracket_stack[iso_level][bracket_stack_size[iso_level]++] = pp;\n              }\n            else\n              {\n                int stack_idx = bracket_stack_size[iso_level] - 1;\n                while (stack_idx >= 0)\n                  {\n                    FriBidiBracketType se_brack_prop = RL_BRACKET_TYPE(bracket_stack[iso_level][stack_idx]);\n                    if (FRIBIDI_BRACKET_ID(se_brack_prop) == FRIBIDI_BRACKET_ID(brack_prop))\n                      {\n                        bracket_stack_size[iso_level] = stack_idx;\n\n                        pairing_nodes = pairing_nodes_push(pairing_nodes,\n                                                           bracket_stack[iso_level][stack_idx],\n                                                           pp);\n                        break;\n                    }\n                    stack_idx--;\n                  }\n              }\n          }\n        last_level = level;\n        last_iso_level = iso_level;\n      }\n\n    /* The list must now be sorted for the next algo to work! */\n    sort_pairing_nodes(&pairing_nodes);\n\n# if DEBUG\n    if UNLIKELY\n    (fribidi_debug_status ())\n      {\n        print_pairing_nodes (pairing_nodes);\n      }\n# endif\t/* DEBUG */\n\n    /* Start the N0 */\n    {\n      FriBidiPairingNode *ppairs = pairing_nodes;\n      while (ppairs)\n        {\n          int embedding_level = ppairs->open->level; \n\n          /* Find matching strong. */\n          fribidi_boolean found = false;\n          FriBidiRun *ppn;\n          for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)\n            {\n              FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n\n              /* Calculate level like in resolve implicit levels below to prevent\n                 embedded levels not to match the base_level */\n              int this_level = RL_LEVEL (ppn) +\n                (FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n              /* N0b */\n              if (FRIBIDI_IS_STRONG (this_type) && this_level == embedding_level)\n                {\n                  RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = this_level%2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;\n                  found = true;\n                  break;\n                }\n            }\n\n          /* N0c */\n          /* Search for any strong type preceding and within the bracket pair */\n          if (!found)\n            {\n              /* Search for a preceding strong */\n              int prec_strong_level = embedding_level; /* TBDov! Extract from Isolate level in effect */\n              int iso_level = RL_ISOLATE_LEVEL(ppairs->open);\n              for (ppn = ppairs->open->prev; ppn->type != FRIBIDI_TYPE_SENTINEL; ppn=ppn->prev)\n                {\n                  FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n                  if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)\n                    {\n                      prec_strong_level = RL_LEVEL (ppn) +\n                        (FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n                      break;\n                    }\n                }\n\n              for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)\n                {\n                  FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n                  if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)\n                    {\n                      /* By constraint this is opposite the embedding direction,\n                         since we did not match the N0b rule. We must now\n                         compare with the preceding strong to establish whether\n                         to apply N0c1 (opposite) or N0c2 embedding */\n                      RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = prec_strong_level % 2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;\n                      found = true;\n                      break;\n                    }\n                }\n            }\n\n          ppairs = ppairs->next;\n        }\n\n      free_pairing_nodes(pairing_nodes);\n\n      if (num_iso_levels >= LOCAL_BRACKET_SIZE)\n        {\n          int i;\n          /* Only need to free the non static members */\n          for (i=LOCAL_BRACKET_SIZE; i<num_iso_levels; i++)\n            fribidi_free(bracket_stack[i]);\n        }\n\n      /* Remove the bracket property and re-compact */\n      {\n        const FriBidiBracketType NoBracket = FRIBIDI_NO_BRACKET;\n        for_run_list (pp, main_run_list)\n          pp->bracket_type = NoBracket;\n        compact_neutrals (main_run_list);\n      }\n    }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n  }\n\n  DBG (\"resolving neutral types - N1+N2\");\n  {\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType prev_type, this_type, next_type;\n      FriBidiRun *ppp_prev, *ppp_next;\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      /* \"European and Arabic numbers are treated as though they were R\"\n         FRIBIDI_CHANGE_NUMBER_TO_RTL does this. */\n      this_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE (pp));\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_prev));\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_next));\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_NEUTRAL (this_type))\n\tRL_TYPE (pp) = (prev_type == next_type) ?\n\t  /* N1. */ prev_type :\n\t  /* N2. */ FRIBIDI_EMBEDDING_DIRECTION (pp);\n    }\n  }\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 6. Resolving implicit levels */\n  DBG (\"resolving implicit levels\");\n  {\n    max_level = base_level;\n\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType this_type;\n      int level;\n\n      this_type = RL_TYPE (pp);\n      level = RL_LEVEL (pp);\n\n      /* I1. Even */\n      /* I2. Odd */\n      if (FRIBIDI_IS_NUMBER (this_type))\n\tRL_LEVEL (pp) = (level + 2) & ~1;\n      else\n\tRL_LEVEL (pp) =\n\t  level +\n\t  (FRIBIDI_LEVEL_IS_RTL (level) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n      if (RL_LEVEL (pp) > max_level)\n\tmax_level = RL_LEVEL (pp);\n    }\n  }\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_bidi_string (bidi_types, len);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n/* Reinsert the explicit codes & BN's that are already removed, from the\n   explicits_list to main_run_list. */\n  DBG (\"reinserting explicit codes\");\n  if UNLIKELY\n    (explicits_list->next != explicits_list)\n    {\n      register FriBidiRun *p;\n      register fribidi_boolean stat =\n\tshadow_run_list (main_run_list, explicits_list, true);\n      explicits_list = NULL;\n      if UNLIKELY\n\t(!stat) goto out;\n\n      /* Set level of inserted explicit chars to that of their previous\n       * char, such that they do not affect reordering. */\n      p = main_run_list->next;\n      if (p != main_run_list && p->level == FRIBIDI_SENTINEL)\n\tp->level = base_level;\n      for_run_list (p, main_run_list) if (p->level == FRIBIDI_SENTINEL)\n\tp->level = p->prev->level;\n    }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  DBG (\"reset the embedding levels, 1, 2, 3.\");\n  {\n    register int j, state, pos;\n    register FriBidiCharType char_type;\n    register FriBidiRun *p, *q, *list;\n\n    /* L1. Reset the embedding levels of some chars:\n       1. segment separators,\n       2. paragraph separators,\n       3. any sequence of whitespace characters preceding a segment\n          separator or paragraph separator, and\n       4. any sequence of whitespace characters and/or isolate formatting\n          characters at the end of the line.\n       ... (to be continued in fribidi_reorder_line()). */\n    list = new_run_list ();\n    if UNLIKELY\n      (!list) goto out;\n    q = list;\n    state = 1;\n    pos = len - 1;\n    for (j = len - 1; j >= -1; j--)\n      {\n\t/* close up the open link at the end */\n\tif (j >= 0)\n\t  char_type = bidi_types[j];\n\telse\n\t  char_type = FRIBIDI_TYPE_ON;\n\tif (!state && FRIBIDI_IS_SEPARATOR (char_type))\n\t  {\n\t    state = 1;\n\t    pos = j;\n\t  }\n\telse if (state &&\n                 !(FRIBIDI_IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS(char_type)\n                   || FRIBIDI_IS_ISOLATE(char_type)))\n\t  {\n\t    state = 0;\n\t    p = new_run ();\n\t    if UNLIKELY\n\t      (!p)\n\t      {\n\t\tfree_run_list (list);\n\t\tgoto out;\n\t      }\n\t    p->pos = j + 1;\n\t    p->len = pos - j;\n\t    p->type = base_dir;\n\t    p->level = base_level;\n\t    move_node_before (p, q);\n\t    q = p;\n\t  }\n      }\n    if UNLIKELY\n      (!shadow_run_list (main_run_list, list, false)) goto out;\n  }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  {\n    FriBidiStrIndex pos = 0;\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiStrIndex l;\n      register FriBidiLevel level = pp->level;\n      for (l = pp->len; l; l--)\n\tembedding_levels[pos++] = level;\n    }\n  }\n\n  status = true;\n\nout:\n  DBG (\"leaving fribidi_get_par_embedding_levels\");\n\n  if (main_run_list)\n    free_run_list (main_run_list);\n  if UNLIKELY\n    (explicits_list) free_run_list (explicits_list);\n\n  return status ? max_level + 1 : 0;\n}",
        "file_path": "/work/build/../../src/fribidi/lib/fribidi-bidi.c",
        "crashing_line": "  }",
        "crashing_line_number": 1262
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void user_stream_create_object(struct php_user_stream_wrapper *uwrap, php_stream_context *context, zval *object)\n{\n\tif (uwrap->ce->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_TRAIT|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) {\n\t\tZVAL_UNDEF(object);\n\t\treturn;\n\t}\n\n\t/* create an instance of our class */\n\tif (object_init_ex(object, uwrap->ce) == FAILURE) {\n\t\tZVAL_UNDEF(object);\n\t\treturn;\n\t}\n\n\tif (context) {\n\t\tadd_property_resource(object, \"context\", context->res);\n\t\tGC_ADDREF(context->res);\n\t} else {\n\t\tadd_property_null(object, \"context\");\n\t}\n\n\tif (uwrap->ce->constructor) {\n\t\tzend_call_known_instance_method_with_0_params(\n\t\t\tuwrap->ce->constructor, Z_OBJ_P(object), NULL);\n\t}\n}\n",
    "target": 1,
    "idx": 1047997,
    "stack_trace": [
      {
        "function_name": "user_stream_create_object",
        "function_body": "static void user_stream_create_object(struct php_user_stream_wrapper *uwrap, php_stream_context *context, zval *object)\n{\n\tif (uwrap->ce->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_TRAIT|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) {\n\t\tZVAL_UNDEF(object);\n\t\treturn;\n\t}\n\n\t/* create an instance of our class */\n\tif (object_init_ex(object, uwrap->ce) == FAILURE) {\n\t\tZVAL_UNDEF(object);\n\t\treturn;\n\t}\n\n\tif (context) {\n\t\tGC_ADDREF(context->res);\n\t\tadd_property_resource(object, \"context\", context->res);\n\t} else {\n\t\tadd_property_null(object, \"context\");\n\t}\n\n\tif (uwrap->ce->constructor) {\n\t\tzend_call_known_instance_method_with_0_params(\n\t\t\tuwrap->ce->constructor, Z_OBJ_P(object), NULL);\n\t}\n}",
        "file_path": "/src/php-src/main/streams/userspace.c",
        "crashing_line": "\t\tadd_property_resource(object, \"context\", context->res);",
        "crashing_line_number": 293
      },
      {
        "function_name": "user_wrapper_opendir",
        "function_body": "",
        "file_path": "/src/php-src/main/streams/userspace.c",
        "crashing_line": "",
        "crashing_line_number": 418
      },
      {
        "function_name": "_php_stream_opendir",
        "function_body": "",
        "file_path": "/src/php-src/main/streams/streams.c",
        "crashing_line": "",
        "crashing_line_number": 2017
      },
      {
        "function_name": "_php_do_opendir",
        "function_body": "static void _php_do_opendir(INTERNAL_FUNCTION_PARAMETERS, int createobject)\n{\n\tchar *dirname;\n\tsize_t dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *dirp;\n\n\tZEND_PARSE_PARAMETERS_START(1, 2)\n\t\tZ_PARAM_PATH(dirname, dir_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tdirp = php_stream_opendir(dirname, REPORT_ERRORS, context);\n\n\tif (dirp == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tdirp->flags |= PHP_STREAM_FLAG_NO_FCLOSE;\n\n\tphp_set_default_dir(dirp->res);\n\n\tif (createobject) {\n\t\tobject_init_ex(return_value, dir_class_entry_ptr);\n\t\tadd_property_stringl(return_value, \"path\", dirname, dir_len);\n\t\tadd_property_resource(return_value, \"handle\", dirp->res);\n\t\tphp_stream_auto_cleanup(dirp); /* so we don't get warnings under debug */\n\t} else {\n\t\tphp_stream_to_zval(dirp, return_value);\n\t}\n}",
        "file_path": "/src/php-src/ext/standard/dir.c",
        "crashing_line": "\tdirp = php_stream_opendir(dirname, REPORT_ERRORS, context);",
        "crashing_line_number": 211
      },
      {
        "function_name": "zif_dir",
        "function_body": "",
        "file_path": "/src/php-src/ext/standard/dir.c",
        "crashing_line": "",
        "crashing_line_number": 242
      },
      {
        "function_name": "ZEND_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER",
        "function_body": "static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzend_execute_data *call = EX(call);\n\tzend_function *fbc = call->func;\n\tzval *ret;\n\tzval retval;\n\n\tSAVE_OPLINE();\n\tEX(call) = call->prev_execute_data;\n\n\tcall->prev_execute_data = execute_data;\n\tEG(current_execute_data) = call;\n\n#if ZEND_DEBUG\n\tzend_bool should_throw = zend_internal_call_should_throw(fbc, call);\n#endif\n\n\tret = 0 ? EX_VAR(opline->result.var) : &retval;\n\tZVAL_NULL(ret);\n\n\tfbc->internal_function.handler(call, ret);\n\n#if ZEND_DEBUG\n\tif (!EG(exception) && call->func) {\n\t\tif (should_throw) {\n\t\t\tzend_internal_call_arginfo_violation(call->func);\n\t\t}\n\t\tZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||\n\t\t\tzend_verify_internal_return_type(call->func, ret));\n\t\tZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)\n\t\t\t? Z_ISREF_P(ret) : !Z_ISREF_P(ret));\n\t}\n#endif\n\n\tEG(current_execute_data) = execute_data;\n\tzend_vm_stack_free_args(call);\n\n\tuint32_t call_info = ZEND_CALL_INFO(call);\n\tif (UNEXPECTED(call_info & (ZEND_CALL_HAS_EXTRA_NAMED_PARAMS|ZEND_CALL_ALLOCATED))) {\n\t\tif (call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS) {\n\t\t\tzend_free_extra_named_params(call->extra_named_params);\n\t\t}\n\t\tzend_vm_stack_free_call_frame_ex(call_info, call);\n\t} else {\n\t\tEG(vm_stack_top) = (zval*)call;\n\t}\n\n\tif (!0) {\n\t\ti_zval_ptr_dtor(ret);\n\t}\n\n\tif (UNEXPECTED(EG(exception) != NULL)) {\n\t\tzend_rethrow_exception(execute_data);\n\t\tHANDLE_EXCEPTION();\n\t}\n\n\tZEND_VM_SET_OPCODE(opline + 1);\n\tZEND_VM_CONTINUE();\n}",
        "file_path": "/src/php-src/Zend/zend_vm_execute.h",
        "crashing_line": "\tfbc->internal_function.handler(call, ret);",
        "crashing_line_number": 1234
      },
      {
        "function_name": "fuzzer_execute_ex",
        "function_body": "static void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-execute.c",
        "crashing_line": "\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {",
        "crashing_line_number": 40
      },
      {
        "function_name": "zend_execute",
        "function_body": "ZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)\n{\n\tzend_execute_data *execute_data;\n\tvoid *object_or_called_scope;\n\tuint32_t call_info;\n\n\tif (EG(exception) != NULL) {\n\t\treturn;\n\t}\n\n\tobject_or_called_scope = zend_get_this_object(EG(current_execute_data));\n\tif (EXPECTED(!object_or_called_scope)) {\n\t\tobject_or_called_scope = zend_get_called_scope(EG(current_execute_data));\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE;\n\t} else {\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE | ZEND_CALL_HAS_THIS;\n\t}\n\texecute_data = zend_vm_stack_push_call_frame(call_info,\n\t\t(zend_function*)op_array, 0, object_or_called_scope);\n\tif (EG(current_execute_data)) {\n\t\texecute_data->symbol_table = zend_rebuild_symbol_table();\n\t} else {\n\t\texecute_data->symbol_table = &EG(symbol_table);\n\t}\n\tEX(prev_execute_data) = EG(current_execute_data);\n\ti_init_code_execute_data(execute_data, op_array, return_value);\n\tZEND_OBSERVER_FCALL_BEGIN(execute_data);\n\tzend_execute_ex(execute_data);\n\t/* Observer end handlers are called from ZEND_RETURN */\n\tzend_vm_stack_free_call_frame(execute_data);\n}",
        "file_path": "/src/php-src/Zend/zend_vm_execute.h",
        "crashing_line": "\tzend_execute_ex(execute_data);",
        "crashing_line_number": 59499
      },
      {
        "function_name": "fuzzer_do_request_from_buffer",
        "function_body": "int fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-sapi.c",
        "crashing_line": "\t\t\t\tzend_execute(op_array, NULL);",
        "crashing_line_number": 259
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "MRB_API void\nmrb_field_write_barrier(mrb_state *mrb, struct RBasic *obj, struct RBasic *value)\n{\n  mrb_gc *gc = &mrb->gc;\n\n  if (!value) return;\n  if (!is_black(obj)) return;\n  if (!is_white(value)) return;\n  if (is_red(value)) return;\n\n  mrb_assert(gc->state == MRB_GC_STATE_MARK || (!is_dead(gc, value) && !is_dead(gc, obj)));\n  mrb_assert(is_generational(gc) || gc->state != MRB_GC_STATE_ROOT);\n\n  if (is_generational(gc) || gc->state == MRB_GC_STATE_MARK) {\n    add_gray_list(mrb, gc, value);\n  }\n  else {\n    mrb_assert(gc->state == MRB_GC_STATE_SWEEP);\n    paint_partial_white(gc, obj); /* for never write barriers */\n  }\n}\n",
    "target": 1,
    "idx": 1056991,
    "stack_trace": [
      {
        "function_name": "mrb_gc_mark",
        "function_body": "MRB_API void\nmrb_gc_mark(mrb_state *mrb, struct RBasic *obj)\n{\n  if (obj == 0) return;\n  if (!is_white(obj)) return;\n  if (is_red(obj)) return;\n  mrb_assert((obj)->tt != MRB_TT_FREE);\n  add_gray_list(mrb, &mrb->gc, obj);\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "  if (!is_white(obj)) return;",
        "crashing_line_number": 742
      },
      {
        "function_name": "iv_mark_i",
        "function_body": "static int\niv_mark_i(mrb_state *mrb, mrb_sym sym, mrb_value v, void *p)\n{\n  mrb_gc_mark_value(mrb, v);\n  return 0;\n}",
        "file_path": "/src/mruby/src/variable.c",
        "crashing_line": "  mrb_gc_mark_value(mrb, v);",
        "crashing_line_number": 240
      },
      {
        "function_name": "iv_foreach",
        "function_body": "static void\niv_foreach(mrb_state *mrb, iv_tbl *t, mrb_iv_foreach_func *func, void *p)\n{\n  int i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  mrb_value *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    if (IV_KEY_P(keys[i])) {\n      if ((*func)(mrb, keys[i], vals[i], p) != 0) {\n        return;\n      }\n    }\n  }\n  return;\n}",
        "file_path": "/src/mruby/src/variable.c",
        "crashing_line": "      if ((*func)(mrb, keys[i], vals[i], p) != 0) {",
        "crashing_line_number": 190
      },
      {
        "function_name": "mark_tbl",
        "function_body": "static void\nmark_tbl(mrb_state *mrb, iv_tbl *t)\n{\n  iv_foreach(mrb, t, iv_mark_i, 0);\n}",
        "file_path": "/src/mruby/src/variable.c",
        "crashing_line": "  iv_foreach(mrb, t, iv_mark_i, 0);",
        "crashing_line_number": 247
      },
      {
        "function_name": "mrb_gc_mark_iv",
        "function_body": "void\nmrb_gc_mark_iv(mrb_state *mrb, struct RObject *obj)\n{\n  mark_tbl(mrb, obj->iv);\n}",
        "file_path": "/src/mruby/src/variable.c",
        "crashing_line": "  mark_tbl(mrb, obj->iv);",
        "crashing_line_number": 266
      },
      {
        "function_name": "gc_mark_children",
        "function_body": "static void\ngc_mark_children(mrb_state *mrb, mrb_gc *gc, struct RBasic *obj)\n{\n  mrb_assert(is_gray(obj));\n  paint_black(obj);\n  mrb_gc_mark(mrb, (struct RBasic*)obj->c);\n  switch (obj->tt) {\n  case MRB_TT_ICLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n      if (MRB_FLAG_TEST(c, MRB_FL_CLASS_IS_ORIGIN))\n        mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RClass*)obj)->super);\n    }\n    break;\n\n  case MRB_TT_CLASS:\n  case MRB_TT_MODULE:\n  case MRB_TT_SCLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n\n      mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)c->super);\n    }\n    /* fall through */\n\n  case MRB_TT_OBJECT:\n  case MRB_TT_CDATA:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    break;\n\n  case MRB_TT_PROC:\n    {\n      struct RProc *p = (struct RProc*)obj;\n\n      mrb_gc_mark(mrb, (struct RBasic*)p->upper);\n      mrb_gc_mark(mrb, (struct RBasic*)p->e.env);\n    }\n    break;\n\n  case MRB_TT_ENV:\n    {\n      struct REnv *e = (struct REnv*)obj;\n      mrb_int i, len;\n\n      if (MRB_ENV_ONSTACK_P(e) && e->cxt && e->cxt->fib) {\n        mrb_gc_mark(mrb, (struct RBasic*)e->cxt->fib);\n      }\n      len = MRB_ENV_LEN(e);\n      for (i=0; i<len; i++) {\n        mrb_gc_mark_value(mrb, e->stack[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_FIBER:\n    {\n      struct mrb_context *c = ((struct RFiber*)obj)->cxt;\n\n      if (c) mark_context(mrb, c);\n    }\n    break;\n\n  case MRB_TT_STRUCT:\n  case MRB_TT_ARRAY:\n    {\n      struct RArray *a = (struct RArray*)obj;\n      size_t i, e=ARY_LEN(a);\n      mrb_value *p = ARY_PTR(a);\n\n      for (i=0; i<e; i++) {\n        mrb_gc_mark_value(mrb, p[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_HASH:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    mrb_gc_mark_hash(mrb, (struct RHash*)obj);\n    break;\n\n  case MRB_TT_STRING:\n    if (RSTR_FSHARED_P(obj)) {\n      struct RString *s = (struct RString*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)s->as.heap.aux.fshared);\n    }\n    break;\n\n  case MRB_TT_RANGE:\n    mrb_gc_mark_range(mrb, (struct RRange*)obj);\n    break;\n\n  case MRB_TT_BREAK:\n    {\n      struct RBreak *brk = (struct RBreak*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)mrb_break_proc_get(brk));\n      mrb_gc_mark_value(mrb, mrb_break_value_get(brk));\n    }\n    break;\n\n  case MRB_TT_EXCEPTION:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    if (((struct RException*)obj)->mesg) {\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->mesg);\n    }\n    mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->backtrace);\n    break;\n\n  default:\n    break;\n  }\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "    mrb_gc_mark_iv(mrb, (struct RObject*)obj);",
        "crashing_line_number": 653
      },
      {
        "function_name": "incremental_marking_phase",
        "function_body": "static size_t\nincremental_marking_phase(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  size_t tried_marks = 0;\n\n  while (gc->gray_list && tried_marks < limit) {\n    struct RBasic *obj = gc->gray_list;\n    gc->gray_list = obj->gcnext;\n    gc_mark_children(mrb, gc, obj);\n    tried_marks += gc_gray_counts(mrb, gc, obj);\n  }\n\n  return tried_marks;\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "    gc_mark_children(mrb, gc, obj);",
        "crashing_line_number": 1050
      },
      {
        "function_name": "incremental_gc",
        "function_body": "static size_t\nincremental_gc(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  switch (gc->state) {\n  case MRB_GC_STATE_ROOT:\n    root_scan_phase(mrb, gc);\n    gc->state = MRB_GC_STATE_MARK;\n    flip_white_part(gc);\n    return 0;\n  case MRB_GC_STATE_MARK:\n    if (gc->gray_list) {\n      return incremental_marking_phase(mrb, gc, limit);\n    }\n    else {\n      final_marking_phase(mrb, gc);\n      prepare_incremental_sweep(mrb, gc);\n      return 0;\n    }\n  case MRB_GC_STATE_SWEEP: {\n     size_t tried_sweep = 0;\n     tried_sweep = incremental_sweep_phase(mrb, gc, limit);\n     if (tried_sweep == 0)\n       gc->state = MRB_GC_STATE_ROOT;\n     return tried_sweep;\n  }\n  default:\n    /* unknown state */\n    mrb_assert(0);\n    return 0;\n  }\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "      return incremental_marking_phase(mrb, gc, limit);",
        "crashing_line_number": 1190
      },
      {
        "function_name": "incremental_gc_finish",
        "function_body": "static void\nincremental_gc_finish(mrb_state *mrb, mrb_gc *gc)\n{\n  do {\n    incremental_gc(mrb, gc, SIZE_MAX);\n  } while (gc->state != MRB_GC_STATE_ROOT);\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "    incremental_gc(mrb, gc, SIZE_MAX);",
        "crashing_line_number": 1215
      },
      {
        "function_name": "mrb_full_gc",
        "function_body": "MRB_API void\nmrb_full_gc(mrb_state *mrb)\n{\n  mrb_gc *gc = &mrb->gc;\n\n  if (!mrb->c) return;\n  if (gc->disabled || gc->iterating) return;\n\n  if (is_generational(gc)) {\n    /* clear all the old objects back to young */\n    clear_all_old(mrb, gc);\n    gc->full = TRUE;\n  }\n  else if (gc->state != MRB_GC_STATE_ROOT) {\n    /* finish half baked GC cycle */\n    incremental_gc_finish(mrb, gc);\n  }\n\n  incremental_gc_finish(mrb, gc);\n  gc->threshold = (gc->live_after_mark/100) * gc->interval_ratio;\n\n  if (is_generational(gc)) {\n    gc->majorgc_old_threshold = gc->live_after_mark/100 * MAJOR_GC_INC_RATIO;\n    gc->full = FALSE;\n  }\n\n#ifdef MRB_USE_MALLOC_TRIM\n  malloc_trim(0);\n#endif\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "  incremental_gc_finish(mrb, gc);",
        "crashing_line_number": 1315
      },
      {
        "function_name": "mrb_objspace_each_objects",
        "function_body": "void\nmrb_objspace_each_objects(mrb_state *mrb, mrb_each_object_callback *callback, void *data)\n{\n  mrb_bool iterating = mrb->gc.iterating;\n\n  mrb_full_gc(mrb);\n  mrb->gc.iterating = TRUE;\n  if (iterating) {\n    gc_each_objects(mrb, &mrb->gc, callback, data);\n  }\n  else {\n    struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n    struct mrb_jmpbuf c_jmp;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      gc_each_objects(mrb, &mrb->gc, callback, data);\n      mrb->jmp = prev_jmp;\n      mrb->gc.iterating = iterating;\n   } MRB_CATCH(&c_jmp) {\n      mrb->gc.iterating = iterating;\n      mrb->jmp = prev_jmp;\n      MRB_THROW(prev_jmp);\n    } MRB_END_EXC(&c_jmp);\n  }\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "  mrb->gc.iterating = TRUE;",
        "crashing_line_number": 1589
      },
      {
        "function_name": "os_count_objects",
        "function_body": "static mrb_value\nos_count_objects(mrb_state *mrb, mrb_value self)\n{\n  struct os_count_struct obj_count = { 0 };\n  mrb_int i;\n  mrb_value hash;\n\n  if (mrb_get_args(mrb, \"|H\", &hash) == 0) {\n    hash = mrb_hash_new(mrb);\n  }\n\n  if (!mrb_hash_empty_p(mrb, hash)) {\n    mrb_hash_clear(mrb, hash);\n  }\n\n  mrb_objspace_each_objects(mrb, os_count_object_type, &obj_count);\n\n  mrb_hash_set(mrb, hash, mrb_symbol_value(MRB_SYM(TOTAL)), mrb_fixnum_value(obj_count.total));\n  mrb_hash_set(mrb, hash, mrb_symbol_value(MRB_SYM(FREE)), mrb_fixnum_value(obj_count.freed));\n\n  for (i = MRB_TT_FALSE; i < MRB_TT_MAXDEFINE; i++) {\n    mrb_value type;\n    switch (i) {\n#define COUNT_TYPE(t) case (MRB_T ## t): type = mrb_symbol_value(MRB_SYM(t)); break;\n      COUNT_TYPE(T_INTEGER);\n      COUNT_TYPE(T_FLOAT);\n      COUNT_TYPE(T_CPTR);\n      COUNT_TYPE(T_OBJECT);\n      COUNT_TYPE(T_CLASS);\n      COUNT_TYPE(T_MODULE);\n      COUNT_TYPE(T_ICLASS);\n      COUNT_TYPE(T_SCLASS);\n      COUNT_TYPE(T_PROC);\n      COUNT_TYPE(T_ARRAY);\n      COUNT_TYPE(T_HASH);\n      COUNT_TYPE(T_STRING);\n      COUNT_TYPE(T_RANGE);\n      COUNT_TYPE(T_EXCEPTION);\n      COUNT_TYPE(T_ENV);\n      COUNT_TYPE(T_DATA);\n      COUNT_TYPE(T_FIBER);\n      COUNT_TYPE(T_STRUCT);\n      COUNT_TYPE(T_ISTRUCT);\n      COUNT_TYPE(T_BREAK);\n      COUNT_TYPE(T_COMPLEX);\n      COUNT_TYPE(T_RATIONAL);\n      COUNT_TYPE(T_BIGINT);\n#undef COUNT_TYPE\n    default:\n      type = mrb_fixnum_value(i); break;\n    }\n    if (obj_count.counts[i])\n      mrb_hash_set(mrb, hash, type, mrb_fixnum_value(obj_count.counts[i]));\n  }\n\n  return hash;\n}",
        "file_path": "/src/mruby/mrbgems/mruby-objectspace/src/mruby_objectspace.c",
        "crashing_line": "  mrb_objspace_each_objects(mrb, os_count_object_type, &obj_count);",
        "crashing_line_number": 73
      },
      {
        "function_name": "mrb_vm_run",
        "function_body": "MRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  else {\n    struct REnv *e = CI_ENV(mrb->c->ci);\n    if (stack_keep == 0 || (e && irep->nlocals < MRB_ENV_LEN(e))) {\n      ci_env_set(mrb->c->ci, NULL);\n      mrb_env_unshare(mrb, e, FALSE);\n    }\n  }\n  stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "  result = mrb_vm_exec(mrb, proc, irep->iseq);",
        "crashing_line_number": 1299
      },
      {
        "function_name": "FuzzRB",
        "function_body": "int FuzzRB(const uint8_t *Data, size_t size) {\n  mrb_value v;\n  mrb_state *mrb = mrb_open();\n  if (!mrb)\n    return 0;\n\n  char *code = (char *)malloc(size+1);\n  if (!code)\n    return 0;\n  memcpy(code, Data, size);\n  code[size] = '\\0';\n\n  if (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n    // With libFuzzer binary run this to generate an RB file x.rb:\n    // PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n    std::ofstream of(dump_path);\n    of.write(code, size);\n  }\n  std::cout << \"\\n\\n############\\n\" << code << \"\\n############\\n\\n\";\n  v = mrb_load_string(mrb, code);\n  mrb_close(mrb);\n\n  free(code);\n  return 0;\n}",
        "file_path": "/src/mruby/oss-fuzz/mruby_proto_fuzzer.cpp",
        "crashing_line": "  v = mrb_load_string(mrb, code);",
        "crashing_line_number": 34
      },
      {
        "function_name": "TestOneProtoInput",
        "function_body": "",
        "file_path": "/src/mruby/oss-fuzz/mruby_proto_fuzzer.cpp",
        "crashing_line": "",
        "crashing_line_number": 44
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "  Status Reserve(const int64_t capacity) override {\n    if (!mutable_data_ || capacity > capacity_) {\n      uint8_t* new_data;\n      int64_t new_capacity = BitUtil::RoundUpToMultipleOf64(capacity);\n      if (mutable_data_) {\n        RETURN_NOT_OK(pool_->Reallocate(capacity_, new_capacity, &mutable_data_));\n      } else {\n        RETURN_NOT_OK(pool_->Allocate(new_capacity, &new_data));\n        mutable_data_ = new_data;\n      }\n      data_ = mutable_data_;\n      capacity_ = new_capacity;\n    }\n    return Status::OK();\n  }\n  Status Resize(const int64_t new_size, bool shrink_to_fit = true) override {\n    if (mutable_data_ && shrink_to_fit && new_size <= size_) {\n      // Buffer is non-null and is not growing, so shrink to the requested size without\n      // excess space.\n      int64_t new_capacity = BitUtil::RoundUpToMultipleOf64(new_size);\n      if (capacity_ != new_capacity) {\n        // Buffer hasn't got yet the requested size.\n        RETURN_NOT_OK(pool_->Reallocate(capacity_, new_capacity, &mutable_data_));\n        data_ = mutable_data_;\n        capacity_ = new_capacity;\n      }\n    } else {\n      RETURN_NOT_OK(Reserve(new_size));\n    }\n    size_ = new_size;\n\n    return Status::OK();\n  }\n  Result<int64_t> ReadAt(int64_t position, int64_t nbytes, void* out) {\n    RETURN_NOT_OK(CheckClosed());\n    // ReadAt() leaves the file position undefined, so require that we seek\n    // before calling Read() or Write().\n    need_seeking_.store(true);\n    return ::arrow::internal::FileReadAt(fd_, reinterpret_cast<uint8_t*>(out), position,\n                                         nbytes);\n  }\nResult<int64_t> MemoryMappedFile::ReadAt(int64_t position, int64_t nbytes, void* out) {\n  RETURN_NOT_OK(memory_map_->CheckClosed());\n  auto guard_resize = memory_map_->writable()\n                          ? std::unique_lock<std::mutex>(memory_map_->resize_lock())\n                          : std::unique_lock<std::mutex>();\n  nbytes = std::max<int64_t>(0, std::min(nbytes, memory_map_->size() - position));\n  if (nbytes > 0) {\n    memcpy(out, memory_map_->data() + position, static_cast<size_t>(nbytes));\n  }\n  return nbytes;\n}\nStatus MemoryMappedFile::WriteAt(int64_t position, const void* data, int64_t nbytes) {\n  RETURN_NOT_OK(memory_map_->CheckClosed());\n  std::lock_guard<std::mutex> guard(memory_map_->write_lock());\n\n  if (!memory_map_->opened() || !memory_map_->writable()) {\n    return Status::IOError(\"Unable to write\");\n  }\n  if (position + nbytes > memory_map_->size()) {\n    return Status::Invalid(\"Cannot write past end of memory map\");\n  }\n\n  RETURN_NOT_OK(memory_map_->Seek(position));\n  if (nbytes + memory_map_->position() > memory_map_->size()) {\n    return Status::Invalid(\"Cannot write past end of memory map\");\n  }\n\n  return WriteInternal(data, nbytes);\n}\nStatus MemoryMappedFile::Write(const void* data, int64_t nbytes) {\n  RETURN_NOT_OK(memory_map_->CheckClosed());\n  std::lock_guard<std::mutex> guard(memory_map_->write_lock());\n\n  if (!memory_map_->opened() || !memory_map_->writable()) {\n    return Status::IOError(\"Unable to write\");\n  }\n  if (nbytes + memory_map_->position() > memory_map_->size()) {\n    return Status::Invalid(\"Cannot write past end of memory map\");\n  }\n\n  return WriteInternal(data, nbytes);\n}\n  Status Write(const void* data, int64_t nbytes) {\n    if (position_ + nbytes > size_) {\n      return Status::IOError(\"Write out of bounds\");\n    }\n    if (nbytes > memcopy_threshold_ && memcopy_num_threads_ > 1) {\n      ::arrow::internal::parallel_memcopy(mutable_data_ + position_,\n                                          reinterpret_cast<const uint8_t*>(data), nbytes,\n                                          memcopy_blocksize_, memcopy_num_threads_);\n    } else {\n      memcpy(mutable_data_ + position_, data, nbytes);\n    }\n    position_ += nbytes;\n    return Status::OK();\n  }\n  Status WriteAt(int64_t position, const void* data, int64_t nbytes) {\n    std::lock_guard<std::mutex> guard(lock_);\n    RETURN_NOT_OK(Seek(position));\n    return Write(data, nbytes);\n  }\nResult<std::shared_ptr<Buffer>> BufferReader::DoReadAt(int64_t position, int64_t nbytes) {\n  RETURN_NOT_OK(CheckClosed());\n\n  if (nbytes < 0) {\n    return Status::IOError(\"Cannot read a negative number of bytes from BufferReader.\");\n  }\n  int64_t size = std::min(nbytes, size_ - position);\n\n  if (size > 0 && buffer_ != nullptr) {\n    return SliceBuffer(buffer_, position, size);\n  } else {\n    return std::make_shared<Buffer>(data_ + position, size);\n  }\n}\nStatus FieldFromFlatbuffer(const flatbuf::Field* field, DictionaryMemo* dictionary_memo,\n                           std::shared_ptr<Field>* out) {\n  std::shared_ptr<DataType> type;\n\n  std::shared_ptr<KeyValueMetadata> metadata;\n  RETURN_NOT_OK(GetFieldMetadata(field, &metadata));\n\n  // Reconstruct the data type\n  auto children = field->children();\n  if (children == nullptr) {\n    return Status::IOError(\"Children-pointer of flatbuffer-encoded Field is null.\");\n  }\n  std::vector<std::shared_ptr<Field>> child_fields(children->size());\n  for (int i = 0; i < static_cast<int>(children->size()); ++i) {\n    RETURN_NOT_OK(\n        FieldFromFlatbuffer(children->Get(i), dictionary_memo, &child_fields[i]));\n  }\n  RETURN_NOT_OK(TypeFromFlatbuffer(field, child_fields, metadata.get(), &type));\n\n  const flatbuf::DictionaryEncoding* encoding = field->dictionary();\n\n  if (encoding != nullptr) {\n    // The field is dictionary-encoded. Construct the DictionaryType\n    // based on the DictionaryEncoding metadata and record in the\n    // dictionary_memo\n    std::shared_ptr<DataType> index_type;\n    auto int_data = encoding->indexType();\n    if (int_data == nullptr) {\n      return Status::IOError(\n          \"indexType-pointer in custom metadata of flatbuffer-encoded DictionaryEncoding \"\n          \"is null.\");\n    }\n    RETURN_NOT_OK(IntFromFlatbuffer(int_data, &index_type));\n    type = ::arrow::dictionary(index_type, type, encoding->isOrdered());\n    *out = ::arrow::field(field->name()->str(), type, field->nullable(), metadata);\n    RETURN_NOT_OK(dictionary_memo->AddField(encoding->id(), *out));\n  } else {\n    auto name = field->name();\n    if (name == nullptr) {\n      return Status::IOError(\"Name-pointer of flatbuffer-encoded Field is null.\");\n    }\n    *out = ::arrow::field(name->str(), type, field->nullable(), metadata);\n  }\n  return Status::OK();\n}\nStatus ReadRecordBatch(const std::shared_ptr<Schema>& schema,\n                       const DictionaryMemo* dictionary_memo, io::InputStream* file,\n                       std::shared_ptr<RecordBatch>* out) {\n  auto options = IpcOptions::Defaults();\n  std::unique_ptr<Message> message;\n  RETURN_NOT_OK(ReadContiguousPayload(file, &message));\n  io::BufferReader buffer_reader(message->body());\n  return ReadRecordBatch(*message->metadata(), schema, dictionary_memo, options,\n                         &buffer_reader, out);\n}\n  Status ReadDictionaries() {\n    // Read all the dictionaries\n    for (int i = 0; i < num_dictionaries(); ++i) {\n      std::unique_ptr<Message> message;\n      RETURN_NOT_OK(ReadMessageFromBlock(GetDictionaryBlock(i), &message));\n\n      io::BufferReader reader(message->body());\n      RETURN_NOT_OK(ReadDictionary(*message->metadata(), &dictionary_memo_, &reader));\n    }\n    return Status::OK();\n  }\nResult<std::shared_ptr<Tensor>> ReadTensor(const Message& message) {\n  std::shared_ptr<DataType> type;\n  std::vector<int64_t> shape;\n  std::vector<int64_t> strides;\n  std::vector<std::string> dim_names;\n  RETURN_NOT_OK(internal::GetTensorMetadata(*message.metadata(), &type, &shape, &strides,\n                                            &dim_names));\n  return Tensor::Make(type, message.body(), shape, strides, dim_names);\n}\nResult<std::shared_ptr<SparseTensor>> ReadSparseTensor(io::InputStream* file) {\n  std::unique_ptr<Message> message;\n  RETURN_NOT_OK(ReadContiguousPayload(file, &message));\n  CHECK_MESSAGE_TYPE(Message::SPARSE_TENSOR, message->type());\n  CHECK_HAS_BODY(*message);\n  io::BufferReader buffer_reader(message->body());\n  return ReadSparseTensor(*message->metadata(), &buffer_reader);\n}\nint DictionaryType::bit_width() const {\n  return checked_cast<const FixedWidthType&>(*index_type_).bit_width();\n}\nDictionaryType::DictionaryType(const std::shared_ptr<DataType>& index_type,\n                               const std::shared_ptr<DataType>& value_type, bool ordered)\n    : FixedWidthType(Type::DICTIONARY),\n      index_type_(index_type),\n      value_type_(value_type),\n      ordered_(ordered) {\n  ARROW_CHECK(is_integer(index_type->id()))\n      << \"dictionary index type should be signed integer\";\n  const auto& int_type = checked_cast<const IntegerType&>(*index_type);\n  ARROW_CHECK(int_type.is_signed()) << \"dictionary index type should be signed integer\";\n}\nDataTypeLayout DictionaryType::layout() const {\n  auto layout = index_type_->layout();\n  layout.has_dictionary = true;\n  return layout;\n}\n  std::string name() const override { return \"dictionary\"; }\n",
    "target": 1,
    "idx": 1020120,
    "stack_trace": [
      {
        "function_name": "CountSetBits",
        "function_body": "int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n  constexpr int64_t pop_len = sizeof(uint64_t) * 8;\n  DCHECK_GE(bit_offset, 0);\n  int64_t count = 0;\n\n  const auto p = BitmapWordAlign<pop_len / 8>(data, bit_offset, length);\n  for (int64_t i = bit_offset; i < bit_offset + p.leading_bits; ++i) {\n    if (BitUtil::GetBit(data, i)) {\n      ++count;\n    }\n  }\n\n  if (p.aligned_words > 0) {\n    // popcount as much as possible with the widest possible count\n    const uint64_t* u64_data = reinterpret_cast<const uint64_t*>(p.aligned_start);\n    DCHECK_EQ(reinterpret_cast<size_t>(u64_data) & 7, 0);\n    const uint64_t* end = u64_data + p.aligned_words;\n\n    for (auto iter = u64_data; iter < end; ++iter) {\n      count += __builtin_popcountll(*iter);\n    }\n  }\n\n  // Account for left over bits (in theory we could fall back to smaller\n  // versions of popcount but the code complexity is likely not worth it)\n  for (int64_t i = p.trailing_bit_offset; i < bit_offset + length; ++i) {\n    if (BitUtil::GetBit(data, i)) {\n      ++count;\n    }\n  }\n\n  return count;\n}",
        "file_path": "/src/arrow/cpp/src/arrow/util/bit_util.cc",
        "crashing_line": "      count += __builtin_popcountll(*iter);",
        "crashing_line_number": 95
      },
      {
        "function_name": "GetNullCount",
        "function_body": "int64_t ArrayData::GetNullCount() const {\n  int64_t precomputed = this->null_count.load();\n  if (ARROW_PREDICT_FALSE(precomputed == kUnknownNullCount)) {\n    if (this->buffers[0]) {\n      precomputed = this->length -\n                    CountSetBits(this->buffers[0]->data(), this->offset, this->length);\n    } else {\n      precomputed = 0;\n    }\n    this->null_count.store(precomputed);\n  }\n  return precomputed;\n}",
        "file_path": "/src/arrow/cpp/src/arrow/array.cc",
        "crashing_line": "                    CountSetBits(this->buffers[0]->data(), this->offset, this->length);",
        "crashing_line_number": 113
      },
      {
        "function_name": "null_count",
        "function_body": "int64_t Array::null_count() const { return data_->GetNullCount(); }",
        "file_path": "/src/arrow/cpp/src/arrow/array.cc",
        "crashing_line": "int64_t Array::null_count() const { return data_->GetNullCount(); }",
        "crashing_line_number": 125
      },
      {
        "function_name": "ValidateArray",
        "function_body": "ARROW_EXPORT\nStatus ValidateArray(const Array& array) {\n  // First check the array layout conforms to the spec\n  const DataType& type = *array.type();\n  const auto layout = type.layout();\n  const ArrayData& data = *array.data();\n\n  if (array.length() < 0) {\n    return Status::Invalid(\"Array length is negative\");\n  }\n\n  if (array.null_count() > array.length()) {\n    return Status::Invalid(\"Null count exceeds array length\");\n  }\n\n  if (data.buffers.size() != layout.bit_widths.size()) {\n    return Status::Invalid(\"Expected \", layout.bit_widths.size(),\n                           \" buffers in array \"\n                           \"of type \",\n                           type.ToString(), \", got \", data.buffers.size());\n  }\n  if (type.id() != Type::EXTENSION) {\n    if (data.child_data.size() != static_cast<size_t>(type.num_children())) {\n      return Status::Invalid(\"Expected \", type.num_children(),\n                             \" child arrays in array \"\n                             \"of type \",\n                             type.ToString(), \", got \", data.child_data.size());\n    }\n  }\n  if (layout.has_dictionary && !data.dictionary) {\n    return Status::Invalid(\"Array of type \", type.ToString(),\n                           \" must have dictionary values\");\n  }\n  if (!layout.has_dictionary && data.dictionary) {\n    return Status::Invalid(\"Unexpected dictionary values in array of type \",\n                           type.ToString());\n  }\n\n  ValidateArrayVisitor visitor;\n  return VisitArrayInline(array, &visitor);\n}",
        "file_path": "/src/arrow/cpp/src/arrow/array/validate.cc",
        "crashing_line": "  if (array.null_count() > array.length()) {",
        "crashing_line_number": 269
      },
      {
        "function_name": "Visit",
        "function_body": "  Status Visit(const ExtensionArray& array) {\n    return ValidateArrayData(*array.storage());\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/array/validate.cc",
        "crashing_line": "",
        "crashing_line_number": 135
      },
      {
        "function_name": "",
        "function_body": "  static Status Visit(const ArrayData& arr, Visitor* visitor) {\n    const auto& fw_type = internal::checked_cast<const FixedSizeBinaryType&>(*arr.type);\n\n    const int32_t byte_width = fw_type.byte_width();\n    const uint8_t* data =\n        arr.GetValues<uint8_t>(1,\n                               /*absolute_offset=*/arr.offset * byte_width);\n\n    if (arr.null_count != 0) {\n      internal::BitmapReader valid_reader(arr.buffers[0]->data(), arr.offset, arr.length);\n      for (int64_t i = 0; i < arr.length; ++i) {\n        const bool is_null = valid_reader.IsNotSet();\n        valid_reader.Next();\n        if (is_null) {\n          ARROW_RETURN_NOT_OK(visitor->VisitNull());\n        } else {\n          auto value = util::string_view(reinterpret_cast<const char*>(data), byte_width);\n          ARROW_RETURN_NOT_OK(visitor->VisitValue(value));\n        }\n        data += byte_width;\n      }\n    } else {\n      for (int64_t i = 0; i < arr.length; ++i) {\n        auto value = util::string_view(reinterpret_cast<const char*>(data), byte_width);\n        ARROW_RETURN_NOT_OK(visitor->VisitValue(value));\n        data += byte_width;\n      }\n    }\n    return Status::OK();\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/visitor_inline.h",
        "crashing_line": "",
        "crashing_line_number": 110
      },
      {
        "function_name": "ValidateArray",
        "function_body": "ARROW_EXPORT\nStatus ValidateArray(const Array& array) {\n  // First check the array layout conforms to the spec\n  const DataType& type = *array.type();\n  const auto layout = type.layout();\n  const ArrayData& data = *array.data();\n\n  if (array.length() < 0) {\n    return Status::Invalid(\"Array length is negative\");\n  }\n\n  if (array.null_count() > array.length()) {\n    return Status::Invalid(\"Null count exceeds array length\");\n  }\n\n  if (data.buffers.size() != layout.bit_widths.size()) {\n    return Status::Invalid(\"Expected \", layout.bit_widths.size(),\n                           \" buffers in array \"\n                           \"of type \",\n                           type.ToString(), \", got \", data.buffers.size());\n  }\n  if (type.id() != Type::EXTENSION) {\n    if (data.child_data.size() != static_cast<size_t>(type.num_children())) {\n      return Status::Invalid(\"Expected \", type.num_children(),\n                             \" child arrays in array \"\n                             \"of type \",\n                             type.ToString(), \", got \", data.child_data.size());\n    }\n  }\n  if (layout.has_dictionary && !data.dictionary) {\n    return Status::Invalid(\"Array of type \", type.ToString(),\n                           \" must have dictionary values\");\n  }\n  if (!layout.has_dictionary && data.dictionary) {\n    return Status::Invalid(\"Unexpected dictionary values in array of type \",\n                           type.ToString());\n  }\n\n  ValidateArrayVisitor visitor;\n  return VisitArrayInline(array, &visitor);\n}",
        "file_path": "/src/arrow/cpp/src/arrow/array/validate.cc",
        "crashing_line": "  return VisitArrayInline(array, &visitor);",
        "crashing_line_number": 297
      },
      {
        "function_name": "Validate",
        "function_body": "  Status Validate() const override {\n    if (static_cast<int>(columns_.size()) != schema_->num_fields()) {\n      return Status::Invalid(\"Number of columns did not match schema\");\n    }\n    return RecordBatch::Validate();\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/record_batch.cc",
        "crashing_line": "",
        "crashing_line_number": 263
      },
      {
        "function_name": "Validate",
        "function_body": "  Status Validate() const override {\n    if (static_cast<int>(columns_.size()) != schema_->num_fields()) {\n      return Status::Invalid(\"Number of columns did not match schema\");\n    }\n    return RecordBatch::Validate();\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/record_batch.cc",
        "crashing_line": "    return RecordBatch::Validate();",
        "crashing_line_number": 162
      },
      {
        "function_name": "ValidateFull",
        "function_body": "  Status Validate() const override {\n    if (static_cast<int>(columns_.size()) != schema_->num_fields()) {\n      return Status::Invalid(\"Number of columns did not match schema\");\n    }\n    return RecordBatch::Validate();\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/record_batch.cc",
        "crashing_line": "",
        "crashing_line_number": 269
      },
      {
        "function_name": "FuzzIpcStream",
        "function_body": "Status FuzzIpcStream(const uint8_t* data, int64_t size) {\n  auto buffer = std::make_shared<Buffer>(data, size);\n  io::BufferReader buffer_reader(buffer);\n\n  std::shared_ptr<RecordBatchReader> batch_reader;\n  RETURN_NOT_OK(RecordBatchStreamReader::Open(&buffer_reader, &batch_reader));\n\n  while (true) {\n    std::shared_ptr<arrow::RecordBatch> batch;\n    RETURN_NOT_OK(batch_reader->ReadNext(&batch));\n    if (batch == nullptr) {\n      break;\n    }\n    RETURN_NOT_OK(batch->ValidateFull());\n  }\n\n  return Status::OK();\n}",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/reader.cc",
        "crashing_line": "    std::shared_ptr<arrow::RecordBatch> batch;",
        "crashing_line_number": 1167
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "R_API void r_core_task_decref (RCoreTask *task) {\n\tif (!task) {\n\t\treturn;\n\t}\n\tTASK_SIGSET_T old_sigset;\n\ttasks_lock_enter (task->core, &old_sigset);\n\ttask->refcount--;\n\tif (task->refcount <= 0) {\n\t\ttask_free (task);\n\t}\n\ttasks_lock_leave (task->core, &old_sigset);\n}\n",
    "target": 1,
    "idx": 1011359,
    "stack_trace": [
      {
        "function_name": "r_core_task_decref",
        "function_body": "R_API void r_core_task_decref (RCoreTask *task) {\n\tif (!task) {\n\t\treturn;\n\t}\n\tTASK_SIGSET_T old_sigset;\n\tRCore *core = task->core;\n\ttasks_lock_enter (core, &old_sigset);\n\ttask->refcount--;\n\tif (task->refcount <= 0) {\n\t\ttask_free (task);\n\t}\n\ttasks_lock_leave (core, &old_sigset);\n}",
        "file_path": "/src/radare2/libr/core/task.c",
        "crashing_line": "\t}",
        "crashing_line_number": 250
      },
      {
        "function_name": "r_list_delete",
        "function_body": "R_API void r_list_delete(RList *list, RListIter *iter) {\n\tr_return_if_fail (list && iter);\n\tr_list_split_iter (list, iter);\n\tif (list->free && iter->data) {\n\t\tlist->free (iter->data);\n\t}\n\titer->data = NULL;\n\tR_FREE (iter);\n}",
        "file_path": "/src/radare2/libr/util/list.c",
        "crashing_line": "\t\tlist->free (iter->data);",
        "crashing_line_number": 101
      },
      {
        "function_name": "r_list_purge",
        "function_body": "R_API void r_list_purge(RList *list) {\n\tRListIter *it;\n\n\tr_return_if_fail (list);\n\n\tit = list->head;\n\twhile (it) {\n\t\tRListIter *next = it->n;\n\t\tr_list_delete (list, it);\n\t\tit = next;\n\t}\n\tlist->head = list->tail = NULL;\n}",
        "file_path": "/src/radare2/libr/util/list.c",
        "crashing_line": "\t\tr_list_delete (list, it);",
        "crashing_line_number": 68
      },
      {
        "function_name": "r_list_free",
        "function_body": "R_API void r_list_free(RList *list) {\n\tif (list) {\n\t\tr_list_purge (list);\n\t\tR_FREE (list);\n\t}\n}",
        "file_path": "/src/radare2/libr/util/list.c",
        "crashing_line": "\t\tr_list_purge (list);",
        "crashing_line_number": 77
      },
      {
        "function_name": "r_core_fini",
        "function_body": "",
        "file_path": "/src/radare2/libr/core/core.c",
        "crashing_line": "",
        "crashing_line_number": 2453
      },
      {
        "function_name": "r_core_free",
        "function_body": "static void r_core_free_autocomplete(RCore *core) {\n\tif (!core || !core->cons || !core->cons->line) {\n\t\treturn;\n\t}\n\tr_line_free_autocomplete (core->cons->line);\n}",
        "file_path": "/src/radare2/libr/core/core.c",
        "crashing_line": "",
        "crashing_line_number": 2490
      },
      {
        "function_name": "ExecuteCallback",
        "function_body": "void Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  if (SMR.IsClient())\n    SMR.WriteByteArray(Data, Size);\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (EF->__msan_unpoison)\n    EF->__msan_unpoison(DataCopy, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  {\n    ScopedEnableMsanInterceptorChecks S;\n    AllocTracer.Start(Options.TraceMalloc);\n    UnitStartTime = system_clock::now();\n    TPC.ResetMaps();\n    RunningUserCallback = true;\n    int Res = CB(DataCopy, Size);\n    RunningUserCallback = false;\n    UnitStopTime = system_clock::now();\n    (void)Res;\n    assert(Res == 0);\n    HasMoreMallocsThanFrees = AllocTracer.Stop();\n  }\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}",
        "file_path": "/src/libfuzzer/FuzzerLoop.cpp",
        "crashing_line": "    int Res = CB(DataCopy, Size);",
        "crashing_line_number": 571
      },
      {
        "function_name": "RunOneTest",
        "function_body": "int RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}",
        "file_path": "/src/libfuzzer/FuzzerDriver.cpp",
        "crashing_line": "  F->ExecuteCallback(U.data(), U.size());",
        "crashing_line_number": 280
      },
      {
        "function_name": "FuzzerDriver",
        "function_body": "int FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  if (EF->__msan_scoped_disable_interceptor_checks)\n    EF->__msan_scoped_disable_interceptor_checks();\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.LenControl = Flags.len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.ReduceDepth = Flags.reduce_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  Options.MallocLimitMb = Flags.malloc_limit_mb;\n  if (!Options.MallocLimitMb)\n    Options.MallocLimitMb = Options.RssLimitMb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  Options.PrintUnstableStats = Flags.print_unstable_stats;\n  if (Flags.handle_unstable == TracePC::MinUnstable ||\n      Flags.handle_unstable == TracePC::ZeroUnstable)\n    Options.HandleUnstable = Flags.handle_unstable;\n  Options.DumpCoverage = Flags.dump_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n  if (Flags.focus_function)\n    Options.FocusFunction = Flags.focus_function;\n  if (Flags.data_flow_trace)\n    Options.DataFlowTrace = Flags.data_flow_trace;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n#if 0  // deprecated, to be removed.\n  if (auto Name = Flags.run_equivalence_server) {\n    SMR.Destroy(Name);\n    if (!SMR.Create(Name)) {\n       Printf(\"ERROR: can't create shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE SERVER UP\\n\");\n    while (true) {\n      SMR.WaitClient();\n      size_t Size = SMR.ReadByteArraySize();\n      SMR.WriteByteArray(nullptr, 0);\n      const Unit tmp(SMR.GetByteArray(), SMR.GetByteArray() + Size);\n      F->ExecuteCallback(tmp.data(), tmp.size());\n      SMR.PostServer();\n    }\n    return 0;\n  }\n\n  if (auto Name = Flags.use_equivalence_server) {\n    if (!SMR.Open(Name)) {\n      Printf(\"ERROR: can't open shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE CLIENT UP\\n\");\n  }\n#endif\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.merge) {\n    F->CrashResistantMerge(Args, *Inputs,\n                           Flags.load_coverage_summary,\n                           Flags.save_coverage_summary,\n                           Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis succeeded\\n\");\n    exit(0);\n  }\n\n  F->Loop(*Inputs);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}",
        "file_path": "/src/libfuzzer/FuzzerDriver.cpp",
        "crashing_line": "        RunOneTest(F, Path.c_str(), Options.MaxLen);",
        "crashing_line_number": 713
      },
      {
        "function_name": "main",
        "function_body": "__attribute__((visibility(\"default\"))) int main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}",
        "file_path": "/src/libfuzzer/FuzzerMain.cpp",
        "crashing_line": "  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);",
        "crashing_line_number": 20
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "cmsHPROFILE CMSEXPORT cmsCreateProfilePlaceholder(cmsContext ContextID)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) _cmsMallocZero(ContextID, sizeof(_cmsICCPROFILE));\n    if (Icc == NULL) return NULL;\n\n    Icc ->ContextID = ContextID;\n\n    // Set it to empty\n    Icc -> TagCount   = 0;\n\n    // Set default version\n    Icc ->Version =  0x02100000;\n    \n    // Set creation date/time\n    if (!_cmsGetTime(&Icc->Created))\n        goto Error;\n\n    // Create a mutex if the user provided proper plugin. NULL otherwise\n    Icc ->UsrMutex = _cmsCreateMutex(ContextID);\n\n    // Return the handle\n    return (cmsHPROFILE) Icc;\n\nError:\n    _cmsFree(ContextID, Icc);\n    return NULL;\n}\ncmsBool _cmsReadHeader(_cmsICCPROFILE* Icc)\n{\n    cmsTagEntry Tag;\n    cmsICCHeader Header;\n    cmsUInt32Number i, j;\n    cmsUInt32Number HeaderSize;\n    cmsIOHANDLER* io = Icc ->IOhandler;\n    cmsUInt32Number TagCount;\n\n\n    // Read the header\n    if (io -> Read(io, &Header, sizeof(cmsICCHeader), 1) != 1) {\n        return FALSE;\n    }\n\n    // Validate file as an ICC profile\n    if (_cmsAdjustEndianess32(Header.magic) != cmsMagicNumber) {\n        cmsSignalError(Icc ->ContextID, cmsERROR_BAD_SIGNATURE, \"not an ICC profile, invalid signature\");\n        return FALSE;\n    }\n\n    // Adjust endianness of the used parameters\n    Icc -> DeviceClass     = (cmsProfileClassSignature) _cmsAdjustEndianess32(Header.deviceClass);\n    Icc -> ColorSpace      = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.colorSpace);\n    Icc -> PCS             = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.pcs);\n   \n    Icc -> RenderingIntent = _cmsAdjustEndianess32(Header.renderingIntent);\n    Icc -> flags           = _cmsAdjustEndianess32(Header.flags);\n    Icc -> manufacturer    = _cmsAdjustEndianess32(Header.manufacturer);\n    Icc -> model           = _cmsAdjustEndianess32(Header.model);\n    Icc -> creator         = _cmsAdjustEndianess32(Header.creator);\n    \n    _cmsAdjustEndianess64(&Icc -> attributes, &Header.attributes);\n    Icc -> Version         = _cmsAdjustEndianess32(_validatedVersion(Header.version));\n\n    // Get size as reported in header\n    HeaderSize = _cmsAdjustEndianess32(Header.size);\n\n    // Make sure HeaderSize is lower than profile size\n    if (HeaderSize >= Icc ->IOhandler ->ReportedSize)\n            HeaderSize = Icc ->IOhandler ->ReportedSize;\n\n\n    // Get creation date/time\n    _cmsDecodeDateTimeNumber(&Header.date, &Icc ->Created);\n\n    // The profile ID are 32 raw bytes\n    memmove(Icc ->ProfileID.ID32, Header.profileID.ID32, 16);\n\n\n    // Read tag directory\n    if (!_cmsReadUInt32Number(io, &TagCount)) return FALSE;\n    if (TagCount > MAX_TABLE_TAG) {\n\n        cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, \"Too many tags (%d)\", TagCount);\n        return FALSE;\n    }\n\n\n    // Read tag directory\n    Icc -> TagCount = 0;\n    for (i=0; i < TagCount; i++) {\n\n        if (!_cmsReadUInt32Number(io, (cmsUInt32Number *) &Tag.sig)) return FALSE;\n        if (!_cmsReadUInt32Number(io, &Tag.offset)) return FALSE;\n        if (!_cmsReadUInt32Number(io, &Tag.size)) return FALSE;\n\n        // Perform some sanity check. Offset + size should fall inside file.\n        if (Tag.size == 0 || Tag.offset == 0) continue;\n        if (Tag.offset + Tag.size > HeaderSize ||\n            Tag.offset + Tag.size < Tag.offset)\n                  continue;\n\n        Icc -> TagNames[Icc ->TagCount]   = Tag.sig;\n        Icc -> TagOffsets[Icc ->TagCount] = Tag.offset;\n        Icc -> TagSizes[Icc ->TagCount]   = Tag.size;\n\n       // Search for links\n        for (j=0; j < Icc ->TagCount; j++) {\n           \n            if ((Icc ->TagOffsets[j] == Tag.offset) &&\n                (Icc ->TagSizes[j]   == Tag.size)) {\n\n                // Check types. \n                if (CompatibleTypes(_cmsGetTagDescriptor(Icc->ContextID, Icc->TagNames[j]),\n                                    _cmsGetTagDescriptor(Icc->ContextID, Tag.sig))) {\n\n                    Icc->TagLinked[Icc->TagCount] = Icc->TagNames[j];\n                }\n            }\n\n        }\n\n        Icc ->TagCount++;\n    }\n\n\n    for (i = 0; i < Icc->TagCount; i++) {\n        for (j = 0; j < Icc->TagCount; j++) {\n\n            // Tags cannot be duplicate\n            if ((i != j) && (Icc->TagNames[i] == Icc->TagNames[j])) {\n                cmsSignalError(Icc->ContextID, cmsERROR_RANGE, \"Duplicate tag found\");\n                return FALSE;\n            }\n\n        }\n    }\n\n    return TRUE;\n}\ncmsHPROFILE CMSEXPORT cmsCreateRGBProfileTHR(cmsContext ContextID,\n                                          const cmsCIExyY* WhitePoint,\n                                          const cmsCIExyYTRIPLE* Primaries,\n                                          cmsToneCurve* const TransferFunction[3])\n{\n    cmsHPROFILE hICC;\n    cmsMAT3 MColorants;\n    cmsCIEXYZTRIPLE Colorants;\n    cmsCIExyY MaxWhite;\n    cmsMAT3 CHAD;\n    cmsCIEXYZ WhitePointXYZ;\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.3);\n\n    cmsSetDeviceClass(hICC,      cmsSigDisplayClass);\n    cmsSetColorSpace(hICC,       cmsSigRgbData);\n    cmsSetPCS(hICC,              cmsSigXYZData);\n\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n\n    // Implement profile using following tags:\n    //\n    //  1 cmsSigProfileDescriptionTag\n    //  2 cmsSigMediaWhitePointTag\n    //  3 cmsSigRedColorantTag\n    //  4 cmsSigGreenColorantTag\n    //  5 cmsSigBlueColorantTag\n    //  6 cmsSigRedTRCTag\n    //  7 cmsSigGreenTRCTag\n    //  8 cmsSigBlueTRCTag\n    //  9 Chromatic adaptation Tag\n    // This conforms a standard RGB DisplayProfile as says ICC, and then I add (As per addendum II)\n    // 10 cmsSigChromaticityTag\n\n\n    if (!SetTextTags(hICC, L\"RGB built-in\")) goto Error;\n\n    if (WhitePoint) {\n\n        if (!cmsWriteTag(hICC, cmsSigMediaWhitePointTag, cmsD50_XYZ())) goto Error;\n\n        cmsxyY2XYZ(&WhitePointXYZ, WhitePoint);\n        _cmsAdaptationMatrix(&CHAD, NULL, &WhitePointXYZ, cmsD50_XYZ());\n\n        // This is a V4 tag, but many CMM does read and understand it no matter which version\n        if (!cmsWriteTag(hICC, cmsSigChromaticAdaptationTag, (void*) &CHAD)) goto Error;\n    }\n\n    if (WhitePoint && Primaries) {\n\n        MaxWhite.x =  WhitePoint -> x;\n        MaxWhite.y =  WhitePoint -> y;\n        MaxWhite.Y =  1.0;\n\n        if (!_cmsBuildRGB2XYZtransferMatrix(&MColorants, &MaxWhite, Primaries)) goto Error;\n\n        Colorants.Red.X   = MColorants.v[0].n[0];\n        Colorants.Red.Y   = MColorants.v[1].n[0];\n        Colorants.Red.Z   = MColorants.v[2].n[0];\n\n        Colorants.Green.X = MColorants.v[0].n[1];\n        Colorants.Green.Y = MColorants.v[1].n[1];\n        Colorants.Green.Z = MColorants.v[2].n[1];\n\n        Colorants.Blue.X  = MColorants.v[0].n[2];\n        Colorants.Blue.Y  = MColorants.v[1].n[2];\n        Colorants.Blue.Z  = MColorants.v[2].n[2];\n\n        if (!cmsWriteTag(hICC, cmsSigRedColorantTag,   (void*) &Colorants.Red)) goto Error;\n        if (!cmsWriteTag(hICC, cmsSigBlueColorantTag,  (void*) &Colorants.Blue)) goto Error;\n        if (!cmsWriteTag(hICC, cmsSigGreenColorantTag, (void*) &Colorants.Green)) goto Error;\n    }\n\n\n    if (TransferFunction) {\n\n        // Tries to minimize space. Thanks to Richard Hughes for this nice idea         \n        if (!cmsWriteTag(hICC, cmsSigRedTRCTag,   (void*) TransferFunction[0])) goto Error;\n\n        if (TransferFunction[1] == TransferFunction[0]) {\n\n            if (!cmsLinkTag (hICC, cmsSigGreenTRCTag, cmsSigRedTRCTag)) goto Error;\n\n        } else {\n\n            if (!cmsWriteTag(hICC, cmsSigGreenTRCTag, (void*) TransferFunction[1])) goto Error;\n        }\n\n        if (TransferFunction[2] == TransferFunction[0]) {\n\n            if (!cmsLinkTag (hICC, cmsSigBlueTRCTag, cmsSigRedTRCTag)) goto Error;\n\n        } else {\n\n            if (!cmsWriteTag(hICC, cmsSigBlueTRCTag, (void*) TransferFunction[2])) goto Error;\n        }\n    }\n\n    if (Primaries) {\n        if (!cmsWriteTag(hICC, cmsSigChromaticityTag, (void*) Primaries)) goto Error;\n    }\n\n\n    return hICC;\n\nError:\n    if (hICC)\n        cmsCloseProfile(hICC);\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateGrayProfileTHR(cmsContext ContextID,\n                                           const cmsCIExyY* WhitePoint,\n                                           const cmsToneCurve* TransferFunction)\n{\n    cmsHPROFILE hICC;\n    cmsCIEXYZ tmp;\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.3);\n\n    cmsSetDeviceClass(hICC,      cmsSigDisplayClass);\n    cmsSetColorSpace(hICC,       cmsSigGrayData);\n    cmsSetPCS(hICC,              cmsSigXYZData);\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n\n    // Implement profile using following tags:\n    //\n    //  1 cmsSigProfileDescriptionTag\n    //  2 cmsSigMediaWhitePointTag\n    //  3 cmsSigGrayTRCTag\n\n    // This conforms a standard Gray DisplayProfile\n\n    // Fill-in the tags\n\n    if (!SetTextTags(hICC, L\"gray built-in\")) goto Error;\n\n\n    if (WhitePoint) {\n\n        cmsxyY2XYZ(&tmp, WhitePoint);\n        if (!cmsWriteTag(hICC, cmsSigMediaWhitePointTag, (void*) &tmp)) goto Error;\n    }\n\n    if (TransferFunction) {\n\n        if (!cmsWriteTag(hICC, cmsSigGrayTRCTag, (void*) TransferFunction)) goto Error;\n    }\n\n    return hICC;\n\nError:\n    if (hICC)\n        cmsCloseProfile(hICC);\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateLinearizationDeviceLinkTHR(cmsContext ContextID,\n                                                          cmsColorSpaceSignature ColorSpace,\n                                                          cmsToneCurve* const TransferFunctions[])\n{\n    cmsHPROFILE hICC;\n    cmsPipeline* Pipeline;\n    cmsUInt32Number nChannels;\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.3);\n\n    cmsSetDeviceClass(hICC,      cmsSigLinkClass);\n    cmsSetColorSpace(hICC,       ColorSpace);\n    cmsSetPCS(hICC,              ColorSpace);\n\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n    // Set up channels\n    nChannels = cmsChannelsOf(ColorSpace);\n\n    // Creates a Pipeline with prelinearization step only\n    Pipeline = cmsPipelineAlloc(ContextID, nChannels, nChannels);\n    if (Pipeline == NULL) goto Error;\n\n\n    // Copy tables to Pipeline\n    if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, cmsStageAllocToneCurves(ContextID, nChannels, TransferFunctions)))\n        goto Error;\n\n    // Create tags\n    if (!SetTextTags(hICC, L\"Linearization built-in\")) goto Error;\n    if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline)) goto Error;\n    if (!SetSeqDescTag(hICC, \"Linearization built-in\")) goto Error;\n\n    // Pipeline is already on virtual profile\n    cmsPipelineFree(Pipeline);\n\n    // Ok, done\n    return hICC;\n\nError:\n    cmsPipelineFree(Pipeline);\n    if (hICC)\n        cmsCloseProfile(hICC);\n\n\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateInkLimitingDeviceLinkTHR(cmsContext ContextID,\n                                                     cmsColorSpaceSignature ColorSpace,\n                                                     cmsFloat64Number Limit)\n{\n    cmsHPROFILE hICC;\n    cmsPipeline* LUT;\n    cmsStage* CLUT;\n    cmsUInt32Number nChannels;\n\n    if (ColorSpace != cmsSigCmykData) {\n        cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, \"InkLimiting: Only CMYK currently supported\");\n        return NULL;\n    }\n\n    if (Limit < 0.0 || Limit > 400) {\n\n        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 0..400\");\n        if (Limit < 0) Limit = 0;\n        if (Limit > 400) Limit = 400;\n\n    }\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.3);\n\n    cmsSetDeviceClass(hICC,      cmsSigLinkClass);\n    cmsSetColorSpace(hICC,       ColorSpace);\n    cmsSetPCS(hICC,              ColorSpace);\n\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n\n    // Creates a Pipeline with 3D grid only\n    LUT = cmsPipelineAlloc(ContextID, 4, 4);\n    if (LUT == NULL) goto Error;\n\n\n    nChannels = cmsChannelsOf(ColorSpace);\n\n    CLUT = cmsStageAllocCLut16bit(ContextID, 17, nChannels, nChannels, NULL);\n    if (CLUT == NULL) goto Error;\n\n    if (!cmsStageSampleCLut16bit(CLUT, InkLimitingSampler, (void*) &Limit, 0)) goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, nChannels)) ||\n        !cmsPipelineInsertStage(LUT, cmsAT_END, CLUT) ||\n        !cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, nChannels)))\n        goto Error;\n\n    // Create tags\n    if (!SetTextTags(hICC, L\"ink-limiting built-in\")) goto Error;\n\n    if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) LUT))  goto Error;\n    if (!SetSeqDescTag(hICC, \"ink-limiting built-in\")) goto Error;\n\n    // cmsPipeline is already on virtual profile\n    cmsPipelineFree(LUT);\n\n    // Ok, done\n    return hICC;\n\nError:\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hICC != NULL)\n        cmsCloseProfile(hICC);\n\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateLab4ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n\n    hProfile = cmsCreateRGBProfileTHR(ContextID, WhitePoint == NULL ? cmsD50_xyY() : WhitePoint, NULL, NULL);\n    if (hProfile == NULL) return NULL;\n\n    cmsSetProfileVersion(hProfile, 4.3);\n\n    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);\n    cmsSetColorSpace(hProfile,  cmsSigLabData);\n    cmsSetPCS(hProfile,         cmsSigLabData);\n\n    if (!SetTextTags(hProfile, L\"Lab identity built-in\")) goto Error;\n\n    // An empty LUTs is all we need\n    LUT = cmsPipelineAlloc(ContextID, 3, 3);\n    if (LUT == NULL) goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))\n        goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;\n    cmsPipelineFree(LUT);\n\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateXYZProfileTHR(cmsContext ContextID)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n\n    hProfile = cmsCreateRGBProfileTHR(ContextID, cmsD50_xyY(), NULL, NULL);\n    if (hProfile == NULL) return NULL;\n\n    cmsSetProfileVersion(hProfile, 4.3);\n\n    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);\n    cmsSetColorSpace(hProfile,  cmsSigXYZData);\n    cmsSetPCS(hProfile,         cmsSigXYZData);\n\n    if (!SetTextTags(hProfile, L\"XYZ identity built-in\")) goto Error;\n\n    // An identity LUT is all we need\n    LUT = cmsPipelineAlloc(ContextID, 3, 3);\n    if (LUT == NULL) goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))\n        goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;\n    cmsPipelineFree(LUT);\n\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}\ncmsHPROFILE CMSEXPORT cmsCreateNULLProfileTHR(cmsContext ContextID)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n    cmsStage* PostLin;\n    cmsStage* OutLin;\n    cmsToneCurve* EmptyTab[3];\n    cmsUInt16Number Zero[2] = { 0, 0 };\n    const cmsFloat64Number PickLstarMatrix[] = { 1, 0, 0 };\n\n    hProfile = cmsCreateProfilePlaceholder(ContextID);\n    if (!hProfile)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hProfile, 4.3);\n\n    if (!SetTextTags(hProfile, L\"NULL profile built-in\")) goto Error;\n\n\n    cmsSetDeviceClass(hProfile, cmsSigOutputClass);\n    cmsSetColorSpace(hProfile,  cmsSigGrayData);\n    cmsSetPCS(hProfile,         cmsSigLabData);\n\n    // Create a valid ICC 4 structure\n    LUT = cmsPipelineAlloc(ContextID, 3, 1);\n    if (LUT == NULL) goto Error;\n    \n    EmptyTab[0] = EmptyTab[1] = EmptyTab[2] = cmsBuildTabulatedToneCurve16(ContextID, 2, Zero);\n    PostLin = cmsStageAllocToneCurves(ContextID, 3, EmptyTab);\n    OutLin  = cmsStageAllocToneCurves(ContextID, 1, EmptyTab);\n    cmsFreeToneCurve(EmptyTab[0]);\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_END, PostLin))\n        goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_END, cmsStageAllocMatrix(ContextID, 1, 3, PickLstarMatrix, NULL)))\n        goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_END, OutLin))\n        goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, (void*) LUT)) goto Error;\n    if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, cmsD50_XYZ())) goto Error;\n\n    cmsPipelineFree(LUT);\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}\n",
    "target": 1,
    "idx": 1049546,
    "stack_trace": [
      {
        "function_name": "cmsFreeNamedColorList",
        "function_body": "void CMSEXPORT cmsFreeNamedColorList(cmsNAMEDCOLORLIST* v)\n{\n    if (v == NULL) return;\n    if (v ->List) _cmsFree(v ->ContextID, v ->List);\n    _cmsFree(v ->ContextID, v);\n}",
        "file_path": "/src/lcms/src/cmsnamed.c",
        "crashing_line": "    if (v ->List) _cmsFree(v ->ContextID, v ->List);",
        "crashing_line_number": 577
      },
      {
        "function_name": "Type_NamedColor_Free",
        "function_body": "static\nvoid Type_NamedColor_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
        "file_path": "/src/lcms/src/cmstypes.c",
        "crashing_line": "    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);",
        "crashing_line_number": 3277
      },
      {
        "function_name": "freeOneTag",
        "function_body": "static\nvoid freeOneTag(_cmsICCPROFILE* Icc, cmsUInt32Number i)\n{\n    if (Icc->TagPtrs[i]) {\n\n        cmsTagTypeHandler* TypeHandler = Icc->TagTypeHandlers[i];\n\n        if (TypeHandler != NULL) {\n            cmsTagTypeHandler LocalTypeHandler = *TypeHandler;\n\n            LocalTypeHandler.ContextID = Icc->ContextID;             \n            LocalTypeHandler.ICCVersion = Icc->Version;\n            LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc->TagPtrs[i]);\n        }\n        else\n            _cmsFree(Icc->ContextID, Icc->TagPtrs[i]);\n    }\n}",
        "file_path": "/src/lcms/src/cmsio0.c",
        "crashing_line": "",
        "crashing_line_number": 1522
      },
      {
        "function_name": "cmsCloseProfile",
        "function_body": "cmsBool  CMSEXPORT cmsCloseProfile(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    cmsBool  rc = TRUE;\n    cmsUInt32Number i;\n\n    if (!Icc) return FALSE;\n\n    // Was open in write mode?\n    if (Icc ->IsWrite) {\n\n        Icc ->IsWrite = FALSE;      // Assure no further writing\n        rc &= cmsSaveProfileToFile(hProfile, Icc ->IOhandler->PhysicalFile);\n    }\n\n    for (i=0; i < Icc -> TagCount; i++) {\n\n        freeOneTag(Icc, i);        \n    }\n\n    if (Icc ->IOhandler != NULL) {\n        rc &= cmsCloseIOhandler(Icc->IOhandler);\n    }\n\n    _cmsDestroyMutex(Icc->ContextID, Icc->UsrMutex);\n\n    _cmsFree(Icc ->ContextID, Icc);   // Free placeholder memory\n\n    return rc;\n}",
        "file_path": "/src/lcms/src/cmsio0.c",
        "crashing_line": "",
        "crashing_line_number": 1547
      },
      {
        "function_name": "run_test",
        "function_body": "void\nrun_test(const uint8_t *data,\n         size_t size,\n         uint32_t intent_id,\n         uint32_t input_format,\n         uint32_t output_format,\n         uint32_t flags) {\n if (size < 2) {\n   return;\n }\n\n size_t mid = size / 2;\n\n cmsHPROFILE hInProfile, hOutProfile;\n cmsHTRANSFORM hTransform;\n\n hInProfile = cmsOpenProfileFromMem(data, mid);\n hOutProfile = cmsOpenProfileFromMem(data + mid, size - mid);\n hTransform = cmsCreateTransform(hInProfile, input_format, hOutProfile,\n                                 output_format, intent_id, flags);\n cmsCloseProfile(hInProfile);\n cmsCloseProfile(hOutProfile);\n\n if (hTransform) {\n   cmsDeleteTransform(hTransform);\n }\n}",
        "file_path": "/src/cms_transform_all_fuzzer.c",
        "crashing_line": " cmsCloseProfile(hInProfile);",
        "crashing_line_number": 36
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void update_errors_warnings(timelib_error_container **last_errors) /* {{{ */\n{\n\tif (DATEG(last_errors)) {\n\t\ttimelib_error_container_dtor(DATEG(last_errors));\n\t\tDATEG(last_errors) = NULL;\n\t}\n\n\tif (last_errors == NULL || (*last_errors) == NULL) {\n\t\treturn;\n\t}\n\n\tif ((*last_errors)->warning_count || (*last_errors)->error_count) {\n\t\tDATEG(last_errors) = *last_errors;\n\t}\n\n\ttimelib_error_container_dtor(*last_errors);\n\t*last_errors = NULL;\n} /* }}} */\n",
    "target": 1,
    "idx": 1051169,
    "stack_trace": [
      {
        "function_name": "timelib_error_container_dtor",
        "function_body": "void timelib_error_container_dtor(timelib_error_container *errors)\n{\n\tint i;\n\n\tfor (i = 0; i < errors->warning_count; i++) {\n\t\ttimelib_free(errors->warning_messages[i].message);\n\t}\n\ttimelib_free(errors->warning_messages);\n\tfor (i = 0; i < errors->error_count; i++) {\n\t\ttimelib_free(errors->error_messages[i].message);\n\t}\n\ttimelib_free(errors->error_messages);\n\ttimelib_free(errors);\n}",
        "file_path": "/src/php-src/ext/date/lib/timelib.c",
        "crashing_line": "\tfor (i = 0; i < errors->warning_count; i++) {",
        "crashing_line_number": 159
      },
      {
        "function_name": "zm_post_zend_deactivate_date",
        "function_body": "",
        "file_path": "/src/php-src/ext/date/php_date.c",
        "crashing_line": "",
        "crashing_line_number": 426
      },
      {
        "function_name": "zend_post_deactivate_modules",
        "function_body": "ZEND_API void zend_post_deactivate_modules(void) /* {{{ */\n{\n\tif (EG(full_tables_cleanup)) {\n\t\tzend_module_entry *module;\n\t\tzval *zv;\n\t\tzend_string *key;\n\n\t\tZEND_HASH_MAP_FOREACH_PTR(&module_registry, module) {\n\t\t\tif (module->post_deactivate_func) {\n\t\t\t\tmodule->post_deactivate_func();\n\t\t\t}\n\t\t} ZEND_HASH_FOREACH_END();\n\t\tZEND_HASH_MAP_REVERSE_FOREACH_STR_KEY_VAL(&module_registry, key, zv) {\n\t\t\tmodule = Z_PTR_P(zv);\n\t\t\tif (module->type != MODULE_TEMPORARY) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmodule_destructor(module);\n\t\t\tzend_string_release_ex(key, 0);\n\t\t} ZEND_HASH_MAP_FOREACH_END_DEL();\n\t} else {\n\t\tzend_module_entry **p = module_post_deactivate_handlers;\n\n\t\twhile (*p) {\n\t\t\tzend_module_entry *module = *p;\n\n\t\t\tmodule->post_deactivate_func();\n\t\t\tp++;\n\t\t}\n\t}\n}",
        "file_path": "/src/php-src/Zend/zend_API.c",
        "crashing_line": "\t\t\tmodule->post_deactivate_func();",
        "crashing_line_number": 3154
      },
      {
        "function_name": "php_request_shutdown",
        "function_body": "void php_request_shutdown(void *dummy)\n{\n\tbool report_memleaks;\n\n\tEG(flags) |= EG_FLAGS_IN_SHUTDOWN;\n\n\treport_memleaks = PG(report_memleaks);\n\n\t/* EG(current_execute_data) points into nirvana and therefore cannot be safely accessed\n\t * inside zend_executor callback functions.\n\t */\n\tEG(current_execute_data) = NULL;\n\n\tphp_deactivate_ticks();\n\n\t/* 0. Call any open observer end handlers that are still open after a zend_bailout */\n\tif (ZEND_OBSERVER_ENABLED) {\n\t\tzend_observer_fcall_end_all();\n\t}\n\n\t/* 1. Call all possible shutdown functions registered with register_shutdown_function() */\n\tif (PG(modules_activated)) {\n\t\tphp_call_shutdown_functions();\n\t}\n\n\t/* 2. Call all possible __destruct() functions */\n\tzend_try {\n\t\tzend_call_destructors();\n\t} zend_end_try();",
        "file_path": "/src/php-src/main/main.c",
        "crashing_line": "",
        "crashing_line_number": 1865
      },
      {
        "function_name": "fuzzer_request_shutdown",
        "function_body": "void fuzzer_request_shutdown()\n{\n\tzend_try {\n\t\t/* Destroy thrown exceptions. This does not happen as part of request shutdown. */\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\n\t\t/* Some fuzzers (like unserialize) may create circular structures. Make sure we free them.\n\t\t * Two calls are performed to handle objects with destructors. */\n\t\tzend_gc_collect_cycles();\n\t\tzend_gc_collect_cycles();\n\t} zend_end_try();\n\n\tphp_request_shutdown(NULL);\n}",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-sapi.c",
        "crashing_line": "\tphp_request_shutdown(NULL);",
        "crashing_line_number": 205
      },
      {
        "function_name": "fuzzer_do_request_from_buffer",
        "function_body": "int fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, bool execute,\n\t\tvoid (*before_shutdown)(void))\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.primary_script = 1;\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\t\t/* Avoid ZEND_HANDLE_FILENAME for opcache. */\n\t\tfile_handle.type = ZEND_HANDLE_STREAM;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tzend_destroy_file_handle(&file_handle);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tzend_destroy_static_vars(op_array);\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\tCG(compiled_filename) = NULL; /* ??? */\n\tif (before_shutdown) {\n\t\tbefore_shutdown();\n\t}\n\tfuzzer_request_shutdown();\n\n\treturn (retval == SUCCESS) ? SUCCESS : FAILURE;\n}",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-sapi.c",
        "crashing_line": "\tfuzzer_request_shutdown();",
        "crashing_line_number": 285
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void\nclear_all_old(mrb_state *mrb, mrb_gc *gc)\n{\n  mrb_assert(is_generational(gc));\n  if (gc->full) {\n    /* finish the half baked GC */\n    incremental_gc_finish(mrb, gc);\n  }\n  else {\n    /* Sweep the dead objects, then reset all the live objects\n     * (including all the old objects, of course) to white. */\n    gc->generational = FALSE;\n    prepare_incremental_sweep(mrb, gc);\n    incremental_gc_finish(mrb, gc);\n    gc->generational = TRUE;\n  }\n  /* The gray objects have already been painted as white */\n  gc->atomic_gray_list = gc->gray_list = NULL;\n}\n",
    "target": 1,
    "idx": 1057703,
    "stack_trace": [
      {
        "function_name": "mrb_gc_mark",
        "function_body": "MRB_API void\nmrb_gc_mark(mrb_state *mrb, struct RBasic *obj)\n{\n  if (obj == 0) return;\n  if (!is_white(obj)) return;\n  if (is_red(obj)) return;\n  mrb_assert((obj)->tt != MRB_TT_FREE);\n  add_gray_list(mrb, &mrb->gc, obj);\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "  if (!is_white(obj)) return;",
        "crashing_line_number": 743
      },
      {
        "function_name": "iv_mark_i",
        "function_body": "static int\niv_mark_i(mrb_state *mrb, mrb_sym sym, mrb_value v, void *p)\n{\n  mrb_gc_mark_value(mrb, v);\n  return 0;\n}",
        "file_path": "/src/mruby/src/variable.c",
        "crashing_line": "  mrb_gc_mark_value(mrb, v);",
        "crashing_line_number": 238
      },
      {
        "function_name": "iv_foreach",
        "function_body": "static void\niv_foreach(mrb_state *mrb, iv_tbl *t, mrb_iv_foreach_func *func, void *p)\n{\n  int i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  mrb_value *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    if (IV_KEY_P(keys[i])) {\n      if ((*func)(mrb, keys[i], vals[i], p) != 0) {\n        return;\n      }\n    }\n  }\n  return;\n}",
        "file_path": "/src/mruby/src/variable.c",
        "crashing_line": "      if ((*func)(mrb, keys[i], vals[i], p) != 0) {",
        "crashing_line_number": 188
      },
      {
        "function_name": "mark_tbl",
        "function_body": "static void\nmark_tbl(mrb_state *mrb, iv_tbl *t)\n{\n  iv_foreach(mrb, t, iv_mark_i, 0);\n}",
        "file_path": "/src/mruby/src/variable.c",
        "crashing_line": "  iv_foreach(mrb, t, iv_mark_i, 0);",
        "crashing_line_number": 245
      },
      {
        "function_name": "mrb_gc_mark_iv",
        "function_body": "void\nmrb_gc_mark_iv(mrb_state *mrb, struct RObject *obj)\n{\n  mark_tbl(mrb, obj->iv);\n}",
        "file_path": "/src/mruby/src/variable.c",
        "crashing_line": "  mark_tbl(mrb, obj->iv);",
        "crashing_line_number": 264
      },
      {
        "function_name": "gc_mark_children",
        "function_body": "static void\ngc_mark_children(mrb_state *mrb, mrb_gc *gc, struct RBasic *obj)\n{\n  mrb_assert(is_gray(obj));\n  paint_black(obj);\n  mrb_gc_mark(mrb, (struct RBasic*)obj->c);\n  switch (obj->tt) {\n  case MRB_TT_ICLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n      if (MRB_FLAG_TEST(c, MRB_FL_CLASS_IS_ORIGIN))\n        mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RClass*)obj)->super);\n    }\n    break;\n\n  case MRB_TT_CLASS:\n  case MRB_TT_MODULE:\n  case MRB_TT_SCLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n\n      mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)c->super);\n    }\n    /* fall through */\n\n  case MRB_TT_OBJECT:\n  case MRB_TT_CDATA:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    break;\n\n  case MRB_TT_PROC:\n    {\n      struct RProc *p = (struct RProc*)obj;\n\n      mrb_gc_mark(mrb, (struct RBasic*)p->upper);\n      mrb_gc_mark(mrb, (struct RBasic*)p->e.env);\n    }\n    break;\n\n  case MRB_TT_ENV:\n    {\n      struct REnv *e = (struct REnv*)obj;\n      mrb_int i, len;\n\n      if (MRB_ENV_ONSTACK_P(e) && e->cxt && e->cxt->fib) {\n        mrb_gc_mark(mrb, (struct RBasic*)e->cxt->fib);\n      }\n      len = MRB_ENV_LEN(e);\n      for (i=0; i<len; i++) {\n        mrb_gc_mark_value(mrb, e->stack[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_FIBER:\n    {\n      struct mrb_context *c = ((struct RFiber*)obj)->cxt;\n\n      if (c) mark_context(mrb, c);\n    }\n    break;\n\n  case MRB_TT_STRUCT:\n  case MRB_TT_ARRAY:\n    {\n      struct RArray *a = (struct RArray*)obj;\n      size_t e=ARY_LEN(a);\n      mrb_value *p = ARY_PTR(a);\n\n      for (size_t i=0; i<e; i++) {\n        mrb_gc_mark_value(mrb, p[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_HASH:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    mrb_gc_mark_hash(mrb, (struct RHash*)obj);\n    break;\n\n  case MRB_TT_STRING:\n    if (RSTR_FSHARED_P(obj)) {\n      struct RString *s = (struct RString*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)s->as.heap.aux.fshared);\n    }\n    break;\n\n  case MRB_TT_RANGE:\n    mrb_gc_mark_range(mrb, (struct RRange*)obj);\n    break;\n\n  case MRB_TT_BREAK:\n    {\n      struct RBreak *brk = (struct RBreak*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)mrb_break_proc_get(brk));\n      mrb_gc_mark_value(mrb, mrb_break_value_get(brk));\n    }\n    break;\n\n  case MRB_TT_EXCEPTION:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    if (((struct RException*)obj)->mesg) {\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->mesg);\n    }\n    mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->backtrace);\n    break;\n\n  default:\n    break;\n  }\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "    mrb_gc_mark_iv(mrb, (struct RObject*)obj);",
        "crashing_line_number": 654
      },
      {
        "function_name": "incremental_marking_phase",
        "function_body": "static size_t\nincremental_marking_phase(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  size_t tried_marks = 0;\n\n  while (gc->gray_list && tried_marks < limit) {\n    struct RBasic *obj = gc->gray_list;\n    gc->gray_list = obj->gcnext;\n    obj->gcnext = NULL;\n    gc_mark_children(mrb, gc, obj);\n    tried_marks += gc_gray_counts(mrb, gc, obj);\n  }\n\n  return tried_marks;\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "    gc_mark_children(mrb, gc, obj);",
        "crashing_line_number": 1052
      },
      {
        "function_name": "incremental_gc",
        "function_body": "static size_t\nincremental_gc(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  switch (gc->state) {\n  case MRB_GC_STATE_ROOT:\n    root_scan_phase(mrb, gc);\n    gc->state = MRB_GC_STATE_MARK;\n    flip_white_part(gc);\n    return 0;\n  case MRB_GC_STATE_MARK:\n    if (gc->gray_list) {\n      return incremental_marking_phase(mrb, gc, limit);\n    }\n    else {\n      final_marking_phase(mrb, gc);\n      prepare_incremental_sweep(mrb, gc);\n      return 0;\n    }\n  case MRB_GC_STATE_SWEEP: {\n     size_t tried_sweep = 0;\n     tried_sweep = incremental_sweep_phase(mrb, gc, limit);\n     if (tried_sweep == 0)\n       gc->state = MRB_GC_STATE_ROOT;\n     return tried_sweep;\n  }\n  default:\n    /* unknown state */\n    mrb_assert(0);\n    return 0;\n  }\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "      return incremental_marking_phase(mrb, gc, limit);",
        "crashing_line_number": 1192
      },
      {
        "function_name": "incremental_gc_finish",
        "function_body": "static void\nincremental_gc_finish(mrb_state *mrb, mrb_gc *gc)\n{\n  do {\n    incremental_gc(mrb, gc, SIZE_MAX);\n  } while (gc->state != MRB_GC_STATE_ROOT);\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "    incremental_gc(mrb, gc, SIZE_MAX);",
        "crashing_line_number": 1217
      },
      {
        "function_name": "mrb_full_gc",
        "function_body": "MRB_API void\nmrb_full_gc(mrb_state *mrb)\n{\n  mrb_gc *gc = &mrb->gc;\n\n  if (!mrb->c) return;\n  if (gc->disabled || gc->iterating) return;\n\n  if (is_generational(gc)) {\n    /* clear all the old objects back to young */\n    clear_all_old(mrb, gc);\n    gc->full = TRUE;\n  }\n  else if (gc->state != MRB_GC_STATE_ROOT) {\n    /* finish half baked GC cycle */\n    incremental_gc_finish(mrb, gc);\n  }\n\n  incremental_gc_finish(mrb, gc);\n  gc->threshold = (gc->live_after_mark/100) * gc->interval_ratio;\n\n  if (is_generational(gc)) {\n    gc->majorgc_old_threshold = gc->live_after_mark/100 * MAJOR_GC_INC_RATIO;\n    gc->full = FALSE;\n  }\n\n#ifdef MRB_USE_MALLOC_TRIM\n  malloc_trim(0);\n#endif\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "",
        "crashing_line_number": 1317
      },
      {
        "function_name": "mrb_objspace_each_objects",
        "function_body": "void\nmrb_objspace_each_objects(mrb_state *mrb, mrb_each_object_callback *callback, void *data)\n{\n  mrb_bool iterating = mrb->gc.iterating;\n\n  mrb_full_gc(mrb);\n  mrb->gc.iterating = TRUE;\n  if (iterating) {\n    gc_each_objects(mrb, &mrb->gc, callback, data);\n  }\n  else {\n    struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n    struct mrb_jmpbuf c_jmp;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      gc_each_objects(mrb, &mrb->gc, callback, data);\n      mrb->jmp = prev_jmp;\n      mrb->gc.iterating = iterating;\n    } MRB_CATCH(&c_jmp) {\n      mrb->gc.iterating = iterating;\n      mrb->jmp = prev_jmp;\n      MRB_THROW(prev_jmp);\n    } MRB_END_EXC(&c_jmp);\n  }\n}",
        "file_path": "/src/mruby/src/gc.c",
        "crashing_line": "  if (iterating) {",
        "crashing_line_number": 1591
      },
      {
        "function_name": "os_count_objects",
        "function_body": "static mrb_value\nos_count_objects(mrb_state *mrb, mrb_value self)\n{\n  struct os_count_struct obj_count = { 0 };\n  mrb_int i;\n  mrb_value hash;\n\n  if (mrb_get_args(mrb, \"|H\", &hash) == 0) {\n    hash = mrb_hash_new(mrb);\n  }\n\n  if (!mrb_hash_empty_p(mrb, hash)) {\n    mrb_hash_clear(mrb, hash);\n  }\n\n  mrb_objspace_each_objects(mrb, os_count_object_type, &obj_count);\n\n  mrb_hash_set(mrb, hash, mrb_symbol_value(MRB_SYM(TOTAL)), mrb_fixnum_value(obj_count.total));\n  mrb_hash_set(mrb, hash, mrb_symbol_value(MRB_SYM(FREE)), mrb_fixnum_value(obj_count.freed));\n\n  for (i = MRB_TT_FALSE; i < MRB_TT_MAXDEFINE; i++) {\n    mrb_value type;\n    switch (i) {\n#define COUNT_TYPE(t) case (MRB_T ## t): type = mrb_symbol_value(MRB_SYM(t)); break;\n      COUNT_TYPE(T_INTEGER);\n      COUNT_TYPE(T_FLOAT);\n      COUNT_TYPE(T_CPTR);\n      COUNT_TYPE(T_OBJECT);\n      COUNT_TYPE(T_CLASS);\n      COUNT_TYPE(T_MODULE);\n      COUNT_TYPE(T_ICLASS);\n      COUNT_TYPE(T_SCLASS);\n      COUNT_TYPE(T_PROC);\n      COUNT_TYPE(T_ARRAY);\n      COUNT_TYPE(T_HASH);\n      COUNT_TYPE(T_STRING);\n      COUNT_TYPE(T_RANGE);\n      COUNT_TYPE(T_EXCEPTION);\n      COUNT_TYPE(T_ENV);\n      COUNT_TYPE(T_DATA);\n      COUNT_TYPE(T_FIBER);\n      COUNT_TYPE(T_STRUCT);\n      COUNT_TYPE(T_ISTRUCT);\n      COUNT_TYPE(T_BREAK);\n      COUNT_TYPE(T_COMPLEX);\n      COUNT_TYPE(T_RATIONAL);\n      COUNT_TYPE(T_BIGINT);\n#undef COUNT_TYPE\n    default:\n      type = mrb_fixnum_value(i); break;\n    }\n    if (obj_count.counts[i])\n      mrb_hash_set(mrb, hash, type, mrb_fixnum_value(obj_count.counts[i]));\n  }\n\n  return hash;\n}",
        "file_path": "/src/mruby/mrbgems/mruby-objectspace/src/mruby_objectspace.c",
        "crashing_line": "  mrb_objspace_each_objects(mrb, os_count_object_type, &obj_count);",
        "crashing_line_number": 73
      },
      {
        "function_name": "mrb_vm_run",
        "function_body": "MRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  else {\n    struct REnv *e = CI_ENV(mrb->c->ci);\n    if (stack_keep == 0 || (e && irep->nlocals < MRB_ENV_LEN(e))) {\n      ci_env_set(mrb->c->ci, NULL);\n      mrb_env_unshare(mrb, e, FALSE);\n    }\n  }\n  stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "  result = mrb_vm_exec(mrb, proc, irep->iseq);",
        "crashing_line_number": 1312
      },
      {
        "function_name": "mrb_top_run",
        "function_body": "MRB_API mrb_value\nmrb_top_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  if (mrb->c->cibase && mrb->c->ci > mrb->c->cibase) {\n    cipush(mrb, 0, CINFO_SKIP, mrb->object_class, NULL, NULL, 0, 0);\n  }\n  return mrb_vm_run(mrb, proc, self, stack_keep);\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "  return mrb_vm_run(mrb, proc, self, stack_keep);",
        "crashing_line_number": 3138
      },
      {
        "function_name": "FuzzRB",
        "function_body": "int FuzzRB(const uint8_t *Data, size_t size) {\n  mrb_value v;\n  mrb_state *mrb = mrb_open();\n  if (!mrb)\n    return 0;\n\n  char *code = (char*)malloc(size+1);\n  if (!code)\n    return 0;\n  memcpy(code, Data, size);\n  code[size] = '\\0';\n\n  if (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n    // With libFuzzer binary run this to generate an RB file x.rb:\n    // PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n    std::ofstream of(dump_path);\n    of.write(code, size);\n  }\n  std::cout << \"\\n\\n############\\n\" << code << \"\\n############\\n\\n\";\n  v = mrb_load_string(mrb, code);\n  mrb_close(mrb);\n\n  free(code);\n  return 0;\n}",
        "file_path": "/src/mruby/oss-fuzz/mruby_proto_fuzzer.cpp",
        "crashing_line": "  v = mrb_load_string(mrb, code);",
        "crashing_line_number": 34
      },
      {
        "function_name": "TestOneProtoInput",
        "function_body": "",
        "file_path": "/src/mruby/oss-fuzz/mruby_proto_fuzzer.cpp",
        "crashing_line": "",
        "crashing_line_number": 44
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\ndxf_tables_read (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  char table[80];\n  Dxf_Pair *pair;\n\n  pair = dxf_read_pair (dat);\n  table[0] = '\\0'; // init\n  while (pair)     // read next 0 TABLE\n    {\n      if (pair->code == 0 && pair->value.s) // TABLE or ENDTAB\n        {\n          if (strEQc (pair->value.s, \"TABLE\"))\n            table[0] = '\\0'; // new table coming up\n          else if (strEQc (pair->value.s, \"BLOCK_RECORD\"))\n            {\n              strncpy (table, pair->value.s, 79);\n              table[79] = '\\0';\n            }\n          else if (strEQc (pair->value.s, \"ENDTAB\"))\n            {\n              table[0] = '\\0'; // close table\n            }\n          else if (strEQc (pair->value.s, \"ENDSEC\"))\n            {\n              dxf_free_pair (pair);\n              return 0;\n            }\n          else\n            {\n              LOG_ERROR (\"Unknown 0 %s (%s)\", pair->value.s, \"tables\");\n              dxf_free_pair (pair);\n              return 1;\n            }\n        }\n      else if (pair->code == 2 && pair->value.s && strlen (pair->value.s) < 80\n               && is_table_name (pair->value.s)) // new table NAME\n        {\n          long i = 0;\n          BITCODE_BL ctrl_id;\n          strncpy (table, pair->value.s, 79);\n          table[79] = '\\0';\n          pair = new_table_control (table, dat, dwg); // until 0 table\n          ctrl_id = dwg->num_objects - 1;             // dwg->object might move\n          while (pair && pair->code == 0 && pair->value.s\n                 && strEQ (pair->value.s, table))\n            {\n              Dwg_Object *obj;\n              Dwg_Object *ctrl = &dwg->object[ctrl_id];\n              char *dxfname = strdup (pair->value.s);\n              BITCODE_BL idx = dwg->num_objects;\n              BITCODE_H ref;\n              dxf_free_pair (pair);\n              // until 0 table or 0 ENDTAB\n              pair = new_object (table, dxfname, dat, dwg, ctrl_id,\n                                 (BITCODE_BL *)&i);\n              obj = &dwg->object[idx];\n              if (!pair)\n                {\n                  free (dxfname);\n                  if (idx != dwg->num_objects)\n                    obj->dxfname = NULL;\n                  return DWG_ERR_INVALIDDWG;\n                }\n              // A minimal DXF will have no handle values\n              if (!obj->handle.value)\n                {\n                  BITCODE_RLL next_handle = dwg_next_handle (dwg);\n                  dwg_add_handle (&obj->handle, 0, next_handle, NULL);\n                  // ref = dwg_add_handleref (dwg, 3, next_handle, ctrl);\n                  LOG_TRACE (\"%s.handle = (0.%d.\" FORMAT_RLLx \")\\n\", obj->name,\n                             obj->handle.size, obj->handle.value);\n                }\n              {\n                Dwg_Object_BLOCK_CONTROL *_ctrl\n                    = ctrl->tio.object->tio.BLOCK_CONTROL;\n                ref = dwg_add_handleref (dwg, 2, obj->handle.value, NULL);\n                PUSH_HV (_ctrl, num_entries, entries, ref);\n              }\n              // undo BLOCK_CONTROL.entries and LTYPE_CONTROL.entries\n              if (strEQc (table, \"BLOCK_RECORD\"))\n                {\n                  Dwg_Object_BLOCK_CONTROL *_ctrl\n                      = ctrl->tio.object->tio.BLOCK_CONTROL;\n                  if (_ctrl->model_space\n                      && obj->handle.value == _ctrl->model_space->absolute_ref)\n                    i--;\n                  else if (_ctrl->paper_space\n                           && obj->handle.value\n                                  == _ctrl->paper_space->absolute_ref)\n                    i--;\n                }\n              else if (strEQc (table, \"LTYPE\"))\n                {\n                  Dwg_Object_LTYPE *_obj = obj->tio.object->tio.LTYPE;\n                  Dwg_Object_LTYPE_CONTROL *_ctrl\n                      = ctrl->tio.object->tio.LTYPE_CONTROL;\n                  int j = _ctrl->num_entries;\n                  if (_ctrl->bylayer\n                      && obj->handle.value == _ctrl->bylayer->absolute_ref)\n                    i--;\n                  else if (_ctrl->byblock\n                           && obj->handle.value\n                                  == _ctrl->byblock->absolute_ref)\n                    i--;\n                  else\n                    {\n                      if (dwg->header.from_version > R_2004 && _obj->name\n                          && _obj->has_strings_area)\n                        {\n                          _obj->strings_area = (BITCODE_TF)xcalloc (512, 1);\n                          if (!_obj->strings_area)\n                            {\n                              free (dxfname);\n                              goto outofmem;\n                            }\n                        }\n                      if (dwg->header.from_version <= R_2004)\n                        {\n                          _obj->strings_area = (BITCODE_TF)xcalloc (256, 1);\n                          if (!_obj->strings_area)\n                            {\n                              free (dxfname);\n                              goto outofmem;\n                            }\n                        }\n                    }\n                }\n            }\n          // next table\n          // fixup entries vs num_entries (no NULL entries)\n          {\n            Dwg_Object *ctrl = &dwg->object[ctrl_id];\n            Dwg_Object_BLOCK_CONTROL *_ctrl\n                = ctrl->tio.object->tio.BLOCK_CONTROL;\n            int at_end = 1;\n            unsigned num_entries = 0;\n            if (!dwg_obj_is_control (ctrl))\n              {\n                LOG_ERROR (\"Missing CONTROL object\");\n                dxf_free_pair (pair);\n                return 1;\n              }\n            // A minimal DXF will have no handle values, assign them then\n            if (!ctrl->handle.value)\n              {\n                BITCODE_RLL next_handle = dwg_next_handle (dwg);\n                dwg_add_handle (&ctrl->handle, 0, next_handle, NULL);\n                // adds header_vars->CONTROL ref\n                (void)dwg_ctrl_table (dwg, table);\n                // ref = dwg_add_handleref (dwg, 3, next_handle, ctrl);\n                LOG_TRACE (\"%s.handle = (0.%d.\" FORMAT_RLLx \")\\n\", ctrl->name,\n                           ctrl->handle.size, ctrl->handle.value);\n              }\n            num_entries = _ctrl->num_entries;\n            if (_ctrl && ctrl->fixedtype == DWG_TYPE_BLOCK_CONTROL)\n              {\n                for (int j = num_entries - 1; j >= 0; j--)\n                  {\n                    BITCODE_H ref = _ctrl->entries ? _ctrl->entries[j] : NULL;\n                    if (!ref)\n                      {\n                        if (at_end)\n                          {\n                            num_entries--;\n                          }\n                        else\n                          {\n                            _ctrl->entries[j]\n                                = dwg_add_handleref (dwg, 2, 0, NULL);\n                            LOG_TRACE (\"%s.entries[%d] = (2.0.0)\\n\",\n                                       ctrl->name, j);\n                          }\n                      }\n                    else\n                      at_end = 0;\n                  }\n                // remove many empty entries at the end at once (avoids DDOS)\n                if (num_entries != _ctrl->num_entries)\n                  {\n                    _ctrl->entries = (BITCODE_H *)realloc (\n                        _ctrl->entries, num_entries * sizeof (BITCODE_H));\n                    if (num_entries && !_ctrl->entries)\n                      goto outofmem;\n                    _ctrl->num_entries = num_entries;\n                    LOG_TRACE (\"%s.num_entries => %d\\n\", ctrl->name,\n                               _ctrl->num_entries);\n                  }\n                // leave room for one active entry\n                if (_ctrl->num_entries == 1 && !_ctrl->entries[0])\n                  {\n                    _ctrl->entries[0] = dwg_add_handleref (dwg, 2, 0, NULL);\n                    LOG_TRACE (\"%s.entries[0] = (2.0.0)\\n\", ctrl->name);\n                  }\n              }\n          }\n        }\n      DXF_RETURN_ENDSEC (0) // next TABLE or ENDSEC\n      dxf_free_pair (pair);\n      pair = dxf_read_pair (dat);\n      DXF_CHECK_EOF;\n    } // while (pair)\n  dxf_free_pair (pair);\n  return 0;\n\noutofmem:\n  dxf_free_pair (pair);\n  return DWG_ERR_OUTOFMEM;\n}\n",
    "target": 1,
    "idx": 1066835,
    "stack_trace": [
      {
        "function_name": "dxf_tables_read",
        "function_body": "static int\ndxf_tables_read (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  char table[80];\n  Dxf_Pair *pair;\n\n  pair = dxf_read_pair (dat);\n  table[0] = '\\0'; // init\n  while (pair)     // read next 0 TABLE\n    {\n      if (pair->code == 0 && pair->value.s) // TABLE or ENDTAB\n        {\n          if (strEQc (pair->value.s, \"TABLE\"))\n            table[0] = '\\0'; // new table coming up\n          else if (strEQc (pair->value.s, \"BLOCK_RECORD\"))\n            {\n              strncpy (table, pair->value.s, 79);\n              table[79] = '\\0';\n            }\n          else if (strEQc (pair->value.s, \"ENDTAB\"))\n            {\n              table[0] = '\\0'; // close table\n            }\n          else if (strEQc (pair->value.s, \"ENDSEC\"))\n            {\n              dxf_free_pair (pair);\n              return 0;\n            }\n          else\n            {\n              LOG_ERROR (\"Unknown 0 %s (%s)\", pair->value.s, \"tables\");\n              dxf_free_pair (pair);\n              return 1;\n            }\n        }\n      else if (pair->code == 2 && pair->value.s && strlen (pair->value.s) < 80\n               && is_table_name (pair->value.s)) // new table NAME\n        {\n          long i = 0;\n          BITCODE_BL ctrl_id;\n          strncpy (table, pair->value.s, 79);\n          table[79] = '\\0';\n          pair = new_table_control (table, dat, dwg); // until 0 table\n          ctrl_id = dwg->num_objects - 1;             // dwg->object might move\n          while (pair && pair->code == 0 && pair->value.s\n                 && strEQ (pair->value.s, table))\n            {\n              Dwg_Object *obj;\n              Dwg_Object *ctrl;\n              char *dxfname = strdup (pair->value.s);\n              BITCODE_BL idx = dwg->num_objects;\n              BITCODE_H ref;\n              dxf_free_pair (pair);\n              // until 0 table or 0 ENDTAB\n              pair = new_object (table, dxfname, dat, dwg, ctrl_id,\n                                 (BITCODE_BL *)&i);\n              obj = &dwg->object[idx];\n              ctrl = &dwg->object[ctrl_id];\n              if (!pair)\n                {\n                  free (dxfname);\n                  if (idx != dwg->num_objects)\n                    obj->dxfname = NULL;\n                  return DWG_ERR_INVALIDDWG;\n                }\n              // A minimal DXF will have no handle values\n              if (!obj->handle.value)\n                {\n                  BITCODE_RLL next_handle = dwg_next_handle (dwg);\n                  dwg_add_handle (&obj->handle, 0, next_handle, NULL);\n                  // ref = dwg_add_handleref (dwg, 3, next_handle, ctrl);\n                  LOG_TRACE (\"%s.handle = (0.%d.\" FORMAT_RLLx \")\\n\", obj->name,\n                             obj->handle.size, obj->handle.value);\n                }\n              {\n                Dwg_Object_BLOCK_CONTROL *_ctrl\n                    = ctrl->tio.object->tio.BLOCK_CONTROL;\n                ref = dwg_add_handleref (dwg, 2, obj->handle.value, NULL);\n                PUSH_HV (_ctrl, num_entries, entries, ref);\n              }\n              // undo BLOCK_CONTROL.entries and LTYPE_CONTROL.entries\n              if (strEQc (table, \"BLOCK_RECORD\"))\n                {\n                  Dwg_Object_BLOCK_CONTROL *_ctrl\n                      = ctrl->tio.object->tio.BLOCK_CONTROL;\n                  if (_ctrl->model_space\n                      && obj->handle.value == _ctrl->model_space->absolute_ref)\n                    i--;\n                  else if (_ctrl->paper_space\n                           && obj->handle.value\n                                  == _ctrl->paper_space->absolute_ref)\n                    i--;\n                }\n              else if (strEQc (table, \"LTYPE\"))\n                {\n                  Dwg_Object_LTYPE *_obj = obj->tio.object->tio.LTYPE;\n                  Dwg_Object_LTYPE_CONTROL *_ctrl\n                      = ctrl->tio.object->tio.LTYPE_CONTROL;\n                  int j = _ctrl->num_entries;\n                  if (_ctrl->bylayer\n                      && obj->handle.value == _ctrl->bylayer->absolute_ref)\n                    i--;\n                  else if (_ctrl->byblock\n                           && obj->handle.value\n                                  == _ctrl->byblock->absolute_ref)\n                    i--;\n                  else\n                    {\n                      if (dwg->header.from_version > R_2004 && _obj->name\n                          && _obj->has_strings_area)\n                        {\n                          _obj->strings_area = (BITCODE_TF)xcalloc (512, 1);\n                          if (!_obj->strings_area)\n                            {\n                              free (dxfname);\n                              goto outofmem;\n                            }\n                        }\n                      if (dwg->header.from_version <= R_2004)\n                        {\n                          _obj->strings_area = (BITCODE_TF)xcalloc (256, 1);\n                          if (!_obj->strings_area)\n                            {\n                              free (dxfname);\n                              goto outofmem;\n                            }\n                        }\n                    }\n                }\n            }\n          // next table\n          // fixup entries vs num_entries (no NULL entries)\n          {\n            Dwg_Object *ctrl = &dwg->object[ctrl_id];\n            Dwg_Object_BLOCK_CONTROL *_ctrl\n                = ctrl->tio.object->tio.BLOCK_CONTROL;\n            int at_end = 1;\n            unsigned num_entries = 0;\n            if (!dwg_obj_is_control (ctrl))\n              {\n                LOG_ERROR (\"Missing CONTROL object\");\n                dxf_free_pair (pair);\n                return 1;\n              }\n            // A minimal DXF will have no handle values, assign them then\n            if (!ctrl->handle.value)\n              {\n                BITCODE_RLL next_handle = dwg_next_handle (dwg);\n                dwg_add_handle (&ctrl->handle, 0, next_handle, NULL);\n                // adds header_vars->CONTROL ref\n                (void)dwg_ctrl_table (dwg, table);\n                // ref = dwg_add_handleref (dwg, 3, next_handle, ctrl);\n                LOG_TRACE (\"%s.handle = (0.%d.\" FORMAT_RLLx \")\\n\", ctrl->name,\n                           ctrl->handle.size, ctrl->handle.value);\n              }\n            num_entries = _ctrl->num_entries;\n            if (_ctrl && ctrl->fixedtype == DWG_TYPE_BLOCK_CONTROL)\n              {\n                for (int j = num_entries - 1; j >= 0; j--)\n                  {\n                    BITCODE_H ref = _ctrl->entries ? _ctrl->entries[j] : NULL;\n                    if (!ref)\n                      {\n                        if (at_end)\n                          {\n                            num_entries--;\n                          }\n                        else\n                          {\n                            _ctrl->entries[j]\n                                = dwg_add_handleref (dwg, 2, 0, NULL);\n                            LOG_TRACE (\"%s.entries[%d] = (2.0.0)\\n\",\n                                       ctrl->name, j);\n                          }\n                      }\n                    else\n                      at_end = 0;\n                  }\n                // remove many empty entries at the end at once (avoids DDOS)\n                if (num_entries != _ctrl->num_entries)\n                  {\n                    _ctrl->entries = (BITCODE_H *)realloc (\n                        _ctrl->entries, num_entries * sizeof (BITCODE_H));\n                    if (num_entries && !_ctrl->entries)\n                      goto outofmem;\n                    _ctrl->num_entries = num_entries;\n                    LOG_TRACE (\"%s.num_entries => %d\\n\", ctrl->name,\n                               _ctrl->num_entries);\n                  }\n                // leave room for one active entry\n                if (_ctrl->num_entries == 1 && !_ctrl->entries[0])\n                  {\n                    _ctrl->entries[0] = dwg_add_handleref (dwg, 2, 0, NULL);\n                    LOG_TRACE (\"%s.entries[0] = (2.0.0)\\n\", ctrl->name);\n                  }\n              }\n          }\n        }\n      DXF_RETURN_ENDSEC (0) // next TABLE or ENDSEC\n      dxf_free_pair (pair);\n      pair = dxf_read_pair (dat);\n      DXF_CHECK_EOF;\n    } // while (pair)\n  dxf_free_pair (pair);\n  return 0;\n\noutofmem:\n  dxf_free_pair (pair);\n  return DWG_ERR_OUTOFMEM;\n}",
        "file_path": "/src/libredwg/src/in_dxf.c",
        "crashing_line": "                Dwg_Object_BLOCK_CONTROL *_ctrl",
        "crashing_line_number": 12143
      },
      {
        "function_name": "dwg_read_dxf",
        "function_body": "EXPORT int\ndwg_read_dxf (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  // const int minimal = dwg->opts & DWG_OPTS_MINIMAL;\n  Dxf_Pair *pair = NULL;\n  int error = 0;\n\n  loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n  if (!dat->chain && dat->fh)\n    {\n      error = dat_read_stream (dat, dat->fh);\n      if (error >= DWG_ERR_CRITICAL)\n        return error;\n      if (dat->size >= 22\n          && !memcmp (dat->chain, \"AutoCAD Binary DXF\",\n                      sizeof (\"AutoCAD Binary DXF\") - 1))\n        {\n          dat->opts |= DWG_OPTS_DXFB;\n          dat->byte = 22;\n        }\n    }\n  if (dat->size < 256)\n    {\n      LOG_ERROR (\"DXF input too small, %\" PRIuSIZE \" byte.\\n\", dat->size);\n      return DWG_ERR_IOERROR;\n    }\n  /* Fail early on DWG */\n  if (!memcmp (dat->chain, \"AC10\", 4) || !memcmp (dat->chain, \"AC1.\", 4)\n      || !memcmp (dat->chain, \"AC2.10\", 4) || !memcmp (dat->chain, \"MC0.0\", 4))\n    {\n      LOG_ERROR (\"This is a DWG, not a DXF\\n\");\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->opts |= DWG_OPTS_INDXF;\n  dwg->opts |= DWG_OPTS_INDXF;\n  // num_dxf_objs = 0;\n  // size_dxf_objs = 1000;\n  // dxf_objs = (Dxf_Objs *)malloc (1000 * sizeof (Dxf_Objs));\n  if (!dwg->object_map)\n    dwg->object_map = hash_new (dat->size / 1000);\n  // cannot rely on ref->obj during realloc's\n  dwg->dirty_refs = 1;\n\n  header_hdls = new_array_hdls (16);\n  eed_hdls = new_array_hdls (16);\n  obj_hdls = new_array_hdls (16);\n\n  // start with the BLOCK_HEADER at objid 0\n  if (!dwg->num_objects)\n    {\n      Dwg_Object *obj;\n      Dwg_Object_BLOCK_HEADER *_obj;\n      char *dxfname = strdup ((char *)\"BLOCK_HEADER\");\n      NEW_OBJECT (dwg, obj);\n      ADD_OBJECT1 (BLOCK_HEADER, BLOCK_HEADER);\n      // dwg->header.version probably here still unknown. <r2000: 0x17\n      // later fixed up when reading $ACADVER and the BLOCK_HEADER.name\n      _obj->name = dwg_add_u8_input (dwg, \"*Model_Space\");\n      _obj->is_xref_ref = 1;\n      obj->tio.object->is_xdic_missing = 1;\n      dwg_add_handle (&obj->handle, 0, 0x1F, obj);\n      obj->tio.object->ownerhandle = dwg_add_handleref (dwg, 4, 1, NULL);\n    }\n\n  while (dat->byte < dat->size)\n    {\n      pair = dxf_read_pair (dat);\n      DXF_BREAK_EOF;\n      pair = dxf_expect_code (dat, pair, 0);\n      DXF_BREAK_EOF;\n      if (pair->type == DWG_VT_STRING && strEQc (pair->value.s, \"SECTION\"))\n        {\n          dxf_free_pair (pair);\n          pair = dxf_read_pair (dat);\n          DXF_BREAK_EOF;\n          pair = dxf_expect_code (dat, pair, 2);\n          DXF_BREAK_EOF;\n          if (!pair->value.s)\n            {\n              LOG_ERROR (\"Expected SECTION string code 2, got code %d\",\n                         pair->code);\n              dxf_free_pair (pair);\n              pair = NULL;\n              break;\n            }\n          else if (strEQc (pair->value.s, \"HEADER\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_header_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n              dxf_fixup_header (dat, dwg);\n              // skip minimal DXF\n              /*\n              if (!dwg->header_vars.DIMPOST) // T in all versions\n                {\n                  LOG_ERROR (\"Unsupported minimal DXF\");\n                  return DWG_ERR_INVALIDDWG;\n                }\n              */\n            }\n          else if (strEQc (pair->value.s, \"CLASSES\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dat, dwg);\n              error = dxf_classes_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                return error;\n            }\n          else if (strEQc (pair->value.s, \"TABLES\"))\n            {\n              BITCODE_H hdl;\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_tables_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n\n              resolve_postponed_header_refs (dwg);\n              resolve_postponed_eed_refs (dwg);\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dat, dwg);\n\n              // should not happen\n              if (!dwg->header_vars.LTYPE_BYLAYER\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"ByLayer\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_BYLAYER\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              // should not happen\n              if (!dwg->header_vars.LTYPE_BYBLOCK\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"ByBlock\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_BYBLOCK\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              // but this is needed\n              if (!dwg->header_vars.LTYPE_CONTINUOUS\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"Continuous\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_CONTINUOUS\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n            }\n          else if (strEQc (pair->value.s, \"BLOCKS\"))\n            {\n              BITCODE_H hdl;\n              dxf_free_pair (pair);\n              pair = NULL;\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dat, dwg);\n              error = dxf_blocks_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n\n              // resolve_postponed_header_refs (dwg);\n              if (!dwg->header_vars.BLOCK_RECORD_PSPACE\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"*Paper_Space\", \"BLOCK\")))\n                dwg->header_vars.BLOCK_RECORD_PSPACE\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              if (!dwg->header_vars.BLOCK_RECORD_MSPACE\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"*Model_Space\", \"BLOCK\")))\n                dwg->header_vars.BLOCK_RECORD_MSPACE\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n            }\n          else if (strEQc (pair->value.s, \"ENTITIES\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              resolve_postponed_object_refs (dwg);\n              error = dxf_entities_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n            }\n          else if (strEQc (pair->value.s, \"OBJECTS\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_objects_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n              resolve_header_dicts (dwg);\n            }\n          else if (strEQc (pair->value.s, \"THUMBNAILIMAGE\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_thumbnail_read (dat, dwg);\n            }\n          else if (strEQc (pair->value.s, \"ACDSDATA\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_acds_read (dat, dwg);\n            }\n          else // if (strEQc (pair->value.s, \"\"))\n            {\n              LOG_WARN (\"SECTION %s ignored for now\", pair->value.s);\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_unknownsection_read (dat, dwg);\n            }\n        }\n      else\n        {\n          LOG_ERROR (\"Expected string SECTION\");\n          dxf_free_pair (pair);\n        }\n    }\n  if (pair != NULL && pair->code == 0 && pair->value.s != NULL\n      && strEQc (pair->value.s, \"EOF\"))\n    ;\n  else if (dat->byte >= dat->size || (pair == NULL))\n    error |= DWG_ERR_IOERROR;\n  dxf_free_pair (pair);\n  resolve_postponed_header_refs (dwg);\n  resolve_postponed_object_refs (dwg);\n  LOG_HANDLE (\"Resolving pointers from ObjectRef vector:\\n\");\n  dwg_resolve_objectrefs_silent (dwg);\n  free_array_hdls (header_hdls);\n  free_array_hdls (eed_hdls);\n  free_array_hdls (obj_hdls);\n  if (dwg->header.version <= R_2000 && dwg->header.from_version > R_2000)\n    dwg_fixup_BLOCKS_entities (dwg);\n  LOG_TRACE (\"import from DXF\\n\");\n  if (error > DWG_ERR_CRITICAL)\n    return error;\n  else\n    return dwg->num_objects ? 1 : 0;\n\nerror:\n  dwg->dirty_refs = 0;\n  free_array_hdls (header_hdls);\n  free_array_hdls (eed_hdls);\n  free_array_hdls (obj_hdls);\n  return error;\n}",
        "file_path": "/src/libredwg/src/in_dxf.c",
        "crashing_line": "              pair = NULL;",
        "crashing_line_number": 13102
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "    }\n\n  return(status);\n}\n\nstatic MagickBooleanType CheckPSDChannels(const PSDInfo *psd_info,\n  LayerInfo *layer_info)\n{\n  int\n    channel_type;\n\n  register ssize_t\n    i;\n\n  if (layer_info->channels < psd_info->min_channels)\n    return(MagickFalse);\n  channel_type=RedChannel;\n  if (psd_info->min_channels >= 3)\n    channel_type|=(GreenChannel | BlueChannel);\n  if (psd_info->min_channels >= 4)\n    channel_type|=BlackChannel;\n  for (i=0; i < (ssize_t) layer_info->channels; i++)\n  {\n    short\n      type;\n\n    type=layer_info->channel_info[i].type;\n    if (type == -1)\n      {\n        channel_type|=AlphaChannel;\n        continue;\n      }\n    if (type < -1)\n      continue;\n    if (type == 0)\n      channel_type&=~RedChannel;\n    else if (type == 1)\n      channel_type&=~GreenChannel;\n    else if (type == 2)\n      channel_type&=~BlueChannel;\n    else if (type == 3)\n      channel_type&=~BlackChannel;\n  }\n  if (channel_type == 0)\n    return(MagickTrue);\n",
    "target": 1,
    "idx": 1019744,
    "stack_trace": [
      {
        "function_name": "SetPSDPixel",
        "function_body": "    *q = *p ^ *q,\n    *p = *p ^ *q;\n  }\n}\n\nstatic inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      PixelInfo\n        *color;\n\n      Quantum\n        index;\n\n      index=pixel;\n      if (packet_size == 1)\n        index=(Quantum) ScaleQuantumToChar(index);\n      index=(Quantum) ConstrainColormapIndex(image,(ssize_t) index,\n        exception);\n\n      if (type == 0)\n        SetPixelIndex(image,index,q);\n      if ((type == 0) && (channels > 1))\n        return;\n      color=image->colormap+(ssize_t) GetPixelIndex(image,q);\n      if (type != 0)\n        color->alpha=(MagickRealType) pixel;\n      SetPixelViaPixelInfo(image,color,q);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(image,pixel,q);\n      break;\n    }\n    case -3:\n    case 1:\n    {\n      SetPixelGreen(image,pixel,q);\n      break;\n    }\n    case -4:\n    case 2:\n    {\n      SetPixelBlue(image,pixel,q);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelBlack(image,pixel,q);\n      else\n        if (image->alpha_trait != UndefinedPixelTrait)\n          SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->alpha_trait != UndefinedPixelTrait)",
        "file_path": "/src/imagemagick/coders/psd.c",
        "crashing_line": "        SetPixelIndex(image,index,q);",
        "crashing_line_number": 949
      },
      {
        "function_name": "ReadPSDChannelPixels",
        "function_body": "      break;\n    }\n  }\n}\n\nstatic MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  register const unsigned char\n    *p;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType) (QuantumRange*nibble));\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;",
        "file_path": "/src/imagemagick/coders/psd.c",
        "crashing_line": "        number_bits=(ssize_t) image->columns-x;",
        "crashing_line_number": 1060
      },
      {
        "function_name": "ReadPSDChannelRaw",
        "function_body": "      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}\n\nstatic MagickBooleanType ReadPSDChannelRaw(Image *image,const size_t channels,\n  const ssize_t type,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RAW\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  (void) memset(pixels,0,row_size*sizeof(*pixels));\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,row_size,pixels);\n    if (count != (ssize_t) row_size)\n      {\n        status=MagickFalse;\n        break;\n      }\n\n    status=ReadPSDChannelPixels(image,channels,y,type,pixels,exception);\n    if (status == MagickFalse)\n      break;",
        "file_path": "/src/imagemagick/coders/psd.c",
        "crashing_line": "      {",
        "crashing_line_number": 1112
      },
      {
        "function_name": "ReadPSDChannel",
        "function_body": "  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n#endif\n\nstatic MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if ((layer_info->channel_info[channel].type < -1) &&\n      (layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0))\n    {\n      const char\n        *option;\n\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n        {\n          (void) SeekBlob(image,(MagickOffsetType)\n            layer_info->channel_info[channel].size-2,SEEK_CUR);\n          return(MagickTrue);\n        }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          (void) ResetImagePixels(mask,exception);\n          (void) SetImageType(mask,GrayscaleType,exception);\n          channel_image=mask;\n        }\n    }\n\n  offset=TellBlob(image);\n  status=MagickFalse;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        (ssize_t) layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          (ssize_t) layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        (ssize_t) layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  (void) SeekBlob(image,offset+layer_info->channel_info[channel].size-2,\n    SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        (void) DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  if (mask != (Image *) NULL)\n    {\n      if (layer_info->mask.image != (Image *) NULL)",
        "file_path": "/src/imagemagick/coders/psd.c",
        "crashing_line": "  offset=TellBlob(image);",
        "crashing_line_number": 1402
      },
      {
        "function_name": "ReadPSDLayer",
        "function_body": "      layer_info->mask.image=mask;\n    }\n  return(status);\n}\n\nstatic MagickBooleanType ReadPSDLayer(Image *image,const ImageInfo *image_info,\n  const PSDInfo *psd_info,LayerInfo* layer_info,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    j;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    setting up new layer image\");\n  if (psd_info->mode != IndexedMode)\n    (void) SetImageBackgroundColor(layer_info->image,exception);\n  layer_info->image->compose=PSDBlendModeToCompositeOperator(\n    layer_info->blendkey);\n  if (layer_info->visible == MagickFalse)\n    layer_info->image->compose=NoCompositeOp;\n  /*\n    Set up some hidden attributes for folks that need them.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.x);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.x\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.y);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.y\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",(double)\n    layer_info->opacity);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.opacity\",message);\n  (void) SetImageProperty(layer_info->image,\"label\",(char *) layer_info->name,\n    exception);\n\n  status=MagickTrue;\n  for (j=0; j < (ssize_t) layer_info->channels; j++)\n  {\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    reading data for channel %.20g\",(double) j);\n\n    compression=(PSDCompressionType) ReadBlobShort(layer_info->image);\n\n    /* TODO: Remove this when we figure out how to support this */\n    if ((compression == ZipWithPrediction) && (image->depth == 32))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          TypeError,\"CompressionNotSupported\",\"ZipWithPrediction(32 bit)\");\n        return(MagickFalse);\n      }\n\n    layer_info->image->compression=ConvertPSDCompression(compression);\n    if (layer_info->channel_info[j].type == -1)\n      layer_info->image->alpha_trait=BlendPixelTrait;\n\n    status=ReadPSDChannel(layer_info->image,image_info,psd_info,layer_info,\n      (size_t) j,compression,exception);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    status=ApplyPSDLayerOpacity(layer_info->image,layer_info->opacity,\n      MagickFalse,exception);\n\n  if ((status != MagickFalse) &&\n      (layer_info->image->colorspace == CMYKColorspace))\n    status=NegateCMYK(layer_info->image,exception);\n\n  if ((status != MagickFalse) && (layer_info->mask.image != (Image *) NULL))\n    {\n      const char\n        *option;\n\n      layer_info->mask.image->page.x=layer_info->mask.page.x;\n      layer_info->mask.image->page.y=layer_info->mask.page.y;\n      /* Do not composite the mask when it is disabled */\n      if ((layer_info->mask.flags & 0x02) == 0x02)\n        layer_info->mask.image->compose=NoCompositeOp;\n      else\n        status=ApplyPSDOpacityMask(layer_info->image,layer_info->mask.image,\n          layer_info->mask.background == 0 ? 0 : QuantumRange,MagickFalse,\n          exception);\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if (IsStringTrue(option) != MagickFalse)\n        PreservePSDOpacityMask(image,layer_info,exception);",
        "file_path": "/src/imagemagick/coders/psd.c",
        "crashing_line": "",
        "crashing_line_number": 1515
      },
      {
        "function_name": "ReadPSDLayersInternal",
        "function_body": "  if (index > image_info->scene+image_info->number_scenes-1)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    index,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      if (count == 4)\n        ReversePSDString(image,type,(size_t) count);\n      if ((count != 4) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          if (count == 4)\n            ReversePSDString(image,type,4);\n          if ((count == 4) && ((LocaleNCompare(type,\"Lr16\",4) == 0) ||\n              (LocaleNCompare(type,\"Lr32\",4) == 0)))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  if (size == 0)\n    return(MagickTrue);\n\n  layer_info=(LayerInfo *) NULL;\n  number_layers=(ssize_t) ReadBlobSignedShort(image);\n\n  if (number_layers < 0)\n    {\n      /*\n        The first alpha channel in the merged result contains the\n        transparency data for the merged result.\n      */\n      number_layers=MagickAbsoluteValue(number_layers);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  negative layer count corrected for\");\n      image->alpha_trait=BlendPixelTrait;\n    }\n\n  /*\n    We only need to know if the image has an alpha channel\n  */\n  if (skip_layers != MagickFalse)\n    return(MagickTrue);\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  image contains %.20g layers\",(double) number_layers);\n\n  if (number_layers == 0)\n    ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n      image->filename);\n\n  layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n    sizeof(*layer_info));\n  if (layer_info == (LayerInfo *) NULL)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  allocation of LayerInfo failed\");\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) memset(layer_info,0,(size_t) number_layers*sizeof(*layer_info));\n\n  for (i=0; i < number_layers; i++)\n  {\n    ssize_t\n      top,\n      left,\n      bottom,\n      right;\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  reading layer #%.20g\",(double) i+1);\n    top=(ssize_t) ReadBlobSignedLong(image);\n    left=(ssize_t) ReadBlobSignedLong(image);\n    bottom=(ssize_t) ReadBlobSignedLong(image);\n    right=(ssize_t) ReadBlobSignedLong(image);\n    if ((right < left) || (bottom < top))\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    layer_info[i].page.y=top;\n    layer_info[i].page.x=left;\n    layer_info[i].page.width=(size_t) (right-left);\n    layer_info[i].page.height=(size_t) (bottom-top);\n    layer_info[i].channels=ReadBlobShort(image);\n    if (layer_info[i].channels > MaxPSDChannels)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n          image->filename);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n        (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n        (double) layer_info[i].page.height,(double)\n        layer_info[i].page.width,(double) layer_info[i].channels);\n    for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n    {\n      layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n      if ((layer_info[i].channel_info[j].type < -4) ||\n          (layer_info[i].channel_info[j].type > 4))\n        {\n          layer_info=DestroyLayerInfo(layer_info,number_layers);\n          ThrowBinaryException(CorruptImageError,\"NoSuchImageChannel\",\n            image->filename);\n        }\n      layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n        image);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n          (double) layer_info[i].channel_info[j].type,\n          (double) layer_info[i].channel_info[j].size);\n    }\n    if (CheckPSDChannels(psd_info,&layer_info[i]) == MagickFalse)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    count=ReadBlob(image,4,(unsigned char *) type);\n    if (count == 4)\n      ReversePSDString(image,type,4);\n    if ((count != 4) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  layer type was %.4s instead of 8BIM\", type);\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n    if (count != 4)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    ReversePSDString(image,layer_info[i].blendkey,4);\n    layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n      ReadBlobByte(image));\n    layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n    layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n    layer_info[i].visible=!(layer_info[i].flags & 0x02);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n        layer_info[i].blendkey,(double) layer_info[i].opacity,\n        layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n        layer_info[i].visible ? \"true\" : \"false\");\n    (void) ReadBlobByte(image);  /* filler */\n\n    size=ReadBlobLong(image);\n    if (size != 0)\n      {\n        MagickSizeType\n          combined_length,\n          length;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    layer contains additional info\");\n        length=ReadBlobLong(image);\n        combined_length=length+4;\n        if (length != 0)\n          {\n            /*\n              Layer mask info.\n            */\n            layer_info[i].mask.page.y=(ssize_t) ReadBlobSignedLong(image);\n            layer_info[i].mask.page.x=(ssize_t) ReadBlobSignedLong(image);\n            layer_info[i].mask.page.height=(size_t)\n              (ReadBlobSignedLong(image)-layer_info[i].mask.page.y);\n            layer_info[i].mask.page.width=(size_t) (\n              ReadBlobSignedLong(image)-layer_info[i].mask.page.x);\n            layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n              image);\n            layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n            if (!(layer_info[i].mask.flags & 0x01))\n              {\n                layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                  layer_info[i].page.y;\n                layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                  layer_info[i].page.x;\n              }\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                (double) layer_info[i].mask.page.x,(double)\n                layer_info[i].mask.page.y,(double)\n                layer_info[i].mask.page.width,(double)\n                layer_info[i].mask.page.height,(double) ((MagickOffsetType)\n                length)-18);\n            /*\n              Skip over the rest of the layer mask information.\n            */\n            if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        length=ReadBlobLong(image);\n        combined_length+=length+4;\n        if (length != 0)\n          {\n            /*\n              Layer blending ranges info.\n            */\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer blending ranges: length=%.20g\",(double)\n                ((MagickOffsetType) length));\n            if (DiscardBlobBytes(image,length) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        /*\n          Layer name.\n        */\n        length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n        combined_length+=length+1;\n        if (length > 0)\n          (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n        layer_info[i].name[length]='\\0';\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      layer name: %s\",layer_info[i].name);\n        if ((length % 4) != 0)\n          {\n            length=4-(length % 4);\n            combined_length+=length;\n            /* Skip over the padding of the layer name */\n            if (DiscardBlobBytes(image,length) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        length=(MagickSizeType) size-combined_length;\n        if (length > 0)\n          {\n            unsigned char\n              *info;\n\n            if (length > GetBlobSize(image))\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image->filename);\n              }\n            layer_info[i].info=AcquireStringInfo((const size_t) length);\n            info=GetStringInfoDatum(layer_info[i].info);\n            (void) ReadBlob(image,(const size_t) length,info);\n          }\n      }\n  }\n\n  for (i=0; i < number_layers; i++)\n  {\n    if ((layer_info[i].page.width == 0) || (layer_info[i].page.height == 0))\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      layer data is empty\");\n        if (layer_info[i].info != (StringInfo *) NULL)\n          layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n        continue;\n      }\n\n    /*\n      Allocate layered image.\n    */\n    layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n      layer_info[i].page.height,MagickFalse,exception);\n    if (layer_info[i].image == (Image *) NULL)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  allocation of image for layer %.20g failed\",(double) i);\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      }\n    if (layer_info[i].info != (StringInfo *) NULL)\n      {\n        (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n          layer_info[i].info,exception);\n        layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n      }\n  }\n  if (image_info->ping != MagickFalse)\n    {\n      AttachPSDLayers(image,layer_info,number_layers);\n      return(MagickTrue);\n    }\n  status=MagickTrue;\n  index=0;\n  for (i=0; i < number_layers; i++)\n  {\n    if ((layer_info[i].image == (Image *) NULL) ||\n        (PSDSkipImage(psd_info, image_info,++index) != MagickFalse))\n      {\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          if (DiscardBlobBytes(image,(MagickSizeType)\n              layer_info[i].channel_info[j].size) == MagickFalse)\n            {\n              layer_info=DestroyLayerInfo(layer_info,number_layers);\n              ThrowBinaryException(CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n            }\n        }\n        continue;\n      }\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  reading data for layer %.20g\",(double) i);\n\n    status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n      exception);\n    if (status == MagickFalse)\n      break;\n\n    status=SetImageProgress(image,LoadImagesTag,(MagickOffsetType) i,\n      (MagickSizeType) number_layers);\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    AttachPSDLayers(image,layer_info,number_layers);",
        "file_path": "/src/imagemagick/coders/psd.c",
        "crashing_line": "        continue;",
        "crashing_line_number": 2012
      },
      {
        "function_name": "ReadPSDImage",
        "function_body": "",
        "file_path": "/src/imagemagick/coders/psd.c",
        "crashing_line": "",
        "crashing_line_number": 2351
      },
      {
        "function_name": "ReadImage",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/constitute.c",
        "crashing_line": "",
        "crashing_line_number": 553
      },
      {
        "function_name": "BlobToImage",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/blob.c",
        "crashing_line": "",
        "crashing_line_number": 475
      },
      {
        "function_name": "read",
        "function_body": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}",
        "file_path": "/src/imagemagick/Magick++/lib/Image.cpp",
        "crashing_line": "",
        "crashing_line_number": 4028
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "int yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* child;\n  RE_NODE* concat;\n\n  int result;\n\n  *result_re_ast = re_ast;\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  if (re_ast->root_node->type != RE_NODE_CONCAT)\n    return ERROR_SUCCESS;\n\n  child = re_ast->root_node->children_head;\n\n  while (child != NULL)\n  {\n    if (!child->greedy &&\n         child->type == RE_NODE_RANGE_ANY &&\n        (child->start > YR_STRING_CHAINING_THRESHOLD ||\n         child->end > YR_STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      concat = yr_re_node_create(RE_NODE_CONCAT);\n\n      if (concat == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      concat->children_head = re_ast->root_node->children_head;\n      concat->children_tail = child->prev_sibling;\n\n      re_ast->root_node->children_head = child->next_sibling;\n\n      if (child->prev_sibling != NULL)\n        child->prev_sibling->next_sibling = NULL;\n\n      if (child->next_sibling != NULL)\n        child->next_sibling->prev_sibling = NULL;\n\n      *min_gap = child->start;\n      *max_gap = child->end;\n\n      (*result_re_ast)->root_node = re_ast->root_node;\n      (*result_re_ast)->flags = re_ast->flags;\n      (*remainder_re_ast)->root_node = concat;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      yr_re_node_destroy(child);\n\n      return ERROR_SUCCESS;\n    }\n\n    child = child->next_sibling;\n  }\n\n  return ERROR_SUCCESS;\n}\nvoid test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\"a|b\", \"a\", \"a\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab{1,2}c\", \"abbbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_false_regexp(\"ab{1}c\", \"ac\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_false_regexp(\"ab{3}c\", \"abbbbc\");  // Issue #817\n  assert_false_regexp(\"ab{4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,4}\", \"abbbbc\", \"abbbb\");\n  assert_true_regexp(\"ab{3,4}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\"ab{3,5}\", \"abbbbb\", \"abbbbb\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbc\");\n  assert_false_regexp(\"ab{3,5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  // Test case for issue #682\n  assert_true_regexp(\"(a|\\\\b)[a]{1,}\", \"aaaa\", \"aaaa\");\n\n  // Test for integer overflow in repeat interval\n  assert_regexp_syntax_error(\"a{2977952116}\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^D]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^D]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^F]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n       \"rule test { strings: $a = /abc[^F]/ condition: $a }\",\n       \"abcd\");\n}\n",
    "target": 1,
    "idx": 1011752,
    "stack_trace": [
      {
        "function_name": "yr_re_ast_split_at_chaining_point",
        "function_body": "int yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* child;\n  RE_NODE* concat;\n\n  int result;\n\n  *result_re_ast = re_ast;\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  if (re_ast->root_node->type != RE_NODE_CONCAT)\n    return ERROR_SUCCESS;\n\n  child = re_ast->root_node->children_head;\n\n  while (child != NULL)\n  {\n    if (!child->greedy &&\n         child->type == RE_NODE_RANGE_ANY &&\n         child->prev_sibling != NULL &&\n         child->next_sibling != NULL &&\n        (child->start > YR_STRING_CHAINING_THRESHOLD ||\n         child->end > YR_STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      concat = yr_re_node_create(RE_NODE_CONCAT);\n\n      if (concat == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      concat->children_head = re_ast->root_node->children_head;\n      concat->children_tail = child->prev_sibling;\n\n      re_ast->root_node->children_head = child->next_sibling;\n\n      child->prev_sibling->next_sibling = NULL;\n      child->next_sibling->prev_sibling = NULL;\n\n      *min_gap = child->start;\n      *max_gap = child->end;\n\n      (*result_re_ast)->root_node = re_ast->root_node;\n      (*result_re_ast)->flags = re_ast->flags;\n      (*remainder_re_ast)->root_node = concat;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      yr_re_node_destroy(child);\n\n      return ERROR_SUCCESS;\n    }\n\n    child = child->next_sibling;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "file_path": "/src/yara/libyara/re.c",
        "crashing_line": "    if (!child->greedy &&",
        "crashing_line_number": 480
      },
      {
        "function_name": "yr_parser_reduce_string_declaration",
        "function_body": "int yr_parser_reduce_string_declaration(\n    yyscan_t yyscanner,\n    int32_t string_flags,\n    const char* identifier,\n    SIZED_STRING* str,\n    YR_STRING** string)\n{\n  int min_atom_quality = YR_MIN_ATOM_QUALITY;\n  int min_atom_quality_aux = YR_MIN_ATOM_QUALITY;\n\n  int32_t min_gap;\n  int32_t max_gap;\n\n  char message[512];\n\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n  YR_STRING* aux_string;\n  YR_STRING* prev_string;\n\n  RE_AST* re_ast = NULL;\n  RE_AST* remainder_re_ast = NULL;\n\n  RE_ERROR re_error;\n\n  int result = ERROR_SUCCESS;\n\n  // Determine if a string with the same identifier was already defined\n  // by searching for the identifier in string_table.\n\n  *string = (YR_STRING*) yr_hash_table_lookup(\n      compiler->strings_table,\n      identifier,\n      NULL);\n\n  if (*string != NULL)\n  {\n    result = ERROR_DUPLICATED_STRING_IDENTIFIER;\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    goto _exit;\n  }\n\n  // Empty strings are not allowed\n\n  if (str->length == 0)\n  {\n    result = ERROR_EMPTY_STRING;\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    goto _exit;\n  }\n\n  if (str->flags & SIZED_STRING_FLAGS_NO_CASE)\n    string_flags |= STRING_GFLAGS_NO_CASE;\n\n  if (str->flags & SIZED_STRING_FLAGS_DOT_ALL)\n    string_flags |= STRING_GFLAGS_DOT_ALL;\n\n  if (strcmp(identifier,\"$\") == 0)\n    string_flags |= STRING_GFLAGS_ANONYMOUS;\n\n  if (!(string_flags & STRING_GFLAGS_WIDE) &&\n      !(string_flags & STRING_GFLAGS_XOR))\n    string_flags |= STRING_GFLAGS_ASCII;\n\n  // Hex strings are always handled as DOT_ALL regexps.\n\n  if (string_flags & STRING_GFLAGS_HEXADECIMAL)\n    string_flags |= STRING_GFLAGS_DOT_ALL;\n\n  // The STRING_GFLAGS_SINGLE_MATCH flag indicates that finding\n  // a single match for the string is enough. This is true in\n  // most cases, except when the string count (#) and string offset (@)\n  // operators are used. All strings are marked STRING_FLAGS_SINGLE_MATCH\n  // initially, and unmarked later if required.\n\n  string_flags |= STRING_GFLAGS_SINGLE_MATCH;\n\n  // The STRING_GFLAGS_FIXED_OFFSET indicates that the string doesn't\n  // need to be searched all over the file because the user is using the\n  // \"at\" operator. The string must be searched at a fixed offset in the\n  // file. All strings are marked STRING_GFLAGS_FIXED_OFFSET initially,\n  // and unmarked later if required.\n\n  string_flags |= STRING_GFLAGS_FIXED_OFFSET;\n\n  if (string_flags & STRING_GFLAGS_HEXADECIMAL ||\n      string_flags & STRING_GFLAGS_REGEXP)\n  {\n    if (string_flags & STRING_GFLAGS_HEXADECIMAL)\n      result = yr_re_parse_hex(str->c_string, &re_ast, &re_error);\n    else\n      result = yr_re_parse(str->c_string, &re_ast, &re_error);\n\n    if (result != ERROR_SUCCESS)\n    {\n      snprintf(\n          message,\n          sizeof(message),\n          \"invalid %s \\\"%s\\\": %s\",\n          (string_flags & STRING_GFLAGS_HEXADECIMAL) ?\n              \"hex string\" : \"regular expression\",\n          identifier,\n          re_error.message);\n\n      yr_compiler_set_error_extra_info(\n          compiler, message);\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_FAST_REGEXP)\n      string_flags |= STRING_GFLAGS_FAST_REGEXP;\n\n    // Regular expressions in the strings section can't mix greedy and ungreedy\n    // quantifiers like .* and .*?. That's because these regular expressions can\n    // be matched forwards and/or backwards depending on the atom found, and we\n    // need the regexp to be all-greedy or all-ungreedy to be able to properly\n    // calculate the length of the match.\n\n    if ((re_ast->flags & RE_FLAGS_GREEDY) &&\n        (re_ast->flags & RE_FLAGS_UNGREEDY))\n    {\n      result = ERROR_INVALID_REGULAR_EXPRESSION;\n\n      yr_compiler_set_error_extra_info(compiler,\n          \"greedy and ungreedy quantifiers can't be mixed in a regular \"\n          \"expression\");\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_GREEDY)\n      string_flags |= STRING_GFLAGS_GREEDY_REGEXP;\n\n    if (yr_re_ast_contains_dot_star(re_ast))\n    {\n      yywarning(\n          yyscanner,\n          \"%s contains .* or .+, consider using .{N} or .{1,N} with a reasonable value for N\",\n          identifier);\n    }\n\n    if (compiler->re_ast_callback != NULL)\n    {\n      compiler->re_ast_callback(\n          compiler->current_rule,\n          identifier,\n          re_ast,\n          compiler->re_ast_clbk_user_data);\n    }\n\n    result = yr_re_ast_split_at_chaining_point(\n        re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    result = _yr_parser_write_string(\n        identifier,\n        string_flags,\n        compiler,\n        NULL,\n        re_ast,\n        string,\n        &min_atom_quality,\n        &compiler->current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    if (remainder_re_ast != NULL)\n    {\n      (*string)->g_flags |= STRING_GFLAGS_CHAIN_TAIL | STRING_GFLAGS_CHAIN_PART;\n      (*string)->chain_gap_min = min_gap;\n      (*string)->chain_gap_max = max_gap;\n    }\n\n    // Use \"aux_string\" from now on, we want to keep the value of \"string\"\n    // because it will returned.\n\n    aux_string = *string;\n\n    while (remainder_re_ast != NULL)\n    {\n      // Destroy regexp pointed by 're_ast' before yr_re_split_at_chaining_point\n      // overwrites 're_ast' with another value.\n\n      yr_re_ast_destroy(re_ast);\n\n      result = yr_re_ast_split_at_chaining_point(\n          remainder_re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      prev_string = aux_string;\n\n      result = _yr_parser_write_string(\n          identifier,\n          string_flags,\n          compiler,\n          NULL,\n          re_ast,\n          &aux_string,\n          &min_atom_quality_aux,\n          &compiler->current_rule->num_atoms);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      if (min_atom_quality_aux < min_atom_quality)\n        min_atom_quality = min_atom_quality_aux;\n\n      aux_string->g_flags |= STRING_GFLAGS_CHAIN_PART;\n      aux_string->chain_gap_min = min_gap;\n      aux_string->chain_gap_max = max_gap;\n\n      prev_string->chained_to = aux_string;\n\n      // prev_string is now chained to aux_string, an string chained\n      // to another one can't have a fixed offset, only the head of the\n      // string chain can have a fixed offset.\n\n      prev_string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n    }\n  }\n  else\n  {\n    result = _yr_parser_write_string(\n        identifier,\n        string_flags,\n        compiler,\n        str,\n        NULL,\n        string,\n        &min_atom_quality,\n        &compiler->current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (!STRING_IS_ANONYMOUS(*string))\n  {\n    result = yr_hash_table_add(\n      compiler->strings_table,\n      identifier,\n      NULL,\n      *string);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (min_atom_quality < compiler->atoms_config.quality_warning_threshold)\n  {\n    yywarning(\n        yyscanner,\n        \"%s in rule %s is slowing down scanning\",\n        (*string)->identifier,\n        compiler->current_rule->identifier);\n  }\n\n_exit:\n\n  if (re_ast != NULL)\n    yr_re_ast_destroy(re_ast);\n\n  if (remainder_re_ast != NULL)\n    yr_re_ast_destroy(remainder_re_ast);\n\n  return result;\n}",
        "file_path": "/src/yara/libyara/parser.c",
        "crashing_line": "      result = yr_re_ast_split_at_chaining_point(",
        "crashing_line_number": 642
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "M3Result  Compile_ExtendedOpcode  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;\n\n_try {\n    u8 opcode;\n_   (Read_u8 (& opcode, & o->wasm, o->wasmEnd));             m3log (compile, d_indent \" (FC: %\" PRIi32 \")\", get_indention_string (o), opcode);\n\n    i_opcode = (i_opcode << 8) | opcode;\n\n    //printf(\"Extended opcode: 0x%x\\n\", i_opcode);\n\n    M3Compiler compiler = GetOpInfo (i_opcode)->compiler;\n    _throwif (m3Err_noCompiler, not compiler);\n\n_   ((* compiler) (o, i_opcode));\n\n    o->previousOpcode = i_opcode;\n\n\t} _catch: return result;\n}\nM3Result  m3_RunStart  (IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    if (io_module and io_module->startFunction >= 0)\n    {\n        IM3Function function = & io_module->functions [io_module->startFunction];\n\n        if (not function->compiled)\n        {\n_           (CompileFunction (function));\n        }\n\n        IM3FuncType ftype = function->funcType;\n        if (ftype->numArgs != 0 || ftype->numRets != 0)\n            _throw (m3Err_argumentCountMismatch);\n\n        IM3Module module = function->module;\n        IM3Runtime runtime = module->runtime;\n\n_       ((M3Result) Call (function->compiled, (m3stack_t) runtime->stack, runtime->memory.mallocated, d_m3OpDefaultArgs));\n\n        io_module->startFunction = -1;\n    }\n\n    _catch: return result;\n}\n",
    "target": 1,
    "idx": 1033765,
    "stack_trace": [
      {
        "function_name": "m3_FreeModule",
        "function_body": "void  m3_FreeModule  (IM3Module i_module)\n{\n    if (i_module)\n    {\n        m3log (module, \"freeing module: %s (funcs: %d; segments: %d)\",\n               i_module->name, i_module->numFunctions, i_module->numDataSegments);\n\n        Module_FreeFunctions (i_module);\n\n        m3_Free (i_module->functions);\n        //m3_Free (i_module->imports);\n        m3_Free (i_module->funcTypes);\n        m3_Free (i_module->dataSegments);\n        m3_Free (i_module->table0);\n\n        for (u32 i = 0; i < i_module->numGlobals; ++i)\n        {\n            m3_Free (i_module->globals[i].name);\n            FreeImportInfo(&(i_module->globals[i].import));\n        }\n        m3_Free (i_module->globals);\n\n        m3_Free (i_module);\n    }\n}",
        "file_path": "/src/wasm3/source/m3_module.c",
        "crashing_line": "        m3_Free (i_module->functions);",
        "crashing_line_number": 31
      },
      {
        "function_name": "_FreeModule",
        "function_body": "",
        "file_path": "/src/wasm3/source/m3_env.c",
        "crashing_line": "",
        "crashing_line_number": 219
      },
      {
        "function_name": "Compile_ExtendedOpcode",
        "function_body": "M3Result  Compile_ExtendedOpcode  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;\n\n_try {\n    u8 opcode;\n_   (Read_u8 (& opcode, & o->wasm, o->wasmEnd));             m3log (compile, d_indent \" (FC: %\" PRIi32 \")\", get_indention_string (o), opcode);\n\n    i_opcode = (i_opcode << 8) | opcode;\n\n    //printf(\"Extended opcode: 0x%x\\n\", i_opcode);\n\n    const M3OpInfo* opinfo = GetOpInfo (i_opcode);\n    _throwif (m3Err_unknownOpcode, not opinfo);\n\n    M3Compiler compiler = opinfo->compiler;\n    _throwif (m3Err_noCompiler, not compiler);\n\n_   ((* compiler) (o, i_opcode));\n\n    o->previousOpcode = i_opcode;\n\n\t} _catch: return result;\n}",
        "file_path": "/src/wasm3/source/m3_compile.c",
        "crashing_line": "    M3Compiler compiler = opinfo->compiler;",
        "crashing_line_number": 1120
      },
      {
        "function_name": "CompileBlockStatements",
        "function_body": "M3Result  CompileBlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n    bool validEnd = false;\n\n    while (o->wasm < o->wasmEnd)\n    {                                                                   emit_stack_dump (o);\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        // Restrict opcodes when evaluating expressions\n        if (not o->function) {\n            switch (opcode) {\n            case c_waOp_i32_const: case c_waOp_i64_const:\n            case c_waOp_f32_const: case c_waOp_f64_const:\n            case c_waOp_getGlobal: case c_waOp_end:\n                break;\n            default:\n                _throw(m3Err_restictedOpcode);\n            }\n        }\n\n        IM3OpInfo opinfo = GetOpInfo(opcode);\n        \n        if (opinfo == NULL)\n            _throw (ErrorCompile (m3Err_unknownOpcode, o, \"opcode '%x' not available\", opcode));\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;\n\n        if (opcode == c_waOp_else)\n        {\n            _throwif (m3Err_wasmMalformed, o->block.opcode != c_waOp_if);\n            validEnd = true;\n            break;\n        }\n        else if (opcode == c_waOp_end)\n        {\n            validEnd = true;\n            break;\n        }\n    }\n    _throwif(m3Err_wasmMalformed, !(validEnd));\n\n_catch:\n    return result;\n}",
        "file_path": "/src/wasm3/source/m3_compile.c",
        "crashing_line": "            _throw (ErrorCompile (m3Err_unknownOpcode, o, \"opcode '%x' not available\", opcode));",
        "crashing_line_number": 2477
      },
      {
        "function_name": "CompileBlock",
        "function_body": "M3Result  CompileBlock  (IM3Compilation o, IM3FuncType i_blockType, m3opcode_t i_blockOpcode)\n{\n    M3Result result = m3Err_none;                                                       d_m3Assert (not IsRegisterAllocated (o, 0));\n                                                                                        d_m3Assert (not IsRegisterAllocated (o, 1));\n    M3CompilationScope outerScope = o->block;\n    M3CompilationScope * block = & o->block;\n\n    block->outer            = & outerScope;\n    block->pc               = GetPagePC (o->page);\n    block->patches          = NULL;\n    block->type             = i_blockType;\n    block->depth            ++;\n    block->opcode           = i_blockOpcode;\n\n    /*\n     The block stack frame is a little strange but for good reasons.  Because blocks need to be restarted to\n     compile different pathways (if/else), the incoming params must be saved.  The parameters are popped\n     and validated.  But, then the stack top is readjusted so they aren't subsequently overwritten.\n     Next, the result are preallocated to find destination slots.  But again these are immediately popped\n     (deallocated) and the stack top is readjusted to keep these records in pace. This allows branch instructions\n     to find their result landing pads.  Finally, the params are copied from the \"dead\" records and pushed back\n     onto the stack as active stack items for the CompileBlockStatements () call.\n\n    [     block      ]\n    [     params     ]\n    ------------------\n    [     result     ]  <---- blockStackIndex\n    [      slots     ]\n    ------------------\n    [   saved param  ]\n    [     records    ]\n                        <----- exitStackIndex\n    */\n\n_try {\n    // validate and dealloc params ----------------------------\n\n    u16 stackIndex = o->stackIndex;\n\n    u16 numParams = GetFuncTypeNumParams (i_blockType);\n\n    if (i_blockOpcode != c_waOp_else)\n    {\n        for (u16 i = 0; i < numParams; ++i)\n        {\n            u8 type = GetFuncTypeParamType (i_blockType, numParams - 1 - i);\n_           (PopType (o, type));\n        }\n    }\n    else o->stackIndex -= numParams;\n\n    u16 paramIndex = o->stackIndex;\n    block->exitStackIndex = paramIndex; // consume the params at block exit\n\n    // keep copies of param slots in the stack\n    o->stackIndex = stackIndex;\n\n    // find slots for the results ----------------------------\n    PushBlockResults (o);\n\n    stackIndex = o->stackIndex;\n\n    // dealloc but keep record of the result slots in the stack\n    u16 numResults = GetFuncTypeNumResults (i_blockType);\n    while (numResults--)\n        Pop (o);\n\n    block->blockStackIndex = o->stackIndex = stackIndex;\n\n    // push the params back onto the stack -------------------\n    for (u16 i = 0; i < numParams; ++i)\n    {\n        u8 type = GetFuncTypeParamType (i_blockType, i);\n\n        u16 slot = GetSlotForStackIndex (o, paramIndex + i);\n        Push (o, type, slot);\n\n        if (slot >= o->slotFirstDynamicIndex)\n            MarkSlotsAllocatedByType (o, slot, type);\n    }\n\n    //--------------------------------------------------------\n\n_   (CompileBlockStatements (o));\n\n_   (ValidateBlockEnd (o));\n\n    if (o->function)    // skip for expressions\n    {\n        if (not IsStackPolymorphic (o))\n_           (ResolveBlockResults (o, & o->block, /* isBranch: */ false));\n\n_       (UnwindBlockStack (o))\n\n        if (not ((i_blockOpcode == c_waOp_if and numResults) or o->previousOpcode == c_waOp_else))\n        {\n            o->stackIndex = o->block.exitStackIndex;\n_           (PushBlockResults (o));\n        }\n    }\n\n    PatchBranches (o);\n\n    o->block = outerScope;\n\n}   _catch: return result;\n}",
        "file_path": "/src/wasm3/source/m3_compile.c",
        "crashing_line": "",
        "crashing_line_number": 2609
      },
      {
        "function_name": "Compile_LoopOrBlock",
        "function_body": "M3Result  Compile_LoopOrBlock  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    // TODO: these shouldn't be necessary for non-loop blocks?\n_   (PreserveRegisters (o));\n_   (PreserveArgsAndLocals (o));\n\n    IM3FuncType blockType;\n_   (ReadBlockType (o, & blockType));\n\n    if (i_opcode == c_waOp_loop)\n    {\n        u16 numParams = GetFuncTypeNumParams (blockType);\n        if (numParams)\n        {\n            // instantiate constants\n            u16 numValues = GetNumBlockValuesOnStack (o);                   // CompileBlock enforces this at comptime\n                                                                            d_m3Assert (numValues >= numParams);\n            if (numValues >= numParams)\n            {\n                u16 stackTop = GetStackTopIndex (o) + 1;\n\n                for (u16 i = stackTop - numParams; i < stackTop; ++i)\n                {\n                    u16 slot = GetSlotForStackIndex (o, i);\n                    u8 type = GetStackTypeFromBottom (o, i);\n\n                    if (IsConstantSlot (o, slot))\n                    {\n                        u16 newSlot;\n_                       (AllocateSlots (o, & newSlot, type));\n_                       (CopyStackIndexToSlot (o, newSlot, i));\n                        o->wasmStack [i] = newSlot;\n                    }\n                }\n            }\n        }\n\n_       (EmitOp (o, op_Loop));\n    }\n    else\n    {\n    }\n\n_   (CompileBlock (o, blockType, i_opcode));\n\n    _catch: return result;\n}",
        "file_path": "/src/wasm3/source/m3_compile.c",
        "crashing_line": "    {",
        "crashing_line_number": 1804
      },
      {
        "function_name": "CompileBlockStatements",
        "function_body": "M3Result  CompileBlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n    bool validEnd = false;\n\n    while (o->wasm < o->wasmEnd)\n    {                                                                   emit_stack_dump (o);\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        // Restrict opcodes when evaluating expressions\n        if (not o->function) {\n            switch (opcode) {\n            case c_waOp_i32_const: case c_waOp_i64_const:\n            case c_waOp_f32_const: case c_waOp_f64_const:\n            case c_waOp_getGlobal: case c_waOp_end:\n                break;\n            default:\n                _throw(m3Err_restictedOpcode);\n            }\n        }\n\n        IM3OpInfo opinfo = GetOpInfo(opcode);\n        \n        if (opinfo == NULL)\n            _throw (ErrorCompile (m3Err_unknownOpcode, o, \"opcode '%x' not available\", opcode));\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;\n\n        if (opcode == c_waOp_else)\n        {\n            _throwif (m3Err_wasmMalformed, o->block.opcode != c_waOp_if);\n            validEnd = true;\n            break;\n        }\n        else if (opcode == c_waOp_end)\n        {\n            validEnd = true;\n            break;\n        }\n    }\n    _throwif(m3Err_wasmMalformed, !(validEnd));\n\n_catch:\n    return result;\n}",
        "file_path": "/src/wasm3/source/m3_compile.c",
        "crashing_line": "            _throw (ErrorCompile (m3Err_unknownOpcode, o, \"opcode '%x' not available\", opcode));",
        "crashing_line_number": 2477
      },
      {
        "function_name": "CompileFunction",
        "function_body": "M3Result  CompileFunction  (IM3Function io_function)\n{\n    M3Result result = m3Err_none;\n\n    if (!io_function->wasm) return \"function body is missing\";\n\n    IM3FuncType funcType = io_function->funcType;                   m3log (compile, \"compiling: [%d] %s %s; wasm-size: %d\",\n                                                                        io_function->index, m3_GetFunctionName (io_function), SPrintFuncTypeSignature (funcType), (u32) (io_function->wasmEnd - io_function->wasm));\n    IM3Runtime runtime = io_function->module->runtime;\n\n    IM3Compilation o = & runtime->compilation;                      d_m3Assert (d_m3MaxFunctionSlots >= d_m3MaxFunctionStackHeight * (d_m3Use32BitSlots + 1))  // need twice as many slots in 32-bit mode\n    memset (o, 0x0, sizeof (M3Compilation));\n\n    o->runtime  = runtime;\n    o->module   = io_function->module;\n    o->function = io_function;\n    o->wasm     = io_function->wasm;\n    o->wasmEnd  = io_function->wasmEnd;\n    o->block.type = funcType;\n\n_try {\n    // skip over code size. the end was already calculated during parse phase\n    u32 size;\n_   (ReadLEB_u32 (& size, & o->wasm, o->wasmEnd));                  d_m3Assert (size == (o->wasmEnd - o->wasm))\n\n_   (AcquireCompilationCodePage (o, & o->page));\n\n    pc_t pc = GetPagePC (o->page);\n\n    u16 numRetSlots = GetFunctionNumReturns (o->function) * c_ioSlotCount;\n\n    for (u16 i = 0; i < numRetSlots; ++i)\n        MarkSlotAllocated (o, i);\n\n    o->function->numRetSlots = o->slotFirstDynamicIndex = numRetSlots;\n\n    u16 numArgs = GetFunctionNumArgs (o->function);\n\n    // push the arg types to the type stack\n    for (u16 i = 0; i < numArgs; ++i)\n    {\n        u8 type = GetFunctionArgType (o->function, i);\n_       (PushAllocatedSlot (o, type));\n\n        // prevent allocator fill-in\n        o->slotFirstDynamicIndex += c_ioSlotCount;\n    }\n\n    o->slotMaxAllocatedIndexPlusOne = o->function->numRetAndArgSlots = o->slotFirstLocalIndex = o->slotFirstDynamicIndex;\n\n_   (CompileLocals (o));\n\n    u16 maxSlot = GetMaxUsedSlotPlusOne (o);\n\n    o->function->numLocalBytes = (maxSlot - o->slotFirstLocalIndex) * sizeof (m3slot_t);\n\n    o->slotFirstConstIndex = o->slotMaxConstIndex = maxSlot;\n\n    // ReserveConstants initializes o->firstDynamicSlotNumber\n_   (ReserveConstants (o));\n\n    // start tracking the max stack used (Push() also updates this value) so that op_Entry can precisely detect stack overflow\n    o->maxStackSlots = o->slotMaxAllocatedIndexPlusOne = o->slotFirstDynamicIndex;\n\n    o->block.blockStackIndex = o->stackFirstDynamicIndex = o->stackIndex;                           m3log (compile, \"start stack index: %d\",\n                                                                                                          (u32) o->stackFirstDynamicIndex);\n_   (EmitOp (o, op_Entry));\n    EmitPointer (o, io_function);\n\n_   (CompileBlockStatements (o));\n\n    // TODO: validate opcode sequences\n    _throwif(m3Err_wasmMalformed, o->previousOpcode != c_waOp_end);\n\n    io_function->compiled = pc;\n    io_function->maxStackSlots = o->maxStackSlots;\n\n    u16 numConstantSlots = o->slotMaxConstIndex - o->slotFirstConstIndex;                           m3log (compile, \"unique constant slots: %d; unused slots: %d\",\n                                                                                                           numConstantSlots, o->slotFirstDynamicIndex - o->slotMaxConstIndex);\n    io_function->numConstantBytes = numConstantSlots * sizeof (m3slot_t);\n\n    if (numConstantSlots)\n    {\n        io_function->constants = m3_CopyMem (o->constants, io_function->numConstantBytes);\n        _throwifnull(io_function->constants);\n    }\n\n} _catch:\n\n    ReleaseCompilationCodePage (o);\n\n    return result;\n}",
        "file_path": "/src/wasm3/source/m3_compile.c",
        "crashing_line": "_   (EmitOp (o, op_Entry));",
        "crashing_line_number": 2767
      },
      {
        "function_name": "m3_FindFunction",
        "function_body": "M3Result  m3_FindFunction  (IM3Function * o_function, IM3Runtime i_runtime, const char * const i_functionName)\n{\n    M3Result result = m3Err_none;                               d_m3Assert (o_function and i_runtime and i_functionName);\n\n    IM3Function function = NULL;\n\n    if (not i_runtime->modules) {\n        _throw (\"no modules loaded\");\n    }\n\n    function = (IM3Function) ForEachModule (i_runtime, (ModuleVisitor) v_FindFunction, (void *) i_functionName);\n\n    if (function)\n    {\n        if (not function->compiled)\n        {\n_           (CompileFunction (function))\n        }\n\n        // Check if start function needs to be called\n        if (function->module->startFunction)\n        {\n_           (m3_RunStart (function->module))\n        }\n    }\n    else _throw (ErrorModule (m3Err_functionLookupFailed, i_runtime->modules, \"'%s'\", i_functionName));\n\n    _catch:\n    if (result)\n        function = NULL;\n\n    * o_function = function;\n\n    return result;\n}",
        "file_path": "/src/wasm3/source/m3_env.c",
        "crashing_line": "",
        "crashing_line_number": 686
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static int parser_conf_file(const char *cfg, struct mk_rconf *fconf,\n                            struct flb_config *config)\n{\n    flb_sds_t name;\n    flb_sds_t format;\n    flb_sds_t regex;\n    flb_sds_t time_fmt;\n    flb_sds_t time_key;\n    flb_sds_t time_offset;\n    flb_sds_t types_str;\n    flb_sds_t tmp_str;\n    int time_keep;\n    int time_strict;\n    int types_len;\n    struct mk_list *head;\n    struct mk_list *decoders = NULL;\n    struct mk_rconf_section *section;\n    struct flb_parser_types *types = NULL;\n\n    /* Read all [PARSER] sections */\n    mk_list_foreach(head, &fconf->sections) {\n        name = NULL;\n        format = NULL;\n        regex = NULL;\n        time_fmt = NULL;\n        time_key = NULL;\n        time_offset = NULL;\n        types_str = NULL;\n        tmp_str = NULL;\n\n        section = mk_list_entry(head, struct mk_rconf_section, _head);\n        if (strcasecmp(section->name, \"PARSER\") != 0) {\n            continue;\n        }\n\n        /* Name */\n        name = get_parser_key(\"Name\", config, section);\n        if (!name) {\n            flb_error(\"[parser] no parser 'name' found in file '%s'\", cfg);\n            goto fconf_error;\n        }\n\n        /* Format */\n        format = get_parser_key(\"Format\", config, section);\n        if (!format) {\n            flb_error(\"[parser] no parser 'format' found for '%s' in file '%s'\",\n                      name, cfg);\n            goto fconf_error;\n        }\n\n        /* Regex (if 'format' == 'regex') */\n        regex = get_parser_key(\"Regex\", config, section);\n        if (!regex && strcmp(format, \"regex\") == 0) {\n            flb_error(\"[parser] no parser 'regex' found for '%s' in file '%s\", name, cfg);\n            goto fconf_error;\n        }\n\n        /* Time_Format */\n        time_fmt = get_parser_key(\"Time_Format\", config, section);\n\n        /* Time_Key */\n        time_key = get_parser_key(\"Time_Key\", config, section);\n\n        /* Time_Keep */\n        time_keep = FLB_FALSE;\n        tmp_str = get_parser_key(\"Time_Keep\", config, section);\n        if (tmp_str) {\n            time_keep = flb_utils_bool(tmp_str);\n            flb_sds_destroy(tmp_str);\n        }\n\n        /* Time_Strict */\n        time_strict = FLB_TRUE;\n        tmp_str = get_parser_key(\"Time_Strict\", config, section);\n        if (tmp_str) {\n            time_strict = flb_utils_bool(tmp_str);\n            flb_sds_destroy(tmp_str);\n        }\n\n        /* Time_Offset (UTC offset) */\n        time_offset = get_parser_key(\"Time_Offset\", config, section);\n\n        /* Types */\n        types_str = get_parser_key(\"Types\", config, section);\n        if (types_str) {\n            types_len = proc_types_str(types_str, &types);\n        }\n        else {\n            types_len = 0;\n        }\n\n        /* Decoders */\n        decoders = flb_parser_decoder_list_create(section);\n\n        /* Create the parser context */\n        if (!flb_parser_create(name, format, regex,\n                               time_fmt, time_key, time_offset, time_keep, time_strict,\n                               types, types_len, decoders, config)) {\n            goto fconf_error;\n        }\n\n        flb_debug(\"[parser] new parser registered: %s\", name);\n\n        flb_sds_destroy(name);\n        flb_sds_destroy(format);\n\n        if (regex) {\n            flb_sds_destroy(regex);\n        }\n        if (time_fmt) {\n            flb_sds_destroy(time_fmt);\n        }\n        if (time_key) {\n            flb_sds_destroy(time_key);\n        }\n        if (time_offset) {\n            flb_sds_destroy(time_offset);\n        }\n        if (types_str) {\n            flb_sds_destroy(types_str);\n        }\n        decoders = NULL;\n    }\n\n    mk_rconf_free(fconf);\n    return 0;\n\n fconf_error:\n    flb_sds_destroy(name);\n    flb_sds_destroy(format);\n    if (regex) {\n        flb_sds_destroy(regex);\n    }\n    if (time_fmt) {\n        flb_sds_destroy(time_fmt);\n    }\n    if (time_key) {\n        flb_sds_destroy(time_key);\n    }\n    if (time_offset) {\n        flb_sds_destroy(time_offset);\n    }\n    if (types_str) {\n        flb_sds_destroy(types_str);\n    }\n    if (decoders) {\n        flb_parser_decoder_list_destroy(decoders);\n    }\n    return -1;\n}\nstatic int multiline_parser_conf_file(const char *cfg, struct mk_rconf *fconf,\n                                      struct flb_config *config)\n{\n    flb_sds_t name;\n    int type;\n    flb_sds_t match_string;\n    int negate;\n    flb_sds_t key_content;\n    flb_sds_t key_pattern;\n    flb_sds_t key_group;\n    flb_sds_t parser;\n    flb_sds_t tmp;\n    int flush_timeout;\n    struct mk_list *head;\n    struct mk_rconf_section *section;\n    struct flb_ml *ml;\n\n    /* Read all [PARSER] sections */\n    mk_list_foreach(head, &fconf->sections) {\n        name = NULL;\n        type = -1;\n        match_string = NULL;\n        negate = FLB_FALSE;\n        key_content = NULL;\n        key_pattern = NULL;\n        key_group = NULL;\n        parser = NULL;\n        flush_timeout = -1;\n\n        section = mk_list_entry(head, struct mk_rconf_section, _head);\n        if (strcasecmp(section->name, \"MULTILINE_PARSER\") != 0) {\n            continue;\n        }\n\n        /* name */\n        name = get_parser_key(\"name\", config, section);\n        if (!name) {\n            flb_error(\"[multiline_parser] no 'name' defined in file '%s'\", cfg);\n            goto fconf_error;\n        }\n\n        /* type */\n        tmp = get_parser_key(\"type\", config, section);\n        if (!tmp) {\n            flb_error(\"[multiline_parser] no 'type' defined in file '%s'\", cfg);\n            goto fconf_error;\n        }\n        else {\n            type = flb_ml_type_lookup(tmp);\n            if (type == -1) {\n                flb_error(\"[multiline_parser] invalid type '%s'\", tmp);\n                flb_sds_destroy(tmp);\n                goto fconf_error;\n            }\n            flb_sds_destroy(tmp);\n        }\n\n        /* match_string */\n        match_string = get_parser_key(\"match_string\", config, section);\n\n        /* negate */\n        tmp = get_parser_key(\"negate\", config, section);\n        if (tmp) {\n            negate = flb_utils_bool(tmp);\n            flb_sds_destroy(tmp);\n        }\n\n        /* key_content */\n        key_content = get_parser_key(\"key_content\", config, section);\n\n        /* key_pattern */\n        key_pattern = get_parser_key(\"key_pattern\", config, section);\n\n        /* key_group */\n        key_group = get_parser_key(\"key_group\", config, section);\n\n        /* parser */\n        parser = get_parser_key(\"parser\", config, section);\n\n        /* flush_timeout */\n        tmp = get_parser_key(\"flush_timeout\", config, section);\n        if (tmp) {\n            flush_timeout = atoi(tmp);\n        }\n\n        ml = flb_ml_create(config, name, type, match_string, negate,\n                           flush_timeout, key_content, key_group, key_pattern,\n                           NULL, parser);\n\n        flb_sds_destroy(name);\n        flb_sds_destroy(match_string);\n        flb_sds_destroy(key_content);\n        flb_sds_destroy(key_pattern);\n        flb_sds_destroy(key_group);\n    }\n\n    mk_rconf_free(fconf);\n    return 0;\n\n fconf_error:\n    flb_sds_destroy(name);\n    flb_sds_destroy(match_string);\n    flb_sds_destroy(key_content);\n    flb_sds_destroy(key_pattern);\n    flb_sds_destroy(key_group);\n\n    return -1;\n}\n",
    "target": 1,
    "idx": 1034960,
    "stack_trace": [
      {
        "function_name": "flb_parser_conf_file",
        "function_body": "int flb_parser_conf_file(const char *file, struct flb_config *config)\n{\n    int ret;\n    char tmp[PATH_MAX + 1];\n    const char *cfg = NULL;\n    struct mk_rconf *fconf;\n    struct stat st;\n\n#ifndef FLB_HAVE_STATIC_CONF\n    ret = stat(file, &st);\n    if (ret == -1 && errno == ENOENT) {\n        /* Try to resolve the real path (if exists) */\n        if (file[0] == '/') {\n            flb_utils_error(FLB_ERR_CFG_PARSER_FILE);\n            return -1;\n        }\n\n        if (config->conf_path) {\n            snprintf(tmp, PATH_MAX, \"%s%s\", config->conf_path, file);\n            cfg = tmp;\n        }\n    }\n    else {\n        cfg = file;\n    }\n\n    fconf = mk_rconf_open(cfg);\n#else\n    fconf = flb_config_static_open(file);\n#endif\n\n    if (!fconf) {\n        return -1;\n    }\n\n    /* process [PARSER]'s sections */\n    ret = parser_conf_file(cfg, fconf, config);\n    if (ret == -1) {\n        mk_rconf_free(fconf);\n        return -1;\n    }\n\n    ret = multiline_parser_conf_file(cfg, fconf, config);\n    if (ret == -1) {\n        mk_rconf_free(fconf);\n        return -1;\n    }\n\n    mk_rconf_free(fconf);\n    return 0;\n}",
        "file_path": "/src/fluent-bit/src/flb_parser.c",
        "crashing_line": "        mk_rconf_free(fconf);",
        "crashing_line_number": 747
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_NULL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *val;\n\n\tval = RT_CONSTANT(opline, opline->op1);\n\tif (IS_CONST != IS_CONST) {\n\t\tZVAL_DEREF(val);\n\t}\n\n\tif (Z_TYPE_INFO_P(val) > IS_NULL) {\n\t\tZEND_VM_NEXT_OPCODE();\n\t} else {\n\t\tzval *result = EX_VAR(opline->result.var);\n\n\t\tif (EXPECTED(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EXPR)) {\n\t\t\tif (UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {\n\t\t\t\tSAVE_OPLINE();\n\t\t\t\tZVAL_UNDEFINED_OP1();\n\t\t\t\tif (UNEXPECTED(EG(exception) != NULL)) {\n\t\t\t\t\tHANDLE_EXCEPTION();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tZVAL_NULL(result);\n\t\t} else if (opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_ISSET) {\n\t\t\tZVAL_FALSE(result);\n\t\t} else {\n\t\t\tZEND_ASSERT(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EMPTY);\n\t\t\tZVAL_TRUE(result);\n\t\t}\n\n\t\tZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);\n\t}\n}\nstatic ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_NULL_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *val;\n\n\tval = EX_VAR(opline->op1.var);\n\tif ((IS_TMP_VAR|IS_VAR|IS_CV) != IS_CONST) {\n\t\tZVAL_DEREF(val);\n\t}\n\n\tif (Z_TYPE_INFO_P(val) > IS_NULL) {\n\t\tZEND_VM_NEXT_OPCODE();\n\t} else {\n\t\tzval *result = EX_VAR(opline->result.var);\n\n\t\tif (EXPECTED(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EXPR)) {\n\t\t\tif (UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {\n\t\t\t\tSAVE_OPLINE();\n\t\t\t\tZVAL_UNDEFINED_OP1();\n\t\t\t\tif (UNEXPECTED(EG(exception) != NULL)) {\n\t\t\t\t\tHANDLE_EXCEPTION();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tZVAL_NULL(result);\n\t\t} else if (opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_ISSET) {\n\t\t\tZVAL_FALSE(result);\n\t\t} else {\n\t\t\tZEND_ASSERT(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EMPTY);\n\t\t\tZVAL_TRUE(result);\n\t\t}\n\n\t\tZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);\n\t}\n}\n",
    "target": 1,
    "idx": 1025526,
    "stack_trace": [
      {
        "function_name": "zend_gc_delref",
        "function_body": "static zend_always_inline uint32_t zend_gc_delref(zend_refcounted_h *p) {\n\tZEND_ASSERT(p->refcount > 0);\n\tZEND_RC_MOD_CHECK(p);\n\treturn --(p->refcount);\n}",
        "file_path": "/src/php-src/Zend/zend_types.h",
        "crashing_line": "\tZEND_ASSERT(p->refcount > 0);",
        "crashing_line_number": 1172
      },
      {
        "function_name": "i_zval_ptr_dtor",
        "function_body": "static zend_always_inline void i_zval_ptr_dtor(zval *zval_ptr)\n{\n\tif (Z_REFCOUNTED_P(zval_ptr)) {\n\t\tzend_refcounted *ref = Z_COUNTED_P(zval_ptr);\n\t\tif (!GC_DELREF(ref)) {\n\t\t\trc_dtor_func(ref);\n\t\t} else {\n\t\t\tgc_check_possible_root(ref);\n\t\t}\n\t}\n}",
        "file_path": "/src/php-src/Zend/zend_variables.h",
        "crashing_line": "\t\tif (!GC_DELREF(ref)) {",
        "crashing_line_number": 43
      },
      {
        "function_name": "zval_ptr_dtor",
        "function_body": "ZEND_API void zval_ptr_dtor(zval *zval_ptr) /* {{{ */\n{\n\ti_zval_ptr_dtor(zval_ptr);\n}",
        "file_path": "/src/php-src/Zend/zend_variables.c",
        "crashing_line": "\ti_zval_ptr_dtor(zval_ptr);",
        "crashing_line_number": 84
      },
      {
        "function_name": "user_shutdown_function_dtor",
        "function_body": "void user_shutdown_function_dtor(zval *zv) /* {{{ */\n{\n\tint i;\n\tphp_shutdown_function_entry *shutdown_function_entry = Z_PTR_P(zv);\n\n\tfor (i = 0; i < shutdown_function_entry->arg_count; i++) {\n\t\tzval_ptr_dtor(&shutdown_function_entry->arguments[i]);\n\t}\n\tefree(shutdown_function_entry->arguments);\n\tefree(shutdown_function_entry);\n}",
        "file_path": "/src/php-src/ext/standard/basic_functions.c",
        "crashing_line": "\t\tzval_ptr_dtor(&shutdown_function_entry->arguments[i]);",
        "crashing_line_number": 1662
      },
      {
        "function_name": "zend_hash_destroy",
        "function_body": "ZEND_API void ZEND_FASTCALL zend_hash_destroy(HashTable *ht)\n{\n\tBucket *p, *end;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(ht, GC_REFCOUNT(ht) <= 1);\n\n\tif (ht->nNumUsed) {\n\t\tp = ht->arData;\n\t\tend = p + ht->nNumUsed;\n\t\tif (ht->pDestructor) {\n\t\t\tSET_INCONSISTENT(HT_IS_DESTROYING);\n\n\t\t\tif (HT_HAS_STATIC_KEYS_ONLY(ht)) {\n\t\t\t\tif (HT_IS_WITHOUT_HOLES(ht)) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t}\n\t\t\t} else if (HT_IS_WITHOUT_HOLES(ht)) {\n\t\t\t\tdo {\n\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t}\n\n\t\t\tSET_INCONSISTENT(HT_DESTROYED);\n\t\t} else {\n\t\t\tif (!HT_HAS_STATIC_KEYS_ONLY(ht)) {\n\t\t\t\tdo {\n\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t}\n\t\t}\n\t\tzend_hash_iterators_remove(ht);\n\t} else if (EXPECTED(HT_FLAGS(ht) & HASH_FLAG_UNINITIALIZED)) {\n\t\treturn;\n\t}\n\tpefree(HT_GET_DATA_ADDR(ht), GC_FLAGS(ht) & IS_ARRAY_PERSISTENT);\n}",
        "file_path": "/src/php-src/Zend/zend_hash.c",
        "crashing_line": "\t\t\t\t\t\tht->pDestructor(&p->val);",
        "crashing_line_number": 1566
      },
      {
        "function_name": "php_free_shutdown_functions",
        "function_body": "PHPAPI void php_free_shutdown_functions(void) /* {{{ */\n{\n\tif (BG(user_shutdown_function_names))\n\t\tzend_try {\n\t\t\tzend_hash_destroy(BG(user_shutdown_function_names));\n\t\t\tFREE_HASHTABLE(BG(user_shutdown_function_names));\n\t\t\tBG(user_shutdown_function_names) = NULL;\n\t\t} zend_catch {",
        "file_path": "/src/php-src/ext/standard/basic_functions.c",
        "crashing_line": "\t\t\tzend_hash_destroy(BG(user_shutdown_function_names));",
        "crashing_line_number": 1776
      },
      {
        "function_name": "php_request_shutdown",
        "function_body": "void php_request_shutdown(void *dummy)\n{\n\tzend_bool report_memleaks;\n\n\tEG(flags) |= EG_FLAGS_IN_SHUTDOWN;\n\n\treport_memleaks = PG(report_memleaks);\n\n\t/* EG(current_execute_data) points into nirvana and therefore cannot be safely accessed\n\t * inside zend_executor callback functions.\n\t */\n\tEG(current_execute_data) = NULL;\n\n\tphp_deactivate_ticks();\n\n\t/* 1. Call all possible shutdown functions registered with register_shutdown_function() */\n\tif (PG(modules_activated)) {\n\t\tphp_call_shutdown_functions();\n\t}\n\n\t/* 2. Call all possible __destruct() functions */\n\tzend_try {\n\t\tzend_call_destructors();\n\t} zend_end_try();",
        "file_path": "/src/php-src/main/main.c",
        "crashing_line": "",
        "crashing_line_number": 1793
      },
      {
        "function_name": "fuzzer_request_shutdown",
        "function_body": "void fuzzer_request_shutdown()\n{\n\tzend_try {\n\t\t/* Destroy thrown exceptions. This does not happen as part of request shutdown. */\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\n\t\t/* Some fuzzers (like unserialize) may create circular structures. Make sure we free them.\n\t\t * Two calls are performed to handle objects with destructors. */\n\t\tzend_gc_collect_cycles();\n\t\tzend_gc_collect_cycles();\n\t} zend_end_try();",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-sapi.c",
        "crashing_line": "",
        "crashing_line_number": 196
      },
      {
        "function_name": "fuzzer_do_request_from_buffer",
        "function_body": "int fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-sapi.c",
        "crashing_line": "",
        "crashing_line_number": 267
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\nxmlAddIDSafe(xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr,\n             int streaming, xmlIDPtr *id) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (id != NULL)\n        *id = NULL;\n\n    if (doc == NULL) {\n\treturn(-1);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(0);\n    }\n    if (attr == NULL) {\n\treturn(-1);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n        if (table == NULL)\n            return(-1);\n    } else {\n        ret = xmlHashLookup(table, value);\n        if (ret != NULL) {\n            /*\n             * Update the attribute to make entities work.\n             */\n            if (ret->attr != NULL) {\n                ret->attr->id = NULL;\n                ret->attr = attr;\n            }\n\t    attr->atype = XML_ATTRIBUTE_ID;\n            attr->id = ret;\n            return(0);\n        }\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL)\n\treturn(-1);\n    memset(ret, 0, sizeof(*ret));\n\n    /*\n     * fill the structure.\n     */\n    ret->doc = doc;\n    ret->value = xmlStrdup(value);\n    if (ret->value == NULL) {\n        xmlFreeID(ret);\n        return(-1);\n    }\n    if (streaming) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n        if (ret->name == NULL) {\n            xmlFreeID(ret);\n            return(-1);\n        }\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n\txmlFreeID(ret);\n\treturn(-1);\n    }\n\n    attr->atype = XML_ATTRIBUTE_ID;\n    attr->id = ret;\n\n    if (id != NULL)\n        *id = ret;\n    return(1);\n}\n",
    "target": 1,
    "idx": 1066446,
    "stack_trace": [
      {
        "function_name": "xmlRemoveID",
        "function_body": "int\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n\n    if (doc == NULL) return(-1);\n    if ((attr == NULL) || (attr->id == NULL)) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)\n        return(-1);\n\n    attr->atype = 0;\n    attr->id = NULL;\n\n    return(0);\n}",
        "file_path": "/src/libxml2/valid.c",
        "crashing_line": "",
        "crashing_line_number": 2520
      },
      {
        "function_name": "xmlFreeProp",
        "function_body": "void\nxmlFreeProp(xmlAttrPtr cur) {\n    xmlDictPtr dict = NULL;\n    if (cur == NULL) return;\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {\n\t    xmlRemoveID(cur->doc, cur);\n    }\n    if (cur->children != NULL) xmlFreeNodeList(cur->children);\n    DICT_FREE(cur->name)\n    xmlFree(cur);\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "\t    xmlRemoveID(cur->doc, cur);",
        "crashing_line_number": 2080
      },
      {
        "function_name": "xmlFreePropList",
        "function_body": "void\nxmlFreePropList(xmlAttrPtr cur) {\n    xmlAttrPtr next;\n    if (cur == NULL) return;\n    while (cur != NULL) {\n        next = cur->next;\n        xmlFreeProp(cur);\n\tcur = next;\n    }\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "        xmlFreeProp(cur);",
        "crashing_line_number": 2057
      },
      {
        "function_name": "xmlFreeNodeList",
        "function_body": "void\nxmlFreeNodeList(xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if (cur->doc != NULL) dict = cur->doc->dict;\n    while (1) {\n        while ((cur->children != NULL) &&\n               (cur->type != XML_DOCUMENT_NODE) &&\n               (cur->type != XML_HTML_DOCUMENT_NODE) &&\n               (cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\tif ((cur->type == XML_DOCUMENT_NODE) ||\n            (cur->type == XML_HTML_DOCUMENT_NODE)) {\n            xmlFreeDoc((xmlDocPtr) cur);\n        } else if (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlFreePropList(cur->properties);\n\t    if ((cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE) &&\n\t\t(cur->content != (xmlChar *) &(cur->properties))) {\n\t\tDICT_FREE(cur->content)\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * When a node is a text node or a comment, it uses a global static\n\t     * variable for the name of the node.\n\t     * Otherwise the node name might come from the document's\n\t     * dictionary\n\t     */\n\t    if ((cur->name != NULL) &&\n\t\t(cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name)\n\t    xmlFree(cur);\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "\t\txmlFreePropList(cur->properties);",
        "crashing_line_number": 3681
      },
      {
        "function_name": "xmlFreeNode",
        "function_body": "void\nxmlFreeNode(xmlNodePtr cur) {\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return;\n\n    /* use xmlFreeDtd for DTD nodes */\n    if (cur->type == XML_DTD_NODE) {\n\txmlFreeDtd((xmlDtdPtr) cur);\n\treturn;\n    }\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNs((xmlNsPtr) cur);\n        return;\n    }\n    if (cur->type == XML_ATTRIBUTE_NODE) {\n\txmlFreeProp((xmlAttrPtr) cur);\n\treturn;\n    }\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue(cur);\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if (cur->type == XML_ENTITY_DECL) {\n        xmlEntityPtr ent = (xmlEntityPtr) cur;\n\tDICT_FREE(ent->SystemID);\n\tDICT_FREE(ent->ExternalID);\n    }\n    if ((cur->children != NULL) &&\n\t(cur->type != XML_ENTITY_REF_NODE))\n\txmlFreeNodeList(cur->children);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n        (cur->type == XML_XINCLUDE_START) ||\n        (cur->type == XML_XINCLUDE_END)) {\n        if (cur->properties != NULL)\n            xmlFreePropList(cur->properties);\n        if (cur->nsDef != NULL)\n            xmlFreeNsList(cur->nsDef);\n    } else if ((cur->content != NULL) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->content != (xmlChar *) &(cur->properties))) {\n        DICT_FREE(cur->content)\n    }\n\n    /*\n     * When a node is a text node or a comment, it uses a global static\n     * variable for the name of the node.\n     * Otherwise the node name might come from the document's dictionary\n     */\n    if ((cur->name != NULL) &&\n        (cur->type != XML_TEXT_NODE) &&\n        (cur->type != XML_COMMENT_NODE))\n\tDICT_FREE(cur->name)\n\n    xmlFree(cur);\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "\txmlFreeNodeList(cur->children);",
        "crashing_line_number": 3759
      },
      {
        "function_name": "xmlCtxtParseContent",
        "function_body": "static xmlNodePtr\nxmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n                    int hasTextDecl, int buildTree) {\n    xmlNodePtr root = NULL;\n    xmlNodePtr list = NULL;\n    xmlChar *rootName = BAD_CAST \"#root\";\n    int result;\n\n    if (buildTree) {\n        root = xmlNewDocNode(ctxt->myDoc, NULL, rootName, NULL);\n        if (root == NULL) {\n            xmlErrMemory(ctxt);\n            goto error;\n        }\n    }\n\n    if (xmlPushInput(ctxt, input) < 0)\n        goto error;\n\n    nameNsPush(ctxt, rootName, NULL, NULL, 0, 0);\n    spacePush(ctxt, -1);\n\n    if (buildTree)\n        nodePush(ctxt, root);\n\n    if (hasTextDecl) {\n        xmlDetectEncoding(ctxt);\n\n        /*\n         * Parse a possible text declaration first\n         */\n        if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n            (IS_BLANK_CH(NXT(5)))) {\n            xmlParseTextDecl(ctxt);\n            /*\n             * An XML-1.0 document can't reference an entity not XML-1.0\n             */\n            if ((xmlStrEqual(ctxt->version, BAD_CAST \"1.0\")) &&\n                (!xmlStrEqual(ctxt->input->version, BAD_CAST \"1.0\"))) {\n                xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,\n                               \"Version mismatch between document and \"\n                               \"entity\\n\");\n            }\n        }\n    }\n\n    xmlParseContentInternal(ctxt);\n\n    if (ctxt->input->cur < ctxt->input->end)\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n\n    if ((ctxt->wellFormed) ||\n        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n        if (root != NULL) {\n            xmlNodePtr cur;\n\n            /*\n             * Return the newly created nodeset after unlinking it from\n             * its pseudo parent.\n             */\n            cur = root->children;\n            list = cur;\n            while (cur != NULL) {\n                cur->parent = NULL;\n                cur = cur->next;\n            }\n            root->children = NULL;\n            root->last = NULL;\n        }\n    }\n\n    /*\n     * Read the rest of the stream in case of errors. We want\n     * to account for the whole entity size.\n     */\n    do {\n        ctxt->input->cur = ctxt->input->end;\n        xmlParserShrink(ctxt);\n        result = xmlParserGrow(ctxt);\n    } while (result > 0);\n\n    if (buildTree)\n        nodePop(ctxt);\n\n    namePop(ctxt);\n    spacePop(ctxt);\n\n    /* xmlPopInput would free the stream */\n    inputPop(ctxt);\n\nerror:\n    xmlFreeNode(root);\n\n    return(list);\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "    xmlFreeNode(root);",
        "crashing_line_number": 12076
      },
      {
        "function_name": "xmlCtxtParseEntity",
        "function_body": "static void\nxmlCtxtParseEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {\n    xmlParserInputPtr input;\n    xmlNodePtr list;\n    unsigned long consumed;\n    int isExternal;\n    int buildTree;\n    int oldMinNsIndex;\n    int oldNodelen, oldNodemem;\n\n    isExternal = (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY);\n    buildTree = (ctxt->node != NULL);\n\n    /*\n     * Recursion check\n     */\n    if (ent->flags & XML_ENT_EXPANDING) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        xmlHaltParser(ctxt);\n        goto error;\n    }\n\n    /*\n     * Load entity\n     */\n    input = xmlNewEntityInputStream(ctxt, ent);\n    if (input == NULL)\n        goto error;\n\n    /*\n     * When building a tree, we need to limit the scope of namespace\n     * declarations, so that entities don't reference xmlNs structs\n     * from the parent of a reference.\n     */\n    oldMinNsIndex = ctxt->nsdb->minNsIndex;\n    if (buildTree)\n        ctxt->nsdb->minNsIndex = ctxt->nsNr;\n\n    oldNodelen = ctxt->nodelen;\n    oldNodemem = ctxt->nodemem;\n    ctxt->nodelen = 0;\n    ctxt->nodemem = 0;\n\n    /*\n     * Parse content\n     *\n     * This initiates a recursive call chain:\n     *\n     * - xmlCtxtParseContent\n     * - xmlParseContentInternal\n     * - xmlParseReference\n     * - xmlCtxtParseEntity\n     *\n     * The nesting depth is limited by the maximum number of inputs,\n     * see xmlPushInput.\n     *\n     * It's possible to make this non-recursive (minNsIndex must be\n     * stored in the input struct) at the expense of code readability.\n     */\n\n    ent->flags |= XML_ENT_EXPANDING;\n\n    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);\n\n    ent->flags &= ~XML_ENT_EXPANDING;\n\n    ctxt->nsdb->minNsIndex = oldMinNsIndex;\n    ctxt->nodelen = oldNodelen;\n    ctxt->nodemem = oldNodemem;\n\n    /*\n     * Entity size accounting\n     */\n    consumed = input->consumed;\n    xmlSaturatedAddSizeT(&consumed, input->end - input->base);\n\n    if ((ent->flags & XML_ENT_CHECKED) == 0)\n        xmlSaturatedAdd(&ent->expandedSize, consumed);\n\n    if ((ent->flags & XML_ENT_PARSED) == 0) {\n        if (isExternal)\n            xmlSaturatedAdd(&ctxt->sizeentities, consumed);\n\n        ent->children = list;\n\n        while (list != NULL) {\n            list->parent = (xmlNodePtr) ent;\n            if (list->next == NULL)\n                ent->last = list;\n            list = list->next;\n        }\n    } else {\n        xmlFreeNodeList(list);\n    }\n\n    xmlFreeInputStream(input);\n\nerror:\n    ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);",
        "crashing_line_number": 12143
      },
      {
        "function_name": "xmlParseTryOrFinish",
        "function_body": "",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "",
        "crashing_line_number": 11290
      },
      {
        "function_name": "xmlParseChunk",
        "function_body": "int\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    size_t curBase;\n    size_t maxLength;\n    int end_in_lf = 0;\n\n    if ((ctxt == NULL) || (size < 0))\n        return(XML_ERR_ARGUMENT);\n    if (ctxt->disableSAX != 0)\n        return(ctxt->errNo);\n    if (ctxt->input == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt->input->flags |= XML_INPUT_PROGRESSIVE;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlCtxtInitializeLate(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n\n    curBase = ctxt->input->cur - ctxt->input->base;\n    maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                XML_MAX_HUGE_LENGTH :\n                XML_MAX_LOOKUP_LIMIT;\n    if (curBase > maxLength) {\n        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n                    \"Buffer size limit exceeded, try XML_PARSE_HUGE\\n\");\n        xmlHaltParser(ctxt);\n    }\n\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n            ctxt->instate = XML_PARSER_EOF;\n            xmlFinishDocument(ctxt);\n\t}\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "    xmlParseTryOrFinish(ctxt, terminate);",
        "crashing_line_number": 11587
      },
      {
        "function_name": "xmlTextReaderPushData",
        "function_body": "static int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlCtxtErrIO(reader->ctxt, reader->input->error, NULL);\n                    reader->mode = XML_TEXTREADER_MODE_ERROR;\n                    reader->state = XML_TEXTREADER_ERROR;\n                    return(-1);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}",
        "file_path": "/src/libxml2/xmlreader.c",
        "crashing_line": "\t    val = xmlParseChunk(reader->ctxt,",
        "crashing_line_number": 769
      },
      {
        "function_name": "xmlTextReaderRead",
        "function_body": "int\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}",
        "file_path": "/src/libxml2/xmlreader.c",
        "crashing_line": "\t    val = xmlTextReaderPushData(reader);",
        "crashing_line_number": 1228
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n#ifdef DEBUG_READER\n    fprintf(stderr, \"\\nREAD \");\n    DUMP_READER\n#endif\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\treader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n\t}\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    xmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))\n\txmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n#ifdef LIBXML_DOCB_ENABLED\n\t(reader->node->type == XML_DOCB_DOCUMENT_NODE) ||\n#endif\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    DUMP_READER\n\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return -1;\n\txmlXIncludeProcessNode(reader->xincctxt, reader->node);\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    xmlTextReaderEntPush(reader, reader->node);\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    xmlTextReaderValidatePush(reader);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n",
    "target": 1,
    "idx": 1025210,
    "stack_trace": [
      {
        "function_name": "xmlTextReaderRead",
        "function_body": "int\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n#ifdef DEBUG_READER\n    fprintf(stderr, \"\\nREAD \");\n    DUMP_READER\n#endif\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\treader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n\t}\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    xmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))\n\txmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n#ifdef LIBXML_DOCB_ENABLED\n\t(reader->node->type == XML_DOCB_DOCUMENT_NODE) ||\n#endif\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    DUMP_READER\n\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return -1;\n\txmlXIncludeProcessNode(reader->xincctxt, reader->node);\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    xmlTextReaderEntPush(reader, reader->node);\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    xmlTextReaderValidatePush(reader);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}",
        "file_path": "/src/libxml2/xmlreader.c",
        "crashing_line": "#endif",
        "crashing_line_number": 1539
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}\n",
    "target": 1,
    "idx": 1031124,
    "stack_trace": [
      {
        "function_name": "__cil_verify_classperms",
        "function_body": "int __cil_verify_class(struct cil_tree_node *node)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_class *class = node->data;\n\n\tif (class->common != NULL) {\n\t\tstruct cil_class *common = class->common;\n\t\tstruct cil_tree_node *common_node = common->datum.nodes->head->data;\n\t\tstruct cil_tree_node *curr_com_perm = NULL;\n\n\t\tfor (curr_com_perm = common_node->cl_head;\n\t\t\tcurr_com_perm != NULL;\n\t\t\tcurr_com_perm = curr_com_perm->next) {\n\t\t\tstruct cil_perm *com_perm = curr_com_perm->data;\n\t\t\tstruct cil_tree_node *curr_class_perm = NULL;\n\n\t\t\tfor (curr_class_perm = node->cl_head;\n\t\t\t\tcurr_class_perm != NULL;\n\t\t\t\tcurr_class_perm = curr_class_perm->next) {\n\t\t\t\tstruct cil_perm *class_perm = curr_class_perm->data;\n\n\t\t\t\tif (com_perm->datum.name == class_perm->datum.name) {\n\t\t\t\t\tcil_log(CIL_ERR, \"Duplicate permissions between %s common and class declarations\\n\", class_perm->datum.name);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(node, CIL_ERR, \"Invalid class\");\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_verify.c",
        "crashing_line": "",
        "crashing_line_number": 1629
      },
      {
        "function_name": "__verify_map_perm_classperms",
        "function_body": "static int __verify_map_perm_classperms(__attribute__((unused)) hashtab_key_t k, hashtab_datum_t d, void *args)\n{\n\tstruct cil_verify_map_args *map_args = args;\n\tstruct cil_perm *cmp = (struct cil_perm *)d;\n\n\tmap_args->rc = __cil_verify_classperms(cmp->classperms, &cmp->datum, &map_args->class->datum, &cmp->datum, CIL_MAP_PERM, 0, 2);\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_verify.c",
        "crashing_line": "\tmap_args->rc = __cil_verify_classperms(cmp->classperms, &cmp->datum, &map_args->class->datum, &cmp->datum, CIL_MAP_PERM, 0, 2);",
        "crashing_line_number": 1661
      },
      {
        "function_name": "hashtab_map",
        "function_body": "int hashtab_map(hashtab_t h,\n\t\tint (*apply) (hashtab_key_t k,\n\t\t\t      hashtab_datum_t d, void *args), void *args)\n{\n\tunsigned int i, ret;\n\thashtab_ptr_t cur;\n\n\tif (!h)\n\t\treturn SEPOL_OK;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur != NULL) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/hashtab.c",
        "crashing_line": "\t\t\tret = apply(cur->key, cur->datum, args);",
        "crashing_line_number": 234
      },
      {
        "function_name": "cil_symtab_map",
        "function_body": "int cil_symtab_map(symtab_t *symtab,\n\t\t\t\t   int (*apply) (hashtab_key_t k, hashtab_datum_t d, void *args),\n\t\t\t\t   void *args)\n{\n\treturn hashtab_map(symtab->table, apply, args);\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_symtab.c",
        "crashing_line": "\treturn hashtab_map(symtab->table, apply, args);",
        "crashing_line_number": 133
      },
      {
        "function_name": "__cil_verify_map_class",
        "function_body": "static int __cil_verify_map_class(struct cil_tree_node *node)\n{\n\tstruct cil_class *mc = node->data;\n\tstruct cil_verify_map_args map_args;\n\n\tmap_args.class = mc;\n\tmap_args.node = node;\n\tmap_args.rc = SEPOL_OK;\n\n\tcil_symtab_map(&mc->perms, __verify_map_perm_classperms, &map_args);\n\n\tif (map_args.rc != SEPOL_OK) {\n\t\treturn SEPOL_ERR;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_verify.c",
        "crashing_line": "\tcil_symtab_map(&mc->perms, __verify_map_perm_classperms, &map_args);",
        "crashing_line_number": 1675
      },
      {
        "function_name": "__cil_pre_verify_helper",
        "function_body": "int __cil_pre_verify_helper(struct cil_tree_node *node, uint32_t *finished, __attribute__((unused)) void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (node->flavor == CIL_MACRO) {\n\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t} else if (node->flavor == CIL_BLOCK) {\n\t\tstruct cil_block *blk = node->data;\n\t\tif (blk->is_abstract == CIL_TRUE) {\n\t\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\t}\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\tswitch (node->flavor) {\n\tcase CIL_USER:\n\t\trc = __cil_verify_user_pre_eval(node);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase CIL_MAP_CLASS:\n\t\trc = __cil_verify_map_class(node);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSION:\n\t\trc = __cil_verify_classpermission(node);\n\t\tbreak;\n\tdefault:\n\t\trc = SEPOL_OK;\n\t\tbreak;\n\t}\n\nexit:\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_verify.c",
        "crashing_line": "\t\trc = __cil_verify_map_class(node);",
        "crashing_line_number": 1709
      },
      {
        "function_name": "cil_tree_walk_core",
        "function_body": "int cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\t\t\trc = (*process_node)(node, &finished, extra_args);",
        "crashing_line_number": 272
      },
      {
        "function_name": "cil_tree_walk",
        "function_body": "int cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 316
      },
      {
        "function_name": "cil_tree_walk_core",
        "function_body": "int cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 284
      },
      {
        "function_name": "cil_tree_walk",
        "function_body": "int cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 316
      },
      {
        "function_name": "cil_tree_walk_core",
        "function_body": "int cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 284
      },
      {
        "function_name": "cil_tree_walk",
        "function_body": "int cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 316
      },
      {
        "function_name": "cil_pre_verify",
        "function_body": "static int cil_pre_verify(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_verify extra_args;\n\n\textra_args.db = db;\n\n\trc = cil_tree_walk(db->ast->root, __cil_pre_verify_helper, NULL, NULL, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_post.c",
        "crashing_line": "\trc = cil_tree_walk(db->ast->root, __cil_pre_verify_helper, NULL, NULL, &extra_args);",
        "crashing_line_number": 2517
      },
      {
        "function_name": "cil_post_process",
        "function_body": "int cil_post_process(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_pre_verify(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_post_db(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed post db handling\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_post_verify(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n\t\t\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_post.c",
        "crashing_line": "\trc = cil_pre_verify(db);",
        "crashing_line_number": 2531
      },
      {
        "function_name": "cil_compile",
        "function_body": "int cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil.c",
        "crashing_line": "\trc = cil_post_process(db);",
        "crashing_line_number": 564
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\nxmlAddIDSafe(xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr,\n             int streaming, xmlIDPtr *id) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (id != NULL)\n        *id = NULL;\n\n    if (doc == NULL) {\n\treturn(-1);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(0);\n    }\n    if (attr == NULL) {\n\treturn(-1);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n        if (table == NULL)\n            return(-1);\n    } else {\n        ret = xmlHashLookup(table, value);\n        if (ret != NULL) {\n            /*\n             * Update the attribute to make entities work.\n             */\n            if (ret->attr != NULL) {\n                ret->attr->id = NULL;\n                ret->attr = attr;\n            }\n\t    attr->atype = XML_ATTRIBUTE_ID;\n            attr->id = ret;\n            return(0);\n        }\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL)\n\treturn(-1);\n    memset(ret, 0, sizeof(*ret));\n\n    /*\n     * fill the structure.\n     */\n    ret->doc = doc;\n    ret->value = xmlStrdup(value);\n    if (ret->value == NULL) {\n        xmlFreeID(ret);\n        return(-1);\n    }\n    if (streaming) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n        if (ret->name == NULL) {\n            xmlFreeID(ret);\n            return(-1);\n        }\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n\txmlFreeID(ret);\n\treturn(-1);\n    }\n\n    attr->atype = XML_ATTRIBUTE_ID;\n    if (!streaming)\n        attr->id = ret;\n\n    if (id != NULL)\n        *id = ret;\n    return(1);\n}\n",
    "target": 1,
    "idx": 1066502,
    "stack_trace": [
      {
        "function_name": "xmlRemoveID",
        "function_body": "int\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n\n    if (doc == NULL) return(-1);\n    if ((attr == NULL) || (attr->id == NULL)) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)\n        return(-1);\n\n    attr->atype = 0;\n    attr->id = NULL;\n\n    return(0);\n}",
        "file_path": "/src/libxml2/valid.c",
        "crashing_line": "        return(-1);",
        "crashing_line_number": 2521
      },
      {
        "function_name": "xmlFreeProp",
        "function_body": "void\nxmlFreeProp(xmlAttrPtr cur) {\n    xmlDictPtr dict = NULL;\n    if (cur == NULL) return;\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {\n\t    xmlRemoveID(cur->doc, cur);\n    }\n    if (cur->children != NULL) xmlFreeNodeList(cur->children);\n    DICT_FREE(cur->name)\n    xmlFree(cur);\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "\t    xmlRemoveID(cur->doc, cur);",
        "crashing_line_number": 2080
      },
      {
        "function_name": "xmlFreePropList",
        "function_body": "void\nxmlFreePropList(xmlAttrPtr cur) {\n    xmlAttrPtr next;\n    if (cur == NULL) return;\n    while (cur != NULL) {\n        next = cur->next;\n        xmlFreeProp(cur);\n\tcur = next;\n    }\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "        xmlFreeProp(cur);",
        "crashing_line_number": 2057
      },
      {
        "function_name": "xmlFreeNodeList",
        "function_body": "void\nxmlFreeNodeList(xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if (cur->doc != NULL) dict = cur->doc->dict;\n    while (1) {\n        while ((cur->children != NULL) &&\n               (cur->type != XML_DOCUMENT_NODE) &&\n               (cur->type != XML_HTML_DOCUMENT_NODE) &&\n               (cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\tif ((cur->type == XML_DOCUMENT_NODE) ||\n            (cur->type == XML_HTML_DOCUMENT_NODE)) {\n            xmlFreeDoc((xmlDocPtr) cur);\n        } else if (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlFreePropList(cur->properties);\n\t    if ((cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE) &&\n\t\t(cur->content != (xmlChar *) &(cur->properties))) {\n\t\tDICT_FREE(cur->content)\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * When a node is a text node or a comment, it uses a global static\n\t     * variable for the name of the node.\n\t     * Otherwise the node name might come from the document's\n\t     * dictionary\n\t     */\n\t    if ((cur->name != NULL) &&\n\t\t(cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name)\n\t    xmlFree(cur);\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "\t\txmlFreePropList(cur->properties);",
        "crashing_line_number": 3681
      },
      {
        "function_name": "xmlFreeNode",
        "function_body": "void\nxmlFreeNode(xmlNodePtr cur) {\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return;\n\n    /* use xmlFreeDtd for DTD nodes */\n    if (cur->type == XML_DTD_NODE) {\n\txmlFreeDtd((xmlDtdPtr) cur);\n\treturn;\n    }\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNs((xmlNsPtr) cur);\n        return;\n    }\n    if (cur->type == XML_ATTRIBUTE_NODE) {\n\txmlFreeProp((xmlAttrPtr) cur);\n\treturn;\n    }\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue(cur);\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if (cur->type == XML_ENTITY_DECL) {\n        xmlEntityPtr ent = (xmlEntityPtr) cur;\n\tDICT_FREE(ent->SystemID);\n\tDICT_FREE(ent->ExternalID);\n    }\n    if ((cur->children != NULL) &&\n\t(cur->type != XML_ENTITY_REF_NODE))\n\txmlFreeNodeList(cur->children);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n        (cur->type == XML_XINCLUDE_START) ||\n        (cur->type == XML_XINCLUDE_END)) {\n        if (cur->properties != NULL)\n            xmlFreePropList(cur->properties);\n        if (cur->nsDef != NULL)\n            xmlFreeNsList(cur->nsDef);\n    } else if ((cur->content != NULL) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->content != (xmlChar *) &(cur->properties))) {\n        DICT_FREE(cur->content)\n    }\n\n    /*\n     * When a node is a text node or a comment, it uses a global static\n     * variable for the name of the node.\n     * Otherwise the node name might come from the document's dictionary\n     */\n    if ((cur->name != NULL) &&\n        (cur->type != XML_TEXT_NODE) &&\n        (cur->type != XML_COMMENT_NODE))\n\tDICT_FREE(cur->name)\n\n    xmlFree(cur);\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "\txmlFreeNodeList(cur->children);",
        "crashing_line_number": 3759
      },
      {
        "function_name": "xmlCtxtParseContent",
        "function_body": "static xmlNodePtr\nxmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n                    int hasTextDecl, int buildTree) {\n    xmlNodePtr root = NULL;\n    xmlNodePtr list = NULL;\n    xmlChar *rootName = BAD_CAST \"#root\";\n    int result;\n\n    if (buildTree) {\n        root = xmlNewDocNode(ctxt->myDoc, NULL, rootName, NULL);\n        if (root == NULL) {\n            xmlErrMemory(ctxt);\n            goto error;\n        }\n    }\n\n    if (xmlPushInput(ctxt, input) < 0)\n        goto error;\n\n    nameNsPush(ctxt, rootName, NULL, NULL, 0, 0);\n    spacePush(ctxt, -1);\n\n    if (buildTree)\n        nodePush(ctxt, root);\n\n    if (hasTextDecl) {\n        xmlDetectEncoding(ctxt);\n\n        /*\n         * Parse a possible text declaration first\n         */\n        if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n            (IS_BLANK_CH(NXT(5)))) {\n            xmlParseTextDecl(ctxt);\n            /*\n             * An XML-1.0 document can't reference an entity not XML-1.0\n             */\n            if ((xmlStrEqual(ctxt->version, BAD_CAST \"1.0\")) &&\n                (!xmlStrEqual(ctxt->input->version, BAD_CAST \"1.0\"))) {\n                xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,\n                               \"Version mismatch between document and \"\n                               \"entity\\n\");\n            }\n        }\n    }\n\n    xmlParseContentInternal(ctxt);\n\n    if (ctxt->input->cur < ctxt->input->end)\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n\n    if ((ctxt->wellFormed) ||\n        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n        if (root != NULL) {\n            xmlNodePtr cur;\n\n            /*\n             * Return the newly created nodeset after unlinking it from\n             * its pseudo parent.\n             */\n            cur = root->children;\n            list = cur;\n            while (cur != NULL) {\n                cur->parent = NULL;\n                cur = cur->next;\n            }\n            root->children = NULL;\n            root->last = NULL;\n        }\n    }\n\n    /*\n     * Read the rest of the stream in case of errors. We want\n     * to account for the whole entity size.\n     */\n    do {\n        ctxt->input->cur = ctxt->input->end;\n        xmlParserShrink(ctxt);\n        result = xmlParserGrow(ctxt);\n    } while (result > 0);\n\n    if (buildTree)\n        nodePop(ctxt);\n\n    namePop(ctxt);\n    spacePop(ctxt);\n\n    /* xmlPopInput would free the stream */\n    inputPop(ctxt);\n\nerror:\n    xmlFreeNode(root);\n\n    return(list);\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "    xmlFreeNode(root);",
        "crashing_line_number": 12076
      },
      {
        "function_name": "xmlCtxtParseEntity",
        "function_body": "static void\nxmlCtxtParseEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {\n    xmlParserInputPtr input;\n    xmlNodePtr list;\n    unsigned long consumed;\n    int isExternal;\n    int buildTree;\n    int oldMinNsIndex;\n    int oldNodelen, oldNodemem;\n\n    isExternal = (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY);\n    buildTree = (ctxt->node != NULL);\n\n    /*\n     * Recursion check\n     */\n    if (ent->flags & XML_ENT_EXPANDING) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        xmlHaltParser(ctxt);\n        goto error;\n    }\n\n    /*\n     * Load entity\n     */\n    input = xmlNewEntityInputStream(ctxt, ent);\n    if (input == NULL)\n        goto error;\n\n    /*\n     * When building a tree, we need to limit the scope of namespace\n     * declarations, so that entities don't reference xmlNs structs\n     * from the parent of a reference.\n     */\n    oldMinNsIndex = ctxt->nsdb->minNsIndex;\n    if (buildTree)\n        ctxt->nsdb->minNsIndex = ctxt->nsNr;\n\n    oldNodelen = ctxt->nodelen;\n    oldNodemem = ctxt->nodemem;\n    ctxt->nodelen = 0;\n    ctxt->nodemem = 0;\n\n    /*\n     * Parse content\n     *\n     * This initiates a recursive call chain:\n     *\n     * - xmlCtxtParseContent\n     * - xmlParseContentInternal\n     * - xmlParseReference\n     * - xmlCtxtParseEntity\n     *\n     * The nesting depth is limited by the maximum number of inputs,\n     * see xmlPushInput.\n     *\n     * It's possible to make this non-recursive (minNsIndex must be\n     * stored in the input struct) at the expense of code readability.\n     */\n\n    ent->flags |= XML_ENT_EXPANDING;\n\n    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);\n\n    ent->flags &= ~XML_ENT_EXPANDING;\n\n    ctxt->nsdb->minNsIndex = oldMinNsIndex;\n    ctxt->nodelen = oldNodelen;\n    ctxt->nodemem = oldNodemem;\n\n    /*\n     * Entity size accounting\n     */\n    consumed = input->consumed;\n    xmlSaturatedAddSizeT(&consumed, input->end - input->base);\n\n    if ((ent->flags & XML_ENT_CHECKED) == 0)\n        xmlSaturatedAdd(&ent->expandedSize, consumed);\n\n    if ((ent->flags & XML_ENT_PARSED) == 0) {\n        if (isExternal)\n            xmlSaturatedAdd(&ctxt->sizeentities, consumed);\n\n        ent->children = list;\n\n        while (list != NULL) {\n            list->parent = (xmlNodePtr) ent;\n            if (list->next == NULL)\n                ent->last = list;\n            list = list->next;\n        }\n    } else {\n        xmlFreeNodeList(list);\n    }\n\n    xmlFreeInputStream(input);\n\nerror:\n    ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);",
        "crashing_line_number": 12143
      },
      {
        "function_name": "xmlParseTryOrFinish",
        "function_body": "",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "",
        "crashing_line_number": 11290
      },
      {
        "function_name": "xmlParseChunk",
        "function_body": "int\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    size_t curBase;\n    size_t maxLength;\n    int end_in_lf = 0;\n\n    if ((ctxt == NULL) || (size < 0))\n        return(XML_ERR_ARGUMENT);\n    if (ctxt->disableSAX != 0)\n        return(ctxt->errNo);\n    if (ctxt->input == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt->input->flags |= XML_INPUT_PROGRESSIVE;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlCtxtInitializeLate(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n\n    curBase = ctxt->input->cur - ctxt->input->base;\n    maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                XML_MAX_HUGE_LENGTH :\n                XML_MAX_LOOKUP_LIMIT;\n    if (curBase > maxLength) {\n        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n                    \"Buffer size limit exceeded, try XML_PARSE_HUGE\\n\");\n        xmlHaltParser(ctxt);\n    }\n\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n            ctxt->instate = XML_PARSER_EOF;\n            xmlFinishDocument(ctxt);\n\t}\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "    xmlParseTryOrFinish(ctxt, terminate);",
        "crashing_line_number": 11587
      },
      {
        "function_name": "xmlTextReaderPushData",
        "function_body": "static int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlCtxtErrIO(reader->ctxt, reader->input->error, NULL);\n                    reader->mode = XML_TEXTREADER_MODE_ERROR;\n                    reader->state = XML_TEXTREADER_ERROR;\n                    return(-1);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}",
        "file_path": "/src/libxml2/xmlreader.c",
        "crashing_line": "\t    val = xmlParseChunk(reader->ctxt,",
        "crashing_line_number": 769
      },
      {
        "function_name": "xmlTextReaderRead",
        "function_body": "int\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}",
        "file_path": "/src/libxml2/xmlreader.c",
        "crashing_line": "\t    val = xmlTextReaderPushData(reader);",
        "crashing_line_number": 1228
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\tif (acl == NULL) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t}\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n",
    "target": 1,
    "idx": 1028843,
    "stack_trace": [
      {
        "function_name": "sc_file_valid",
        "function_body": "int sc_file_valid(const sc_file_t *file) {\n\tif (file == NULL)\n\t\treturn 0;\n\treturn file->magic == SC_FILE_MAGIC;\n}",
        "file_path": "/src/opensc/src/libopensc/sc.c",
        "crashing_line": "\treturn file->magic == SC_FILE_MAGIC;",
        "crashing_line_number": 810
      },
      {
        "function_name": "sc_file_free",
        "function_body": "void sc_file_free(sc_file_t *file)\n{\n\tunsigned int i;\n\tif (file == NULL || !sc_file_valid(file))\n\t\treturn;\n\tfile->magic = 0;\n\tfor (i = 0; i < SC_MAX_AC_OPS; i++)\n\t\tsc_file_clear_acl_entries(file, i);\n\tif (file->sec_attr)\n\t\tfree(file->sec_attr);\n\tif (file->prop_attr)\n\t\tfree(file->prop_attr);\n\tif (file->type_attr)\n\t\tfree(file->type_attr);\n\tif (file->encoded_content)\n\t\tfree(file->encoded_content);\n\tfree(file);\n}",
        "file_path": "/src/opensc/src/libopensc/sc.c",
        "crashing_line": "\tif (file == NULL || !sc_file_valid(file))",
        "crashing_line_number": 619
      },
      {
        "function_name": "sc_oberthur_read_file",
        "function_body": "static int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii, nobjs;\n\n\t\tif (acl == NULL) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\n\t\tnobjs = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (nobjs < 1) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_DATA_OBJECT_NOT_FOUND,\n\t\t\t\t\"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii = 0; ii < nobjs; ii++) {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t}\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}",
        "file_path": "/src/opensc/src/libopensc/pkcs15-oberthur.c",
        "crashing_line": "",
        "crashing_line_number": 344
      },
      {
        "function_name": "sc_pkcs15emu_oberthur_init",
        "function_body": "static int\nsc_pkcs15emu_oberthur_init(struct sc_pkcs15_card * p15card)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_auth_info auth_info;\n\tstruct sc_pkcs15_object   obj;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_path path;\n\tint rv, ii, tries_left;\n\tchar serial[0x10];\n\tunsigned char sopin_reference = 0x04;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_bin_to_hex(card->serialnr.value, card->serialnr.len, serial, sizeof(serial), 0);\n\tset_string(&p15card->tokeninfo->serial_number, serial);\n\n\tp15card->ops.parse_df = sc_awp_parse_df;\n\tp15card->ops.clear = sc_awp_clear;\n\n\tsc_log(ctx, \"Oberthur init: serial %s\", p15card->tokeninfo->serial_number);\n\n\tsc_format_path(AWP_PIN_DF, &path);\n\trv = sc_select_file(card, &path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot select PIN dir\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tsopin_reference = 0x84;\n\t\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\t}\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)\n\t\tLOG_TEST_RET(ctx, rv, \"Invalid state of SO-PIN\");\n\n\t/* add PIN */\n\tmemset(&auth_info, 0, sizeof(auth_info));\n\tmemset(&obj,  0, sizeof(obj));\n\n\tauth_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tauth_info.auth_method\t= SC_AC_CHV;\n\tauth_info.auth_id.len = 1;\n\tauth_info.auth_id.value[0] = 0xFF;\n\tauth_info.attrs.pin.min_length\t\t= 4;\n\tauth_info.attrs.pin.max_length\t\t= 64;\n\tauth_info.attrs.pin.stored_length\t= 64;\n\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tauth_info.attrs.pin.reference\t\t= sopin_reference;\n\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t| SC_PKCS15_PIN_FLAG_SO_PIN;\n\tauth_info.tries_left\t\t= tries_left;\n\tauth_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tstrncpy(obj.label, \"SO PIN\", SC_PKCS15_MAX_LABEL_SIZE-1);\n\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, 0x81, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv == SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\t/* add PIN */\n\t\tmemset(&auth_info, 0, sizeof(auth_info));\n\t\tmemset(&obj,  0, sizeof(obj));\n\n\t\tauth_info.auth_id.len = sizeof(PinDomainID) > sizeof(auth_info.auth_id.value)\n\t\t\t\t? sizeof(auth_info.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(auth_info.auth_id.value, PinDomainID, auth_info.auth_id.len);\n\t\tauth_info.auth_method\t= SC_AC_CHV;\n\n\t\tauth_info.attrs.pin.min_length\t\t= 4;\n\t\tauth_info.attrs.pin.max_length\t\t= 64;\n\t\tauth_info.attrs.pin.stored_length\t= 64;\n\t\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tauth_info.attrs.pin.reference\t\t= 0x81;\n\t\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\t\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_LOCAL;\n\t\tauth_info.tries_left\t\t= tries_left;\n\n\t\tstrncpy(obj.label, PIN_DOMAIN_LABEL, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\t\tif (sopin_reference == 0x84) {\n\t\t\t/*\n\t\t\t * auth_pin_reset_oberthur_style() in card-oberthur.c\n\t\t\t * always uses PUK with reference 0x84 for\n\t\t\t * unblocking of User PIN\n\t\t\t */\n\t\t\tobj.auth_id.len = 1;\n\t\t\tobj.auth_id.value[0] = 0xFF;\n\t\t}\n\n\t\tsc_format_path(AWP_PIN_DF, &auth_info.path);\n\t\tauth_info.path.type = SC_PATH_TYPE_PATH;\n\n\t\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\t\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\t}\n\telse if (rv != SC_ERROR_DATA_OBJECT_NOT_FOUND)    {\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot verify PIN\");\n\t}\n\n\tfor (ii=0; oberthur_infos[ii].name; ii++)   {\n\t\tsc_log(ctx, \"Oberthur init: read %s file\", oberthur_infos[ii].name);\n\t\tfree(oberthur_infos[ii].content);\n\t\trv = sc_oberthur_read_file(p15card, oberthur_infos[ii].path,\n\t\t\t\t&oberthur_infos[ii].content, &oberthur_infos[ii].len, 1);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: read oberthur file error\");\n\n\t\tsc_log(ctx,\n\t\t       \"Oberthur init: parse %s file, content length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       oberthur_infos[ii].name, oberthur_infos[ii].len);\n\t\trv = oberthur_infos[ii].parser(p15card, oberthur_infos[ii].content, oberthur_infos[ii].len,\n\t\t\t\toberthur_infos[ii].postpone_allowed);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: parse error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}",
        "file_path": "/src/opensc/src/libopensc/pkcs15-oberthur.c",
        "crashing_line": "\t\tfree(oberthur_infos[ii].content);",
        "crashing_line_number": 1043
      },
      {
        "function_name": "sc_pkcs15emu_oberthur_init_ex",
        "function_body": "int\nsc_pkcs15emu_oberthur_init_ex(struct sc_pkcs15_card * p15card, struct sc_aid *aid)\n{\n\tint rv;\n\n\tLOG_FUNC_CALLED(p15card->card->ctx);\n\trv = oberthur_detect_card(p15card);\n\tif (!rv)\n\t\trv = sc_pkcs15emu_oberthur_init(p15card);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}",
        "file_path": "/src/opensc/src/libopensc/pkcs15-oberthur.c",
        "crashing_line": "\tif (!rv)",
        "crashing_line_number": 1079
      },
      {
        "function_name": "sc_pkcs15_bind_synthetic",
        "function_body": "int\nsc_pkcs15_bind_synthetic(sc_pkcs15_card_t *p15card, struct sc_aid *aid)\n{\n\tsc_context_t\t\t*ctx = p15card->card->ctx;\n\tscconf_block\t\t*conf_block, **blocks, *blk;\n\tint\t\t\ti, r = SC_ERROR_WRONG_CARD;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tconf_block = NULL;\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\n\tif (!conf_block) {\n\t\t/* no conf file found => try builtin drivers  */\n\t\tsc_log(ctx, \"no conf file (or section), trying all builtin emulators\");\n\t\tfor (i = 0; builtin_emulators[i].name; i++) {\n\t\t\tsc_log(ctx, \"trying %s\", builtin_emulators[i].name);\n\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t/* we got a hit */\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* we have a conf file => let's use it */\n\t\tint builtin_enabled;\n\t\tconst scconf_list *list, *item;\n\n\t\tbuiltin_enabled = scconf_get_bool(conf_block, \"enable_builtin_emulation\", 1);\n\t\tlist = scconf_find_list(conf_block, \"builtin_emulators\"); /* FIXME: rename to enabled_emulators */\n\n\t\tif (builtin_enabled && list) {\n\t\t\t/* get the list of enabled emulation drivers */\n\t\t\tfor (item = list; item; item = item->next) {\n\t\t\t\t/* go through the list of builtin drivers */\n\t\t\t\tconst char *name = item->data;\n\n\t\t\t\tsc_log(ctx, \"trying %s\", name);\n\t\t\t\tfor (i = 0; builtin_emulators[i].name; i++)\n\t\t\t\t\tif (!strcmp(builtin_emulators[i].name, name)) {\n\t\t\t\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\t\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t\t\t\t/* we got a hit */\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (builtin_enabled) {\n\t\t\tsc_log(ctx, \"no emulator list in config file, trying all builtin emulators\");\n\t\t\tfor (i = 0; builtin_emulators[i].name; i++) {\n\t\t\t\tsc_log(ctx, \"trying %s\", builtin_emulators[i].name);\n\t\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t\t/* we got a hit */\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* search for 'emulate foo { ... }' entries in the conf file */\n\t\tsc_log(ctx, \"searching for 'emulate foo { ... }' blocks\");\n\t\tblocks = scconf_find_blocks(ctx->conf, conf_block, \"emulate\", NULL);\n\t\tsc_log(ctx, \"Blocks: %p\", blocks);\n\t\tfor (i = 0; blocks && (blk = blocks[i]) != NULL; i++) {\n\t\t\tconst char *name = blk->name->data;\n\t\t\tsc_log(ctx, \"trying %s\", name);\n\t\t\tr = parse_emu_block(p15card, aid, blk);\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tfree(blocks);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (blocks)\n\t\t\tfree(blocks);\n\t}\n\nout:\n\tif (r == SC_SUCCESS) {\n\t\tp15card->magic  = SC_PKCS15_CARD_MAGIC;\n\t\tp15card->flags |= SC_PKCS15_CARD_FLAG_EMULATED;\n\t} else {\n\t\tif (r != SC_ERROR_WRONG_CARD)\n\t\t\tsc_log(ctx, \"Failed to load card emulator: %s\", sc_strerror(r));\n\t}\n\n\tLOG_FUNC_RETURN(ctx, r);\n}",
        "file_path": "/src/opensc/src/libopensc/pkcs15-syn.c",
        "crashing_line": "\t\t\tr = builtin_emulators[i].handler(p15card, aid);",
        "crashing_line_number": 125
      },
      {
        "function_name": "sc_pkcs15_bind",
        "function_body": "int\nsc_pkcs15_bind(struct sc_card *card, struct sc_aid *aid,\n\t\tstruct sc_pkcs15_card **p15card_out)\n{\n\tstruct sc_pkcs15_card *p15card = NULL;\n\tstruct sc_context *ctx;\n\tscconf_block *conf_block = NULL;\n\tint r, emu_first, enable_emu;\n\tconst char *private_certificate;\n\n\tif (card == NULL || p15card_out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tctx = card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"application(aid:'%s')\", aid ? sc_dump_hex(aid->value, aid->len) : \"empty\");\n\n\tp15card = sc_pkcs15_card_new();\n\tif (p15card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tp15card->card = card;\n\tp15card->opts.use_file_cache = 0;\n\tp15card->opts.use_pin_cache = 1;\n\tp15card->opts.pin_cache_counter = 10;\n\tp15card->opts.pin_cache_ignore_user_consent = 0;\n\tif(0 == strcmp(ctx->app_name, \"tokend\")) {\n\t\tprivate_certificate = \"ignore\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else {\n\t\tprivate_certificate = \"protect\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t}\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\tif (conf_block) {\n\t\tp15card->opts.use_file_cache = scconf_get_bool(conf_block, \"use_file_caching\", p15card->opts.use_file_cache);\n\t\tp15card->opts.use_pin_cache = scconf_get_bool(conf_block, \"use_pin_caching\", p15card->opts.use_pin_cache);\n\t\tp15card->opts.pin_cache_counter = scconf_get_int(conf_block, \"pin_cache_counter\", p15card->opts.pin_cache_counter);\n\t\tp15card->opts.pin_cache_ignore_user_consent = scconf_get_bool(conf_block, \"pin_cache_ignore_user_consent\",\n\t\t\t\tp15card->opts.pin_cache_ignore_user_consent);\n\t\tprivate_certificate = scconf_get_str(conf_block, \"private_certificate\", private_certificate);\n\t}\n\tif (0 == strcmp(private_certificate, \"protect\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t} else if (0 == strcmp(private_certificate, \"ignore\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else if (0 == strcmp(private_certificate, \"declassify\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_DECLASSIFY;\n\t}\n\tsc_log(ctx, \"PKCS#15 options: use_file_cache=%d use_pin_cache=%d pin_cache_counter=%d pin_cache_ignore_user_consent=%d private_certificate=%d\",\n\t\t\tp15card->opts.use_file_cache, p15card->opts.use_pin_cache,p15card->opts.pin_cache_counter,\n\t\t\tp15card->opts.pin_cache_ignore_user_consent, p15card->opts.private_certificate);\n\n\tr = sc_lock(card);\n\tif (r) {\n\t\tsc_log(ctx, \"sc_lock() failed: %s\", sc_strerror(r));\n\t\tsc_pkcs15_card_free(p15card);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tenable_emu = scconf_get_bool(conf_block, \"enable_pkcs15_emulation\", 1);\n\tif (enable_emu) {\n\t\tsc_log(ctx, \"PKCS#15 emulation enabled\");\n\t\temu_first = scconf_get_bool(conf_block, \"try_emulation_first\", 0);\n\t\tif (emu_first || sc_pkcs15_is_emulation_only(card)) {\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\telse {\n\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t}\ndone:\n\t*p15card_out = p15card;\n\tsc_unlock(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerror:\n\tsc_unlock(card);\n\tsc_pkcs15_card_free(p15card);\n\tLOG_FUNC_RETURN(ctx, r);\n}",
        "file_path": "/src/opensc/src/libopensc/pkcs15.c",
        "crashing_line": "\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);",
        "crashing_line_number": 1288
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "%  CloseBlob() closes a stream associated with the image.\n%\n%  The format of the CloseBlob method is:\n%\n%      MagickBooleanType CloseBlob(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType CloseBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    status;\n\n  /*\n    Close image file.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  blob_info=image->blob;\n  if (blob_info->type == UndefinedStream)\n    return(MagickTrue);\n  status=SyncBlob(image);\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      if (blob_info->synchronize != MagickFalse)\n        status=fsync(fileno(blob_info->file_info.file));\n      status=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&status);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&status);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      if (blob_info->file_info.file != (FILE *) NULL)\n        {\n          if (blob_info->synchronize != MagickFalse)\n            status=fsync(fileno(blob_info->file_info.file));\n          status=ferror(blob_info->file_info.file);\n        }\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  blob_info->status=status < 0 ? MagickTrue : MagickFalse;\n  blob_info->size=GetBlobSize(image);\n  image->extent=blob_info->size;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->mode=UndefinedBlobMode;\n  if (blob_info->exempt != MagickFalse)\n    {\n      blob_info->type=UndefinedStream;\n      return(blob_info->status);\n    }\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    {\n      status=fclose(blob_info->file_info.file);\n      break;\n    }\n    case PipeStream:\n    {\n#if defined(MAGICKCORE_HAVE_PCLOSE)\n      status=pclose(blob_info->file_info.file);\n#endif\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      status=gzclose(blob_info->file_info.gzfile);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      BZ2_bzclose(blob_info->file_info.bzfile);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n",
    "target": 1,
    "idx": 1008287,
    "stack_trace": [
      {
        "function_name": "CloseBlob",
        "function_body": "%  CloseBlob() closes a stream associated with the image.\n%\n%  The format of the CloseBlob method is:\n%\n%      MagickBooleanType CloseBlob(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType CloseBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    status;\n\n  /*\n    Close image file.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  blob_info=image->blob;\n  if ((blob_info == (BlobInfo *) NULL) || (blob_info->type == UndefinedStream))\n    return(MagickTrue);\n  status=SyncBlob(image);\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      if (blob_info->synchronize != MagickFalse)\n        status=fsync(fileno(blob_info->file_info.file));\n      status=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&status);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&status);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      if (blob_info->file_info.file != (FILE *) NULL)\n        {\n          if (blob_info->synchronize != MagickFalse)\n            status=fsync(fileno(blob_info->file_info.file));\n          status=ferror(blob_info->file_info.file);\n        }\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  blob_info->status=status < 0 ? MagickTrue : MagickFalse;\n  blob_info->size=GetBlobSize(image);\n  image->extent=blob_info->size;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->mode=UndefinedBlobMode;\n  if (blob_info->exempt != MagickFalse)\n    {\n      blob_info->type=UndefinedStream;\n      return(blob_info->status);\n    }\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    {\n      status=fclose(blob_info->file_info.file);\n      break;\n    }\n    case PipeStream:\n    {\n#if defined(MAGICKCORE_HAVE_PCLOSE)\n      status=pclose(blob_info->file_info.file);\n#endif\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      status=gzclose(blob_info->file_info.gzfile);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      BZ2_bzclose(blob_info->file_info.bzfile);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {",
        "file_path": "/src/imagemagick/MagickCore/blob.c",
        "crashing_line": "{",
        "crashing_line_number": 609
      },
      {
        "function_name": "ReadMATImage",
        "function_body": "",
        "file_path": "/src/imagemagick/coders/mat.c",
        "crashing_line": "",
        "crashing_line_number": 1095
      },
      {
        "function_name": "ReadImage",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/constitute.c",
        "crashing_line": "",
        "crashing_line_number": 500
      },
      {
        "function_name": "ReadStream",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/stream.c",
        "crashing_line": "",
        "crashing_line_number": 1043
      },
      {
        "function_name": "PingBlob",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/blob.c",
        "crashing_line": "",
        "crashing_line_number": 3601
      },
      {
        "function_name": "ping",
        "function_body": "void Magick::Image::ping(const Blob& blob_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=PingBlob(imageInfo(),blob_.data(),blob_.length(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}",
        "file_path": "/src/imagemagick/Magick++/lib/Image.cpp",
        "crashing_line": "  newImage=PingBlob(imageInfo(),blob_.data(),blob_.length(),exceptionInfo);",
        "crashing_line_number": 3861
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey)\n{\n#ifndef OPENSSL_NO_DH\n    PACKET prime, generator, pub_key;\n    EVP_PKEY *peer_tmp = NULL;\n\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;\n\n    int check_bits = 0;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    peer_tmp = EVP_PKEY_new();\n    dh = DH_new();\n\n    if (peer_tmp == NULL || dh == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* TODO(size_t): Convert these calls */\n    p = BN_bin2bn(PACKET_data(&prime), (int)PACKET_remaining(&prime), NULL);\n    g = BN_bin2bn(PACKET_data(&generator), (int)PACKET_remaining(&generator),\n                  NULL);\n    bnpub_key = BN_bin2bn(PACKET_data(&pub_key),\n                          (int)PACKET_remaining(&pub_key), NULL);\n    if (p == NULL || g == NULL || bnpub_key == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* test non-zero pubkey */\n    if (BN_is_zero(bnpub_key)) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_pqg(dh, p, NULL, g)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    p = g = NULL;\n\n    if (DH_check_params(dh, &check_bits) == 0 || check_bits != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_key(dh, bnpub_key, NULL)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    bnpub_key = NULL;\n\n    if (EVP_PKEY_assign_DH(peer_tmp, dh) == 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    if (!ssl_security(s, SSL_SECOP_TMP_DH, EVP_PKEY_security_bits(peer_tmp),\n                      0, dh)) {\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_DH_KEY_TOO_SMALL);\n        goto err;\n    }\n\n    s->s3.peer_tmp = peer_tmp;\n\n    /*\n     * FIXME: This makes assumptions about which ciphersuites come with\n     * public keys. We should have a less ad-hoc way of doing this\n     */\n    if (s->s3.tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous DH, so no certificate or pkey. */\n\n    return 1;\n\n err:\n    BN_free(p);\n    BN_free(g);\n    BN_free(bnpub_key);\n    DH_free(dh);\n    EVP_PKEY_free(peer_tmp);\n\n    return 0;\n#else\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n             ERR_R_INTERNAL_ERROR);\n    return 0;\n#endif\n}\n",
    "target": 1,
    "idx": 1020816,
    "stack_trace": [
      {
        "function_name": "CRYPTO_DOWN_REF",
        "function_body": "static __inline int CRYPTO_DOWN_REF(volatile int *val, int *ret, void *lock)\n{\n    *ret = _InterlockedExchangeAdd(val, -1) - 1;\n    return 1;\n}",
        "file_path": "/src/openssl/include/internal/refcount.h",
        "crashing_line": "",
        "crashing_line_number": 51
      },
      {
        "function_name": "DH_free",
        "function_body": "void DH_free(DH *r)\n{\n    int i;\n\n    if (r == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(&r->references, &i, r->lock);\n    REF_PRINT_COUNT(\"DH\", r);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n\n    if (r->meth != NULL && r->meth->finish != NULL)\n        r->meth->finish(r);\n#if !defined(FIPS_MODE)\n# if !defined(OPENSSL_NO_ENGINE)\n    ENGINE_finish(r->engine);\n# endif\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DH, r, &r->ex_data);\n#endif\n\n    CRYPTO_THREAD_lock_free(r->lock);\n\n    ffc_params_cleanup(&r->params);\n    BN_clear_free(r->pub_key);\n    BN_clear_free(r->priv_key);\n    OPENSSL_free(r);\n}",
        "file_path": "/src/openssl/crypto/dh/dh_lib.c",
        "crashing_line": "    CRYPTO_DOWN_REF(&r->references, &i, r->lock);",
        "crashing_line_number": 133
      },
      {
        "function_name": "evp_pkey_free_legacy",
        "function_body": "void evp_pkey_free_legacy(EVP_PKEY *x)\n{\n    if (x->ameth != NULL) {\n        if (x->ameth->pkey_free != NULL)\n            x->ameth->pkey_free(x);\n        x->pkey.ptr = NULL;\n    }\n# ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(x->engine);\n    x->engine = NULL;\n    ENGINE_finish(x->pmeth_engine);\n    x->pmeth_engine = NULL;\n# endif\n    x->type = EVP_PKEY_NONE;\n}",
        "file_path": "/src/openssl/crypto/evp/p_lib.c",
        "crashing_line": "            x->ameth->pkey_free(x);",
        "crashing_line_number": 1168
      },
      {
        "function_name": "evp_pkey_free_it",
        "function_body": "static void evp_pkey_free_it(EVP_PKEY *x)\n{\n    /* internal function; x is never NULL */\n\n    evp_keymgmt_util_clear_operation_cache(x);\n#ifndef FIPS_MODE\n    evp_pkey_free_legacy(x);\n#endif\n\n    if (x->keymgmt != NULL) {\n        evp_keymgmt_freedata(x->keymgmt, x->keydata);\n        EVP_KEYMGMT_free(x->keymgmt);\n        x->keymgmt = NULL;\n        x->keydata = NULL;\n    }\n}",
        "file_path": "/src/openssl/crypto/evp/p_lib.c",
        "crashing_line": "    evp_pkey_free_legacy(x);",
        "crashing_line_number": 1187
      },
      {
        "function_name": "EVP_PKEY_free",
        "function_body": "void EVP_PKEY_free(EVP_PKEY *x)\n{\n    int i;\n\n    if (x == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(&x->references, &i, x->lock);\n    REF_PRINT_COUNT(\"EVP_PKEY\", x);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n    evp_pkey_free_it(x);\n    CRYPTO_THREAD_lock_free(x->lock);\n#ifndef FIPS_MODE\n    sk_X509_ATTRIBUTE_pop_free(x->attributes, X509_ATTRIBUTE_free);\n#endif\n    OPENSSL_free(x);\n}",
        "file_path": "/src/openssl/crypto/evp/p_lib.c",
        "crashing_line": "    evp_pkey_free_it(x);",
        "crashing_line_number": 1210
      },
      {
        "function_name": "tls_process_ske_dhe",
        "function_body": "static int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey)\n{\n#ifndef OPENSSL_NO_DH\n    PACKET prime, generator, pub_key;\n    EVP_PKEY *peer_tmp = NULL;\n\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;\n\n    int check_bits = 0;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    peer_tmp = EVP_PKEY_new();\n    dh = DH_new();\n\n    if (peer_tmp == NULL || dh == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* TODO(size_t): Convert these calls */\n    p = BN_bin2bn(PACKET_data(&prime), (int)PACKET_remaining(&prime), NULL);\n    g = BN_bin2bn(PACKET_data(&generator), (int)PACKET_remaining(&generator),\n                  NULL);\n    bnpub_key = BN_bin2bn(PACKET_data(&pub_key),\n                          (int)PACKET_remaining(&pub_key), NULL);\n    if (p == NULL || g == NULL || bnpub_key == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* test non-zero pubkey */\n    if (BN_is_zero(bnpub_key)) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_pqg(dh, p, NULL, g)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    p = g = NULL;\n\n    if (DH_check_params(dh, &check_bits) == 0 || check_bits != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_key(dh, bnpub_key, NULL)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    bnpub_key = NULL;\n\n    if (EVP_PKEY_assign_DH(peer_tmp, dh) == 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n    dh = NULL;\n\n    if (!ssl_security(s, SSL_SECOP_TMP_DH, EVP_PKEY_security_bits(peer_tmp),\n                      0, EVP_PKEY_get0_DH(peer_tmp))) {\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_DH_KEY_TOO_SMALL);\n        goto err;\n    }\n\n    s->s3.peer_tmp = peer_tmp;\n\n    /*\n     * FIXME: This makes assumptions about which ciphersuites come with\n     * public keys. We should have a less ad-hoc way of doing this\n     */\n    if (s->s3.tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous DH, so no certificate or pkey. */\n\n    return 1;\n\n err:\n    BN_free(p);\n    BN_free(g);\n    BN_free(bnpub_key);\n    DH_free(dh);\n    EVP_PKEY_free(peer_tmp);\n\n    return 0;\n#else\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n             ERR_R_INTERNAL_ERROR);\n    return 0;\n#endif\n}",
        "file_path": "/src/openssl/ssl/statem/statem_clnt.c",
        "crashing_line": "    DH_free(dh);",
        "crashing_line_number": 2180
      },
      {
        "function_name": "tls_process_key_exchange",
        "function_body": "MSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)\n{\n    long alg_k;\n    EVP_PKEY *pkey = NULL;\n    EVP_MD_CTX *md_ctx = NULL;\n    EVP_PKEY_CTX *pctx = NULL;\n    PACKET save_param_start, signature;\n\n    alg_k = s->s3.tmp.new_cipher->algorithm_mkey;\n\n    save_param_start = *pkt;\n\n#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)\n    EVP_PKEY_free(s->s3.peer_tmp);\n    s->s3.peer_tmp = NULL;\n#endif\n\n    if (alg_k & SSL_PSK) {\n        if (!tls_process_ske_psk_preamble(s, pkt)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    }\n\n    /* Nothing else to do for plain PSK or RSAPSK */\n    if (alg_k & (SSL_kPSK | SSL_kRSAPSK)) {\n    } else if (alg_k & SSL_kSRP) {\n        if (!tls_process_ske_srp(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {\n        if (!tls_process_ske_dhe(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        if (!tls_process_ske_ecdhe(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                 SSL_R_UNEXPECTED_MESSAGE);\n        goto err;\n    }\n\n    /* if it was signed, check the signature */\n    if (pkey != NULL) {\n        PACKET params;\n        const EVP_MD *md = NULL;\n        unsigned char *tbs;\n        size_t tbslen;\n        int rv;\n\n        /*\n         * |pkt| now points to the beginning of the signature, so the difference\n         * equals the length of the parameters.\n         */\n        if (!PACKET_get_sub_packet(&save_param_start, &params,\n                                   PACKET_remaining(&save_param_start) -\n                                   PACKET_remaining(pkt))) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (SSL_USE_SIGALGS(s)) {\n            unsigned int sigalg;\n\n            if (!PACKET_get_net_2(pkt, &sigalg)) {\n                SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                         SSL_R_LENGTH_TOO_SHORT);\n                goto err;\n            }\n            if (tls12_check_peer_sigalg(s, sigalg, pkey) <=0) {\n                /* SSLfatal() already called */\n                goto err;\n            }\n        } else if (!tls1_set_peer_legacy_sigalg(s, pkey)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (!tls1_lookup_md(s->ctx, s->s3.tmp.peer_sigalg, &md)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        if (SSL_USE_SIGALGS(s))\n            OSSL_TRACE1(TLS, \"USING TLSv1.2 HASH %s\\n\",\n                        md == NULL ? \"n/a\" : EVP_MD_name(md));\n\n        if (!PACKET_get_length_prefixed_2(pkt, &signature)\n            || PACKET_remaining(pkt) != 0) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        md_ctx = EVP_MD_CTX_new();\n        if (md_ctx == NULL) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        if (EVP_DigestVerifyInit(md_ctx, &pctx, md, NULL, pkey) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_EVP_LIB);\n            goto err;\n        }\n        if (SSL_USE_PSS(s)) {\n            if (EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PSS_PADDING) <= 0\n                || EVP_PKEY_CTX_set_rsa_pss_saltlen(pctx,\n                                                RSA_PSS_SALTLEN_DIGEST) <= 0) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_EVP_LIB);\n                goto err;\n            }\n        }\n        tbslen = construct_key_exchange_tbs(s, &tbs, PACKET_data(&params),\n                                            PACKET_remaining(&params));\n        if (tbslen == 0) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n\n        rv = EVP_DigestVerify(md_ctx, PACKET_data(&signature),\n                              PACKET_remaining(&signature), tbs, tbslen);\n        OPENSSL_free(tbs);\n        if (rv <= 0) {\n            SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_BAD_SIGNATURE);\n            goto err;\n        }\n        EVP_MD_CTX_free(md_ctx);\n        md_ctx = NULL;\n    } else {\n        /* aNULL, aSRP or PSK do not need public keys */\n        if (!(s->s3.tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))\n            && !(alg_k & SSL_PSK)) {\n            /* Might be wrong key type, check it */\n            if (ssl3_check_cert_and_algorithm(s)) {\n                SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                         SSL_R_BAD_DATA);\n            }\n            /* else this shouldn't happen, SSLfatal() already called */\n            goto err;\n        }\n        /* still data left over */\n        if (PACKET_remaining(pkt) != 0) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_EXTRA_DATA_IN_MESSAGE);\n            goto err;\n        }\n    }\n\n    return MSG_PROCESS_CONTINUE_READING;\n err:\n    EVP_MD_CTX_free(md_ctx);\n    return MSG_PROCESS_ERROR;\n}",
        "file_path": "/src/openssl/ssl/statem/statem_clnt.c",
        "crashing_line": "    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {",
        "crashing_line_number": 2288
      },
      {
        "function_name": "read_state_machine",
        "function_body": "static SUB_STATE_RETURN read_state_machine(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n    int ret, mt;\n    size_t len = 0;\n    int (*transition) (SSL *s, int mt);\n    PACKET pkt;\n    MSG_PROCESS_RETURN(*process_message) (SSL *s, PACKET *pkt);\n    WORK_STATE(*post_process_message) (SSL *s, WORK_STATE wst);\n    size_t (*max_message_size) (SSL *s);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n\n    cb = get_callback(s);\n\n    if (s->server) {\n        transition = ossl_statem_server_read_transition;\n        process_message = ossl_statem_server_process_message;\n        max_message_size = ossl_statem_server_max_message_size;\n        post_process_message = ossl_statem_server_post_process_message;\n    } else {\n        transition = ossl_statem_client_read_transition;\n        process_message = ossl_statem_client_process_message;\n        max_message_size = ossl_statem_client_max_message_size;\n        post_process_message = ossl_statem_client_post_process_message;\n    }\n\n    if (st->read_state_first_init) {\n        s->first_packet = 1;\n        st->read_state_first_init = 0;\n    }\n\n    while (1) {\n        switch (st->read_state) {\n        case READ_STATE_HEADER:\n            /* Get the state the peer wants to move to */\n            if (SSL_IS_DTLS(s)) {\n                /*\n                 * In DTLS we get the whole message in one go - header and body\n                 */\n                ret = dtls_get_message(s, &mt, &len);\n            } else {\n                ret = tls_get_message_header(s, &mt);\n            }\n\n            if (ret == 0) {\n                /* Could be non-blocking IO */\n                return SUB_STATE_ERROR;\n            }\n\n            if (cb != NULL) {\n                /* Notify callback of an impending state change */\n                if (s->server)\n                    cb(s, SSL_CB_ACCEPT_LOOP, 1);\n                else\n                    cb(s, SSL_CB_CONNECT_LOOP, 1);\n            }\n            /*\n             * Validate that we are allowed to move to the new state and move\n             * to that state if so\n             */\n            if (!transition(s, mt))\n                return SUB_STATE_ERROR;\n\n            if (s->s3.tmp.message_size > max_message_size(s)) {\n                SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_READ_STATE_MACHINE,\n                         SSL_R_EXCESSIVE_MESSAGE_SIZE);\n                return SUB_STATE_ERROR;\n            }\n\n            /* dtls_get_message already did this */\n            if (!SSL_IS_DTLS(s)\n                    && s->s3.tmp.message_size > 0\n                    && !grow_init_buf(s, s->s3.tmp.message_size\n                                         + SSL3_HM_HEADER_LENGTH)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                         ERR_R_BUF_LIB);\n                return SUB_STATE_ERROR;\n            }\n\n            st->read_state = READ_STATE_BODY;\n            /* Fall through */\n\n        case READ_STATE_BODY:\n            if (!SSL_IS_DTLS(s)) {\n                /* We already got this above for DTLS */\n                ret = tls_get_message_body(s, &len);\n                if (ret == 0) {\n                    /* Could be non-blocking IO */\n                    return SUB_STATE_ERROR;\n                }\n            }\n\n            s->first_packet = 0;\n            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                return SUB_STATE_ERROR;\n            }\n            ret = process_message(s, &pkt);\n\n            /* Discard the packet data */\n            s->init_num = 0;\n\n            switch (ret) {\n            case MSG_PROCESS_ERROR:\n                check_fatal(s, SSL_F_READ_STATE_MACHINE);\n                return SUB_STATE_ERROR;\n\n            case MSG_PROCESS_FINISHED_READING:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n\n            case MSG_PROCESS_CONTINUE_PROCESSING:\n                st->read_state = READ_STATE_POST_PROCESS;\n                st->read_state_work = WORK_MORE_A;\n                break;\n\n            default:\n                st->read_state = READ_STATE_HEADER;\n                break;\n            }\n            break;\n\n        case READ_STATE_POST_PROCESS:\n            st->read_state_work = post_process_message(s, st->read_state_work);\n            switch (st->read_state_work) {\n            case WORK_ERROR:\n                check_fatal(s, SSL_F_READ_STATE_MACHINE);\n                /* Fall through */\n            case WORK_MORE_A:\n            case WORK_MORE_B:\n            case WORK_MORE_C:\n                return SUB_STATE_ERROR;\n\n            case WORK_FINISHED_CONTINUE:\n                st->read_state = READ_STATE_HEADER;\n                break;\n\n            case WORK_FINISHED_STOP:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n            }\n            break;\n\n        default:\n            /* Shouldn't happen */\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            return SUB_STATE_ERROR;\n        }\n    }\n}",
        "file_path": "/src/openssl/ssl/statem/statem.c",
        "crashing_line": "            ret = process_message(s, &pkt);",
        "crashing_line_number": 637
      },
      {
        "function_name": "state_machine",
        "function_body": "static int state_machine(SSL *s, int server)\n{\n    BUF_MEM *buf = NULL;\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n    OSSL_STATEM *st = &s->statem;\n    int ret = -1;\n    int ssret;\n\n    if (st->state == MSG_FLOW_ERROR) {\n        /* Shouldn't have been called if we're already in the error state */\n        return -1;\n    }\n\n    ERR_clear_error();\n    clear_sys_error();\n\n    cb = get_callback(s);\n\n    st->in_handshake++;\n    if (!SSL_in_init(s) || SSL_in_before(s)) {\n        /*\n         * If we are stateless then we already called SSL_clear() - don't do\n         * it again and clear the STATELESS flag itself.\n         */\n        if ((s->s3.flags & TLS1_FLAGS_STATELESS) == 0 && !SSL_clear(s))\n            return -1;\n    }\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        /*\n         * Notify SCTP BIO socket to enter handshake mode and prevent stream\n         * identifier other than 0.\n         */\n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,\n                 st->in_handshake, NULL);\n    }\n#endif\n\n    /* Initialise state machine */\n    if (st->state == MSG_FLOW_UNINITED\n            || st->state == MSG_FLOW_FINISHED) {\n        if (st->state == MSG_FLOW_UNINITED) {\n            st->hand_state = TLS_ST_BEFORE;\n            st->request_state = TLS_ST_BEFORE;\n        }\n\n        s->server = server;\n        if (cb != NULL) {\n            if (SSL_IS_FIRST_HANDSHAKE(s) || !SSL_IS_TLS13(s))\n                cb(s, SSL_CB_HANDSHAKE_START, 1);\n        }\n\n        /*\n         * Fatal errors in this block don't send an alert because we have\n         * failed to even initialise properly. Sending an alert is probably\n         * doomed to failure.\n         */\n\n        if (SSL_IS_DTLS(s)) {\n            if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00) &&\n                (server || (s->version & 0xff00) != (DTLS1_BAD_VER & 0xff00))) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n        } else {\n            if ((s->version >> 8) != SSL3_VERSION_MAJOR) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n        }\n\n        if (!ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) {\n            SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            goto end;\n        }\n\n        if (s->init_buf == NULL) {\n            if ((buf = BUF_MEM_new()) == NULL) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n            if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n            s->init_buf = buf;\n            buf = NULL;\n        }\n\n        if (!ssl3_setup_buffers(s)) {\n            SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            goto end;\n        }\n        s->init_num = 0;\n\n        /*\n         * Should have been reset by tls_process_finished, too.\n         */\n        s->s3.change_cipher_spec = 0;\n\n        /*\n         * Ok, we now need to push on a buffering BIO ...but not with\n         * SCTP\n         */\n#ifndef OPENSSL_NO_SCTP\n        if (!SSL_IS_DTLS(s) || !BIO_dgram_is_sctp(SSL_get_wbio(s)))\n#endif\n            if (!ssl_init_wbio_buffer(s)) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n\n        if ((SSL_in_before(s))\n                || s->renegotiate) {\n            if (!tls_setup_handshake(s)) {\n                /* SSLfatal() already called */\n                goto end;\n            }\n\n            if (SSL_IS_FIRST_HANDSHAKE(s))\n                st->read_state_first_init = 1;\n        }\n\n        st->state = MSG_FLOW_WRITING;\n        init_write_state_machine(s);\n    }\n\n    while (st->state != MSG_FLOW_FINISHED) {\n        if (st->state == MSG_FLOW_READING) {\n            ssret = read_state_machine(s);\n            if (ssret == SUB_STATE_FINISHED) {\n                st->state = MSG_FLOW_WRITING;\n                init_write_state_machine(s);\n            } else {\n                /* NBIO or error */\n                goto end;\n            }\n        } else if (st->state == MSG_FLOW_WRITING) {\n            ssret = write_state_machine(s);\n            if (ssret == SUB_STATE_FINISHED) {\n                st->state = MSG_FLOW_READING;\n                init_read_state_machine(s);\n            } else if (ssret == SUB_STATE_END_HANDSHAKE) {\n                st->state = MSG_FLOW_FINISHED;\n            } else {\n                /* NBIO or error */\n                goto end;\n            }\n        } else {\n            /* Error */\n            check_fatal(s, SSL_F_STATE_MACHINE);\n            SSLerr(SSL_F_STATE_MACHINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n            goto end;\n        }\n    }\n\n    ret = 1;\n\n end:\n    st->in_handshake--;\n\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        /*\n         * Notify SCTP BIO socket to leave handshake mode and allow stream\n         * identifier other than 0.\n         */\n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,\n                 st->in_handshake, NULL);\n    }\n#endif\n\n    BUF_MEM_free(buf);\n    if (cb != NULL) {\n        if (server)\n            cb(s, SSL_CB_ACCEPT_EXIT, ret);\n        else\n            cb(s, SSL_CB_CONNECT_EXIT, ret);\n    }\n    return ret;\n}",
        "file_path": "/src/openssl/ssl/statem/statem.c",
        "crashing_line": "            ssret = read_state_machine(s);",
        "crashing_line_number": 435
      },
      {
        "function_name": "SSL_do_handshake",
        "function_body": "int SSL_do_handshake(SSL *s)\n{\n    int ret = 1;\n\n    if (s->handshake_func == NULL) {\n        SSLerr(SSL_F_SSL_DO_HANDSHAKE, SSL_R_CONNECTION_TYPE_NOT_SET);\n        return -1;\n    }\n\n    ossl_statem_check_finish_init(s, -1);\n\n    s->method->ssl_renegotiate_check(s, 0);\n\n    if (SSL_in_init(s) || SSL_in_before(s)) {\n        if ((s->mode & SSL_MODE_ASYNC) && ASYNC_get_current_job() == NULL) {\n            struct ssl_async_args args;\n\n            args.s = s;\n\n            ret = ssl_start_async_job(s, &args, ssl_do_handshake_intern);\n        } else {\n            ret = s->handshake_func(s);\n        }\n    }\n    return ret;\n}",
        "file_path": "/src/openssl/ssl/ssl_lib.c",
        "crashing_line": "            ret = s->handshake_func(s);",
        "crashing_line_number": 3812
      },
      {
        "function_name": "FuzzerTestOneInput",
        "function_body": "int FuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n    SSL *client;\n    BIO *in;\n    BIO *out;\n    SSL_CTX *ctx;\n\n    if (len == 0)\n        return 0;\n\n    /*\n     * TODO: use the ossltest engine (optionally?) to disable crypto checks.\n     */\n\n    /* This only fuzzes the initial flow from the client so far. */\n    ctx = SSL_CTX_new(SSLv23_method());\n\n    client = SSL_new(ctx);\n    OPENSSL_assert(SSL_set_min_proto_version(client, 0) == 1);\n    OPENSSL_assert(SSL_set_cipher_list(client, \"ALL:eNULL:@SECLEVEL=0\") == 1);\n    SSL_set_tlsext_host_name(client, \"localhost\");\n    in = BIO_new(BIO_s_mem());\n    out = BIO_new(BIO_s_mem());\n    SSL_set_bio(client, in, out);\n    SSL_set_connect_state(client);\n    OPENSSL_assert((size_t)BIO_write(in, buf, len) == len);\n    if (SSL_do_handshake(client) == 1) {\n        /* Keep reading application data until error or EOF. */\n        uint8_t tmp[1024];\n        for (;;) {\n            if (SSL_read(client, tmp, sizeof(tmp)) <= 0) {\n                break;\n            }\n        }\n    }\n    SSL_free(client);\n    ERR_clear_error();\n    SSL_CTX_free(ctx);\n\n    return 0;\n}",
        "file_path": "/src/openssl/fuzz/client.c",
        "crashing_line": "    if (SSL_do_handshake(client) == 1) {",
        "crashing_line_number": 84
      },
      {
        "function_name": "ExecuteCallback",
        "function_body": "void Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (EF->__msan_unpoison)\n    EF->__msan_unpoison(DataCopy, Size);\n  if (EF->__msan_unpoison_param)\n    EF->__msan_unpoison_param(2);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  {\n    ScopedEnableMsanInterceptorChecks S;\n    AllocTracer.Start(Options.TraceMalloc);\n    UnitStartTime = system_clock::now();\n    TPC.ResetMaps();\n    RunningUserCallback = true;\n    int Res = CB(DataCopy, Size);\n    RunningUserCallback = false;\n    UnitStopTime = system_clock::now();\n    (void)Res;\n    assert(Res == 0);\n    HasMoreMallocsThanFrees = AllocTracer.Stop();\n  }\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}",
        "file_path": "/src/libfuzzer/FuzzerLoop.cpp",
        "crashing_line": "    int Res = CB(DataCopy, Size);",
        "crashing_line_number": 556
      },
      {
        "function_name": "RunOneTest",
        "function_body": "int RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}",
        "file_path": "/src/libfuzzer/FuzzerDriver.cpp",
        "crashing_line": "  F->ExecuteCallback(U.data(), U.size());",
        "crashing_line_number": 292
      },
      {
        "function_name": "FuzzerDriver",
        "function_body": "int FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  if (EF->__msan_scoped_disable_interceptor_checks)\n    EF->__msan_scoped_disable_interceptor_checks();\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args, EF);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.LenControl = Flags.len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.IgnoreTimeouts = Flags.ignore_timeouts;\n  Options.IgnoreOOMs = Flags.ignore_ooms;\n  Options.IgnoreCrashes = Flags.ignore_crashes;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.ReduceDepth = Flags.reduce_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  Options.MallocLimitMb = Flags.malloc_limit_mb;\n  if (!Options.MallocLimitMb)\n    Options.MallocLimitMb = Options.RssLimitMb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool RunIndividualFiles = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !RunIndividualFiles || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n  if (Flags.focus_function)\n    Options.FocusFunction = Flags.focus_function;\n  if (Flags.data_flow_trace)\n    Options.DataFlowTrace = Flags.data_flow_trace;\n  if (Flags.features_dir)\n    Options.FeaturesDir = Flags.features_dir;\n  if (Flags.collect_data_flow)\n    Options.CollectDataFlow = Flags.collect_data_flow;\n  if (Flags.stop_file)\n    Options.StopFile = Flags.stop_file;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  if (Flags.collect_data_flow && !Flags.fork && !Flags.merge) {\n    if (RunIndividualFiles)\n      return CollectDataFlow(Flags.collect_data_flow, Flags.data_flow_trace,\n                        ReadCorpora({}, *Inputs));\n    else\n      return CollectDataFlow(Flags.collect_data_flow, Flags.data_flow_trace,\n                        ReadCorpora(*Inputs, {}));\n  }\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n  if (RunIndividualFiles) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.fork)\n    FuzzWithFork(F->GetMD().GetRand(), Options, Args, *Inputs, Flags.fork);\n\n  if (Flags.merge)\n    Merge(F, Options, Args, *Inputs, Flags.merge_control_file);\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis succeeded\\n\");\n    exit(0);\n  }\n\n  auto CorporaFiles = ReadCorpora(*Inputs, ParseSeedInuts(Flags.seed_inputs));\n  F->Loop(CorporaFiles);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}",
        "file_path": "/src/libfuzzer/FuzzerDriver.cpp",
        "crashing_line": "        RunOneTest(F, Path.c_str(), Options.MaxLen);",
        "crashing_line_number": 774
      },
      {
        "function_name": "main",
        "function_body": "ATTRIBUTE_INTERFACE int main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}",
        "file_path": "/src/libfuzzer/FuzzerMain.cpp",
        "crashing_line": "  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);",
        "crashing_line_number": 19
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey)\n{\n#ifndef OPENSSL_NO_DH\n    PACKET prime, generator, pub_key;\n    EVP_PKEY *peer_tmp = NULL;\n\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;\n\n    int check_bits = 0;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    peer_tmp = EVP_PKEY_new();\n    dh = DH_new();\n\n    if (peer_tmp == NULL || dh == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* TODO(size_t): Convert these calls */\n    p = BN_bin2bn(PACKET_data(&prime), (int)PACKET_remaining(&prime), NULL);\n    g = BN_bin2bn(PACKET_data(&generator), (int)PACKET_remaining(&generator),\n                  NULL);\n    bnpub_key = BN_bin2bn(PACKET_data(&pub_key),\n                          (int)PACKET_remaining(&pub_key), NULL);\n    if (p == NULL || g == NULL || bnpub_key == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* test non-zero pubkey */\n    if (BN_is_zero(bnpub_key)) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_pqg(dh, p, NULL, g)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    p = g = NULL;\n\n    if (DH_check_params(dh, &check_bits) == 0 || check_bits != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_key(dh, bnpub_key, NULL)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    bnpub_key = NULL;\n\n    if (EVP_PKEY_assign_DH(peer_tmp, dh) == 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    if (!ssl_security(s, SSL_SECOP_TMP_DH, EVP_PKEY_security_bits(peer_tmp),\n                      0, dh)) {\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_DH_KEY_TOO_SMALL);\n        goto err;\n    }\n\n    s->s3.peer_tmp = peer_tmp;\n\n    /*\n     * FIXME: This makes assumptions about which ciphersuites come with\n     * public keys. We should have a less ad-hoc way of doing this\n     */\n    if (s->s3.tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous DH, so no certificate or pkey. */\n\n    return 1;\n\n err:\n    BN_free(p);\n    BN_free(g);\n    BN_free(bnpub_key);\n    DH_free(dh);\n    EVP_PKEY_free(peer_tmp);\n\n    return 0;\n#else\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n             ERR_R_INTERNAL_ERROR);\n    return 0;\n#endif\n}\n",
    "target": 1,
    "idx": 1021550,
    "stack_trace": [
      {
        "function_name": "CRYPTO_DOWN_REF",
        "function_body": "static __inline int CRYPTO_DOWN_REF(volatile int *val, int *ret, void *lock)\n{\n    *ret = _InterlockedExchangeAdd(val, -1) - 1;\n    return 1;\n}",
        "file_path": "/src/openssl/include/internal/refcount.h",
        "crashing_line": "",
        "crashing_line_number": 51
      },
      {
        "function_name": "DH_free",
        "function_body": "void DH_free(DH *r)\n{\n    int i;\n\n    if (r == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(&r->references, &i, r->lock);\n    REF_PRINT_COUNT(\"DH\", r);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n\n    if (r->meth != NULL && r->meth->finish != NULL)\n        r->meth->finish(r);\n#if !defined(FIPS_MODE)\n# if !defined(OPENSSL_NO_ENGINE)\n    ENGINE_finish(r->engine);\n# endif\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DH, r, &r->ex_data);\n#endif\n\n    CRYPTO_THREAD_lock_free(r->lock);\n\n    ffc_params_cleanup(&r->params);\n    BN_clear_free(r->pub_key);\n    BN_clear_free(r->priv_key);\n    OPENSSL_free(r);\n}",
        "file_path": "/src/openssl/crypto/dh/dh_lib.c",
        "crashing_line": "    CRYPTO_DOWN_REF(&r->references, &i, r->lock);",
        "crashing_line_number": 133
      },
      {
        "function_name": "evp_pkey_free_legacy",
        "function_body": "void evp_pkey_free_legacy(EVP_PKEY *x)\n{\n    if (x->ameth != NULL) {\n        if (x->ameth->pkey_free != NULL)\n            x->ameth->pkey_free(x);\n        x->pkey.ptr = NULL;\n    }\n# ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(x->engine);\n    x->engine = NULL;\n    ENGINE_finish(x->pmeth_engine);\n    x->pmeth_engine = NULL;\n# endif\n    x->type = EVP_PKEY_NONE;\n}",
        "file_path": "/src/openssl/crypto/evp/p_lib.c",
        "crashing_line": "            x->ameth->pkey_free(x);",
        "crashing_line_number": 1168
      },
      {
        "function_name": "evp_pkey_free_it",
        "function_body": "static void evp_pkey_free_it(EVP_PKEY *x)\n{\n    /* internal function; x is never NULL */\n\n    evp_keymgmt_util_clear_operation_cache(x);\n#ifndef FIPS_MODE\n    evp_pkey_free_legacy(x);\n#endif\n\n    if (x->keymgmt != NULL) {\n        evp_keymgmt_freedata(x->keymgmt, x->keydata);\n        EVP_KEYMGMT_free(x->keymgmt);\n        x->keymgmt = NULL;\n        x->keydata = NULL;\n    }\n}",
        "file_path": "/src/openssl/crypto/evp/p_lib.c",
        "crashing_line": "    evp_pkey_free_legacy(x);",
        "crashing_line_number": 1187
      },
      {
        "function_name": "EVP_PKEY_free",
        "function_body": "void EVP_PKEY_free(EVP_PKEY *x)\n{\n    int i;\n\n    if (x == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(&x->references, &i, x->lock);\n    REF_PRINT_COUNT(\"EVP_PKEY\", x);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n    evp_pkey_free_it(x);\n    CRYPTO_THREAD_lock_free(x->lock);\n#ifndef FIPS_MODE\n    sk_X509_ATTRIBUTE_pop_free(x->attributes, X509_ATTRIBUTE_free);\n#endif\n    OPENSSL_free(x);\n}",
        "file_path": "/src/openssl/crypto/evp/p_lib.c",
        "crashing_line": "    evp_pkey_free_it(x);",
        "crashing_line_number": 1210
      },
      {
        "function_name": "tls_process_ske_dhe",
        "function_body": "static int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey)\n{\n#ifndef OPENSSL_NO_DH\n    PACKET prime, generator, pub_key;\n    EVP_PKEY *peer_tmp = NULL;\n\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;\n\n    int check_bits = 0;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    peer_tmp = EVP_PKEY_new();\n    dh = DH_new();\n\n    if (peer_tmp == NULL || dh == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* TODO(size_t): Convert these calls */\n    p = BN_bin2bn(PACKET_data(&prime), (int)PACKET_remaining(&prime), NULL);\n    g = BN_bin2bn(PACKET_data(&generator), (int)PACKET_remaining(&generator),\n                  NULL);\n    bnpub_key = BN_bin2bn(PACKET_data(&pub_key),\n                          (int)PACKET_remaining(&pub_key), NULL);\n    if (p == NULL || g == NULL || bnpub_key == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* test non-zero pubkey */\n    if (BN_is_zero(bnpub_key)) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_pqg(dh, p, NULL, g)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    p = g = NULL;\n\n    if (DH_check_params(dh, &check_bits) == 0 || check_bits != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_key(dh, bnpub_key, NULL)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_BN_LIB);\n        goto err;\n    }\n    bnpub_key = NULL;\n\n    if (EVP_PKEY_assign_DH(peer_tmp, dh) == 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n    dh = NULL;\n\n    if (!ssl_security(s, SSL_SECOP_TMP_DH, EVP_PKEY_security_bits(peer_tmp),\n                      0, EVP_PKEY_get0_DH(peer_tmp))) {\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_PROCESS_SKE_DHE,\n                 SSL_R_DH_KEY_TOO_SMALL);\n        goto err;\n    }\n\n    s->s3.peer_tmp = peer_tmp;\n\n    /*\n     * FIXME: This makes assumptions about which ciphersuites come with\n     * public keys. We should have a less ad-hoc way of doing this\n     */\n    if (s->s3.tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous DH, so no certificate or pkey. */\n\n    return 1;\n\n err:\n    BN_free(p);\n    BN_free(g);\n    BN_free(bnpub_key);\n    DH_free(dh);\n    EVP_PKEY_free(peer_tmp);\n\n    return 0;\n#else\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_SKE_DHE,\n             ERR_R_INTERNAL_ERROR);\n    return 0;\n#endif\n}",
        "file_path": "/src/openssl/ssl/statem/statem_clnt.c",
        "crashing_line": "    DH_free(dh);",
        "crashing_line_number": 2180
      },
      {
        "function_name": "tls_process_key_exchange",
        "function_body": "MSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)\n{\n    long alg_k;\n    EVP_PKEY *pkey = NULL;\n    EVP_MD_CTX *md_ctx = NULL;\n    EVP_PKEY_CTX *pctx = NULL;\n    PACKET save_param_start, signature;\n\n    alg_k = s->s3.tmp.new_cipher->algorithm_mkey;\n\n    save_param_start = *pkt;\n\n#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)\n    EVP_PKEY_free(s->s3.peer_tmp);\n    s->s3.peer_tmp = NULL;\n#endif\n\n    if (alg_k & SSL_PSK) {\n        if (!tls_process_ske_psk_preamble(s, pkt)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    }\n\n    /* Nothing else to do for plain PSK or RSAPSK */\n    if (alg_k & (SSL_kPSK | SSL_kRSAPSK)) {\n    } else if (alg_k & SSL_kSRP) {\n        if (!tls_process_ske_srp(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {\n        if (!tls_process_ske_dhe(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        if (!tls_process_ske_ecdhe(s, pkt, &pkey)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else if (alg_k) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                 SSL_R_UNEXPECTED_MESSAGE);\n        goto err;\n    }\n\n    /* if it was signed, check the signature */\n    if (pkey != NULL) {\n        PACKET params;\n        const EVP_MD *md = NULL;\n        unsigned char *tbs;\n        size_t tbslen;\n        int rv;\n\n        /*\n         * |pkt| now points to the beginning of the signature, so the difference\n         * equals the length of the parameters.\n         */\n        if (!PACKET_get_sub_packet(&save_param_start, &params,\n                                   PACKET_remaining(&save_param_start) -\n                                   PACKET_remaining(pkt))) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (SSL_USE_SIGALGS(s)) {\n            unsigned int sigalg;\n\n            if (!PACKET_get_net_2(pkt, &sigalg)) {\n                SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                         SSL_R_LENGTH_TOO_SHORT);\n                goto err;\n            }\n            if (tls12_check_peer_sigalg(s, sigalg, pkey) <=0) {\n                /* SSLfatal() already called */\n                goto err;\n            }\n        } else if (!tls1_set_peer_legacy_sigalg(s, pkey)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (!tls1_lookup_md(s->ctx, s->s3.tmp.peer_sigalg, &md)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        if (SSL_USE_SIGALGS(s))\n            OSSL_TRACE1(TLS, \"USING TLSv1.2 HASH %s\\n\",\n                        md == NULL ? \"n/a\" : EVP_MD_name(md));\n\n        if (!PACKET_get_length_prefixed_2(pkt, &signature)\n            || PACKET_remaining(pkt) != 0) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        md_ctx = EVP_MD_CTX_new();\n        if (md_ctx == NULL) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        if (EVP_DigestVerifyInit(md_ctx, &pctx, md, NULL, pkey) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     ERR_R_EVP_LIB);\n            goto err;\n        }\n        if (SSL_USE_PSS(s)) {\n            if (EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PSS_PADDING) <= 0\n                || EVP_PKEY_CTX_set_rsa_pss_saltlen(pctx,\n                                                RSA_PSS_SALTLEN_DIGEST) <= 0) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_EVP_LIB);\n                goto err;\n            }\n        }\n        tbslen = construct_key_exchange_tbs(s, &tbs, PACKET_data(&params),\n                                            PACKET_remaining(&params));\n        if (tbslen == 0) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n\n        rv = EVP_DigestVerify(md_ctx, PACKET_data(&signature),\n                              PACKET_remaining(&signature), tbs, tbslen);\n        OPENSSL_free(tbs);\n        if (rv <= 0) {\n            SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_BAD_SIGNATURE);\n            goto err;\n        }\n        EVP_MD_CTX_free(md_ctx);\n        md_ctx = NULL;\n    } else {\n        /* aNULL, aSRP or PSK do not need public keys */\n        if (!(s->s3.tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))\n            && !(alg_k & SSL_PSK)) {\n            /* Might be wrong key type, check it */\n            if (ssl3_check_cert_and_algorithm(s)) {\n                SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                         SSL_R_BAD_DATA);\n            }\n            /* else this shouldn't happen, SSLfatal() already called */\n            goto err;\n        }\n        /* still data left over */\n        if (PACKET_remaining(pkt) != 0) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                     SSL_R_EXTRA_DATA_IN_MESSAGE);\n            goto err;\n        }\n    }\n\n    return MSG_PROCESS_CONTINUE_READING;\n err:\n    EVP_MD_CTX_free(md_ctx);\n    return MSG_PROCESS_ERROR;\n}",
        "file_path": "/src/openssl/ssl/statem/statem_clnt.c",
        "crashing_line": "    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {",
        "crashing_line_number": 2288
      },
      {
        "function_name": "read_state_machine",
        "function_body": "static SUB_STATE_RETURN read_state_machine(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n    int ret, mt;\n    size_t len = 0;\n    int (*transition) (SSL *s, int mt);\n    PACKET pkt;\n    MSG_PROCESS_RETURN(*process_message) (SSL *s, PACKET *pkt);\n    WORK_STATE(*post_process_message) (SSL *s, WORK_STATE wst);\n    size_t (*max_message_size) (SSL *s);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n\n    cb = get_callback(s);\n\n    if (s->server) {\n        transition = ossl_statem_server_read_transition;\n        process_message = ossl_statem_server_process_message;\n        max_message_size = ossl_statem_server_max_message_size;\n        post_process_message = ossl_statem_server_post_process_message;\n    } else {\n        transition = ossl_statem_client_read_transition;\n        process_message = ossl_statem_client_process_message;\n        max_message_size = ossl_statem_client_max_message_size;\n        post_process_message = ossl_statem_client_post_process_message;\n    }\n\n    if (st->read_state_first_init) {\n        s->first_packet = 1;\n        st->read_state_first_init = 0;\n    }\n\n    while (1) {\n        switch (st->read_state) {\n        case READ_STATE_HEADER:\n            /* Get the state the peer wants to move to */\n            if (SSL_IS_DTLS(s)) {\n                /*\n                 * In DTLS we get the whole message in one go - header and body\n                 */\n                ret = dtls_get_message(s, &mt, &len);\n            } else {\n                ret = tls_get_message_header(s, &mt);\n            }\n\n            if (ret == 0) {\n                /* Could be non-blocking IO */\n                return SUB_STATE_ERROR;\n            }\n\n            if (cb != NULL) {\n                /* Notify callback of an impending state change */\n                if (s->server)\n                    cb(s, SSL_CB_ACCEPT_LOOP, 1);\n                else\n                    cb(s, SSL_CB_CONNECT_LOOP, 1);\n            }\n            /*\n             * Validate that we are allowed to move to the new state and move\n             * to that state if so\n             */\n            if (!transition(s, mt))\n                return SUB_STATE_ERROR;\n\n            if (s->s3.tmp.message_size > max_message_size(s)) {\n                SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_READ_STATE_MACHINE,\n                         SSL_R_EXCESSIVE_MESSAGE_SIZE);\n                return SUB_STATE_ERROR;\n            }\n\n            /* dtls_get_message already did this */\n            if (!SSL_IS_DTLS(s)\n                    && s->s3.tmp.message_size > 0\n                    && !grow_init_buf(s, s->s3.tmp.message_size\n                                         + SSL3_HM_HEADER_LENGTH)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                         ERR_R_BUF_LIB);\n                return SUB_STATE_ERROR;\n            }\n\n            st->read_state = READ_STATE_BODY;\n            /* Fall through */\n\n        case READ_STATE_BODY:\n            if (!SSL_IS_DTLS(s)) {\n                /* We already got this above for DTLS */\n                ret = tls_get_message_body(s, &len);\n                if (ret == 0) {\n                    /* Could be non-blocking IO */\n                    return SUB_STATE_ERROR;\n                }\n            }\n\n            s->first_packet = 0;\n            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                return SUB_STATE_ERROR;\n            }\n            ret = process_message(s, &pkt);\n\n            /* Discard the packet data */\n            s->init_num = 0;\n\n            switch (ret) {\n            case MSG_PROCESS_ERROR:\n                check_fatal(s, SSL_F_READ_STATE_MACHINE);\n                return SUB_STATE_ERROR;\n\n            case MSG_PROCESS_FINISHED_READING:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n\n            case MSG_PROCESS_CONTINUE_PROCESSING:\n                st->read_state = READ_STATE_POST_PROCESS;\n                st->read_state_work = WORK_MORE_A;\n                break;\n\n            default:\n                st->read_state = READ_STATE_HEADER;\n                break;\n            }\n            break;\n\n        case READ_STATE_POST_PROCESS:\n            st->read_state_work = post_process_message(s, st->read_state_work);\n            switch (st->read_state_work) {\n            case WORK_ERROR:\n                check_fatal(s, SSL_F_READ_STATE_MACHINE);\n                /* Fall through */\n            case WORK_MORE_A:\n            case WORK_MORE_B:\n            case WORK_MORE_C:\n                return SUB_STATE_ERROR;\n\n            case WORK_FINISHED_CONTINUE:\n                st->read_state = READ_STATE_HEADER;\n                break;\n\n            case WORK_FINISHED_STOP:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n            }\n            break;\n\n        default:\n            /* Shouldn't happen */\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_READ_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            return SUB_STATE_ERROR;\n        }\n    }\n}",
        "file_path": "/src/openssl/ssl/statem/statem.c",
        "crashing_line": "            ret = process_message(s, &pkt);",
        "crashing_line_number": 637
      },
      {
        "function_name": "state_machine",
        "function_body": "static int state_machine(SSL *s, int server)\n{\n    BUF_MEM *buf = NULL;\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n    OSSL_STATEM *st = &s->statem;\n    int ret = -1;\n    int ssret;\n\n    if (st->state == MSG_FLOW_ERROR) {\n        /* Shouldn't have been called if we're already in the error state */\n        return -1;\n    }\n\n    ERR_clear_error();\n    clear_sys_error();\n\n    cb = get_callback(s);\n\n    st->in_handshake++;\n    if (!SSL_in_init(s) || SSL_in_before(s)) {\n        /*\n         * If we are stateless then we already called SSL_clear() - don't do\n         * it again and clear the STATELESS flag itself.\n         */\n        if ((s->s3.flags & TLS1_FLAGS_STATELESS) == 0 && !SSL_clear(s))\n            return -1;\n    }\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        /*\n         * Notify SCTP BIO socket to enter handshake mode and prevent stream\n         * identifier other than 0.\n         */\n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,\n                 st->in_handshake, NULL);\n    }\n#endif\n\n    /* Initialise state machine */\n    if (st->state == MSG_FLOW_UNINITED\n            || st->state == MSG_FLOW_FINISHED) {\n        if (st->state == MSG_FLOW_UNINITED) {\n            st->hand_state = TLS_ST_BEFORE;\n            st->request_state = TLS_ST_BEFORE;\n        }\n\n        s->server = server;\n        if (cb != NULL) {\n            if (SSL_IS_FIRST_HANDSHAKE(s) || !SSL_IS_TLS13(s))\n                cb(s, SSL_CB_HANDSHAKE_START, 1);\n        }\n\n        /*\n         * Fatal errors in this block don't send an alert because we have\n         * failed to even initialise properly. Sending an alert is probably\n         * doomed to failure.\n         */\n\n        if (SSL_IS_DTLS(s)) {\n            if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00) &&\n                (server || (s->version & 0xff00) != (DTLS1_BAD_VER & 0xff00))) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n        } else {\n            if ((s->version >> 8) != SSL3_VERSION_MAJOR) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n        }\n\n        if (!ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) {\n            SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            goto end;\n        }\n\n        if (s->init_buf == NULL) {\n            if ((buf = BUF_MEM_new()) == NULL) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n            if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n            s->init_buf = buf;\n            buf = NULL;\n        }\n\n        if (!ssl3_setup_buffers(s)) {\n            SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                     ERR_R_INTERNAL_ERROR);\n            goto end;\n        }\n        s->init_num = 0;\n\n        /*\n         * Should have been reset by tls_process_finished, too.\n         */\n        s->s3.change_cipher_spec = 0;\n\n        /*\n         * Ok, we now need to push on a buffering BIO ...but not with\n         * SCTP\n         */\n#ifndef OPENSSL_NO_SCTP\n        if (!SSL_IS_DTLS(s) || !BIO_dgram_is_sctp(SSL_get_wbio(s)))\n#endif\n            if (!ssl_init_wbio_buffer(s)) {\n                SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_STATE_MACHINE,\n                         ERR_R_INTERNAL_ERROR);\n                goto end;\n            }\n\n        if ((SSL_in_before(s))\n                || s->renegotiate) {\n            if (!tls_setup_handshake(s)) {\n                /* SSLfatal() already called */\n                goto end;\n            }\n\n            if (SSL_IS_FIRST_HANDSHAKE(s))\n                st->read_state_first_init = 1;\n        }\n\n        st->state = MSG_FLOW_WRITING;\n        init_write_state_machine(s);\n    }\n\n    while (st->state != MSG_FLOW_FINISHED) {\n        if (st->state == MSG_FLOW_READING) {\n            ssret = read_state_machine(s);\n            if (ssret == SUB_STATE_FINISHED) {\n                st->state = MSG_FLOW_WRITING;\n                init_write_state_machine(s);\n            } else {\n                /* NBIO or error */\n                goto end;\n            }\n        } else if (st->state == MSG_FLOW_WRITING) {\n            ssret = write_state_machine(s);\n            if (ssret == SUB_STATE_FINISHED) {\n                st->state = MSG_FLOW_READING;\n                init_read_state_machine(s);\n            } else if (ssret == SUB_STATE_END_HANDSHAKE) {\n                st->state = MSG_FLOW_FINISHED;\n            } else {\n                /* NBIO or error */\n                goto end;\n            }\n        } else {\n            /* Error */\n            check_fatal(s, SSL_F_STATE_MACHINE);\n            SSLerr(SSL_F_STATE_MACHINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n            goto end;\n        }\n    }\n\n    ret = 1;\n\n end:\n    st->in_handshake--;\n\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        /*\n         * Notify SCTP BIO socket to leave handshake mode and allow stream\n         * identifier other than 0.\n         */\n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,\n                 st->in_handshake, NULL);\n    }\n#endif\n\n    BUF_MEM_free(buf);\n    if (cb != NULL) {\n        if (server)\n            cb(s, SSL_CB_ACCEPT_EXIT, ret);\n        else\n            cb(s, SSL_CB_CONNECT_EXIT, ret);\n    }\n    return ret;\n}",
        "file_path": "/src/openssl/ssl/statem/statem.c",
        "crashing_line": "            ssret = read_state_machine(s);",
        "crashing_line_number": 435
      },
      {
        "function_name": "SSL_do_handshake",
        "function_body": "int SSL_do_handshake(SSL *s)\n{\n    int ret = 1;\n\n    if (s->handshake_func == NULL) {\n        SSLerr(SSL_F_SSL_DO_HANDSHAKE, SSL_R_CONNECTION_TYPE_NOT_SET);\n        return -1;\n    }\n\n    ossl_statem_check_finish_init(s, -1);\n\n    s->method->ssl_renegotiate_check(s, 0);\n\n    if (SSL_in_init(s) || SSL_in_before(s)) {\n        if ((s->mode & SSL_MODE_ASYNC) && ASYNC_get_current_job() == NULL) {\n            struct ssl_async_args args;\n\n            args.s = s;\n\n            ret = ssl_start_async_job(s, &args, ssl_do_handshake_intern);\n        } else {\n            ret = s->handshake_func(s);\n        }\n    }\n    return ret;\n}",
        "file_path": "/src/openssl/ssl/ssl_lib.c",
        "crashing_line": "            ret = s->handshake_func(s);",
        "crashing_line_number": 3812
      },
      {
        "function_name": "FuzzerTestOneInput",
        "function_body": "int FuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n    SSL *client;\n    BIO *in;\n    BIO *out;\n    SSL_CTX *ctx;\n\n    if (len == 0)\n        return 0;\n\n    /*\n     * TODO: use the ossltest engine (optionally?) to disable crypto checks.\n     */\n\n    /* This only fuzzes the initial flow from the client so far. */\n    ctx = SSL_CTX_new(SSLv23_method());\n\n    client = SSL_new(ctx);\n    OPENSSL_assert(SSL_set_min_proto_version(client, 0) == 1);\n    OPENSSL_assert(SSL_set_cipher_list(client, \"ALL:eNULL:@SECLEVEL=0\") == 1);\n    SSL_set_tlsext_host_name(client, \"localhost\");\n    in = BIO_new(BIO_s_mem());\n    out = BIO_new(BIO_s_mem());\n    SSL_set_bio(client, in, out);\n    SSL_set_connect_state(client);\n    OPENSSL_assert((size_t)BIO_write(in, buf, len) == len);\n    if (SSL_do_handshake(client) == 1) {\n        /* Keep reading application data until error or EOF. */\n        uint8_t tmp[1024];\n        for (;;) {\n            if (SSL_read(client, tmp, sizeof(tmp)) <= 0) {\n                break;\n            }\n        }\n    }\n    SSL_free(client);\n    ERR_clear_error();\n    SSL_CTX_free(ctx);\n\n    return 0;\n}",
        "file_path": "/src/openssl/fuzz/client.c",
        "crashing_line": "    if (SSL_do_handshake(client) == 1) {",
        "crashing_line_number": 84
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\ngs_main_finit(gs_main_instance * minst, int exit_status, int env_code)\n{\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    gs_dual_memory_t dmem = {0};\n    int exit_code;\n    ref error_object;\n    char *tempnames = NULL;\n    gs_lib_ctx_core_t *core;\n\n    /* NB: need to free gs_name_table\n     */\n\n    /*\n     * Previous versions of this code closed the devices in the\n     * device list here.  Since these devices are now prototypes,\n     * they cannot be opened, so they do not need to be closed;\n     * alloc_restore_all will close dynamically allocated devices.\n     */\n    tempnames = gs_main_tempnames(minst);\n\n    /* by the time we get here, we *must* avoid any random redefinitions of\n     * operators etc, so we push systemdict onto the top of the dict stack.\n     * We do this in C to avoid running into any other re-defininitions in the\n     * Postscript world.\n     */\n    gs_finit_push_systemdict(i_ctx_p);\n\n    /* We have to disable BGPrint before we call interp_reclaim() to prevent the\n     * parent rendering thread initialising for the next page, whilst we are\n     * removing objects it may want to access - for example, the I/O device table.\n     * We also have to mess with the BeginPage/EndPage procs so that we don't\n     * trigger a spurious extra page to be emitted.\n     */\n    if (minst->init_done >= 2) {\n        gs_main_run_string(minst,\n            \"/BGPrint /GetDeviceParam .special_op \\\n            {{ <</BeginPage {pop} /EndPage {pop pop //false } \\\n              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \\\n              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \\\n              .systemvar exec\",\n            0 , &exit_code, &error_object);\n    }\n\n    /*\n     * Close the \"main\" device, because it may need to write out\n     * data before destruction. pdfwrite needs so.\n     */\n    if (minst->init_done >= 2) {\n        int code = 0;\n\n        if (idmemory->reclaim != 0) {\n            code = interp_reclaim(&minst->i_ctx_p, avm_global);\n\n            /* We ignore gs_error_VMerror because it comes from gs_vmreclaim()\n            calling context_state_load(), and we don't seem to depend on the\n            missing fields. */\n            if (code == gs_error_VMerror) {\n                if (exit_status == 0 || exit_status == gs_error_Quit) {\n                    exit_status = gs_error_VMerror;\n                }\n            }\n            else if (code < 0) {\n                ref error_name;\n                if (tempnames)\n                    free(tempnames);\n\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf2(imemory, \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\", err_str, code);\n                }\n                else {\n                    emprintf1(imemory, \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\", code);\n                }\n#ifdef MEMENTO\n                if (Memento_squeezing() && code != gs_error_VMerror ) return gs_error_Fatal;\n#endif\n                return gs_error_Fatal;\n            }\n            i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&\n            gx_device_is_null(i_ctx_p->pgs->device)) {\n            /* if the job replaced the device with the nulldevice, we we need to grestore\n               away that device, so the block below can properly dispense\n               with the default device.\n             */\n            int code = gs_grestoreall(i_ctx_p->pgs);\n            if (code < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {\n            gx_device *pdev = i_ctx_p->pgs->device;\n            const char * dname = pdev->dname;\n            gs_gc_root_t dev_root;\n            gs_gc_root_t *dev_root_ptr = &dev_root;\n            /* There is a chance that, during the call to gs_main_run_string(), the interpreter may\n             * decide to call the garbager - the device is in gc memory, and the only reference to it\n             * (in the gstate) has been removed, thus it can be destroyed by the garbager.\n             * Counter-intuitively, adjusting the reference count makes not difference to that.\n             * Register the device as a gc 'root' so it will be implicitely marked by garbager, and\n             * and thus surive until control returns here.\n             */\n            if (gs_register_struct_root(pdev->memory, &dev_root_ptr, (void **)&pdev, \"gs_main_finit\") < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n\n            /* make sure device doesn't isn't freed by .uninstalldevice */\n            rc_adjust(pdev, 1, \"gs_main_finit\");\n            /* deactivate the device just before we close it for the last time */\n            gs_main_run_string(minst,\n                /* we need to do the 'quit' so we don't loop for input (double quit) */\n                \".uninstallpagedevice serverdict \\\n                /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemvar exec\",\n                0 , &exit_code, &error_object);\n            code = gs_closedevice(pdev);\n            if (code < 0) {\n                ref error_name;\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf3(imemory, \"ERROR: %s (%d) on closing %s device.\\n\", err_str, code, dname);\n                }\n                else {\n                    emprintf2(imemory, \"UNKNOWN ERROR %d closing %s device.\\n\", code, dname);\n               }\n            }\n            gs_unregister_root(pdev->memory, dev_root_ptr, \"gs_main_finit\");\n            rc_decrement(pdev, \"gs_main_finit\");                /* device might be freed */\n            if (exit_status == 0 || exit_status == gs_error_Quit)\n                exit_status = code;\n        }\n\n      /* Flush stdout and stderr */\n      gs_main_run_string(minst,\n        \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\\n        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \\\n          systemdict /savedinitialgstate .forceundef\",\n        0 , &exit_code, &error_object);\n    }\n    gp_readline_finit(minst->readline_data);\n    gs_free_object(minst->heap, minst->saved_pages_initial_arg, \"gs_main_finit\");\n    i_ctx_p = minst->i_ctx_p;\t\t/* get current interp context */\n    if (gs_debug_c(':')) {\n        print_resource_usage(minst, &gs_imemory, \"Final\");\n        dmprintf1(minst->heap, \"%% Exiting instance \"PRI_INTPTR\"\\n\", (intptr_t)minst);\n    }\n    /* Do the equivalent of a restore \"past the bottom\". */\n    /* This will release all memory, close all open files, etc. */\n    if (minst->init_done >= 1) {\n        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;\n        i_plugin_holder *h = i_ctx_p->plugin_list;\n\n        dmem = *idmemory;\n        env_code = alloc_restore_all(i_ctx_p);\n        if (env_code < 0)\n            emprintf1(mem_raw,\n                      \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\",\n                      env_code);\n        i_iodev_finit(&dmem);\n        i_plugin_finit(mem_raw, h);\n    }\n\n    /* clean up redirected stdout */\n    core = minst->heap->gs_lib_ctx->core;\n    if (core->fstdout2\n        && (gp_get_file(core->fstdout2) != core->fstdout)\n        && (gp_get_file(core->fstdout2) != core->fstderr)) {\n        gp_fclose(core->fstdout2);\n        core->fstdout2 = NULL;\n    }\n\n    minst->heap->gs_lib_ctx->core->stdout_is_redirected = 0;\n    minst->heap->gs_lib_ctx->core->stdout_to_stderr = 0;\n    /* remove any temporary files, after ghostscript has closed files */\n    if (tempnames) {\n        char *p = tempnames;\n        while (*p) {\n            gp_unlink(minst->heap, p);\n            p += strlen(p) + 1;\n        }\n        free(tempnames);\n    }\n    gs_lib_finit(exit_status, env_code, minst->heap);\n\n    set_lib_path_length(minst, 0);\n    gs_free_object(minst->heap, minst->lib_path.container.value.refs, \"lib_path array\");\n    if (minst->init_done == 0 && i_ctx_p) {\n        /* This fixes leak if memento forces failure in gs_main_init1(). */\n        dmem = *idmemory;\n    }\n    ialloc_finit(&dmem);\n    return exit_status;\n}\n",
    "target": 1,
    "idx": 1055443,
    "stack_trace": [
      {
        "function_name": "gc_trace",
        "function_body": "static int\ngc_trace_clump(const gs_memory_t *mem, clump_t * cp, gc_state_t * pstate, gc_mark_stack * pmstack)\n{\n    gs_gc_root_t root;\n    void *comp;\n    int more = 0;\n    int min_trace = pstate->min_collect;\n\n    root.p = &comp;\n    if_debug_clump('6', mem, \"[6]marking from clump\", cp);\n    SCAN_CLUMP_OBJECTS(cp)\n        DO_ALL\n    {\n        if_debug2m('7', mem, \" [7]scanning/marking \"PRI_INTPTR\"(%lu)\\n\",\n                   (intptr_t)pre, (ulong)size);\n        if (pre->o_type == &st_refs) {\n            ref_packed *rp = (ref_packed *) (pre + 1);\n            char *end = (char *)rp + size;\n\n            root.ptype = ptr_ref_type;\n            while ((char *)rp < end) {\n                comp = rp;\n                if (r_is_packed(rp)) {\t/* No packed refs need tracing. */\n                    rp++;\n                } else {\n                    ref *const pref = (ref *)rp;\n\n                    if (r_space(pref) >= min_trace) {\n                        r_clear_attrs(pref, l_mark);\n                        more |= gc_trace(&root, pstate, pmstack);\n                    }\n                    rp += packed_per_ref;\n                }\n            }\n        } else if (!o_is_unmarked(pre)) {\n            if (!o_is_untraced(pre))\n                o_set_unmarked(pre);\n            if (pre->o_type != &st_free) {\n                struct_proc_clear_marks((*proc)) =\n                    pre->o_type->clear_marks;\n\n                root.ptype = ptr_struct_type;\n                comp = pre + 1;\n                if (proc != 0)\n                    (*proc) (mem, comp, size, pre->o_type);\n                more |= gc_trace(&root, pstate, pmstack);\n            }\n        }\n    }",
        "file_path": "/src/ghostpdl/./psi/igc.c",
        "crashing_line": "",
        "crashing_line_number": 915
      },
      {
        "function_name": "gs_gc_reclaim",
        "function_body": "",
        "file_path": "/src/ghostpdl/./psi/igc.c",
        "crashing_line": "",
        "crashing_line_number": 338
      },
      {
        "function_name": "gs_vmreclaim",
        "function_body": "static int\ngs_vmreclaim(gs_dual_memory_t *dmem, bool global)\n{\n    /* HACK: we know the gs_dual_memory_t is embedded in a context state. */\n    i_ctx_t *i_ctx_p =\n        (i_ctx_t *)((char *)dmem - offset_of(i_ctx_t, memory));\n    gs_ref_memory_t *lmem = dmem->space_local;\n    int code = context_state_store(i_ctx_p);\n    gs_ref_memory_t *memories[5];\n    gs_ref_memory_t *mem;\n    int nmem, i;\n\n    if (code < 0)\n        return code;\n\n    memories[0] = dmem->space_system;\n    memories[1] = mem = dmem->space_global;\n    nmem = 2;\n    if (lmem != dmem->space_global)\n        memories[nmem++] = lmem;\n    for (i = nmem; --i >= 0;) {\n        mem = memories[i];\n        if (mem->stable_memory != (gs_memory_t *)mem)\n            memories[nmem++] = (gs_ref_memory_t *)mem->stable_memory;\n    }\n\n    /****** ABORT IF code < 0 ******/\n    for (i = nmem; --i >= 0; )\n        alloc_close_clump(memories[i]);\n\n    /* Prune the file list so it won't retain potentially collectible */\n    /* files. */\n\n    for (i = (global ? i_vm_system : i_vm_local);\n         i < countof(dmem->spaces_indexed);\n         ++i\n         ) {\n        gs_ref_memory_t *mem = dmem->spaces_indexed[i];\n\n        /* Always safe to substract 1 from i here, as i is always at\n         * least i_vm_system (1) or i_vm_local (2). */\n        if (mem == 0 || (mem == dmem->spaces_indexed[i - 1]))\n            continue;\n        if (mem->stable_memory != (gs_memory_t *)mem)\n            ialloc_gc_prepare((gs_ref_memory_t *)mem->stable_memory);\n        for (;; mem = &mem->saved->state) {\n            ialloc_gc_prepare(mem);\n            if (mem->saved == 0)\n                break;\n        }\n    }\n\n    /* Do the actual collection. */\n\n    {\n        void *ctxp = i_ctx_p;\n        gs_gc_root_t context_root, *r = &context_root;\n\n        gs_register_struct_root((gs_memory_t *)lmem, &r,\n                                &ctxp, \"i_ctx_p root\");\n        GS_RECLAIM(&dmem->spaces, global);\n        gs_unregister_root((gs_memory_t *)lmem, r, \"i_ctx_p root\");\n        i_ctx_p = ctxp;\n        dmem = &i_ctx_p->memory;\n    }\n\n    /* Update caches not handled by context_state_load. */\n\n    *systemdict = *ref_stack_index(&d_stack, ref_stack_count(&d_stack) - 1);\n\n    /* Update the cached value pointers in names. */\n\n    dicts_gc_cleanup();\n\n    /* Reopen the active clumps. */\n\n    for (i = 0; i < nmem; ++i)\n        alloc_open_clump(memories[i]);\n\n    /* Reload the context state.  Note this should be done\n       AFTER the clumps are reopened, since the context state\n       load could do allocations that must remain.\n       If it were done while the clumps were still closed,\n       we would lose those allocations when the clumps were opened */\n\n    code = context_state_load(i_ctx_p);\n    return code;\n}",
        "file_path": "/src/ghostpdl/./psi/ireclaim.c",
        "crashing_line": "        GS_RECLAIM(&dmem->spaces, global);",
        "crashing_line_number": 165
      },
      {
        "function_name": "ireclaim",
        "function_body": "static int\nireclaim(gs_dual_memory_t * dmem, int space)\n{\n    bool global;\n    gs_ref_memory_t *mem = NULL;\n    int code;\n\n    if (space < 0) {\n        /* Determine which allocator exceeded the limit. */\n        int i;\n\n        for (i = 0; i < countof(dmem->spaces_indexed); i++) {\n            mem = dmem->spaces_indexed[i];\n            if (mem == 0)\n                continue;\n            if (mem->gc_status.requested > 0 ||\n                ((gs_ref_memory_t *)mem->stable_memory)->gc_status.requested > 0\n                )\n                break;\n        }\n        if (!mem) {\n            mem = dmem->space_global; /* just in case */\n        }\n    } else {\n        mem = dmem->spaces_indexed[space >> r_space_shift];\n    }\n    if_debug3m('0', (gs_memory_t *)mem, \"[0]GC called, space=%d, requestor=%d, requested=%ld\\n\",\n               space, mem->space, (long)mem->gc_status.requested);\n    global = mem->space != avm_local;\n    /* Since dmem may move, reset the request now. */\n    ialloc_reset_requested(dmem);\n    code = gs_vmreclaim(dmem, global);\n    if (code < 0)\n        return code;\n    ialloc_set_limit(mem);\n    if (space < 0) {\n        gs_memory_status_t stats;\n        size_t allocated;\n\n        /* If the ammount still allocated after the GC is complete */\n        /* exceeds the max_vm setting, then return a VMerror       */\n        gs_memory_status((gs_memory_t *) mem, &stats);\n        allocated = stats.allocated;\n        if (mem->stable_memory != (gs_memory_t *)mem) {\n            gs_memory_status(mem->stable_memory, &stats);\n            allocated += stats.allocated;\n        }\n        if (allocated >= mem->gc_status.max_vm) {\n            /* We can't satisfy this request within max_vm. */\n            return_error(gs_error_VMerror);\n        }\n    }\n    return 0;\n}",
        "file_path": "/src/ghostpdl/./psi/ireclaim.c",
        "crashing_line": "    code = gs_vmreclaim(dmem, global);",
        "crashing_line_number": 80
      },
      {
        "function_name": "interp_reclaim",
        "function_body": "int\ninterp_reclaim(i_ctx_t **pi_ctx_p, int space)\n{\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    gs_gc_root_t ctx_root, *r = &ctx_root;\n    int code;\n\n#ifdef DEBUG\n    if (gs_debug_c(gs_debug_flag_gc_disable))\n        return 0;\n#endif\n\n    gs_register_struct_root(imemory_system, &r,\n                            (void **)pi_ctx_p, \"interp_reclaim(pi_ctx_p)\");\n    code = (*idmemory->reclaim)(idmemory, space);\n    i_ctx_p = *pi_ctx_p;        /* may have moved */\n    gs_unregister_root(imemory_system, r, \"interp_reclaim(pi_ctx_p)\");\n    return code;\n}",
        "file_path": "/src/ghostpdl/./psi/interp.c",
        "crashing_line": "    code = (*idmemory->reclaim)(idmemory, space);",
        "crashing_line_number": 452
      },
      {
        "function_name": "gs_main_finit",
        "function_body": "int\ngs_main_finit(gs_main_instance * minst, int exit_status, int env_code)\n{\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    gs_dual_memory_t dmem = {0};\n    int exit_code;\n    ref error_object;\n    char *tempnames = NULL;\n    gs_lib_ctx_core_t *core;\n\n    /* NB: need to free gs_name_table\n     */\n\n    /*\n     * Previous versions of this code closed the devices in the\n     * device list here.  Since these devices are now prototypes,\n     * they cannot be opened, so they do not need to be closed;\n     * alloc_restore_all will close dynamically allocated devices.\n     */\n    tempnames = gs_main_tempnames(minst);\n\n    /* by the time we get here, we *must* avoid any random redefinitions of\n     * operators etc, so we push systemdict onto the top of the dict stack.\n     * We do this in C to avoid running into any other re-defininitions in the\n     * Postscript world.\n     */\n    gs_finit_push_systemdict(i_ctx_p);\n\n    /* We have to disable BGPrint before we call interp_reclaim() to prevent the\n     * parent rendering thread initialising for the next page, whilst we are\n     * removing objects it may want to access - for example, the I/O device table.\n     * We also have to mess with the BeginPage/EndPage procs so that we don't\n     * trigger a spurious extra page to be emitted.\n     */\n    if (minst->init_done >= 2) {\n        gs_main_run_string(minst,\n            \"/BGPrint /GetDeviceParam .special_op \\\n            {{ <</BeginPage {pop} /EndPage {pop pop //false } \\\n              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \\\n              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \\\n              .systemvar exec\",\n            0 , &exit_code, &error_object);\n    }\n\n    /*\n     * Close the \"main\" device, because it may need to write out\n     * data before destruction. pdfwrite needs so.\n     */\n    if (minst->init_done >= 2) {\n        int code = 0;\n\n        if (idmemory->reclaim != 0) {\n            /* In extreme error conditions, these references can persist, despite the\n             * arrays themselves having been restored away.\n             */\n            gs_main_run_string(minst,\n                \"$error /dstack undef \\\n                 $error /estack undef \\\n                 $error /ostack undef\",\n                 0 , &exit_code, &error_object);\n\n            ref_stack_clear(&o_stack);\n            code = interp_reclaim(&minst->i_ctx_p, avm_global);\n\n            /* We ignore gs_error_VMerror because it comes from gs_vmreclaim()\n            calling context_state_load(), and we don't seem to depend on the\n            missing fields. */\n            if (code == gs_error_VMerror) {\n                if (exit_status == 0 || exit_status == gs_error_Quit) {\n                    exit_status = gs_error_VMerror;\n                }\n            }\n            else if (code < 0) {\n                ref error_name;\n                if (tempnames)\n                    free(tempnames);\n\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf2(imemory, \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\", err_str, code);\n                }\n                else {\n                    emprintf1(imemory, \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\", code);\n                }\n#ifdef MEMENTO\n                if (Memento_squeezing() && code != gs_error_VMerror ) return gs_error_Fatal;\n#endif\n                return gs_error_Fatal;\n            }\n            i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&\n            gx_device_is_null(i_ctx_p->pgs->device)) {\n            /* if the job replaced the device with the nulldevice, we we need to grestore\n               away that device, so the block below can properly dispense\n               with the default device.\n             */\n            int code = gs_grestoreall(i_ctx_p->pgs);\n            if (code < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {\n            gx_device *pdev = i_ctx_p->pgs->device;\n            const char * dname = pdev->dname;\n            gs_gc_root_t dev_root;\n            gs_gc_root_t *dev_root_ptr = &dev_root;\n            /* There is a chance that, during the call to gs_main_run_string(), the interpreter may\n             * decide to call the garbager - the device is in gc memory, and the only reference to it\n             * (in the gstate) has been removed, thus it can be destroyed by the garbager.\n             * Counter-intuitively, adjusting the reference count makes not difference to that.\n             * Register the device as a gc 'root' so it will be implicitely marked by garbager, and\n             * and thus surive until control returns here.\n             */\n            if (gs_register_struct_root(pdev->memory, &dev_root_ptr, (void **)&pdev, \"gs_main_finit\") < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n\n            /* make sure device doesn't isn't freed by .uninstalldevice */\n            rc_adjust(pdev, 1, \"gs_main_finit\");\n            /* deactivate the device just before we close it for the last time */\n            gs_main_run_string(minst,\n                /* we need to do the 'quit' so we don't loop for input (double quit) */\n                \".uninstallpagedevice serverdict \\\n                /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemvar exec\",\n                0 , &exit_code, &error_object);\n            code = gs_closedevice(pdev);\n            if (code < 0) {\n                ref error_name;\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf3(imemory, \"ERROR: %s (%d) on closing %s device.\\n\", err_str, code, dname);\n                }\n                else {\n                    emprintf2(imemory, \"UNKNOWN ERROR %d closing %s device.\\n\", code, dname);\n               }\n            }\n            gs_unregister_root(pdev->memory, dev_root_ptr, \"gs_main_finit\");\n            rc_decrement(pdev, \"gs_main_finit\");                /* device might be freed */\n            if (exit_status == 0 || exit_status == gs_error_Quit)\n                exit_status = code;\n        }\n\n      /* Flush stdout and stderr */\n      gs_main_run_string(minst,\n        \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\\n        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \\\n          systemdict /savedinitialgstate .forceundef\",\n        0 , &exit_code, &error_object);\n    }\n    gp_readline_finit(minst->readline_data);\n    gs_free_object(minst->heap, minst->saved_pages_initial_arg, \"gs_main_finit\");\n    i_ctx_p = minst->i_ctx_p;\t\t/* get current interp context */\n    if (gs_debug_c(':')) {\n        print_resource_usage(minst, &gs_imemory, \"Final\");\n        dmprintf1(minst->heap, \"%% Exiting instance \"PRI_INTPTR\"\\n\", (intptr_t)minst);\n    }\n    /* Do the equivalent of a restore \"past the bottom\". */\n    /* This will release all memory, close all open files, etc. */\n    if (minst->init_done >= 1) {\n        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;\n        i_plugin_holder *h = i_ctx_p->plugin_list;\n\n        dmem = *idmemory;\n        env_code = alloc_restore_all(i_ctx_p);\n        if (env_code < 0)\n            emprintf1(mem_raw,\n                      \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\",\n                      env_code);\n        i_iodev_finit(&dmem);\n        i_plugin_finit(mem_raw, h);\n    }\n\n    /* clean up redirected stdout */\n    core = minst->heap->gs_lib_ctx->core;\n    if (core->fstdout2\n        && (gp_get_file(core->fstdout2) != core->fstdout)\n        && (gp_get_file(core->fstdout2) != core->fstderr)) {\n        gp_fclose(core->fstdout2);\n        core->fstdout2 = NULL;\n    }\n\n    minst->heap->gs_lib_ctx->core->stdout_is_redirected = 0;\n    minst->heap->gs_lib_ctx->core->stdout_to_stderr = 0;\n    /* remove any temporary files, after ghostscript has closed files */\n    if (tempnames) {\n        char *p = tempnames;\n        while (*p) {\n            gp_unlink(minst->heap, p);\n            p += strlen(p) + 1;\n        }\n        free(tempnames);\n    }\n    gs_lib_finit(exit_status, env_code, minst->heap);\n\n    set_lib_path_length(minst, 0);\n    gs_free_object(minst->heap, minst->lib_path.container.value.refs, \"lib_path array\");\n    if (minst->init_done == 0 && i_ctx_p) {\n        /* This fixes leak if memento forces failure in gs_main_init1(). */\n        dmem = *idmemory;\n    }\n    ialloc_finit(&dmem);\n    return exit_status;\n}",
        "file_path": "/src/ghostpdl/./psi/imain.c",
        "crashing_line": "            /* In extreme error conditions, these references can persist, despite the",
        "crashing_line_number": 1281
      },
      {
        "function_name": "gs_to_exit_with_code",
        "function_body": "int\ngs_to_exit_with_code(const gs_memory_t *mem, int exit_status, int code)\n{\n    return gs_main_finit(get_minst_from_memory(mem), exit_status, code);\n}",
        "file_path": "/src/ghostpdl/./psi/imain.c",
        "crashing_line": "",
        "crashing_line_number": 1434
      },
      {
        "function_name": "gs_to_exit",
        "function_body": "int\ngs_to_exit(const gs_memory_t *mem, int exit_status)\n{\n    return gs_to_exit_with_code(mem, exit_status, 0);\n}",
        "file_path": "/src/ghostpdl/./psi/imain.c",
        "crashing_line": "",
        "crashing_line_number": 1439
      },
      {
        "function_name": "psapi_exit",
        "function_body": "int\npsapi_exit(gs_lib_ctx_t *ctx)\n{\n    if (ctx == NULL)\n        return gs_error_Fatal;\n\n    gs_to_exit(ctx->memory, 0);\n    return 0;\n}",
        "file_path": "/src/ghostpdl/./psi/psapi.c",
        "crashing_line": "    gs_to_exit(ctx->memory, 0);",
        "crashing_line_number": 517
      },
      {
        "function_name": "gsapi_exit",
        "function_body": "GSDLLEXPORT int GSDLLAPI\ngsapi_exit(void *instance)\n{\n    gs_lib_ctx_t *ctx = (gs_lib_ctx_t *)instance;\n    if (instance == NULL)\n        return gs_error_Fatal;\n    gp_set_debug_mem_ptr(ctx->memory);\n    return psapi_exit(ctx);\n}",
        "file_path": "/src/ghostpdl/./psi/iapi.c",
        "crashing_line": "    return psapi_exit(ctx);",
        "crashing_line_number": 440
      },
      {
        "function_name": "fuzz_gs_device",
        "function_body": "int fuzz_gs_device(\n\tconst unsigned char *buf,\n\tsize_t size,\n\tint color_scheme,\n\tconst char *device_target,\n\tconst char *output_file\n)\n{\n\tint ret;\n\tvoid *gs = NULL;\n\tchar color_space[50];\n\tchar gs_device[50];\n\tchar gs_o[100];\n\t/*\n\t * We are expecting color_scheme to be in the [0:62] interval.\n\t * This corresponds to the color schemes defined here:\n\t * https://github.com/ArtifexSoftware/ghostpdl/blob/8c97d5adce0040ac38a1fb4d7954499c65f582ff/cups/libs/cups/raster.h#L102\n\t */\n\tsprintf(color_space, \"-dcupsColorSpace=%d\", color_scheme);\n\tsprintf(gs_device, \"-sDEVICE=%s\", device_target);\n\tsprintf(gs_o, \"-sOutputFile=%s\", output_file);\n\t/* Mostly stolen from cups-filters gstoraster. */\n\tchar *args[] = {\n\t\t\"gs\",\n\t\t\"-K1048576\",\n\t\t\"-r200x200\",\n\t\t\"-sBandListStorage=memory\",\n\t\t\"-dMaxBitmap=0\",\n\t\t\"-dBufferSpace=450k\",\n\t\t\"-dMediaPosition=1\",\n\t\tcolor_space,\n\t\t\"-dQUIET\",\n\t\t\"-dSAFER\",\n\t\t\"-dNOPAUSE\",\n\t\t\"-dBATCH\",\n\t\t\"-dNOINTERPOLATE\",\n\t\t\"-dNOMEDIAATTRS\",\n\t\t\"-sstdout=%%stderr\",\n\t\tgs_o,\n\t\tgs_device,\n\t\t\"-_\",\n\t};\n\tint argc = sizeof(args) / sizeof(args[0]);\n\n\t/* Stash buffers globally, for gs_stdin(). */\n\tg_data = buf;\n\tg_size = size;\n\n\tret = gsapi_new_instance(&gs, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"gsapi_new_instance: error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgsapi_set_stdio(gs, gs_stdin, gs_stdnull, gs_stdnull);\n\tret = gsapi_set_arg_encoding(gs, GS_ARG_ENCODING_UTF8);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"gsapi_set_arg_encoding: error %d\\n\", ret);\n\t\tgsapi_delete_instance(gs);\n\t\treturn ret;\n\t}\n\n\tret = gsapi_init_with_args(gs, argc, args);\n\tif (ret && ret != gs_error_Quit)\n\t\t/* Just keep going, to cleanup. */\n\t\tfprintf(stderr, \"gsapi_init_with_args: error %d\\n\", ret);\n\n\tret = gsapi_exit(gs);\n\tif (ret < 0 && ret != gs_error_Quit) {\n\t\tfprintf(stderr, \"gsapi_exit: error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgsapi_delete_instance(gs);\n\n\treturn 0;\n}",
        "file_path": "/src/gs_fuzzlib.h",
        "crashing_line": "\tret = gsapi_exit(gs);",
        "crashing_line_number": 135
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "    virtual bool put_by_index(u32 property_index, Value value) override\n    {\n        if (property_index >= m_array_length)\n            return Base::put_by_index(property_index, value);\n\n        if constexpr (sizeof(T) < 4) {\n            auto number = value.to_i32(global_object());\n            if (vm().exception())\n                return {};\n            data()[property_index] = number;\n        } else if constexpr (sizeof(T) == 4 || sizeof(T) == 8) {\n            auto number = value.to_double(global_object());\n            if (vm().exception())\n                return {};\n            data()[property_index] = number;\n        } else {\n            static_assert(DependentFalse<T>, \"TypedArray::put_by_index with unhandled type size\");\n        }\n        return true;\n    }\n    virtual Value get_by_index(u32 property_index) const override\n    {\n        if (property_index >= m_array_length)\n            return Base::get_by_index(property_index);\n\n        if constexpr (sizeof(T) < 4) {\n            return Value((i32)data()[property_index]);\n        } else if constexpr (sizeof(T) == 4 || sizeof(T) == 8) {\n            auto value = data()[property_index];\n            if constexpr (IsFloatingPoint<T>) {\n                return Value((double)value);\n            } else if constexpr (NumericLimits<T>::is_signed()) {\n                if (value > NumericLimits<i32>::max() || value < NumericLimits<i32>::min())\n                    return Value((double)value);\n            } else {\n                if (value > NumericLimits<i32>::max())\n                    return Value((double)value);\n            }\n            return Value((i32)value);\n        } else {\n            static_assert(DependentFalse<T>, \"TypedArray::get_by_index with unhandled type size\");\n        }\n    }\n    Span<T> data()\n    {\n        return { reinterpret_cast<T*>(m_viewed_array_buffer->buffer().data() + m_byte_offset), m_array_length };\n    }\n    virtual size_t element_size() const override { return sizeof(T); };\n    TypedArray(u32 array_length, Object& prototype)\n        : TypedArrayBase(prototype)\n    {\n        VERIFY(!Checked<u32>::multiplication_would_overflow(array_length, sizeof(T)));\n        m_viewed_array_buffer = ArrayBuffer::create(global_object(), array_length * sizeof(T));\n        if (array_length)\n            VERIFY(!data().is_null());\n        m_array_length = array_length;\n        m_byte_length = m_viewed_array_buffer->byte_length();\n    }\nvoid generate_implementation(const IDL::Interface& interface)\n{\n    StringBuilder builder;\n    SourceGenerator generator { builder };\n\n    generator.set(\"name\", interface.name);\n    generator.set(\"wrapper_class\", interface.wrapper_class);\n    generator.set(\"wrapper_base_class\", interface.wrapper_base_class);\n    generator.set(\"prototype_class\", interface.prototype_class);\n    generator.set(\"fully_qualified_name\", interface.fully_qualified_name);\n\n    generator.append(R\"~~~(\n#include <AK/FlyString.h>\n#include <LibJS/Runtime/Array.h>\n#include <LibJS/Runtime/Error.h>\n#include <LibJS/Runtime/Function.h>\n#include <LibJS/Runtime/GlobalObject.h>\n#include <LibJS/Runtime/Uint8ClampedArray.h>\n#include <LibJS/Runtime/Value.h>\n#include <LibWeb/Bindings/@prototype_class@.h>\n#include <LibWeb/Bindings/@wrapper_class@.h>\n#include <LibWeb/Bindings/CanvasRenderingContext2DWrapper.h>\n#include <LibWeb/Bindings/CommentWrapper.h>\n#include <LibWeb/Bindings/DOMImplementationWrapper.h>\n#include <LibWeb/Bindings/DocumentFragmentWrapper.h>\n#include <LibWeb/Bindings/DocumentTypeWrapper.h>\n#include <LibWeb/Bindings/DocumentWrapper.h>\n#include <LibWeb/Bindings/EventTargetWrapperFactory.h>\n#include <LibWeb/Bindings/EventWrapperFactory.h>\n#include <LibWeb/Bindings/HTMLCanvasElementWrapper.h>\n#include <LibWeb/Bindings/HTMLCollectionWrapper.h>\n#include <LibWeb/Bindings/HTMLFormElementWrapper.h>\n#include <LibWeb/Bindings/HTMLHeadElementWrapper.h>\n#include <LibWeb/Bindings/HTMLImageElementWrapper.h>\n#include <LibWeb/Bindings/HTMLTableCaptionElementWrapper.h>\n#include <LibWeb/Bindings/HTMLTableSectionElementWrapper.h>\n#include <LibWeb/Bindings/ImageDataWrapper.h>\n#include <LibWeb/Bindings/NodeWrapperFactory.h>\n#include <LibWeb/Bindings/TextWrapper.h>\n#include <LibWeb/Bindings/WindowObject.h>\n#include <LibWeb/DOM/Element.h>\n#include <LibWeb/DOM/EventListener.h>\n#include <LibWeb/HTML/HTMLElement.h>\n#include <LibWeb/Origin.h>\n\n// FIXME: This is a total hack until we can figure out the namespace for a given type somehow.\nusing namespace Web::CSS;\nusing namespace Web::DOM;\nusing namespace Web::HTML;\n\nnamespace Web::Bindings {\n\n@wrapper_class@* @wrapper_class@::create(JS::GlobalObject& global_object, @fully_qualified_name@& impl)\n{\n    return global_object.heap().allocate<@wrapper_class@>(global_object, global_object, impl);\n}\n\n)~~~\");\n\n    if (interface.wrapper_base_class == \"Wrapper\") {\n        generator.append(R\"~~~(\n@wrapper_class@::@wrapper_class@(JS::GlobalObject& global_object, @fully_qualified_name@& impl)\n    : Wrapper(static_cast<WindowObject&>(global_object).ensure_web_prototype<@prototype_class@>(\"@name@\"))\n    , m_impl(impl)\n{\n}\n)~~~\");\n    } else {\n        generator.append(R\"~~~(\n@wrapper_class@::@wrapper_class@(JS::GlobalObject& global_object, @fully_qualified_name@& impl)\n    : @wrapper_base_class@(global_object, impl)\n{\n    set_prototype(&static_cast<WindowObject&>(global_object).ensure_web_prototype<@prototype_class@>(\"@name@\"));\n}\n)~~~\");\n    }\n\n    generator.append(R\"~~~(\nvoid @wrapper_class@::initialize(JS::GlobalObject& global_object)\n{\n    @wrapper_base_class@::initialize(global_object);\n}\n\n@wrapper_class@::~@wrapper_class@()\n{\n}\n)~~~\");\n\n    if (should_emit_wrapper_factory(interface)) {\n        generator.append(R\"~~~(\n@wrapper_class@* wrap(JS::GlobalObject& global_object, @fully_qualified_name@& impl)\n{\n    return static_cast<@wrapper_class@*>(wrap_impl(global_object, impl));\n}\n)~~~\");\n    }\n\n    generator.append(R\"~~~(\n} // namespace Web::Bindings\n)~~~\");\n\n    outln(\"{}\", generator.as_string_view());\n}\nvoid generate_prototype_implementation(const IDL::Interface& interface)\n{\n    StringBuilder builder;\n    SourceGenerator generator { builder };\n\n    generator.set(\"name\", interface.name);\n    generator.set(\"parent_name\", interface.parent_name);\n    generator.set(\"prototype_class\", interface.prototype_class);\n    generator.set(\"prototype_base_class\", interface.prototype_base_class);\n    generator.set(\"wrapper_class\", interface.wrapper_class);\n    generator.set(\"constructor_class\", interface.constructor_class);\n    generator.set(\"prototype_class:snakecase\", interface.prototype_class.to_snakecase());\n    generator.set(\"fully_qualified_name\", interface.fully_qualified_name);\n\n    generator.append(R\"~~~(\n#include <AK/Function.h>\n#include <LibJS/Runtime/Array.h>\n#include <LibJS/Runtime/Error.h>\n#include <LibJS/Runtime/Function.h>\n#include <LibJS/Runtime/GlobalObject.h>\n#include <LibJS/Runtime/Uint8ClampedArray.h>\n#include <LibWeb/Bindings/@prototype_class@.h>\n#include <LibWeb/Bindings/@wrapper_class@.h>\n#include <LibWeb/Bindings/CSSStyleDeclarationWrapper.h>\n#include <LibWeb/Bindings/CSSStyleSheetWrapper.h>\n#include <LibWeb/Bindings/CanvasRenderingContext2DWrapper.h>\n#include <LibWeb/Bindings/CommentWrapper.h>\n#include <LibWeb/Bindings/DOMImplementationWrapper.h>\n#include <LibWeb/Bindings/DocumentFragmentWrapper.h>\n#include <LibWeb/Bindings/DocumentTypeWrapper.h>\n#include <LibWeb/Bindings/DocumentWrapper.h>\n#include <LibWeb/Bindings/EventTargetWrapperFactory.h>\n#include <LibWeb/Bindings/EventWrapper.h>\n#include <LibWeb/Bindings/EventWrapperFactory.h>\n#include <LibWeb/Bindings/ExceptionOrUtils.h>\n#include <LibWeb/Bindings/HTMLCanvasElementWrapper.h>\n#include <LibWeb/Bindings/HTMLCollectionWrapper.h>\n#include <LibWeb/Bindings/HTMLFormElementWrapper.h>\n#include <LibWeb/Bindings/HTMLHeadElementWrapper.h>\n#include <LibWeb/Bindings/HTMLImageElementWrapper.h>\n#include <LibWeb/Bindings/HTMLTableCaptionElementWrapper.h>\n#include <LibWeb/Bindings/HTMLTableSectionElementWrapper.h>\n#include <LibWeb/Bindings/ImageDataWrapper.h>\n#include <LibWeb/Bindings/NodeWrapperFactory.h>\n#include <LibWeb/Bindings/PerformanceTimingWrapper.h>\n#include <LibWeb/Bindings/RangeWrapper.h>\n#include <LibWeb/Bindings/StyleSheetListWrapper.h>\n#include <LibWeb/Bindings/TextWrapper.h>\n#include <LibWeb/Bindings/WindowObject.h>\n#include <LibWeb/DOM/Element.h>\n#include <LibWeb/DOM/EventListener.h>\n#include <LibWeb/DOM/Range.h>\n#include <LibWeb/DOM/Window.h>\n#include <LibWeb/HTML/EventHandler.h>\n#include <LibWeb/HTML/HTMLElement.h>\n#include <LibWeb/NavigationTiming/PerformanceTiming.h>\n#include <LibWeb/Origin.h>\n\n#if __has_include(<LibWeb/Bindings/@prototype_base_class@.h>)\n#    include <LibWeb/Bindings/@prototype_base_class@.h>\n#endif\n#if __has_include(<LibWeb/CSS/@name@.h>)\n#    include <LibWeb/CSS/@name@.h>\n#elif __has_include(<LibWeb/DOM/@name@.h>)\n#    include <LibWeb/DOM/@name@.h>\n#elif __has_include(<LibWeb/HTML/@name@.h>)\n#    include <LibWeb/HTML/@name@.h>\n#elif __has_include(<LibWeb/UIEvents/@name@.h>)\n#    include <LibWeb/UIEvents/@name@.h>\n#elif __has_include(<LibWeb/HighResolutionTime/@name@.h>)\n#    include <LibWeb/HighResolutionTime/@name@.h>\n#elif __has_include(<LibWeb/NavigationTiming/@name@.h>)\n#    include <LibWeb/NavigationTiming/@name@.h>\n#elif __has_include(<LibWeb/SVG/@name@.h>)\n#    include <LibWeb/SVG/@name@.h>\n#elif __has_include(<LibWeb/XHR/@name@.h>)\n#    include <LibWeb/XHR/@name@.h>\n#endif\n\n// FIXME: This is a total hack until we can figure out the namespace for a given type somehow.\nusing namespace Web::CSS;\nusing namespace Web::DOM;\nusing namespace Web::HTML;\nusing namespace Web::NavigationTiming;\nusing namespace Web::XHR;\n\nnamespace Web::Bindings {\n\n@prototype_class@::@prototype_class@(JS::GlobalObject& global_object)\n    : Object(*global_object.object_prototype())\n{\n)~~~\");\n\n    if (interface.name == \"DOMException\") {\n        // https://heycam.github.io/webidl/#es-DOMException-specialness\n        // Object.getPrototypeOf(DOMException.prototype) === Error.prototype\n        generator.append(R\"~~~(\n    set_prototype(global_object.error_prototype());\n)~~~\");\n    } else if (!interface.parent_name.is_empty()) {\n        generator.append(R\"~~~(\n    set_prototype(&static_cast<WindowObject&>(global_object).ensure_web_prototype<@prototype_base_class@>(\"@parent_name@\"));\n)~~~\");\n    }\n\n    generator.append(R\"~~~(\n}\n\n@prototype_class@::~@prototype_class@()\n{\n}\n\nvoid @prototype_class@::initialize(JS::GlobalObject& global_object)\n{\n    [[maybe_unused]] auto& vm = this->vm();\n    [[maybe_unused]] u8 default_attributes = JS::Attribute::Enumerable | JS::Attribute::Configurable;\n\n)~~~\");\n\n    for (auto& attribute : interface.attributes) {\n        auto attribute_generator = generator.fork();\n        attribute_generator.set(\"attribute.name\", attribute.name);\n        attribute_generator.set(\"attribute.getter_callback\", attribute.getter_callback_name);\n\n        if (attribute.readonly)\n            attribute_generator.set(\"attribute.setter_callback\", \"nullptr\");\n        else\n            attribute_generator.set(\"attribute.setter_callback\", attribute.setter_callback_name);\n\n        attribute_generator.append(R\"~~~(\n    define_native_property(\"@attribute.name@\", @attribute.getter_callback@, @attribute.setter_callback@, default_attributes);\n)~~~\");\n    }\n\n    for (auto& constant : interface.constants) {\n        auto constant_generator = generator.fork();\n        constant_generator.set(\"constant.name\", constant.name);\n        constant_generator.set(\"constant.value\", constant.value);\n\n        constant_generator.append(R\"~~~(\n    define_property(\"@constant.name@\", JS::Value((i32)@constant.value@), JS::Attribute::Enumerable);\n)~~~\");\n    }\n\n    for (auto& function : interface.functions) {\n        auto function_generator = generator.fork();\n        function_generator.set(\"function.name\", function.name);\n        function_generator.set(\"function.name:snakecase\", function.name.to_snakecase());\n        function_generator.set(\"function.length\", String::number(function.length()));\n\n        function_generator.append(R\"~~~(\n    define_native_function(\"@function.name@\", @function.name:snakecase@, @function.length@, default_attributes);\n)~~~\");\n    }\n\n    generator.append(R\"~~~(\n    Object::initialize(global_object);\n}\n)~~~\");\n\n    if (!interface.attributes.is_empty() || !interface.functions.is_empty()) {\n        generator.append(R\"~~~(\nstatic @fully_qualified_name@* impl_from(JS::VM& vm, JS::GlobalObject& global_object)\n{\n    auto* this_object = vm.this_value(global_object).to_object(global_object);\n    if (!this_object)\n        return {};\n)~~~\");\n\n        if (interface.name == \"EventTarget\") {\n            generator.append(R\"~~~(\n    if (is<WindowObject>(this_object)) {\n        return &static_cast<WindowObject*>(this_object)->impl();\n    }\n)~~~\");\n        }\n\n        generator.append(R\"~~~(\n    if (!is<@wrapper_class@>(this_object)) {\n        vm.throw_exception<JS::TypeError>(global_object, JS::ErrorType::NotA, \"@fully_qualified_name@\");\n        return nullptr;\n    }\n\n    return &static_cast<@wrapper_class@*>(this_object)->impl();\n}\n)~~~\");\n    }\n\n    auto generate_return_statement = [&](auto& return_type) {\n        auto scoped_generator = generator.fork();\n        scoped_generator.set(\"return_type\", return_type.name);\n\n        if (return_type.name == \"undefined\") {\n            scoped_generator.append(R\"~~~(\n    return JS::js_undefined();\n)~~~\");\n            return;\n        }\n\n        if (return_type.nullable) {\n            if (return_type.is_string()) {\n                scoped_generator.append(R\"~~~(\n    if (retval.is_null())\n        return JS::js_null();\n)~~~\");\n            } else {\n                scoped_generator.append(R\"~~~(\n    if (!retval)\n        return JS::js_null();\n)~~~\");\n            }\n        }\n\n        if (return_type.is_string()) {\n            scoped_generator.append(R\"~~~(\n    return JS::js_string(vm, retval);\n)~~~\");\n        } else if (return_type.name == \"ArrayFromVector\") {\n            // FIXME: Remove this fake type hack once it's no longer needed.\n            //        Basically once we have NodeList we can throw this out.\n            scoped_generator.append(R\"~~~(\n    auto* new_array = JS::Array::create(global_object);\n    for (auto& element : retval)\n        new_array->indexed_properties().append(wrap(global_object, element));\n\n    return new_array;\n)~~~\");\n        } else if (return_type.name == \"boolean\" || return_type.name == \"double\") {\n            scoped_generator.append(R\"~~~(\n    return JS::Value(retval);\n)~~~\");\n        } else if (return_type.name == \"short\" || return_type.name == \"unsigned short\" || return_type.name == \"long\" || return_type.name == \"unsigned long\") {\n            scoped_generator.append(R\"~~~(\n    return JS::Value((i32)retval);\n)~~~\");\n        } else if (return_type.name == \"Uint8ClampedArray\") {\n            scoped_generator.append(R\"~~~(\n    return retval;\n)~~~\");\n        } else if (return_type.name == \"EventHandler\") {\n            scoped_generator.append(R\"~~~(\n    return retval.callback.cell();\n)~~~\");\n        } else {\n            scoped_generator.append(R\"~~~(\n    return wrap(global_object, const_cast<@return_type@&>(*retval));\n)~~~\");\n        }\n    };\n\n    for (auto& attribute : interface.attributes) {\n        auto attribute_generator = generator.fork();\n        attribute_generator.set(\"attribute.getter_callback\", attribute.getter_callback_name);\n        attribute_generator.set(\"attribute.setter_callback\", attribute.setter_callback_name);\n        attribute_generator.set(\"attribute.name:snakecase\", attribute.name.to_snakecase());\n\n        if (attribute.extended_attributes.contains(\"ImplementedAs\")) {\n            auto implemented_as = attribute.extended_attributes.get(\"ImplementedAs\").value();\n            attribute_generator.set(\"attribute.cpp_getter_name\", implemented_as);\n        } else {\n            attribute_generator.set(\"attribute.cpp_getter_name\", attribute.name.to_snakecase());\n        }\n\n        if (attribute.extended_attributes.contains(\"Reflect\")) {\n            auto attribute_name = attribute.extended_attributes.get(\"Reflect\").value();\n            if (attribute_name.is_null())\n                attribute_name = attribute.name;\n            attribute_name = make_input_acceptable_cpp(attribute_name);\n\n            attribute_generator.set(\"attribute.reflect_name\", attribute_name);\n        } else {\n            attribute_generator.set(\"attribute.reflect_name\", attribute.name.to_snakecase());\n        }\n\n        attribute_generator.append(R\"~~~(\nJS_DEFINE_NATIVE_GETTER(@prototype_class@::@attribute.getter_callback@)\n{\n    auto* impl = impl_from(vm, global_object);\n    if (!impl)\n        return {};\n)~~~\");\n\n        if (attribute.extended_attributes.contains(\"ReturnNullIfCrossOrigin\")) {\n            attribute_generator.append(R\"~~~(\n    if (!impl->may_access_from_origin(static_cast<WindowObject&>(global_object).origin()))\n        return JS::js_null();\n)~~~\");\n        }\n\n        if (attribute.extended_attributes.contains(\"Reflect\")) {\n            if (attribute.type.name != \"boolean\") {\n                attribute_generator.append(R\"~~~(\n    auto retval = impl->attribute(HTML::AttributeNames::@attribute.reflect_name@);\n)~~~\");\n            } else {\n                attribute_generator.append(R\"~~~(\n    auto retval = impl->has_attribute(HTML::AttributeNames::@attribute.reflect_name@);\n)~~~\");\n            }\n        } else {\n            attribute_generator.append(R\"~~~(\n    auto retval = impl->@attribute.cpp_getter_name@();\n)~~~\");\n        }\n\n        generate_return_statement(attribute.type);\n\n        attribute_generator.append(R\"~~~(\n}\n)~~~\");\n\n        if (!attribute.readonly) {\n            attribute_generator.append(R\"~~~(\nJS_DEFINE_NATIVE_SETTER(@prototype_class@::@attribute.setter_callback@)\n{\n    auto* impl = impl_from(vm, global_object);\n    if (!impl)\n        return;\n)~~~\");\n\n            generate_to_cpp(generator, attribute, \"value\", \"\", \"cpp_value\", true, attribute.extended_attributes.contains(\"LegacyNullToEmptyString\"));\n\n            if (attribute.extended_attributes.contains(\"Reflect\")) {\n                if (attribute.type.name != \"boolean\") {\n                    attribute_generator.append(R\"~~~(\n    impl->set_attribute(HTML::AttributeNames::@attribute.reflect_name@, cpp_value);\n)~~~\");\n                } else {\n                    attribute_generator.append(R\"~~~(\n    if (!cpp_value)\n        impl->remove_attribute(HTML::AttributeNames::@attribute.reflect_name@);\n    else\n        impl->set_attribute(HTML::AttributeNames::@attribute.reflect_name@, String::empty());\n)~~~\");\n                }\n            } else {\n                attribute_generator.append(R\"~~~(\n    impl->set_@attribute.name:snakecase@(cpp_value);\n)~~~\");\n            }\n\n            attribute_generator.append(R\"~~~(\n}\n)~~~\");\n        }\n    }\n\n    // Implementation: Functions\n    for (auto& function : interface.functions) {\n        auto function_generator = generator.fork();\n        function_generator.set(\"function.name\", function.name);\n        function_generator.set(\"function.name:snakecase\", function.name.to_snakecase());\n\n        if (function.extended_attributes.contains(\"ImplementedAs\")) {\n            auto implemented_as = function.extended_attributes.get(\"ImplementedAs\").value();\n            function_generator.set(\"function.cpp_name\", implemented_as);\n        } else {\n            function_generator.set(\"function.cpp_name\", function.name.to_snakecase());\n        }\n\n        function_generator.append(R\"~~~(\nJS_DEFINE_NATIVE_FUNCTION(@prototype_class@::@function.name:snakecase@)\n{\n    auto* impl = impl_from(vm, global_object);\n    if (!impl)\n        return {};\n)~~~\");\n\n        generate_argument_count_check(generator, function);\n\n        StringBuilder arguments_builder;\n        generate_arguments(generator, function.parameters, arguments_builder);\n        function_generator.set(\".arguments\", arguments_builder.string_view());\n\n        function_generator.append(R\"~~~(\n    auto result = throw_dom_exception_if_needed(vm, global_object, [&] { return impl->@function.cpp_name@(@.arguments@); });\n    if (should_return_empty(result))\n        return JS::Value();\n\n    [[maybe_unused]] auto retval = result.release_value();\n)~~~\");\n\n        generate_return_statement(function.return_type);\n\n        function_generator.append(R\"~~~(\n}\n)~~~\");\n    }\n\n    generator.append(R\"~~~(\n} // namespace Web::Bindings\n)~~~\");\n\n    outln(\"{}\", generator.as_string_view());\n}\nRefPtr<ImageData> ImageData::create_with_size(JS::GlobalObject& global_object, int width, int height)\n{\n    if (width <= 0 || height <= 0)\n        return nullptr;\n\n    if (width > 16384 || height > 16384)\n        return nullptr;\n\n    dbgln(\"Creating ImageData with {}x{}\", width, height);\n\n    auto* data = JS::Uint8ClampedArray::create(global_object, width * height * 4);\n    if (!data)\n        return nullptr;\n\n    auto data_handle = JS::make_handle(data);\n\n    auto bitmap = Gfx::Bitmap::create_wrapper(Gfx::BitmapFormat::RGBA8888, Gfx::IntSize(width, height), 1, width * sizeof(u32), (u32*)data->data());\n    if (!bitmap)\n        return nullptr;\n    return adopt_ref(*new ImageData(bitmap.release_nonnull(), move(data_handle)));\n}\n",
    "target": 1,
    "idx": 1034584,
    "stack_trace": [
      {
        "function_name": "Atomic<unsigned long,",
        "function_body": "    Atomic(T* val) noexcept\n        : m_value(val)\n    {\n    }",
        "file_path": "/src/serenity/Meta/Lagom/build/../../../AK/Atomic.h",
        "crashing_line": "",
        "crashing_line_number": 226
      },
      {
        "function_name": "lock",
        "function_body": "    ALWAYS_INLINE static FlatPtr lock(Atomic<FlatPtr>& atomic_var)\n    {\n        // This sets the lock bit atomically, preventing further modifications.\n        // This is important when e.g. copying a RefPtr where the source\n        // might be released and freed too quickly. This allows us\n        // to temporarily lock the pointer so we can add a reference, then\n        // unlock it\n        FlatPtr bits;\n        for (;;) {\n            bits = atomic_var.fetch_or(1, AK::MemoryOrder::memory_order_acq_rel);\n            if (!(bits & 1))\n                break;\n#ifdef KERNEL\n            Kernel::Processor::wait_check();\n#endif\n        }\n        VERIFY(!(bits & 1));\n        return bits;\n    }",
        "file_path": "/src/serenity/Meta/Lagom/build/../../../AK/RefPtr.h",
        "crashing_line": "            bits = atomic_var.fetch_or(1, AK::MemoryOrder::memory_order_acq_rel);",
        "crashing_line_number": 92
      },
      {
        "function_name": "add_ref_raw",
        "function_body": "    [[nodiscard]] ALWAYS_INLINE FlatPtr add_ref_raw() const\n    {\n#ifdef KERNEL\n        // We don't want to be pre-empted while we have the lock bit set\n        Kernel::ScopedCritical critical;\n#endif\n        // This prevents a race condition between thread A and B:\n        // 1. Thread A copies RefPtr, e.g. through assignment or copy constructor,\n        //    gets the pointer from source, but is pre-empted before adding\n        //    another reference\n        // 2. Thread B calls clear, leak_ref, or release_nonnull on source, and\n        //    then drops the last reference, causing the object to be deleted\n        // 3. Thread A finishes step #1 by attempting to add a reference to\n        //    the object that was already deleted in step #2\n        FlatPtr bits = PtrTraits::lock(m_bits);\n        if (T* ptr = PtrTraits::as_ptr(bits))\n            ptr->ref();\n        PtrTraits::unlock(m_bits, bits);\n        return bits;\n    }",
        "file_path": "/src/serenity/Meta/Lagom/build/../../../AK/RefPtr.h",
        "crashing_line": "        FlatPtr bits = PtrTraits::lock(m_bits);",
        "crashing_line_number": 412
      },
      {
        "function_name": "RefPtr",
        "function_body": "    RefPtr(const OwnPtr<U>&) = delete;",
        "file_path": "/src/serenity/Meta/Lagom/build/../../../AK/RefPtr.h",
        "crashing_line": "",
        "crashing_line_number": 170
      },
      {
        "function_name": "String",
        "function_body": "    String(NonnullRefPtr<StringImpl>&& impl)\n        : m_impl(move(impl))\n    {\n    }",
        "file_path": "/src/serenity/Meta/Lagom/build/../../../AK/String.h",
        "crashing_line": "",
        "crashing_line_number": 48
      },
      {
        "function_name": "abstract_relation",
        "function_body": "TriState abstract_relation(GlobalObject& global_object, bool left_first, Value lhs, Value rhs)\n{\n    Value x_primitive;\n    Value y_primitive;\n\n    if (left_first) {\n        x_primitive = lhs.to_primitive(global_object, Value::PreferredType::Number);\n        if (global_object.vm().exception())\n            return {};\n        y_primitive = rhs.to_primitive(global_object, Value::PreferredType::Number);\n        if (global_object.vm().exception())\n            return {};\n    } else {\n        y_primitive = lhs.to_primitive(global_object, Value::PreferredType::Number);\n        if (global_object.vm().exception())\n            return {};\n        x_primitive = rhs.to_primitive(global_object, Value::PreferredType::Number);\n        if (global_object.vm().exception())\n            return {};\n    }\n\n    if (x_primitive.is_string() && y_primitive.is_string()) {\n        auto x_string = x_primitive.as_string().string();\n        auto y_string = y_primitive.as_string().string();\n\n        Utf8View x_code_points { x_string };\n        Utf8View y_code_points { y_string };\n\n        if (x_code_points.starts_with(y_code_points))\n            return TriState::False;\n        if (y_code_points.starts_with(x_code_points))\n            return TriState::True;\n\n        for (auto k = x_code_points.begin(), l = y_code_points.begin();\n             k != x_code_points.end() && l != y_code_points.end();\n             ++k, ++l) {\n            if (*k != *l) {\n                if (*k < *l) {\n                    return TriState::True;\n                } else {\n                    return TriState::False;\n                }\n            }\n        }\n        VERIFY_NOT_REACHED();\n    }\n\n    if (x_primitive.is_bigint() && y_primitive.is_string()) {\n        auto& y_string = y_primitive.as_string().string();\n        if (!is_valid_bigint_value(y_string))\n            return TriState::Unknown;\n        if (x_primitive.as_bigint().big_integer() < Crypto::SignedBigInteger::from_base10(y_string))\n            return TriState::True;\n        else\n            return TriState::False;\n    }\n\n    if (x_primitive.is_string() && y_primitive.is_bigint()) {\n        auto& x_string = x_primitive.as_string().string();\n        if (!is_valid_bigint_value(x_string))\n            return TriState::Unknown;\n        if (Crypto::SignedBigInteger::from_base10(x_string) < y_primitive.as_bigint().big_integer())\n            return TriState::True;\n        else\n            return TriState::False;\n    }\n\n    auto x_numeric = x_primitive.to_numeric(global_object);\n    if (global_object.vm().exception())\n        return {};\n    auto y_numeric = y_primitive.to_numeric(global_object);\n    if (global_object.vm().exception())\n        return {};\n\n    if (x_numeric.is_nan() || y_numeric.is_nan())\n        return TriState::Unknown;\n\n    if (x_numeric.is_positive_infinity() || y_numeric.is_negative_infinity())\n        return TriState::False;\n\n    if (x_numeric.is_negative_infinity() || y_numeric.is_positive_infinity())\n        return TriState::True;\n\n    if (x_numeric.is_number() && y_numeric.is_number()) {\n        if (x_numeric.as_double() < y_numeric.as_double())\n            return TriState::True;\n        else\n            return TriState::False;\n    }\n\n    if (x_numeric.is_bigint() && y_numeric.is_bigint()) {\n        if (x_numeric.as_bigint().big_integer() < y_numeric.as_bigint().big_integer())\n            return TriState::True;\n        else\n            return TriState::False;\n    }\n\n    VERIFY((x_numeric.is_number() && y_numeric.is_bigint()) || (x_numeric.is_bigint() && y_numeric.is_number()));\n\n    bool x_lower_than_y;\n    if (x_numeric.is_number()) {\n        x_lower_than_y = x_numeric.is_integer()\n            ? Crypto::SignedBigInteger { x_numeric.to_i32(global_object) } < y_numeric.as_bigint().big_integer()\n            : (Crypto::SignedBigInteger { x_numeric.to_i32(global_object) } < y_numeric.as_bigint().big_integer() || Crypto::SignedBigInteger { x_numeric.to_i32(global_object) + 1 } < y_numeric.as_bigint().big_integer());\n    } else {\n        x_lower_than_y = y_numeric.is_integer()\n            ? x_numeric.as_bigint().big_integer() < Crypto::SignedBigInteger { y_numeric.to_i32(global_object) }\n            : (x_numeric.as_bigint().big_integer() < Crypto::SignedBigInteger { y_numeric.to_i32(global_object) } || x_numeric.as_bigint().big_integer() < Crypto::SignedBigInteger { y_numeric.to_i32(global_object) + 1 });\n    }\n    if (x_lower_than_y)\n        return TriState::True;\n    else\n        return TriState::False;\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/Runtime/Value.cpp",
        "crashing_line": "        auto x_string = x_primitive.as_string().string();",
        "crashing_line_number": 1231
      },
      {
        "function_name": "less_than",
        "function_body": "Value less_than(GlobalObject& global_object, Value lhs, Value rhs)\n{\n    TriState relation = abstract_relation(global_object, true, lhs, rhs);\n    if (relation == TriState::Unknown)\n        return Value(false);\n    return Value(relation == TriState::True);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/Runtime/Value.cpp",
        "crashing_line": "    TriState relation = abstract_relation(global_object, true, lhs, rhs);",
        "crashing_line_number": 656
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 591
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 558
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 558
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 558
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 558
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 558
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 2165
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "",
        "crashing_line_number": 109
      },
      {
        "function_name": "execute_statement",
        "function_body": "Value Interpreter::execute_statement(GlobalObject& global_object, const Statement& statement, ScopeType scope_type)\n{\n    if (!is<ScopeNode>(statement))\n        return statement.execute(*this, global_object);\n\n    auto& block = static_cast<const ScopeNode&>(statement);\n    enter_scope(block, scope_type, global_object);\n\n    for (auto& node : block.children()) {\n        auto value = node.execute(*this, global_object);\n        if (!value.is_empty())\n            vm().set_last_value({}, value);\n        if (vm().should_unwind()) {\n            if (!block.label().is_null() && vm().should_unwind_until(ScopeType::Breakable, block.label()))\n                vm().stop_unwind();\n            break;\n        }\n    }\n\n    if (scope_type == ScopeType::Function) {\n        bool did_return = vm().unwind_until() == ScopeType::Function;\n        if (!did_return)\n            vm().set_last_value({}, js_undefined());\n    }\n\n    if (vm().unwind_until() == scope_type)\n        vm().stop_unwind();\n\n    exit_scope(block);\n\n    return vm().last_value();\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/Interpreter.cpp",
        "crashing_line": "        auto value = node.execute(*this, global_object);",
        "crashing_line_number": 154
      },
      {
        "function_name": "execute",
        "function_body": "Value Program::execute(Interpreter& interpreter, GlobalObject& global_object) const\n{\n    InterpreterNodeScope node_scope { interpreter, *this };\n    return interpreter.execute_statement(global_object, *this, ScopeType::Block);\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/AST.cpp",
        "crashing_line": "    return interpreter.execute_statement(global_object, *this, ScopeType::Block);",
        "crashing_line_number": 91
      },
      {
        "function_name": "run",
        "function_body": "void Interpreter::run(GlobalObject& global_object, const Program& program)\n{\n    auto& vm = this->vm();\n    VERIFY(!vm.exception());\n\n    VM::InterpreterExecutionScope scope(*this);\n\n    vm.set_last_value({}, {});\n\n    CallFrame global_call_frame;\n    global_call_frame.current_node = &program;\n    global_call_frame.this_value = &global_object;\n    static FlyString global_execution_context_name = \"(global execution context)\";\n    global_call_frame.function_name = global_execution_context_name;\n    global_call_frame.scope = &global_object;\n    VERIFY(!vm.exception());\n    global_call_frame.is_strict_mode = program.is_strict_mode();\n    vm.push_call_frame(global_call_frame, global_object);\n    VERIFY(!vm.exception());\n    program.execute(*this, global_object);\n\n    // Whatever the promise jobs or on_call_stack_emptied do should not affect the effective\n    // 'last value'.\n    auto last_value = vm.last_value();\n\n    vm.pop_call_frame();\n\n    // At this point we may have already run any queued promise jobs via on_call_stack_emptied,\n    // in which case this is a no-op.\n    vm.run_queued_promise_jobs();\n\n    vm.set_last_value({}, last_value.value_or(js_undefined()));\n}",
        "file_path": "/src/serenity/Userland/Libraries/LibJS/Interpreter.cpp",
        "crashing_line": "    program.execute(*this, global_object);",
        "crashing_line_number": 58
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static UA_StatusCode\nremoveSession(UA_SessionManager *sm, session_list_entry *sentry) {\n    /* Deactivate the session */\n    sentry->session.activated = false;\n\n    /* Add a delayed callback to remove the session when the currently\n     * scheduled jobs have completed */\n    UA_StatusCode retval = UA_Server_delayedCallback(sm->server, removeSessionCallback, sentry);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING_SESSION(sm->server->config.logger, &sentry->session,\n                       \"Could not remove session with error code %s\",\n                       UA_StatusCode_name(retval));\n        return retval; /* Try again next time */\n    }\n\n    /* Detach the session and make the capacity available */\n    LIST_REMOVE(sentry, pointers);\n    UA_atomic_add(&sm->currentSessionCount, (UA_UInt32)-1);\n    return UA_STATUSCODE_GOOD;\n}\n",
    "target": 1,
    "idx": 1005577,
    "stack_trace": [
      {
        "function_name": "UA_Session_detachFromSecureChannel",
        "function_body": "void UA_Session_detachFromSecureChannel(UA_Session *session) {\n    if(!session->header.channel)\n        return;\n    session->header.channel = NULL;\n    LIST_REMOVE(&session->header, pointers);\n}",
        "file_path": "/src/open62541/src/server/ua_session.c",
        "crashing_line": "    LIST_REMOVE(&session->header, pointers);",
        "crashing_line_number": 87
      },
      {
        "function_name": "removeSessionCallback",
        "function_body": "static void\nremoveSessionCallback(UA_Server *server, void *entry) {\n    session_list_entry *sentry = (session_list_entry*)entry;\n    UA_Session_deleteMembersCleanup(&sentry->session, server);\n    UA_free(sentry);\n}",
        "file_path": "/src/open62541/src/server/ua_session_manager.c",
        "crashing_line": "    UA_Session_deleteMembersCleanup(&sentry->session, server);",
        "crashing_line_number": 29
      },
      {
        "function_name": "processDelayedCallbacks",
        "function_body": "static void\nprocessDelayedCallbacks(UA_Server *server) {\n    UA_DelayedCallback *dc, *dc_tmp;\n    SLIST_FOREACH_SAFE(dc, &server->delayedCallbacks, next, dc_tmp) {\n        SLIST_REMOVE(&server->delayedCallbacks, dc, UA_DelayedCallback, next);\n        dc->callback(server, dc->data);\n        UA_free(dc);\n    }\n}",
        "file_path": "/src/open62541/src/server/ua_server_worker.c",
        "crashing_line": "        dc->callback(server, dc->data);",
        "crashing_line_number": 180
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "GF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, u32 parent_type)\n{\n\tGF_Err e;\n\tGF_Box *a = NULL;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\t//always register boxes\n\t\tif (!parent->child_boxes) {\n\t\t\tparent->child_boxes = gf_list_new();\n\t\t\tif (!parent->child_boxes) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(parent->child_boxes, a);\n\t\tif (e) return e;\n\n\t\tif (parent->registry->add_rem_fn) {\n\t\t\te = parent->registry->add_rem_fn(parent, a, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\t\t//if the box is no longer present, consider it destroyed\n\t\t\t\tif (gf_list_find(parent->child_boxes, a) >=0) {\n\t\t\t\t\tgf_isom_box_del_parent(&parent->child_boxes, a);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n",
    "target": 1,
    "idx": 1032356,
    "stack_trace": [
      {
        "function_name": "gf_isom_box_del",
        "function_body": "GF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}",
        "file_path": "/src/gpac/src/isomedia/box_funcs.c",
        "crashing_line": "\tGF_List *child_boxes;",
        "crashing_line_number": 1799
      },
      {
        "function_name": "gf_isom_box_array_reset",
        "function_body": "void gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}",
        "file_path": "/src/gpac/src/isomedia/box_funcs.c",
        "crashing_line": "\t\tif (a) gf_isom_box_del(a);",
        "crashing_line_number": 348
      },
      {
        "function_name": "gf_isom_box_array_del",
        "function_body": "void gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}",
        "file_path": "/src/gpac/src/isomedia/box_funcs.c",
        "crashing_line": "\tgf_isom_box_array_reset(boxlist);",
        "crashing_line_number": 354
      },
      {
        "function_name": "gf_isom_box_del",
        "function_body": "GF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}",
        "file_path": "/src/gpac/src/isomedia/box_funcs.c",
        "crashing_line": "\t\ta_box_registry->del_fn(a);",
        "crashing_line_number": 1810
      },
      {
        "function_name": "gf_isom_box_array_reset",
        "function_body": "void gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}",
        "file_path": "/src/gpac/src/isomedia/box_funcs.c",
        "crashing_line": "\t\tif (a) gf_isom_box_del(a);",
        "crashing_line_number": 348
      },
      {
        "function_name": "gf_isom_box_array_del",
        "function_body": "void gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}",
        "file_path": "/src/gpac/src/isomedia/box_funcs.c",
        "crashing_line": "\tgf_isom_box_array_reset(boxlist);",
        "crashing_line_number": 354
      },
      {
        "function_name": "gf_isom_box_del",
        "function_body": "GF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}",
        "file_path": "/src/gpac/src/isomedia/box_funcs.c",
        "crashing_line": "\t\ta_box_registry->del_fn(a);",
        "crashing_line_number": 1810
      },
      {
        "function_name": "gf_isom_box_array_reset",
        "function_body": "void gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}",
        "file_path": "/src/gpac/src/isomedia/box_funcs.c",
        "crashing_line": "\t\tif (a) gf_isom_box_del(a);",
        "crashing_line_number": 348
      },
      {
        "function_name": "gf_isom_box_array_del",
        "function_body": "void gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}",
        "file_path": "/src/gpac/src/isomedia/box_funcs.c",
        "crashing_line": "\tgf_isom_box_array_reset(boxlist);",
        "crashing_line_number": 354
      },
      {
        "function_name": "gf_isom_delete_movie",
        "function_body": "void gf_isom_delete_movie(GF_ISOFile *mov)\n{\n\tif (!mov) return;\n\n\t//these are our two main files\n\tif (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->editFileMap) {\n\t\tgf_isom_datamap_del(mov->editFileMap);\n\t}\n\tif (mov->finalName) gf_free(mov->finalName);\n#endif\n\n\tgf_isom_box_array_del(mov->TopBoxes);\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_box_array_del(mov->moof_list);\n\tif (mov->mfra)\n\t\tgf_isom_box_del((GF_Box*)mov->mfra);\n\tif (mov->sidx_pts_store)\n\t\tgf_free(mov->sidx_pts_store);\n\tif (mov->sidx_pts_next_store)\n\t\tgf_free(mov->sidx_pts_next_store);\n\n\tif (mov->main_sidx)\n\t\tgf_isom_box_del((GF_Box*)mov->main_sidx);\n\n\tif (mov->block_buffer)\n\t\tgf_free(mov->block_buffer);\n#endif\n\tif (mov->last_producer_ref_time)\n\t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);\n\tif (mov->fileName) gf_free(mov->fileName);\n\tgf_free(mov);\n}",
        "file_path": "/src/gpac/src/isomedia/isom_intern.c",
        "crashing_line": "\tgf_isom_box_array_del(mov->TopBoxes);",
        "crashing_line_number": 999
      },
      {
        "function_name": "ExecuteFilesOnyByOne",
        "function_body": "static int ExecuteFilesOnyByOne(int argc, char **argv) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n  for (int i = 1; i < argc; i++) {\n\n    int fd = open(argv[i], O_RDONLY);\n    if (fd == -1) continue;\n    ssize_t length = read(fd, buf, MAX_FILE);\n    if (length > 0) {\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      LLVMFuzzerTestOneInput(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n  }\n\n  free(buf);\n  return 0;\n\n}",
        "file_path": "/src/aflplusplus/utils/aflpp_driver/aflpp_driver.c",
        "crashing_line": "      LLVMFuzzerTestOneInput(buf, length);",
        "crashing_line_number": 185
      },
      {
        "function_name": "main",
        "function_body": "int main(int argc, char **argv) {\n\n  printf(\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for afl++.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before re-spawning the process (default: \"\n      \"INT_MAX)\\n\"\n      \"======================================================\\n\",\n      argv[0], argv[0]);\n\n  if (getenv(\"AFL_GDB\")) {\n\n    char cmd[64];\n    snprintf(cmd, sizeof(cmd), \"cat /proc/%d/maps\", getpid());\n    system(cmd);\n    fprintf(stderr, \"DEBUG: aflpp_driver pid is %d\\n\", getpid());\n    sleep(1);\n\n  }\n\n  output_file = stderr;\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize) {\n\n    fprintf(stderr, \"Running LLVMFuzzerInitialize ...\\n\");\n    LLVMFuzzerInitialize(&argc, &argv);\n    fprintf(stderr, \"continue...\\n\");\n\n  }\n\n  // Do any other expensive one-time initialization here.\n\n  uint8_t dummy_input[64] = {0};\n  memcpy(dummy_input, (void *)AFL_PERSISTENT, sizeof(AFL_PERSISTENT));\n  memcpy(dummy_input + 32, (void *)AFL_DEFER_FORKSVR,\n         sizeof(AFL_DEFER_FORKSVR));\n  int N = INT_MAX;\n  if (argc == 2 && argv[1][0] == '-')\n    N = atoi(argv[1] + 1);\n  else if (argc == 2 && (N = atoi(argv[1])) > 0)\n    printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n  else if (argc > 1) {\n\n    __afl_sharedmem_fuzzing = 0;\n    __afl_manual_init();\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  }\n\n  assert(N > 0);\n\n  //  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n  __afl_manual_init();\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n\n#ifdef _DEBUG\n    fprintf(stderr, \"CLIENT crc: %016llx len: %u\\n\",\n            hash64(__afl_fuzz_ptr, *__afl_fuzz_len, 0xa5b35705),\n            *__afl_fuzz_len);\n    fprintf(stderr, \"RECV:\");\n    for (int i = 0; i < *__afl_fuzz_len; i++)\n      fprintf(stderr, \"%02x\", __afl_fuzz_ptr[i]);\n    fprintf(stderr, \"\\n\");\n#endif\n    if (*__afl_fuzz_len) {\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len);\n\n    }\n\n  }\n\n  printf(\"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n\n}",
        "file_path": "/src/aflplusplus/utils/aflpp_driver/aflpp_driver.c",
        "crashing_line": "    return ExecuteFilesOnyByOne(argc, argv);",
        "crashing_line_number": 247
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void zip_check_torrentzip(zip_t *za, const zip_cdir_t *cdir) {\n    zip_uint32_t crc_should;\n    char buf[8+1];\n    char *end;\n\n    if (cdir == NULL) {\n        return;\n    }\n\n    if (_zip_string_length(cdir->comment) != TORRENTZIP_SIGNATURE_LENGTH + TORRENTZIP_CRC_LENGTH\n        || strncmp((const char *)cdir->comment->raw, TORRENTZIP_SIGNATURE, TORRENTZIP_SIGNATURE_LENGTH) != 0)\n        return;\n\n    memcpy(buf, cdir->comment->raw + TORRENTZIP_SIGNATURE_LENGTH, TORRENTZIP_CRC_LENGTH);\n    buf[TORRENTZIP_CRC_LENGTH] = '\\0';\n    errno = 0;\n    crc_should = strtoul(buf, &end, 16);\n    if ((crc_should == UINT_MAX && errno != 0) || (end && *end)) {\n        return;\n    }\n\n    {\n        zip_stat_t st;\n        zip_source_t* src_window;\n        zip_source_t* src_crc;\n\n        zip_stat_init(&st);\n        st.valid |= ZIP_STAT_SIZE | ZIP_STAT_CRC;\n        st.size = cdir->size;\n        st.crc = crc_should;\n        if ((src_window = _zip_source_window_new(za->src, cdir->offset, cdir->size, &st, NULL, NULL, 0, NULL))  == NULL) {\n            return;\n        }\n        if ((src_crc = zip_source_crc_create(src_window, 1, NULL)) == NULL) {\n            zip_source_free(src_window);\n            return;\n        }\n        zip_source_free(src_window);\n        if (zip_source_open(src_crc) != 0) {\n            zip_source_free(src_crc);\n            return;\n        }\n        zip_uint8_t buffer[512];\n        while (zip_source_read(src_crc, buffer, sizeof(buffer)) > 0) {\n        }\n        if (zip_source_stat(src_crc, &st) < 0) {\n            zip_source_free(src_crc);\n            return;\n        }\n        zip_source_free(src_crc);\n    }\n\n    /* TODO: if check consistency, check cdir entries for valid values */\n    za->flags |= ZIP_AFL_IS_TORRENTZIP;\n}\n",
    "target": 1,
    "idx": 1055365,
    "stack_trace": [
      {
        "function_name": "zip_source_open",
        "function_body": "ZIP_EXTERN int\nzip_source_open(zip_source_t *src) {\n    if (src->source_closed) {\n        return -1;\n    }\n    if (src->write_state == ZIP_SOURCE_WRITE_REMOVED) {\n        zip_error_set(&src->error, ZIP_ER_DELETED, 0);\n        return -1;\n    }\n\n    if (ZIP_SOURCE_IS_OPEN_READING(src)) {\n        if ((zip_source_supports(src) & ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_SEEK)) == 0) {\n            zip_error_set(&src->error, ZIP_ER_INUSE, 0);\n            return -1;\n        }\n    }\n    else {\n        if (ZIP_SOURCE_IS_LAYERED(src)) {\n            if (zip_source_open(src->src) < 0) {\n                zip_error_set_from_source(&src->error, src->src);\n                return -1;\n            }\n        }\n\n        if (_zip_source_call(src, NULL, 0, ZIP_SOURCE_OPEN) < 0) {\n            if (ZIP_SOURCE_IS_LAYERED(src)) {\n                zip_source_close(src->src);\n            }\n            return -1;\n        }\n    }\n\n    src->eof = false;\n    src->had_read_error = false;\n    _zip_error_clear(&src->error);\n    src->bytes_read = 0;\n    src->open_count++;\n\n    return 0;\n}",
        "file_path": "/src/libzip/lib/zip_source_open.c",
        "crashing_line": "    if (src->source_closed) {",
        "crashing_line_number": 39
      },
      {
        "function_name": "zip_source_open",
        "function_body": "ZIP_EXTERN int\nzip_source_open(zip_source_t *src) {\n    if (src->source_closed) {\n        return -1;\n    }\n    if (src->write_state == ZIP_SOURCE_WRITE_REMOVED) {\n        zip_error_set(&src->error, ZIP_ER_DELETED, 0);\n        return -1;\n    }\n\n    if (ZIP_SOURCE_IS_OPEN_READING(src)) {\n        if ((zip_source_supports(src) & ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_SEEK)) == 0) {\n            zip_error_set(&src->error, ZIP_ER_INUSE, 0);\n            return -1;\n        }\n    }\n    else {\n        if (ZIP_SOURCE_IS_LAYERED(src)) {\n            if (zip_source_open(src->src) < 0) {\n                zip_error_set_from_source(&src->error, src->src);\n                return -1;\n            }\n        }\n\n        if (_zip_source_call(src, NULL, 0, ZIP_SOURCE_OPEN) < 0) {\n            if (ZIP_SOURCE_IS_LAYERED(src)) {\n                zip_source_close(src->src);\n            }\n            return -1;\n        }\n    }\n\n    src->eof = false;\n    src->had_read_error = false;\n    _zip_error_clear(&src->error);\n    src->bytes_read = 0;\n    src->open_count++;\n\n    return 0;\n}",
        "file_path": "/src/libzip/lib/zip_source_open.c",
        "crashing_line": "            if (zip_source_open(src->src) < 0) {",
        "crashing_line_number": 55
      },
      {
        "function_name": "zip_check_torrentzip",
        "function_body": "static void zip_check_torrentzip(zip_t *za, const zip_cdir_t *cdir) {\n    zip_uint32_t crc_should;\n    char buf[8+1];\n    char *end;\n\n    if (cdir == NULL) {\n        return;\n    }\n\n    if (_zip_string_length(cdir->comment) != TORRENTZIP_SIGNATURE_LENGTH + TORRENTZIP_CRC_LENGTH\n        || strncmp((const char *)cdir->comment->raw, TORRENTZIP_SIGNATURE, TORRENTZIP_SIGNATURE_LENGTH) != 0)\n        return;\n\n    memcpy(buf, cdir->comment->raw + TORRENTZIP_SIGNATURE_LENGTH, TORRENTZIP_CRC_LENGTH);\n    buf[TORRENTZIP_CRC_LENGTH] = '\\0';\n    errno = 0;\n    crc_should = strtoul(buf, &end, 16);\n    if ((crc_should == UINT_MAX && errno != 0) || (end && *end)) {\n        return;\n    }\n\n    {\n        zip_stat_t st;\n        zip_source_t* src_window;\n        zip_source_t* src_crc;\n\n        zip_stat_init(&st);\n        st.valid |= ZIP_STAT_SIZE | ZIP_STAT_CRC;\n        st.size = cdir->size;\n        st.crc = crc_should;\n        if ((src_window = _zip_source_window_new(za->src, cdir->offset, cdir->size, &st, NULL, NULL, 0, NULL))  == NULL) {\n            return;\n        }\n        if ((src_crc = zip_source_crc_create(src_window, 1, NULL)) == NULL) {\n            zip_source_free(src_window);\n            return;\n        }\n        if (zip_source_open(src_crc) != 0) {\n            zip_source_free(src_crc);\n            return;\n        }\n        zip_uint8_t buffer[512];\n        while (zip_source_read(src_crc, buffer, sizeof(buffer)) > 0) {\n        }\n        if (zip_source_stat(src_crc, &st) < 0) {\n            zip_source_free(src_crc);\n            return;\n        }\n        zip_source_free(src_crc);\n    }\n\n    /* TODO: if check consistency, check cdir entries for valid values */\n    za->flags |= ZIP_AFL_IS_TORRENTZIP;\n}",
        "file_path": "/src/libzip/lib/zip_open.c",
        "crashing_line": "            zip_source_free(src_crc);",
        "crashing_line_number": 932
      },
      {
        "function_name": "_zip_open",
        "function_body": "",
        "file_path": "/src/libzip/lib/zip_open.c",
        "crashing_line": "",
        "crashing_line_number": 187
      },
      {
        "function_name": "zip_open_from_source",
        "function_body": "",
        "file_path": "/src/libzip/lib/zip_open.c",
        "crashing_line": "",
        "crashing_line_number": 134
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_tree_children_destroy(parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 1,
    "idx": 1028459,
    "stack_trace": [
      {
        "function_name": "__cil_ordered_item_insert",
        "function_body": "",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_resolve_ast.c",
        "crashing_line": "",
        "crashing_line_number": 1244
      },
      {
        "function_name": "__cil_ordered_list_insert",
        "function_body": "int __cil_ordered_list_insert(struct cil_list *old, struct cil_list_item *ocurr, struct cil_list_item *nstart, struct cil_list_item *nstop)\n{\n\tstruct cil_list_item *ncurr = NULL;\n\n\tfor (ncurr = nstart; ncurr != nstop; ncurr = ncurr->next) {\n\t\tocurr = __cil_ordered_item_insert(old, ocurr, ncurr);\n\t\tif (ocurr == NULL) {\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\t}\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_resolve_ast.c",
        "crashing_line": "\tfor (ncurr = nstart; ncurr != nstop; ncurr = ncurr->next) {",
        "crashing_line_number": 1259
      },
      {
        "function_name": "__cil_ordered_lists_merge",
        "function_body": "int __cil_ordered_lists_merge(struct cil_list *old, struct cil_list *new)\n{\n\tstruct cil_list_item *omatch = NULL;\n\tstruct cil_list_item *ofirst = old->head;\n\tstruct cil_list_item *ocurr = NULL;\n\tstruct cil_list_item *oprev = NULL;\n\tstruct cil_list_item *nmatch = NULL;\n\tstruct cil_list_item *nfirst = new->head;\n\tstruct cil_list_item *ncurr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (nfirst == NULL) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (ofirst == NULL) {\n\t\t/* First list added */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, NULL);\n\t\treturn rc;\n\t}\n\n\t/* Find a match between the new list and the old one */\n\tfor (nmatch = nfirst; nmatch; nmatch = nmatch->next) {\n\t\tomatch = __cil_ordered_find_match(nmatch, ofirst);\n\t\tif (omatch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nmatch) {\n\t\t/* List cannot be merged yet */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst && omatch != ofirst) {\n\t\t/* Potential ordering conflict--try again later */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst) {\n\t\t/* Prepend the beginning of the new list up to the first match to the old list */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, nmatch);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* In the overlapping protion, add items from the new list not in the old list */\n\tncurr = nmatch->next;\n\tocurr = omatch->next;\n\toprev = omatch;\n\twhile (ncurr && ocurr) {\n\t\tif (ncurr->data == ocurr->data) {\n\t\t\toprev = ocurr;\n\t\t\tocurr = ocurr->next;\n\t\t\tncurr = ncurr->next;\n\t\t} else {\n\t\t\t/* Handle gap in old: old = (A C)  new = (A B C) */\n\t\t\tnmatch = __cil_ordered_find_match(ocurr, ncurr->next);\n\t\t\tif (nmatch) {\n\t\t\t\trc = __cil_ordered_list_insert(old, oprev, ncurr, nmatch);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\toprev = ocurr;\n\t\t\t\tocurr = ocurr->next;\n\t\t\t\tncurr = nmatch->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handle gap in new: old = (A B C)  new = (A C) */\n\t\t\tomatch = __cil_ordered_find_match(ncurr, ocurr->next);\n\t\t\tif (omatch) {\n\t\t\t\t/* Nothing to insert, just skip */\n\t\t\t\toprev = omatch;\n\t\t\t\tocurr = omatch->next;\n\t\t\t\tncurr = ncurr->next;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ncurr) {\n\t\t/* Add the rest of the items from the new list */\n\t\trc = __cil_ordered_list_insert(old, old->tail, ncurr, NULL);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_resolve_ast.c",
        "crashing_line": "\t\t/* First list added */",
        "crashing_line_number": 1295
      },
      {
        "function_name": "__cil_ordered_lists_merge_all",
        "function_body": "int __cil_ordered_lists_merge(struct cil_list *old, struct cil_list *new)\n{\n\tstruct cil_list_item *omatch = NULL;\n\tstruct cil_list_item *ofirst = old->head;\n\tstruct cil_list_item *ocurr = NULL;\n\tstruct cil_list_item *oprev = NULL;\n\tstruct cil_list_item *nmatch = NULL;\n\tstruct cil_list_item *nfirst = new->head;\n\tstruct cil_list_item *ncurr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (nfirst == NULL) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (ofirst == NULL) {\n\t\t/* First list added */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, NULL);\n\t\treturn rc;\n\t}\n\n\t/* Find a match between the new list and the old one */\n\tfor (nmatch = nfirst; nmatch; nmatch = nmatch->next) {\n\t\tomatch = __cil_ordered_find_match(nmatch, ofirst);\n\t\tif (omatch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nmatch) {\n\t\t/* List cannot be merged yet */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst && omatch != ofirst) {\n\t\t/* Potential ordering conflict--try again later */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst) {\n\t\t/* Prepend the beginning of the new list up to the first match to the old list */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, nmatch);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* In the overlapping protion, add items from the new list not in the old list */\n\tncurr = nmatch->next;\n\tocurr = omatch->next;\n\toprev = omatch;\n\twhile (ncurr && ocurr) {\n\t\tif (ncurr->data == ocurr->data) {\n\t\t\toprev = ocurr;\n\t\t\tocurr = ocurr->next;\n\t\t\tncurr = ncurr->next;\n\t\t} else {\n\t\t\t/* Handle gap in old: old = (A C)  new = (A B C) */\n\t\t\tnmatch = __cil_ordered_find_match(ocurr, ncurr->next);\n\t\t\tif (nmatch) {\n\t\t\t\trc = __cil_ordered_list_insert(old, oprev, ncurr, nmatch);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\toprev = ocurr;\n\t\t\t\tocurr = ocurr->next;\n\t\t\t\tncurr = nmatch->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handle gap in new: old = (A B C)  new = (A C) */\n\t\t\tomatch = __cil_ordered_find_match(ncurr, ocurr->next);\n\t\t\tif (omatch) {\n\t\t\t\t/* Nothing to insert, just skip */\n\t\t\t\toprev = omatch;\n\t\t\t\tocurr = omatch->next;\n\t\t\t\tncurr = ncurr->next;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ncurr) {\n\t\t/* Add the rest of the items from the new list */\n\t\trc = __cil_ordered_list_insert(old, old->tail, ncurr, NULL);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_resolve_ast.c",
        "crashing_line": "",
        "crashing_line_number": 1423
      },
      {
        "function_name": "cil_resolve_ast",
        "function_body": "int __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_resolve_ast.c",
        "crashing_line": "",
        "crashing_line_number": 4047
      },
      {
        "function_name": "cil_compile",
        "function_body": "int cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil.c",
        "crashing_line": "\trc = cil_resolve_ast(db, db->ast->root);",
        "crashing_line_number": 550
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n",
    "target": 1,
    "idx": 1044597,
    "stack_trace": [
      {
        "function_name": "luaH_newkey",
        "function_body": "void luaH_newkey (lua_State *L, Table *t, const TValue *key, TValue *value) {\n  Node *mp;\n  TValue aux;\n  if (l_unlikely(ttisnil(key)))\n    luaG_runerror(L, \"table index is nil\");\n  else if (ttisfloat(key)) {\n    lua_Number f = fltvalue(key);\n    lua_Integer k;\n    if (luaV_flttointeger(f, &k, F2Ieq)) {  /* does key fit in an integer? */\n      setivalue(&aux, k);\n      key = &aux;  /* insert it as an integer */\n    }\n    else if (l_unlikely(luai_numisnan(f)))\n      luaG_runerror(L, \"table index is NaN\");\n  }\n  if (ttisnil(value))\n    return;  /* do not insert nil values */\n  mp = mainpositionTV(t, key);\n  if (!isempty(gval(mp)) || isdummy(t)) {  /* main position is taken? */\n    Node *othern;\n    Node *f = getfreepos(t);  /* get a free place */\n    if (f == NULL) {  /* cannot find a free place? */\n      rehash(L, t, key);  /* grow table */\n      /* whatever called 'newkey' takes care of TM cache */\n      luaH_set(L, t, key, value);  /* insert key into grown table */\n      return;\n    }\n    lua_assert(!isdummy(t));\n    othern = mainpositionfromnode(t, mp);\n    if (othern != mp) {  /* is colliding node out of its main position? */\n      /* yes; move colliding node into free position */\n      while (othern + gnext(othern) != mp)  /* find previous */\n        othern += gnext(othern);\n      gnext(othern) = cast_int(f - othern);  /* rechain to point to 'f' */\n      *f = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      if (gnext(mp) != 0) {\n        gnext(f) += cast_int(mp - f);  /* correct 'next' */\n        gnext(mp) = 0;  /* now 'mp' is free */\n      }\n      setempty(gval(mp));\n    }\n    else {  /* colliding node is in its own main position */\n      /* new node will go into free position */\n      if (gnext(mp) != 0)\n        gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position */\n      else lua_assert(gnext(f) == 0);\n      gnext(mp) = cast_int(f - mp);\n      mp = f;\n    }\n  }\n  setnodekey(L, mp, key);\n  luaC_barrierback(L, obj2gco(t), key);\n  lua_assert(isempty(gval(mp)));\n  setobj2t(L, gval(mp), value);\n}",
        "file_path": "/src/lua/ltable.c",
        "crashing_line": "  if (ttisnil(value))",
        "crashing_line_number": 678
      },
      {
        "function_name": "luaV_finishset",
        "function_body": "void luaV_finishset (lua_State *L, const TValue *t, TValue *key,\n                     TValue *val, const TValue *slot) {\n  int loop;  /* counter to avoid infinite loops */\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    const TValue *tm;  /* '__newindex' metamethod */\n    if (slot != NULL) {  /* is 't' a table? */\n      Table *h = hvalue(t);  /* save 't' table */\n      lua_assert(isempty(slot));  /* slot must be empty */\n      tm = fasttm(L, h->metatable, TM_NEWINDEX);  /* get metamethod */\n      if (tm == NULL) {  /* no metamethod? */\n        luaH_finishset(L, h, key, slot, val);  /* set new value */\n        invalidateTMcache(h);\n        luaC_barrierback(L, obj2gco(h), val);\n        return;\n      }\n      /* else will try the metamethod */\n    }\n    else {  /* not a table; check metamethod */\n      tm = luaT_gettmbyobj(L, t, TM_NEWINDEX);\n      if (l_unlikely(notm(tm)))\n        luaG_typeerror(L, t, \"index\");\n    }\n    /* try the metamethod */\n    if (ttisfunction(tm)) {\n      luaT_callTM(L, tm, t, key, val);\n      return;\n    }\n    t = tm;  /* else repeat assignment over 'tm' */\n    if (luaV_fastget(L, t, key, slot, luaH_get)) {\n      luaV_finishfastset(L, t, slot, val);\n      return;  /* done */\n    }\n    /* else 'return luaV_finishset(L, t, key, val, slot)' (loop) */\n  }\n  luaG_runerror(L, \"'__newindex' chain too long; possible loop\");\n}",
        "file_path": "/src/lua/lvm.c",
        "crashing_line": "        luaH_finishset(L, h, key, slot, val);  /* set new value */",
        "crashing_line_number": 340
      },
      {
        "function_name": "luaV_execute",
        "function_body": "void luaV_execute (lua_State *L, CallInfo *ci) {\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n  const Instruction *pc;\n  int trap;\n#if LUA_USE_JUMPTABLE\n#include \"ljumptab.h\"\n#endif\n startfunc:\n  trap = L->hookmask;\n returning:  /* trap already set */\n  cl = clLvalue(s2v(ci->func));\n  k = cl->p->k;\n  pc = ci->u.l.savedpc;\n  if (l_unlikely(trap)) {\n    if (pc == cl->p->code) {  /* first instruction (not resuming)? */\n      if (cl->p->is_vararg)\n        trap = 0;  /* hooks will start after VARARGPREP instruction */\n      else  /* check 'call' hook */\n        luaD_hookcall(L, ci);\n    }\n    ci->u.l.trap = 1;  /* assume trap is on, for now */\n  }\n  base = ci->func + 1;\n  /* main loop of interpreter */\n  for (;;) {\n    Instruction i;  /* instruction being executed */\n    StkId ra;  /* instruction's A register */\n    vmfetch();\n    #if 0\n      /* low-level line tracing for debugging Lua */\n      printf(\"line: %d\\n\", luaG_getfuncline(cl->p, pcRel(pc, cl->p)));\n    #endif\n    lua_assert(base == ci->func + 1);\n    lua_assert(base <= L->top && L->top < L->stack_last);\n    /* invalidate top for instructions not expecting it */\n    lua_assert(isIT(i) || (cast_void(L->top = base), 1));\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE) {\n        setobjs2s(L, ra, RB(i));\n        vmbreak;\n      }\n      vmcase(OP_LOADI) {\n        lua_Integer b = GETARG_sBx(i);\n        setivalue(s2v(ra), b);\n        vmbreak;\n      }\n      vmcase(OP_LOADF) {\n        int b = GETARG_sBx(i);\n        setfltvalue(s2v(ra), cast_num(b));\n        vmbreak;\n      }\n      vmcase(OP_LOADK) {\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADKX) {\n        TValue *rb;\n        rb = k + GETARG_Ax(*pc); pc++;\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADFALSE) {\n        setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LFALSESKIP) {\n        setbfvalue(s2v(ra));\n        pc++;  /* skip next instruction */\n        vmbreak;\n      }\n      vmcase(OP_LOADTRUE) {\n        setbtvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LOADNIL) {\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(s2v(ra++));\n        } while (b--);\n        vmbreak;\n      }\n      vmcase(OP_GETUPVAL) {\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v);\n        vmbreak;\n      }\n      vmcase(OP_SETUPVAL) {\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v, s2v(ra));\n        luaC_barrier(L, uv, s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_GETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_B(i)]->v;\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, upval, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETTABLE) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = vRC(i);\n        lua_Unsigned n;\n        if (ttisinteger(rc)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))\n            : luaV_fastget(L, rb, rc, slot, luaH_get)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETI) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        int c = GETARG_C(i);\n        if (luaV_fastgeti(L, rb, c, slot)) {\n          setobj2s(L, ra, slot);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishget(L, rb, &key, ra, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_GETFIELD) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_A(i)]->v;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, upval, slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, upval, rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABLE) {\n        const TValue *slot;\n        TValue *rb = vRB(i);  /* key (table is in 'ra') */\n        TValue *rc = RKC(i);  /* value */\n        lua_Unsigned n;\n        if (ttisinteger(rb)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))\n            : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETI) {\n        const TValue *slot;\n        int c = GETARG_B(i);\n        TValue *rc = RKC(i);\n        if (luaV_fastgeti(L, s2v(ra), c, slot)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishset(L, s2v(ra), &key, rc, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETFIELD) {\n        const TValue *slot;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_NEWTABLE) {\n        int b = GETARG_B(i);  /* log2(hash size) + 1 */\n        int c = GETARG_C(i);  /* array size */\n        Table *t;\n        if (b > 0)\n          b = 1 << (b - 1);  /* size is 2^(b - 1) */\n        lua_assert((!TESTARG_k(i)) == (GETARG_Ax(*pc) == 0));\n        if (TESTARG_k(i))  /* non-zero extra argument? */\n          c += GETARG_Ax(*pc) * (MAXARG_C + 1);  /* add it to size */\n        pc++;  /* skip extra argument */\n        L->top = ra + 1;  /* correct top in case of emergency GC */\n        t = luaH_new(L);  /* memory allocation */\n        sethvalue2s(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, c, b);  /* idem */\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_SELF) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        setobj2s(L, ra + 1, rb);\n        if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_ADDI) {\n        op_arithI(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_ADDK) {\n        op_arithK(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUBK) {\n        op_arithK(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MULK) {\n        op_arithK(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MODK) {\n        op_arithK(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POWK) {\n        op_arithfK(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIVK) {\n        op_arithfK(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIVK) {\n        op_arithK(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BANDK) {\n        op_bitwiseK(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BORK) {\n        op_bitwiseK(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXORK) {\n        op_bitwiseK(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHRI) {\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ib, -ic));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SHLI) {\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ic, ib));\n        }\n        vmbreak;\n      }\n      vmcase(OP_ADD) {\n        op_arith(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUB) {\n        op_arith(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MUL) {\n        op_arith(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MOD) {\n        op_arith(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POW) {\n        op_arithf(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIV) {  /* float division (always with floats) */\n        op_arithf(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIV) {  /* floor division */\n        op_arith(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BAND) {\n        op_bitwise(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BOR) {\n        op_bitwise(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXOR) {\n        op_bitwise(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHR) {\n        op_bitwise(L, luaV_shiftr);\n        vmbreak;\n      }\n      vmcase(OP_SHL) {\n        op_bitwise(L, luaV_shiftl);\n        vmbreak;\n      }\n      vmcase(OP_MMBIN) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *rb = vRB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        StkId result = RA(pi);\n        lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);\n        Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINI) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        int imm = GETARG_sB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINK) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *imm = KB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_UNM) {\n        TValue *rb = vRB(i);\n        lua_Number nb;\n        if (ttisinteger(rb)) {\n          lua_Integer ib = ivalue(rb);\n          setivalue(s2v(ra), intop(-, 0, ib));\n        }\n        else if (tonumberns(rb, nb)) {\n          setfltvalue(s2v(ra), luai_numunm(L, nb));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));\n        vmbreak;\n      }\n      vmcase(OP_BNOT) {\n        TValue *rb = vRB(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));\n        vmbreak;\n      }\n      vmcase(OP_NOT) {\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb))\n          setbtvalue(s2v(ra));\n        else\n          setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LEN) {\n        Protect(luaV_objlen(L, ra, vRB(i)));\n        vmbreak;\n      }\n      vmcase(OP_CONCAT) {\n        int n = GETARG_B(i);  /* number of elements to concatenate */\n        L->top = ra + n;  /* mark the end of concat operands */\n        ProtectNT(luaV_concat(L, n));\n        checkGC(L, L->top); /* 'luaV_concat' ensures correct top */\n        vmbreak;\n      }\n      vmcase(OP_CLOSE) {\n        Protect(luaF_close(L, ra, LUA_OK, 1));\n        vmbreak;\n      }\n      vmcase(OP_TBC) {\n        /* create new to-be-closed upvalue */\n        halfProtect(luaF_newtbcupval(L, ra));\n        vmbreak;\n      }\n      vmcase(OP_JMP) {\n        dojump(ci, i, 0);\n        vmbreak;\n      }\n      vmcase(OP_EQ) {\n        int cond;\n        TValue *rb = vRB(i);\n        Protect(cond = luaV_equalobj(L, s2v(ra), rb));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LT) {\n        op_order(L, l_lti, LTnum, lessthanothers);\n        vmbreak;\n      }\n      vmcase(OP_LE) {\n        op_order(L, l_lei, LEnum, lessequalothers);\n        vmbreak;\n      }\n      vmcase(OP_EQK) {\n        TValue *rb = KB(i);\n        /* basic types do not use '__eq'; we can use raw equality */\n        int cond = luaV_rawequalobj(s2v(ra), rb);\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_EQI) {\n        int cond;\n        int im = GETARG_sB(i);\n        if (ttisinteger(s2v(ra)))\n          cond = (ivalue(s2v(ra)) == im);\n        else if (ttisfloat(s2v(ra)))\n          cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));\n        else\n          cond = 0;  /* other types cannot be equal to a number */\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LTI) {\n        op_orderI(L, l_lti, luai_numlt, 0, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_LEI) {\n        op_orderI(L, l_lei, luai_numle, 0, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_GTI) {\n        op_orderI(L, l_gti, luai_numgt, 1, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_GEI) {\n        op_orderI(L, l_gei, luai_numge, 1, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_TEST) {\n        int cond = !l_isfalse(s2v(ra));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_TESTSET) {\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb) == GETARG_k(i))\n          pc++;\n        else {\n          setobj2s(L, ra, rb);\n          donextjump(ci);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CALL) {\n        CallInfo *newci;\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0)  /* fixed number of arguments? */\n          L->top = ra + b;  /* top signals number of arguments */\n        /* else previous instruction set top */\n        savepc(L);  /* in case of errors */\n        if ((newci = luaD_precall(L, ra, nresults)) == NULL)\n          updatetrap(ci);  /* C call; nothing else to be done */\n        else {  /* Lua call: run function in this same C frame */\n          ci = newci;\n          goto startfunc;\n        }\n        vmbreak;\n      }\n      vmcase(OP_TAILCALL) {\n        int b = GETARG_B(i);  /* number of arguments + 1 (function) */\n        int n;  /* number of results when calling a C function */\n        int nparams1 = GETARG_C(i);\n        /* delta is virtual 'func' - real 'func' (vararg functions) */\n        int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;\n        if (b != 0)\n          L->top = ra + b;\n        else  /* previous instruction set top */\n          b = cast_int(L->top - ra);\n        savepc(ci);  /* several calls here can raise errors */\n        if (TESTARG_k(i)) {\n          luaF_closeupval(L, base);  /* close upvalues from current call */\n          lua_assert(L->tbclist < base);  /* no pending tbc variables */\n          lua_assert(base == ci->func + 1);\n        }\n        if ((n = luaD_pretailcall(L, ci, ra, b, delta)) < 0)  /* Lua function? */\n          goto startfunc;  /* execute the callee */\n        else {  /* C function? */\n          ci->func -= delta;  /* restore 'func' (if vararg) */\n          luaD_poscall(L, ci, n);  /* finish caller */\n          updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n          goto ret;  /* caller returns after the tail call */\n        }\n      }\n      vmcase(OP_RETURN) {\n        int n = GETARG_B(i) - 1;  /* number of results */\n        int nparams1 = GETARG_C(i);\n        if (n < 0)  /* not fixed? */\n          n = cast_int(L->top - ra);  /* get what is available */\n        savepc(ci);\n        if (TESTARG_k(i)) {  /* may there be open upvalues? */\n          ci->u2.nres = n;  /* save number of returns */\n          if (L->top < ci->top)\n            L->top = ci->top;\n          luaF_close(L, base, CLOSEKTOP, 1);\n          updatetrap(ci);\n          updatestack(ci);\n        }\n        if (nparams1)  /* vararg function? */\n          ci->func -= ci->u.l.nextraargs + nparams1;\n        L->top = ra + n;  /* set call for 'luaD_poscall' */\n        luaD_poscall(L, ci, n);\n        updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n        goto ret;\n      }\n      vmcase(OP_RETURN0) {\n        if (l_unlikely(L->hookmask)) {\n          L->top = ra;\n          savepc(ci);\n          luaD_poscall(L, ci, 0);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres;\n          L->ci = ci->previous;  /* back to caller */\n          L->top = base - 1;\n          for (nres = ci->nresults; l_unlikely(nres > 0); nres--)\n            setnilvalue(s2v(L->top++));  /* all results are nil */\n        }\n        goto ret;\n      }\n      vmcase(OP_RETURN1) {\n        if (l_unlikely(L->hookmask)) {\n          L->top = ra + 1;\n          savepc(ci);\n          luaD_poscall(L, ci, 1);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          if (nres == 0)\n            L->top = base - 1;  /* asked for no results */\n          else {\n            setobjs2s(L, base - 1, ra);  /* at least this result */\n            L->top = base;\n            for (; l_unlikely(nres > 1); nres--)\n              setnilvalue(s2v(L->top++));  /* complete missing results */\n          }\n        }\n       ret:  /* return from a Lua function */\n        if (ci->callstatus & CIST_FRESH)\n          return;  /* end this frame */\n        else {\n          ci = ci->previous;\n          goto returning;  /* continue running caller in this frame */\n        }\n      }\n      vmcase(OP_FORLOOP) {\n        if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */\n          lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));\n          if (count > 0) {  /* still more iterations? */\n            lua_Integer step = ivalue(s2v(ra + 2));\n            lua_Integer idx = ivalue(s2v(ra));  /* internal index */\n            chgivalue(s2v(ra + 1), count - 1);  /* update counter */\n            idx = intop(+, idx, step);  /* add step to index */\n            chgivalue(s2v(ra), idx);  /* update internal index */\n            setivalue(s2v(ra + 3), idx);  /* and control variable */\n            pc -= GETARG_Bx(i);  /* jump back */\n          }\n        }\n        else if (floatforloop(ra))  /* float loop */\n          pc -= GETARG_Bx(i);  /* jump back */\n        updatetrap(ci);  /* allows a signal to break the loop */\n        vmbreak;\n      }\n      vmcase(OP_FORPREP) {\n        savestate(L, ci);  /* in case of errors */\n        if (forprep(L, ra))\n          pc += GETARG_Bx(i) + 1;  /* skip the loop */\n        vmbreak;\n      }\n      vmcase(OP_TFORPREP) {\n        /* create to-be-closed upvalue (if needed) */\n        halfProtect(luaF_newtbcupval(L, ra + 3));\n        pc += GETARG_Bx(i);\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));\n        goto l_tforcall;\n      }\n      vmcase(OP_TFORCALL) {\n       l_tforcall:\n        /* 'ra' has the iterator function, 'ra + 1' has the state,\n           'ra + 2' has the control variable, and 'ra + 3' has the\n           to-be-closed variable. The call will use the stack after\n           these values (starting at 'ra + 4')\n        */\n        /* push function, state, and control variable */\n        memcpy(ra + 4, ra, 3 * sizeof(*ra));\n        L->top = ra + 4 + 3;\n        ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */\n        updatestack(ci);  /* stack may have changed */\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));\n        goto l_tforloop;\n      }\n      vmcase(OP_TFORLOOP) {\n        l_tforloop:\n        if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */\n          setobjs2s(L, ra + 2, ra + 4);  /* save control variable */\n          pc -= GETARG_Bx(i);  /* jump back */\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETLIST) {\n        int n = GETARG_B(i);\n        unsigned int last = GETARG_C(i);\n        Table *h = hvalue(s2v(ra));\n        if (n == 0)\n          n = cast_int(L->top - ra) - 1;  /* get up to the top */\n        else\n          L->top = ci->top;  /* correct top in case of emergency GC */\n        last += n;\n        if (TESTARG_k(i)) {\n          last += GETARG_Ax(*pc) * (MAXARG_C + 1);\n          pc++;\n        }\n        if (last > luaH_realasize(h))  /* needs more space? */\n          luaH_resizearray(L, h, last);  /* preallocate it at once */\n        for (; n > 0; n--) {\n          TValue *val = s2v(ra + n);\n          setobj2t(L, &h->array[last - 1], val);\n          last--;\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CLOSURE) {\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        halfProtect(pushclosure(L, p, cl->upvals, base, ra));\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_VARARG) {\n        int n = GETARG_C(i) - 1;  /* required results */\n        Protect(luaT_getvarargs(L, ci, ra, n));\n        vmbreak;\n      }\n      vmcase(OP_VARARGPREP) {\n        ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));\n        if (l_unlikely(trap)) {  /* previous \"Protect\" updated trap */\n          luaD_hookcall(L, ci);\n          L->oldpc = 1;  /* next opcode will be seen as a \"new\" line */\n        }\n        updatebase(ci);  /* function has new base after adjustment */\n        vmbreak;\n      }\n      vmcase(OP_EXTRAARG) {\n        lua_assert(0);\n        vmbreak;\n      }\n    }\n  }\n}",
        "file_path": "/src/lua/lvm.c",
        "crashing_line": "          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));",
        "crashing_line_number": 1336
      },
      {
        "function_name": "ccall",
        "function_body": "l_sinline void ccall (lua_State *L, StkId func, int nResults, int inc) {\n  CallInfo *ci;\n  L->nCcalls += inc;\n  if (l_unlikely(getCcalls(L) >= LUAI_MAXCCALLS))\n    luaE_checkcstack(L);\n  if ((ci = luaD_precall(L, func, nResults)) != NULL) {  /* Lua function? */\n    ci->callstatus = CIST_FRESH;  /* mark that it is a \"fresh\" execute */\n    luaV_execute(L, ci);  /* call it */\n  }\n  L->nCcalls -= inc;\n}",
        "file_path": "/src/lua/ldo.c",
        "crashing_line": "    luaV_execute(L, ci);  /* call it */",
        "crashing_line_number": 609
      },
      {
        "function_name": "luaD_callnoyield",
        "function_body": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  ccall(L, func, nResults, nyci);\n}",
        "file_path": "/src/lua/ldo.c",
        "crashing_line": "  ccall(L, func, nResults, nyci);",
        "crashing_line_number": 627
      },
      {
        "function_name": "luaD_rawrunprotected",
        "function_body": "int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  l_uint32 oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  /* chain new error handler */\n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;  /* restore old error handler */\n  L->nCcalls = oldnCcalls;\n  return lj.status;\n}",
        "file_path": "/src/lua/ldo.c",
        "crashing_line": "  LUAI_TRY(L, &lj,",
        "crashing_line_number": 144
      },
      {
        "function_name": "luaD_pcall",
        "function_body": "int luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (l_unlikely(status != LUA_OK)) {  /* an error occurred? */\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    status = luaD_closeprotected(L, old_top, status);\n    luaD_seterrorobj(L, status, restorestack(L, old_top));\n    luaD_shrinkstack(L);   /* restore stack size in case of overflow */\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}",
        "file_path": "/src/lua/ldo.c",
        "crashing_line": "  status = luaD_rawrunprotected(L, func, u);",
        "crashing_line_number": 926
      },
      {
        "function_name": "lua_pcallk",
        "function_body": "LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,\n                        lua_KContext ctx, lua_KFunction k) {\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0;\n  else {\n    StkId o = index2stack(L, errfunc);\n    api_check(L, ttisfunction(s2v(o)), \"error handler must be a function\");\n    func = savestack(L, o);\n  }\n  c.func = L->top - (nargs+1);  /* function to be called */\n  if (k == NULL || !yieldable(L)) {  /* no continuation or no yieldable? */\n    c.nresults = nresults;  /* do a 'conventional' protected call */\n    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);\n  }\n  else {  /* prepare continuation (call is already protected by 'resume') */\n    CallInfo *ci = L->ci;\n    ci->u.c.k = k;  /* save continuation */\n    ci->u.c.ctx = ctx;  /* save context */\n    /* save information for error recovery */\n    ci->u2.funcidx = cast_int(savestack(L, c.func));\n    ci->u.c.old_errfunc = L->errfunc;\n    L->errfunc = func;\n    setoah(ci->callstatus, L->allowhook);  /* save value of 'allowhook' */\n    ci->callstatus |= CIST_YPCALL;  /* function can do error recovery */\n    luaD_call(L, c.func, nresults);  /* do the call */\n    ci->callstatus &= ~CIST_YPCALL;\n    L->errfunc = ci->u.c.old_errfunc;\n    status = LUA_OK;  /* if it is here, there were no errors */\n  }\n  adjustresults(L, nresults);\n  lua_unlock(L);\n  return status;\n}",
        "file_path": "/src/lua/lapi.c",
        "crashing_line": "    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);",
        "crashing_line_number": 1067
      },
      {
        "function_name": "ExecuteFilesOnyByOne",
        "function_body": "static int ExecuteFilesOnyByOne(int argc, char **argv) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n  for (int i = 1; i < argc; i++) {\n\n    int fd = open(argv[i], O_RDONLY);\n    if (fd == -1) continue;\n    ssize_t length = read(fd, buf, MAX_FILE);\n    if (length > 0) {\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      LLVMFuzzerTestOneInput(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n  }\n\n  free(buf);\n  return 0;\n\n}",
        "file_path": "/src/aflplusplus/utils/aflpp_driver/aflpp_driver.c",
        "crashing_line": "      LLVMFuzzerTestOneInput(buf, length);",
        "crashing_line_number": 185
      },
      {
        "function_name": "main",
        "function_body": "int main(int argc, char **argv) {\n\n  printf(\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for afl++.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before re-spawning the process (default: \"\n      \"1000)\\n\"\n      \"======================================================\\n\",\n      argv[0], argv[0]);\n\n  output_file = stderr;\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize) {\n\n    fprintf(stderr, \"Running LLVMFuzzerInitialize ...\\n\");\n    LLVMFuzzerInitialize(&argc, &argv);\n    fprintf(stderr, \"continue...\\n\");\n\n  }\n\n  // Do any other expensive one-time initialization here.\n\n  uint8_t dummy_input[64] = {0};\n  memcpy(dummy_input, (void *)AFL_PERSISTENT, sizeof(AFL_PERSISTENT));\n  memcpy(dummy_input + 32, (void *)AFL_DEFER_FORKSVR,\n         sizeof(AFL_DEFER_FORKSVR));\n  int N = INT_MAX;\n  if (argc == 2 && argv[1][0] == '-')\n    N = atoi(argv[1] + 1);\n  else if (argc == 2 && (N = atoi(argv[1])) > 0)\n    printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n  else if (argc > 1) {\n\n    __afl_sharedmem_fuzzing = 0;\n    __afl_manual_init();\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  }\n\n  assert(N > 0);\n\n  //  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n  __afl_manual_init();\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n\n#ifdef _DEBUG\n    fprintf(stderr, \"CLIENT crc: %016llx len: %u\\n\",\n            hash64(__afl_fuzz_ptr, *__afl_fuzz_len, 0xa5b35705),\n            *__afl_fuzz_len);\n    fprintf(stderr, \"RECV:\");\n    for (int i = 0; i < *__afl_fuzz_len; i++)\n      fprintf(stderr, \"%02x\", __afl_fuzz_ptr[i]);\n    fprintf(stderr, \"\\n\");\n#endif\n    if (*__afl_fuzz_len) {\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len);\n\n    }\n\n  }\n\n  printf(\"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n\n}",
        "file_path": "/src/aflplusplus/utils/aflpp_driver/aflpp_driver.c",
        "crashing_line": "    return ExecuteFilesOnyByOne(argc, argv);",
        "crashing_line_number": 237
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "ZEND_API zend_result ZEND_FASTCALL div_function(zval *result, zval *op1, zval *op2) /* {{{ */\n{\n\tZVAL_DEREF(op1);\n\tZVAL_DEREF(op2);\n\n\tint retval = div_function_base(result, op1, op2);\n\tif (EXPECTED(retval == SUCCESS)) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (UNEXPECTED(retval == DIV_BY_ZERO)) {\n\t\tgoto div_by_zero;\n\t}\n\n\tZEND_TRY_BINARY_OBJECT_OPERATION(ZEND_DIV);\n\n\tzval op1_copy, op2_copy;\n\tif (UNEXPECTED(zendi_try_convert_scalar_to_number(op1, &op1_copy) == FAILURE)\n\t\t\t|| UNEXPECTED(zendi_try_convert_scalar_to_number(op2, &op2_copy) == FAILURE)) {\n\t\tzend_binop_error(\"/\", op1, op2);\n\t\tif (result != op1) {\n\t\t\tZVAL_UNDEF(result);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (result == op1) {\n\t\tzval_ptr_dtor(result);\n\t}\n\n\tretval = div_function_base(result, &op1_copy, &op2_copy);\n\tif (retval == SUCCESS) {\n\t\treturn SUCCESS;\n\t}\n\ndiv_by_zero:\n\tZEND_ASSERT(retval == DIV_BY_ZERO && \"TYPES_NOT_HANDLED should not occur here\");\n\tif (result != op1) {\n\t\tZVAL_UNDEF(result);\n\t}\n\tzend_throw_error(zend_ce_division_by_zero_error, \"Division by zero\");\n\treturn FAILURE;\n}\n",
    "target": 1,
    "idx": 1035876,
    "stack_trace": [
      {
        "function_name": "zend_gc_addref",
        "function_body": "static zend_always_inline uint32_t zend_gc_addref(zend_refcounted_h *p) {\n\tZEND_RC_MOD_CHECK(p);\n\treturn ++(p->refcount);\n}",
        "file_path": "/src/php-src/Zend/zend_types.h",
        "crashing_line": "\treturn ++(p->refcount);",
        "crashing_line_number": 1161
      },
      {
        "function_name": "ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER",
        "function_body": "static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *var_ptr;\n\tzval *value;\n\n\tSAVE_OPLINE();\n\tvalue = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);\n\tvar_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);\n\n\tdo {\n\t\tif (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {\n\t\t\tzend_reference *ref = Z_REF_P(var_ptr);\n\t\t\tvar_ptr = Z_REFVAL_P(var_ptr);\n\t\t\tif (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {\n\t\t\t\tzend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tzend_binary_op(var_ptr, var_ptr, value OPLINE_CC);\n\t} while (0);\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), var_ptr);\n\t}\n\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op2.var));\n\tzval_ptr_dtor_nogc(EX_VAR(opline->op1.var));\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}",
        "file_path": "/src/php-src/Zend/zend_vm_execute.h",
        "crashing_line": "\t\tZVAL_COPY(EX_VAR(opline->result.var), var_ptr);",
        "crashing_line_number": 24843
      },
      {
        "function_name": "fuzzer_execute_ex",
        "function_body": "static void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-execute.c",
        "crashing_line": "\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {",
        "crashing_line_number": 40
      },
      {
        "function_name": "zend_execute",
        "function_body": "ZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)\n{\n\tzend_execute_data *execute_data;\n\tvoid *object_or_called_scope;\n\tuint32_t call_info;\n\n\tif (EG(exception) != NULL) {\n\t\treturn;\n\t}\n\n\tobject_or_called_scope = zend_get_this_object(EG(current_execute_data));\n\tif (EXPECTED(!object_or_called_scope)) {\n\t\tobject_or_called_scope = zend_get_called_scope(EG(current_execute_data));\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE;\n\t} else {\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE | ZEND_CALL_HAS_THIS;\n\t}\n\texecute_data = zend_vm_stack_push_call_frame(call_info,\n\t\t(zend_function*)op_array, 0, object_or_called_scope);\n\tif (EG(current_execute_data)) {\n\t\texecute_data->symbol_table = zend_rebuild_symbol_table();\n\t} else {\n\t\texecute_data->symbol_table = &EG(symbol_table);\n\t}\n\tEX(prev_execute_data) = EG(current_execute_data);\n\ti_init_code_execute_data(execute_data, op_array, return_value);\n\tZEND_OBSERVER_FCALL_BEGIN(execute_data);\n\tzend_execute_ex(execute_data);\n\t/* Observer end handlers are called from ZEND_RETURN */\n\tzend_vm_stack_free_call_frame(execute_data);\n}",
        "file_path": "/src/php-src/Zend/zend_vm_execute.h",
        "crashing_line": "\tzend_execute_ex(execute_data);",
        "crashing_line_number": 58871
      },
      {
        "function_name": "fuzzer_do_request_from_buffer",
        "function_body": "int fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();",
        "file_path": "/src/php-src/sapi/fuzzer/fuzzer-sapi.c",
        "crashing_line": "\t\t\t\tzend_execute(op_array, NULL);",
        "crashing_line_number": 259
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\ngnutls_pkcs12_simple_parse(gnutls_pkcs12_t p12,\n\t\t\t   const char *password,\n\t\t\t   gnutls_x509_privkey_t * key,\n\t\t\t   gnutls_x509_crt_t ** chain,\n\t\t\t   unsigned int *chain_len,\n\t\t\t   gnutls_x509_crt_t ** extra_certs,\n\t\t\t   unsigned int *extra_certs_len,\n\t\t\t   gnutls_x509_crl_t * crl, unsigned int flags)\n{\n\tgnutls_pkcs12_bag_t bag = NULL;\n\tgnutls_x509_crt_t *_extra_certs = NULL;\n\tunsigned int _extra_certs_len = 0;\n\tgnutls_x509_crt_t *_chain = NULL;\n\tunsigned int _chain_len = 0;\n\tint idx = 0;\n\tint ret;\n\tsize_t cert_id_size = 0;\n\tsize_t key_id_size = 0;\n\tuint8_t cert_id[20];\n\tuint8_t key_id[20];\n\tint privkey_ok = 0;\n\tunsigned int i;\n\tint elements_in_bag;\n\n\t*key = NULL;\n\n\tif (crl)\n\t\t*crl = NULL;\n\n\t/* find the first private key */\n\tfor (;;) {\n\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tif (password == NULL) {\n\t\t\t\tret =\n\t\t\t\t    gnutls_assert_val\n\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_PKCS8_ENCRYPTED_KEY:\n\t\t\t\tif (password == NULL) {\n\t\t\t\t\tret =\n\t\t\t\t\t    gnutls_assert_val\n\t\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* fallthrough */\n\t\t\tcase GNUTLS_BAG_PKCS8_KEY:\n\t\t\t\tif (*key != NULL) {\t/* too simple to continue */\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_init(key);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_import_pkcs8\n\t\t\t\t    (*key, &data, GNUTLS_X509_FMT_DER,\n\t\t\t\t     password,\n\t\t\t\t     type ==\n\t\t\t\t     GNUTLS_BAG_PKCS8_KEY ?\n\t\t\t\t     GNUTLS_PKCS_PLAIN : 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tkey_id_size = sizeof(key_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_privkey_get_key_id(*key, 0,\n\t\t\t\t\t\t\t\t   key_id,\n\t\t\t\t\t\t\t\t   &key_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tprivkey_ok = 1;\t/* break */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\n\t\tif (privkey_ok != 0)\t/* private key was found */\n\t\t\tbreak;\n\t}\n\n\tif (privkey_ok == 0) {\t/* no private key */\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t}\n\n\t/* now find the corresponding certificate \n\t */\n\tidx = 0;\n\tbag = NULL;\n\tfor (;;) {\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\t\t\tgnutls_x509_crt_t this_cert;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_CERTIFICATE:\n\t\t\t\tret = gnutls_x509_crt_init(&this_cert);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_import(this_cert,\n\t\t\t\t\t\t\t   &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* check if the key id match */\n\t\t\t\tcert_id_size = sizeof(cert_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_get_key_id(this_cert,\n\t\t\t\t\t\t\t       0, cert_id,\n\t\t\t\t\t\t\t       &cert_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (memcmp(cert_id, key_id, cert_id_size) != 0) {\t/* they don't match - skip the certificate */\n\t\t\t\t\t_extra_certs =\n\t\t\t\t\t\tgnutls_realloc_fast\n\t\t\t\t\t\t(_extra_certs,\n\t\t\t\t\t\t sizeof(_extra_certs\n\t\t\t\t\t\t\t[0]) *\n\t\t\t\t\t\t ++_extra_certs_len);\n\t\t\t\t\tif (!_extra_certs) {\n\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\tret =\n\t\t\t\t\t\t\tGNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\t_extra_certs\n\t\t\t\t\t\t[_extra_certs_len -\n\t\t\t\t\t\t 1] = this_cert;\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tif (chain && _chain_len == 0) {\n\t\t\t\t\t\t_chain =\n\t\t\t\t\t\t    gnutls_malloc(sizeof\n\t\t\t\t\t\t\t\t  (_chain\n\t\t\t\t\t\t\t\t   [0]) *\n\t\t\t\t\t\t\t\t  (++_chain_len));\n\t\t\t\t\t\tif (!_chain) {\n\t\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\t\tret =\n\t\t\t\t\t\t\t    GNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_chain[_chain_len - 1] =\n\t\t\t\t\t\t    this_cert;\n\t\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgnutls_x509_crt_deinit\n\t\t\t\t\t\t    (this_cert);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_CRL:\n\t\t\t\tif (crl == NULL || *crl != NULL) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_crl_init(crl);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crl_import(*crl, &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_ENCRYPTED:\n\t\t\t\t/* XXX Bother to recurse one level down?  Unlikely to\n\t\t\t\t   use the same password anyway. */\n\t\t\tcase GNUTLS_BAG_EMPTY:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\t}\n\n\tif (chain != NULL) {\n\t\tif (_chain_len != 1) {\n\t\t\tret = GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret =\n\t\t    make_chain(&_chain, &_chain_len, &_extra_certs,\n\t\t\t       &_extra_certs_len, flags);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = 0;\n\n      done:\n\tif (bag)\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\n\tif (ret < 0) {\n\t\tif (*key) {\n\t\t\tgnutls_x509_privkey_deinit(*key);\n\t\t\t*key = NULL;\n\t\t}\n\t\tif (crl != NULL && *crl != NULL) {\n\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t*crl = NULL;\n\t\t}\n\t\tif (_extra_certs_len && _extra_certs != NULL) {\n\t\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\t\tgnutls_free(_extra_certs);\n\t\t}\n\t\tif (_chain_len && _chain != NULL) {\n\t\t\tfor (i = 0; i < _chain_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_chain[i]);\n\t\t\tgnutls_free(_chain);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tif (extra_certs && _extra_certs_len > 0) {\n\t\t*extra_certs = _extra_certs;\n\t\t*extra_certs_len = _extra_certs_len;\n\t} else {\n\t\tif (extra_certs) {\n\t\t\t*extra_certs = NULL;\n\t\t\t*extra_certs_len = 0;\n\t\t}\n\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\tgnutls_free(_extra_certs);\n\t}\n\n\tif (chain != NULL) {\n\t\t*chain = _chain;\n\t\t*chain_len = _chain_len;\n\t}\n\n\treturn ret;\n}\n",
    "target": 1,
    "idx": 1001304,
    "stack_trace": [
      {
        "function_name": "gnutls_x509_crl_deinit",
        "function_body": "void gnutls_x509_crl_deinit(gnutls_x509_crl_t crl)\n{\n\tif (!crl)\n\t\treturn;\n\n\tif (crl->crl)\n\t\tasn1_delete_structure(&crl->crl);\n\tgnutls_free(crl->der.data);\n\n\tgnutls_free(crl);\n}",
        "file_path": "/src/gnutls/lib/x509/crl.c",
        "crashing_line": "\tif (crl->crl)",
        "crashing_line_number": 98
      },
      {
        "function_name": "gnutls_pkcs12_simple_parse",
        "function_body": "int\ngnutls_pkcs12_simple_parse(gnutls_pkcs12_t p12,\n\t\t\t   const char *password,\n\t\t\t   gnutls_x509_privkey_t * key,\n\t\t\t   gnutls_x509_crt_t ** chain,\n\t\t\t   unsigned int *chain_len,\n\t\t\t   gnutls_x509_crt_t ** extra_certs,\n\t\t\t   unsigned int *extra_certs_len,\n\t\t\t   gnutls_x509_crl_t * crl, unsigned int flags)\n{\n\tgnutls_pkcs12_bag_t bag = NULL;\n\tgnutls_x509_crt_t *_extra_certs = NULL;\n\tunsigned int _extra_certs_len = 0;\n\tgnutls_x509_crt_t *_chain = NULL;\n\tunsigned int _chain_len = 0;\n\tint idx = 0;\n\tint ret;\n\tsize_t cert_id_size = 0;\n\tsize_t key_id_size = 0;\n\tuint8_t cert_id[20];\n\tuint8_t key_id[20];\n\tint privkey_ok = 0;\n\tunsigned int i;\n\tint elements_in_bag;\n\n\t*key = NULL;\n\n\tif (crl)\n\t\t*crl = NULL;\n\n\t/* find the first private key */\n\tfor (;;) {\n\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tif (password == NULL) {\n\t\t\t\tret =\n\t\t\t\t    gnutls_assert_val\n\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_PKCS8_ENCRYPTED_KEY:\n\t\t\t\tif (password == NULL) {\n\t\t\t\t\tret =\n\t\t\t\t\t    gnutls_assert_val\n\t\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* fallthrough */\n\t\t\tcase GNUTLS_BAG_PKCS8_KEY:\n\t\t\t\tif (*key != NULL) {\t/* too simple to continue */\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_init(key);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_import_pkcs8\n\t\t\t\t    (*key, &data, GNUTLS_X509_FMT_DER,\n\t\t\t\t     password,\n\t\t\t\t     type ==\n\t\t\t\t     GNUTLS_BAG_PKCS8_KEY ?\n\t\t\t\t     GNUTLS_PKCS_PLAIN : 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tkey_id_size = sizeof(key_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_privkey_get_key_id(*key, 0,\n\t\t\t\t\t\t\t\t   key_id,\n\t\t\t\t\t\t\t\t   &key_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tprivkey_ok = 1;\t/* break */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\n\t\tif (privkey_ok != 0)\t/* private key was found */\n\t\t\tbreak;\n\t}\n\n\tif (privkey_ok == 0) {\t/* no private key */\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t}\n\n\t/* now find the corresponding certificate \n\t */\n\tidx = 0;\n\tbag = NULL;\n\tfor (;;) {\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\t\t\tgnutls_x509_crt_t this_cert;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_CERTIFICATE:\n\t\t\t\tret = gnutls_x509_crt_init(&this_cert);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_import(this_cert,\n\t\t\t\t\t\t\t   &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* check if the key id match */\n\t\t\t\tcert_id_size = sizeof(cert_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_get_key_id(this_cert,\n\t\t\t\t\t\t\t       0, cert_id,\n\t\t\t\t\t\t\t       &cert_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (memcmp(cert_id, key_id, cert_id_size) != 0) {\t/* they don't match - skip the certificate */\n\t\t\t\t\t_extra_certs =\n\t\t\t\t\t\tgnutls_realloc_fast\n\t\t\t\t\t\t(_extra_certs,\n\t\t\t\t\t\t sizeof(_extra_certs\n\t\t\t\t\t\t\t[0]) *\n\t\t\t\t\t\t ++_extra_certs_len);\n\t\t\t\t\tif (!_extra_certs) {\n\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\tret =\n\t\t\t\t\t\t\tGNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\t_extra_certs\n\t\t\t\t\t\t[_extra_certs_len -\n\t\t\t\t\t\t 1] = this_cert;\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tif (chain && _chain_len == 0) {\n\t\t\t\t\t\t_chain =\n\t\t\t\t\t\t    gnutls_malloc(sizeof\n\t\t\t\t\t\t\t\t  (_chain\n\t\t\t\t\t\t\t\t   [0]) *\n\t\t\t\t\t\t\t\t  (++_chain_len));\n\t\t\t\t\t\tif (!_chain) {\n\t\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\t\tret =\n\t\t\t\t\t\t\t    GNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_chain[_chain_len - 1] =\n\t\t\t\t\t\t    this_cert;\n\t\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgnutls_x509_crt_deinit\n\t\t\t\t\t\t    (this_cert);\n\t\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_CRL:\n\t\t\t\tif (crl == NULL || *crl != NULL) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_crl_init(crl);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crl_import(*crl, &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t\t\t*crl = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_ENCRYPTED:\n\t\t\t\t/* XXX Bother to recurse one level down?  Unlikely to\n\t\t\t\t   use the same password anyway. */\n\t\t\tcase GNUTLS_BAG_EMPTY:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\t}\n\n\tif (chain != NULL) {\n\t\tif (_chain_len != 1) {\n\t\t\tret = GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret =\n\t\t    make_chain(&_chain, &_chain_len, &_extra_certs,\n\t\t\t       &_extra_certs_len, flags);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = 0;\n\n      done:\n\tif (bag)\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\n\tif (ret < 0) {\n\t\tif (*key) {\n\t\t\tgnutls_x509_privkey_deinit(*key);\n\t\t\t*key = NULL;\n\t\t}\n\t\tif (crl != NULL && *crl != NULL) {\n\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t*crl = NULL;\n\t\t}\n\t\tif (_extra_certs_len && _extra_certs != NULL) {\n\t\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\t\tgnutls_free(_extra_certs);\n\t\t}\n\t\tif (_chain_len && _chain != NULL) {\n\t\t\tfor (i = 0; i < _chain_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_chain[i]);\n\t\t\tgnutls_free(_chain);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tif (extra_certs && _extra_certs_len > 0) {\n\t\t*extra_certs = _extra_certs;\n\t\t*extra_certs_len = _extra_certs_len;\n\t} else {\n\t\tif (extra_certs) {\n\t\t\t*extra_certs = NULL;\n\t\t\t*extra_certs_len = 0;\n\t\t}\n\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\tgnutls_free(_extra_certs);\n\t}\n\n\tif (chain != NULL) {\n\t\t*chain = _chain;\n\t\t*chain_len = _chain_len;\n\t}\n\n\treturn ret;\n}",
        "file_path": "/src/gnutls/lib/x509/pkcs12.c",
        "crashing_line": "\t\t\tgnutls_x509_privkey_deinit(*key);",
        "crashing_line_number": 1791
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static UA_StatusCode\nremoveSession(UA_SessionManager *sm, session_list_entry *sentry) {\n    /* Deactivate the session */\n    sentry->session.activated = false;\n\n    /* Add a delayed callback to remove the session when the currently\n     * scheduled jobs have completed */\n    UA_StatusCode retval = UA_Server_delayedCallback(sm->server, removeSessionCallback, sentry);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING_SESSION(sm->server->config.logger, &sentry->session,\n                       \"Could not remove session with error code %s\",\n                       UA_StatusCode_name(retval));\n        return retval; /* Try again next time */\n    }\n\n    /* Detach the session and make the capacity available */\n    LIST_REMOVE(sentry, pointers);\n    UA_atomic_add(&sm->currentSessionCount, (UA_UInt32)-1);\n    return UA_STATUSCODE_GOOD;\n}\n",
    "target": 1,
    "idx": 1005499,
    "stack_trace": [
      {
        "function_name": "UA_SecureChannel_deleteMembersCleanup",
        "function_body": "void\nUA_SecureChannel_deleteMembersCleanup(UA_SecureChannel *channel) {\n    /* Delete members */\n    UA_ByteString_deleteMembers(&channel->remoteCertificate);\n    UA_ByteString_deleteMembers(&channel->localNonce);\n    UA_ByteString_deleteMembers(&channel->remoteNonce);\n    UA_ChannelSecurityToken_deleteMembers(&channel->securityToken);\n    UA_ChannelSecurityToken_deleteMembers(&channel->nextSecurityToken);\n\n    /* Delete the channel context for the security policy */\n    if(channel->securityPolicy)\n        channel->securityPolicy->channelModule.deleteContext(channel->channelContext);\n\n    /* Detach from the connection and close the connection */\n    if(channel->connection) {\n        if(channel->connection->state != UA_CONNECTION_CLOSED)\n            channel->connection->close(channel->connection);\n        UA_Connection_detachSecureChannel(channel->connection);\n    }\n\n    /* Remove session pointers (not the sessions) and NULL the pointers back to\n     * the SecureChannel in the Session */\n    UA_SessionHeader *sh, *temp;\n    LIST_FOREACH_SAFE(sh, &channel->sessions, pointers, temp) {\n        sh->channel = NULL;\n        LIST_REMOVE(sh, pointers);\n    }\n\n    /* Remove the buffered chunks */\n    struct ChunkEntry *ch, *temp_ch;\n    LIST_FOREACH_SAFE(ch, &channel->chunks, pointers, temp_ch) {\n        UA_ByteString_deleteMembers(&ch->bytes);\n        LIST_REMOVE(ch, pointers);\n        UA_free(ch);\n    }\n}",
        "file_path": "/src/open62541/src/ua_securechannel.c",
        "crashing_line": "    LIST_FOREACH_SAFE(sh, &channel->sessions, pointers, temp) {",
        "crashing_line_number": 84
      },
      {
        "function_name": "removeSecureChannelCallback",
        "function_body": "static void\nremoveSecureChannelCallback(UA_Server *server, void *entry) {\n    channel_list_entry *centry = (channel_list_entry*)entry;\n    UA_SecureChannel_deleteMembersCleanup(&centry->channel);\n    UA_free(entry);\n}",
        "file_path": "/src/open62541/src/server/ua_securechannel_manager.c",
        "crashing_line": "    UA_SecureChannel_deleteMembersCleanup(&centry->channel);",
        "crashing_line_number": 36
      },
      {
        "function_name": "processDelayedCallbacks",
        "function_body": "static void\nprocessDelayedCallbacks(UA_Server *server) {\n    UA_DelayedCallback *dc, *dc_tmp;\n    SLIST_FOREACH_SAFE(dc, &server->delayedCallbacks, next, dc_tmp) {\n        SLIST_REMOVE(&server->delayedCallbacks, dc, UA_DelayedCallback, next);\n        dc->callback(server, dc->data);\n        UA_free(dc);\n    }\n}",
        "file_path": "/src/open62541/src/server/ua_server_worker.c",
        "crashing_line": "        dc->callback(server, dc->data);",
        "crashing_line_number": 180
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_reset_classperms_list(cp->classperms);\n}\n",
    "target": 1,
    "idx": 1031065,
    "stack_trace": [
      {
        "function_name": "__cil_verify_classperms",
        "function_body": "int __cil_verify_class(struct cil_tree_node *node)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_class *class = node->data;\n\n\tif (class->common != NULL) {\n\t\tstruct cil_class *common = class->common;\n\t\tstruct cil_tree_node *common_node = common->datum.nodes->head->data;\n\t\tstruct cil_tree_node *curr_com_perm = NULL;\n\n\t\tfor (curr_com_perm = common_node->cl_head;\n\t\t\tcurr_com_perm != NULL;\n\t\t\tcurr_com_perm = curr_com_perm->next) {\n\t\t\tstruct cil_perm *com_perm = curr_com_perm->data;\n\t\t\tstruct cil_tree_node *curr_class_perm = NULL;\n\n\t\t\tfor (curr_class_perm = node->cl_head;\n\t\t\t\tcurr_class_perm != NULL;\n\t\t\t\tcurr_class_perm = curr_class_perm->next) {\n\t\t\t\tstruct cil_perm *class_perm = curr_class_perm->data;\n\n\t\t\t\tif (com_perm->datum.name == class_perm->datum.name) {\n\t\t\t\t\tcil_log(CIL_ERR, \"Duplicate permissions between %s common and class declarations\\n\", class_perm->datum.name);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(node, CIL_ERR, \"Invalid class\");\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_verify.c",
        "crashing_line": "",
        "crashing_line_number": 1617
      },
      {
        "function_name": "__cil_verify_classpermission",
        "function_body": "static int __cil_verify_classpermission(struct cil_tree_node *node)\n{\n\tstruct cil_classpermission *cp = node->data;\n\n\treturn __cil_verify_classperms(cp->classperms, &cp->datum, NULL, &cp->datum, CIL_CLASSPERMISSION, 0, 2);\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_verify.c",
        "crashing_line": "\treturn __cil_verify_classperms(cp->classperms, &cp->datum, NULL, &cp->datum, CIL_CLASSPERMISSION, 0, 2);",
        "crashing_line_number": 1647
      },
      {
        "function_name": "__cil_pre_verify_helper",
        "function_body": "int __cil_pre_verify_helper(struct cil_tree_node *node, uint32_t *finished, __attribute__((unused)) void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (node->flavor == CIL_MACRO) {\n\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t} else if (node->flavor == CIL_BLOCK) {\n\t\tstruct cil_block *blk = node->data;\n\t\tif (blk->is_abstract == CIL_TRUE) {\n\t\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\t}\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\tswitch (node->flavor) {\n\tcase CIL_USER:\n\t\trc = __cil_verify_user_pre_eval(node);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase CIL_MAP_CLASS:\n\t\trc = __cil_verify_map_class(node);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSION:\n\t\trc = __cil_verify_classpermission(node);\n\t\tbreak;\n\tdefault:\n\t\trc = SEPOL_OK;\n\t\tbreak;\n\t}\n\nexit:\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_verify.c",
        "crashing_line": "\t\trc = __cil_verify_classpermission(node);",
        "crashing_line_number": 1712
      },
      {
        "function_name": "cil_tree_walk_core",
        "function_body": "int cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\t\t\trc = (*process_node)(node, &finished, extra_args);",
        "crashing_line_number": 272
      },
      {
        "function_name": "cil_tree_walk",
        "function_body": "int cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 316
      },
      {
        "function_name": "cil_tree_walk_core",
        "function_body": "int cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 284
      },
      {
        "function_name": "cil_tree_walk",
        "function_body": "int cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 316
      },
      {
        "function_name": "cil_tree_walk_core",
        "function_body": "int cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 284
      },
      {
        "function_name": "cil_tree_walk",
        "function_body": "int cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_tree.c",
        "crashing_line": "\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);",
        "crashing_line_number": 316
      },
      {
        "function_name": "cil_pre_verify",
        "function_body": "static int cil_pre_verify(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_verify extra_args;\n\n\textra_args.db = db;\n\n\trc = cil_tree_walk(db->ast->root, __cil_pre_verify_helper, NULL, NULL, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_post.c",
        "crashing_line": "\trc = cil_tree_walk(db->ast->root, __cil_pre_verify_helper, NULL, NULL, &extra_args);",
        "crashing_line_number": 2517
      },
      {
        "function_name": "cil_post_process",
        "function_body": "int cil_post_process(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_pre_verify(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_post_db(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed post db handling\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_post_verify(db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to verify cil database\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n\t\t\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_post.c",
        "crashing_line": "\trc = cil_pre_verify(db);",
        "crashing_line_number": 2531
      },
      {
        "function_name": "cil_compile",
        "function_body": "int cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil.c",
        "crashing_line": "\trc = cil_post_process(db);",
        "crashing_line_number": 564
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int igraph_read_graph_gml(igraph_t *graph, FILE *instream) {\n\n    long int i, p;\n    long int no_of_nodes = 0, no_of_edges = 0;\n    igraph_trie_t trie;\n    igraph_vector_t edges;\n    igraph_bool_t directed = IGRAPH_UNDIRECTED;\n    igraph_gml_tree_t *gtree;\n    long int gidx;\n    igraph_trie_t vattrnames;\n    igraph_trie_t eattrnames;\n    igraph_trie_t gattrnames;\n    igraph_vector_ptr_t gattrs = IGRAPH_VECTOR_PTR_NULL,\n                        vattrs = IGRAPH_VECTOR_PTR_NULL, eattrs = IGRAPH_VECTOR_PTR_NULL;\n    igraph_vector_ptr_t *attrs[3];\n    long int edgeptr = 0;\n    igraph_i_gml_parsedata_t context;\n\n    attrs[0] = &gattrs; attrs[1] = &vattrs; attrs[2] = &eattrs;\n\n    IGRAPH_CHECK(igraph_i_gml_parsedata_init(&context));\n    IGRAPH_FINALLY(igraph_i_gml_parsedata_destroy, &context);\n\n    igraph_gml_yylex_init_extra(&context, &context.scanner);\n\n    igraph_gml_yyset_in(instream, context.scanner);\n\n    i = igraph_gml_yyparse(&context);\n    if (i != 0) {\n        if (context.errmsg[0] != 0) {\n            IGRAPH_ERROR(context.errmsg, IGRAPH_PARSEERROR);\n        } else {\n            IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_PARSEERROR);\n        }\n    }\n\n    IGRAPH_VECTOR_INIT_FINALLY(&edges, 0);\n\n    /* Check version, if present, integer and not '1' then ignored */\n    i = igraph_gml_tree_find(context.tree, \"Version\", 0);\n    if (i >= 0 &&\n        igraph_gml_tree_type(context.tree, i) == IGRAPH_I_GML_TREE_INTEGER &&\n        igraph_gml_tree_get_integer(context.tree, i) != 1) {\n        igraph_gml_tree_destroy(context.tree);\n        IGRAPH_ERROR(\"Unknown GML version\", IGRAPH_UNIMPLEMENTED);\n        /* RETURN HERE!!!! */\n    }\n\n    /* get the graph */\n    gidx = igraph_gml_tree_find(context.tree, \"graph\", 0);\n    if (gidx == -1) {\n        IGRAPH_ERROR(\"No 'graph' object in GML file\", IGRAPH_PARSEERROR);\n    }\n    if (igraph_gml_tree_type(context.tree, gidx) !=\n        IGRAPH_I_GML_TREE_TREE) {\n        IGRAPH_ERROR(\"Invalid type for 'graph' object in GML file\", IGRAPH_PARSEERROR);\n    }\n    gtree = igraph_gml_tree_get_tree(context.tree, gidx);\n\n    IGRAPH_FINALLY(igraph_i_gml_destroy_attrs, attrs);\n    igraph_vector_ptr_init(&gattrs, 0);\n    igraph_vector_ptr_init(&vattrs, 0);\n    igraph_vector_ptr_init(&eattrs, 0);\n\n    IGRAPH_TRIE_INIT_FINALLY(&trie, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&vattrnames, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&eattrnames, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&gattrnames, 0);\n\n    /* Is is directed? */\n    i = igraph_gml_tree_find(gtree, \"directed\", 0);\n    if (i >= 0 && igraph_gml_tree_type(gtree, i) == IGRAPH_I_GML_TREE_INTEGER) {\n        if (igraph_gml_tree_get_integer(gtree, i) == 1) {\n            directed = IGRAPH_DIRECTED;\n        }\n    }\n\n    /* Now we go over all objects in the graph and collect the attribute names and\n       types. Plus we collect node ids. We also do some checks. */\n    for (i = 0; i < igraph_gml_tree_length(gtree); i++) {\n        long int j;\n        char cname[100];\n        const char *name = igraph_gml_tree_name(gtree, i);\n        if (!strcmp(name, \"node\")) {\n            igraph_gml_tree_t *node;\n            igraph_bool_t hasid;\n            no_of_nodes++;\n            if (igraph_gml_tree_type(gtree, i) != IGRAPH_I_GML_TREE_TREE) {\n                IGRAPH_ERROR(\"'node' is not a list\", IGRAPH_PARSEERROR);\n            }\n            node = igraph_gml_tree_get_tree(gtree, i);\n            hasid = 0;\n            for (j = 0; j < igraph_gml_tree_length(node); j++) {\n                const char *name = igraph_gml_tree_name(node, j);\n                long int trieid, triesize = igraph_trie_size(&vattrnames);\n                IGRAPH_CHECK(igraph_trie_get(&vattrnames, name, &trieid));\n                if (trieid == triesize) {\n                    /* new attribute */\n                    igraph_attribute_record_t *atrec = igraph_Calloc(1, igraph_attribute_record_t);\n                    int type = igraph_gml_tree_type(node, j);\n                    if (!atrec) {\n                        IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_ENOMEM);\n                    }\n                    IGRAPH_CHECK(igraph_vector_ptr_push_back(&vattrs, atrec));\n                    atrec->name = strdup(name);\n                    if (type == IGRAPH_I_GML_TREE_INTEGER || type == IGRAPH_I_GML_TREE_REAL) {\n                        atrec->type = IGRAPH_ATTRIBUTE_NUMERIC;\n                    } else {\n                        atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                    }\n                } else {\n                    /* already seen, should we update type? */\n                    igraph_attribute_record_t *atrec = VECTOR(vattrs)[trieid];\n                    int type1 = atrec->type;\n                    int type2 = igraph_gml_tree_type(node, j);\n                    if (type1 == IGRAPH_ATTRIBUTE_NUMERIC && type2 == IGRAPH_I_GML_TREE_STRING) {\n                        atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                    }\n                }\n                /* check id */\n                if (!hasid && !strcmp(name, \"id\")) {\n                    long int id;\n                    if (igraph_gml_tree_type(node, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer node id in GML file\", IGRAPH_PARSEERROR);\n                    }\n                    id = igraph_gml_tree_get_integer(node, j);\n                    snprintf(cname, sizeof(cname) / sizeof(char) -1, \"%li\", id);\n                    IGRAPH_CHECK(igraph_trie_get(&trie, cname, &id));\n                    hasid = 1;\n                }\n            }\n            if (!hasid) {\n                IGRAPH_ERROR(\"Node without 'id' while parsing GML file\", IGRAPH_PARSEERROR);\n            }\n        } else if (!strcmp(name, \"edge\")) {\n            igraph_gml_tree_t *edge;\n            igraph_bool_t has_source = 0, has_target = 0;\n            no_of_edges++;\n            if (igraph_gml_tree_type(gtree, i) != IGRAPH_I_GML_TREE_TREE) {\n                IGRAPH_ERROR(\"'edge' is not a list\", IGRAPH_PARSEERROR);\n            }\n            edge = igraph_gml_tree_get_tree(gtree, i);\n            has_source = has_target = 0;\n            for (j = 0; j < igraph_gml_tree_length(edge); j++) {\n                const char *name = igraph_gml_tree_name(edge, j);\n                if (!strcmp(name, \"source\")) {\n                    has_source = 1;\n                    if (igraph_gml_tree_type(edge, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer 'source' for an edge in GML file\",\n                                     IGRAPH_PARSEERROR);\n                    }\n                } else if (!strcmp(name, \"target\")) {\n                    has_target = 1;\n                    if (igraph_gml_tree_type(edge, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer 'source' for an edge in GML file\",\n                                     IGRAPH_PARSEERROR);\n                    }\n                } else {\n                    long int trieid, triesize = igraph_trie_size(&eattrnames);\n                    IGRAPH_CHECK(igraph_trie_get(&eattrnames, name, &trieid));\n                    if (trieid == triesize) {\n                        /* new attribute */\n                        igraph_attribute_record_t *atrec = igraph_Calloc(1, igraph_attribute_record_t);\n                        int type = igraph_gml_tree_type(edge, j);\n                        if (!atrec) {\n                            IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_ENOMEM);\n                        }\n                        IGRAPH_CHECK(igraph_vector_ptr_push_back(&eattrs, atrec));\n                        atrec->name = strdup(name);\n                        if (type == IGRAPH_I_GML_TREE_INTEGER || type == IGRAPH_I_GML_TREE_REAL) {\n                            atrec->type = IGRAPH_ATTRIBUTE_NUMERIC;\n                        } else {\n                            atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                        }\n                    } else {\n                        /* already seen, should we update type? */\n                        igraph_attribute_record_t *atrec = VECTOR(eattrs)[trieid];\n                        int type1 = atrec->type;\n                        int type2 = igraph_gml_tree_type(edge, j);\n                        if (type1 == IGRAPH_ATTRIBUTE_NUMERIC && type2 == IGRAPH_I_GML_TREE_STRING) {\n                            atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                        }\n                    }\n                }\n            } /* for */\n            if (!has_source) {\n                IGRAPH_ERROR(\"No 'source' for edge in GML file\", IGRAPH_PARSEERROR);\n            }\n            if (!has_target) {\n                IGRAPH_ERROR(\"No 'target' for edge in GML file\", IGRAPH_PARSEERROR);\n            }\n        } else {\n            /* anything to do? Maybe add as graph attribute.... */\n        }\n    }\n\n    /* check vertex id uniqueness */\n    if (igraph_trie_size(&trie) != no_of_nodes) {\n        IGRAPH_ERROR(\"Node 'id' not unique\", IGRAPH_PARSEERROR);\n    }\n\n    /* now we allocate the vectors and strvectors for the attributes */\n    for (i = 0; i < igraph_vector_ptr_size(&vattrs); i++) {\n        igraph_attribute_record_t *atrec = VECTOR(vattrs)[i];\n        int type = atrec->type;\n        if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n            igraph_vector_t *p = igraph_Calloc(1, igraph_vector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_vector_init(p, no_of_nodes));\n        } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n            igraph_strvector_t *p = igraph_Calloc(1, igraph_strvector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_strvector_init(p, no_of_nodes));\n        } else {\n            IGRAPH_WARNING(\"A composite attribute ignored\");\n        }\n    }\n\n    for (i = 0; i < igraph_vector_ptr_size(&eattrs); i++) {\n        igraph_attribute_record_t *atrec = VECTOR(eattrs)[i];\n        int type = atrec->type;\n        if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n            igraph_vector_t *p = igraph_Calloc(1, igraph_vector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_vector_init(p, no_of_edges));\n        } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n            igraph_strvector_t *p = igraph_Calloc(1, igraph_strvector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_strvector_init(p, no_of_edges));\n        } else {\n            IGRAPH_WARNING(\"A composite attribute ignored\");\n        }\n    }\n\n    /* Ok, now the edges, attributes too */\n    IGRAPH_CHECK(igraph_vector_resize(&edges, no_of_edges * 2));\n    p = -1;\n    while ( (p = igraph_gml_tree_find(gtree, \"edge\", p + 1)) != -1) {\n        igraph_gml_tree_t *edge;\n        long int from, to, fromidx = 0, toidx = 0;\n        char name[100];\n        long int j;\n        edge = igraph_gml_tree_get_tree(gtree, p);\n        for (j = 0; j < igraph_gml_tree_length(edge); j++) {\n            const char *n = igraph_gml_tree_name(edge, j);\n            if (!strcmp(n, \"source\")) {\n                fromidx = igraph_gml_tree_find(edge, \"source\", 0);\n            } else if (!strcmp(n, \"target\")) {\n                toidx = igraph_gml_tree_find(edge, \"target\", 0);\n            } else {\n                long int edgeid = edgeptr / 2;\n                long int trieidx;\n                igraph_attribute_record_t *atrec;\n                int type;\n                igraph_trie_get(&eattrnames, n, &trieidx);\n                atrec = VECTOR(eattrs)[trieidx];\n                type = atrec->type;\n                if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n                    igraph_vector_t *v = (igraph_vector_t *)atrec->value;\n                    IGRAPH_CHECK(igraph_i_gml_toreal(edge, j, VECTOR(*v) + edgeid));\n                } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n                    igraph_strvector_t *v = (igraph_strvector_t *)atrec->value;\n                    const char *value = igraph_i_gml_tostring(edge, j);\n                    IGRAPH_CHECK(igraph_strvector_set(v, edgeid, value));\n                }\n            }\n        }\n        from = igraph_gml_tree_get_integer(edge, fromidx);\n        to = igraph_gml_tree_get_integer(edge, toidx);\n        snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", from);\n        IGRAPH_CHECK(igraph_trie_get(&trie, name, &from));\n        snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", to);\n        IGRAPH_CHECK(igraph_trie_get(&trie, name, &to));\n        if (igraph_trie_size(&trie) != no_of_nodes) {\n            IGRAPH_ERROR(\"Unknown node id found at an edge\", IGRAPH_PARSEERROR);\n        }\n        VECTOR(edges)[edgeptr++] = from;\n        VECTOR(edges)[edgeptr++] = to;\n    }\n\n    /* and add vertex attributes */\n    for (i = 0; i < igraph_gml_tree_length(gtree); i++) {\n        const char *n;\n        char name[100];\n        long int j, k;\n        n = igraph_gml_tree_name(gtree, i);\n        if (!strcmp(n, \"node\")) {\n            igraph_gml_tree_t *node = igraph_gml_tree_get_tree(gtree, i);\n            long int iidx = igraph_gml_tree_find(node, \"id\", 0);\n            long int id = igraph_gml_tree_get_integer(node, iidx);\n            snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", id);\n            igraph_trie_get(&trie, name, &id);\n            for (j = 0; j < igraph_gml_tree_length(node); j++) {\n                const char *aname = igraph_gml_tree_name(node, j);\n                igraph_attribute_record_t *atrec;\n                int type;\n                igraph_trie_get(&vattrnames, aname, &k);\n                atrec = VECTOR(vattrs)[k];\n                type = atrec->type;\n                if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n                    igraph_vector_t *v = (igraph_vector_t *)atrec->value;\n                    IGRAPH_CHECK(igraph_i_gml_toreal(node, j, VECTOR(*v) + id));\n                } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n                    igraph_strvector_t *v = (igraph_strvector_t *)atrec->value;\n                    const char *value = igraph_i_gml_tostring(node, j);\n                    IGRAPH_CHECK(igraph_strvector_set(v, id, value));\n                }\n            }\n        }\n    }\n\n    igraph_trie_destroy(&trie);\n    igraph_trie_destroy(&gattrnames);\n    igraph_trie_destroy(&vattrnames);\n    igraph_trie_destroy(&eattrnames);\n    IGRAPH_FINALLY_CLEAN(4);\n\n    IGRAPH_CHECK(igraph_empty_attrs(graph, 0, directed, 0)); /* TODO */\n    IGRAPH_CHECK(igraph_add_vertices(graph, (igraph_integer_t) no_of_nodes,\n                                     &vattrs));\n    IGRAPH_CHECK(igraph_add_edges(graph, &edges, &eattrs));\n\n    igraph_i_gml_destroy_attrs(attrs);\n    igraph_vector_destroy(&edges);\n    igraph_i_gml_parsedata_destroy(&context);\n    IGRAPH_FINALLY_CLEAN(3);\n\n    return 0;\n}\n",
    "target": 1,
    "idx": 1029408,
    "stack_trace": [
      {
        "function_name": "igraph_vector_ptr_size",
        "function_body": "long int igraph_vector_ptr_size(const igraph_vector_ptr_t* v) {\n    IGRAPH_ASSERT(v != NULL);\n    /*  IGRAPH_ASSERT(v->stor_begin != NULL);       */ /* TODO */\n    return v->end - v->stor_begin;\n}",
        "file_path": "/src/igraph/src/core/vector_ptr.c",
        "crashing_line": "    return v->end - v->stor_begin;",
        "crashing_line_number": 264
      },
      {
        "function_name": "igraph_gml_tree_destroy",
        "function_body": "void igraph_gml_tree_destroy(igraph_gml_tree_t *t) {\n\n    long int i, n = igraph_vector_ptr_size(&t->children);\n    for (i = 0; i < n; i++) {\n        int type = VECTOR(t->types)[i];\n        switch (type) {\n        case IGRAPH_I_GML_TREE_TREE:\n            igraph_gml_tree_destroy(VECTOR(t->children)[i]);\n            igraph_Free(VECTOR(t->names)[i]);\n            break;\n        case IGRAPH_I_GML_TREE_INTEGER:\n            igraph_Free(VECTOR(t->children)[i]);\n            igraph_Free(VECTOR(t->names)[i]);\n            break;\n        case IGRAPH_I_GML_TREE_REAL:\n            igraph_Free(VECTOR(t->children)[i]);\n            igraph_Free(VECTOR(t->names)[i]);\n            break;\n        case IGRAPH_I_GML_TREE_STRING:\n            igraph_Free(VECTOR(t->children)[i]);\n            igraph_Free(VECTOR(t->names)[i]);\n            break;\n        case IGRAPH_I_GML_TREE_DELETED:\n            break;\n        }\n    }\n    igraph_vector_ptr_destroy(&t->names);\n    igraph_vector_char_destroy(&t->types);\n    igraph_vector_ptr_destroy(&t->children);\n    igraph_Free(t);\n}",
        "file_path": "/src/igraph/src/io/gml-tree.c",
        "crashing_line": "    long int i, n = igraph_vector_ptr_size(&t->children);",
        "crashing_line_number": 162
      },
      {
        "function_name": "igraph_i_gml_parsedata_destroy",
        "function_body": "void igraph_i_gml_parsedata_destroy(igraph_i_gml_parsedata_t* context) {\n    if (context->tree != 0) {\n        igraph_gml_tree_destroy(context->tree);\n        context->tree = 0;\n    }\n\n    if (context->scanner != 0) {\n        igraph_gml_yylex_destroy(context->scanner);\n        context->scanner = 0;\n    }\n}",
        "file_path": "/src/igraph/src/io/gml.c",
        "crashing_line": "        igraph_gml_tree_destroy(context->tree);",
        "crashing_line_number": 130
      },
      {
        "function_name": "IGRAPH_FINALLY_FREE",
        "function_body": "void IGRAPH_FINALLY_FREE(void) {\n    int p;\n    /*   printf(\"[X] Finally stack will be cleaned (contained %d elements)\\n\", igraph_i_finally_stack[0].all);  */\n    for (p = igraph_i_finally_stack[0].all - 1; p >= 0; p--) {\n        igraph_i_finally_stack[p].func(igraph_i_finally_stack[p].ptr);\n    }\n    igraph_i_finally_stack[0].all = 0;\n}",
        "file_path": "/src/igraph/src/core/error.c",
        "crashing_line": "        igraph_i_finally_stack[p].func(igraph_i_finally_stack[p].ptr);",
        "crashing_line_number": 239
      },
      {
        "function_name": "igraph_error_handler_ignore",
        "function_body": "void igraph_error_handler_ignore (const char *reason, const char *file,\n                                  int line, int igraph_errno) {\n    IGRAPH_UNUSED(reason);\n    IGRAPH_UNUSED(file);\n    IGRAPH_UNUSED(line);\n    IGRAPH_UNUSED(igraph_errno);\n\n    IGRAPH_FINALLY_FREE();\n}",
        "file_path": "/src/igraph/src/core/error.c",
        "crashing_line": "    IGRAPH_FINALLY_FREE();",
        "crashing_line_number": 188
      },
      {
        "function_name": "igraph_error",
        "function_body": "int igraph_error(const char *reason, const char *file, int line,\n                 int igraph_errno) {\n\n    if (igraph_i_error_handler) {\n        igraph_i_error_handler(reason, file, line, igraph_errno);\n#ifndef USING_R\n    }  else {\n        igraph_error_handler_abort(reason, file, line, igraph_errno);\n#endif\n    }\n    return igraph_errno;\n}",
        "file_path": "/src/igraph/src/core/error.c",
        "crashing_line": "        igraph_i_error_handler(reason, file, line, igraph_errno);",
        "crashing_line_number": 147
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\nxmlAddIDSafe(xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr,\n             int streaming, xmlIDPtr *id) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (id != NULL)\n        *id = NULL;\n\n    if (doc == NULL) {\n\treturn(-1);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(0);\n    }\n    if (attr == NULL) {\n\treturn(-1);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n        if (table == NULL)\n            return(-1);\n    } else {\n        ret = xmlHashLookup(table, value);\n        if (ret != NULL) {\n            /*\n             * Update the attribute to make entities work.\n             */\n            if (!streaming) {\n                if (ret->attr != NULL) {\n                    ret->attr->id = NULL;\n                    ret->attr = attr;\n                }\n                attr->id = ret;\n            }\n\t    attr->atype = XML_ATTRIBUTE_ID;\n            return(0);\n        }\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL)\n\treturn(-1);\n    memset(ret, 0, sizeof(*ret));\n\n    /*\n     * fill the structure.\n     */\n    ret->doc = doc;\n    ret->value = xmlStrdup(value);\n    if (ret->value == NULL) {\n        xmlFreeID(ret);\n        return(-1);\n    }\n    if (streaming) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n        if (ret->name == NULL) {\n            xmlFreeID(ret);\n            return(-1);\n        }\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n\txmlFreeID(ret);\n\treturn(-1);\n    }\n\n    attr->atype = XML_ATTRIBUTE_ID;\n    if (!streaming)\n        attr->id = ret;\n\n    if (id != NULL)\n        *id = ret;\n    return(1);\n}\n",
    "target": 1,
    "idx": 1066679,
    "stack_trace": [
      {
        "function_name": "xmlRemoveID",
        "function_body": "int\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n\n    if (doc == NULL) return(-1);\n    if ((attr == NULL) || (attr->id == NULL)) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)\n        return(-1);\n\n    attr->atype = 0;\n    attr->id = NULL;\n\n    return(0);\n}",
        "file_path": "/src/libxml2/valid.c",
        "crashing_line": "",
        "crashing_line_number": 2523
      },
      {
        "function_name": "xmlFreeProp",
        "function_body": "void\nxmlFreeProp(xmlAttrPtr cur) {\n    xmlDictPtr dict = NULL;\n    if (cur == NULL) return;\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {\n\t    xmlRemoveID(cur->doc, cur);\n    }\n    if (cur->children != NULL) xmlFreeNodeList(cur->children);\n    DICT_FREE(cur->name)\n    xmlFree(cur);\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "\t    xmlRemoveID(cur->doc, cur);",
        "crashing_line_number": 2080
      },
      {
        "function_name": "xmlFreePropList",
        "function_body": "void\nxmlFreePropList(xmlAttrPtr cur) {\n    xmlAttrPtr next;\n    if (cur == NULL) return;\n    while (cur != NULL) {\n        next = cur->next;\n        xmlFreeProp(cur);\n\tcur = next;\n    }\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "        xmlFreeProp(cur);",
        "crashing_line_number": 2057
      },
      {
        "function_name": "xmlFreeNode",
        "function_body": "void\nxmlFreeNode(xmlNodePtr cur) {\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return;\n\n    /* use xmlFreeDtd for DTD nodes */\n    if (cur->type == XML_DTD_NODE) {\n\txmlFreeDtd((xmlDtdPtr) cur);\n\treturn;\n    }\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNs((xmlNsPtr) cur);\n        return;\n    }\n    if (cur->type == XML_ATTRIBUTE_NODE) {\n\txmlFreeProp((xmlAttrPtr) cur);\n\treturn;\n    }\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue(cur);\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if (cur->type == XML_ENTITY_DECL) {\n        xmlEntityPtr ent = (xmlEntityPtr) cur;\n\tDICT_FREE(ent->SystemID);\n\tDICT_FREE(ent->ExternalID);\n    }\n    if ((cur->children != NULL) &&\n\t(cur->type != XML_ENTITY_REF_NODE))\n\txmlFreeNodeList(cur->children);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n        (cur->type == XML_XINCLUDE_START) ||\n        (cur->type == XML_XINCLUDE_END)) {\n        if (cur->properties != NULL)\n            xmlFreePropList(cur->properties);\n        if (cur->nsDef != NULL)\n            xmlFreeNsList(cur->nsDef);\n    } else if ((cur->content != NULL) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->content != (xmlChar *) &(cur->properties))) {\n        DICT_FREE(cur->content)\n    }\n\n    /*\n     * When a node is a text node or a comment, it uses a global static\n     * variable for the name of the node.\n     * Otherwise the node name might come from the document's dictionary\n     */\n    if ((cur->name != NULL) &&\n        (cur->type != XML_TEXT_NODE) &&\n        (cur->type != XML_COMMENT_NODE))\n\tDICT_FREE(cur->name)\n\n    xmlFree(cur);\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "            xmlFreePropList(cur->properties);",
        "crashing_line_number": 3765
      },
      {
        "function_name": "xmlStaticCopyNode",
        "function_body": "xmlNodePtr\nxmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,\n                  int extended) {\n    xmlNodePtr ret;\n\n    if (node == NULL) return(NULL);\n    switch (node->type) {\n        case XML_TEXT_NODE:\n        case XML_CDATA_SECTION_NODE:\n        case XML_ELEMENT_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_ENTITY_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n\t    break;\n        case XML_ATTRIBUTE_NODE:\n\t\treturn((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n        case XML_NAMESPACE_DECL:\n\t    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_TREE_ENABLED\n\t    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n#endif /* LIBXML_TREE_ENABLED */\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_NOTATION_NODE:\n        case XML_DTD_NODE:\n        case XML_ELEMENT_DECL:\n        case XML_ATTRIBUTE_DECL:\n        case XML_ENTITY_DECL:\n            return(NULL);\n    }\n\n    /*\n     * Allocate a new node and fill the fields.\n     */\n    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n    if (ret == NULL)\n\treturn(NULL);\n    memset(ret, 0, sizeof(xmlNode));\n    ret->type = node->type;\n\n    ret->doc = doc;\n    ret->parent = parent;\n    if (node->name == xmlStringText)\n\tret->name = xmlStringText;\n    else if (node->name == xmlStringTextNoenc)\n\tret->name = xmlStringTextNoenc;\n    else if (node->name == xmlStringComment)\n\tret->name = xmlStringComment;\n    else if (node->name != NULL) {\n        if ((doc != NULL) && (doc->dict != NULL))\n\t    ret->name = xmlDictLookup(doc->dict, node->name, -1);\n\telse\n\t    ret->name = xmlStrdup(node->name);\n        if (ret->name == NULL)\n            goto error;\n    }\n    if ((node->type != XML_ELEMENT_NODE) &&\n\t(node->content != NULL) &&\n\t(node->type != XML_ENTITY_REF_NODE) &&\n\t(node->type != XML_XINCLUDE_END) &&\n\t(node->type != XML_XINCLUDE_START)) {\n\tret->content = xmlStrdup(node->content);\n        if (ret->content == NULL)\n            goto error;\n    }else{\n      if (node->type == XML_ELEMENT_NODE)\n        ret->line = node->line;\n    }\n    if (parent != NULL) {\n\txmlNodePtr tmp;\n\n\t/*\n\t * this is a tricky part for the node register thing:\n\t * in case ret does get coalesced in xmlAddChild\n\t * the deregister-node callback is called; so we register ret now already\n\t */\n\tif ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n\t    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n\n        /*\n         * Note that since ret->parent is already set, xmlAddChild will\n         * return early and not actually insert the node. It will only\n         * coalesce text nodes and unnecessarily call xmlSetTreeDoc.\n         * Assuming that the subtree to be copied always has its text\n         * nodes coalesced, the somewhat confusing call to xmlAddChild\n         * could be removed.\n         */\n        tmp = xmlAddChild(parent, ret);\n\t/* node could have coalesced */\n\tif (tmp != ret)\n\t    return(tmp);\n    }\n\n    if (!extended)\n\tgoto out;\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL)) {\n        ret->nsDef = xmlCopyNamespaceList(node->nsDef);\n        if (ret->nsDef == NULL)\n            goto error;\n    }\n\n    if ((node->type == XML_ELEMENT_NODE) && (node->ns != NULL)) {\n        xmlNsPtr ns;\n\n\tns = xmlSearchNs(doc, ret, node->ns->prefix);\n\tif (ns == NULL) {\n\t    /*\n\t     * Humm, we are copying an element whose namespace is defined\n\t     * out of the new tree scope. Search it in the original tree\n\t     * and add it at the top of the new tree.\n             *\n             * TODO: Searching the original tree seems unnecessary. We\n             * already have a namespace URI.\n\t     */\n\t    ns = xmlSearchNs(node->doc, node, node->ns->prefix);\n\t    if (ns != NULL) {\n\t        xmlNodePtr root = ret;\n\n\t\twhile (root->parent != NULL) root = root->parent;\n\t\tret->ns = xmlNewNs(root, ns->href, ns->prefix);\n            } else {\n                ret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n\t    }\n            if (ret->ns == NULL)\n                goto error;\n\t} else {\n\t    /*\n\t     * reference the existing namespace definition in our own tree.\n\t     */\n\t    ret->ns = ns;\n\t}\n    }\n    if ((node->type == XML_ELEMENT_NODE) && (node->properties != NULL)) {\n        ret->properties = xmlCopyPropList(ret, node->properties);\n        if (ret->properties == NULL)\n            goto error;\n    }\n    if (node->type == XML_ENTITY_REF_NODE) {\n\tif ((doc == NULL) || (node->doc != doc)) {\n\t    /*\n\t     * The copied node will go into a separate document, so\n\t     * to avoid dangling references to the ENTITY_DECL node\n\t     * we cannot keep the reference. Try to find it in the\n\t     * target document.\n\t     */\n\t    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n\t} else {\n            ret->children = node->children;\n\t}\n\tret->last = ret->children;\n    } else if ((node->children != NULL) && (extended != 2)) {\n        xmlNodePtr cur, insert;\n\n        cur = node->children;\n        insert = ret;\n        while (cur != NULL) {\n            xmlNodePtr copy = xmlStaticCopyNode(cur, doc, insert, 2);\n            if (copy == NULL)\n                goto error;\n\n            /* Check for coalesced text nodes */\n            if (insert->last != copy) {\n                if (insert->last == NULL) {\n                    insert->children = copy;\n                } else {\n                    copy->prev = insert->last;\n                    insert->last->next = copy;\n                }\n                insert->last = copy;\n            }\n\n            if ((cur->type != XML_ENTITY_REF_NODE) &&\n                (cur->children != NULL)) {\n                cur = cur->children;\n                insert = copy;\n                continue;\n            }\n\n            while (1) {\n                if (cur->next != NULL) {\n                    cur = cur->next;\n                    break;\n                }\n\n                cur = cur->parent;\n                insert = insert->parent;\n                if (cur == node) {\n                    cur = NULL;\n                    break;\n                }\n            }\n        }\n    }\n\nout:\n    /* if parent != NULL we already registered the node above */\n    if ((parent == NULL) &&\n        ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))\n\txmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n    return(ret);\n\nerror:\n    xmlFreeNode(ret);\n    return(NULL);\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "    xmlFreeNode(ret);",
        "crashing_line_number": 4368
      },
      {
        "function_name": "xmlDocCopyNode",
        "function_body": "xmlNodePtr\nxmlDocCopyNode(xmlNodePtr node, xmlDocPtr doc, int extended) {\n    xmlNodePtr ret;\n\n    ret = xmlStaticCopyNode(node, doc, NULL, extended);\n    return(ret);\n}",
        "file_path": "/src/libxml2/tree.c",
        "crashing_line": "    ret = xmlStaticCopyNode(node, doc, NULL, extended);",
        "crashing_line_number": 4460
      },
      {
        "function_name": "xmlParseReference",
        "function_body": "void\nxmlParseReference(xmlParserCtxtPtr ctxt) {\n    xmlEntityPtr ent = NULL;\n    const xmlChar *name;\n    xmlChar *val;\n\n    if (RAW != '&')\n        return;\n\n    /*\n     * Simple case of a CharRef\n     */\n    if (NXT(1) == '#') {\n\tint i = 0;\n\txmlChar out[16];\n\tint value = xmlParseCharRef(ctxt);\n\n\tif (value == 0)\n\t    return;\n\n        /*\n         * Just encode the value in UTF-8\n         */\n        COPY_BUF(out, i, value);\n        out[i] = 0;\n        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n            (!ctxt->disableSAX))\n            ctxt->sax->characters(ctxt->userData, out, i);\n\treturn;\n    }\n\n    /*\n     * We are seeing an entity reference\n     */\n    name = xmlParseEntityRefInternal(ctxt);\n    if (name != NULL)\n        ent = xmlLookupGeneralEntity(ctxt, name, /* isAttr */ 0);\n    if (ent == NULL) return;\n    if (!ctxt->wellFormed)\n\treturn;\n\n    /* special case of predefined entities */\n    if ((ent->name == NULL) ||\n        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\tval = ent->content;\n\tif (val == NULL) return;\n\t/*\n\t * inline the entity.\n\t */\n\tif ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));\n\treturn;\n    }\n\n    /*\n     * The first reference to the entity trigger a parsing phase\n     * where the ent->children is filled with the result from\n     * the parsing.\n     * Note: external parsed entities will not be loaded, it is not\n     * required for a non-validating parser, unless the parsing option\n     * of validating, or substituting entities were given. Doing so is\n     * far more secure as the parser will only process data coming from\n     * the document entity by default.\n     *\n     * FIXME: This doesn't work correctly since entities can be\n     * expanded with different namespace declarations in scope.\n     * For example:\n     *\n     * <!DOCTYPE doc [\n     *   <!ENTITY ent \"<ns:elem/>\">\n     * ]>\n     * <doc>\n     *   <decl1 xmlns:ns=\"urn:ns1\">\n     *     &ent;\n     *   </decl1>\n     *   <decl2 xmlns:ns=\"urn:ns2\">\n     *     &ent;\n     *   </decl2>\n     * </doc>\n     *\n     * Proposed fix:\n     *\n     * - Ignore current namespace declarations when parsing the\n     *   entity. If a prefix can't be resolved, don't report an error\n     *   but mark it as unresolved.\n     * - Try to resolve these prefixes when expanding the entity.\n     *   This will require a specialized version of xmlStaticCopyNode\n     *   which can also make use of the namespace hash table to avoid\n     *   quadratic behavior.\n     *\n     * Alternatively, we could simply reparse the entity on each\n     * expansion like we already do with custom SAX callbacks.\n     * External entity content should be cached in this case.\n     */\n    if ((ent->etype == XML_INTERNAL_GENERAL_ENTITY) ||\n        (((ctxt->options & XML_PARSE_NO_XXE) == 0) &&\n         ((ctxt->replaceEntities) ||\n          (ctxt->validate)))) {\n        if ((ent->flags & XML_ENT_PARSED) == 0) {\n            xmlCtxtParseEntity(ctxt, ent);\n        } else if (ent->children == NULL) {\n            /*\n             * Probably running in SAX mode and the callbacks don't\n             * build the entity content. Parse the entity again.\n             *\n             * This will also be triggered in normal tree builder mode\n             * if an entity happens to be empty, causing unnecessary\n             * reloads. It's hard to come up with a reliable check in\n             * which mode we're running.\n             */\n            xmlCtxtParseEntity(ctxt, ent);\n        }\n    }\n\n    /*\n     * We also check for amplification if entities aren't substituted.\n     * They might be expanded later.\n     */\n    if (xmlParserEntityCheck(ctxt, ent->expandedSize))\n        return;\n\n    if ((ctxt->sax == NULL) || (ctxt->disableSAX))\n        return;\n\n    if (ctxt->replaceEntities == 0) {\n\t/*\n\t * Create a reference\n\t */\n        if (ctxt->sax->reference != NULL)\n\t    ctxt->sax->reference(ctxt->userData, ent->name);\n    } else if ((ent->children != NULL) && (ctxt->node != NULL)) {\n        xmlNodePtr copy, cur;\n\n        /*\n         * Seems we are generating the DOM content, copy the tree\n\t */\n        cur = ent->children;\n\n        /*\n         * Handle first text node with SAX to coalesce text efficiently\n         */\n        if ((cur->type == XML_TEXT_NODE) ||\n            (cur->type == XML_CDATA_SECTION_NODE)) {\n            int len = xmlStrlen(cur->content);\n\n            if ((cur->type == XML_TEXT_NODE) ||\n                (ctxt->sax->cdataBlock == NULL)) {\n                if (ctxt->sax->characters != NULL)\n                    ctxt->sax->characters(ctxt, cur->content, len);\n            } else {\n                if (ctxt->sax->cdataBlock != NULL)\n                    ctxt->sax->cdataBlock(ctxt, cur->content, len);\n            }\n\n            cur = cur->next;\n        }\n\n        while (cur != NULL) {\n            xmlNodePtr last;\n\n            /*\n             * Handle last text node with SAX to coalesce text efficiently\n             */\n            if ((cur->next == NULL) &&\n                ((cur->type == XML_TEXT_NODE) ||\n                 (cur->type == XML_CDATA_SECTION_NODE))) {\n                int len = xmlStrlen(cur->content);\n\n                if ((cur->type == XML_TEXT_NODE) ||\n                    (ctxt->sax->cdataBlock == NULL)) {\n                    if (ctxt->sax->characters != NULL)\n                        ctxt->sax->characters(ctxt, cur->content, len);\n                } else {\n                    if (ctxt->sax->cdataBlock != NULL)\n                        ctxt->sax->cdataBlock(ctxt, cur->content, len);\n                }\n\n                break;\n            }\n\n            /*\n             * Reset coalesce buffer stats only for non-text nodes.\n             */\n            ctxt->nodemem = 0;\n            ctxt->nodelen = 0;\n\n            copy = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n\n            if (copy == NULL) {\n                xmlErrMemory(ctxt);\n                break;\n            }\n\n            if (ctxt->parseMode == XML_PARSE_READER) {\n                /* Needed for reader */\n                copy->extra = cur->extra;\n                /* Maybe needed for reader */\n                copy->_private = cur->_private;\n            }\n\n            copy->parent = ctxt->node;\n            last = ctxt->node->last;\n            if (last == NULL) {\n                ctxt->node->children = copy;\n            } else {\n                last->next = copy;\n                copy->prev = last;\n            }\n            ctxt->node->last = copy;\n\n            cur = cur->next;\n        }\n    }\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "            copy = xmlDocCopyNode(cur, ctxt->myDoc, 1);",
        "crashing_line_number": 7521
      },
      {
        "function_name": "xmlParseTryOrFinish",
        "function_body": "",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "",
        "crashing_line_number": 11290
      },
      {
        "function_name": "xmlParseChunk",
        "function_body": "int\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    size_t curBase;\n    size_t maxLength;\n    int end_in_lf = 0;\n\n    if ((ctxt == NULL) || (size < 0))\n        return(XML_ERR_ARGUMENT);\n    if (ctxt->disableSAX != 0)\n        return(ctxt->errNo);\n    if (ctxt->input == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt->input->flags |= XML_INPUT_PROGRESSIVE;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlCtxtInitializeLate(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n\n    curBase = ctxt->input->cur - ctxt->input->base;\n    maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                XML_MAX_HUGE_LENGTH :\n                XML_MAX_LOOKUP_LIMIT;\n    if (curBase > maxLength) {\n        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n                    \"Buffer size limit exceeded, try XML_PARSE_HUGE\\n\");\n        xmlHaltParser(ctxt);\n    }\n\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n            ctxt->instate = XML_PARSER_EOF;\n            xmlFinishDocument(ctxt);\n\t}\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "    xmlParseTryOrFinish(ctxt, terminate);",
        "crashing_line_number": 11587
      },
      {
        "function_name": "xmlTextReaderPushData",
        "function_body": "static int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlCtxtErrIO(reader->ctxt, reader->input->error, NULL);\n                    reader->mode = XML_TEXTREADER_MODE_ERROR;\n                    reader->state = XML_TEXTREADER_ERROR;\n                    return(-1);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}",
        "file_path": "/src/libxml2/xmlreader.c",
        "crashing_line": "\t    val = xmlParseChunk(reader->ctxt,",
        "crashing_line_number": 769
      },
      {
        "function_name": "xmlTextReaderRead",
        "function_body": "int\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n    if (reader->state == XML_TEXTREADER_ERROR)\n        return(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n            if (val < 0) {\n                reader->mode = XML_TEXTREADER_MODE_ERROR;\n                reader->state = XML_TEXTREADER_ERROR;\n                return(-1);\n            }\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL) {\n                reader->mode = XML_TEXTREADER_MODE_ERROR;\n                reader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t    }\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\t    return(0);\n        } else {\n            reader->mode = XML_TEXTREADER_MODE_ERROR;\n            reader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n        }\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0) {\n            reader->mode = XML_TEXTREADER_MODE_ERROR;\n            reader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n        }\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n                reader->mode = XML_TEXTREADER_MODE_ERROR;\n                reader->state = XML_TEXTREADER_ERROR;\n\t        return(-1);\n            }\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\tif (xmlTextReaderValidateEntity(reader) < 0)\n            return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}",
        "file_path": "/src/libxml2/xmlreader.c",
        "crashing_line": "\t    val = xmlTextReaderPushData(reader);",
        "crashing_line_number": 1233
      }
    ]
  }
]