[
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "otError Ip6::RemoveMplOption(Message &aMessage)\n{\n    otError        error = OT_ERROR_NONE;\n    Header         ip6Header;\n    HopByHopHeader hbh;\n    uint16_t       offset;\n    uint16_t       endOffset;\n    uint16_t       mplOffset = 0;\n    uint8_t        mplLength = 0;\n    bool           remove    = false;\n\n    offset = 0;\n    aMessage.Read(offset, sizeof(ip6Header), &ip6Header);\n    offset += sizeof(ip6Header);\n    VerifyOrExit(ip6Header.GetNextHeader() == kProtoHopOpts);\n\n    aMessage.Read(offset, sizeof(hbh), &hbh);\n    endOffset = offset + (hbh.GetLength() + 1) * 8;\n    VerifyOrExit(aMessage.GetLength() >= endOffset, error = OT_ERROR_PARSE);\n\n    offset += sizeof(hbh);\n\n    while (offset < endOffset)\n    {\n        OptionHeader option;\n\n        aMessage.Read(offset, sizeof(option), &option);\n\n        switch (option.GetType())\n        {\n        case OptionMpl::kType:\n            // if multiple MPL options exist, discard packet\n            VerifyOrExit(mplOffset == 0, error = OT_ERROR_PARSE);\n\n            mplOffset = offset;\n            mplLength = option.GetLength();\n\n            if (mplOffset == sizeof(ip6Header) + sizeof(hbh) && hbh.GetLength() == 0)\n            {\n                // first and only IPv6 Option, remove IPv6 HBH Option header\n                remove = true;\n            }\n            else if (mplOffset + 8 == endOffset)\n            {\n                // last IPv6 Option, remove last 8 bytes\n                remove = true;\n            }\n\n            offset += sizeof(option) + option.GetLength();\n            break;\n\n        case OptionPad1::kType:\n            offset += sizeof(OptionPad1);\n            break;\n\n        case OptionPadN::kType:\n            offset += sizeof(option) + option.GetLength();\n            break;\n\n        default:\n            // encountered another option, now just replace MPL Option with PadN\n            remove = false;\n            offset += sizeof(option) + option.GetLength();\n            break;\n        }\n    }\n\n    // verify that IPv6 Options header is properly formed\n    VerifyOrExit(offset == endOffset, error = OT_ERROR_PARSE);\n\n    if (remove)\n    {\n        // last IPv6 Option, shrink HBH Option header\n        uint8_t buf[8];\n\n        offset = endOffset - sizeof(buf);\n\n        while (offset >= sizeof(buf))\n        {\n            aMessage.Read(offset - sizeof(buf), sizeof(buf), buf);\n            aMessage.Write(offset, sizeof(buf), buf);\n            offset -= sizeof(buf);\n        }\n\n        aMessage.RemoveHeader(sizeof(buf));\n\n        if (mplOffset == sizeof(ip6Header) + sizeof(hbh))\n        {\n            // remove entire HBH header\n            ip6Header.SetNextHeader(hbh.GetNextHeader());\n        }\n        else\n        {\n            // update HBH header length\n            hbh.SetLength(hbh.GetLength() - 1);\n            aMessage.Write(sizeof(ip6Header), sizeof(hbh), &hbh);\n        }\n\n        ip6Header.SetPayloadLength(ip6Header.GetPayloadLength() - sizeof(buf));\n        aMessage.Write(0, sizeof(ip6Header), &ip6Header);\n    }\n    else if (mplOffset != 0)\n    {\n        // replace MPL Option with PadN Option\n        OptionPadN padOption;\n\n        padOption.Init(sizeof(OptionHeader) + mplLength);\n        aMessage.Write(mplOffset, padOption.GetTotalLength(), &padOption);\n    }\n\nexit:\n    return error;\n}\n",
    "target": 1,
    "idx": 1014854,
    "stack_trace": [
      {
        "function_name": "Init",
        "function_body": "    void Init(void) { mType = kType; }",
        "file_path": "/src/openthread/src/core/./net/ip6_headers.hpp",
        "crashing_line": "",
        "crashing_line_number": 500
      },
      {
        "function_name": "RemoveMplOption",
        "function_body": "otError Ip6::RemoveMplOption(Message &aMessage)\n{\n    otError        error = OT_ERROR_NONE;\n    Header         ip6Header;\n    HopByHopHeader hbh;\n    uint16_t       offset;\n    uint16_t       endOffset;\n    uint16_t       mplOffset = 0;\n    uint8_t        mplLength = 0;\n    bool           remove    = false;\n\n    offset = 0;\n    aMessage.Read(offset, sizeof(ip6Header), &ip6Header);\n    offset += sizeof(ip6Header);\n    VerifyOrExit(ip6Header.GetNextHeader() == kProtoHopOpts);\n\n    aMessage.Read(offset, sizeof(hbh), &hbh);\n    endOffset = offset + (hbh.GetLength() + 1) * 8;\n    VerifyOrExit(aMessage.GetLength() >= endOffset, error = OT_ERROR_PARSE);\n\n    offset += sizeof(hbh);\n\n    while (offset < endOffset)\n    {\n        OptionHeader option;\n\n        aMessage.Read(offset, sizeof(option), &option);\n\n        switch (option.GetType())\n        {\n        case OptionMpl::kType:\n            // if multiple MPL options exist, discard packet\n            VerifyOrExit(mplOffset == 0, error = OT_ERROR_PARSE);\n\n            mplOffset = offset;\n            mplLength = option.GetLength();\n\n            VerifyOrExit(mplLength <= sizeof(OptionMpl) - sizeof(OptionHeader), error = OT_ERROR_PARSE);\n\n            if (mplOffset == sizeof(ip6Header) + sizeof(hbh) && hbh.GetLength() == 0)\n            {\n                // first and only IPv6 Option, remove IPv6 HBH Option header\n                remove = true;\n            }\n            else if (mplOffset + 8 == endOffset)\n            {\n                // last IPv6 Option, remove last 8 bytes\n                remove = true;\n            }\n\n            offset += sizeof(option) + option.GetLength();\n            break;\n\n        case OptionPad1::kType:\n            offset += sizeof(OptionPad1);\n            break;\n\n        case OptionPadN::kType:\n            offset += sizeof(option) + option.GetLength();\n            break;\n\n        default:\n            // encountered another option, now just replace MPL Option with PadN\n            remove = false;\n            offset += sizeof(option) + option.GetLength();\n            break;\n        }\n    }\n\n    // verify that IPv6 Options header is properly formed\n    VerifyOrExit(offset == endOffset, error = OT_ERROR_PARSE);\n\n    if (remove)\n    {\n        // last IPv6 Option, shrink HBH Option header\n        uint8_t buf[8];\n\n        offset = endOffset - sizeof(buf);\n\n        while (offset >= sizeof(buf))\n        {\n            aMessage.Read(offset - sizeof(buf), sizeof(buf), buf);\n            aMessage.Write(offset, sizeof(buf), buf);\n            offset -= sizeof(buf);\n        }\n\n        aMessage.RemoveHeader(sizeof(buf));\n\n        if (mplOffset == sizeof(ip6Header) + sizeof(hbh))\n        {\n            // remove entire HBH header\n            ip6Header.SetNextHeader(hbh.GetNextHeader());\n        }\n        else\n        {\n            // update HBH header length\n            hbh.SetLength(hbh.GetLength() - 1);\n            aMessage.Write(sizeof(ip6Header), sizeof(hbh), &hbh);\n        }\n\n        ip6Header.SetPayloadLength(ip6Header.GetPayloadLength() - sizeof(buf));\n        aMessage.Write(0, sizeof(ip6Header), &ip6Header);\n    }\n    else if (mplOffset != 0)\n    {\n        // replace MPL Option with PadN Option\n        OptionPadN padOption;\n\n        padOption.Init(sizeof(OptionHeader) + mplLength);\n        aMessage.Write(mplOffset, padOption.GetTotalLength(), &padOption);\n    }\n\nexit:\n    return error;\n}",
        "file_path": "/src/openthread/src/core/net/ip6.cpp",
        "crashing_line": "        OptionPadN padOption;",
        "crashing_line_number": 436
      },
      {
        "function_name": "ProcessReceiveCallback",
        "function_body": "otError Ip6::ProcessReceiveCallback(const Message &    aMessage,\n                                    const MessageInfo &aMessageInfo,\n                                    uint8_t            aIpProto,\n                                    bool               aFromNcpHost)\n{\n    otError  error       = OT_ERROR_NONE;\n    Message *messageCopy = NULL;\n\n    VerifyOrExit(aFromNcpHost == false, error = OT_ERROR_NO_ROUTE);\n    VerifyOrExit(mReceiveIp6DatagramCallback != NULL, error = OT_ERROR_NO_ROUTE);\n\n    if (mIsReceiveIp6FilterEnabled)\n    {\n        // do not pass messages sent to an RLOC/ALOC, except Service Locator\n        VerifyOrExit(\n            (!aMessageInfo.GetSockAddr().IsRoutingLocator() && !aMessageInfo.GetSockAddr().IsAnycastRoutingLocator()) ||\n                aMessageInfo.GetSockAddr().IsAnycastServiceLocator(),\n            error = OT_ERROR_NO_ROUTE);\n\n        switch (aIpProto)\n        {\n        case kProtoIcmp6:\n            if (mIcmp.ShouldHandleEchoRequest(aMessageInfo))\n            {\n                IcmpHeader icmp;\n                aMessage.Read(aMessage.GetOffset(), sizeof(icmp), &icmp);\n\n                // do not pass ICMP Echo Request messages\n                VerifyOrExit(icmp.GetType() != IcmpHeader::kTypeEchoRequest, error = OT_ERROR_DROP);\n            }\n\n            break;\n\n        case kProtoUdp:\n        {\n            UdpHeader udp;\n            aMessage.Read(aMessage.GetOffset(), sizeof(udp), &udp);\n\n            switch (udp.GetDestinationPort())\n            {\n            case Mle::kUdpPort:\n\n                // do not pass MLE messages\n                if (aMessageInfo.GetSockAddr().IsLinkLocal() || aMessageInfo.GetSockAddr().IsLinkLocalMulticast())\n                {\n                    ExitNow(error = OT_ERROR_NO_ROUTE);\n                }\n\n                break;\n\n#if OPENTHREAD_ENABLE_PLATFORM_UDP == 0\n            case kCoapUdpPort:\n\n                // do not pass TMF messages\n                if (Get<ThreadNetif>().IsTmfMessage(aMessageInfo))\n                {\n                    ExitNow(error = OT_ERROR_NO_ROUTE);\n                }\n\n                break;\n#endif // OPENTHREAD_ENABLE_PLATFORM_UDP\n\n            default:\n#if OPENTHREAD_FTD\n                if (udp.GetDestinationPort() == Get<MeshCoP::JoinerRouter>().GetJoinerUdpPort())\n                {\n                    ExitNow(error = OT_ERROR_NO_ROUTE);\n                }\n#endif\n                break;\n            }\n\n            break;\n        }\n\n        default:\n            break;\n        }\n    }\n\n    // make a copy of the datagram to pass to host\n    VerifyOrExit((messageCopy = aMessage.Clone()) != NULL, error = OT_ERROR_NO_BUFS);\n    RemoveMplOption(*messageCopy);\n    mReceiveIp6DatagramCallback(messageCopy, mReceiveIp6DatagramCallbackContext);\n\nexit:\n\n    switch (error)\n    {\n    case OT_ERROR_NO_BUFS:\n        otLogWarnIp6(\"Failed to pass up message (len: %d) to host - out of message buffer.\", aMessage.GetLength());\n        break;\n\n    case OT_ERROR_DROP:\n        otLogNoteIp6(\"Dropping message (len: %d) from local host since next hop is the host.\", aMessage.GetLength());\n        break;\n\n    default:\n        break;\n    }\n\n    return error;\n}",
        "file_path": "/src/openthread/src/core/net/ip6.cpp",
        "crashing_line": "    // make a copy of the datagram to pass to host",
        "crashing_line_number": 777
      },
      {
        "function_name": "HandleDatagram",
        "function_body": "otError Ip6::HandleDatagram(Message &   aMessage,\n                            Netif *     aNetif,\n                            int8_t      aInterfaceId,\n                            const void *aLinkMessageInfo,\n                            bool        aFromNcpHost)\n{\n    otError     error = OT_ERROR_NONE;\n    MessageInfo messageInfo;\n    Header      header;\n    bool        receive              = false;\n    bool        forward              = false;\n    bool        tunnel               = false;\n    bool        multicastPromiscuous = false;\n    uint8_t     nextHeader;\n    uint8_t     hopLimit;\n    int8_t      forwardInterfaceId;\n\n    SuccessOrExit(error = header.Init(aMessage));\n\n    messageInfo.SetPeerAddr(header.GetSource());\n    messageInfo.SetSockAddr(header.GetDestination());\n    messageInfo.SetInterfaceId(aInterfaceId);\n    messageInfo.SetHopLimit(header.GetHopLimit());\n    messageInfo.SetLinkInfo(aLinkMessageInfo);\n\n    // determine destination of packet\n    if (header.GetDestination().IsMulticast())\n    {\n        if (aNetif != NULL)\n        {\n            if (aNetif->IsMulticastSubscribed(header.GetDestination()))\n            {\n                receive = true;\n            }\n            else if (aNetif->IsMulticastPromiscuousEnabled())\n            {\n                multicastPromiscuous = true;\n            }\n\n            if (header.GetDestination().IsMulticastLargerThanRealmLocal() &&\n                Get<Mle::MleRouter>().HasSleepyChildrenSubscribed(header.GetDestination()))\n            {\n                forward = true;\n            }\n        }\n        else\n        {\n            forward = true;\n        }\n    }\n    else\n    {\n        if (IsUnicastAddress(header.GetDestination()))\n        {\n            receive = true;\n        }\n        else if (!header.GetDestination().IsLinkLocal())\n        {\n            forward = true;\n        }\n        else if (aNetif == NULL)\n        {\n            forward = true;\n        }\n    }\n\n    aMessage.SetInterfaceId(aInterfaceId);\n    aMessage.SetOffset(sizeof(header));\n\n    // process IPv6 Extension Headers\n    nextHeader = static_cast<uint8_t>(header.GetNextHeader());\n    SuccessOrExit(error = HandleExtensionHeaders(aMessage, header, nextHeader, forward, receive));\n\n    // process IPv6 Payload\n    if (receive)\n    {\n        if (nextHeader == kProtoIp6)\n        {\n            // Remove encapsulating header.\n            aMessage.RemoveHeader(aMessage.GetOffset());\n\n            HandleDatagram(aMessage, aNetif, aInterfaceId, aLinkMessageInfo, aFromNcpHost);\n            ExitNow(tunnel = true);\n        }\n\n        ProcessReceiveCallback(aMessage, messageInfo, nextHeader, aFromNcpHost);\n\n        SuccessOrExit(error = HandlePayload(aMessage, messageInfo, nextHeader));\n    }\n    else if (multicastPromiscuous)\n    {\n        ProcessReceiveCallback(aMessage, messageInfo, nextHeader, aFromNcpHost);\n    }\n\n    if (forward)\n    {\n        forwardInterfaceId = FindForwardInterfaceId(messageInfo);\n\n        if (forwardInterfaceId == 0)\n        {\n            // try passing to host\n            SuccessOrExit(error = ProcessReceiveCallback(aMessage, messageInfo, nextHeader, aFromNcpHost));\n\n            // the caller transfers custody in the success case, so free the aMessage here\n            aMessage.Free();\n\n            ExitNow();\n        }\n\n        if (aNetif != NULL)\n        {\n            VerifyOrExit(mForwardingEnabled, forward = false);\n            header.SetHopLimit(header.GetHopLimit() - 1);\n        }\n\n        if (header.GetHopLimit() == 0)\n        {\n            // send time exceeded\n            ExitNow(error = OT_ERROR_DROP);\n        }\n        else\n        {\n            hopLimit = header.GetHopLimit();\n            aMessage.Write(Header::GetHopLimitOffset(), Header::GetHopLimitSize(), &hopLimit);\n\n            // submit aMessage to interface\n            VerifyOrExit((aNetif = GetNetifById(forwardInterfaceId)) != NULL, error = OT_ERROR_NO_ROUTE);\n            SuccessOrExit(error = aNetif->SendMessage(aMessage));\n        }\n    }\n\nexit:\n\n    if (!tunnel && (error != OT_ERROR_NONE || !forward))\n    {\n        aMessage.Free();\n    }\n\n    return error;\n}",
        "file_path": "/src/openthread/src/core/net/ip6.cpp",
        "crashing_line": "        {",
        "crashing_line_number": 933
      },
      {
        "function_name": "HandleSendQueue",
        "function_body": "void Ip6::HandleSendQueue(void)\n{\n    Message *message;\n\n    while ((message = mSendQueue.GetHead()) != NULL)\n    {\n        mSendQueue.Dequeue(*message);\n        HandleDatagram(*message, NULL, message->GetInterfaceId(), NULL, false);\n    }\n}",
        "file_path": "/src/openthread/src/core/net/ip6.cpp",
        "crashing_line": "    {",
        "crashing_line_number": 549
      },
      {
        "function_name": "ProcessQueuedTasklets",
        "function_body": "void TaskletScheduler::ProcessQueuedTasklets(void)\n{\n    Tasklet *tail = mTail;\n    Tasklet *cur;\n\n    while ((cur = PopTasklet()) != NULL)\n    {\n        cur->RunTask();\n\n        // only process tasklets that were queued at the time this method was called\n        if (cur == tail)\n        {\n            if (mHead != NULL)\n            {\n                otTaskletsSignalPending(&mHead->GetInstance());\n            }\n\n            break;\n        }\n    }\n}",
        "file_path": "/src/openthread/src/core/common/tasklet.cpp",
        "crashing_line": "        cur->RunTask();",
        "crashing_line_number": 113
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int dav1d_decode_frame_init(Dav1dFrameContext *const f) {\n    const Dav1dContext *const c = f->c;\n    int retval = DAV1D_ERR(ENOMEM);\n\n    if (f->sbh > f->lf.start_of_tile_row_sz) {\n        free(f->lf.start_of_tile_row);\n        f->lf.start_of_tile_row = malloc(f->sbh * sizeof(uint8_t));\n        if (!f->lf.start_of_tile_row) {\n            f->lf.start_of_tile_row_sz = 0;\n            goto error;\n        }\n        f->lf.start_of_tile_row_sz = f->sbh;\n    }\n    int sby = 0;\n    for (int tile_row = 0; tile_row < f->frame_hdr->tiling.rows; tile_row++) {\n        f->lf.start_of_tile_row[sby++] = tile_row;\n        while (sby < f->frame_hdr->tiling.row_start_sb[tile_row + 1])\n            f->lf.start_of_tile_row[sby++] = 0;\n    }\n\n    const int n_ts = f->frame_hdr->tiling.cols * f->frame_hdr->tiling.rows;\n    if (n_ts != f->n_ts) {\n        if (c->n_fc > 1) {\n            freep(&f->frame_thread.tile_start_off);\n            f->frame_thread.tile_start_off =\n                malloc(sizeof(*f->frame_thread.tile_start_off) * n_ts);\n            if (!f->frame_thread.tile_start_off) {\n                f->n_ts = 0;\n                goto error;\n            }\n        }\n        Dav1dTileState *ts_new = dav1d_alloc_aligned(sizeof(*f->ts) * n_ts, 32);\n        if (!ts_new) goto error;\n        if (f->ts) {\n            memcpy(ts_new, f->ts, sizeof(*f->ts) * imin(n_ts, f->n_ts));\n            dav1d_free_aligned(f->ts);\n        }\n        f->n_ts = n_ts;\n        f->ts = ts_new;\n    }\n\n    const int a_sz = f->sb128w * f->frame_hdr->tiling.rows * (1 + (c->n_fc > 1 && c->n_tc > 1));\n    if (a_sz != f->a_sz) {\n        freep(&f->a);\n        f->a = malloc(sizeof(*f->a) * a_sz);\n        if (!f->a) {\n            f->a_sz = 0;\n            goto error;\n        }\n        f->a_sz = a_sz;\n    }\n\n    const int num_sb128 = f->sb128w * f->sb128h;\n    const uint8_t *const size_mul = ss_size_mul[f->cur.p.layout];\n    const int hbd = !!f->seq_hdr->hbd;\n    if (c->n_fc > 1) {\n        int tile_idx = 0;\n        for (int tile_row = 0; tile_row < f->frame_hdr->tiling.rows; tile_row++) {\n            int row_off = f->frame_hdr->tiling.row_start_sb[tile_row] *\n                          f->sb_step * 4 * f->sb128w * 128;\n            int b_diff = (f->frame_hdr->tiling.row_start_sb[tile_row + 1] -\n                          f->frame_hdr->tiling.row_start_sb[tile_row]) * f->sb_step * 4;\n            for (int tile_col = 0; tile_col < f->frame_hdr->tiling.cols; tile_col++) {\n                f->frame_thread.tile_start_off[tile_idx++] = row_off + b_diff *\n                    f->frame_hdr->tiling.col_start_sb[tile_col] * f->sb_step * 4;\n            }\n        }\n\n        const int lowest_pixel_mem_sz = f->frame_hdr->tiling.cols * f->sbh;\n        if (lowest_pixel_mem_sz != f->tile_thread.lowest_pixel_mem_sz) {\n            free(f->tile_thread.lowest_pixel_mem);\n            f->tile_thread.lowest_pixel_mem =\n                malloc(lowest_pixel_mem_sz * sizeof(*f->tile_thread.lowest_pixel_mem));\n            if (!f->tile_thread.lowest_pixel_mem) {\n                f->tile_thread.lowest_pixel_mem_sz = 0;\n                goto error;\n            }\n            f->tile_thread.lowest_pixel_mem_sz = lowest_pixel_mem_sz;\n        }\n        int (*lowest_pixel_ptr)[7][2] = f->tile_thread.lowest_pixel_mem;\n        for (int tile_row = 0, tile_row_base = 0; tile_row < f->frame_hdr->tiling.rows;\n             tile_row++, tile_row_base += f->frame_hdr->tiling.cols)\n        {\n            const int tile_row_sb_h = f->frame_hdr->tiling.row_start_sb[tile_row + 1] -\n                                      f->frame_hdr->tiling.row_start_sb[tile_row];\n            for (int tile_col = 0; tile_col < f->frame_hdr->tiling.cols; tile_col++) {\n                f->ts[tile_row_base + tile_col].lowest_pixel = lowest_pixel_ptr;\n                lowest_pixel_ptr += tile_row_sb_h;\n            }\n        }\n\n        const int cf_sz = (num_sb128 * size_mul[0]) << hbd;\n        if (cf_sz != f->frame_thread.cf_sz) {\n            dav1d_freep_aligned(&f->frame_thread.cf);\n            f->frame_thread.cf =\n                dav1d_alloc_aligned((size_t)cf_sz * 128 * 128 / 2, 64);\n            if (!f->frame_thread.cf) {\n                f->frame_thread.cf_sz = 0;\n                goto error;\n            }\n            memset(f->frame_thread.cf, 0, (size_t)cf_sz * 128 * 128 / 2);\n            f->frame_thread.cf_sz = cf_sz;\n        }\n\n        if (f->frame_hdr->allow_screen_content_tools) {\n            if (num_sb128 != f->frame_thread.pal_sz) {\n                dav1d_freep_aligned(&f->frame_thread.pal);\n                f->frame_thread.pal =\n                    dav1d_alloc_aligned(sizeof(*f->frame_thread.pal) *\n                                        num_sb128 * 16 * 16, 64);\n                if (!f->frame_thread.pal) {\n                    f->frame_thread.pal_sz = 0;\n                    goto error;\n                }\n                f->frame_thread.pal_sz = num_sb128;\n            }\n\n            const int pal_idx_sz = num_sb128 * size_mul[1];\n            if (pal_idx_sz != f->frame_thread.pal_idx_sz) {\n                dav1d_freep_aligned(&f->frame_thread.pal_idx);\n                f->frame_thread.pal_idx =\n                    dav1d_alloc_aligned(sizeof(*f->frame_thread.pal_idx) *\n                                        pal_idx_sz * 128 * 128 / 4, 64);\n                if (!f->frame_thread.pal_idx) {\n                    f->frame_thread.pal_idx_sz = 0;\n                    goto error;\n                }\n                f->frame_thread.pal_idx_sz = pal_idx_sz;\n            }\n        } else if (f->frame_thread.pal) {\n            dav1d_freep_aligned(&f->frame_thread.pal);\n            dav1d_freep_aligned(&f->frame_thread.pal_idx);\n            f->frame_thread.pal_sz = f->frame_thread.pal_idx_sz = 0;\n        }\n    }\n\n    // update allocation of block contexts for above\n    ptrdiff_t y_stride = f->cur.stride[0], uv_stride = f->cur.stride[1];\n    const int has_resize = f->frame_hdr->width[0] != f->frame_hdr->width[1];\n    const int need_cdef_lpf_copy = c->n_tc > 1 && has_resize;\n    if (y_stride * f->sbh * 4 != f->lf.cdef_buf_plane_sz[0] ||\n        uv_stride * f->sbh * 8 != f->lf.cdef_buf_plane_sz[1] ||\n        need_cdef_lpf_copy != f->lf.need_cdef_lpf_copy)\n    {\n        dav1d_free_aligned(f->lf.cdef_line_buf);\n        size_t alloc_sz = 64;\n        alloc_sz += (size_t)llabs(y_stride) * 4 * f->sbh << need_cdef_lpf_copy;\n        alloc_sz += (size_t)llabs(uv_stride) * 8 * f->sbh << need_cdef_lpf_copy;\n        uint8_t *ptr = f->lf.cdef_line_buf = dav1d_alloc_aligned(alloc_sz, 32);\n        if (!ptr) {\n            f->lf.cdef_buf_plane_sz[0] = f->lf.cdef_buf_plane_sz[1] = 0;\n            goto error;\n        }\n\n        ptr += 32;\n        if (y_stride < 0) {\n            f->lf.cdef_line[0][0] = ptr - y_stride * (f->sbh * 4 - 1);\n            f->lf.cdef_line[1][0] = ptr - y_stride * (f->sbh * 4 - 3);\n        } else {\n            f->lf.cdef_line[0][0] = ptr + y_stride * 0;\n            f->lf.cdef_line[1][0] = ptr + y_stride * 2;\n        }\n        ptr += llabs(y_stride) * f->sbh * 4;\n        if (uv_stride < 0) {\n            f->lf.cdef_line[0][1] = ptr - uv_stride * (f->sbh * 8 - 1);\n            f->lf.cdef_line[0][2] = ptr - uv_stride * (f->sbh * 8 - 3);\n            f->lf.cdef_line[1][1] = ptr - uv_stride * (f->sbh * 8 - 5);\n            f->lf.cdef_line[1][2] = ptr - uv_stride * (f->sbh * 8 - 7);\n        } else {\n            f->lf.cdef_line[0][1] = ptr + uv_stride * 0;\n            f->lf.cdef_line[0][2] = ptr + uv_stride * 2;\n            f->lf.cdef_line[1][1] = ptr + uv_stride * 4;\n            f->lf.cdef_line[1][2] = ptr + uv_stride * 6;\n        }\n\n        if (need_cdef_lpf_copy) {\n            ptr += llabs(uv_stride) * f->sbh * 8;\n            if (y_stride < 0)\n                f->lf.cdef_lpf_line[0] = ptr - y_stride * (f->sbh * 4 - 1);\n            else\n                f->lf.cdef_lpf_line[0] = ptr;\n            ptr += llabs(y_stride) * f->sbh * 4;\n            if (uv_stride < 0) {\n                f->lf.cdef_lpf_line[1] = ptr - uv_stride * (f->sbh * 4 - 1);\n                f->lf.cdef_lpf_line[2] = ptr - uv_stride * (f->sbh * 8 - 1);\n            } else {\n                f->lf.cdef_lpf_line[1] = ptr;\n                f->lf.cdef_lpf_line[2] = ptr + uv_stride * f->sbh * 4;\n            }\n        }\n\n        f->lf.cdef_buf_plane_sz[0] = (int) y_stride * f->sbh * 4;\n        f->lf.cdef_buf_plane_sz[1] = (int) uv_stride * f->sbh * 8;\n        f->lf.need_cdef_lpf_copy = need_cdef_lpf_copy;\n    }\n\n    const int sb128 = f->seq_hdr->sb128;\n    const int num_lines = c->n_tc > 1 ? f->sbh * 4 << sb128 : 12;\n    y_stride = f->sr_cur.p.stride[0], uv_stride = f->sr_cur.p.stride[1];\n    if (y_stride * num_lines != f->lf.lr_buf_plane_sz[0] ||\n        uv_stride * num_lines * 2 != f->lf.lr_buf_plane_sz[1])\n    {\n        dav1d_free_aligned(f->lf.lr_line_buf);\n        // lr simd may overread the input, so slightly over-allocate the lpf buffer\n        size_t alloc_sz = 64;\n        alloc_sz += (size_t)llabs(y_stride) * num_lines;\n        alloc_sz += (size_t)llabs(uv_stride) * num_lines * 2;\n        uint8_t *ptr = f->lf.lr_line_buf = dav1d_alloc_aligned(alloc_sz, 32);\n        if (!ptr) {\n            f->lf.lr_buf_plane_sz[0] = f->lf.lr_buf_plane_sz[1] = 0;\n            goto error;\n        }\n\n        if (y_stride < 0)\n            f->lf.lr_lpf_line[0] = ptr - y_stride * (num_lines - 1);\n        else\n            f->lf.lr_lpf_line[0] = ptr;\n        ptr += llabs(y_stride) * num_lines;\n        if (uv_stride < 0) {\n            f->lf.lr_lpf_line[1] = ptr - uv_stride * (num_lines * 1 - 1);\n            f->lf.lr_lpf_line[2] = ptr - uv_stride * (num_lines * 2 - 1);\n        } else {\n            f->lf.lr_lpf_line[1] = ptr;\n            f->lf.lr_lpf_line[2] = ptr + uv_stride * num_lines;\n        }\n\n        f->lf.lr_buf_plane_sz[0] = (int) y_stride * num_lines;\n        f->lf.lr_buf_plane_sz[1] = (int) uv_stride * num_lines * 2;\n    }\n\n    // update allocation for loopfilter masks\n    if (num_sb128 != f->lf.mask_sz) {\n        freep(&f->lf.mask);\n        freep(&f->lf.level);\n        f->lf.mask = malloc(sizeof(*f->lf.mask) * num_sb128);\n        // over-allocate by 3 bytes since some of the SIMD implementations\n        // index this from the level type and can thus over-read by up to 3\n        f->lf.level = malloc(sizeof(*f->lf.level) * num_sb128 * 32 * 32 + 3);\n        if (!f->lf.mask || !f->lf.level) {\n            f->lf.mask_sz = 0;\n            goto error;\n        }\n        if (c->n_fc > 1) {\n            freep(&f->frame_thread.b);\n            freep(&f->frame_thread.cbi);\n            f->frame_thread.b = malloc(sizeof(*f->frame_thread.b) *\n                                       num_sb128 * 32 * 32);\n            f->frame_thread.cbi = malloc(sizeof(*f->frame_thread.cbi) *\n                                         num_sb128 * 32 * 32);\n            if (!f->frame_thread.b || !f->frame_thread.cbi) {\n                f->lf.mask_sz = 0;\n                goto error;\n            }\n        }\n        f->lf.mask_sz = num_sb128;\n    }\n\n    f->sr_sb128w = (f->sr_cur.p.p.w + 127) >> 7;\n    const int lr_mask_sz = f->sr_sb128w * f->sb128h;\n    if (lr_mask_sz != f->lf.lr_mask_sz) {\n        freep(&f->lf.lr_mask);\n        f->lf.lr_mask = malloc(sizeof(*f->lf.lr_mask) * lr_mask_sz);\n        if (!f->lf.lr_mask) {\n            f->lf.lr_mask_sz = 0;\n            goto error;\n        }\n        f->lf.lr_mask_sz = lr_mask_sz;\n    }\n    f->lf.restore_planes =\n        ((f->frame_hdr->restoration.type[0] != DAV1D_RESTORATION_NONE) << 0) +\n        ((f->frame_hdr->restoration.type[1] != DAV1D_RESTORATION_NONE) << 1) +\n        ((f->frame_hdr->restoration.type[2] != DAV1D_RESTORATION_NONE) << 2);\n    if (f->frame_hdr->loopfilter.sharpness != f->lf.last_sharpness) {\n        dav1d_calc_eih(&f->lf.lim_lut, f->frame_hdr->loopfilter.sharpness);\n        f->lf.last_sharpness = f->frame_hdr->loopfilter.sharpness;\n    }\n    dav1d_calc_lf_values(f->lf.lvl, f->frame_hdr, (int8_t[4]) { 0, 0, 0, 0 });\n    memset(f->lf.mask, 0, sizeof(*f->lf.mask) * num_sb128);\n\n    const int ipred_edge_sz = f->sbh * f->sb128w << hbd;\n    if (ipred_edge_sz != f->ipred_edge_sz) {\n        dav1d_freep_aligned(&f->ipred_edge[0]);\n        uint8_t *ptr = f->ipred_edge[0] =\n            dav1d_alloc_aligned(ipred_edge_sz * 128 * 3, 64);\n        if (!ptr) {\n            f->ipred_edge_sz = 0;\n            goto error;\n        }\n        f->ipred_edge[1] = ptr + ipred_edge_sz * 128 * 1;\n        f->ipred_edge[2] = ptr + ipred_edge_sz * 128 * 2;\n        f->ipred_edge_sz = ipred_edge_sz;\n    }\n\n    const int re_sz = f->sb128h * f->frame_hdr->tiling.cols;\n    if (re_sz != f->lf.re_sz) {\n        freep(&f->lf.tx_lpf_right_edge[0]);\n        f->lf.tx_lpf_right_edge[0] = malloc(re_sz * 32 * 2);\n        if (!f->lf.tx_lpf_right_edge[0]) {\n            f->lf.re_sz = 0;\n            goto error;\n        }\n        f->lf.tx_lpf_right_edge[1] = f->lf.tx_lpf_right_edge[0] + re_sz * 32;\n        f->lf.re_sz = re_sz;\n    }\n\n    // init ref mvs\n    if (IS_INTER_OR_SWITCH(f->frame_hdr) || f->frame_hdr->allow_intrabc) {\n        const int ret =\n            dav1d_refmvs_init_frame(&f->rf, f->seq_hdr, f->frame_hdr,\n                                    f->refpoc, f->mvs, f->refrefpoc, f->ref_mvs,\n                                    f->c->n_tc, f->c->n_fc);\n        if (ret < 0) goto error;\n    }\n\n    retval = DAV1D_ERR(EINVAL);\n\n    // setup dequant tables\n    init_quant_tables(f->seq_hdr, f->frame_hdr, f->frame_hdr->quant.yac, f->dq);\n    if (f->frame_hdr->quant.qm)\n        for (int i = 0; i < N_RECT_TX_SIZES; i++) {\n            f->qm[i][0] = dav1d_qm_tbl[f->frame_hdr->quant.qm_y][0][i];\n            f->qm[i][1] = dav1d_qm_tbl[f->frame_hdr->quant.qm_u][1][i];\n            f->qm[i][2] = dav1d_qm_tbl[f->frame_hdr->quant.qm_v][1][i];\n        }\n    else\n        memset(f->qm, 0, sizeof(f->qm));\n\n    // setup jnt_comp weights\n    if (f->frame_hdr->switchable_comp_refs) {\n        for (int i = 0; i < 7; i++) {\n            const unsigned ref0poc = f->refp[i].p.frame_hdr->frame_offset;\n\n            for (int j = i + 1; j < 7; j++) {\n                const unsigned ref1poc = f->refp[j].p.frame_hdr->frame_offset;\n\n                const unsigned d1 =\n                    imin(abs(get_poc_diff(f->seq_hdr->order_hint_n_bits, ref0poc,\n                                          f->cur.frame_hdr->frame_offset)), 31);\n                const unsigned d0 =\n                    imin(abs(get_poc_diff(f->seq_hdr->order_hint_n_bits, ref1poc,\n                                          f->cur.frame_hdr->frame_offset)), 31);\n                const int order = d0 <= d1;\n\n                static const uint8_t quant_dist_weight[3][2] = {\n                    { 2, 3 }, { 2, 5 }, { 2, 7 }\n                };\n                static const uint8_t quant_dist_lookup_table[4][2] = {\n                    { 9, 7 }, { 11, 5 }, { 12, 4 }, { 13, 3 }\n                };\n\n                int k;\n                for (k = 0; k < 3; k++) {\n                    const int c0 = quant_dist_weight[k][order];\n                    const int c1 = quant_dist_weight[k][!order];\n                    const int d0_c0 = d0 * c0;\n                    const int d1_c1 = d1 * c1;\n                    if ((d0 > d1 && d0_c0 < d1_c1) || (d0 <= d1 && d0_c0 > d1_c1)) break;\n                }\n\n                f->jnt_weights[i][j] = quant_dist_lookup_table[k][order];\n            }\n        }\n    }\n\n    /* Init loopfilter pointers. Increasing NULL pointers is technically UB,\n     * so just point the chroma pointers in 4:0:0 to the luma plane here to\n     * avoid having additional in-loop branches in various places. We never\n     * dereference those pointers so it doesn't really matter what they\n     * point at, as long as the pointers are valid. */\n    const int has_chroma = f->cur.p.layout != DAV1D_PIXEL_LAYOUT_I400;\n    f->lf.mask_ptr = f->lf.mask;\n    f->lf.p[0] = f->cur.data[0];\n    f->lf.p[1] = f->cur.data[has_chroma ? 1 : 0];\n    f->lf.p[2] = f->cur.data[has_chroma ? 2 : 0];\n    f->lf.sr_p[0] = f->sr_cur.p.data[0];\n    f->lf.sr_p[1] = f->sr_cur.p.data[has_chroma ? 1 : 0];\n    f->lf.sr_p[2] = f->sr_cur.p.data[has_chroma ? 2 : 0];\n\n    if (f->frame_hdr->refresh_context)\n        dav1d_cdf_thread_copy(f->out_cdf.data.cdf, &f->in_cdf);\n\n    // parse individual tiles per tile group\n    int tile_row = 0, tile_col = 0;\n    f->task_thread.update_set = 0;\n    for (int i = 0; i < f->n_tile_data; i++) {\n        const uint8_t *data = f->tile[i].data.data;\n        size_t size = f->tile[i].data.sz;\n\n        for (int j = f->tile[i].start; j <= f->tile[i].end; j++) {\n            size_t tile_sz;\n            if (j == f->tile[i].end) {\n                tile_sz = size;\n            } else {\n                if (f->frame_hdr->tiling.n_bytes > size) goto error;\n                tile_sz = 0;\n                for (unsigned k = 0; k < f->frame_hdr->tiling.n_bytes; k++)\n                    tile_sz |= (unsigned)*data++ << (k * 8);\n                tile_sz++;\n                size -= f->frame_hdr->tiling.n_bytes;\n                if (tile_sz > size) goto error;\n            }\n\n            setup_tile(&f->ts[j], f, data, tile_sz, tile_row, tile_col++,\n                       c->n_fc > 1 ? f->frame_thread.tile_start_off[j] : 0);\n\n            if (tile_col == f->frame_hdr->tiling.cols) {\n                tile_col = 0;\n                tile_row++;\n            }\n            if (j == f->frame_hdr->tiling.update && f->frame_hdr->refresh_context)\n                f->task_thread.update_set = 1;\n            data += tile_sz;\n            size -= tile_sz;\n        }\n    }\n\n    if (c->n_tc > 1) {\n        const int uses_2pass = c->n_fc > 1;\n        for (int n = 0; n < f->sb128w * f->frame_hdr->tiling.rows * (1 + uses_2pass); n++)\n            reset_context(&f->a[n], IS_KEY_OR_INTRA(f->frame_hdr),\n                          uses_2pass ? 1 + (n >= f->sb128w * f->frame_hdr->tiling.rows) : 0);\n    }\n\n    retval = 0;\nerror:\n    return retval;\n}\n",
    "target": 1,
    "idx": 1040661,
    "stack_trace": [
      {
        "function_name": "backup2lines",
        "function_body": "",
        "file_path": "/work/build/../../src/dav1d/src/cdef_apply_tmpl.c",
        "crashing_line": "",
        "crashing_line_number": 59
      },
      {
        "function_name": "dav1d_cdef_brow_8bpc",
        "function_body": "",
        "file_path": "/work/build/../../src/dav1d/src/cdef_apply_tmpl.c",
        "crashing_line": "",
        "crashing_line_number": 138
      },
      {
        "function_name": "dav1d_filter_sbrow_cdef_8bpc",
        "function_body": "",
        "file_path": "/work/build/../../src/dav1d/src/recon_tmpl.c",
        "crashing_line": "",
        "crashing_line_number": 2100
      },
      {
        "function_name": "dav1d_worker_task",
        "function_body": "",
        "file_path": "/work/build/../../src/dav1d/src/thread_task.c",
        "crashing_line": "",
        "crashing_line_number": 610
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "FMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& fp,\n                                    const basic_format_specs<Char>& specs,\n                                    float_specs fspecs, locale_ref loc)\n    -> OutputIt {\n  auto significand = fp.significand;\n  int significand_size = get_significand_size(fp);\n  constexpr Char zero = static_cast<Char>('0');\n  auto sign = fspecs.sign;\n  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);\n  using iterator = reserve_iterator<OutputIt>;\n\n  Char decimal_point =\n      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');\n\n  int output_exp = fp.exponent + significand_size - 1;\n  auto use_exp_format = [=]() {\n    if (fspecs.format == float_format::exp) return true;\n    if (fspecs.format != float_format::general) return false;\n    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),\n    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.\n    const int exp_lower = -4, exp_upper = 16;\n    return output_exp < exp_lower ||\n           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);\n  };\n  if (use_exp_format()) {\n    int num_zeros = 0;\n    if (fspecs.showpoint) {\n      num_zeros = fspecs.precision - significand_size;\n      if (num_zeros < 0) num_zeros = 0;\n      size += to_unsigned(num_zeros);\n    } else if (significand_size == 1) {\n      decimal_point = Char();\n    }\n    auto abs_output_exp = output_exp >= 0 ? output_exp : -output_exp;\n    int exp_digits = 2;\n    if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;\n\n    size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);\n    char exp_char = fspecs.upper ? 'E' : 'e';\n    auto write = [=](iterator it) {\n      if (sign) *it++ = detail::sign<Char>(sign);\n      // Insert a decimal point after the first digit and add an exponent.\n      it = write_significand(it, significand, significand_size, 1,\n                             decimal_point);\n      if (num_zeros > 0) it = detail::fill_n(it, num_zeros, zero);\n      *it++ = static_cast<Char>(exp_char);\n      return write_exponent<Char>(output_exp, it);\n    };\n    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)\n                           : base_iterator(out, write(reserve(out, size)));\n  }\n\n  int exp = fp.exponent + significand_size;\n  if (fp.exponent >= 0) {\n    // 1234e5 -> 123400000[.0+]\n    size += to_unsigned(fp.exponent);\n    int num_zeros = fspecs.precision - exp;\n#ifdef FMT_FUZZ\n    if (num_zeros > 5000)\n      throw std::runtime_error(\"fuzz mode - avoiding excessive cpu use\");\n#endif\n    if (fspecs.showpoint) {\n      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 1;\n      if (num_zeros > 0) size += to_unsigned(num_zeros) + 1;\n    }\n    auto grouping = Grouping(loc, fspecs.locale);\n    size += to_unsigned(grouping.count_separators(significand_size));\n    return write_padded<align::right>(out, specs, size, [&](iterator it) {\n      if (sign) *it++ = detail::sign<Char>(sign);\n      it = write_significand<Char>(it, significand, significand_size,\n                                   fp.exponent, grouping);\n      if (!fspecs.showpoint) return it;\n      *it++ = decimal_point;\n      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;\n    });\n  } else if (exp > 0) {\n    // 1234e-2 -> 12.34[0+]\n    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;\n    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);\n    auto grouping = Grouping(loc, fspecs.locale);\n    size += to_unsigned(grouping.count_separators(significand_size));\n    return write_padded<align::right>(out, specs, size, [&](iterator it) {\n      if (sign) *it++ = detail::sign<Char>(sign);\n      it = write_significand(it, significand, significand_size, exp,\n                             decimal_point, grouping);\n      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;\n    });\n  }\n  // 1234e-6 -> 0.001234\n  int num_zeros = -exp;\n  if (significand_size == 0 && fspecs.precision >= 0 &&\n      fspecs.precision < num_zeros) {\n    num_zeros = fspecs.precision;\n  }\n  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;\n  size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);\n  return write_padded<align::right>(out, specs, size, [&](iterator it) {\n    if (sign) *it++ = detail::sign<Char>(sign);\n    *it++ = zero;\n    if (!pointy) return it;\n    *it++ = decimal_point;\n    it = detail::fill_n(it, num_zeros, zero);\n    return write_significand<Char>(it, significand, significand_size);\n  });\n}\n",
    "target": 1,
    "idx": 1044791,
    "stack_trace": [
      {
        "function_name": "digit_grouping<char> >",
        "function_body": "  explicit digit_grouping(thousands_sep_result<Char> sep) : sep_(sep) {}",
        "file_path": "/src/fmt/include/fmt/format.h",
        "crashing_line": "",
        "crashing_line_number": 2114
      },
      {
        "function_name": "write_padded<",
        "function_body": "constexpr auto write_padded(OutputIt out, const basic_format_specs<Char>& specs,\n                            size_t size, F&& f) -> OutputIt {\n  return write_padded<align>(out, specs, size, size, f);\n}",
        "file_path": "/src/fmt/include/fmt/format.h",
        "crashing_line": "",
        "crashing_line_number": 1371
      },
      {
        "function_name": "write_padded<",
        "function_body": "constexpr auto write_padded(OutputIt out, const basic_format_specs<Char>& specs,\n                            size_t size, F&& f) -> OutputIt {\n  return write_padded<align>(out, specs, size, size, f);\n}",
        "file_path": "/src/fmt/include/fmt/format.h",
        "crashing_line": "  return write_padded<align>(out, specs, size, size, f);",
        "crashing_line_number": 1380
      },
      {
        "function_name": "digit_grouping<char> >",
        "function_body": "  explicit digit_grouping(thousands_sep_result<Char> sep) : sep_(sep) {}",
        "file_path": "/src/fmt/include/fmt/format.h",
        "crashing_line": "",
        "crashing_line_number": 2109
      },
      {
        "function_name": "big_decimal_fp, char>",
        "function_body": "",
        "file_path": "/src/fmt/include/fmt/format.h",
        "crashing_line": "",
        "crashing_line_number": 2172
      },
      {
        "function_name": "allocator<char> > >, long double, 0>",
        "function_body": "",
        "file_path": "/src/fmt/include/fmt/format.h",
        "crashing_line": "",
        "crashing_line_number": 2266
      },
      {
        "function_name": "allocator<char> > >, 0>",
        "function_body": "",
        "file_path": "/src/fmt/include/fmt/chrono.h",
        "crashing_line": "",
        "crashing_line_number": 1529
      },
      {
        "function_name": "decltype",
        "function_body": "",
        "file_path": "/src/fmt/include/fmt/chrono.h",
        "crashing_line": "",
        "crashing_line_number": 1996
      },
      {
        "function_name": "ratio<1l, 1000000l> >, char, void> >",
        "function_body": "",
        "file_path": "/src/fmt/include/fmt/core.h",
        "crashing_line": "",
        "crashing_line_number": 1258
      },
      {
        "function_name": "format",
        "function_body": "FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)\n    -> std::string {\n  return vformat(fmt, fmt::make_format_args(args...));\n}",
        "file_path": "/src/fmt/include/fmt/core.h",
        "crashing_line": "",
        "crashing_line_number": 1542
      },
      {
        "function_name": "operator",
        "function_body": "  friend auto operator|(const uint128_fallback& lhs,\n                        const uint128_fallback& rhs) -> uint128_fallback {\n    return {lhs.hi_ | rhs.hi_, lhs.lo_ | rhs.lo_};\n  }",
        "file_path": "/src/fmt/include/fmt/format.h",
        "crashing_line": "",
        "crashing_line_number": 2467
      },
      {
        "function_name": "decltype",
        "function_body": "  FMT_CONSTEXPR auto type(int index) const -> detail::type {\n    int shift = index * detail::packed_arg_bits;\n    unsigned int mask = (1 << detail::packed_arg_bits) - 1;\n    return static_cast<detail::type>((desc_ >> shift) & mask);\n  }",
        "file_path": "/src/fmt/include/fmt/core.h",
        "crashing_line": "",
        "crashing_line_number": 1606
      },
      {
        "function_name": "vformat_to<char>",
        "function_body": "auto vformat_to(OutputIt out, const Locale& loc, string_view fmt,\n                format_args args) -> OutputIt {\n  using detail::get_buffer;\n  auto&& buf = get_buffer<char>(out);\n  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));\n  return detail::get_iterator(buf);\n}",
        "file_path": "/src/fmt/include/fmt/format.h",
        "crashing_line": "",
        "crashing_line_number": 3187
      },
      {
        "function_name": "vformat_to<char>",
        "function_body": "auto vformat_to(OutputIt out, string_view fmt, format_args args) -> OutputIt {\n  using detail::get_buffer;\n  auto&& buf = get_buffer<char>(out);\n  detail::vformat_to(buf, fmt, args, {});\n  return detail::get_iterator(buf);\n}",
        "file_path": "/src/fmt/include/fmt/core.h",
        "crashing_line": "",
        "crashing_line_number": 2587
      },
      {
        "function_name": "vformat_to<char>",
        "function_body": "auto vformat_to(OutputIt out, string_view fmt, format_args args) -> OutputIt {\n  using detail::get_buffer;\n  auto&& buf = get_buffer<char>(out);\n  detail::vformat_to(buf, fmt, args, {});\n  return detail::get_iterator(buf);\n}",
        "file_path": "/src/fmt/include/fmt/core.h",
        "crashing_line": "",
        "crashing_line_number": 2646
      },
      {
        "function_name": "vformat_to<char>",
        "function_body": "auto vformat_to(OutputIt out, const Locale& loc, string_view fmt,\n                format_args args) -> OutputIt {\n  using detail::get_buffer;\n  auto&& buf = get_buffer<char>(out);\n  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));\n  return detail::get_iterator(buf);\n}",
        "file_path": "/src/fmt/include/fmt/format.h",
        "crashing_line": "",
        "crashing_line_number": 3201
      },
      {
        "function_name": "allocator<char> > >, 0>",
        "function_body": "",
        "file_path": "/src/fmt/include/fmt/core.h",
        "crashing_line": "",
        "crashing_line_number": 3137
      },
      {
        "function_name": "ratio<1l, 1000000l> >&, 0>",
        "function_body": "",
        "file_path": "/src/fmt/include/fmt/core.h",
        "crashing_line": "",
        "crashing_line_number": 3157
      },
      {
        "function_name": "ratio<1l, 1000000l>, long double>",
        "function_body": "",
        "file_path": "/src/fmt/test/fuzzing/chrono-duration.cc",
        "crashing_line": "",
        "crashing_line_number": 18
      },
      {
        "function_name": "void invoke_outer<long double>",
        "function_body": "void invoke_outer(const uint8_t* data, size_t size, int period) {\n  // Always use a fixed location of the data.\n  static_assert(sizeof(Rep) <= fixed_size, \"fixed size is too small\");\n  if (size <= fixed_size + 1) return;\n\n  const Rep rep = assign_from_buf<Rep>(data);\n  data += fixed_size;\n  size -= fixed_size;\n\n  // data is already allocated separately in libFuzzer so reading past the end\n  // will most likely be detected anyway.\n  const auto format_str = fmt::string_view(as_chars(data), size);\n\n  // yocto, zepto, zetta and yotta are not handled.\n  switch (period) {\n  case 1:\n    invoke_inner<std::atto>(format_str, rep);\n    break;\n  case 2:\n    invoke_inner<std::femto>(format_str, rep);\n    break;\n  case 3:\n    invoke_inner<std::pico>(format_str, rep);\n    break;\n  case 4:\n    invoke_inner<std::nano>(format_str, rep);\n    break;\n  case 5:\n    invoke_inner<std::micro>(format_str, rep);\n    break;\n  case 6:\n    invoke_inner<std::milli>(format_str, rep);\n    break;\n  case 7:\n    invoke_inner<std::centi>(format_str, rep);\n    break;\n  case 8:\n    invoke_inner<std::deci>(format_str, rep);\n    break;\n  case 9:\n    invoke_inner<std::deca>(format_str, rep);\n    break;\n  case 10:\n    invoke_inner<std::kilo>(format_str, rep);\n    break;\n  case 11:\n    invoke_inner<std::mega>(format_str, rep);\n    break;\n  case 12:\n    invoke_inner<std::giga>(format_str, rep);\n    break;\n  case 13:\n    invoke_inner<std::tera>(format_str, rep);\n    break;\n  case 14:\n    invoke_inner<std::peta>(format_str, rep);\n    break;\n  case 15:\n    invoke_inner<std::exa>(format_str, rep);\n    break;\n  }\n}",
        "file_path": "/src/fmt/test/fuzzing/chrono-duration.cc",
        "crashing_line": "    invoke_inner<std::micro>(format_str, rep);",
        "crashing_line_number": 54
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int\nwavlike_read_cart_chunk (SF_PRIVATE *psf, uint32_t chunksize)\n{\tSF_CART_INFO_16K *c ;\n\tuint32_t bytes = 0 ;\n\tint k ;\n\n\tif (chunksize < WAV_CART_MIN_CHUNK_SIZE)\n\t{\tpsf_log_printf (psf, \"cart : %u (should be >= %d)\\n\", chunksize, WAV_CART_MIN_CHUNK_SIZE) ;\n\t\tpsf_binheader_readf (psf, \"j\", chunksize) ;\n\t\treturn 0 ;\n\t\t} ;\n\tif (chunksize > WAV_CART_MAX_CHUNK_SIZE)\n\t{\tpsf_log_printf (psf, \"cart : %u (should be < %d)\\n\", chunksize, WAV_CART_MAX_CHUNK_SIZE) ;\n\t\tpsf_binheader_readf (psf, \"j\", chunksize) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (chunksize >= sizeof (SF_CART_INFO_16K))\n\t{\tpsf_log_printf (psf, \"cart : %u too big to be handled\\n\", chunksize) ;\n\t\tpsf_binheader_readf (psf, \"j\", chunksize) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"cart : %u\\n\", chunksize) ;\n\n\tif (psf->cart_16k)\n\t{\tpsf_log_printf (psf, \"  Found more than one cart chunk, using last one.\\n\") ;\n\t\tfree (psf->cart_16k) ;\n\t\tpsf->cart_16k = NULL ;\n\t\t} ;\n\n\tif ((psf->cart_16k = cart_var_alloc ()) == NULL)\n\t{\tpsf->error = SFE_MALLOC_FAILED ;\n\t\treturn psf->error ;\n\t\t} ;\n\n\tc = psf->cart_16k ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->version, sizeof (c->version)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->title, sizeof (c->title)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->artist, sizeof (c->artist)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->cut_id, sizeof (c->cut_id)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->client_id, sizeof (c->client_id)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->category, sizeof (c->category)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->classification, sizeof (c->classification)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->out_cue, sizeof (c->out_cue)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->start_date, sizeof (c->start_date)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->start_time, sizeof (c->start_time)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->end_date, sizeof (c->end_date)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->end_time, sizeof (c->end_time)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->producer_app_id, sizeof (c->producer_app_id)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->producer_app_version, sizeof (c->producer_app_version)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->user_def, sizeof (c->user_def)) ;\n\tbytes += psf_binheader_readf (psf, \"e4\", &c->level_reference, sizeof (c->level_reference)) ;\n\n\tfor (k = 0 ; k < ARRAY_LEN (c->post_timers) ; k++)\n\t\tbytes += psf_binheader_readf (psf, \"b4\", &c->post_timers [k].usage, make_size_t (4), &c->post_timers [k].value) ;\n\n\tbytes += psf_binheader_readf (psf, \"b\", c->reserved, sizeof (c->reserved)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->url, sizeof (c->url)) ;\n\n\tif (chunksize > WAV_CART_MIN_CHUNK_SIZE)\n\t{\t/* File has tag text. */\n\t\tc->tag_text_size = chunksize - WAV_CART_MIN_CHUNK_SIZE ;\n\t\tbytes += psf_binheader_readf (psf, \"b\", c->tag_text, make_size_t (c->tag_text_size)) ;\n\t\t} ;\n\n\treturn 0 ;\n} /* wavlike_read_cart_chunk */\n",
    "target": 1,
    "idx": 1026026,
    "stack_trace": [
      {
        "function_name": "memset",
        "function_body": "",
        "file_path": "/usr/include/x86_64-linux-gnu/bits/string3.h",
        "crashing_line": "",
        "crashing_line_number": 90
      },
      {
        "function_name": "psf_binheader_readf",
        "function_body": "int\npsf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)\n{\tva_list\t\t\targptr ;\n\tsf_count_t\t\t*countptr, countdata ;\n\tunsigned char\t*ucptr, sixteen_bytes [16] ;\n\tunsigned int \t*intptr, intdata ;\n\tunsigned short\t*shortptr ;\n\tchar\t\t\t*charptr ;\n\tfloat\t\t\t*floatptr ;\n\tdouble\t\t\t*doubleptr ;\n\tchar\t\t\tc ;\n\tint\t\t\t\tbyte_count = 0, count = 0 ;\n\n\tif (! format)\n\t\treturn psf_ftell (psf) ;\n\n\tva_start (argptr, format) ;\n\n\twhile ((c = *format++))\n\t{\n\t\tif (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))\n\t\t\treturn count ;\n\n\t\tswitch (c)\n\t\t{\tcase 'e' : /* All conversions are now from LE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'E' : /* All conversions are now from BE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_BIG ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'm' : /* 4 byte marker value eg 'RIFF' */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) intptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;\n\t\t\t\t\t*intptr = GET_MARKER (ucptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'h' :\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) intptr ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;\n\t\t\t\t\t{\tint k ;\n\t\t\t\t\t\tintdata = 0 ;\n\t\t\t\t\t\tfor (k = 0 ; k < 16 ; k++)\n\t\t\t\t\t\t\tintdata ^= sixteen_bytes [k] << k ;\n\t\t\t\t\t\t}\n\t\t\t\t\t*intptr = intdata ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '1' :\n\t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n\t\t\t\t\t*charptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, charptr, sizeof (char)) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '2' : /* 2 byte value with the current endian-ness */\n\t\t\t\t\tshortptr = va_arg (argptr, unsigned short*) ;\n\t\t\t\t\t*shortptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) shortptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (short)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*shortptr = GET_BE_SHORT (ucptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*shortptr = GET_LE_SHORT (ucptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '3' : /* 3 byte value with the current endian-ness */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, 3) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*intptr = GET_BE_3BYTE (sixteen_bytes) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*intptr = GET_LE_3BYTE (sixteen_bytes) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '4' : /* 4 byte value with the current endian-ness */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) intptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*intptr = psf_get_be32 (ucptr, 0) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*intptr = psf_get_le32 (ucptr, 0) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '8' : /* 8 byte value with the current endian-ness */\n\t\t\t\t\tcountptr = va_arg (argptr, sf_count_t *) ;\n\t\t\t\t\t*countptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, 8) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tcountdata = psf_get_be64 (sixteen_bytes, 0) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tcountdata = psf_get_le64 (sixteen_bytes, 0) ;\n\t\t\t\t\t*countptr = countdata ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'f' : /* Float conversion */\n\t\t\t\t\tfloatptr = va_arg (argptr, float *) ;\n\t\t\t\t\t*floatptr = 0.0 ;\n\t\t\t\t\tbyte_count += header_read (psf, floatptr, sizeof (float)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*floatptr = float32_be_read ((unsigned char*) floatptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*floatptr = float32_le_read ((unsigned char*) floatptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd' : /* double conversion */\n\t\t\t\t\tdoubleptr = va_arg (argptr, double *) ;\n\t\t\t\t\t*doubleptr = 0.0 ;\n\t\t\t\t\tbyte_count += header_read (psf, doubleptr, sizeof (double)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*doubleptr = double64_be_read ((unsigned char*) doubleptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*doubleptr = double64_le_read ((unsigned char*) doubleptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 's' :\n\t\t\t\t\tpsf_log_printf (psf, \"Format conversion 's' not implemented yet.\\n\") ;\n\t\t\t\t\t/*\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize   = strlen (strptr) + 1 ;\n\t\t\t\t\tsize  += (size & 1) ;\n\t\t\t\t\tlongdata = H2LE_32 (size) ;\n\t\t\t\t\tget_int (psf, longdata) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\t*/\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'b' : /* Raw bytes */\n\t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\tmemset (charptr, 0, count) ;\n\t\t\t\t\tbyte_count += header_read (psf, charptr, count) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'G' :\n\t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\tmemset (charptr, 0, count) ;\n\n\t\t\t\t\tif (psf->header.indx + count >= psf->header.len && psf_bump_header_allocation (psf, count))\n\t\t\t\t\t\treturn 0 ;\n\n\t\t\t\t\tbyte_count += header_gets (psf, charptr, count) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'z' :\n\t\t\t\t\tpsf_log_printf (psf, \"Format conversion 'z' not implemented yet.\\n\") ;\n\t\t\t\t\t/*\n\t\t\t\t\tsize    = va_arg (argptr, size_t) ;\n\t\t\t\t\twhile (size)\n\t\t\t\t\t{\tpsf->header.ptr [psf->header.indx] = 0 ;\n\t\t\t\t\t\tpsf->header.indx ++ ;\n\t\t\t\t\t\tsize -- ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t*/\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'p' :\t/* Seek to position from start. */\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\theader_seek (psf, count, SEEK_SET) ;\n\t\t\t\t\tbyte_count = count ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'j' :\t/* Seek to position from current position. */\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\theader_seek (psf, count, SEEK_CUR) ;\n\t\t\t\t\tbyte_count += count ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;\n\t\t\t\tpsf->error = SFE_INTERNAL ;\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tva_end (argptr) ;\n\n\treturn byte_count ;\n} /* psf_binheader_readf */",
        "file_path": "/src/libsndfile/src/common.c",
        "crashing_line": "\t\t\t\t\tmemset (charptr, 0, count) ;",
        "crashing_line_number": 1091
      },
      {
        "function_name": "wavlike_read_cart_chunk",
        "function_body": "int\nwavlike_read_cart_chunk (SF_PRIVATE *psf, uint32_t chunksize)\n{\tSF_CART_INFO_16K *c ;\n\tuint32_t bytes = 0 ;\n\tint k ;\n\n\tif (chunksize < WAV_CART_MIN_CHUNK_SIZE)\n\t{\tpsf_log_printf (psf, \"cart : %u (should be >= %d)\\n\", chunksize, WAV_CART_MIN_CHUNK_SIZE) ;\n\t\tpsf_binheader_readf (psf, \"j\", chunksize) ;\n\t\treturn 0 ;\n\t\t} ;\n\tif (chunksize > WAV_CART_MAX_CHUNK_SIZE)\n\t{\tpsf_log_printf (psf, \"cart : %u (should be < %d)\\n\", chunksize, WAV_CART_MAX_CHUNK_SIZE) ;\n\t\tpsf_binheader_readf (psf, \"j\", chunksize) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\t/*\n\t**\tSF_CART_INFO_16K has an extra field 'tag_text_size' that isn't part\n\t**\tof the chunk, so don't include it in the size check.\n\t*/\n\tif (chunksize >= sizeof (SF_CART_INFO_16K) - 4)\n\t{\tpsf_log_printf (psf, \"cart : %u too big to be handled\\n\", chunksize) ;\n\t\tpsf_binheader_readf (psf, \"j\", chunksize) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"cart : %u\\n\", chunksize) ;\n\n\tif (psf->cart_16k)\n\t{\tpsf_log_printf (psf, \"  Found more than one cart chunk, using last one.\\n\") ;\n\t\tfree (psf->cart_16k) ;\n\t\tpsf->cart_16k = NULL ;\n\t\t} ;\n\n\tif ((psf->cart_16k = cart_var_alloc ()) == NULL)\n\t{\tpsf->error = SFE_MALLOC_FAILED ;\n\t\treturn psf->error ;\n\t\t} ;\n\n\tc = psf->cart_16k ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->version, sizeof (c->version)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->title, sizeof (c->title)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->artist, sizeof (c->artist)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->cut_id, sizeof (c->cut_id)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->client_id, sizeof (c->client_id)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->category, sizeof (c->category)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->classification, sizeof (c->classification)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->out_cue, sizeof (c->out_cue)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->start_date, sizeof (c->start_date)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->start_time, sizeof (c->start_time)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->end_date, sizeof (c->end_date)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->end_time, sizeof (c->end_time)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->producer_app_id, sizeof (c->producer_app_id)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->producer_app_version, sizeof (c->producer_app_version)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->user_def, sizeof (c->user_def)) ;\n\tbytes += psf_binheader_readf (psf, \"e4\", &c->level_reference, sizeof (c->level_reference)) ;\n\n\tfor (k = 0 ; k < ARRAY_LEN (c->post_timers) ; k++)\n\t\tbytes += psf_binheader_readf (psf, \"b4\", &c->post_timers [k].usage, make_size_t (4), &c->post_timers [k].value) ;\n\n\tbytes += psf_binheader_readf (psf, \"b\", c->reserved, sizeof (c->reserved)) ;\n\tbytes += psf_binheader_readf (psf, \"b\", c->url, sizeof (c->url)) ;\n\n\tif (chunksize > WAV_CART_MIN_CHUNK_SIZE)\n\t{\t/* File has tag text. */\n\t\tc->tag_text_size = chunksize - WAV_CART_MIN_CHUNK_SIZE ;\n\t\tbytes += psf_binheader_readf (psf, \"b\", c->tag_text, make_size_t (c->tag_text_size)) ;\n\t\t} ;\n\n\treturn 0 ;\n} /* wavlike_read_cart_chunk */",
        "file_path": "/src/libsndfile/src/wavlike.c",
        "crashing_line": "",
        "crashing_line_number": 879
      },
      {
        "function_name": "wav_read_header",
        "function_body": "static int\nwav_read_header\t(SF_PRIVATE *psf, int *blockalign, int *framesperblock)\n{\tWAVLIKE_PRIVATE\t*wpriv ;\n\tWAV_FMT\t\t*wav_fmt ;\n\tFACT_CHUNK\tfact_chunk ;\n\tuint32_t\tmarker, chunk_size = 0, RIFFsize = 0, done = 0 ;\n\tint\t\t\tparsestage = 0, error, format = 0 ;\n\n\tif (psf->is_pipe == 0 && psf->filelength > SF_PLATFORM_S64 (0xffffffff))\n\t\tpsf_log_printf (psf, \"Warning : filelength > 0xffffffff. This is bad!!!!\\n\") ;\n\n\tif ((wpriv = psf->container_data) == NULL)\n\t\treturn SFE_INTERNAL ;\n\twav_fmt = &wpriv->wav_fmt ;\n\n\t/* Set position to start of file to begin reading header. */\n\tpsf_binheader_readf (psf, \"pmj\", 0, &marker, -4) ;\n\tpsf->header.indx = 0 ;\n\n\t/* RIFX signifies big-endian format for all header and data  to prevent\n\t** lots of code copying here, we'll set the psf->rwf_endian flag once here,\n\t** and never specify endian-ness for all other header ops/\n\t*/\n\tpsf->rwf_endian = (marker == RIFF_MARKER) ? SF_ENDIAN_LITTLE : SF_ENDIAN_BIG ;\n\n\twhile (! done)\n\t{\tsize_t jump = chunk_size & 1 ;\n\n\t\tmarker = chunk_size = 0 ;\n\t\tpsf_binheader_readf (psf, \"jm4\", jump, &marker, &chunk_size) ;\n\t\tif (marker == 0)\n\t\t{\tsf_count_t pos = psf_ftell (psf) ;\n\t\t\tpsf_log_printf (psf, \"Have 0 marker at position %D (0x%x).\\n\", pos, pos) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tpsf_store_read_chunk_u32 (&psf->rchunks, marker, psf_ftell (psf), chunk_size) ;\n\n\t\tswitch (marker)\n\t\t{\tcase RIFF_MARKER :\n\t\t\tcase RIFX_MARKER :\n\t\t\t\t\tif (parsestage)\n\t\t\t\t\t\treturn SFE_WAV_NO_RIFF ;\n\n\t\t\t\t\tparsestage |= HAVE_RIFF ;\n\n\t\t\t\t\tRIFFsize = chunk_size ;\n\n\t\t\t\t\tif (psf->fileoffset > 0 && psf->filelength > RIFFsize + 8)\n\t\t\t\t\t{\t/* Set file length. */\n\t\t\t\t\t\tpsf->filelength = RIFFsize + 8 ;\n\t\t\t\t\t\tif (marker == RIFF_MARKER)\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"RIFF : %u\\n\", RIFFsize) ;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"RIFX : %u\\n\", RIFFsize) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->filelength < RIFFsize + 2 * SIGNED_SIZEOF (marker))\n\t\t\t\t\t{\tif (marker == RIFF_MARKER)\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"RIFF : %u (should be %D)\\n\", RIFFsize, psf->filelength - 2 * SIGNED_SIZEOF (marker)) ;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"RIFX : %u (should be %D)\\n\", RIFFsize, psf->filelength - 2 * SIGNED_SIZEOF (marker)) ;\n\n\t\t\t\t\t\tRIFFsize = psf->filelength - 2 * SIGNED_SIZEOF (RIFFsize) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\tif (marker == RIFF_MARKER)\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"RIFF : %u\\n\", RIFFsize) ;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"RIFX : %u\\n\", RIFFsize) ;\n\t\t\t\t\t} ;\n\n\t\t\t\t\tpsf_binheader_readf (psf, \"m\", &marker) ;\n\t\t\t\t\tif (marker != WAVE_MARKER)\n\t\t\t\t\t\treturn SFE_WAV_NO_WAVE ;\n\t\t\t\t\tparsestage |= HAVE_WAVE ;\n\t\t\t\t\tpsf_log_printf (psf, \"WAVE\\n\") ;\n\t\t\t\t\tchunk_size = 0 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase fmt_MARKER :\n\t\t\t\t\tif ((parsestage & (HAVE_RIFF | HAVE_WAVE)) != (HAVE_RIFF | HAVE_WAVE))\n\t\t\t\t\t\treturn SFE_WAV_NO_FMT ;\n\n\t\t\t\t\t/* If this file has a SECOND fmt chunk, I don't want to know about it. */\n\t\t\t\t\tif (parsestage & HAVE_fmt)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tparsestage |= HAVE_fmt ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"fmt  : %d\\n\", chunk_size) ;\n\n\t\t\t\t\tif ((error = wavlike_read_fmt_chunk (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\n\t\t\t\t\tformat = wav_fmt->format ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase data_MARKER :\n\t\t\t\t\tif ((parsestage & (HAVE_RIFF | HAVE_WAVE | HAVE_fmt)) != (HAVE_RIFF | HAVE_WAVE | HAVE_fmt))\n\t\t\t\t\t\treturn SFE_WAV_NO_DATA ;\n\n\t\t\t\t\tif (psf->file.mode == SFM_RDWR && (parsestage & HAVE_other) != 0)\n\t\t\t\t\t\treturn SFE_RDWR_BAD_HEADER ;\n\n\t\t\t\t\tparsestage |= HAVE_data ;\n\n\t\t\t\t\tpsf->datalength = chunk_size ;\n\t\t\t\t\tif (psf->datalength & 1)\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** 'data' chunk should be an even number of bytes in length.\\n\") ;\n\n\t\t\t\t\tpsf->dataoffset = psf_ftell (psf) ;\n\n\t\t\t\t\tif (psf->dataoffset > 0)\n\t\t\t\t\t{\tif (chunk_size == 0 && RIFFsize == 8 && psf->filelength > 44)\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"*** Looks like a WAV file which wasn't closed properly. Fixing it.\\n\") ;\n\t\t\t\t\t\t\tpsf->datalength = psf->filelength - psf->dataoffset ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\tif (psf->datalength > psf->filelength - psf->dataoffset)\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"data : %D (should be %D)\\n\", psf->datalength, psf->filelength - psf->dataoffset) ;\n\t\t\t\t\t\t\tpsf->datalength = psf->filelength - psf->dataoffset ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"data : %D\\n\", psf->datalength) ;\n\n\t\t\t\t\t\t/* Only set dataend if there really is data at the end. */\n\t\t\t\t\t\tif (psf->datalength + psf->dataoffset < psf->filelength)\n\t\t\t\t\t\t\tpsf->dataend = psf->datalength + psf->dataoffset ;\n\n\t\t\t\t\t\tpsf->datalength += chunk_size & 1 ;\n\t\t\t\t\t\tchunk_size = 0 ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (! psf->sf.seekable || psf->dataoffset < 0)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t/* Seek past data and continue reading header. */\n\t\t\t\t\tpsf_fseek (psf, psf->datalength, SEEK_CUR) ;\n\n\t\t\t\t\tif (psf_ftell (psf) != psf->datalength + psf->dataoffset)\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** psf_fseek past end error ***\\n\") ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase fact_MARKER :\n\t\t\t\t\tif ((parsestage & (HAVE_RIFF | HAVE_WAVE)) != (HAVE_RIFF | HAVE_WAVE))\n\t\t\t\t\t\treturn SFE_WAV_BAD_FACT ;\n\n\t\t\t\t\tparsestage |= HAVE_fact ;\n\n\t\t\t\t\tif ((parsestage & HAVE_fmt) != HAVE_fmt)\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** Should have 'fmt ' chunk before 'fact'\\n\") ;\n\n\t\t\t\t\tpsf_binheader_readf (psf, \"4\", & (fact_chunk.frames)) ;\n\n\t\t\t\t\tif (chunk_size > SIGNED_SIZEOF (fact_chunk))\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", (int) (chunk_size - SIGNED_SIZEOF (fact_chunk))) ;\n\n\t\t\t\t\tif (chunk_size)\n\t\t\t\t\t\tpsf_log_printf (psf, \"%M : %u\\n\", marker, chunk_size) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tpsf_log_printf (psf, \"%M : %u (should not be zero)\\n\", marker, chunk_size) ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"  frames  : %d\\n\", fact_chunk.frames) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase PEAK_MARKER :\n\t\t\t\t\tif ((parsestage & (HAVE_RIFF | HAVE_WAVE | HAVE_fmt)) != (HAVE_RIFF | HAVE_WAVE | HAVE_fmt))\n\t\t\t\t\t\treturn SFE_WAV_PEAK_B4_FMT ;\n\n\t\t\t\t\tparsestage |= HAVE_PEAK ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"%M : %u\\n\", marker, chunk_size) ;\n\t\t\t\t\tif ((error = wavlike_read_peak_chunk (psf, chunk_size)) != 0)\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tpsf->peak_info->peak_loc = ((parsestage & HAVE_data) == 0) ? SF_PEAK_START : SF_PEAK_END ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase cue_MARKER :\n\t\t\t\t\tparsestage |= HAVE_other ;\n\n\t\t\t\t\t{\tuint32_t thisread, bytesread, cue_count, position, offset ;\n\t\t\t\t\t\tint id, chunk_id, chunk_start, block_start, cue_index ;\n\n\t\t\t\t\t\tbytesread = psf_binheader_readf (psf, \"4\", &cue_count) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"%M : %u\\n\", marker, chunk_size) ;\n\n\t\t\t\t\t\tif (cue_count > 2500) /* 2500 is close to the largest number of cues possible because of block sizes */\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"  Count : %u (skipping)\\n\", cue_count) ;\n\t\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size - bytesread) ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Count : %d\\n\", cue_count) ;\n\n\t\t\t\t\t\tif (psf->cues)\n\t\t\t\t\t\t{\tfree (psf->cues) ;\n\t\t\t\t\t\t\tpsf->cues = NULL ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\tif ((psf->cues = psf_cues_alloc (cue_count)) == NULL)\n\t\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t\tcue_index = 0 ;\n\n\t\t\t\t\t\twhile (cue_count)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((thisread = psf_binheader_readf (psf, \"e44m444\", &id, &position, &chunk_id, &chunk_start, &block_start, &offset)) == 0)\n\t\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t\tbytesread += thisread ;\n\n\t\t\t\t\t\t\tif (cue_index < 10) /* avoid swamping log buffer with cues */\n\t\t\t\t\t\t\t\tpsf_log_printf (psf,\t\"   Cue ID : %2d\"\n\t\t\t\t\t\t\t\t\t\t\t\"  Pos : %5u  Chunk : %M\"\n\t\t\t\t\t\t\t\t\t\t\t\"  Chk Start : %d  Blk Start : %d\"\n\t\t\t\t\t\t\t\t\t\t\t\"  Offset : %5d\\n\",\n\t\t\t\t\t\t\t\t\t\tid, position, chunk_id, chunk_start, block_start, offset) ;\n\t\t\t\t\t\t\telse if (cue_index == 10)\n\t\t\t\t\t\t\t\tpsf_log_printf (psf,\t\"   (Skipping)\\n\") ;\n\n\t\t\t\t\t\t\tpsf->cues->cue_points [cue_index].indx = id ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [cue_index].position = position ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [cue_index].fcc_chunk = chunk_id ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [cue_index].chunk_start = chunk_start ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [cue_index].block_start = block_start ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [cue_index].sample_offset = offset ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [cue_index].name [0] = '\\0' ;\n\t\t\t\t\t\t\tcue_count -- ;\n\t\t\t\t\t\t\tcue_index ++ ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\tif (bytesread != chunk_size)\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"**** Chunk size weirdness (%d != %d)\\n\", chunk_size, bytesread) ;\n\t\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size - bytesread) ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase smpl_MARKER :\n\t\t\t\t\tparsestage |= HAVE_other ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"smpl : %u\\n\", chunk_size) ;\n\n\t\t\t\t\tif ((error = wav_read_smpl_chunk (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase acid_MARKER :\n\t\t\t\t\tparsestage |= HAVE_other ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"acid : %u\\n\", chunk_size) ;\n\n\t\t\t\t\tif ((error = wav_read_acid_chunk (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase INFO_MARKER :\n\t\t\tcase LIST_MARKER :\n\t\t\t\t\tparsestage |= HAVE_other ;\n\n\t\t\t\t\tif ((error = wavlike_subchunk_parse (psf, marker, chunk_size)) != 0)\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase bext_MARKER :\n\t\t\t\t\t/*\n\t\t\t\t\tThe 'bext' chunk can actually be updated, so don't need to set this.\n\t\t\t\t\tparsestage |= HAVE_other ;\n\t\t\t\t\t*/\n\t\t\t\t\tif ((error = wavlike_read_bext_chunk (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase PAD_MARKER :\n\t\t\t\t\t/*\n\t\t\t\t\tWe can eat into a 'PAD ' chunk if we need to.\n\t\t\t\t\tparsestage |= HAVE_other ;\n\t\t\t\t\t*/\n\t\t\t\t\tpsf_log_printf (psf, \"%M : %u\\n\", marker, chunk_size) ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase cart_MARKER:\n\t\t\t\t\tif ((error = wavlike_read_cart_chunk (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase iXML_MARKER : /* See http://en.wikipedia.org/wiki/IXML */\n\t\t\tcase strc_MARKER : /* Multiple of 32 bytes. */\n\t\t\tcase afsp_MARKER :\n\t\t\tcase clm_MARKER :\n\t\t\tcase elmo_MARKER :\n\t\t\tcase levl_MARKER :\n\t\t\tcase plst_MARKER :\n\t\t\tcase minf_MARKER :\n\t\t\tcase elm1_MARKER :\n\t\t\tcase regn_MARKER :\n\t\t\tcase ovwf_MARKER :\n\t\t\tcase inst_MARKER :\n\t\t\tcase AFAn_MARKER :\n\t\t\tcase umid_MARKER :\n\t\t\tcase SyLp_MARKER :\n\t\t\tcase Cr8r_MARKER :\n\t\t\tcase JUNK_MARKER :\n\t\t\tcase PMX_MARKER :\n\t\t\tcase DISP_MARKER :\n\t\t\tcase MEXT_MARKER :\n\t\t\tcase FLLR_MARKER :\n\t\t\t\t\tpsf_log_printf (psf, \"%M : %u\\n\", marker, chunk_size) ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\t\tif (chunk_size >= 0xffff0000)\n\t\t\t\t\t{\tdone = SF_TRUE ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\\n\", marker, psf_ftell (psf) - 8, chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (psf_isprint ((marker >> 24) & 0xFF) && psf_isprint ((marker >> 16) & 0xFF)\n\t\t\t\t\t\t&& psf_isprint ((marker >> 8) & 0xFF) && psf_isprint (marker & 0xFF))\n\t\t\t\t\t{\tpsf_log_printf (psf, \"*** %M : %u (unknown marker)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tif (psf_ftell (psf) & 0x03)\n\t\t\t\t\t{\tpsf_log_printf (psf, \"  Unknown chunk marker at position %D. Resynching.\\n\", psf_ftell (psf) - 8) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", -3) ;\n\t\t\t\t\t\t/* File is too messed up so we prevent editing in RDWR mode here. */\n\t\t\t\t\t\tparsestage |= HAVE_other ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tpsf_log_printf (psf, \"*** Unknown chunk marker (%X) at position %D. Exiting parser.\\n\", marker, psf_ftell (psf) - 8) ;\n\t\t\t\t\tdone = SF_TRUE ;\n\t\t\t\t\tbreak ;\n\t\t\t} ;\t/* switch (marker) */\n\n\t\tif (chunk_size >= psf->filelength)\n\t\t{\tpsf_log_printf (psf, \"*** Chunk size %u > file length %D. Exiting parser.\\n\", chunk_size, psf->filelength) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (! psf->sf.seekable && (parsestage & HAVE_data))\n\t\t\tbreak ;\n\n\t\tif (psf_ftell (psf) >= psf->filelength - SIGNED_SIZEOF (chunk_size))\n\t\t{\tpsf_log_printf (psf, \"End\\n\") ;\n\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ; /* while (1) */\n\n\tif (psf->dataoffset <= 0)\n\t\treturn SFE_WAV_NO_DATA ;\n\n\tif (psf->sf.channels < 1)\n\t\treturn SFE_CHANNEL_COUNT_ZERO ;\n\n\tif (psf->sf.channels > SF_MAX_CHANNELS)\n\t\treturn SFE_CHANNEL_COUNT ;\n\n\tif (format != WAVE_FORMAT_PCM && (parsestage & HAVE_fact) == 0)\n\t\tpsf_log_printf (psf, \"**** All non-PCM format files should have a 'fact' chunk.\\n\") ;\n\n\t/* WAVs can be little or big endian */\n\tpsf->endian = psf->rwf_endian ;\n\n\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\n\tif (psf->is_pipe == 0)\n\t{\t/*\n\t\t** Check for 'wvpk' at the start of the DATA section. Not able to\n\t\t** handle this.\n\t\t*/\n\t\tpsf_binheader_readf (psf, \"4\", &marker) ;\n\t\tif (marker == wvpk_MARKER || marker == OggS_MARKER)\n\t\t\treturn SFE_WAV_WVPK_DATA ;\n\t\t} ;\n\n\t/* Seek to start of DATA section. */\n\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\n\tif (psf->blockwidth)\n\t{\tif (psf->filelength - psf->dataoffset < psf->datalength)\n\t\t\tpsf->sf.frames = (psf->filelength - psf->dataoffset) / psf->blockwidth ;\n\t\telse\n\t\t\tpsf->sf.frames = psf->datalength / psf->blockwidth ;\n\t\t} ;\n\n\tswitch (format)\n\t{\tcase WAVE_FORMAT_EXTENSIBLE :\n\t\t\tif (psf->sf.format == (SF_FORMAT_WAVEX | SF_FORMAT_MS_ADPCM))\n\t\t\t{\t*blockalign = wav_fmt->msadpcm.blockalign ;\n\t\t\t\t*framesperblock = wav_fmt->msadpcm.samplesperblock ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase WAVE_FORMAT_NMS_VBXADPCM :\n\t\t\t*blockalign = wav_fmt->min.blockalign ;\n\t\t\t*framesperblock = 160 ;\n\t\t\tswitch (wav_fmt->min.bitwidth)\n\t\t\t{\tcase 2 :\n\t\t\t\t\tpsf->sf.format = SF_FORMAT_WAV | SF_FORMAT_NMS_ADPCM_16 ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 3 :\n\t\t\t\t\tpsf->sf.format = SF_FORMAT_WAV | SF_FORMAT_NMS_ADPCM_24 ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 4 :\n\t\t\t\t\tpsf->sf.format = SF_FORMAT_WAV | SF_FORMAT_NMS_ADPCM_32 ;\n\t\t\t\t\tbreak ;\n\n\t\t\t\tdefault :\n\t\t\t\t\treturn SFE_UNIMPLEMENTED ;\n\t\t\t\t}\n\t\t\t\tbreak ;\n\n\t\tcase WAVE_FORMAT_PCM :\n\t\t\t\t\tpsf->sf.format = SF_FORMAT_WAV | u_bitwidth_to_subformat (psf->bytewidth * 8) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase WAVE_FORMAT_MULAW :\n\t\tcase IBM_FORMAT_MULAW :\n\t\t\t\t\tpsf->sf.format = (SF_FORMAT_WAV | SF_FORMAT_ULAW) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase WAVE_FORMAT_ALAW :\n\t\tcase IBM_FORMAT_ALAW :\n\t\t\t\t\tpsf->sf.format = (SF_FORMAT_WAV | SF_FORMAT_ALAW) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase WAVE_FORMAT_MS_ADPCM :\n\t\t\t\t\tpsf->sf.format = (SF_FORMAT_WAV | SF_FORMAT_MS_ADPCM) ;\n\t\t\t\t\t*blockalign = wav_fmt->msadpcm.blockalign ;\n\t\t\t\t\t*framesperblock = wav_fmt->msadpcm.samplesperblock ;\n\t\t\t\t\tbreak ;\n\n\t\tcase WAVE_FORMAT_IMA_ADPCM :\n\t\t\t\t\tpsf->sf.format = (SF_FORMAT_WAV | SF_FORMAT_IMA_ADPCM) ;\n\t\t\t\t\t*blockalign = wav_fmt->ima.blockalign ;\n\t\t\t\t\t*framesperblock = wav_fmt->ima.samplesperblock ;\n\t\t\t\t\tbreak ;\n\n\t\tcase WAVE_FORMAT_GSM610 :\n\t\t\t\t\tpsf->sf.format = (SF_FORMAT_WAV | SF_FORMAT_GSM610) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase WAVE_FORMAT_IEEE_FLOAT :\n\t\t\t\t\tpsf->sf.format = SF_FORMAT_WAV ;\n\t\t\t\t\tpsf->sf.format |= (psf->bytewidth == 8) ? SF_FORMAT_DOUBLE : SF_FORMAT_FLOAT ;\n\t\t\t\t\tbreak ;\n\n\t\tcase WAVE_FORMAT_G721_ADPCM :\n\t\t\t\t\tpsf->sf.format = SF_FORMAT_WAV | SF_FORMAT_G721_32 ;\n\t\t\t\t\tbreak ;\n\n\t\tdefault : return SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\tif (wpriv->fmt_is_broken)\n\t\twavlike_analyze (psf) ;\n\n\t/* Only set the format endian-ness if its non-standard big-endian. */\n\tif (psf->endian == SF_ENDIAN_BIG)\n\t\tpsf->sf.format |= SF_ENDIAN_BIG ;\n\n\treturn 0 ;\n} /* wav_read_header */",
        "file_path": "/src/libsndfile/src/wav.c",
        "crashing_line": "\t\t\t\t\tif ((error = wavlike_read_cart_chunk (psf, chunk_size)))",
        "crashing_line_number": 572
      },
      {
        "function_name": "wav_open",
        "function_body": "int\nwav_open\t(SF_PRIVATE *psf)\n{\tWAVLIKE_PRIVATE * wpriv ;\n\tint\tformat, subformat, error, blockalign = 0, framesperblock = 0 ;\n\n\tif ((wpriv = calloc (1, sizeof (WAVLIKE_PRIVATE))) == NULL)\n\t\treturn SFE_MALLOC_FAILED ;\n\tpsf->container_data = wpriv ;\n\n\twpriv->wavex_ambisonic = SF_AMBISONIC_NONE ;\n\tpsf->strings.flags = SF_STR_ALLOW_START | SF_STR_ALLOW_END ;\n\n\tif (psf->file.mode == SFM_READ || (psf->file.mode == SFM_RDWR && psf->filelength > 0))\n\t{\tif ((error = wav_read_header (psf, &blockalign, &framesperblock)))\n\t\t\treturn error ;\n\n\t\tpsf->next_chunk_iterator = wav_next_chunk_iterator ;\n\t\tpsf->get_chunk_size = wav_get_chunk_size ;\n\t\tpsf->get_chunk_data = wav_get_chunk_data ;\n\t\t} ;\n\n\tsubformat = SF_CODEC (psf->sf.format) ;\n\n\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t{\tif (psf->is_pipe)\n\t\t\treturn SFE_NO_PIPE_WRITE ;\n\n\t\twpriv->wavex_ambisonic = SF_AMBISONIC_NONE ;\n\n\t\tformat = SF_CONTAINER (psf->sf.format) ;\n\t\tif (format != SF_FORMAT_WAV && format != SF_FORMAT_WAVEX)\n\t\t\treturn\tSFE_BAD_OPEN_FORMAT ;\n\n\t\tpsf->blockwidth = psf->bytewidth * psf->sf.channels ;\n\n\t\t/* RIFF WAVs are little-endian, RIFX WAVs are big-endian, default to little */\n\t\tpsf->endian = SF_ENDIAN (psf->sf.format) ;\n\t\tif (CPU_IS_BIG_ENDIAN && psf->endian == SF_ENDIAN_CPU)\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\telse if (psf->endian != SF_ENDIAN_BIG)\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\n\t\tif (psf->file.mode != SFM_RDWR || psf->filelength < 44)\n\t\t{\tpsf->filelength = 0 ;\n\t\t\tpsf->datalength = 0 ;\n\t\t\tpsf->dataoffset = 0 ;\n\t\t\tpsf->sf.frames = 0 ;\n\t\t\t} ;\n\n\t\tif (subformat == SF_FORMAT_IMA_ADPCM || subformat == SF_FORMAT_MS_ADPCM)\n\t\t{\tblockalign = wavlike_srate2blocksize (psf->sf.samplerate * psf->sf.channels) ;\n\t\t\tframesperblock = -1 ; /* Corrected later. */\n\t\t\t} ;\n\n\t\t/* By default, add the peak chunk to floating point files. Default behaviour\n\t\t** can be switched off using sf_command (SFC_SET_PEAK_CHUNK, SF_FALSE).\n\t\t*/\n\t\tif (psf->file.mode == SFM_WRITE && (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE))\n\t\t{\tif ((psf->peak_info = peak_info_calloc (psf->sf.channels)) == NULL)\n\t\t\t\treturn SFE_MALLOC_FAILED ;\n\t\t\tpsf->peak_info->peak_loc = SF_PEAK_START ;\n\t\t\t} ;\n\n\t\tpsf->write_header\t= wav_write_header ;\n\t\tpsf->set_chunk\t\t= wav_set_chunk ;\n\t\t} ;\n\n\tpsf->container_close = wav_close ;\n\tpsf->command = wav_command ;\n\n\tswitch (subformat)\n\t{\tcase SF_FORMAT_PCM_U8 :\n\t\tcase SF_FORMAT_PCM_16 :\n\t\tcase SF_FORMAT_PCM_24 :\n\t\tcase SF_FORMAT_PCM_32 :\n\t\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ULAW :\n\t\t\t\t\terror = ulaw_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ALAW :\n\t\t\t\t\terror = alaw_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\t/* Lite remove start */\n\t\tcase SF_FORMAT_FLOAT :\n\t\t\t\t\terror = float32_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DOUBLE :\n\t\t\t\t\terror = double64_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_IMA_ADPCM :\n\t\t\t\t\terror = wavlike_ima_init (psf, blockalign, framesperblock) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_MS_ADPCM :\n\t\t\t\t\terror = wavlike_msadpcm_init (psf, blockalign, framesperblock) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_G721_32 :\n\t\t\t\t\terror = g72x_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_NMS_ADPCM_16 :\n\t\tcase SF_FORMAT_NMS_ADPCM_24 :\n\t\tcase SF_FORMAT_NMS_ADPCM_32 :\n\t\t\t\t\terror = nms_adpcm_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\t/* Lite remove end */\n\n\t\tcase SF_FORMAT_GSM610 :\n\t\t\t\t\terror = gsm610_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tdefault : \treturn SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE || (psf->file.mode == SFM_RDWR && psf->filelength == 0))\n\t\treturn psf->write_header (psf, SF_FALSE) ;\n\n\treturn error ;\n} /* wav_open */",
        "file_path": "/src/libsndfile/src/wav.c",
        "crashing_line": "\t{\tif ((error = wav_read_header (psf, &blockalign, &framesperblock)))",
        "crashing_line_number": 171
      },
      {
        "function_name": "psf_open_file",
        "function_body": "",
        "file_path": "/src/libsndfile/src/sndfile.c",
        "crashing_line": "",
        "crashing_line_number": 3128
      },
      {
        "function_name": "sf_open_virtual",
        "function_body": "",
        "file_path": "/src/libsndfile/src/sndfile.c",
        "crashing_line": "",
        "crashing_line_number": 515
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int mosquitto__hex2bin(const char *hex, unsigned char *bin, int bin_max_len)\n{\n\tBIGNUM *bn = NULL;\n\tint len;\n\tint leading_zero = 0;\n\tint start = 0;\n\tsize_t i = 0;\n\n\t/* Count the number of leading zero */\n\tfor(i=0; i<strlen(hex); i=i+2) {\n\t\tif(strncmp(hex + i, \"00\", 2) == 0) {\n\t\t\tleading_zero++;\n\t\t\t/* output leading zero to bin */\n\t\t\tbin[start++] = 0;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(BN_hex2bn(&bn, hex) == 0){\n\t\tif(bn) BN_free(bn);\n\t\treturn 0;\n\t}\n\tif(BN_num_bytes(bn) + leading_zero > bin_max_len){\n\t\tBN_free(bn);\n\t\treturn 0;\n\t}\n\n\tlen = BN_bn2bin(bn, bin + leading_zero);\n\tBN_free(bn);\n\treturn len + leading_zero;\n}\n",
    "target": 1,
    "idx": 1055948,
    "stack_trace": [
      {
        "function_name": "mosquitto__hex2bin",
        "function_body": "int mosquitto__hex2bin(const char *hex, unsigned char *bin, int bin_max_len)\n{\n\tBIGNUM *bn = NULL;\n\tint len;\n\tint leading_zero = 0;\n\tsize_t i = 0;\n\n\t/* Count the number of leading zero */\n\tfor(i=0; i<strlen(hex); i=i+2) {\n\t\tif(strncmp(hex + i, \"00\", 2) == 0) {\n\t\t\tif(leading_zero >= bin_max_len){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* output leading zero to bin */\n\t\t\tbin[leading_zero] = 0;\n\t\t\tleading_zero++;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(BN_hex2bn(&bn, hex) == 0){\n\t\tif(bn) BN_free(bn);\n\t\treturn 0;\n\t}\n\tif(BN_num_bytes(bn) + leading_zero > bin_max_len){\n\t\tBN_free(bn);\n\t\treturn 0;\n\t}\n\n\tlen = BN_bn2bin(bn, bin + leading_zero);\n\tBN_free(bn);\n\treturn len + leading_zero;\n}",
        "file_path": "/src/mosquitto/src/../lib/util_mosq.c",
        "crashing_line": "\t\t\t/* output leading zero to bin */",
        "crashing_line_number": 185
      },
      {
        "function_name": "mosquitto__hex2bin_sha1",
        "function_body": "int mosquitto__hex2bin_sha1(const char *hex, unsigned char **bin)\n{\n\tunsigned char *sha, tmp[SHA_DIGEST_LENGTH];\n\n\tif(mosquitto__hex2bin(hex, tmp, SHA_DIGEST_LENGTH) != SHA_DIGEST_LENGTH){\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\tsha = mosquitto__malloc(SHA_DIGEST_LENGTH);\n\tif(!sha){\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\tmemcpy(sha, tmp, SHA_DIGEST_LENGTH);\n\t*bin = sha;\n\treturn MOSQ_ERR_SUCCESS;\n}",
        "file_path": "/src/mosquitto/src/../lib/util_mosq.c",
        "crashing_line": "\tif(mosquitto__hex2bin(hex, tmp, SHA_DIGEST_LENGTH) != SHA_DIGEST_LENGTH){",
        "crashing_line_number": 159
      },
      {
        "function_name": "config__read_file_core",
        "function_body": "int config__read_file(struct mosquitto__config *config, bool reload, const char *file, struct config_recurse *cr, int level, int *lineno)\n{\n\tint rc;\n\tFILE *fptr = NULL;\n\tchar *buf;\n\tint buflen;\n#ifndef WIN32\n\tDIR *dir;\n#endif\n\n#ifndef WIN32\n\tdir = opendir(file);\n\tif(dir){\n\t\tclosedir(dir);\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Config file '%s' is a directory.\", file);\n\t\treturn 1;\n\t}\n#endif\n\n\tfptr = mosquitto__fopen(file, \"rt\", false);\n\tif(!fptr){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open config file '%s'.\", file);\n\t\treturn 1;\n\t}\n\n\tbuflen = 1000;\n\tbuf = mosquitto__malloc((size_t)buflen);\n\tif(!buf){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\tfclose(fptr);\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\trc = config__read_file_core(config, reload, cr, level, lineno, fptr, &buf, &buflen);\n\tmosquitto__FREE(buf);\n\tfclose(fptr);\n\n\treturn rc;\n}",
        "file_path": "/src/mosquitto/src/conf.c",
        "crashing_line": "",
        "crashing_line_number": 2289
      },
      {
        "function_name": "config__read_file",
        "function_body": "int config__read_file(struct mosquitto__config *config, bool reload, const char *file, struct config_recurse *cr, int level, int *lineno)\n{\n\tint rc;\n\tFILE *fptr = NULL;\n\tchar *buf;\n\tint buflen;\n#ifndef WIN32\n\tDIR *dir;\n#endif\n\n#ifndef WIN32\n\tdir = opendir(file);\n\tif(dir){\n\t\tclosedir(dir);\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Config file '%s' is a directory.\", file);\n\t\treturn 1;\n\t}\n#endif\n\n\tfptr = mosquitto__fopen(file, \"rt\", false);\n\tif(!fptr){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open config file '%s'.\", file);\n\t\treturn 1;\n\t}\n\n\tbuflen = 1000;\n\tbuf = mosquitto__malloc((size_t)buflen);\n\tif(!buf){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\tfclose(fptr);\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\trc = config__read_file_core(config, reload, cr, level, lineno, fptr, &buf, &buflen);\n\tmosquitto__FREE(buf);\n\tfclose(fptr);\n\n\treturn rc;\n}",
        "file_path": "/src/mosquitto/src/conf.c",
        "crashing_line": "\trc = config__read_file_core(config, reload, cr, level, lineno, fptr, &buf, &buflen);",
        "crashing_line_number": 2517
      },
      {
        "function_name": "config__parse_args",
        "function_body": "int config__parse_args(struct mosquitto__config *config, int argc, char *argv[])\n{\n\tint i;\n\tint port_tmp;\n\n\tfor(i=1; i<argc; i++){\n\t\tif(!strcmp(argv[i], \"-c\") || !strcmp(argv[i], \"--config-file\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tdb.config_file = argv[i+1];\n\n\t\t\t\tif(config__read(config, false)){\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -c argument given, but no config file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--daemon\")){\n\t\t\tconfig->daemon = true;\n\t\t}else if(!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")){\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else if(!strcmp(argv[i], \"-p\") || !strcmp(argv[i], \"--port\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tport_tmp = atoi(argv[i+1]);\n\t\t\t\tif(port_tmp<1 || port_tmp>UINT16_MAX){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port specified (%d).\", port_tmp);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}else{\n\t\t\t\t\tif(config->cmd_port_count == CMD_PORT_LIMIT){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Only %d ports can be specified on the command line.\", CMD_PORT_LIMIT);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tconfig->cmd_port[config->cmd_port_count] = (uint16_t)port_tmp;\n\t\t\t\t\tconfig->cmd_port_count++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -p argument given, but no port specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"--tls-keylog\")){\n#ifdef WITH_TLS\n\t\t\tif(i<argc-1){\n\t\t\t\tdb.tls_keylog = mosquitto_strdup(argv[i+1]);\n\t\t\t\tif(db.tls_keylog == NULL){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: --tls-keylog argument given, but no file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n#else\n\t\t\tfprintf(stderr, \"Error: TLS support not available so --tls-keylog is not available.\\n\");\n\t\t\treturn MOSQ_ERR_INVAL;\n#endif\n\t\t}else if(!strcmp(argv[i], \"-q\") || !strcmp(argv[i], \"--quiet\")){\n\t\t\tdb.quiet = true;\n\t\t}else if(!strcmp(argv[i], \"-v\") || !strcmp(argv[i], \"--verbose\")){\n\t\t\tdb.verbose = true;\n\t\t}else if(!strcmp(argv[i], \"--test-config\")){\n\t\t\tconfig->test_configuration = true;\n\t\t}else{\n\t\t\tfprintf(stderr, \"Error: Unknown option '%s'.\\n\",argv[i]);\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}\n\n\t/* Default to drop to mosquitto user if we are privileged and no user specified. */\n\tif(!config->user){\n\t\tconfig->user = mosquitto__strdup(\"mosquitto\");\n\t\tif(config->user == NULL){\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n\tif(db.quiet){\n\t\tconfig->log_type = 0;\n\t}else if(db.verbose){\n\t\tconfig->log_type = UINT_MAX;\n\t}\n\n\tif(getenv(\"MOSQUITTO_PERSISTENCE_LOCATION\")){\n\t\tmosquitto__FREE(config->persistence_location);\n\t\tconfig->persistence_location = mosquitto_strdup(getenv(\"MOSQUITTO_PERSISTENCE_LOCATION\"));\n\t\tif(!config->persistence_location){\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n\treturn config__check(config);\n}",
        "file_path": "/src/mosquitto/src/conf.c",
        "crashing_line": "\t\t\t\tif(config__read(config, false)){",
        "crashing_line_number": 528
      },
      {
        "function_name": "mosquitto_fuzz_main",
        "function_body": "int main(int argc, char *argv[])\n#endif\n{\n\tstruct mosquitto__config config;\n\tint rc;\n#ifdef WIN32\n\tSYSTEMTIME st;\n#else\n\tstruct timeval tv;\n#endif\n\tstruct mosquitto *ctxt, *ctxt_tmp;\n\n#if defined(WIN32) || defined(__CYGWIN__)\n\tif(argc == 2){\n\t\tif(!strcmp(argv[1], \"run\")){\n\t\t\tservice_run(argv[0]);\n\t\t\treturn 0;\n\t\t}else if(!strcmp(argv[1], \"install\")){\n\t\t\tservice_install(argv[0]);\n\t\t\treturn 0;\n\t\t}else if(!strcmp(argv[1], \"uninstall\")){\n\t\t\tservice_uninstall(argv[0]);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\n\n#ifdef WIN32\n\tGetSystemTime(&st);\n\tsrand(st.wSecond + st.wMilliseconds);\n#else\n\tgettimeofday(&tv, NULL);\n\tsrand((unsigned int)(tv.tv_sec + tv.tv_usec));\n#endif\n\n#ifdef WIN32\n\tif(_setmaxstdio(8192) != 8192){\n\t\t/* Old limit was 2048 */\n\t\tif(_setmaxstdio(2048) != 2048){\n\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Unable to increase maximum allowed connections. This session may be limited to 512 connections.\");\n\t\t}\n\t}\n\n#endif\n\n\tmemset(&db, 0, sizeof(struct mosquitto_db));\n\tdb.now_s = mosquitto_time();\n\tdb.now_real_s = time(NULL);\n\tmosquitto_broker_node_id_set(0);\n\n\tnet__broker_init();\n\n\tdb.config = &config;\n\tconfig__init(&config);\n\trc = config__parse_args(&config, argc, argv);\n\tif(rc != MOSQ_ERR_SUCCESS){\n\t\tconfig__cleanup(&config);\n\t\treturn rc;\n\t}\n\n\tif(config.test_configuration){\n\t\tif(!db.config_file){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Please provide a configuration file to test.\");\n\t\t\tconfig__cleanup(&config);\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else{\n\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Configuration file is OK.\");\n\t\t\tconfig__cleanup(&config);\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\n\trc = keepalive__init();\n\tif(rc != MOSQ_ERR_SUCCESS) return rc;\n\n\t/* Drop privileges permanently immediately after the config is loaded.\n\t * This requires the user to ensure that all certificates, log locations,\n\t * etc. are accessible my the `mosquitto` or other unprivileged user.\n\t */\n\trc = drop_privileges(&config);\n\tif(rc != MOSQ_ERR_SUCCESS) return rc;\n\t/* Set umask based on environment variable */\n\trc = set_umask();\n\tif(rc != MOSQ_ERR_SUCCESS) return rc;\n\n\n\tif(config.daemon){\n\t\tmosquitto__daemonise();\n\t}\n\n\tif(pid__write()) return 1;\n\n\trc = db__open(&config);\n\tif(rc != MOSQ_ERR_SUCCESS){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Couldn't open database.\");\n\t\treturn rc;\n\t}\n\n\t/* Initialise logging only after initialising the database in case we're\n\t * logging to topics */\n\tif(log__init(&config)){\n\t\trc = 1;\n\t\treturn rc;\n\t}\n\tlog__printf(NULL, MOSQ_LOG_INFO, \"mosquitto version %s starting\", VERSION);\n\tif(db.config_file){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Config loaded from %s.\", db.config_file);\n\t}else{\n\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Using default config.\");\n\t}\n\treport_features();\n\n\trc = plugin__load_all();\n\tif(rc) return rc;\n\trc = mosquitto_security_init(false);\n\tif(rc) return rc;\n\n\tplugin_persist__handle_restore();\n\tdb__msg_store_compact();\n\n\t/* After loading persisted clients and ACLs, try to associate them,\n\t * so persisted subscriptions can start storing messages */\n\tHASH_ITER(hh_id, db.contexts_by_id, ctxt, ctxt_tmp){\n\t\tif(ctxt && !ctxt->clean_start && ctxt->username){\n\t\t\trc = acl__find_acls(ctxt);\n\t\t\tif(rc){\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Failed to associate persisted user %s with ACLs, \"\n\t\t\t\t\t\"likely due to changed ports while using a per_listener_settings configuration.\", ctxt->username);\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_SYS_TREE\n\tsys_tree__init();\n#endif\n\n\trc = mux__init();\n\tif(rc) return rc;\n\n\tif(listeners__start()) return 1;\n\n\tsignal__setup();\n\n#ifdef WITH_BRIDGE\n\tbridge__start_all();\n#endif\n\n#ifdef WITH_CJSON\n\tbroker_control__init();\n#endif\n\n\tlog__printf(NULL, MOSQ_LOG_INFO, \"mosquitto version %s running\", VERSION);\n#ifdef WITH_SYSTEMD\n\tsd_notify(0, \"READY=1\");\n#endif\n\n\tg_run = 1;\n\trc = mosquitto_main_loop(g_listensock, g_listensock_count);\n\n\t/* FIXME - this isn't quite right, all wills with will delay zero should be\n\t * sent now, but those with positive will delay should be persisted and\n\t * restored, pending the client reconnecting in time. */\n\tHASH_ITER(hh_id, db.contexts_by_id, ctxt, ctxt_tmp){\n\t\tcontext__send_will(ctxt);\n\t}\n\twill_delay__send_all();\n\n\t/* Set to true only after persistence events have been processed */\n\tdb.shutdown = true;\n\tlog__printf(NULL, MOSQ_LOG_INFO, \"mosquitto version %s terminating\", VERSION);\n\n#ifdef WITH_CJSON\n\tbroker_control__cleanup();\n#endif\n\n#ifdef WITH_PERSISTENCE\n\tpersist__backup(true);\n#endif\n\tsession_expiry__remove_all();\n\n\tlisteners__stop();\n\n\tHASH_ITER(hh_id, db.contexts_by_id, ctxt, ctxt_tmp){\n#if defined(WITH_WEBSOCKETS) && WITH_WEBSOCKETS == WS_IS_LWS\n\t\tif(!ctxt->wsi)\n#endif\n\t\t{\n\t\t\tctxt->is_persisted = false; /* prevent persistence removal */\n\t\t\tcontext__cleanup(ctxt, true);\n\t\t}\n\t}\n\tHASH_ITER(hh_sock, db.contexts_by_sock, ctxt, ctxt_tmp){\n\t\tctxt->is_persisted = false; /* prevent persistence removal */\n\t\tcontext__cleanup(ctxt, true);\n\t}\n#ifdef WITH_BRIDGE\n\tbridge__db_cleanup();\n#endif\n\tcontext__free_disused();\n\tkeepalive__cleanup();\n\n#ifdef WITH_TLS\n\tmosquitto__FREE(db.tls_keylog);\n#endif\n\tdb__close();\n\n\tplugin__unload_all();\n\tmosquitto_security_cleanup(false);\n\n\tif(config.pid_file){\n\t\t(void)remove(config.pid_file);\n\t}\n\n\tlog__close(&config);\n\tconfig__cleanup(db.config);\n\tnet__broker_cleanup();\n\n\treturn rc;\n}",
        "file_path": "/src/mosquitto/src/mosquitto.c",
        "crashing_line": "\trc = config__parse_args(&config, argc, argv);",
        "crashing_line_number": 357
      },
      {
        "function_name": "run_broker",
        "function_body": "void run_broker(char *filename)\n{\n\tchar *argv[4];\n\tint argc = 4;\n\n\targv[0] = strdup(\"mosquitto\");\n\targv[1] = strdup(\"--test-config\");\n\targv[2] = strdup(\"-c\");\n\targv[3] = strdup(filename);\n\n\tmosquitto_fuzz_main(argc, argv);\n\n\tfor(int i=0; i<argc; i++){\n\t\tfree(argv[i]);\n\t}\n}",
        "file_path": "/src/mosquitto/fuzzing/broker/broker_fuzz_test_config.cpp",
        "crashing_line": "\tmosquitto_fuzz_main(argc, argv);",
        "crashing_line_number": 42
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "        Ret call(Args... args) {\n            const void *arg_ptrs[] = { reinterpret_cast<const void*>(&args)... };\n            M3Result res = m3_Call(m_func, sizeof...(args), arg_ptrs);\n            detail::check_error(res);\n\n            if constexpr (!std::is_void<Ret>::value) {\n                Ret ret;\n                const void* ret_ptrs[] = { &ret };\n                res = m3_GetResults(m_func, 1, ret_ptrs);\n                detail::check_error(res);\n                return ret; \n            }\n        }\nIM3CodePage  NewCodePage  (IM3Runtime i_runtime, u32 i_minNumLines)\n{\n    IM3CodePage page;\n\n    u32 pageSize = sizeof (M3CodePageHeader) + sizeof (code_t) * i_minNumLines;\n\n    pageSize = (pageSize + (d_m3CodePageAlignSize-1)) & ~(d_m3CodePageAlignSize-1); // align\n    page = (IM3CodePage)m3_Malloc (\"M3CodePage\", pageSize);\n\n    if (page)\n    {\n        page->info.sequence = ++i_runtime->newCodePageSequence;\n        page->info.numLines = (pageSize - sizeof (M3CodePageHeader)) / sizeof (code_t);\n\n#if d_m3RecordBacktraces\n        u32 pageSizeBt = sizeof (M3CodeMappingPage) + sizeof (M3CodeMapEntry) * page->info.numLines;\n        page->info.mapping = (M3CodeMappingPage *)m3_Malloc (\"M3CodeMappingPage\", pageSizeBt);\n\n        if (page->info.mapping)\n        {\n            page->info.mapping->size = 0;\n            page->info.mapping->capacity = page->info.numLines;\n        }\n        else\n        {\n            m3_Free (page);\n            return NULL;\n        }\n        page->info.mapping->basePC = GetPageStartPC(page);\n#endif // d_m3RecordBacktraces\n\n        m3log (runtime, \"new page: %p; seq: %d; bytes: %d; lines: %d\", GetPagePC (page), page->info.sequence, pageSize, page->info.numLines);\n    }\n\n    return page;\n}\nstatic inline\nvoid  TouchSlot  (IM3Compilation o, u16 i_slot)\n{\n    if (o->function)\n    {\n        // op_Entry uses this value to track and detect stack overflow\n        o->maxStackSlots = M3_MAX (o->maxStackSlots, i_slot + 1);\n    }\n}\nstatic\nM3Result  Compile_GetGlobal  (IM3Compilation o, M3Global * i_global)\n{\n    M3Result result;\n\n    IM3Operation op = Is64BitType (i_global->type) ? op_GetGlobal_s64 : op_GetGlobal_s32;\n_   (EmitOp (o, op));\n    EmitPointer (o, & i_global->intValue);\n_   (PushAllocatedSlotAndEmit (o, i_global->type));\n\n    _catch: return result;\n}\nstatic\nM3Result  Compile_SetGlobal  (IM3Compilation o, M3Global * i_global)\n{\n    M3Result result = m3Err_none;\n\n    if (i_global->isMutable)\n    {\n        IM3Operation op;\n        u8 type = GetStackTopType (o);\n\n        if (IsStackTopInRegister (o))\n        {\n            op = c_setGlobalOps [type];\n        }\n        else op = Is64BitType (type) ? op_SetGlobal_s64 : op_SetGlobal_s32;\n\n_      (EmitOp (o, op));\n        EmitPointer (o, & i_global->intValue);\n\n        if (IsStackTopInSlot (o))\n            EmitSlotOffset (o, GetStackTopSlotNumber (o));\n\n_      (Pop (o));\n    }\n    else _throw (m3Err_settingImmutableGlobal);\n\n    _catch: return result;\n}\nstatic\nM3Result  CompileElseBlock  (IM3Compilation o, pc_t * o_startPC, IM3FuncType i_blockType)\n{\n_try {\n\n    IM3CodePage elsePage;\n_   (AcquireCompilationCodePage (o, & elsePage));\n\n    * o_startPC = GetPagePC (elsePage);\n\n    IM3CodePage savedPage = o->page;\n    o->page = elsePage;\n\n_   (CompileBlock (o, i_blockType, c_waOp_else));\n\n_   (EmitOp (o, op_Branch));\n    EmitPointer (o, GetPagePC (savedPage));\n\n    ReleaseCompilationCodePage (o);\n\n    o->page = savedPage;\n\n} _catch:\nM3Result  CompileBlock  (IM3Compilation o, IM3FuncType i_blockType, m3opcode_t i_blockOpcode)\n{\n                                                                                        d_m3Assert (not IsRegisterAllocated (o, 0));\n                                                                                        d_m3Assert (not IsRegisterAllocated (o, 1));\n    M3CompilationScope outerScope = o->block;\n    M3CompilationScope * block = & o->block;\n\n    block->outer            = & outerScope;\n    block->pc               = GetPagePC (o->page);\n    block->patches          = NULL;\n    block->type             = i_blockType;\n    block->depth            ++;\n    block->opcode           = i_blockOpcode;\n\n    /*\n     The block stack frame is a little strange but for good reasons.  Because blocks need to be restarted to\n     compile different pathways (if/else), the incoming params must be saved.  The parameters are popped\n     and validated.  But, then the stack top is readjusted so they aren't subsequently overwritten.\n     Next, the result are preallocated to find destination slots.  But again these are immediately popped\n     (deallocated) and the stack top is readjusted to keep these records in pace. This allows branch instructions\n     to find their result landing pads.  Finally, the params are copied from the \"dead\" records and pushed back\n     onto the stack as active stack items for the CompileBlockStatements () call.\n\n    [     block      ]\n    [     params     ]\n    ------------------\n    [     result     ]  <---- blockStackIndex\n    [      slots     ]\n    ------------------\n    [   saved param  ]\n    [     records    ]\n                        <----- exitStackIndex\n    */\n\n_try {\n    // validate and dealloc params ----------------------------\n\n    u16 stackIndex = o->stackIndex;\n\n    u16 numParams = GetFuncTypeNumParams (i_blockType);\n\n    if (i_blockOpcode != c_waOp_else)\n    {\n        for (u16 i = 0; i < numParams; ++i)\n        {\n            u8 type = GetFuncTypeParamType (i_blockType, numParams - 1 - i);\n_           (PopType (o, type));\n        }\n    }\n    else o->stackIndex -= numParams;\n\n    u16 paramIndex = o->stackIndex;\n    block->exitStackIndex = paramIndex; // consume the params at block exit\n\n    // keep copies of param slots in the stack\n    o->stackIndex = stackIndex;\n\n    // find slots for the results ----------------------------\n    PushBlockResults (o);\n\n    stackIndex = o->stackIndex;\n\n    // dealloc but keep record of the result slots in the stack\n    u16 numResults = GetFuncTypeNumResults (i_blockType);\n    while (numResults--)\n        Pop (o);\n\n    block->blockStackIndex = o->stackIndex = stackIndex;\n\n    // push the params back onto the stack -------------------\n    for (u16 i = 0; i < numParams; ++i)\n    {\n        u8 type = GetFuncTypeParamType (i_blockType, i);\n\n        u16 slot = GetSlotForStackIndex (o, paramIndex + i);\n        Push (o, type, slot);\n\n        if (slot >= o->slotFirstDynamicIndex)\n            MarkSlotsAllocatedByType (o, slot, type);\n    }\n\n    //--------------------------------------------------------\n\n_   (CompileBlockStatements (o));\n\n_   (ValidateBlockEnd (o));\n\n    if (o->function)    // skip for expressions\n    {\n        if (not IsStackPolymorphic (o))\n_           (ResolveBlockResults (o, & o->block, /* isBranch: */ false));\n\n_       (UnwindBlockStack (o))\n\n        if (not ((i_blockOpcode == c_waOp_if and numResults) or o->previousOpcode == c_waOp_else))\n        {\n            o->stackIndex = o->block.exitStackIndex;\n_           (PushBlockResults (o));\n        }\n    }\n\n    PatchBranches (o);\n\n    o->block = outerScope;\n\n}   _catch: return result;\nM3Result  InitGlobals  (IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    if (io_module->numGlobals)\n    {\n        // placing the globals in their structs isn't good for cache locality, but i don't really know what the global\n        // access patterns typically look like yet.\n\n        //          io_module->globalMemory = m3Alloc (m3reg_t, io_module->numGlobals);\n\n        //          if (io_module->globalMemory)\n        {\n            for (u32 i = 0; i < io_module->numGlobals; ++i)\n            {\n                M3Global * g = & io_module->globals [i];                        m3log (runtime, \"initializing global: %d\", i);\n\n                if (g->initExpr)\n                {\n                    bytes_t start = g->initExpr;\n                    result = EvaluateExpression (io_module, & g->intValue, g->type, & start, g->initExpr + g->initExprSize);\n\n                    if (not result)\n                    {\n                        // io_module->globalMemory [i] = initValue;\n                    }\n                    else break;\n                }\n                else\n                {                                                               m3log (runtime, \"importing global\");\n\n                }\n            }\n        }\n        //          else result = ErrorModule (m3Err_mallocFailed, io_module, \"could allocate globals for module: '%s\", io_module->name);\n    }\n\n    return result;\n}\nM3Result  m3_GetGlobal  (IM3Global                 i_global,\n                         IM3TaggedValue            o_value)\n{\n    if (not i_global) return m3Err_globalLookupFailed;\n\n    switch (i_global->type) {\n    case c_m3Type_i32: o_value->value.i32 = i_global->intValue; break;\n    case c_m3Type_i64: o_value->value.i64 = i_global->intValue; break;\n# if d_m3HasFloat\n    case c_m3Type_f32: o_value->value.f32 = i_global->f32Value; break;\n    case c_m3Type_f64: o_value->value.f64 = i_global->f64Value; break;\n# endif\n    default: return m3Err_invalidTypeId;\n    }\n\n    o_value->type = (M3ValueType)(i_global->type);\n    return m3Err_none;\n}\nM3Result  m3_SetGlobal  (IM3Global                 i_global,\n                         const IM3TaggedValue      i_value)\n{\n    if (not i_global) return m3Err_globalLookupFailed;\n    // TODO: if (not g->isMutable) return m3Err_globalNotMutable;\n\n    if (i_global->type != i_value->type) return m3Err_globalTypeMismatch;\n\n    switch (i_value->type) {\n    case c_m3Type_i32: i_global->intValue = i_value->value.i32; break;\n    case c_m3Type_i64: i_global->intValue = i_value->value.i64; break;\n# if d_m3HasFloat\n    case c_m3Type_f32: i_global->f32Value = i_value->value.f32; break;\n    case c_m3Type_f64: i_global->f64Value = i_value->value.f64; break;\n# endif\n    default: return m3Err_invalidTypeId;\n    }\n\n    return m3Err_none;\n}\n",
    "target": 1,
    "idx": 1033554,
    "stack_trace": [
      {
        "function_name": "op_Const64",
        "function_body": "",
        "file_path": "/src/wasm3/source/./m3_exec.h",
        "crashing_line": "",
        "crashing_line_number": 1226
      },
      {
        "function_name": "RunCode",
        "function_body": "d_m3RetSig  RunCode  (d_m3OpSig)\n{\n    nextOpDirect();\n}",
        "file_path": "/src/wasm3/source/./m3_exec_defs.h",
        "crashing_line": "    nextOpDirect();",
        "crashing_line_number": 58
      },
      {
        "function_name": "EvaluateExpression",
        "function_body": "M3Result  EvaluateExpression  (IM3Module i_module, void * o_expressed, u8 i_type, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    // OPTZ: use a simplified interpreter for expressions\n\n    // create a temporary runtime context\n#if defined(d_m3PreferStaticAlloc)\n    static M3Runtime runtime;\n#else\n    M3Runtime runtime;\n#endif\n    M3_INIT (runtime);\n\n    runtime.environment = i_module->runtime->environment;\n    runtime.numStackSlots = i_module->runtime->numStackSlots;\n    runtime.stack = i_module->runtime->stack;\n\n    m3stack_t stack = (m3stack_t)runtime.stack;\n\n    IM3Runtime savedRuntime = i_module->runtime;\n    i_module->runtime = & runtime;\n\n    IM3Compilation o = & runtime.compilation;\n    o->runtime = & runtime;\n    o->module =  i_module;\n    o->wasm =    * io_bytes;\n    o->wasmEnd = i_end;\n    o->lastOpcodeStart = o->wasm;\n\n    o->block.depth = -1;  // so that root compilation depth = 0\n\n    //  OPTZ: this code page could be erased after use.  maybe have 'empty' list in addition to full and open?\n    o->page = AcquireCodePage (& runtime);  // AcquireUnusedCodePage (...)\n\n    if (o->page)\n    {\n        IM3FuncType ftype = runtime.environment->retFuncTypes[i_type];\n\n        pc_t m3code = GetPagePC (o->page);\n        result = CompileBlock (o, ftype, c_waOp_block);\n\n        if (not result && o->maxStackSlots >= runtime.numStackSlots) {\n            result = m3Err_trapStackOverflow;\n        }\n\n        if (not result)\n        {\n            m3ret_t r = RunCode (m3code, stack, NULL, d_m3OpDefaultArgs);\n\n            if (r == 0)\n            {                                                                               m3log (runtime, \"expression result: %s\", SPrintValue (stack, i_type));\n                if (SizeOfType (i_type) == sizeof (u32))\n                {\n                    * (u32 *) o_expressed = * ((u32 *) stack);\n                }\n                else\n                {\n                    * (u64 *) o_expressed = * ((u64 *) stack);\n                }\n            }\n        }\n\n        // TODO: EraseCodePage (...) see OPTZ above\n        ReleaseCodePage (& runtime, o->page);\n    }\n    else result = m3Err_mallocFailedCodePage;\n\n    runtime.stack = NULL;        // prevent free(stack) in ReleaseRuntime\n    Runtime_Release (& runtime);\n    i_module->runtime = savedRuntime;\n\n    * io_bytes = o->wasm;\n\n    return result;\n}",
        "file_path": "/src/wasm3/source/m3_env.c",
        "crashing_line": "            m3ret_t r = RunCode (m3code, stack, NULL, d_m3OpDefaultArgs);",
        "crashing_line_number": 300
      },
      {
        "function_name": "InitDataSegments",
        "function_body": "M3Result  InitDataSegments  (M3Memory * io_memory, IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    _throwif (\"unallocated linear memory\", !(io_memory->mallocated));\n\n    for (u32 i = 0; i < io_module->numDataSegments; ++i)\n    {\n        M3DataSegment * segment = & io_module->dataSegments [i];\n\n        i32 segmentOffset;\n        bytes_t start = segment->initExpr;\n_       (EvaluateExpression (io_module, & segmentOffset, c_m3Type_i32, & start, segment->initExpr + segment->initExprSize));\n\n        m3log (runtime, \"loading data segment: %d; size: %d; offset: %d\", i, segment->size, segmentOffset);\n\n        if (segmentOffset >= 0 && (size_t)(segmentOffset) + segment->size <= io_memory->mallocated->length)\n        {\n            u8 * dest = m3MemData (io_memory->mallocated) + segmentOffset;\n            memcpy (dest, segment->data, segment->size);\n        } else {\n            _throw (\"data segment out of bounds\");\n        }\n    }\n\n    _catch: return result;\n}",
        "file_path": "/src/wasm3/source/m3_env.c",
        "crashing_line": "        bytes_t start = segment->initExpr;",
        "crashing_line_number": 460
      },
      {
        "function_name": "m3_LoadModule",
        "function_body": "M3Result  m3_LoadModule  (IM3Runtime io_runtime, IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    if (M3_UNLIKELY(io_module->runtime)) {\n        return m3Err_moduleAlreadyLinked;\n    }\n\n    io_module->runtime = io_runtime;\n    M3Memory * memory = & io_runtime->memory;\n\n_   (InitMemory (io_runtime, io_module));\n_   (InitGlobals (io_module));\n_   (InitDataSegments (memory, io_module));\n_   (InitElements (io_module));\n\n    // Start func might use imported functions, which are not liked here yet,\n    // so it will be called before a function call is attempted (in m3_FindFunction)\n\n#ifdef DEBUG\n    Module_GenerateNames(io_module);\n#endif\n\n    io_module->next = io_runtime->modules;\n    io_runtime->modules = io_module;\n    return result; // ok\n\n_catch:\n    io_module->runtime = NULL;\n    return result;\n}",
        "file_path": "/src/wasm3/source/m3_env.c",
        "crashing_line": "_   (InitGlobals (io_module));",
        "crashing_line_number": 597
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "bool KAr::openArchive(QIODevice::OpenMode mode)\n{\n    // Open archive\n\n    if (mode == QIODevice::WriteOnly) {\n        return true;\n    }\n    if (mode != QIODevice::ReadOnly && mode != QIODevice::ReadWrite) {\n        setErrorString(tr(\"Unsupported mode %1\").arg(mode));\n        return false;\n    }\n\n    QIODevice *dev = device();\n    if (!dev) {\n        return false;\n    }\n\n    QByteArray magic = dev->read(7);\n    if (magic != \"!<arch>\") {\n        setErrorString(tr(\"Invalid main magic\"));\n        return false;\n    }\n\n    char *ar_longnames = nullptr;\n    while (! dev->atEnd()) {\n        QByteArray ar_header;\n        ar_header.resize(60);\n\n        dev->seek(dev->pos() + (2 - (dev->pos() % 2)) % 2);   // Ar headers are padded to byte boundary\n\n        if (dev->read(ar_header.data(), 60) != 60) {   // Read ar header\n            //qCWarning(KArchiveLog) << \"Couldn't read header\";\n            delete[] ar_longnames;\n            //return false;\n            return true; // Probably EOF / trailing junk\n        }\n\n        if (!ar_header.endsWith(\"`\\n\")) { // Check header magic // krazy:exclude=strings\n            setErrorString(tr(\"Invalid magic\"));\n            delete[] ar_longnames;\n            return false;\n        }\n\n        QByteArray name = ar_header.mid(0, 16);   // Process header\n        const int date = ar_header.mid(16, 12).trimmed().toInt();\n        //const int uid = ar_header.mid( 28, 6 ).trimmed().toInt();\n        //const int gid = ar_header.mid( 34, 6 ).trimmed().toInt();\n        const int mode = ar_header.mid(40, 8).trimmed().toInt();\n        const qint64 size = ar_header.mid(48, 10).trimmed().toInt();\n\n        bool skip_entry = false; // Deal with special entries\n        if (name.mid(0, 1) == \"/\") {\n            if (name.mid(1, 1) == \"/\") { // Longfilename table entry\n                delete[] ar_longnames;\n                ar_longnames = new char[size + 1];\n                ar_longnames[size] = '\\0';\n                dev->read(ar_longnames, size);\n                skip_entry = true;\n                //qCDebug(KArchiveLog) << \"Read in longnames entry\";\n            } else if (name.mid(1, 1) == \" \") { // Symbol table entry\n                //qCDebug(KArchiveLog) << \"Skipped symbol entry\";\n                dev->seek(dev->pos() + size);\n                skip_entry = true;\n            } else { // Longfilename\n                //qCDebug(KArchiveLog) << \"Longfilename #\" << name.mid(1, 15).toInt();\n                if (! ar_longnames) {\n                    setErrorString(tr(\"Invalid longfilename reference\"));\n                    delete[] ar_longnames;\n                    return false;\n                }\n                name = &ar_longnames[name.mid(1, 15).toInt()];\n                name = name.left(name.indexOf(\"/\"));\n            }\n        }\n        if (skip_entry) {\n            continue;\n        }\n\n        name = name.trimmed(); // Process filename\n        name.replace('/', QByteArray());\n        //qCDebug(KArchiveLog) << \"Filename: \" << name << \" Size: \" << size;\n\n        KArchiveEntry *entry = new KArchiveFile(this, QString::fromLocal8Bit(name.constData()), mode, KArchivePrivate::time_tToDateTime(date),\n                                                rootDir()->user(), rootDir()->group(), /*symlink*/ QString(),\n                                                dev->pos(), size);\n        rootDir()->addEntry(entry); // Ar files don't support directories, so everything in root\n\n        dev->seek(dev->pos() + size);   // Skip contents\n    }\n    delete[] ar_longnames;\n\n    return true;\n}\n",
    "target": 1,
    "idx": 1014703,
    "stack_trace": [
      {
        "function_name": "openArchive",
        "function_body": "bool KAr::openArchive(QIODevice::OpenMode mode)\n{\n    // Open archive\n\n    if (mode == QIODevice::WriteOnly) {\n        return true;\n    }\n    if (mode != QIODevice::ReadOnly && mode != QIODevice::ReadWrite) {\n        setErrorString(tr(\"Unsupported mode %1\").arg(mode));\n        return false;\n    }\n\n    QIODevice *dev = device();\n    if (!dev) {\n        return false;\n    }\n\n    QByteArray magic = dev->read(7);\n    if (magic != \"!<arch>\") {\n        setErrorString(tr(\"Invalid main magic\"));\n        return false;\n    }\n\n    char *ar_longnames = nullptr;\n    while (! dev->atEnd()) {\n        QByteArray ar_header;\n        ar_header.resize(60);\n\n        dev->seek(dev->pos() + (2 - (dev->pos() % 2)) % 2);   // Ar headers are padded to byte boundary\n\n        if (dev->read(ar_header.data(), 60) != 60) {   // Read ar header\n            //qCWarning(KArchiveLog) << \"Couldn't read header\";\n            delete[] ar_longnames;\n            //return false;\n            return true; // Probably EOF / trailing junk\n        }\n\n        if (!ar_header.endsWith(\"`\\n\")) { // Check header magic // krazy:exclude=strings\n            setErrorString(tr(\"Invalid magic\"));\n            delete[] ar_longnames;\n            return false;\n        }\n\n        QByteArray name = ar_header.mid(0, 16);   // Process header\n        const int date = ar_header.mid(16, 12).trimmed().toInt();\n        //const int uid = ar_header.mid( 28, 6 ).trimmed().toInt();\n        //const int gid = ar_header.mid( 34, 6 ).trimmed().toInt();\n        const int mode = ar_header.mid(40, 8).trimmed().toInt();\n        const qint64 size = ar_header.mid(48, 10).trimmed().toInt();\n        if (size < 0) {\n            setErrorString(tr(\"Invalid size\"));\n            delete[] ar_longnames;\n            return false;\n        }\n\n        bool skip_entry = false; // Deal with special entries\n        if (name.mid(0, 1) == \"/\") {\n            if (name.mid(1, 1) == \"/\") { // Longfilename table entry\n                delete[] ar_longnames;\n                ar_longnames = new char[size + 1];\n                ar_longnames[size] = '\\0';\n                dev->read(ar_longnames, size);\n                skip_entry = true;\n                //qCDebug(KArchiveLog) << \"Read in longnames entry\";\n            } else if (name.mid(1, 1) == \" \") { // Symbol table entry\n                //qCDebug(KArchiveLog) << \"Skipped symbol entry\";\n                dev->seek(dev->pos() + size);\n                skip_entry = true;\n            } else { // Longfilename\n                //qCDebug(KArchiveLog) << \"Longfilename #\" << name.mid(1, 15).toInt();\n                if (! ar_longnames) {\n                    setErrorString(tr(\"Invalid longfilename reference\"));\n                    delete[] ar_longnames;\n                    return false;\n                }\n                name = &ar_longnames[name.mid(1, 15).toInt()];\n                name = name.left(name.indexOf(\"/\"));\n            }\n        }\n        if (skip_entry) {\n            continue;\n        }\n\n        name = name.trimmed(); // Process filename\n        name.replace('/', QByteArray());\n        //qCDebug(KArchiveLog) << \"Filename: \" << name << \" Size: \" << size;\n\n        KArchiveEntry *entry = new KArchiveFile(this, QString::fromLocal8Bit(name.constData()), mode, KArchivePrivate::time_tToDateTime(date),\n                                                rootDir()->user(), rootDir()->group(), /*symlink*/ QString(),\n                                                dev->pos(), size);\n        rootDir()->addEntry(entry); // Ar files don't support directories, so everything in root\n\n        dev->seek(dev->pos() + size);   // Skip contents\n    }\n    delete[] ar_longnames;\n\n    return true;\n}",
        "file_path": "/src/karchive/src/kar.cpp",
        "crashing_line": "        bool skip_entry = false; // Deal with special entries",
        "crashing_line_number": 147
      },
      {
        "function_name": "open",
        "function_body": "bool KArchive::open(QIODevice::OpenMode mode)\n{\n    Q_ASSERT(mode != QIODevice::NotOpen);\n\n    if (isOpen()) {\n        close();\n    }\n\n    if (!d->fileName.isEmpty()) {\n        Q_ASSERT(!d->dev);\n        if (!createDevice(mode)) {\n            return false;\n        }\n    }\n\n    if (!d->dev) {\n        setErrorString(tr(\"No filename or device was specified\"));\n        return false;\n    }\n\n    if (!d->dev->isOpen() && !d->dev->open(mode)) {\n        setErrorString(tr(\"Could not set device mode to %1\").arg(mode));\n        return false;\n    }\n\n    d->mode = mode;\n\n    Q_ASSERT(!d->rootDir);\n    d->rootDir = nullptr;\n\n    return openArchive(mode);\n}",
        "file_path": "/src/karchive/src/karchive.cpp",
        "crashing_line": "    return openArchive(mode);",
        "crashing_line_number": 178
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "  sfnt_init_face( FT_Stream      stream,\n                  TT_Face        face,\n                  FT_Int         face_instance_index,\n                  FT_Int         num_params,\n                  FT_Parameter*  params )\n  {\n    FT_Error      error;\n    FT_Memory     memory = face->root.memory;\n    FT_Library    library = face->root.driver->root.library;\n    SFNT_Service  sfnt;\n    FT_Int        face_index;\n\n\n    /* for now, parameters are unused */\n    FT_UNUSED( num_params );\n    FT_UNUSED( params );\n\n\n    sfnt = (SFNT_Service)face->sfnt;\n    if ( !sfnt )\n    {\n      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, \"sfnt\" );\n      if ( !sfnt )\n      {\n        FT_ERROR(( \"sfnt_init_face: cannot access `sfnt' module\\n\" ));\n        return FT_THROW( Missing_Module );\n      }\n\n      face->sfnt       = sfnt;\n      face->goto_table = sfnt->goto_table;\n    }\n\n    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    if ( !face->mm )\n    {\n      /* we want the MM interface from the `truetype' module only */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->mm = ft_module_get_service( tt_module,\n                                        FT_SERVICE_ID_MULTI_MASTERS,\n                                        0 );\n    }\n\n    if ( !face->var )\n    {\n      /* we want the metrics variations interface */\n      /* from the `truetype' module only          */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->var = ft_module_get_service( tt_module,\n                                         FT_SERVICE_ID_METRICS_VARIATIONS,\n                                         0 );\n    }\n#endif\n\n    FT_TRACE2(( \"SFNT driver\\n\" ));\n\n    error = sfnt_open_font( stream, face );\n    if ( error )\n      return error;\n\n    /* Stream may have changed in sfnt_open_font. */\n    stream = face->root.stream;\n\n    FT_TRACE2(( \"sfnt_init_face: %08p, %d\\n\", face, face_instance_index ));\n\n    face_index = FT_ABS( face_instance_index ) & 0xFFFF;\n\n    /* value -(N+1) requests information on index N */\n    if ( face_instance_index < 0 )\n      face_index--;\n\n    if ( face_index >= face->ttc_header.count )\n    {\n      if ( face_instance_index >= 0 )\n        return FT_THROW( Invalid_Argument );\n      else\n        face_index = 0;\n    }\n\n    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )\n      return error;\n\n    /* check whether we have a valid TrueType file */\n    error = sfnt->load_font_dir( face, stream );\n    if ( error )\n      return error;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    {\n      FT_ULong  fvar_len;\n\n      FT_ULong  version;\n      FT_ULong  offset;\n\n      FT_UShort  num_axes;\n      FT_UShort  axis_size;\n      FT_UShort  num_instances;\n      FT_UShort  instance_size;\n\n      FT_Int  instance_index;\n\n      FT_Byte*  default_values  = NULL;\n      FT_Byte*  instance_values = NULL;\n\n\n      face->is_default_instance = 1;\n\n      instance_index = FT_ABS( face_instance_index ) >> 16;\n\n      /* test whether current face is a GX font with named instances */\n      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||\n           fvar_len < 20                                          ||\n           FT_READ_ULONG( version )                               ||\n           FT_READ_USHORT( offset )                               ||\n           FT_STREAM_SKIP( 2 ) /* reserved */                     ||\n           FT_READ_USHORT( num_axes )                             ||\n           FT_READ_USHORT( axis_size )                            ||\n           FT_READ_USHORT( num_instances )                        ||\n           FT_READ_USHORT( instance_size )                        )\n      {\n        version       = 0;\n        offset        = 0;\n        num_axes      = 0;\n        axis_size     = 0;\n        num_instances = 0;\n        instance_size = 0;\n      }\n\n      /* check that the data is bound by the table length */\n      if ( version != 0x00010000UL                    ||\n           axis_size != 20                            ||\n           num_axes == 0                              ||\n           /* `num_axes' limit implied by 16-bit `instance_size' */\n           num_axes > 0x3FFE                          ||\n           !( instance_size == 4 + 4 * num_axes ||\n              instance_size == 6 + 4 * num_axes )     ||\n           /* `num_instances' limit implied by limited range of name IDs */\n           num_instances > 0x7EFF                     ||\n           offset                          +\n             axis_size * num_axes          +\n             instance_size * num_instances > fvar_len )\n        num_instances = 0;\n      else\n        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;\n\n      /*\n       *  As documented in the OpenType specification, an entry for the\n       *  default instance may be omitted in the named instance table.  In\n       *  particular this means that even if there is no named instance\n       *  table in the font we actually do have a named instance, namely the\n       *  default instance.\n       *\n       *  For consistency, we always want the default instance in our list\n       *  of named instances.  If it is missing, we try to synthesize it\n       *  later on.  Here, we have to adjust `num_instances' accordingly.\n       */\n\n      if ( !( FT_ALLOC( default_values, num_axes * 2 )  ||\n              FT_ALLOC( instance_values, num_axes * 2 ) ) )\n      {\n        /* the current stream position is 16 bytes after the table start */\n        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;\n        FT_ULong  default_value_offset, instance_offset;\n\n        FT_Byte*  p;\n        FT_UInt   i;\n\n\n        default_value_offset = array_start + 8;\n        p                    = default_values;\n\n        for ( i = 0; i < num_axes; i++ )\n        {\n          (void)FT_STREAM_READ_AT( default_value_offset, p, 2 );\n\n          default_value_offset += axis_size;\n          p                    += 2;\n        }\n\n        instance_offset = array_start + axis_size * num_axes + 4;\n\n        for ( i = 0; i < num_instances; i++ )\n        {\n          (void)FT_STREAM_READ_AT( instance_offset,\n                                   instance_values,\n                                   num_axes * 2 );\n\n          if ( !ft_memcmp( default_values, instance_values, num_axes * 2 ) )\n            break;\n\n          instance_offset += instance_size;\n        }\n\n        if ( i == num_instances )\n        {\n          /* no default instance in named instance table; */\n          /* we thus have to synthesize it                */\n          num_instances++;\n        }\n      }\n\n      FT_FREE( default_values );\n      FT_FREE( instance_values );\n\n      /* we don't support Multiple Master CFFs yet */\n      if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&\n           !face->goto_table( face, TTAG_CFF, stream, 0 ) )\n        num_instances = 0;\n\n      /* instance indices in `face_instance_index' start with index 1, */\n      /* thus `>' and not `>='                                         */\n      if ( instance_index > num_instances )\n      {\n        if ( face_instance_index >= 0 )\n          return FT_THROW( Invalid_Argument );\n        else\n          num_instances = 0;\n      }\n\n      face->root.style_flags = (FT_Long)num_instances << 16;\n    }\n#endif\n\n    face->root.num_faces  = face->ttc_header.count;\n    face->root.face_index = face_instance_index;\n\n    return error;\n  }\n",
    "target": 1,
    "idx": 1000759,
    "stack_trace": [
      {
        "function_name": "TT_Get_MM_Var",
        "function_body": "  TT_Get_MM_Var( TT_Face      face,\n                 FT_MM_Var*  *master )\n  {\n    FT_Stream            stream = face->root.stream;\n    FT_Memory            memory = face->root.memory;\n    FT_ULong             table_len;\n    FT_Error             error  = FT_Err_Ok;\n    FT_ULong             fvar_start;\n    FT_UInt              i, j;\n    FT_MM_Var*           mmvar = NULL;\n    FT_Fixed*            next_coords;\n    FT_Fixed*            nsc;\n    FT_String*           next_name;\n    FT_Var_Axis*         a;\n    FT_Fixed*            c;\n    FT_Var_Named_Style*  ns;\n    GX_FVar_Head         fvar_head;\n    FT_Bool              usePsName;\n    FT_UInt              num_instances;\n\n    static const FT_Frame_Field  fvar_fields[] =\n    {\n\n#undef  FT_STRUCTURE\n#define FT_STRUCTURE  GX_FVar_Head\n\n      FT_FRAME_START( 16 ),\n        FT_FRAME_LONG      ( version ),\n        FT_FRAME_USHORT    ( offsetToData ),\n        FT_FRAME_SKIP_SHORT,\n        FT_FRAME_USHORT    ( axisCount ),\n        FT_FRAME_USHORT    ( axisSize ),\n        FT_FRAME_USHORT    ( instanceCount ),\n        FT_FRAME_USHORT    ( instanceSize ),\n      FT_FRAME_END\n    };\n\n    static const FT_Frame_Field  fvaraxis_fields[] =\n    {\n\n#undef  FT_STRUCTURE\n#define FT_STRUCTURE  GX_FVar_Axis\n\n      FT_FRAME_START( 20 ),\n        FT_FRAME_ULONG ( axisTag ),\n        FT_FRAME_LONG  ( minValue ),\n        FT_FRAME_LONG  ( defaultValue ),\n        FT_FRAME_LONG  ( maxValue ),\n        FT_FRAME_USHORT( flags ),\n        FT_FRAME_USHORT( nameID ),\n      FT_FRAME_END\n    };\n\n\n    /* read the font data and set up the internal representation */\n    /* if not already done                                       */\n\n    if ( !face->blend )\n    {\n      FT_TRACE2(( \"FVAR \" ));\n\n      /* both `fvar' and `gvar' must be present */\n      if ( FT_SET_ERROR( face->goto_table( face, TTAG_gvar,\n                                           stream, &table_len ) ) )\n      {\n        /* CFF2 is an alternate to gvar here */\n        if ( FT_SET_ERROR( face->goto_table( face, TTAG_CFF2,\n                                             stream, &table_len ) ) )\n        {\n          FT_TRACE1(( \"\\n\"\n                      \"TT_Get_MM_Var: `gvar' or `CFF2' table is missing\\n\" ));\n          goto Exit;\n        }\n      }\n\n      if ( FT_SET_ERROR( face->goto_table( face, TTAG_fvar,\n                                           stream, &table_len ) ) )\n      {\n        FT_TRACE1(( \"is missing\\n\" ));\n        goto Exit;\n      }\n\n      fvar_start = FT_STREAM_POS( );\n\n      /* the validity of the `fvar' header data was already checked */\n      /* in function `sfnt_init_face'                               */\n      if ( FT_STREAM_READ_FIELDS( fvar_fields, &fvar_head ) )\n        goto Exit;\n\n      usePsName = FT_BOOL( fvar_head.instanceSize ==\n                           6 + 4 * fvar_head.axisCount );\n\n      FT_TRACE2(( \"loaded\\n\" ));\n\n      FT_TRACE5(( \"number of GX style axes: %d\\n\", fvar_head.axisCount ));\n\n      if ( FT_NEW( face->blend ) )\n        goto Exit;\n\n      /* `num_instances' holds the number of all named instances, */\n      /* including the default instance which might be missing    */\n      /* in fvar's table of named instances                       */\n      num_instances = face->root.style_flags >> 16;\n\n      /* cannot overflow 32-bit arithmetic because of the size limits */\n      /* used in the `fvar' table validity check in `sfnt_init_face'  */\n      face->blend->mmvar_len =\n        sizeof ( FT_MM_Var ) +\n        fvar_head.axisCount * sizeof ( FT_Var_Axis ) +\n        num_instances * sizeof ( FT_Var_Named_Style ) +\n        num_instances * fvar_head.axisCount * sizeof ( FT_Fixed ) +\n        5 * fvar_head.axisCount;\n\n      if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )\n        goto Exit;\n      face->blend->mmvar = mmvar;\n\n      /* set up pointers and offsets into the `mmvar' array; */\n      /* the data gets filled in later on                    */\n\n      mmvar->num_axis =\n        fvar_head.axisCount;\n      mmvar->num_designs =\n        ~0U;                   /* meaningless in this context; each glyph */\n                               /* may have a different number of designs  */\n                               /* (or tuples, as called by Apple)         */\n      mmvar->num_namedstyles =\n        num_instances;\n      mmvar->axis =\n        (FT_Var_Axis*)&( mmvar[1] );\n      mmvar->namedstyle =\n        (FT_Var_Named_Style*)&( mmvar->axis[fvar_head.axisCount] );\n\n      next_coords =\n        (FT_Fixed*)&( mmvar->namedstyle[num_instances] );\n      for ( i = 0; i < num_instances; i++ )\n      {\n        mmvar->namedstyle[i].coords  = next_coords;\n        next_coords                 += fvar_head.axisCount;\n      }\n\n      next_name = (FT_String*)next_coords;\n      for ( i = 0; i < fvar_head.axisCount; i++ )\n      {\n        mmvar->axis[i].name  = next_name;\n        next_name           += 5;\n      }\n\n      /* now fill in the data */\n\n      if ( FT_STREAM_SEEK( fvar_start + fvar_head.offsetToData ) )\n        goto Exit;\n\n      a = mmvar->axis;\n      for ( i = 0; i < fvar_head.axisCount; i++ )\n      {\n        GX_FVar_Axis  axis_rec;\n\n\n        if ( FT_STREAM_READ_FIELDS( fvaraxis_fields, &axis_rec ) )\n          goto Exit;\n        a->tag     = axis_rec.axisTag;\n        a->minimum = axis_rec.minValue;\n        a->def     = axis_rec.defaultValue;\n        a->maximum = axis_rec.maxValue;\n        a->strid   = axis_rec.nameID;\n\n        a->name[0] = (FT_String)(   a->tag >> 24 );\n        a->name[1] = (FT_String)( ( a->tag >> 16 ) & 0xFF );\n        a->name[2] = (FT_String)( ( a->tag >>  8 ) & 0xFF );\n        a->name[3] = (FT_String)( ( a->tag       ) & 0xFF );\n        a->name[4] = '\\0';\n\n        if ( a->minimum > a->def ||\n             a->def > a->maximum )\n        {\n          FT_TRACE2(( \"TT_Get_MM_Var:\"\n                      \" invalid \\\"%s\\\" axis record; disabling\\n\",\n                      a->name ));\n\n          a->minimum = a->def;\n          a->maximum = a->def;\n        }\n\n        FT_TRACE5(( \"  \\\"%s\\\": minimum=%.5f, default=%.5f, maximum=%.5f\\n\",\n                    a->name,\n                    a->minimum / 65536.0,\n                    a->def / 65536.0,\n                    a->maximum / 65536.0 ));\n\n        a++;\n      }\n\n      FT_TRACE5(( \"\\n\" ));\n\n      /* named instance coordinates are stored as design coordinates; */\n      /* we have to convert them to normalized coordinates also       */\n      if ( FT_NEW_ARRAY( face->blend->normalized_stylecoords,\n                         fvar_head.axisCount * num_instances ) )\n        goto Exit;\n\n      if ( fvar_head.instanceCount && !face->blend->avar_checked )\n        ft_var_load_avar( face );\n\n      ns  = mmvar->namedstyle;\n      nsc = face->blend->normalized_stylecoords;\n      for ( i = 0; i < fvar_head.instanceCount; i++, ns++ )\n      {\n        /* PostScript names add 2 bytes to the instance record size */\n        if ( FT_FRAME_ENTER( ( usePsName ? 6L : 4L ) +\n                             4L * fvar_head.axisCount ) )\n          goto Exit;\n\n        ns->strid       =    FT_GET_USHORT();\n        (void) /* flags = */ FT_GET_USHORT();\n\n        c = ns->coords;\n        for ( j = 0; j < fvar_head.axisCount; j++, c++ )\n          *c = FT_GET_LONG();\n\n        if ( usePsName )\n          ns->psid = FT_GET_USHORT();\n\n        ft_var_to_normalized( face,\n                              fvar_head.axisCount,\n                              ns->coords,\n                              nsc );\n        nsc += fvar_head.axisCount;\n\n        FT_FRAME_EXIT();\n      }\n\n      if ( num_instances != fvar_head.instanceCount )\n      {\n        SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n\n        FT_Int  found, win, apple;\n\n\n        /* the default instance is missing in array the   */\n        /* of named instances; try to synthesize an entry */\n        found = sfnt->get_name_id( face,\n                                   TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY,\n                                   &win,\n                                   &apple );\n        if ( !found )\n          found = sfnt->get_name_id( face,\n                                     TT_NAME_ID_FONT_SUBFAMILY,\n                                     &win,\n                                     &apple );\n\n        if ( found )\n        {\n          FT_Int  strid = win >= 0 ? win : apple;\n\n\n          found = sfnt->get_name_id( face,\n                                     TT_NAME_ID_PS_NAME,\n                                     &win,\n                                     &apple );\n          if ( found )\n          {\n            FT_Int  psid = win >= 0 ? win : apple;\n\n\n            FT_TRACE5(( \"TT_Get_MM_Var:\"\n                        \" Adding default instance to named instances\\n\" ));\n\n            ns = &mmvar->namedstyle[fvar_head.instanceCount];\n\n            ns->strid = strid;\n            ns->psid  = psid;\n\n            a = mmvar->axis;\n            c = ns->coords;\n            for ( j = 0; j < fvar_head.axisCount; j++, a++, c++ )\n              *c = a->def;\n          }\n        }\n      }\n\n      ft_var_load_mvar( face );\n    }\n\n    /* fill the output array if requested */\n\n    if ( master )\n    {\n      FT_UInt  n;\n\n\n      if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )\n        goto Exit;\n      FT_MEM_COPY( mmvar, face->blend->mmvar, face->blend->mmvar_len );\n\n      mmvar->axis =\n        (FT_Var_Axis*)&( mmvar[1] );\n      mmvar->namedstyle =\n        (FT_Var_Named_Style*)&( mmvar->axis[mmvar->num_axis] );\n      next_coords =\n        (FT_Fixed*)&( mmvar->namedstyle[mmvar->num_namedstyles] );\n\n      for ( n = 0; n < mmvar->num_namedstyles; n++ )\n      {\n        mmvar->namedstyle[n].coords  = next_coords;\n        next_coords                 += mmvar->num_axis;\n      }\n\n      a         = mmvar->axis;\n      next_name = (FT_String*)next_coords;\n      for ( n = 0; n < mmvar->num_axis; n++ )\n      {\n        a->name = next_name;\n\n        /* standard PostScript names for some standard apple tags */\n        if ( a->tag == TTAG_wght )\n          a->name = (char*)\"Weight\";\n        else if ( a->tag == TTAG_wdth )\n          a->name = (char*)\"Width\";\n        else if ( a->tag == TTAG_opsz )\n          a->name = (char*)\"OpticalSize\";\n        else if ( a->tag == TTAG_slnt )\n          a->name = (char*)\"Slant\";\n\n        next_name += 5;\n        a++;\n      }\n\n      *master = mmvar;\n    }\n\n  Exit:\n    return error;\n  }",
        "file_path": "/src/freetype2/src/truetype/ttgxvar.c",
        "crashing_line": "        ns->strid       =    FT_GET_USHORT();",
        "crashing_line_number": 2139
      },
      {
        "function_name": "FT_Get_MM_Var",
        "function_body": "  FT_Get_MM_Var( FT_Face      face,\n                 FT_MM_Var*  *amaster )\n  {\n    FT_Error                 error;\n    FT_Service_MultiMasters  service;\n\n\n    /* check of `face' delayed to `ft_face_get_mm_service' */\n\n    if ( !amaster )\n      return FT_THROW( Invalid_Argument );\n\n    error = ft_face_get_mm_service( face, &service );\n    if ( !error )\n    {\n      error = FT_ERR( Invalid_Argument );\n      if ( service->get_mm_var )\n        error = service->get_mm_var( face, amaster );\n    }\n\n    return error;\n  }",
        "file_path": "/src/freetype2/src/base/ftmm.c",
        "crashing_line": "        error = service->get_mm_var( face, amaster );",
        "crashing_line_number": 141
      },
      {
        "function_name": "setIntermediateAxis",
        "function_body": "  static void\n  setIntermediateAxis( FT_Face  face )\n  {\n    // only handle Multiple Masters and GX variation fonts\n    if ( !FT_HAS_MULTIPLE_MASTERS( face ) )\n      return;\n\n    // get variation data for current instance\n    FT_MM_Var*  variations_ptr = nullptr;\n    if ( FT_Get_MM_Var( face, &variations_ptr ) )\n      return;\n\n    unique_ptr<FT_MM_Var,\n               decltype ( free )*>  variations( variations_ptr, free );\n    vector<FT_Fixed>                coords( variations->num_axis );\n\n    // select an arbitrary instance\n    for ( unsigned int  i = 0; i < variations->num_axis; i++ )\n      coords[i] = ( variations->axis[i].minimum +\n                    variations->axis[i].def     ) / 2;\n\n    if ( FT_Set_Var_Design_Coordinates( face,\n                                        FT_UInt( coords.size() ),\n                                        coords.data() ) )\n      return;\n  }",
        "file_path": "/src/freetype2/./src/tools/ftfuzzer/ftfuzzer.cc",
        "crashing_line": "    if ( FT_Get_MM_Var( face, &variations_ptr ) )",
        "crashing_line_number": 219
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int\nwavlike_msadpcm_init\t(SF_PRIVATE *psf, int blockalign, int samplesperblock)\n{\tMSADPCM_PRIVATE\t*pms ;\n\tunsigned int\tpmssize ;\n\tint\t\t\t\tcount ;\n\n\tif (psf->codec_data != NULL)\n\t{\tpsf_log_printf (psf, \"*** psf->codec_data is not NULL.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t\tsamplesperblock = 2 + 2 * (blockalign - 7 * psf->sf.channels) / psf->sf.channels ;\n\n\tif (blockalign < 7 * psf->sf.channels)\n\t{\tpsf_log_printf (psf, \"*** Error blockalign (%d) should be > %d.\\n\", blockalign, 7 * psf->sf.channels) ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tpmssize = sizeof (MSADPCM_PRIVATE) + blockalign + 3 * psf->sf.channels * samplesperblock ;\n\n\tif (! (psf->codec_data = calloc (1, pmssize)))\n\t\treturn SFE_MALLOC_FAILED ;\n\tpms = (MSADPCM_PRIVATE*) psf->codec_data ;\n\n\tpms->sync_error = 0 ;\n\tpms->samples\t= pms->dummydata ;\n\tpms->block\t\t= (unsigned char*) (pms->dummydata + psf->sf.channels * samplesperblock) ;\n\n\tpms->channels\t= psf->sf.channels ;\n\tpms->blocksize\t= blockalign ;\n\tpms->samplesperblock = samplesperblock ;\n\n\tif (pms->blocksize <= 0)\n\t{\tpsf_log_printf (psf, \"*** Error : pms->blocksize should be > 0.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpms->dataremaining = psf->datalength ;\n\n\t\tif (psf->datalength % pms->blocksize)\n\t\t\tpms->blocks = psf->datalength / pms->blocksize + 1 ;\n\t\telse\n\t\t\tpms->blocks = psf->datalength / pms->blocksize ;\n\n\t\tcount = 2 * (pms->blocksize - 6 * pms->channels) / pms->channels ;\n\t\tif (pms->samplesperblock != count)\n\t\t{\tpsf_log_printf (psf, \"*** Error : samplesperblock should be %d.\\n\", count) ;\n\t\t\treturn SFE_INTERNAL ;\n\t\t\t} ;\n\n\t\tpsf->sf.frames = (psf->datalength / pms->blocksize) * pms->samplesperblock ;\n\n\t\tmsadpcm_decode_block (psf, pms) ;\n\n\t\tpsf->read_short\t\t= msadpcm_read_s ;\n\t\tpsf->read_int\t\t= msadpcm_read_i ;\n\t\tpsf->read_float\t\t= msadpcm_read_f ;\n\t\tpsf->read_double\t= msadpcm_read_d ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpms->samples = pms->dummydata ;\n\n\t\tpms->samplecount = 0 ;\n\n\t\tpsf->write_short\t= msadpcm_write_s ;\n\t\tpsf->write_int\t\t= msadpcm_write_i ;\n\t\tpsf->write_float\t= msadpcm_write_f ;\n\t\tpsf->write_double\t= msadpcm_write_d ;\n\t\t} ;\n\n\tpsf->codec_close = msadpcm_close ;\n\tpsf->seek = msadpcm_seek ;\n\n\treturn 0 ;\n} /* wavlike_msadpcm_init */\n",
    "target": 1,
    "idx": 1026803,
    "stack_trace": [
      {
        "function_name": "msadpcm_decode_block",
        "function_body": "static int\nmsadpcm_decode_block\t(SF_PRIVATE *psf, MSADPCM_PRIVATE *pms)\n{\tint\t\tchan, k, blockindx, sampleindx ;\n\tshort\tbytecode, bpred [2], chan_idelta [2] ;\n\n\tint predict ;\n\tint current ;\n\tint idelta ;\n\n\tpms->blockcount ++ ;\n\tpms->samplecount = 0 ;\n\n\tif (pms->blockcount > pms->blocks)\n\t{\tmemset (pms->samples, 0, pms->samplesperblock * pms->channels) ;\n\t\treturn 1 ;\n\t\t} ;\n\n\tif ((k = psf_fread (pms->block, 1, pms->blocksize, psf)) != pms->blocksize)\n\t{\tpsf_log_printf (psf, \"*** Warning : short read (%d != %d).\\n\", k, pms->blocksize) ;\n\t\tif (k <= 0)\n\t\t\treturn 1 ;\n\t\t} ;\n\n\t/* Read and check the block header. */\n\n\tif (pms->channels == 1)\n\t{\tbpred [0] = msadpcm_get_bpred (psf, pms, pms->block [0]) ;\n\n\t\tchan_idelta [0] = pms->block [1] | (pms->block [2] << 8) ;\n\t\tchan_idelta [1] = 0 ;\n\n\t\tpms->samples [1] = pms->block [3] | (pms->block [4] << 8) ;\n\t\tpms->samples [0] = pms->block [5] | (pms->block [6] << 8) ;\n\t\tblockindx = 7 ;\n\t\t}\n\telse\n\t{\tbpred [0] = msadpcm_get_bpred (psf, pms, pms->block [0]) ;\n\t\tbpred [1] = msadpcm_get_bpred (psf, pms, pms->block [1]) ;\n\n\t\tchan_idelta [0] = pms->block [2] | (pms->block [3] << 8) ;\n\t\tchan_idelta [1] = pms->block [4] | (pms->block [5] << 8) ;\n\n\t\tpms->samples [2] = pms->block [6] | (pms->block [7] << 8) ;\n\t\tpms->samples [3] = pms->block [8] | (pms->block [9] << 8) ;\n\n\t\tpms->samples [0] = pms->block [10] | (pms->block [11] << 8) ;\n\t\tpms->samples [1] = pms->block [12] | (pms->block [13] << 8) ;\n\n\t\tblockindx = 14 ;\n\t\t} ;\n\n\t/*--------------------------------------------------------\n\tThis was left over from a time when calculations were done\n\tas ints rather than shorts. Keep this around as a reminder\n\tin case I ever find a file which decodes incorrectly.\n\n    if (chan_idelta [0] & 0x8000)\n\t\tchan_idelta [0] -= 0x10000 ;\n    if (chan_idelta [1] & 0x8000)\n\t\tchan_idelta [1] -= 0x10000 ;\n\t--------------------------------------------------------*/\n\n\t/* Pull apart the packed 4 bit samples and store them in their\n\t** correct sample positions.\n\t*/\n\n\tsampleindx = 2 * pms->channels ;\n\twhile (blockindx < pms->blocksize)\n\t{\tbytecode = pms->block [blockindx++] ;\n\t\tpms->samples [sampleindx++] = (bytecode >> 4) & 0x0F ;\n\t\tpms->samples [sampleindx++] = bytecode & 0x0F ;\n\t\t} ;\n\n\t/* Decode the encoded 4 bit samples. */\n\n\tfor (k = 2 * pms->channels ; k < (pms->samplesperblock * pms->channels) ; k ++)\n\t{\tchan = (pms->channels > 1) ? (k % 2) : 0 ;\n\n\t\tbytecode = pms->samples [k] & 0xF ;\n\n\t\t/* Compute next Adaptive Scale Factor (ASF) */\n\t\tidelta = chan_idelta [chan] ;\n\t\tchan_idelta [chan] = (AdaptationTable [bytecode] * idelta) >> 8 ;\t/* => / 256 => FIXED_POINT_ADAPTATION_BASE == 256 */\n\t\tif (chan_idelta [chan] < 16)\n\t\t\tchan_idelta [chan] = 16 ;\n\t\tif (bytecode & 0x8)\n\t\t\tbytecode -= 0x10 ;\n\n\t\tpredict = ((pms->samples [k - pms->channels] * AdaptCoeff1 [bpred [chan]])\n\t\t\t\t\t+ (pms->samples [k - 2 * pms->channels] * AdaptCoeff2 [bpred [chan]])) >> 8 ; /* => / 256 => FIXED_POINT_COEFF_BASE == 256 */\n\t\tcurrent = (bytecode * idelta) + predict ;\n\n\t\tif (current > 32767)\n\t\t\tcurrent = 32767 ;\n\t\telse if (current < -32768)\n\t\t\tcurrent = -32768 ;\n\n\t\tpms->samples [k] = current ;\n\t\t} ;\n\n\treturn 0 ;\n} /* msadpcm_decode_block */",
        "file_path": "/src/libsndfile/src/ms_adpcm.c",
        "crashing_line": "\t** correct sample positions.",
        "crashing_line_number": 279
      },
      {
        "function_name": "wavlike_msadpcm_init",
        "function_body": "int\nwavlike_msadpcm_init\t(SF_PRIVATE *psf, int blockalign, int samplesperblock)\n{\tMSADPCM_PRIVATE\t*pms ;\n\tunsigned int\tpmssize ;\n\tint\t\t\t\tcount ;\n\n\tif (psf->codec_data != NULL)\n\t{\tpsf_log_printf (psf, \"*** psf->codec_data is not NULL.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t\tsamplesperblock = 2 + 2 * (blockalign - 7 * psf->sf.channels) / psf->sf.channels ;\n\n\t/* There's 7 samples per channel in the preamble of each block */\n\tif (samplesperblock < 7 * psf->sf.channels)\n\t{\tpsf_log_printf (psf, \"*** Error samplesperblock (%d) should be >= %d.\\n\", samplesperblock, 7 * psf->sf.channels) ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (2 * blockalign < samplesperblock * psf->sf.channels)\n\t{\tpsf_log_printf (psf, \"*** Error blockalign (%d) should be >= %d.\\n\", blockalign, samplesperblock * psf->sf.channels / 2) ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tpmssize = sizeof (MSADPCM_PRIVATE) + blockalign + 3 * psf->sf.channels * samplesperblock ;\n\n\tif (! (psf->codec_data = calloc (1, pmssize)))\n\t\treturn SFE_MALLOC_FAILED ;\n\tpms = (MSADPCM_PRIVATE*) psf->codec_data ;\n\n\tpms->sync_error = 0 ;\n\tpms->samples\t= pms->dummydata ;\n\tpms->block\t\t= (unsigned char*) (pms->dummydata + psf->sf.channels * samplesperblock) ;\n\n\tpms->channels\t= psf->sf.channels ;\n\tpms->blocksize\t= blockalign ;\n\tpms->samplesperblock = samplesperblock ;\n\n\tif (pms->blocksize <= 0)\n\t{\tpsf_log_printf (psf, \"*** Error : pms->blocksize should be > 0.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpms->dataremaining = psf->datalength ;\n\n\t\tif (psf->datalength % pms->blocksize)\n\t\t\tpms->blocks = psf->datalength / pms->blocksize + 1 ;\n\t\telse\n\t\t\tpms->blocks = psf->datalength / pms->blocksize ;\n\n\t\tcount = 2 * (pms->blocksize - 6 * pms->channels) / pms->channels ;\n\t\tif (pms->samplesperblock != count)\n\t\t{\tpsf_log_printf (psf, \"*** Error : samplesperblock should be %d.\\n\", count) ;\n\t\t\treturn SFE_INTERNAL ;\n\t\t\t} ;\n\n\t\tpsf->sf.frames = (psf->datalength / pms->blocksize) * pms->samplesperblock ;\n\n\t\tmsadpcm_decode_block (psf, pms) ;\n\n\t\tpsf->read_short\t\t= msadpcm_read_s ;\n\t\tpsf->read_int\t\t= msadpcm_read_i ;\n\t\tpsf->read_float\t\t= msadpcm_read_f ;\n\t\tpsf->read_double\t= msadpcm_read_d ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpms->samples = pms->dummydata ;\n\n\t\tpms->samplecount = 0 ;\n\n\t\tpsf->write_short\t= msadpcm_write_s ;\n\t\tpsf->write_int\t\t= msadpcm_write_i ;\n\t\tpsf->write_float\t= msadpcm_write_f ;\n\t\tpsf->write_double\t= msadpcm_write_d ;\n\t\t} ;\n\n\tpsf->codec_close = msadpcm_close ;\n\tpsf->seek = msadpcm_seek ;\n\n\treturn 0 ;\n} /* wavlike_msadpcm_init */",
        "file_path": "/src/libsndfile/src/ms_adpcm.c",
        "crashing_line": "\t\t{\tpsf_log_printf (psf, \"*** Error : samplesperblock should be %d.\\n\", count) ;",
        "crashing_line_number": 171
      },
      {
        "function_name": "wav_open",
        "function_body": "int\nwav_open\t(SF_PRIVATE *psf)\n{\tWAVLIKE_PRIVATE * wpriv ;\n\tint\tformat, subformat, error, blockalign = 0, framesperblock = 0 ;\n\n\tif ((wpriv = calloc (1, sizeof (WAVLIKE_PRIVATE))) == NULL)\n\t\treturn SFE_MALLOC_FAILED ;\n\tpsf->container_data = wpriv ;\n\n\twpriv->wavex_ambisonic = SF_AMBISONIC_NONE ;\n\tpsf->strings.flags = SF_STR_ALLOW_START | SF_STR_ALLOW_END ;\n\n\tif (psf->file.mode == SFM_READ || (psf->file.mode == SFM_RDWR && psf->filelength > 0))\n\t{\tif ((error = wav_read_header (psf, &blockalign, &framesperblock)))\n\t\t\treturn error ;\n\n\t\tpsf->next_chunk_iterator = wav_next_chunk_iterator ;\n\t\tpsf->get_chunk_size = wav_get_chunk_size ;\n\t\tpsf->get_chunk_data = wav_get_chunk_data ;\n\t\t} ;\n\n\tsubformat = SF_CODEC (psf->sf.format) ;\n\n\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t{\tif (psf->is_pipe)\n\t\t\treturn SFE_NO_PIPE_WRITE ;\n\n\t\twpriv->wavex_ambisonic = SF_AMBISONIC_NONE ;\n\n\t\tformat = SF_CONTAINER (psf->sf.format) ;\n\t\tif (format != SF_FORMAT_WAV && format != SF_FORMAT_WAVEX)\n\t\t\treturn\tSFE_BAD_OPEN_FORMAT ;\n\n\t\tpsf->blockwidth = psf->bytewidth * psf->sf.channels ;\n\n\t\t/* RIFF WAVs are little-endian, RIFX WAVs are big-endian, default to little */\n\t\tpsf->endian = SF_ENDIAN (psf->sf.format) ;\n\t\tif (CPU_IS_BIG_ENDIAN && psf->endian == SF_ENDIAN_CPU)\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\telse if (psf->endian != SF_ENDIAN_BIG)\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\n\t\tif (psf->file.mode != SFM_RDWR || psf->filelength < 44)\n\t\t{\tpsf->filelength = 0 ;\n\t\t\tpsf->datalength = 0 ;\n\t\t\tpsf->dataoffset = 0 ;\n\t\t\tpsf->sf.frames = 0 ;\n\t\t\t} ;\n\n\t\tif (subformat == SF_FORMAT_IMA_ADPCM || subformat == SF_FORMAT_MS_ADPCM)\n\t\t{\tblockalign = wavlike_srate2blocksize (psf->sf.samplerate * psf->sf.channels) ;\n\t\t\tframesperblock = -1 ; /* Corrected later. */\n\t\t\t} ;\n\n\t\t/* By default, add the peak chunk to floating point files. Default behaviour\n\t\t** can be switched off using sf_command (SFC_SET_PEAK_CHUNK, SF_FALSE).\n\t\t*/\n\t\tif (psf->file.mode == SFM_WRITE && (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE))\n\t\t{\tif ((psf->peak_info = peak_info_calloc (psf->sf.channels)) == NULL)\n\t\t\t\treturn SFE_MALLOC_FAILED ;\n\t\t\tpsf->peak_info->peak_loc = SF_PEAK_START ;\n\t\t\t} ;\n\n\t\tpsf->write_header\t= wav_write_header ;\n\t\tpsf->set_chunk\t\t= wav_set_chunk ;\n\t\t} ;\n\n\tpsf->container_close = wav_close ;\n\tpsf->command = wav_command ;\n\n\tswitch (subformat)\n\t{\tcase SF_FORMAT_PCM_U8 :\n\t\tcase SF_FORMAT_PCM_16 :\n\t\tcase SF_FORMAT_PCM_24 :\n\t\tcase SF_FORMAT_PCM_32 :\n\t\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ULAW :\n\t\t\t\t\terror = ulaw_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ALAW :\n\t\t\t\t\terror = alaw_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\t/* Lite remove start */\n\t\tcase SF_FORMAT_FLOAT :\n\t\t\t\t\terror = float32_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DOUBLE :\n\t\t\t\t\terror = double64_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_IMA_ADPCM :\n\t\t\t\t\terror = wavlike_ima_init (psf, blockalign, framesperblock) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_MS_ADPCM :\n\t\t\t\t\terror = wavlike_msadpcm_init (psf, blockalign, framesperblock) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_G721_32 :\n\t\t\t\t\terror = g72x_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_NMS_ADPCM_16 :\n\t\tcase SF_FORMAT_NMS_ADPCM_24 :\n\t\tcase SF_FORMAT_NMS_ADPCM_32 :\n\t\t\t\t\terror = nms_adpcm_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\t/* Lite remove end */\n\n\t\tcase SF_FORMAT_GSM610 :\n\t\t\t\t\terror = gsm610_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tdefault : \treturn SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE || (psf->file.mode == SFM_RDWR && psf->filelength == 0))\n\t\treturn psf->write_header (psf, SF_FALSE) ;\n\n\treturn error ;\n} /* wav_open */",
        "file_path": "/src/libsndfile/src/wav.c",
        "crashing_line": "\t\t\t\t\terror = wavlike_msadpcm_init (psf, blockalign, framesperblock) ;",
        "crashing_line_number": 258
      },
      {
        "function_name": "psf_open_file",
        "function_body": "",
        "file_path": "/src/libsndfile/src/sndfile.c",
        "crashing_line": "",
        "crashing_line_number": 3128
      },
      {
        "function_name": "sf_open_virtual",
        "function_body": "",
        "file_path": "/src/libsndfile/src/sndfile.c",
        "crashing_line": "",
        "crashing_line_number": 515
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "TEST(special_cases_utf8_utf16_roundtrip) {\n  std::string cases[] = {\n    \"\\x05\\x0A\\x0A\\x01\\x0C\\x00\\x00\\x0A\\x0C\\x00\\x00\\x00\\x00\\x00\\x0A\\x0A\\x0A\\xF0\"\n    \"\\x93\\x93\\x93\\x01\\x00\\x00\\x00\\xE2\\xBB\\x9A\\xEF\\x9B\\xBB\\xEE\\x81\\x81\\x05\\x2D\"\n    \"\\x01\\x7B\\x00\\x00\\xE2\\xBB\\x9A\\xEF\\x9B\\xBB\\xEE\\x81\\x81\\x05\\x2D\\x01\\x7B\\x00\"\n    \"\\x00\\x00\\x00\\x0A\\x00\\x2A\\x0A\\x7E\\x0A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n    \"\\x20\\x20\\xEF\\xBB\\x8A\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\"\n    \"\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\"\n  };\n  for (std::string source : cases) {\n    bool validutf8 = simdutf::validate_utf8(source.c_str(), source.size());\n    if (!validutf8) {\n      continue;\n    } // we allow it.\n      // We need a buffer of size where to write the UTF-16LE words.\n    std::cout << \"it is valid!\" << std::endl;\n\n    size_t expected_utf16words =\n        simdutf::utf16_length_from_utf8(source.c_str(), source.size());\n    std::cout << \"I am going to need \" << expected_utf16words << \" words\"\n              << std::endl;\n\n    std::unique_ptr<char16_t[]> utf16_output{\n      new char16_t[expected_utf16words]\n    };\n    // convert to UTF-16LE\n    size_t utf16words = simdutf::convert_utf8_to_utf16le(\n        source.c_str(), source.size(), utf16_output.get());\n    // It wrote utf16words * sizeof(char16_t) bytes.\n    bool validutf16 = simdutf::validate_utf16le(utf16_output.get(), utf16words);\n    ASSERT_TRUE(validutf16);\n    // convert it back:\n    // We need a buffer of size where to write the UTF-8 words.\n    size_t expected_utf8words =\n        simdutf::utf8_length_from_utf16le(utf16_output.get(), utf16words);\n    ASSERT_TRUE(expected_utf8words == source.size());\n    std::unique_ptr<char[]> utf8_output{ new char[expected_utf8words] };\n    // convert to UTF-8\n    size_t utf8words = simdutf::convert_utf16le_to_utf8(\n        utf16_output.get(), utf16words, utf8_output.get());\n    ASSERT_TRUE(expected_utf8words == utf8words);\n    std::string final_string(utf8_output.get(), utf8words);\n    ASSERT_TRUE(final_string == source);\n  }\n}\nint main(int argc, char *argv[]) { return simdutf::test::main(argc, argv); }\n",
    "target": 1,
    "idx": 1057632,
    "stack_trace": []
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "int cil_resolve_classcommon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_class *class = NULL;\n\tstruct cil_class *common = NULL;\n\tstruct cil_classcommon *clscom = current->data;\n\tstruct cil_symtab_datum *class_datum = NULL;\n\tstruct cil_symtab_datum *common_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, clscom->class_str, CIL_SYM_CLASSES, extra_args, &class_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_name(current, clscom->common_str, CIL_SYM_COMMONS, extra_args, &common_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tclass = (struct cil_class *)class_datum;\n\tcommon = (struct cil_class *)common_datum;\n\tif (class->common != NULL) {\n\t\tcil_log(CIL_ERR, \"class cannot be associeated with more than one common\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tclass->common = common;\n\n\tcil_symtab_map(&class->perms, __class_update_perm_values, &common->num_perms);\n\n\tclass->num_perms += common->num_perms;\n\tif (class->num_perms > CIL_PERMS_PER_CLASS) {\n\t\tcil_tree_log(current, CIL_ERR, \"Too many permissions in class '%s' when including common permissions\", class->datum.name);\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\nint cil_resolve_classorder(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *classorder_list = args->classorder_lists;\n\tstruct cil_list *unordered_classorder_list = args->unordered_classorder_lists;\n\tstruct cil_classorder *classorder = current->data;\n\tstruct cil_list *new = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_symtab_datum *datum = NULL;\n\tstruct cil_ordered_list *class_list = NULL;\n\tint rc = SEPOL_ERR;\n\tint unordered = CIL_FALSE;\n\n\tcil_list_init(&new, CIL_CLASSORDER);\n\n\tcil_list_for_each(curr, classorder->class_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tunordered = CIL_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_CLASSES, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to resolve class %s in classorder\\n\", (char *)curr->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(new, CIL_CLASS, datum);\n\t}\n\n\t__cil_ordered_list_init(&class_list);\n\tclass_list->list = new;\n\tclass_list->node = current;\n\tif (unordered) {\n\t\tcil_list_append(unordered_classorder_list, CIL_CLASSORDER, class_list);\n\t} else {\n\t\tcil_list_append(classorder_list, CIL_CLASSORDER, class_list);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(&new, CIL_FALSE);\n\treturn rc;\n}\nint cil_resolve_blockabstract(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_blockabstract *abstract = current->data;\n\tstruct cil_symtab_datum *block_datum = NULL;\n\tstruct cil_tree_node *block_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, abstract->block_str, CIL_SYM_BLOCKS, extra_args, &block_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tblock_node = NODE(block_datum);\n\tif (block_node->flavor != CIL_BLOCK) {\n\t\tcil_log(CIL_ERR, \"Failed to resolve blockabstract to a block, rc: %d\\n\", rc);\n\t\tgoto exit;\n\t}\n\n\t((struct cil_block*)block_datum)->is_abstract = CIL_TRUE;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 1,
    "idx": 1029451,
    "stack_trace": [
      {
        "function_name": "cil_classorder_to_policydb",
        "function_body": "int cil_classorder_to_policydb(policydb_t *pdb, const struct cil_db *db, struct cil_class *class_value_to_cil[], struct cil_perm **perm_value_to_cil[])\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_list_item *curr_class;\n\n\tcil_list_for_each(curr_class, db->classorder) {\n\t\tstruct cil_class *cil_class = curr_class->data;\n\t\tuint32_t value = 0;\n\t\tchar *key = NULL;\n\t\tint class_index;\n\t\tstruct cil_tree_node *curr;\n\t\tcommon_datum_t *sepol_common = NULL;\n\t\tclass_datum_t *sepol_class = cil_malloc(sizeof(*sepol_class));\n\t\tmemset(sepol_class, 0, sizeof(class_datum_t));\n\n\t\tkey = cil_strdup(cil_class->datum.fqn);\n\t\trc = symtab_insert(pdb, SYM_CLASSES, key, sepol_class, SCOPE_DECL, 0, &value);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tfree(sepol_class);\n\t\t\tfree(key);\n\t\t\tgoto exit;\n\t\t}\n\t\tsepol_class->s.value = value;\n\t\tclass_index = value;\n\t\tclass_value_to_cil[class_index] = cil_class;\n\n\t\trc = symtab_init(&sepol_class->permissions, PERM_SYMTAB_SIZE);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (cil_class->common != NULL) {\n\t\t\tint i;\n\t\t\tstruct cil_class *cil_common = cil_class->common;\n\n\t\t\tkey = cil_class->common->datum.fqn;\n\t\t\tsepol_common = hashtab_search(pdb->p_commons.table, key);\n\t\t\tif (sepol_common == NULL) {\n\t\t\t\trc = cil_common_to_policydb(pdb, cil_common, &sepol_common);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsepol_class->comdatum = sepol_common;\n\t\t\tsepol_class->comkey = cil_strdup(key);\n\t\t\tsepol_class->permissions.nprim += sepol_common->permissions.nprim;\n\n\t\t\tfor (curr = NODE(cil_class->common)->cl_head, i = 1; curr; curr = curr->next, i++) {\n\t\t\t\tstruct cil_perm *cil_perm = curr->data;\n\t\t\t\tperm_value_to_cil[class_index][i] = cil_perm;\n\t\t\t}\n\t\t}\n\n\t\tfor (curr = NODE(cil_class)->cl_head; curr; curr = curr->next) {\n\t\t\tstruct cil_perm *cil_perm = curr->data;\n\t\t\tperm_datum_t *sepol_perm = cil_malloc(sizeof(*sepol_perm));\n\t\t\tmemset(sepol_perm, 0, sizeof(perm_datum_t));\n\n\t\t\tkey = cil_strdup(cil_perm->datum.fqn);\n\t\t\trc = hashtab_insert(sepol_class->permissions.table, key, sepol_perm);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tfree(sepol_perm);\n\t\t\t\tfree(key);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsepol_perm->s.value = sepol_class->permissions.nprim + 1;\n\t\t\tsepol_class->permissions.nprim++;\n\t\t\tperm_value_to_cil[class_index][sepol_perm->s.value] = cil_perm;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_binary.c",
        "crashing_line": "\t\t\tperm_value_to_cil[class_index][sepol_perm->s.value] = cil_perm;",
        "crashing_line_number": 357
      },
      {
        "function_name": "__cil_policydb_init",
        "function_body": "int __cil_policydb_init(policydb_t *pdb, const struct cil_db *db, struct cil_class *class_value_to_cil[], struct cil_perm **perm_value_to_cil[])\n{\n\tint rc = SEPOL_ERR;\n\n\t// these flags should get set in __cil_policydb_create. However, for\n\t// backwards compatibility, it is possible that __cil_policydb_create is\n\t// never called. So, they must also be set here.\n\tpdb->handle_unknown = db->handle_unknown;\n\tpdb->mls = db->mls;\n\n\trc = cil_classorder_to_policydb(pdb, db, class_value_to_cil, perm_value_to_cil);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (pdb->mls == CIL_TRUE) {\n\t\trc = cil_catorder_to_policydb(pdb, db);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\trc = cil_sensitivityorder_to_policydb(pdb, db);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\trc = avtab_alloc(&pdb->te_avtab, MAX_AVTAB_SIZE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = avtab_alloc(&pdb->te_cond_avtab, MAX_AVTAB_SIZE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_binary.c",
        "crashing_line": "\trc = cil_classorder_to_policydb(pdb, db, class_value_to_cil, perm_value_to_cil);",
        "crashing_line_number": 4212
      },
      {
        "function_name": "cil_binary_create_allocated_pdb",
        "function_body": "int cil_binary_create_allocated_pdb(const struct cil_db *db, sepol_policydb_t *policydb)\n{\n\tint rc = SEPOL_ERR;\n\tint i;\n\tstruct cil_args_binary extra_args;\n\tpolicydb_t *pdb = &policydb->p;\n\tstruct cil_list *neverallows = NULL;\n\thashtab_t role_trans_table = NULL;\n\thashtab_t avrulex_ioctl_table = NULL;\n\tvoid **type_value_to_cil = NULL;\n\tstruct cil_class **class_value_to_cil = NULL;\n\tstruct cil_perm ***perm_value_to_cil = NULL;\n\n\tif (db == NULL || policydb == NULL) {\n\t\tif (db == NULL) {\n\t\t\tcil_log(CIL_ERR,\"db == NULL\\n\");\n\t\t} else if (policydb == NULL) {\n\t\t\tcil_log(CIL_ERR,\"policydb == NULL\\n\");\n\t\t}\n\t\treturn SEPOL_ERR;\n\t}\n\n\t/* libsepol values start at 1. Just allocate extra memory rather than\n\t * subtract 1 from the sepol value.\n\t */\n\ttype_value_to_cil = calloc(db->num_types_and_attrs+1, sizeof(*type_value_to_cil));\n\tif (!type_value_to_cil) goto exit;\n\n\tclass_value_to_cil = calloc(db->num_classes+1, sizeof(*class_value_to_cil));\n\tif (!class_value_to_cil) goto exit;\n\n\tperm_value_to_cil = calloc(db->num_classes+1, sizeof(*perm_value_to_cil));\n\tif (!perm_value_to_cil) goto exit;\n\tfor (i=1; i < db->num_classes+1; i++) {\n\t\tperm_value_to_cil[i] = calloc(PERMS_PER_CLASS+1, sizeof(*perm_value_to_cil[i]));\n\t\tif (!perm_value_to_cil[i]) goto exit;\n\t}\n\n\trc = __cil_policydb_init(pdb, db, class_value_to_cil, perm_value_to_cil);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR,\"Problem in policydb_init\\n\");\n\t\tgoto exit;\n\t}\n\n\trole_trans_table = hashtab_create(role_trans_hash, role_trans_compare, ROLE_TRANS_TABLE_SIZE);\n\tif (!role_trans_table) {\n\t\tcil_log(CIL_INFO, \"Failure to create hashtab for role_trans\\n\");\n\t\tgoto exit;\n\t}\n\n\tavrulex_ioctl_table = hashtab_create(avrulex_hash, avrulex_compare, AVRULEX_TABLE_SIZE);\n\tif (!avrulex_ioctl_table) {\n\t\tcil_log(CIL_INFO, \"Failure to create hashtab for avrulex\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_list_init(&neverallows, CIL_LIST_ITEM);\n\n\textra_args.db = db;\n\textra_args.pdb = pdb;\n\textra_args.neverallows = neverallows;\n\textra_args.role_trans_table = role_trans_table;\n\textra_args.avrulex_ioctl_table = avrulex_ioctl_table;\n\textra_args.type_value_to_cil = type_value_to_cil;\n\n\tfor (i = 1; i <= 3; i++) {\n\t\textra_args.pass = i;\n\n\t\trc = cil_tree_walk(db->ast->root, __cil_binary_create_helper, NULL, NULL, &extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_INFO, \"Failure while walking cil database\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (i == 1) {\n\t\t\trc = __cil_policydb_val_arrays_create(pdb);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_INFO, \"Failure creating val_to_{struct,name} arrays\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif (i == 3) {\n\t\t\trc = hashtab_map(avrulex_ioctl_table, __cil_avrulex_ioctl_to_policydb, pdb);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_INFO, \"Failure creating avrulex rules\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = cil_sidorder_to_policydb(pdb, db);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_contexts_to_policydb(pdb, db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failure while inserting cil contexts into sepol policydb\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (pdb->type_attr_map == NULL) {\n\t\trc = __cil_typeattr_bitmap_init(pdb);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_INFO, \"Failure while initializing typeattribute bitmap\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tcond_optimize_lists(pdb->cond_list);\n\t__cil_set_conditional_state_and_flags(pdb);\n\n\tif (db->disable_neverallow != CIL_TRUE) {\n\t\tint violation = CIL_FALSE;\n\t\tcil_log(CIL_INFO, \"Checking Neverallows\\n\");\n\t\trc = cil_check_neverallows(db, pdb, neverallows, &violation);\n\t\tif (rc != SEPOL_OK) goto exit;\n\n\t\tcil_log(CIL_INFO, \"Checking User Bounds\\n\");\n\t\trc = bounds_check_users(NULL, pdb);\n\t\tif (rc) {\n\t\t\tviolation = CIL_TRUE;\n\t\t}\n\n\t\tcil_log(CIL_INFO, \"Checking Role Bounds\\n\");\n\t\trc = bounds_check_roles(NULL, pdb);\n\t\tif (rc) {\n\t\t\tviolation = CIL_TRUE;\n\t\t}\n\n\t\tcil_log(CIL_INFO, \"Checking Type Bounds\\n\");\n\t\trc = cil_check_type_bounds(db, pdb, type_value_to_cil, class_value_to_cil, perm_value_to_cil, &violation);\n\t\tif (rc != SEPOL_OK) goto exit;\n\n\t\tif (violation == CIL_TRUE) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t}\n\n\t/* This pre-expands the roles and users for context validity checking */\n\tif (hashtab_map(pdb->p_roles.table, policydb_role_cache, pdb)) {\n\t\tcil_log(CIL_INFO, \"Failure creating roles cache\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n    }\n\n\tif (hashtab_map(pdb->p_users.table, policydb_user_cache, pdb)) {\n\t\tcil_log(CIL_INFO, \"Failure creating users cache\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = SEPOL_OK;\n\nexit:\n\thashtab_destroy(role_trans_table);\n\thashtab_map(avrulex_ioctl_table, __cil_avrulex_ioctl_destroy, NULL);\n\thashtab_destroy(avrulex_ioctl_table);\n\tfree(type_value_to_cil);\n\tfree(class_value_to_cil);\n\tif (perm_value_to_cil != NULL) {\n\t\t/* Range is because libsepol values start at 1. */\n\t\tfor (i=1; i < db->num_classes+1; i++) {\n\t\t\tfree(perm_value_to_cil[i]);\n\t\t}\n\t\tfree(perm_value_to_cil);\n\t}\n\tcil_list_destroy(&neverallows, CIL_FALSE);\n\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_binary.c",
        "crashing_line": "\trc = __cil_policydb_init(pdb, db, class_value_to_cil, perm_value_to_cil);",
        "crashing_line_number": 4920
      },
      {
        "function_name": "cil_binary_create",
        "function_body": "int cil_binary_create(const struct cil_db *db, sepol_policydb_t **policydb)\n{\n\tint rc = SEPOL_ERR;\n\tstruct sepol_policydb *pdb = NULL;\n\n\trc = __cil_policydb_create(db, &pdb);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_binary_create_allocated_pdb(db, pdb);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\t*policydb = pdb;\n\n\treturn SEPOL_OK;\n\nexit:\n\tsepol_policydb_free(pdb);\n\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil_binary.c",
        "crashing_line": "\trc = cil_binary_create_allocated_pdb(db, pdb);",
        "crashing_line_number": 4325
      },
      {
        "function_name": "cil_build_policydb",
        "function_body": "int cil_build_policydb(cil_db_t *db, sepol_policydb_t **sepol_db)\n{\n\tint rc;\n\n\tcil_log(CIL_INFO, \"Building policy binary\\n\");\n\trc = cil_binary_create(db, sepol_db);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to generate binary\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n}",
        "file_path": "/src/selinux/libsepol/src/../cil/src/cil.c",
        "crashing_line": "\trc = cil_binary_create(db, sepol_db);",
        "crashing_line_number": 672
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\ndecode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,\n                       Dwg_Data *restrict dwg)\n{\n  Dwg_Section *tbl = &dwg->header.section[id];\n  Bit_Chain *hdl_dat = dat;\n  int i;\n  BITCODE_BL vcount;\n  int error = 0;\n  long unsigned int num = dwg->num_objects;\n  long unsigned int pos = tbl->address;\n  BITCODE_RC flag;\n  BITCODE_TF name;\n\n  LOG_TRACE (\"contents table %-8s [%2d]: size:%-4u num:%-3ld (0x%lx-0x%lx)\\n\",\n             tbl->name, id, tbl->size, (long)tbl->number, (unsigned long)tbl->address,\n             (unsigned long)(tbl->address + ((unsigned long long)tbl->number * tbl->size)))\n  dat->byte = tbl->address;\n  dat->bit = 0;\n  if ((unsigned long)(tbl->number * tbl->size) > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"Overlarge table num_entries %ld or size %ld for %-8s [%2d]\",\n                 (long)tbl->number, (long)tbl->size, tbl->name, id);\n      return DWG_ERR_INVALIDDWG;\n    }\n  tbl->objid_r11 = num;\n  if (dwg->num_alloced_objects < dwg->num_objects + tbl->number)\n    {\n      dwg->num_alloced_objects = dwg->num_objects + tbl->number;\n      dwg->object = (Dwg_Object*)realloc (dwg->object,\n          dwg->num_alloced_objects * sizeof (Dwg_Object));\n      dwg->dirty_refs = 1;\n    }\n\n  // TODO: use the dwg.spec instead\n  // MAYBE: move to a spec dwg_r11.spec, and dwg_decode_r11_NAME\n#define PREP_TABLE(token)                                                     \\\n  Dwg_Object *obj;                                                            \\\n  Dwg_Object_##token *_obj;                                                   \\\n  Dwg_Object *ctrl = dwg_get_first_object (dwg, DWG_TYPE_##token##_CONTROL);  \\\n  Dwg_Object_##token##_CONTROL *_ctrl                                         \\\n      = ctrl->tio.object->tio.token##_CONTROL;                                \\\n  if (dat->byte > dat->size || (num + i) > dwg->num_objects)                  \\\n    return DWG_ERR_INVALIDDWG;                                                \\\n  flag = bit_read_RC (dat);                                                   \\\n  name = bit_read_TF (dat, 32);                                               \\\n  _obj = dwg_add_##token (dwg, (const char *)name);                           \\\n  obj = dwg_obj_generic_to_object (_obj, &error);                             \\\n  _ctrl->entries[i] = dwg_add_handleref (dwg, 2, obj->handle.value, obj);     \\\n  obj->size = tbl->size;                                                      \\\n  obj->address = pos;                                                         \\\n  _obj->flag = flag;                                                          \\\n  LOG_TRACE (\"\\n-- table entry \" #token \" [%d]: 0x%lx\\n\", i, pos);            \\\n  LOG_TRACE (\"flag: %u [RC 70]\\n\", flag);                                     \\\n  LOG_TRACE (\"name: \\\"%s\\\" [TF 32 2]\\n\", name);                               \\\n  free (name)\n\n#define CHK_ENDPOS                                                            \\\n  SINCE (R_11) {                                                              \\\n    BITCODE_RS crc16 = bit_read_RS (dat);                                     \\\n    LOG_TRACE (\"crc16: %04X\\n\", crc16);                                       \\\n  }                                                                           \\\n  pos = tbl->address + (long)((i + 1) * tbl->size);                           \\\n  if (pos != dat->byte)                                                       \\\n    {                                                                         \\\n      LOG_ERROR (\"offset %ld\", pos - dat->byte);                              \\\n      /*return DWG_ERR_SECTIONNOTFOUND;*/                                     \\\n    }                                                                         \\\n",
    "target": 1,
    "idx": 1054839,
    "stack_trace": [
      {
        "function_name": "decode_preR13_section",
        "function_body": "static int\ndecode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,\n                       Dwg_Data *restrict dwg)\n{\n  Dwg_Section *tbl = &dwg->header.section[id];\n  Bit_Chain *hdl_dat = dat;\n  int i;\n  BITCODE_BL vcount;\n  int error = 0;\n  long unsigned int num = dwg->num_objects;\n  long unsigned int pos = tbl->address;\n  BITCODE_RC flag;\n  BITCODE_TF name;\n\n  LOG_TRACE (\"contents table %-8s [%2d]: size:%-4u num:%-3ld (0x%lx-0x%lx)\\n\",\n             tbl->name, id, tbl->size, (long)tbl->number, (unsigned long)tbl->address,\n             (unsigned long)(tbl->address + ((unsigned long long)tbl->number * tbl->size)))\n  dat->byte = tbl->address;\n  dat->bit = 0;\n  if ((unsigned long)(tbl->number * tbl->size) > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"Overlarge table num_entries %ld or size %ld for %-8s [%2d]\",\n                 (long)tbl->number, (long)tbl->size, tbl->name, id);\n      return DWG_ERR_INVALIDDWG;\n    }\n  tbl->objid_r11 = num;\n  if (dwg->num_alloced_objects < dwg->num_objects + tbl->number)\n    {\n      dwg->num_alloced_objects = dwg->num_objects + tbl->number;\n      dwg->object = (Dwg_Object*)realloc (dwg->object,\n          dwg->num_alloced_objects * sizeof (Dwg_Object));\n      dwg->dirty_refs = 1;\n    }\n\n  // TODO: use the dwg.spec instead\n  // MAYBE: move to a spec dwg_r11.spec, and dwg_decode_r11_NAME\n#define PREP_TABLE(token)                                                     \\\n  Dwg_Object *obj;                                                            \\\n  Dwg_Object_##token *_obj;                                                   \\\n  Dwg_Object *ctrl = dwg_get_first_object (dwg, DWG_TYPE_##token##_CONTROL);  \\\n  Dwg_Object_##token##_CONTROL *_ctrl                                         \\\n    = ctrl ? ctrl->tio.object->tio.token##_CONTROL : NULL;                    \\\n  if (!ctrl || dat->byte > dat->size || (num + i) > dwg->num_objects)         \\\n    return DWG_ERR_INVALIDDWG;                                                \\\n  flag = bit_read_RC (dat);                                                   \\\n  name = bit_read_TF (dat, 32);                                               \\\n  _obj = dwg_add_##token (dwg, (const char *)name);                           \\\n  obj = dwg_obj_generic_to_object (_obj, &error);                             \\\n  _ctrl->entries[i] = dwg_add_handleref (dwg, 2, obj->handle.value, obj);     \\\n  obj->size = tbl->size;                                                      \\\n  obj->address = pos;                                                         \\\n  _obj->flag = flag;                                                          \\\n  LOG_TRACE (\"\\n-- table entry \" #token \" [%d]: 0x%lx\\n\", i, pos);            \\\n  LOG_TRACE (\"flag: %u [RC 70]\\n\", flag);                                     \\\n  LOG_TRACE (\"name: \\\"%s\\\" [TF 32 2]\\n\", name);                               \\\n  free (name)\n\n#define CHK_ENDPOS                                                            \\\n  SINCE (R_11) {                                                              \\\n    BITCODE_RS crc16 = bit_read_RS (dat);                                     \\\n    LOG_TRACE (\"crc16: %04X\\n\", crc16);                                       \\\n  }                                                                           \\\n  pos = tbl->address + (long)((i + 1) * tbl->size);                           \\\n  if (pos != dat->byte)                                                       \\\n    {                                                                         \\\n      LOG_ERROR (\"offset %ld\", pos - dat->byte);                              \\\n      /*return DWG_ERR_SECTIONNOTFOUND;*/                                     \\\n    }                                                                         \\",
        "file_path": "/src/libredwg/src/decode_r11.c",
        "crashing_line": "",
        "crashing_line_number": 468
      },
      {
        "function_name": "decode_preR13",
        "function_body": "EXPORT int\ndecode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_RL entities_start = 0, entities_end = 0;\n  BITCODE_RL blocks_start = 0, blocks_size = 0, blocks_end = 0;\n  BITCODE_RL rl1, rl2, blocks_max = 0xFFFFFFFF, num_entities;\n  BITCODE_RS rs2;\n  Dwg_Object *obj = NULL;\n  int tbl_id;\n  int error = 0;\n  int num_sections = 5;\n\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n#ifndef USE_WRITE\n  fprintf(stderr, \"Cannot create pre-R13 documents with --disable-write\\n\");\n  return DWG_ERR_INTERNALERROR;\n#else\n  {\n    int i;\n    Dwg_Header *_obj = (Dwg_Header *)&dwg->header;\n    Bit_Chain *hdl_dat = dat;\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x14\n\n  // setup all the new control objects\n  error |= dwg_add_Document (dwg, 0);\n\n  // 5 tables + header + block. VIEW = 6\n  if (dwg->header.numheader_vars > 158) // r10\n    num_sections += 3;\n  if (dwg->header.numheader_vars > 160) // r11\n    num_sections += 2;\n  dwg->header.section = (Dwg_Section *)calloc (sizeof (Dwg_Section),\n                                               num_sections + 2);\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  dwg->header.numsections = num_sections;\n  PRE (R_2_0b) {\n    bit_read_RC (dat); // the 6th zero\n    LOG_TRACE (\"zero[6]: 0 [RC 0]\\n\");\n  }\n  SINCE (R_2_0b) {\n    entities_start = bit_read_RL (dat);\n    LOG_TRACE (\"entities_start: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", entities_start, entities_start);\n    entities_end = bit_read_RL (dat);\n    LOG_TRACE (\"entities_end: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", entities_end, entities_end);\n    blocks_start = bit_read_RL (dat);\n    LOG_TRACE (\"blocks_start: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", blocks_start, blocks_start);\n    blocks_size = bit_read_RL (dat);\n    if (blocks_size >= 0x40000000) {\n      LOG_TRACE (\"blocks_size: 0x40000000 | \" FORMAT_RL \" [RLx]\\n\", blocks_size & 0x3fffffff);\n    }\n    else {\n      LOG_TRACE (\"blocks_size: \" FORMAT_RL \" [RL]\\n\", blocks_size);\n    }\n    blocks_end = bit_read_RL (dat);\n    LOG_TRACE (\"blocks_end: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", blocks_end, blocks_end);\n    blocks_max = bit_read_RL (dat); // 0x80000000\n    LOG_TRACE (\"blocks_max: \" FORMAT_RLx \" [RLx]\\n\", blocks_max);\n    tbl_id = 0;\n    dwg->header.section[0].number = 0;\n    dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;\n    strcpy (dwg->header.section[0].name, \"HEADER\");\n\n    // The 5 tables (num_sections always 5): 3 RS + 1 RL address\n    LOG_INFO (\"==========================================\\n\")\n    if (decode_preR13_section_hdr (\"BLOCK\", SECTION_BLOCK, dat, dwg)\n        || decode_preR13_section_hdr (\"LAYER\", SECTION_LAYER, dat, dwg)\n        || decode_preR13_section_hdr (\"STYLE\", SECTION_STYLE, dat, dwg)\n        || decode_preR13_section_hdr (\"LTYPE\", SECTION_LTYPE, dat, dwg)\n        || decode_preR13_section_hdr (\"VIEW\", SECTION_VIEW, dat, dwg))\n      return DWG_ERR_INVALIDDWG;\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x5e\n  if (dat->size < 0x1f0) // AC1.50 0x1f9 74 vars\n    {\n      LOG_ERROR (\"DWG too small %zu\", (size_t)dat->size)\n      return DWG_ERR_INVALIDDWG;\n    }\n\n  LOG_INFO (\"==========================================\\n\")\n  error |= decode_preR13_header_variables (dat, dwg);\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  SINCE (R_11)\n    {\n      // crc16 + DWG_SENTINEL_R11_HEADER_END\n      BITCODE_RS crc, crcc;\n      BITCODE_TF r11_sentinel;\n      crcc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now\n      crc = bit_read_RS (dat);\n      LOG_TRACE (\"crc: %04X [RSx] from 0-0x%lx\\n\", crc, dat->byte - 2);\n      if (crc != crcc)\n        {\n          LOG_ERROR (\"Header CRC mismatch %04X <=> %04X\", crc, crcc);\n          error |= DWG_ERR_WRONGCRC;\n        }\n      r11_sentinel = bit_read_TF (dat, 16);\n      LOG_TRACE (\"r11_sentinel: \");\n      LOG_TRACE_TF (r11_sentinel, 16) // == C46E6854F86E3330633EC1852ADC9401\n      if (memcmp (r11_sentinel, dwg_sentinel (DWG_SENTINEL_R11_HEADER_END), 16))\n        {\n          LOG_ERROR (\"DWG_SENTINEL_R11_HEADER_END mismatch\");\n          error |= DWG_ERR_WRONGCRC;\n        }\n      free (r11_sentinel);\n    }\n\n  PRE (R_10)\n    num_entities = dwg->header_vars.numentities;\n  else\n    num_entities = 0;\n  PRE (R_2_0b) {\n    entities_start = dat->byte;\n    entities_end = dwg->header_vars.dwg_size;\n  }\n\n  // additional tables mixed-in since r10\n  if (dwg->header.numheader_vars > 158) // r10\n    {\n      dat->byte = 0x3ef;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"UCS\", SECTION_UCS, dat, dwg);\n      dat->byte = 0x500;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"VPORT\", SECTION_VPORT, dat, dwg);\n      dat->byte = 0x512;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"APPID\", SECTION_APPID, dat, dwg);\n      dat->byte = entities_start;\n    }\n  if (dwg->header.numheader_vars > 160) // r11\n    {\n      dat->byte = 0x522;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"DIMSTYLE\", SECTION_DIMSTYLE, dat, dwg);\n      dat->byte = 0x69f;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"VX\", SECTION_VX, dat, dwg);\n      dat->byte = entities_start;\n    }\n\n  // entities\n  if (dat->byte != entities_start)\n    {\n      LOG_WARN (\"@0x%lx => entities_start 0x%x\", dat->byte, entities_start);\n      if (dat->byte < entities_start)\n        {\n          _DEBUG_HERE (dat->byte - entities_start)\n        }\n      dat->byte = entities_start;\n    }\n  error |= decode_preR13_entities (entities_start, entities_end, num_entities,\n                                   entities_end - entities_start, 0, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  if (dat->byte != entities_end)\n    {\n      LOG_WARN (\"@0x%lx => entities_end 0x%x\", dat->byte, entities_end);\n      dat->byte = entities_end;\n    }\n  PRE (R_2_0b) {\n    // this has usually some slack at the end.\n    return error;\n  }\n  LOG_INFO (\"==========================================\\n\")\n  //dat->byte += 20; /* crc + sentinel? 20 byte */\n  if (!dwg->next_hdl)\n    dwg_set_next_hdl (dwg, 0x22);\n  error |= decode_preR13_section (SECTION_BLOCK, dat, dwg);\n  error |= decode_preR13_section (SECTION_LAYER, dat, dwg);\n  error |= decode_preR13_section (SECTION_STYLE, dat, dwg);\n  error |= decode_preR13_section (SECTION_LTYPE, dat, dwg);\n  error |= decode_preR13_section (SECTION_VIEW, dat, dwg);\n#if 1\n  if (num_sections > 5) // r10\n    {\n      error |= decode_preR13_section (SECTION_UCS, dat, dwg);\n      error |= decode_preR13_section (SECTION_VPORT, dat, dwg);\n      error |= decode_preR13_section (SECTION_APPID, dat, dwg);\n    }\n  if (num_sections > 8) // r11\n    {\n      error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg);\n      error |= decode_preR13_section (SECTION_VX, dat, dwg);\n    }\n#endif\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n\n  // block entities\n  if (dat->byte != blocks_start)\n    {\n      BITCODE_TF unknown;\n      int len = blocks_start - dat->byte;\n      LOG_WARN (\"\\n@0x%lx => blocks_start 0x%x\", dat->byte, blocks_start);\n      if (dat->byte < blocks_start)\n        {\n          unknown = bit_read_TF (dat, len);\n          LOG_TRACE (\"unknown (%d):\", len);\n          LOG_TRACE_TF (unknown, len);\n          free (unknown);\n        }\n      dat->byte = blocks_start;\n    }\n  num_entities = 0;\n  VERSION (R_11)\n    blocks_end -= 32; // ??\n  error |= decode_preR13_entities (blocks_start, blocks_end,\n                                   num_entities, blocks_size & 0x3FFFFFFF,\n                                   blocks_max, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n\n  PRE (R_11) {\n    return error;\n  }\n  // only since r11 (AC1009)\n  LOG_TRACE (\"AUXHEADER: @0x%lx\\n\", dat->byte);\n  // 36 byte: 9x long\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  LOG_TRACE (\"@0x%lx: 4 block ptrs chk\\n\", dat->byte);\n  if ((rl1 = bit_read_RL (dat)) != entities_start)\n    {\n      LOG_WARN (\"entities_start %x/%x\", rl1, entities_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != entities_end)\n    {\n      LOG_WARN (\"entities_end %x/%x\", rl1, entities_end);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_start)\n    {\n      LOG_WARN (\"blocks_start %x/%x\", rl1, blocks_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_end)\n    {\n      LOG_WARN (\"blocks_end %x/%x\", rl1, blocks_end);\n    }\n  // 12 byte\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x\\n\", rl1, rl2);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  rl1 = blocks_end + 36 + 4 * 4 + 12; // ??\n  DEBUG_HERE\n  UNKNOWN_UNTIL (rl1);\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  decode_preR13_section_chk (SECTION_BLOCK, dat, dwg);\n  decode_preR13_section_chk (SECTION_LAYER, dat, dwg);\n  decode_preR13_section_chk (SECTION_STYLE, dat, dwg);\n  decode_preR13_section_chk (SECTION_LTYPE, dat, dwg);\n  decode_preR13_section_chk (SECTION_VIEW, dat, dwg);\n  if (num_sections > 5) // dead code?\n    {\n      decode_preR13_section_chk (SECTION_UCS, dat, dwg);\n      decode_preR13_section_chk (SECTION_VPORT, dat, dwg);\n      decode_preR13_section_chk (SECTION_APPID, dat, dwg);\n      decode_preR13_section_chk (SECTION_DIMSTYLE, dat, dwg);\n      decode_preR13_section_chk (SECTION_VX, dat, dwg);\n    }\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"long 0x%x\\n\", rl1); // address\n  if (dat->byte < dat->size)\n    {\n      int len = dat->size - dat->byte;\n      BITCODE_TF unknown = bit_read_TF (dat, len);\n      LOG_TRACE (\"unknown (%d):\", len);\n      LOG_TRACE_TF (unknown, len);\n      free (unknown);\n    }\n  if (dwg->dirty_refs)\n    dwg_resolve_objectrefs_silent (dwg);\n  return 0;\n#endif // USE_WRITE\n}",
        "file_path": "/src/libredwg/src/decode_r11.c",
        "crashing_line": "      error |= decode_preR13_section (SECTION_UCS, dat, dwg);",
        "crashing_line_number": 843
      },
      {
        "function_name": "dwg_decode",
        "function_body": "EXPORT int\ndwg_decode (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int i;\n  char magic[8];\n\n  dwg->num_object_refs = 0;\n  // dwg->num_layers = 0; // see now dwg->layer_control->num_entries\n  dwg->num_entities = 0;\n  dwg->num_objects = 0;\n  dwg->num_classes = 0;\n  dwg->thumbnail.size = 0;\n  dwg->thumbnail.chain = NULL;\n  dwg->header.numsections = 0;\n  dwg->header.section_infohdr.num_desc = 0;\n  dwg->dwg_class = NULL;\n  dwg->object_ref = NULL;\n  dwg->object = NULL;\n  dwg->object_map = hash_new (dat->size / 1000);\n  if (!dwg->object_map)\n    {\n      // whatever, we are obviously on a tiny system\n      dwg->object_map = hash_new (1024);\n      if (!dwg->object_map)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n    }\n  dwg->dirty_refs = 1;\n\n  //memset (&dwg->header, 0, sizeof (dwg->header)); // no, needed for magic\n  memset (&dwg->header_vars, 0, sizeof (dwg->header_vars));\n  memset (&dwg->summaryinfo, 0, sizeof (dwg->summaryinfo));\n  memset (&dwg->r2004_header, 0, sizeof (dwg->r2004_header));\n  memset (&dwg->auxheader, 0, sizeof (dwg->auxheader));\n  memset (&dwg->second_header, 0, sizeof (dwg->second_header));\n\n  if (dwg->opts)\n    {\n      loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n      dat->opts = dwg->opts;\n    }\n\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  /* Version */\n  dat->byte = 0;\n  dat->bit = 0;\n  if (!dat->chain || dat->size < 58) // saw the smallest r2.10 DWG with 1095 bytes\n    {\n      LOG_ERROR (\"dwg too small: %lu bytes\", dat->size);\n      return DWG_ERR_INVALIDDWG;\n    }\n  strncpy (magic, (const char *)dat->chain, 6);\n  if (memcmp (dat->chain, \"AC103-4\", 7) == 0)\n    {\n      magic[6] = '4';\n      magic[7] = '\\0';\n    }\n  else\n    magic[6] = '\\0';\n\n  dwg->header.from_version = dwg_version_hdr_type (magic);\n  if (!dwg->header.from_version)\n    {\n      if (strncmp (magic, \"AC\", 2)) // let's ignore MC0.0 for now\n        {\n          LOG_ERROR (\"Invalid DWG, magic: %s\", magic);\n        }\n      else\n        {\n          LOG_ERROR (\"Invalid or unimplemented DWG version code %s\", magic);\n        }\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->from_version = dwg->header.from_version;\n  if (!dwg->header.version) // target version not set\n    {\n      dat->version = dwg->header.version = dat->from_version;\n    }\n  LOG_INFO (\"This file's version code is: %s (%s)\\n\", magic,\n            dwg_version_type (dat->from_version))\n\n  PRE (R_13) {\n    Dwg_Object *ctrl;\n    int error = decode_preR13 (dat, dwg);\n    if (error <= DWG_ERR_CRITICAL)\n      {\n        ctrl = &dwg->object[0];\n        dwg->block_control = *ctrl->tio.object->tio.BLOCK_CONTROL;\n      }\n    return error;\n  }\n  VERSIONS (R_13, R_2000) { return decode_R13_R2000 (dat, dwg); }\n  VERSION (R_2004) { return decode_R2004 (dat, dwg); }\n  VERSION (R_2007) { return decode_R2007 (dat, dwg); }\n  SINCE (R_2010)\n  {\n    read_r2007_init (dwg); // sets loglevel only for now\n    return decode_R2004 (dat, dwg);\n  }\n\n  // This line should not be reached\n  LOG_ERROR (\"LibreDWG does not support this DWG version: %s (%s).\",\n\t     magic, dwg_version_type (dat->from_version))\n  return DWG_ERR_INVALIDDWG;\n}",
        "file_path": "/src/libredwg/src/decode.c",
        "crashing_line": "    int error = decode_preR13 (dat, dwg);",
        "crashing_line_number": 211
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "    bool IsValid(void) const\n    {\n        return ((GetLength() >= sizeof(*this) - sizeof(NetworkDataTlv)) &&\n                (GetLength() >= BitVectorBytes(mPrefixLength) + sizeof(*this) - sizeof(NetworkDataTlv)));\n    }\n",
    "target": 1,
    "idx": 1013334,
    "stack_trace": [
      {
        "function_name": "GetNextOnMeshPrefix",
        "function_body": "otError NetworkData::GetNextOnMeshPrefix(otNetworkDataIterator *aIterator,\n                                         uint16_t               aRloc16,\n                                         otBorderRouterConfig * aConfig)\n{\n    otError             error = OT_ERROR_NOT_FOUND;\n    NetworkDataIterator iterator(aIterator);\n    NetworkDataTlv *    cur = reinterpret_cast<NetworkDataTlv *>(mTlvs + iterator.GetTlvOffset());\n    NetworkDataTlv *    end = reinterpret_cast<NetworkDataTlv *>(mTlvs + mLength);\n\n    for (; cur < end; cur = cur->GetNext(), iterator.SetSubTlvOffset(0), iterator.SetEntryIndex(0))\n    {\n        PrefixTlv *     prefix;\n        NetworkDataTlv *subCur;\n        NetworkDataTlv *subEnd;\n\n        VerifyOrExit((cur + 1) <= end && cur->GetNext() <= end, error = OT_ERROR_PARSE);\n\n        if (cur->GetType() != NetworkDataTlv::kTypePrefix)\n        {\n            continue;\n        }\n\n        prefix = static_cast<PrefixTlv *>(cur);\n        subCur = reinterpret_cast<NetworkDataTlv *>(reinterpret_cast<uint8_t *>(prefix->GetSubTlvs()) +\n                                                    iterator.GetSubTlvOffset());\n        subEnd = cur->GetNext();\n\n        for (; subCur < subEnd; subCur = subCur->GetNext(), iterator.SetEntryIndex(0))\n        {\n            BorderRouterTlv *borderRouter;\n\n            VerifyOrExit((subCur + 1) <= subEnd && subCur->GetNext() <= subEnd, error = OT_ERROR_PARSE);\n\n            if (subCur->GetType() != NetworkDataTlv::kTypeBorderRouter)\n            {\n                continue;\n            }\n\n            borderRouter = static_cast<BorderRouterTlv *>(subCur);\n\n            for (uint8_t index = iterator.GetEntryIndex(); index < borderRouter->GetNumEntries(); index++)\n            {\n                if (aRloc16 == Mac::kShortAddrBroadcast || borderRouter->GetEntry(index)->GetRloc() == aRloc16)\n                {\n                    BorderRouterEntry *borderRouterEntry = borderRouter->GetEntry(index);\n\n                    memset(aConfig, 0, sizeof(*aConfig));\n                    memcpy(&aConfig->mPrefix.mPrefix, prefix->GetPrefix(), BitVectorBytes(prefix->GetPrefixLength()));\n                    aConfig->mPrefix.mLength = prefix->GetPrefixLength();\n                    aConfig->mPreference     = borderRouterEntry->GetPreference();\n                    aConfig->mPreferred      = borderRouterEntry->IsPreferred();\n                    aConfig->mSlaac          = borderRouterEntry->IsSlaac();\n                    aConfig->mDhcp           = borderRouterEntry->IsDhcp();\n                    aConfig->mConfigure      = borderRouterEntry->IsConfigure();\n                    aConfig->mDefaultRoute   = borderRouterEntry->IsDefaultRoute();\n                    aConfig->mOnMesh         = borderRouterEntry->IsOnMesh();\n                    aConfig->mStable         = borderRouter->IsStable();\n                    aConfig->mRloc16         = borderRouterEntry->GetRloc();\n\n                    iterator.SaveTlvOffset(cur, mTlvs);\n                    iterator.SaveSubTlvOffset(subCur, prefix->GetSubTlvs());\n                    iterator.SetEntryIndex(index + 1);\n\n                    ExitNow(error = OT_ERROR_NONE);\n                }\n            }\n        }\n    }\n\nexit:\n    return error;\n}",
        "file_path": "/src/openthread/src/core/thread/network_data.cpp",
        "crashing_line": "                    memcpy(&aConfig->mPrefix.mPrefix, prefix->GetPrefix(), BitVectorBytes(prefix->GetPrefixLength()));",
        "crashing_line_number": 138
      },
      {
        "function_name": "UpdateAddresses",
        "function_body": "void Dhcp6Client::UpdateAddresses(void)\n{\n    bool                  found    = false;\n    bool                  newAgent = false;\n    otNetworkDataIterator iterator;\n    otBorderRouterConfig  config;\n\n    // remove addresses directly if prefix not valid in network data\n    for (uint8_t i = 0; i < OT_ARRAY_LENGTH(mIdentityAssociations); i++)\n    {\n        IdentityAssociation &ia = mIdentityAssociations[i];\n\n        if (ia.mStatus == kIaStatusInvalid || ia.mValidLifetime == 0)\n        {\n            continue;\n        }\n\n        found    = false;\n        iterator = OT_NETWORK_DATA_ITERATOR_INIT;\n\n        while ((otNetDataGetNextOnMeshPrefix(&GetInstance(), &iterator, &config)) == OT_ERROR_NONE)\n        {\n            if (!config.mDhcp)\n            {\n                continue;\n            }\n\n            if (MatchNetifAddressWithPrefix(ia.mNetifAddress, config.mPrefix))\n            {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found)\n        {\n            GetNetif().RemoveUnicastAddress(*static_cast<Ip6::NetifUnicastAddress *>(&ia.mNetifAddress));\n            mIdentityAssociations[i].mStatus = kIaStatusInvalid;\n        }\n    }\n\n    // add IdentityAssociation for new configured prefix\n    iterator = OT_NETWORK_DATA_ITERATOR_INIT;\n\n    while (otNetDataGetNextOnMeshPrefix(&GetInstance(), &iterator, &config) == OT_ERROR_NONE)\n    {\n        IdentityAssociation *ia = NULL;\n\n        if (!config.mDhcp)\n        {\n            continue;\n        }\n\n        found = false;\n\n        for (uint8_t i = 0; i < OT_ARRAY_LENGTH(mIdentityAssociations); i++)\n        {\n            if (mIdentityAssociations[i].mStatus == kIaStatusInvalid)\n            {\n                // record an available ia\n                if (ia == NULL)\n                {\n                    ia = &mIdentityAssociations[i];\n                }\n            }\n            else if (MatchNetifAddressWithPrefix(mIdentityAssociations[i].mNetifAddress, config.mPrefix))\n            {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found)\n        {\n            if (ia != NULL)\n            {\n                ia->mPrefixAgentRloc            = config.mRloc16;\n                ia->mNetifAddress.mAddress      = config.mPrefix.mPrefix;\n                ia->mNetifAddress.mPrefixLength = config.mPrefix.mLength;\n                ia->mStatus                     = kIaStatusSolicit;\n                ia->mValidLifetime              = 0;\n                newAgent                        = true;\n            }\n            else\n            {\n                otLogWarnIp6(\"Insufficient memory for new DHCP prefix\");\n            }\n        }\n    }\n\n    if (newAgent)\n    {\n        Start();\n    }\n    else\n    {\n        Stop();\n    }\n}",
        "file_path": "/src/openthread/src/core/net/dhcp6_client.cpp",
        "crashing_line": "    while (otNetDataGetNextOnMeshPrefix(&GetInstance(), &iterator, &config) == OT_ERROR_NONE)",
        "crashing_line_number": 117
      },
      {
        "function_name": "HandleStateChanged",
        "function_body": "void Mle::HandleStateChanged(otChangedFlags aFlags)\n{\n    ThreadNetif &netif = GetNetif();\n\n    VerifyOrExit(mRole != OT_DEVICE_ROLE_DISABLED);\n\n    if ((aFlags & (OT_CHANGED_IP6_ADDRESS_ADDED | OT_CHANGED_IP6_ADDRESS_REMOVED)) != 0)\n    {\n        if (!netif.IsUnicastAddress(mMeshLocal64.GetAddress()))\n        {\n            // Mesh Local EID was removed, choose a new one and add it back\n            Random::FillBuffer(mMeshLocal64.GetAddress().mFields.m8 + OT_IP6_PREFIX_SIZE,\n                               OT_IP6_ADDRESS_SIZE - OT_IP6_PREFIX_SIZE);\n\n            netif.AddUnicastAddress(mMeshLocal64);\n            GetNotifier().Signal(OT_CHANGED_THREAD_ML_ADDR);\n        }\n\n        if (mRole == OT_DEVICE_ROLE_CHILD && !IsFullThreadDevice())\n        {\n            mChildUpdateRequestState = kChildUpdateRequestPending;\n            ScheduleMessageTransmissionTimer();\n        }\n    }\n\n    if ((aFlags & (OT_CHANGED_IP6_MULTICAST_SUBSRCRIBED | OT_CHANGED_IP6_MULTICAST_UNSUBSRCRIBED)) != 0)\n    {\n        if (mRole == OT_DEVICE_ROLE_CHILD && !IsFullThreadDevice() && !IsRxOnWhenIdle())\n        {\n            mChildUpdateRequestState = kChildUpdateRequestPending;\n            ScheduleMessageTransmissionTimer();\n        }\n    }\n\n    if ((aFlags & OT_CHANGED_THREAD_NETDATA) != 0)\n    {\n        if (IsFullThreadDevice())\n        {\n            netif.GetMle().HandleNetworkDataUpdateRouter();\n        }\n        else if ((aFlags & OT_CHANGED_THREAD_ROLE) == 0)\n        {\n            mChildUpdateRequestState = kChildUpdateRequestPending;\n            ScheduleMessageTransmissionTimer();\n        }\n\n#if OPENTHREAD_ENABLE_BORDER_ROUTER || OPENTHREAD_ENABLE_SERVICE\n        netif.GetNetworkDataLocal().SendServerDataNotification();\n#if OPENTHREAD_ENABLE_SERVICE\n        this->UpdateServiceAlocs();\n#endif\n#endif\n\n#if OPENTHREAD_CONFIG_ENABLE_SLAAC\n        GetNetif().UpdateSlaac();\n#endif\n\n#if OPENTHREAD_ENABLE_DHCP6_SERVER\n        GetNetif().GetDhcp6Server().UpdateService();\n#endif // OPENTHREAD_ENABLE_DHCP6_SERVER\n\n#if OPENTHREAD_ENABLE_DHCP6_CLIENT\n        GetNetif().GetDhcp6Client().UpdateAddresses();\n#endif // OPENTHREAD_ENABLE_DHCP6_CLIENT\n    }\n\n    if (aFlags & (OT_CHANGED_THREAD_ROLE | OT_CHANGED_THREAD_KEY_SEQUENCE_COUNTER))\n    {\n        // Store the settings on a key seq change, or when role changes and device\n        // is attached (i.e., skip `Store()` on role change to detached).\n\n        if ((aFlags & OT_CHANGED_THREAD_KEY_SEQUENCE_COUNTER) || IsAttached())\n        {\n            Store();\n        }\n    }\n\n    if (aFlags & OT_CHANGED_SECURITY_POLICY)\n    {\n        GetNetif().GetIp6Filter().AllowNativeCommissioner(\n            (GetNetif().GetKeyManager().GetSecurityPolicyFlags() & OT_SECURITY_POLICY_NATIVE_COMMISSIONING) != 0);\n    }\n\nexit:\n    return;\n}",
        "file_path": "/src/openthread/src/core/thread/mle.cpp",
        "crashing_line": "        GetNetif().GetDhcp6Client().UpdateAddresses();",
        "crashing_line_number": 1518
      },
      {
        "function_name": "HandleStateChanged",
        "function_body": "void Notifier::HandleStateChanged(void)\n{\n    otChangedFlags flags = mFlagsToSignal;\n\n    VerifyOrExit(flags != 0);\n\n    mFlagsToSignal = 0;\n\n    LogChangedFlags(flags);\n\n    for (Callback *callback = mCallbacks; callback != NULL; callback = callback->mNext)\n    {\n        callback->Invoke(flags);\n    }\n\n    for (unsigned int i = 0; i < kMaxExternalHandlers; i++)\n    {\n        ExternalCallback &callback = mExternalCallbacks[i];\n\n        if (callback.mHandler != NULL)\n        {\n            callback.mHandler(flags, callback.mContext);\n        }\n    }\n\nexit:\n    return;\n}",
        "file_path": "/src/openthread/src/core/common/notifier.cpp",
        "crashing_line": "        callback->Invoke(flags);",
        "crashing_line_number": 158
      },
      {
        "function_name": "ProcessQueuedTasklets",
        "function_body": "void TaskletScheduler::ProcessQueuedTasklets(void)\n{\n    Tasklet *tail = mTail;\n    Tasklet *cur;\n\n    while ((cur = PopTasklet()) != NULL)\n    {\n        cur->RunTask();\n\n        // only process tasklets that were queued at the time this method was called\n        if (cur == tail)\n        {\n            if (mHead != NULL)\n            {\n                otTaskletsSignalPending(&mHead->GetInstance());\n            }\n\n            break;\n        }\n    }\n}",
        "file_path": "/src/openthread/src/core/common/tasklet.cpp",
        "crashing_line": "        cur->RunTask();",
        "crashing_line_number": 112
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static mrb_value\nint_to_s(mrb_state *mrb, mrb_value self)\n{\n  mrb_int base = 10;\n\n  mrb_get_args(mrb, \"|i\", &base);\n#ifdef MRB_USE_BIGINT\n  if (mrb_bigint_p(self)) {\n    return mrb_bint_to_s(mrb, self, base);\n  }\n#endif\n  return mrb_integer_to_str(mrb, self, base);\n}\n",
    "target": 1,
    "idx": 1049045,
    "stack_trace": [
      {
        "function_name": "mrb_bint_to_s",
        "function_body": "mrb_value\nmrb_bint_to_s(mrb_state *mrb, mrb_value x, mrb_int base)\n{\n  struct RBigint *b = RBIGINT(x);\n  mrb_int len = mpz_sizeinbase(&b->mp, (int)base);\n  mrb_value str = mrb_str_new(mrb, NULL, len+2);\n  mpz_get_str(mrb, RSTRING_PTR(str), len, base, &b->mp);\n  RSTR_SET_LEN(RSTRING(str), strlen(RSTRING_PTR(str)));\n  return str;\n}",
        "file_path": "/src/mruby/mrbgems/mruby-bigint/core/bigint.c",
        "crashing_line": "  mpz_get_str(mrb, RSTRING_PTR(str), len, base, &b->mp);",
        "crashing_line_number": 1345
      },
      {
        "function_name": "int_to_s",
        "function_body": "static mrb_value\nint_to_s(mrb_state *mrb, mrb_value self)\n{\n  mrb_int base = 10;\n\n  mrb_get_args(mrb, \"|i\", &base);\n  return mrb_integer_to_str(mrb, self, base);\n}",
        "file_path": "/src/mruby/src/numeric.c",
        "crashing_line": "",
        "crashing_line_number": 1810
      },
      {
        "function_name": "mrb_vm_run",
        "function_body": "MRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "  result = mrb_vm_exec(mrb, proc, irep->iseq);",
        "crashing_line_number": 1208
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void LibRaw::sony_arq_load_raw()\n{\n  int row, col;\n  read_shorts(imgdata.rawdata.raw_image,\n              imgdata.sizes.raw_width * imgdata.sizes.raw_height * 4);\n  libraw_internal_data.internal_data.input->seek(\n      -2, SEEK_CUR); // avoid wrong eof error\n\n  if(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_ARQ_SKIP_CHANNEL_SWAP)\n    return;\n\n  for (row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    unsigned short(*rowp)[4] =\n        (unsigned short(*)[4]) &\n        imgdata.rawdata.raw_image[row * imgdata.sizes.raw_width * 4];\n    for (col = 0; col < imgdata.sizes.raw_width; col++)\n    {\n      unsigned short g2 = rowp[col][2];\n      rowp[col][2] = rowp[col][3];\n      rowp[col][3] = g2;\n      if (((unsigned)(row - imgdata.sizes.top_margin) < imgdata.sizes.height) &&\n          ((unsigned)(col - imgdata.sizes.left_margin) < imgdata.sizes.width) &&\n          (MAX(MAX(rowp[col][0], rowp[col][1]),\n               MAX(rowp[col][2], rowp[col][3])) > imgdata.color.maximum))\n        derror();\n    }\n  }\n}\n",
    "target": 1,
    "idx": 1060983,
    "stack_trace": [
      {
        "function_name": "read",
        "function_body": "int LibRaw_file_datastream::read(void *ptr, size_t size, size_t nmemb)\n{\n/* Visual Studio 2008 marks sgetn as insecure, but VS2010 does not. */\n#if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)\n  LR_STREAM_CHK();\n  return int(f->_Sgetn_s(static_cast<char *>(ptr), nmemb * size, nmemb * size) /\n             (size > 0 ? size : 1));\n#else\n  LR_STREAM_CHK();\n  return int(f->sgetn(static_cast<char *>(ptr), std::streamsize(nmemb * size)) /\n             (size > 0 ? size : 1));\n#endif\n}",
        "file_path": "/src/libraw/src/libraw_datastream.cpp",
        "crashing_line": "",
        "crashing_line_number": 372
      },
      {
        "function_name": "read_shorts",
        "function_body": "void LibRaw::read_shorts(ushort *pixel, unsigned count)\n{\n  if ((unsigned)fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    libraw_swab(pixel, count * 2);\n}",
        "file_path": "/src/libraw/src/utils/read_utils.cpp",
        "crashing_line": "  if ((unsigned)fread(pixel, 2, count, ifp) < count)",
        "crashing_line_number": 172
      },
      {
        "function_name": "sony_arq_load_raw",
        "function_body": "void LibRaw::sony_arq_load_raw()\n{\n  int row, col;\n  if (imgdata.idata.filters || imgdata.idata.colors < 3)\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  read_shorts(imgdata.rawdata.raw_image,\n              imgdata.sizes.raw_width * imgdata.sizes.raw_height * 4);\n  libraw_internal_data.internal_data.input->seek(\n      -2, SEEK_CUR); // avoid wrong eof error\n\n  if(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_ARQ_SKIP_CHANNEL_SWAP)\n    return;\n\n  for (row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    unsigned short(*rowp)[4] =\n        (unsigned short(*)[4]) &\n        imgdata.rawdata.raw_image[row * imgdata.sizes.raw_width * 4];\n    for (col = 0; col < imgdata.sizes.raw_width; col++)\n    {\n      unsigned short g2 = rowp[col][2];\n      rowp[col][2] = rowp[col][3];\n      rowp[col][3] = g2;\n      if (((unsigned)(row - imgdata.sizes.top_margin) < imgdata.sizes.height) &&\n          ((unsigned)(col - imgdata.sizes.left_margin) < imgdata.sizes.width) &&\n          (MAX(MAX(rowp[col][0], rowp[col][1]),\n               MAX(rowp[col][2], rowp[col][3])) > imgdata.color.maximum))\n        derror();\n    }\n  }\n}",
        "file_path": "/src/libraw/src/decoders/decoders_libraw.cpp",
        "crashing_line": "  if (imgdata.idata.filters || imgdata.idata.colors < 3)",
        "crashing_line_number": 25
      },
      {
        "function_name": "unpack",
        "function_body": "int LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try\n  {\n\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);\n    if (imgdata.rawparams.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if (!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if (imgdata.image)\n    {\n      free(imgdata.image);\n      imgdata.image = 0;\n    }\n    if (imgdata.rawdata.raw_alloc)\n    {\n      free(imgdata.rawdata.raw_alloc);\n      imgdata.rawdata.raw_alloc = 0;\n    }\n    if (libraw_internal_data.unpacker_data.meta_length)\n    {\n      if (libraw_internal_data.unpacker_data.meta_length >\n          INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n        throw LIBRAW_EXCEPTION_TOOBIG;\n\n      libraw_internal_data.internal_data.meta_data =\n          (char *)malloc(libraw_internal_data.unpacker_data.meta_length);\n    }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight,\n        save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if (!IO.fuji_width)\n    {\n      // adjust non-Fuji allocation\n      if (rwidth < S.width + S.left_margin)\n        rwidth = S.width + S.left_margin;\n      if (rheight < S.height + S.top_margin)\n        rheight = S.height + S.top_margin;\n    }\n    if (rwidth > 65535 ||\n        rheight > 65535) // No way to make image larger than 64k pix\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n    imgdata.rawdata.float_image = 0;\n    imgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n    if (imgdata.idata.dng_version && dnghost\n        && libraw_internal_data.unpacker_data.tiff_samples != 2  // Fuji SuperCCD; it is better to detect is more rigid way\n        && valid_for_dngsdk() && load_raw != &LibRaw::pentax_4shot_load_raw)\n    {\n      // Data size check\n      INT64 pixcount =\n          INT64(MAX(S.width, S.raw_width)) * INT64(MAX(S.height, S.raw_height));\n      INT64 planecount =\n          (imgdata.idata.filters || P1.colors == 1) ? 1 : LIM(P1.colors, 3, 4);\n      INT64 samplesize = is_floating_point() ? 4 : 2;\n      INT64 bytes = pixcount * planecount * samplesize;\n      if (bytes + INT64(libraw_internal_data.unpacker_data.meta_length )\n\t\t\t> INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n        throw LIBRAW_EXCEPTION_TOOBIG;\n\n      // find ifd to check sample\n      try_dngsdk();\n      if (raw_was_read())\n        imgdata.process_warnings |= LIBRAW_WARN_DNGSDK_PROCESSED;\n    }\n#endif\n#ifdef USE_RAWSPEED3\n    if (!raw_was_read()\n        && (!IO.fuji_width) // Do not use for fuji rotated\n        && ((imgdata.idata.raw_count == 1) \n            // Canon dual pixel, 1st frame\n            || (makeIs(LIBRAW_CAMERAMAKER_Canon) && imgdata.idata.raw_count == 2 && imgdata.rawparams.shot_select==0)\n            )\n#ifdef USE_RAWSPEED_BITS\n        && (imgdata.rawparams.use_rawspeed & LIBRAW_RAWSPEEDV3_USE)\n#else\n        && imgdata.rawparams.use_rawspeed\n#endif\n        && (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED3)\n        )\n    {\n      INT64 pixcount = INT64(MAX(S.width, S.raw_width)) * INT64(MAX(S.height, S.raw_height));\n      INT64 planecount = (imgdata.idata.filters || P1.colors == 1) ? 1 : LIM(P1.colors, 3, 4);\n      INT64 bytes = pixcount * planecount * 2; // sample size is always 2 for rawspeed\n      if (bytes + INT64(libraw_internal_data.unpacker_data.meta_length) \n\t\t\t\t> INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n        throw LIBRAW_EXCEPTION_TOOBIG;\n\n        if (!_rawspeed3_handle)\n            _rawspeed3_handle = rawspeed3_initdefault();\n\n        if (_rawspeed3_handle && ID.input->size() > 0) // large bound is checked at identify\n        {\n            void *_rawspeed_buffer = 0;\n            try {\n                ID.input->seek(0, SEEK_SET);\n                INT64 _rawspeed_buffer_sz = ID.input->size() + 32;\n                _rawspeed_buffer = malloc(_rawspeed_buffer_sz);\n                if (!_rawspeed_buffer)\n                    throw LIBRAW_EXCEPTION_ALLOC;\n                ID.input->read(_rawspeed_buffer, ID.input->size(), 1);\n\n                rawspeed3_ret_t rs3ret;\n                rawspeed3_clearresult(&rs3ret);\n                int status = rawspeed3_decodefile(_rawspeed3_handle, &rs3ret, _rawspeed_buffer, ID.input->size(),\n#ifdef USE_RAWSPEED_BITS\n                    !(imgdata.rawparams.use_rawspeed & LIBRAW_RAWSPEEDV3_FAILONUNKNOWN)\n#else\n                    false\n#endif\n                );\n                if (status != rawspeed3_ok)\n                  imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;\n\n                if (status == rawspeed3_not_supported)\n                  imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED3_NOTLISTED;\n\n                if (status == rawspeed3_ok\n#ifdef USE_RAWSPEED_BITS\n                    ||\n                    (status == rawspeed3_ok_warnings && (imgdata.rawparams.use_rawspeed & LIBRAW_RAWSPEEDV3_IGNOREERRORS))\n#endif\n                    )\n                {\n\n                  if ((S.raw_width != rs3ret.width) || (S.raw_height != rs3ret.height))\n                      throw \"Size mismatch\";\n\n                    // DECODED w/ success\n                  if (rs3ret.filters>1) // Fuji or bayer\n                      imgdata.rawdata.raw_image = (ushort*)rs3ret.pixeldata;\n                  else if (rs3ret.cpp == 4)\n                  {\n                      imgdata.rawdata.color4_image = (ushort(*)[4])rs3ret.pixeldata;\n                    //if (r->whitePoint > 0 && r->whitePoint < 65536)\n                    //  C.maximum = r->whitePoint;\n                  }\n                  else if (rs3ret.cpp == 3)\n                  {\n                      imgdata.rawdata.color3_image = (ushort(*)[3])rs3ret.pixeldata;\n                    //if (r->whitePoint > 0 && r->whitePoint < 65536)\n                    //  C.maximum = r->whitePoint;\n                  }\n\n                  if (raw_was_read()) // buffers are assigned above\n                  {\n                    // set sizes\n                    S.raw_pitch = rs3ret.pitch;\n                    S.raw_width = rs3ret.width;\n                    S.raw_height = rs3ret.height;\n                    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED3_PROCESSED;\n                    // if (r->whitePoint > 0 && r->whitePoint < 65536)\n                    // C.maximum = r->whitePoint;\n                  }\n                }\n                free(_rawspeed_buffer);\n            }\n            catch (...)\n            {\n                imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED3_PROBLEM;\n                if (_rawspeed_buffer)\n                    free(_rawspeed_buffer);\n            }\n         }\n    }\n#endif\n#ifdef USE_RAWSPEED\n    if (!raw_was_read())\n    {\n      int rawspeed_enabled = 1;\n\n      if (imgdata.idata.dng_version && (libraw_internal_data.unpacker_data.tiff_samples == 2 || imgdata.idata.raw_count > 1))\n        rawspeed_enabled = 0;\n\n      if (libraw_internal_data.unpacker_data.is_NikonTransfer)\n        rawspeed_enabled = 0;\n\n      if (libraw_internal_data.unpacker_data.pana_encoding == 5)\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.raw_count > 1)\n        rawspeed_enabled = 0;\n      if (!strncasecmp(imgdata.idata.software, \"Magic\", 5))\n        rawspeed_enabled = 0;\n      // Disable rawspeed for double-sized Oly files\n      if (makeIs(LIBRAW_CAMERAMAKER_Olympus) &&\n          ((imgdata.sizes.raw_width > 6000) ||\n           !strncasecmp(imgdata.idata.model, \"SH-\", 3) ||\n           !strncasecmp(imgdata.idata.model, \"TG-\", 3) ))\n        rawspeed_enabled = 0;\n\n      if (makeIs(LIBRAW_CAMERAMAKER_Canon) &&\n          (libraw_internal_data.identify_data.unique_id == CanonID_EOS_6D_Mark_II))\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.dng_version && imgdata.idata.filters == 0 &&\n          libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::packed_load_raw &&\n        makeIs(LIBRAW_CAMERAMAKER_Nikon) &&\n          (!strncasecmp(imgdata.idata.model, \"E\", 1) ||\n           !strncasecmp(imgdata.idata.model, \"COOLPIX B\", 9) ||\n\t\t   !strncasecmp(imgdata.idata.model, \"COOLPIX P9\", 10) ||\n           !strncasecmp(imgdata.idata.model, \"COOLPIX P1000\", 13)))\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::nikon_load_raw && makeIs(LIBRAW_CAMERAMAKER_Nikon) &&\n          !strcasecmp(imgdata.idata.model, \"D6\"))\n        rawspeed_enabled = 0;\n\n\tif (load_raw == &LibRaw::lossless_jpeg_load_raw &&\n\t\tMN.canon.RecordMode && makeIs(LIBRAW_CAMERAMAKER_Kodak) &&\n\t\t/* Not normalized models here, it is intentional */\n\t\t(!strncasecmp(imgdata.idata.model, \"EOS D2000\", 9) ||\n\t\t !strncasecmp(imgdata.idata.model, \"EOS D6000\", 9)))\n\t  rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::nikon_load_raw &&\n        makeIs(LIBRAW_CAMERAMAKER_Nikon) &&\n          (!strncasecmp(imgdata.idata.model, \"Z\", 1) || !strncasecmp(imgdata.idata.model,\"D780\",4)))\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::panasonic_load_raw &&\n          libraw_internal_data.unpacker_data.pana_encoding > 4)\n        rawspeed_enabled = 0;\n\n      // RawSpeed Supported,\n      if (\n#ifdef USE_RAWSPEED_BITS\n          (imgdata.rawparams.use_rawspeed & LIBRAW_RAWSPEEDV1_USE)\n#else\n          imgdata.rawparams.use_rawspeed \n#endif\n          && rawspeed_enabled &&\n          !(is_sraw() && (imgdata.rawparams.specials &\n                          (LIBRAW_RAWSPECIAL_SRAW_NO_RGB |\n                           LIBRAW_RAWSPECIAL_SRAW_NO_INTERPOLATE))) &&\n          (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) &&\n          _rawspeed_camerameta)\n      {\n        INT64 pixcount = INT64(MAX(S.width, S.raw_width)) *\n                         INT64(MAX(S.height, S.raw_height));\n        INT64 planecount = (imgdata.idata.filters || P1.colors == 1)\n                               ? 1\n                               : LIM(P1.colors, 3, 4);\n        INT64 bytes =\n            pixcount * planecount * 2; // sample size is always 2 for rawspeed\n        if (bytes + +INT64(libraw_internal_data.unpacker_data.meta_length) >\n            INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_TOOBIG;\n\n        /*int rr = */ try_rawspeed();\n\n      }\n    }\n#endif\n    if (!raw_was_read()) // RawSpeed failed or not run\n    {\n      // Not allocated on RawSpeed call, try call LibRaow\n      int zero_rawimage = 0;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder and DNG float\n        // Do nothing! Decoder will allocate data internally\n      }\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_SINAR4SHOT)\n      {\n        if (imgdata.rawparams.shot_select) // single image extract\n        {\n          if (INT64(rwidth) * INT64(rheight + 8) *\n                  INT64(sizeof(imgdata.rawdata.raw_image[0])) \n\t\t\t\t+ +INT64(libraw_internal_data.unpacker_data.meta_length) >\n              INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n            throw LIBRAW_EXCEPTION_TOOBIG;\n          imgdata.rawdata.raw_alloc = malloc(\n              rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));\n          imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n          if (!S.raw_pitch)\n            S.raw_pitch = S.raw_width * 2; // Bayer case, not set before\n        }\n        else // Full image extract\n        {\n          if (INT64(rwidth) * INT64(rheight + 8) *\n                  INT64(sizeof(imgdata.rawdata.raw_image[0])) * 4 \n\t\t\t\t+INT64(libraw_internal_data.unpacker_data.meta_length) >\n              INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n            throw LIBRAW_EXCEPTION_TOOBIG;\n          S.raw_pitch = S.raw_width * 8;\n          imgdata.rawdata.raw_alloc = 0;\n          imgdata.image = (ushort(*)[4])calloc(\n              unsigned(MAX(S.width, S.raw_width)) *\n                  unsigned(MAX(S.height, S.raw_height) + 8),\n              sizeof(*imgdata.image));\n        }\n      }\n      else if (decoder_info.decoder_flags & LIBRAW_DECODER_3CHANNEL)\n      {\n        if (INT64(rwidth) * INT64(rheight + 8) *\n                INT64(sizeof(imgdata.rawdata.raw_image[0])) * 3 \n\t\t\t+ INT64(libraw_internal_data.unpacker_data.meta_length) >\n            INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_TOOBIG;\n\n        imgdata.rawdata.raw_alloc = malloc(\n            rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]) * 3);\n        imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 6;\n      }\n      else if (imgdata.idata.filters ||\n               P1.colors ==\n                   1) // Bayer image or single color -> decode to raw_image\n      {\n        if (INT64(rwidth) * INT64(rheight + 8) *\n                INT64(sizeof(imgdata.rawdata.raw_image[0])) \n\t\t\t+ INT64(libraw_internal_data.unpacker_data.meta_length) >\n            INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_TOOBIG;\n        imgdata.rawdata.raw_alloc = malloc(\n            rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));\n        imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 2; // Bayer case, not set before\n      }\n      else // NO LEGACY FLAG if (decoder_info.decoder_flags &\n           // LIBRAW_DECODER_LEGACY)\n      {\n        if (decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL)\n        {\n          S.raw_pitch = S.raw_width * 8;\n        }\n        else\n        {\n          S.iwidth = S.width;\n          S.iheight = S.height;\n          IO.shrink = 0;\n          if (!S.raw_pitch)\n            S.raw_pitch = (decoder_info.decoder_flags &\n                           LIBRAW_DECODER_LEGACY_WITH_MARGINS)\n                              ? S.raw_width * 8\n                              : S.width * 8;\n        }\n        // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n        // allocate image as temporary buffer, size\n        if (INT64(MAX(S.width, S.raw_width)) *\n                INT64(MAX(S.height, S.raw_height) + 8) *\n                INT64(sizeof(*imgdata.image)) \n\t\t\t+ INT64(libraw_internal_data.unpacker_data.meta_length) >\n            INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_TOOBIG;\n\n        imgdata.rawdata.raw_alloc = 0;\n        imgdata.image =\n            (ushort(*)[4])calloc(unsigned(MAX(S.width, S.raw_width)) *\n                                     unsigned(MAX(S.height, S.raw_height) + 8),\n                                 sizeof(*imgdata.image));\n        if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n          zero_rawimage = 1;\n        }\n      }\n      ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n      unsigned m_save = C.maximum;\n      if (load_raw == &LibRaw::unpacked_load_raw &&\n          (!strcasecmp(imgdata.idata.make, \"Nikon\") || !strcasecmp(imgdata.idata.make, \"Hasselblad\"))\n          )\n        C.maximum = 65535;\n      (this->*load_raw)();\n      if (zero_rawimage)\n        imgdata.rawdata.raw_image = 0;\n      if (load_raw == &LibRaw::unpacked_load_raw &&\n          (!strcasecmp(imgdata.idata.make, \"Nikon\") || !strcasecmp(imgdata.idata.make, \"Hasselblad\"))\n          )\n        C.maximum = m_save;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder only: do nothing\n      }\n      else if (decoder_info.decoder_flags & LIBRAW_DECODER_SINAR4SHOT &&\n               imgdata.rawparams.shot_select == 0)\n      {\n        imgdata.rawdata.raw_alloc = imgdata.image;\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n        imgdata.image = 0;\n      }\n      else if (!(imgdata.idata.filters ||\n                 P1.colors == 1)) // legacy decoder, ownalloc handled above\n      {\n        // successfully decoded legacy image, attach image to raw_alloc\n        imgdata.rawdata.raw_alloc = imgdata.image;\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n        imgdata.image = 0;\n        // Restore saved values. Note: Foveon have masked frame\n        // Other 4-color legacy data: no borders\n        if (!(libraw_internal_data.unpacker_data.load_flags & 256) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS))\n        {\n          S.raw_width = S.width;\n          S.left_margin = 0;\n          S.raw_height = S.height;\n          S.top_margin = 0;\n        }\n      }\n    }\n\n    if (imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for (c = 0; c < 3; c++)\n      if (i > C.cblack[c])\n        i = C.cblack[c];\n    for (c = 0; c < 4; c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams,\n            &libraw_internal_data.internal_output_params,\n            sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 1, 2);\n\n    return 0;\n  }\n  catch (const std::bad_alloc&)\n  {\n      EXCEPTION_HANDLER(LIBRAW_EXCEPTION_ALLOC);\n  }\n  catch (const LibRaw_exceptions& err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (const std::exception& )\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}",
        "file_path": "/src/libraw/src/decoders/unpack.cpp",
        "crashing_line": "      (this->*load_raw)();",
        "crashing_line_number": 411
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void pns_decode(ic_stream *ics_left, ic_stream *ics_right,\n                real_t *spec_left, real_t *spec_right, uint16_t frame_len,\n                uint8_t channel_pair, uint8_t object_type,\n                /* RNG states */ uint32_t *__r1, uint32_t *__r2)\n{\n    uint8_t g, sfb, b;\n    uint16_t size, offs;\n\n    uint8_t group = 0;\n    uint16_t nshort = frame_len >> 3;\n\n    uint8_t sub = 0;\n\n#ifdef FIXED_POINT\n    /* IMDCT scaling */\n    if (object_type == LD)\n    {\n        sub = 9 /*9*/;\n    } else {\n        if (ics_left->window_sequence == EIGHT_SHORT_SEQUENCE)\n            sub = 7 /*7*/;\n        else\n            sub = 10 /*10*/;\n    }\n#endif\n\n    for (g = 0; g < ics_left->num_window_groups; g++)\n    {\n        /* Do perceptual noise substitution decoding */\n        for (b = 0; b < ics_left->window_group_length[g]; b++)\n        {\n            for (sfb = 0; sfb < ics_left->max_sfb; sfb++)\n            {\n                uint32_t r1_dep = 0, r2_dep = 0;\n\n                if (is_noise(ics_left, g, sfb))\n                {\n#ifdef LTP_DEC\n                    /* Simultaneous use of LTP and PNS is not prevented in the\n                       syntax. If both LTP, and PNS are enabled on the same\n                       scalefactor band, PNS takes precedence, and no prediction\n                       is applied to this band.\n                    */\n                    ics_left->ltp.long_used[sfb] = 0;\n                    ics_left->ltp2.long_used[sfb] = 0;\n#endif\n\n#ifdef MAIN_DEC\n                    /* For scalefactor bands coded using PNS the corresponding\n                       predictors are switched to \"off\".\n                    */\n                    ics_left->pred.prediction_used[sfb] = 0;\n#endif\n\n                    offs = ics_left->swb_offset[sfb];\n                    size = min(ics_left->swb_offset[sfb+1], ics_left->swb_offset_max) - offs;\n\n                    r1_dep = *__r1;\n                    r2_dep = *__r2;\n\n                    /* Generate random vector */\n                    gen_rand_vector(&spec_left[(group*nshort)+offs],\n                        ics_left->scale_factors[g][sfb], size, sub, __r1, __r2);\n                }\n\n/* From the spec:\n   If the same scalefactor band and group is coded by perceptual noise\n   substitution in both channels of a channel pair, the correlation of\n   the noise signal can be controlled by means of the ms_used field: While\n   the default noise generation process works independently for each channel\n   (separate generation of random vectors), the same random vector is used\n   for both channels if ms_used[] is set for a particular scalefactor band\n   and group. In this case, no M/S stereo coding is carried out (because M/S\n   stereo coding and noise substitution coding are mutually exclusive).\n   If the same scalefactor band and group is coded by perceptual noise\n   substitution in only one channel of a channel pair the setting of ms_used[]\n   is not evaluated.\n*/\n                if ((ics_right != NULL)\n                    && is_noise(ics_right, g, sfb))\n                {\n#ifdef LTP_DEC\n                    /* See comment above. */\n                    ics_right->ltp.long_used[sfb] = 0;\n                    ics_right->ltp2.long_used[sfb] = 0;\n#endif\n#ifdef MAIN_DEC\n                    /* See comment above. */\n                    ics_right->pred.prediction_used[sfb] = 0;\n#endif\n\n                    if (channel_pair && is_noise(ics_left, g, sfb) &&\n                        (((ics_left->ms_mask_present == 1) &&\n                        (ics_left->ms_used[g][sfb])) ||\n                        (ics_left->ms_mask_present == 2)))\n                    {\n                        /*uint16_t c;*/\n\n                        offs = ics_right->swb_offset[sfb];\n                        size = min(ics_right->swb_offset[sfb+1], ics_right->swb_offset_max) - offs;\n\n                        /* Generate random vector dependent on left channel*/\n                        gen_rand_vector(&spec_right[(group*nshort)+offs],\n                            ics_right->scale_factors[g][sfb], size, sub, &r1_dep, &r2_dep);\n\n                    } else /*if (ics_left->ms_mask_present == 0)*/ {\n\n                        offs = ics_right->swb_offset[sfb];\n                        size = min(ics_right->swb_offset[sfb+1], ics_right->swb_offset_max) - offs;\n\n                        /* Generate random vector */\n                        gen_rand_vector(&spec_right[(group*nshort)+offs],\n                            ics_right->scale_factors[g][sfb], size, sub, __r1, __r2);\n                    }\n                }\n            } /* sfb */\n            group++;\n        } /* b */\n    } /* g */\n}\n",
    "target": 1,
    "idx": 1058287,
    "stack_trace": [
      {
        "function_name": "gen_rand_vector",
        "function_body": "static INLINE void gen_rand_vector(real_t *spec, int16_t scale_factor, uint16_t size,\n                                   uint8_t sub,\n                                   /* RNG states */ uint32_t *__r1, uint32_t *__r2)\n{\n#ifndef FIXED_POINT\n    uint16_t i;\n    real_t energy = 0.0;\n\n    real_t scale = (real_t)1.0/(real_t)size;\n\n    for (i = 0; i < size; i++)\n    {\n        real_t tmp = scale*(real_t)(int32_t)ne_rng(__r1, __r2);\n        spec[i] = tmp;\n        energy += tmp*tmp;\n    }\n\n    scale = (real_t)1.0/(real_t)sqrt(energy);\n    scale *= (real_t)pow(2.0, 0.25 * scale_factor);\n    for (i = 0; i < size; i++)\n    {\n        spec[i] *= scale;\n    }\n#else\n    uint16_t i;\n    real_t energy = 0, scale;\n    int32_t exp, frac;\n\n    for (i = 0; i < size; i++)\n    {\n        /* this can be replaced by a 16 bit random generator!!!! */\n        real_t tmp = (int32_t)ne_rng(__r1, __r2);\n        if (tmp < 0)\n            tmp = -(tmp & ((1<<(REAL_BITS-1))-1));\n        else\n            tmp = (tmp & ((1<<(REAL_BITS-1))-1));\n\n        energy += MUL_R(tmp,tmp);\n\n        spec[i] = tmp;\n    }\n\n    energy = fp_sqrt(energy);\n    if (energy > 0)\n    {\n        scale = DIV(REAL_CONST(1),energy);\n\n        exp = scale_factor >> 2;\n        frac = scale_factor & 3;\n\n        /* IMDCT pre-scaling */\n        exp -= sub;\n\n        if (exp < 0)\n            scale >>= -exp;\n        else\n            scale <<= exp;\n\n        if (frac)\n            scale = MUL_C(scale, pow2_table[frac]);\n\n        for (i = 0; i < size; i++)\n        {\n            spec[i] = MUL_R(spec[i], scale);\n        }\n    }\n#endif\n}",
        "file_path": "/src/faad2/libfaad/pns.c",
        "crashing_line": "        spec[i] = tmp;",
        "crashing_line_number": 102
      },
      {
        "function_name": "pns_decode",
        "function_body": "void pns_decode(ic_stream *ics_left, ic_stream *ics_right,\n                real_t *spec_left, real_t *spec_right, uint16_t frame_len,\n                uint8_t channel_pair, uint8_t object_type,\n                /* RNG states */ uint32_t *__r1, uint32_t *__r2)\n{\n    uint8_t g, sfb, b;\n    uint16_t begin, end;\n\n    uint8_t group = 0;\n    uint16_t nshort = frame_len >> 3;\n\n    uint8_t sub = 0;\n\n#ifdef FIXED_POINT\n    /* IMDCT scaling */\n    if (object_type == LD)\n    {\n        sub = 9 /*9*/;\n    } else {\n        if (ics_left->window_sequence == EIGHT_SHORT_SEQUENCE)\n            sub = 7 /*7*/;\n        else\n            sub = 10 /*10*/;\n    }\n#endif\n\n    for (g = 0; g < ics_left->num_window_groups; g++)\n    {\n        /* Do perceptual noise substitution decoding */\n        for (b = 0; b < ics_left->window_group_length[g]; b++)\n        {\n            uint16_t base = group * nshort;\n            for (sfb = 0; sfb < ics_left->max_sfb; sfb++)\n            {\n                uint32_t r1_dep = 0, r2_dep = 0;\n\n                if (is_noise(ics_left, g, sfb))\n                {\n#ifdef LTP_DEC\n                    /* Simultaneous use of LTP and PNS is not prevented in the\n                       syntax. If both LTP, and PNS are enabled on the same\n                       scalefactor band, PNS takes precedence, and no prediction\n                       is applied to this band.\n                    */\n                    ics_left->ltp.long_used[sfb] = 0;\n                    ics_left->ltp2.long_used[sfb] = 0;\n#endif\n\n#ifdef MAIN_DEC\n                    /* For scalefactor bands coded using PNS the corresponding\n                       predictors are switched to \"off\".\n                    */\n                    ics_left->pred.prediction_used[sfb] = 0;\n#endif\n                    begin = min(base + ics_right->swb_offset[sfb], ics_right->swb_offset_max);\n                    end = min(base + ics_left->swb_offset[sfb+1], ics_left->swb_offset_max);\n\n                    r1_dep = *__r1;\n                    r2_dep = *__r2;\n\n                    /* Generate random vector */\n                    gen_rand_vector(&spec_left[begin],\n                        ics_left->scale_factors[g][sfb], end - begin, sub, __r1, __r2);\n                }\n\n/* From the spec:\n   If the same scalefactor band and group is coded by perceptual noise\n   substitution in both channels of a channel pair, the correlation of\n   the noise signal can be controlled by means of the ms_used field: While\n   the default noise generation process works independently for each channel\n   (separate generation of random vectors), the same random vector is used\n   for both channels if ms_used[] is set for a particular scalefactor band\n   and group. In this case, no M/S stereo coding is carried out (because M/S\n   stereo coding and noise substitution coding are mutually exclusive).\n   If the same scalefactor band and group is coded by perceptual noise\n   substitution in only one channel of a channel pair the setting of ms_used[]\n   is not evaluated.\n*/\n                if ((ics_right != NULL)\n                    && is_noise(ics_right, g, sfb))\n                {\n#ifdef LTP_DEC\n                    /* See comment above. */\n                    ics_right->ltp.long_used[sfb] = 0;\n                    ics_right->ltp2.long_used[sfb] = 0;\n#endif\n#ifdef MAIN_DEC\n                    /* See comment above. */\n                    ics_right->pred.prediction_used[sfb] = 0;\n#endif\n\n                    if (channel_pair && is_noise(ics_left, g, sfb) &&\n                        (((ics_left->ms_mask_present == 1) &&\n                        (ics_left->ms_used[g][sfb])) ||\n                        (ics_left->ms_mask_present == 2)))\n                    {\n                        /*uint16_t c;*/\n\n                        begin = min(base + ics_right->swb_offset[sfb], ics_right->swb_offset_max);\n                        end = min(base + ics_right->swb_offset[sfb+1], ics_right->swb_offset_max);\n\n                        /* Generate random vector dependent on left channel*/\n                        gen_rand_vector(&spec_right[begin],\n                            ics_right->scale_factors[g][sfb], end - begin, sub, &r1_dep, &r2_dep);\n\n                    } else /*if (ics_left->ms_mask_present == 0)*/ {\n                        begin = min(base + ics_right->swb_offset[sfb], ics_right->swb_offset_max);\n                        end = min(base + ics_right->swb_offset[sfb+1], ics_right->swb_offset_max);\n\n                        /* Generate random vector */\n                        gen_rand_vector(&spec_right[begin],\n                            ics_right->scale_factors[g][sfb], end - begin, sub, __r1, __r2);\n                    }\n                }\n            } /* sfb */\n            group++;\n        } /* b */\n    } /* g */\n}",
        "file_path": "/src/faad2/libfaad/pns.c",
        "crashing_line": "                            ics_right->scale_factors[g][sfb], end - begin, sub, __r1, __r2);",
        "crashing_line_number": 269
      },
      {
        "function_name": "channel_pair_element",
        "function_body": "",
        "file_path": "/src/faad2/libfaad/syntax.c",
        "crashing_line": "",
        "crashing_line_number": 807
      },
      {
        "function_name": "decode_cpe",
        "function_body": "static void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                       uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+2 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for CPE the number of output channels is always 2 */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != 2) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    if (hDecoder->element_id[hDecoder->fr_ch_ele] != INVALID_ELEMENT_ID &&\n        hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele)\n    {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = channel_pair_element(hDecoder, ld, channels, &tag);\n\n    /* map output channel position to internal data channels */\n    if (hDecoder->pce_set)\n    {\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels;\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]+1] = channels+1;\n    } else {\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    }\n\n    hDecoder->fr_channels += 2;\n    hDecoder->fr_ch_ele++;\n}",
        "file_path": "/src/faad2/libfaad/syntax.c",
        "crashing_line": "    hInfo->error = channel_pair_element(hDecoder, ld, channels, &tag);",
        "crashing_line_number": 421
      },
      {
        "function_name": "raw_data_block",
        "function_body": "void raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                    bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t id_syn_ele;\n    uint8_t ele_this_frame = 0;\n\n    hDecoder->fr_channels = 0;\n    hDecoder->fr_ch_ele = 0;\n    hDecoder->first_syn_ele = 25;\n    hDecoder->has_lfe = 0;\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->object_type < ER_OBJECT_START)\n    {\n#endif\n        /* Table 4.4.3: raw_data_block() */\n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\"NeAACDecDecode(): id_syn_ele\"))) != ID_END)\n        {\n            switch (id_syn_ele) {\n            case ID_SCE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CPE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_LFE:\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n                hDecoder->has_lfe++;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CCE: /* not implemented yet, but skip the bits */\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n#ifdef COUPLING_DEC\n                hInfo->error = coupling_channel_element(hDecoder, ld);\n#else\n                hInfo->error = 6;\n#endif\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_DSE:\n                ele_this_frame++;\n                data_stream_element(hDecoder, ld);\n                break;\n            case ID_PCE:\n                if (ele_this_frame != 0)\n                {\n                    hInfo->error = 31;\n                    return;\n                }\n                ele_this_frame++;\n                /* 14496-4: 5.6.4.1.2.1.3: */\n                /* program_configuration_element()'s in access units shall be ignored */\n                program_config_element(pce, ld);\n                //if ((hInfo->error = program_config_element(pce, ld)) > 0)\n                //    return;\n                //hDecoder->pce_set = 1;\n                break;\n            case ID_FIL:\n                ele_this_frame++;\n                /* one sbr_info describes a channel_element not a channel! */\n                /* if we encounter SBR data here: error */\n                /* SBR data will be read directly in the SCE/LFE/CPE element */\n                if ((hInfo->error = fill_element(hDecoder, ld, drc\n#ifdef SBR_DEC\n                    , INVALID_SBR_ELEMENT\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n            if (ld->error != 0)\n            {\n                hInfo->error = 32;\n                return;\n            }\n        }\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* Table 262: er_raw_data_block() */\n        switch (hDecoder->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 7: /* 8 channels */\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        default:\n            hInfo->error = 7;\n            return;\n        }\n#if 0\n        cnt = bits_to_decode() / 8;\n        while (cnt >= 1)\n        {\n            cnt -= extension_payload(cnt);\n        }\n#endif\n    }\n#endif\n\n    /* new in corrigendum 14496-3:2002 */\n#ifdef DRM\n    if (hDecoder->object_type != DRM_ER_LC\n#if 0\n        && !hDecoder->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(ld);\n    }\n\n    return;\n}",
        "file_path": "/src/faad2/libfaad/syntax.c",
        "crashing_line": "                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);",
        "crashing_line_number": 467
      },
      {
        "function_name": "aac_frame_decode",
        "function_body": "",
        "file_path": "/src/faad2/libfaad/decoder.c",
        "crashing_line": "",
        "crashing_line_number": 1000
      },
      {
        "function_name": "NeAACDecDecode",
        "function_body": "",
        "file_path": "/src/faad2/libfaad/decoder.c",
        "crashing_line": "",
        "crashing_line_number": 828
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n\t    if ((ctxt->sax != NULL) &&\n                (ctxt->disableSAX == 0) &&\n\t\t(ctxt->sax->comment != NULL)) {\n\t\tif (buf == NULL) {\n\t\t    if ((*in == '-') && (in[1] == '-'))\n\t\t        size = nbchar + 1;\n\t\t    else\n\t\t        size = XML_PARSER_BUFFER_SIZE + nbchar;\n\t\t    buf = (xmlChar *) xmlMallocAtomic(size);\n\t\t    if (buf == NULL) {\n\t\t        xmlErrMemory(ctxt, NULL);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    len = 0;\n\t\t} else if (len + nbchar + 1 >= size) {\n\t\t    xmlChar *new_buf;\n\t\t    size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n\t\t    new_buf = (xmlChar *) xmlRealloc(buf, size);\n\t\t    if (new_buf == NULL) {\n\t\t        xmlFree (buf);\n\t\t\txmlErrMemory(ctxt, NULL);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    buf = new_buf;\n\t\t}\n\t\tmemcpy(&buf[len], ctxt->input->cur, nbchar);\n\t\tlen += nbchar;\n\t\tbuf[len] = 0;\n\t    }\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n",
    "target": 1,
    "idx": 1063124,
    "stack_trace": [
      {
        "function_name": "xmlCopyCharMultiByte",
        "function_body": "int\nxmlCopyCharMultiByte(xmlChar *out, int val) {\n    if ((out == NULL) || (val < 0)) return(0);\n    /*\n     * We are supposed to handle UTF8, check it's valid\n     * From rfc2044: encoding of the Unicode values on UTF-8:\n     *\n     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n     * 0000 0000-0000 007F   0xxxxxxx\n     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n     */\n    if  (val >= 0x80) {\n\txmlChar *savedout = out;\n\tint bits;\n\tif (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }\n\telse if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}\n\telse if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }\n\telse {\n\t    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,\n\t\t    \"Internal error, xmlCopyCharMultiByte 0x%X out of bound\\n\",\n\t\t\t      val);\n\t    return(0);\n\t}\n\tfor ( ; bits >= 0; bits-= 6)\n\t    *out++= ((val >> bits) & 0x3F) | 0x80 ;\n\treturn (out - savedout);\n    }\n    *out = val;\n    return 1;\n}",
        "file_path": "/src/libxml2/parserInternals.c",
        "crashing_line": "\t    *out++= ((val >> bits) & 0x3F) | 0x80 ;",
        "crashing_line_number": 1095
      },
      {
        "function_name": "xmlParseCommentComplex",
        "function_body": "static void\nxmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,\n                       size_t len, size_t size) {\n    int q, ql;\n    int r, rl;\n    int cur, l;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    int inputid;\n\n    inputid = ctxt->input->id;\n\n    if (buf == NULL) {\n        len = 0;\n\tsize = XML_PARSER_BUFFER_SIZE;\n\tbuf = (xmlChar *) xmlMallocAtomic(size);\n\tif (buf == NULL) {\n\t    xmlErrMemory(ctxt, NULL);\n\t    return;\n\t}\n    }\n    q = CUR_CHAR(ql);\n    if (q == 0)\n        goto not_terminated;\n    if (!IS_CHAR(q)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  q);\n\txmlFree (buf);\n\treturn;\n    }\n    NEXTL(ql);\n    r = CUR_CHAR(rl);\n    if (r == 0)\n        goto not_terminated;\n    if (!IS_CHAR(r)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  r);\n\txmlFree (buf);\n\treturn;\n    }\n    NEXTL(rl);\n    cur = CUR_CHAR(l);\n    if (cur == 0)\n        goto not_terminated;\n    while (IS_CHAR(cur) && /* checked */\n           ((cur != '>') ||\n\t    (r != '-') || (q != '-'))) {\n\tif ((r == '-') && (q == '-')) {\n\t    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);\n\t}\n\tif (len + 5 >= size) {\n\t    xmlChar *new_buf;\n            size_t new_size;\n\n\t    new_size = size * 2;\n\t    new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n\t    if (new_buf == NULL) {\n\t\txmlFree (buf);\n\t\txmlErrMemory(ctxt, NULL);\n\t\treturn;\n\t    }\n\t    buf = new_buf;\n            size = new_size;\n\t}\n\tCOPY_BUF(ql,buf,len,q);\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\n\tq = r;\n\tql = rl;\n\tr = cur;\n\trl = l;\n\n\tNEXTL(l);\n\tcur = CUR_CHAR(l);\n\n    }\n    buf[len] = 0;\n    if (ctxt->instate == XML_PARSER_EOF) {\n        xmlFree(buf);\n        return;\n    }\n    if (cur == 0) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t                     \"Comment not terminated \\n<!--%.50s\\n\", buf);\n    } else if (!IS_CHAR(cur)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  cur);\n    } else {\n\tif (inputid != ctxt->input->id) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t           \"Comment doesn't start and stop in the same\"\n                           \" entity\\n\");\n\t}\n        NEXT;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->comment(ctxt->userData, buf);\n    }\n    xmlFree(buf);\n    return;\nnot_terminated:\n    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t\t\t \"Comment not terminated\\n\", NULL);\n    xmlFree(buf);\n    return;\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "\tCOPY_BUF(ql,buf,len,q);",
        "crashing_line_number": 4964
      },
      {
        "function_name": "xmlParseComment",
        "function_body": "void\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n            if (buf == NULL) {\n                if ((*in == '-') && (in[1] == '-'))\n                    size = nbchar + 1;\n                else\n                    size = XML_PARSER_BUFFER_SIZE + nbchar;\n                buf = (xmlChar *) xmlMallocAtomic(size);\n                if (buf == NULL) {\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                len = 0;\n            } else if (len + nbchar + 1 >= size) {\n                xmlChar *new_buf;\n                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n                new_buf = (xmlChar *) xmlRealloc(buf, size);\n                if (new_buf == NULL) {\n                    xmlFree (buf);\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                buf = new_buf;\n            }\n            memcpy(&buf[len], ctxt->input->cur, nbchar);\n            len += nbchar;\n            buf[len] = 0;\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "",
        "crashing_line_number": 5189
      },
      {
        "function_name": "xmlParseMisc",
        "function_body": "void\nxmlParseMisc(xmlParserCtxtPtr ctxt) {\n    while (ctxt->instate != XML_PARSER_EOF) {\n        SKIP_BLANKS;\n        GROW;\n        if ((RAW == '<') && (NXT(1) == '?')) {\n\t    xmlParsePI(ctxt);\n        } else if (CMP4(CUR_PTR, '<', '!', '-', '-')) {\n\t    xmlParseComment(ctxt);\n        } else {\n            break;\n        }\n    }\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "    }",
        "crashing_line_number": 11037
      },
      {
        "function_name": "xmlParseDocument",
        "function_body": "int\nxmlParseDocument(xmlParserCtxtPtr ctxt) {\n    xmlInitParser();\n\n    if ((ctxt == NULL) || (ctxt->input == NULL))\n        return(-1);\n\n    GROW;\n\n    /*\n     * SAX: detecting the level.\n     */\n    xmlDetectSAX2(ctxt);\n\n    /*\n     * SAX: beginning of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n\n    xmlDetectEncoding(ctxt);\n\n    if (CUR == 0) {\n\txmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\treturn(-1);\n    }\n\n    GROW;\n    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {\n\n\t/*\n\t * Note that we will switch encoding on the fly.\n\t */\n\txmlParseXMLDecl(ctxt);\n\tif ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||\n\t    (ctxt->instate == XML_PARSER_EOF)) {\n\t    /*\n\t     * The XML REC instructs us to stop parsing right here\n\t     */\n\t    return(-1);\n\t}\n\tSKIP_BLANKS;\n    } else {\n\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n    }\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n        ctxt->sax->startDocument(ctxt->userData);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n    if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {\n\tctxt->myDoc->compression = ctxt->input->buf->compressed;\n    }\n\n    /*\n     * The Misc part of the Prolog\n     */\n    xmlParseMisc(ctxt);\n\n    /*\n     * Then possibly doc type declaration(s) and more Misc\n     * (doctypedecl Misc*)?\n     */\n    GROW;\n    if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {\n\n\tctxt->inSubset = 1;\n\txmlParseDocTypeDecl(ctxt);\n\tif (RAW == '[') {\n\t    ctxt->instate = XML_PARSER_DTD;\n\t    xmlParseInternalSubset(ctxt);\n\t    if (ctxt->instate == XML_PARSER_EOF)\n\t\treturn(-1);\n\t}\n\n\t/*\n\t * Create and update the external subset.\n\t */\n\tctxt->inSubset = 2;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n\t                              ctxt->extSubSystem, ctxt->extSubURI);\n\tif (ctxt->instate == XML_PARSER_EOF)\n\t    return(-1);\n\tctxt->inSubset = 0;\n\n        xmlCleanSpecialAttr(ctxt);\n\n\tctxt->instate = XML_PARSER_PROLOG;\n\txmlParseMisc(ctxt);\n    }\n\n    /*\n     * Time to start parsing the tree itself\n     */\n    GROW;\n    if (RAW != '<') {\n\txmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n\t\t       \"Start tag expected, '<' not found\\n\");\n    } else {\n\tctxt->instate = XML_PARSER_CONTENT;\n\txmlParseElement(ctxt);\n\tctxt->instate = XML_PARSER_EPILOG;\n\n\n\t/*\n\t * The Misc part at the end\n\t */\n\txmlParseMisc(ctxt);\n\n        if (ctxt->input->cur < ctxt->input->end) {\n            if (ctxt->errNo == XML_ERR_OK)\n\t        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tctxt->instate = XML_PARSER_EOF;\n    }\n\n    /*\n     * SAX: end of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n\n    /*\n     * Remove locally kept entity definitions if the tree was not built\n     */\n    if ((ctxt->myDoc != NULL) &&\n\t(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n\txmlFreeDoc(ctxt->myDoc);\n\tctxt->myDoc = NULL;\n    }\n\n    if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {\n        ctxt->myDoc->properties |= XML_DOC_WELLFORMED;\n\tif (ctxt->valid)\n\t    ctxt->myDoc->properties |= XML_DOC_DTDVALID;\n\tif (ctxt->nsWellFormed)\n\t    ctxt->myDoc->properties |= XML_DOC_NSVALID;\n\tif (ctxt->options & XML_PARSE_OLD10)\n\t    ctxt->myDoc->properties |= XML_DOC_OLD10;\n    }\n    if (! ctxt->wellFormed) {\n\tctxt->valid = 0;\n\treturn(-1);\n    }\n    return(0);\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "     * (doctypedecl Misc*)?",
        "crashing_line_number": 11118
      },
      {
        "function_name": "xmlDoRead",
        "function_body": "static xmlDocPtr\nxmlDoRead(xmlParserCtxtPtr ctxt, const char *URL, const char *encoding,\n          int options, int reuse)\n{\n    xmlDocPtr ret;\n\n    xmlCtxtUseOptionsInternal(ctxt, options, encoding);\n    if (encoding != NULL) {\n        xmlCharEncodingHandlerPtr hdlr;\n\n        /*\n         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the\n         * caller provided an encoding. Otherwise, we might switch to\n         * the encoding from the XML declaration which is likely to\n         * break things. Also see xmlSwitchInputEncoding.\n         */\n\thdlr = xmlFindCharEncodingHandler(encoding);\n\tif (hdlr != NULL)\n\t    xmlSwitchToEncoding(ctxt, hdlr);\n    }\n    if ((URL != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->filename == NULL))\n        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);\n    xmlParseDocument(ctxt);\n    if ((ctxt->wellFormed) || ctxt->recovery)\n        ret = ctxt->myDoc;\n    else {\n        ret = NULL;\n\tif (ctxt->myDoc != NULL) {\n\t    xmlFreeDoc(ctxt->myDoc);\n\t}\n    }\n    ctxt->myDoc = NULL;\n    if (!reuse) {\n\txmlFreeParserCtxt(ctxt);\n    }\n\n    return (ret);\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "        ret = NULL;",
        "crashing_line_number": 14809
      },
      {
        "function_name": "xmlReadMemory",
        "function_body": "xmlDocPtr\nxmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)\n{\n    xmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n    ctxt = xmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL)\n        return (NULL);\n    return (xmlDoRead(ctxt, URL, encoding, options, 0));\n}",
        "file_path": "/src/libxml2/parser.c",
        "crashing_line": "",
        "crashing_line_number": 14895
      },
      {
        "function_name": "xsltFuzzXslt",
        "function_body": "int\nxsltFuzzXsltInit(void) {\n    xsltFuzzInit();\n    xmlSetExternalEntityLoader(xmlFuzzEntityLoader);\n    return(0);\n}",
        "file_path": "/src/libxslt/tests/fuzz/fuzz.c",
        "crashing_line": "",
        "crashing_line_number": 284
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tbn_t tab[RLC_TABLE_SIZE], t, u, r;\n\tint i, j, l, w = 1;\n\tuint8_t win[RLC_BN_BITS];\n\n\tif (bn_is_zero(b)) {\n\t\tbn_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(r);\n\t/* Initialize table. */\n\tfor (i = 0; i < RLC_TABLE_SIZE; i++) {\n\t\tbn_null(tab[i]);\n\t}\n\n\tRLC_TRY {\n\t\t/* Find window size. */\n\t\ti = bn_bits(b);\n\t\tif (i <= 21) {\n\t\t\tw = 2;\n\t\t} else if (i <= 32) {\n\t\t\tw = 3;\n\t\t} else if (i <= 128) {\n\t\t\tw = 4;\n\t\t} else if (i <= 256) {\n\t\t\tw = 5;\n\t\t} else if (i <= 512) {\n\t\t\tw = 6;\n\t\t} else {\n\t\t\tw = 7;\n\t\t}\n\n\t\tfor (i = 0; i < (1 << (w - 1)); i ++) {\n\t\t\tbn_new(tab[i]);\n\t\t}\n\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(r);\n\t\tbn_mod_pre(u, m);\n\n#if BN_MOD == MONTY\n\t\tbn_set_dig(r, 1);\n\t\tbn_mod_monty_conv(r, r, m);\n\t\tbn_mod_monty_conv(t, a, m);\n#else /* BN_MOD == BARRT || BN_MOD == RADIX */\n\t\tbn_set_dig(r, 1);\n\t\tbn_copy(t, a);\n#endif\n\n\t\tbn_copy(tab[0], t);\n\t\tbn_sqr(t, tab[0]);\n\t\tbn_mod(t, t, m, u);\n\t\t/* Create table. */\n\t\tfor (i = 1; i < 1 << (w - 1); i++) {\n\t\t\tbn_mul(tab[i], tab[i - 1], t);\n\t\t\tbn_mod(tab[i], tab[i], m, u);\n\t\t}\n\n\t\tl = RLC_BN_BITS + 1;\n\t\tbn_rec_slw(win, &l, b, w);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tbn_sqr(r, r);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tbn_sqr(r, r);\n\t\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t\t}\n\t\t\t\tbn_mul(r, r, tab[win[i] >> 1]);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t}\n\t\t}\n\t\tbn_trim(r);\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_back(r, r, m);\n#endif\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tbn_mod_inv(c, r, m);\n\t\t} else {\n\t\t\tbn_copy(c, r);\n\t\t}\n\t}\n",
    "target": 1,
    "idx": 1029993,
    "stack_trace": [
      {
        "function_name": "bn_mxp_slide",
        "function_body": "void bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tbn_t tab[RLC_TABLE_SIZE], t, u, r;\n\tint i, j, l, w = 1;\n\tuint8_t *win = RLC_ALLOCA(uint8_t, bn_bits(b));\n\n\tif (bn_is_zero(b)) {\n\t\tbn_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(r);\n\t/* Initialize table. */\n\tfor (i = 0; i < RLC_TABLE_SIZE; i++) {\n\t\tbn_null(tab[i]);\n\t}\n\n\tRLC_TRY {\n\t\tif (win == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\t/* Find window size. */\n\t\ti = bn_bits(b);\n\t\tif (i <= 21) {\n\t\t\tw = 2;\n\t\t} else if (i <= 32) {\n\t\t\tw = 3;\n\t\t} else if (i <= 128) {\n\t\t\tw = 4;\n\t\t} else if (i <= 256) {\n\t\t\tw = 5;\n\t\t} else if (i <= 512) {\n\t\t\tw = 6;\n\t\t} else {\n\t\t\tw = 7;\n\t\t}\n\n\t\tfor (i = 0; i < (1 << (w - 1)); i ++) {\n\t\t\tbn_new(tab[i]);\n\t\t}\n\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(r);\n\t\tbn_mod_pre(u, m);\n\n#if BN_MOD == MONTY\n\t\tbn_set_dig(r, 1);\n\t\tbn_mod_monty_conv(r, r, m);\n\t\tbn_mod_monty_conv(t, a, m);\n#else /* BN_MOD == BARRT || BN_MOD == RADIX */\n\t\tbn_set_dig(r, 1);\n\t\tbn_copy(t, a);\n#endif\n\n\t\tbn_copy(tab[0], t);\n\t\tbn_sqr(t, tab[0]);\n\t\tbn_mod(t, t, m, u);\n\t\t/* Create table. */\n\t\tfor (i = 1; i < 1 << (w - 1); i++) {\n\t\t\tbn_mul(tab[i], tab[i - 1], t);\n\t\t\tbn_mod(tab[i], tab[i], m, u);\n\t\t}\n\n\t\tl = bn_bits(b);\n\t\tbn_rec_slw(win, &l, b, w);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tbn_sqr(r, r);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tbn_sqr(r, r);\n\t\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t\t}\n\t\t\t\tbn_mul(r, r, tab[win[i] >> 1]);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t}\n\t\t}\n\t\tbn_trim(r);\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_back(r, r, m);\n#endif\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tbn_mod_inv(c, r, m);\n\t\t} else {\n\t\t\tbn_copy(c, r);\n\t\t}\n\t}",
        "file_path": "/src/relic/src/bn/relic_bn_mxp.c",
        "crashing_line": "\t\t\tbn_mod(tab[i], tab[i], m, u);",
        "crashing_line_number": 175
      },
      {
        "function_name": "Run",
        "function_body": "bool Add::Run(Datasource& ds, Bignum& res, std::vector<Bignum>& bn) const {\n    (void)ds;\n\n    RLC_TRY {\n        /* noret */ bn_add(res.Get(), bn[0].Get(), bn[1].Get());\n    } RLC_CATCH_ANY {",
        "file_path": "/src/cryptofuzz/modules/relic/bn_ops.cpp",
        "crashing_line": "",
        "crashing_line_number": 362
      },
      {
        "function_name": "OpBignumCalc",
        "function_body": "std::optional<component::Bignum> relic::OpBignumCalc(operation::BignumCalc& op) {\n    std::optional<component::Bignum> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    relic_bignum::Bignum res(ds);\n    std::vector<relic_bignum::Bignum> bn = {\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n    };\n\n    std::unique_ptr<relic_bignum::Operation> opRunner = nullptr;\n\n    CF_CHECK_TRUE(res.Set(\"0\"));\n    CF_CHECK_TRUE(bn[0].Set(op.bn0.ToString(ds)));\n    CF_CHECK_TRUE(bn[1].Set(op.bn1.ToString(ds)));\n    CF_CHECK_TRUE(bn[2].Set(op.bn2.ToString(ds)));\n    CF_CHECK_TRUE(bn[3].Set(op.bn3.ToString(ds)));\n\n    switch ( op.calcOp.Get() ) {\n        case    CF_CALCOP(\"Add(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Add>();\n            break;\n        case    CF_CALCOP(\"Sub(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Sub>();\n            break;\n        case    CF_CALCOP(\"Mul(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Mul>();\n            break;\n        case    CF_CALCOP(\"Sqr(A)\"):\n            opRunner = std::make_unique<relic_bignum::Sqr>();\n            break;\n        case    CF_CALCOP(\"Div(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Div>();\n            break;\n        case    CF_CALCOP(\"GCD(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::GCD>();\n            break;\n        case    CF_CALCOP(\"LCM(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::LCM>();\n            break;\n        case    CF_CALCOP(\"InvMod(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::InvMod>();\n            break;\n        case    CF_CALCOP(\"LShift1(A)\"):\n            opRunner = std::make_unique<relic_bignum::LShift1>();\n            break;\n        case    CF_CALCOP(\"Jacobi(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Jacobi>();\n            break;\n        case    CF_CALCOP(\"Cmp(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Cmp>();\n            break;\n        case    CF_CALCOP(\"Mod(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Mod>();\n            break;\n        case    CF_CALCOP(\"IsEven(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsEven>();\n            break;\n        case    CF_CALCOP(\"IsOdd(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsOdd>();\n            break;\n        case    CF_CALCOP(\"IsZero(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsZero>();\n            break;\n        case    CF_CALCOP(\"Neg(A)\"):\n            opRunner = std::make_unique<relic_bignum::Neg>();\n            break;\n        case    CF_CALCOP(\"Sqrt(A)\"):\n            opRunner = std::make_unique<relic_bignum::Sqrt>();\n            break;\n        case    CF_CALCOP(\"Abs(A)\"):\n            opRunner = std::make_unique<relic_bignum::Abs>();\n            break;\n        case    CF_CALCOP(\"ExpMod(A,B,C)\"):\n            opRunner = std::make_unique<relic_bignum::ExpMod>();\n            break;\n        case    CF_CALCOP(\"NumBits(A)\"):\n            opRunner = std::make_unique<relic_bignum::NumBits>();\n            break;\n        case    CF_CALCOP(\"CmpAbs(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::CmpAbs>();\n            break;\n        case    CF_CALCOP(\"RShift(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::RShift>();\n            break;\n        case    CF_CALCOP(\"Bit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Bit>();\n            break;\n        case    CF_CALCOP(\"SetBit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::SetBit>();\n            break;\n        case    CF_CALCOP(\"ClearBit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::ClearBit>();\n            break;\n    }\n\n    CF_CHECK_NE(opRunner, nullptr);\n    CF_CHECK_EQ(opRunner->Run(ds, res, bn), true);\n\n    ret = res.ToComponentBignum();\n\nend:\n    return ret;\n}",
        "file_path": "/src/cryptofuzz/modules/relic/module.cpp",
        "crashing_line": "    CF_CHECK_EQ(opRunner->Run(ds, res, bn), true);",
        "crashing_line_number": 365
      },
      {
        "function_name": "callModule",
        "function_body": "template<> std::optional<bool> ExecutorBase<bool, operation::Verify>::callModule(std::shared_ptr<Module> module, operation::Verify& op) const {\n    return module->OpVerify(op);\n}",
        "file_path": "/src/cryptofuzz/executor.cpp",
        "crashing_line": "",
        "crashing_line_number": 1018
      },
      {
        "function_name": "Run",
        "function_body": "void ExecutorBase<ResultType, OperationType>::Run(Datasource& parentDs, const uint8_t* data, const size_t size) const {\n    typename ExecutorBase<ResultType, OperationType>::ResultSet results;\n\n    std::vector< std::pair<std::shared_ptr<Module>, OperationType> > operations;\n\n    do {\n        auto op = getOp(&parentDs, data, size);\n        auto module = getModule(parentDs);\n        if ( module == nullptr ) {\n            continue;\n        }\n\n        operations.push_back( {module, op} );\n\n        /* Limit number of operations per run to prevent time-outs */\n        if ( operations.size() == OperationType::MaxOperations() ) {\n            break;\n        }\n    } while ( parentDs.Get<bool>() == true );\n\n    if ( operations.empty() == true ) {\n        return;\n    }\n\n    /* Enable this to run every operation on every loaded module */\n#if 1\n    {\n        std::set<uint64_t> moduleIDs;\n        for (const auto& m : modules ) {\n            const auto moduleID = m.first;\n\n            /* Skip if this is a disabled module */\n            if ( options.disableModules != std::nullopt ) {\n                if ( std::find(\n                            options.disableModules->begin(),\n                            options.disableModules->end(),\n                            moduleID) != options.disableModules->end() ) {\n                    continue;\n                }\n            }\n            moduleIDs.insert(moduleID);\n        }\n\n        std::set<uint64_t> operationModuleIDs;\n        for (const auto& op : operations) {\n            operationModuleIDs.insert(op.first->ID);\n        }\n\n        std::vector<uint64_t> addModuleIDs(moduleIDs.size());\n        auto it = std::set_difference(moduleIDs.begin(), moduleIDs.end(), operationModuleIDs.begin(), operationModuleIDs.end(), addModuleIDs.begin());\n        addModuleIDs.resize(it - addModuleIDs.begin());\n\n        for (const auto& id : addModuleIDs) {\n            operations.push_back({ modules.at(id), operations[0].second});\n        }\n    }\n#endif\n\n    if ( operations.size() < options.minModules ) {\n        return;\n    }\n\n    if ( options.debug == true && !operations.empty() ) {\n        printf(\"Running:\\n%s\\n\", operations[0].second.ToString().c_str());\n    }\n    for (size_t i = 0; i < operations.size(); i++) {\n        auto& operation = operations[i];\n\n        auto& module = operation.first;\n        auto& op = operation.second;\n\n        if ( i > 0 ) {\n            auto& prevModule = operations[i-1].first;\n            auto& prevOp = operations[i].second;\n\n            if ( prevModule == module && prevOp.modifier == op.modifier ) {\n                auto& curModifier = op.modifier.GetVectorPtr();\n                if ( curModifier.size() == 0 ) {\n                    for (size_t j = 0; j < 512; j++) {\n                        curModifier.push_back(1);\n                    }\n                } else {\n                    for (auto& c : curModifier) {\n                        c++;\n                    }\n                }\n            }\n        }\n\n        results.push_back( {module, std::move(callModule(module, op))} );\n\n        const auto& result = results.back();\n\n        if ( result.second != std::nullopt ) {\n            updateExtraCounters(module->ID, op);\n\n            if ( options.jsonDumpFP != std::nullopt ) {\n                nlohmann::json j;\n                j[\"operation\"] = op.ToJSON();\n                j[\"result\"] = util::ToJSON(*result.second);\n                fprintf(*options.jsonDumpFP, \"%s\\n\", j.dump().c_str());\n            }\n        }\n\n        if ( options.debug == true ) {\n            printf(\"Module %s result:\\n\\n%s\\n\\n\",\n                    result.first->name.c_str(),\n                    result.second == std::nullopt ?\n                        \"(empty)\" :\n                        util::ToString(*result.second).c_str());\n        }\n\n        if ( options.disableTests == false ) {\n            tests::test(op, result.second);\n        }\n\n        postprocess(module, op, result);\n    }\n\n    if ( options.noCompare == false ) {\n        compare(operations, results, data, size);\n    }\n}",
        "file_path": "/src/cryptofuzz/executor.cpp",
        "crashing_line": "        results.push_back( {module, std::move(callModule(module, op))} );",
        "crashing_line_number": 1353
      },
      {
        "function_name": "Run",
        "function_body": "void Driver::Run(const uint8_t* data, const size_t size) const {\n    using fuzzing::datasource::ID;\n\n    static ExecutorDigest executorDigest(CF_OPERATION(\"Digest\"), modules, options);\n    static ExecutorHMAC executorHMAC(CF_OPERATION(\"HMAC\"), modules, options);\n    static ExecutorCMAC executorCMAC(CF_OPERATION(\"CMAC\"), modules, options);\n    static ExecutorSymmetricEncrypt executorSymmetricEncrypt(CF_OPERATION(\"SymmetricEncrypt\"), modules, options);\n    static ExecutorSymmetricDecrypt executorSymmetricDecrypt(CF_OPERATION(\"SymmetricDecrypt\"), modules, options);\n    static ExecutorKDF_SCRYPT executorKDF_SCRYPT(CF_OPERATION(\"KDF_SCRYPT\"), modules, options);\n    static ExecutorKDF_HKDF executorKDF_HKDF(CF_OPERATION(\"KDF_HKDF\"), modules, options);\n    static ExecutorKDF_TLS1_PRF executorKDF_TLS1_PRF(CF_OPERATION(\"KDF_TLS1_PRF\"), modules, options);\n    static ExecutorKDF_PBKDF executorKDF_PBKDF(CF_OPERATION(\"KDF_PBKDF\"), modules, options);\n    static ExecutorKDF_PBKDF1 executorKDF_PBKDF1(CF_OPERATION(\"KDF_PBKDF1\"), modules, options);\n    static ExecutorKDF_PBKDF2 executorKDF_PBKDF2(CF_OPERATION(\"KDF_PBKDF2\"), modules, options);\n    static ExecutorKDF_ARGON2 executorKDF_ARGON2(CF_OPERATION(\"KDF_ARGON2\"), modules, options);\n    static ExecutorKDF_SSH executorKDF_SSH(ID(\"Cryptofuzz/Operation/KDF_SSH\"), modules, options);\n    static ExecutorKDF_X963 executorKDF_X963(CF_OPERATION(\"KDF_X963\"), modules, options);\n    static ExecutorKDF_BCRYPT executorKDF_BCRYPT(CF_OPERATION(\"KDF_BCRYPT\"), modules, options);\n    static ExecutorKDF_SP_800_108 executorKDF_SP_800_108(CF_OPERATION(\"KDF_SP_800_108\"), modules, options);\n    static ExecutorECC_PrivateToPublic executorECC_PrivateToPublic(CF_OPERATION(\"ECC_PrivateToPublic\"), modules, options);\n    static ExecutorECC_ValidatePubkey executorECC_ValidatePubkey(CF_OPERATION(\"ECC_ValidatePubkey\"), modules, options);\n    static ExecutorECC_GenerateKeyPair executorECC_GenerateKeyPair(CF_OPERATION(\"ECC_GenerateKeyPair\"), modules, options);\n    static ExecutorECDSA_Sign executorECDSA_Sign(CF_OPERATION(\"ECDSA_Sign\"), modules, options);\n    static ExecutorECDSA_Verify executorECDSA_Verify(CF_OPERATION(\"ECDSA_Verify\"), modules, options);\n    static ExecutorECDH_Derive executorECDH_Derive(CF_OPERATION(\"ECDH_Derive\"), modules, options);\n    static ExecutorECIES_Encrypt executorECIES_Encrypt(CF_OPERATION(\"ECIES_Encrypt\"), modules, options);\n    static ExecutorDH_GenerateKeyPair executorDH_GenerateKeyPair(CF_OPERATION(\"DH_GenerateKeyPair\"), modules, options);\n    static ExecutorDH_Derive executorDH_Derive(CF_OPERATION(\"DH_Derive\"), modules, options);\n    static ExecutorBignumCalc executorBignumCalc(CF_OPERATION(\"BignumCalc\"), modules, options);\n\n    try {\n\n        Datasource ds(data, size);\n\n        const auto operation = ds.Get<uint64_t>();\n\n        /* Only run whitelisted operations, if specified */\n        if ( options.operations != std::nullopt ) {\n            if ( std::find(\n                    options.operations->begin(),\n                    options.operations->end(),\n                    operation) == options.operations->end() ) {\n                return;\n            }\n        }\n        const auto payload = ds.GetData(0, 1);\n\n        switch ( operation ) {\n            case CF_OPERATION(\"Digest\"):\n                executorDigest.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"HMAC\"):\n                executorHMAC.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"CMAC\"):\n                executorCMAC.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"SymmetricEncrypt\"):\n                executorSymmetricEncrypt.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"SymmetricDecrypt\"):\n                executorSymmetricDecrypt.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_SCRYPT\"):\n                executorKDF_SCRYPT.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_HKDF\"):\n                executorKDF_HKDF.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_TLS1_PRF\"):\n                executorKDF_TLS1_PRF.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_PBKDF\"):\n                executorKDF_PBKDF.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_PBKDF1\"):\n                executorKDF_PBKDF1.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_PBKDF2\"):\n                executorKDF_PBKDF2.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_ARGON2\"):\n                executorKDF_ARGON2.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_SSH\"):\n                executorKDF_SSH.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_X963\"):\n                executorKDF_X963.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_BCRYPT\"):\n                executorKDF_BCRYPT.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_SP_800_108\"):\n                executorKDF_SP_800_108.Run(ds, payload.data(), payload.size());\n                break;\n#if 0\n            case    ID(\"Cryptofuzz/Operation/Sign\"):\n                executorSign.Run(ds, payload.data(), payload.size());\n                break;\n            case    ID(\"Cryptofuzz/Operation/Verify\"):\n                executorVerify.Run(ds, payload.data(), payload.size());\n                break;\n#endif\n            case CF_OPERATION(\"ECC_PrivateToPublic\"):\n                executorECC_PrivateToPublic.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECC_ValidatePubkey\"):\n                executorECC_ValidatePubkey.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECC_GenerateKeyPair\"):\n                executorECC_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECDSA_Sign\"):\n                executorECDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECDSA_Verify\"):\n                executorECDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECDH_Derive\"):\n                executorECDH_Derive.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECIES_Encrypt\"):\n                executorECIES_Encrypt.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"DH_GenerateKeyPair\"):\n                executorDH_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"DH_Derive\"):\n                executorDH_Derive.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"BignumCalc\"):\n                executorBignumCalc.Run(ds, payload.data(), payload.size());\n                break;\n        }\n    } catch ( Datasource::OutOfData ) {\n    }\n};",
        "file_path": "/src/cryptofuzz/driver.cpp",
        "crashing_line": "                executorBignumCalc.Run(ds, payload.data(), payload.size());",
        "crashing_line_number": 148
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "MEM_STATIC size_t\nZSTD_entropyCompressSeqStore_internal(seqStore_t* seqStorePtr,\n                          const ZSTD_entropyCTables_t* prevEntropy,\n                                ZSTD_entropyCTables_t* nextEntropy,\n                          const ZSTD_CCtx_params* cctxParams,\n                                void* dst, size_t dstCapacity,\n                                void* entropyWorkspace, size_t entropyWkspSize,\n                          const int bmi2)\n{\n    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;\n    ZSTD_strategy const strategy = cctxParams->cParams.strategy;\n    unsigned* count = (unsigned*)entropyWorkspace;\n    FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;\n    FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;\n    FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;\n    const seqDef* const sequences = seqStorePtr->sequencesStart;\n    const size_t nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n    const BYTE* const ofCodeTable = seqStorePtr->ofCode;\n    const BYTE* const llCodeTable = seqStorePtr->llCode;\n    const BYTE* const mlCodeTable = seqStorePtr->mlCode;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    size_t lastCountSize;\n\n    entropyWorkspace = count + (MaxSeq + 1);\n    entropyWkspSize -= (MaxSeq + 1) * sizeof(*count);\n\n    DEBUGLOG(5, \"ZSTD_entropyCompressSeqStore_internal (nbSeq=%zu)\", nbSeq);\n    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));\n    assert(entropyWkspSize >= HUF_WORKSPACE_SIZE);\n\n    /* Compress literals */\n    {   const BYTE* const literals = seqStorePtr->litStart;\n        size_t const numSequences = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n        size_t const numLiterals = seqStorePtr->lit - seqStorePtr->litStart;\n        /* Base suspicion of uncompressibility on ratio of literals to sequences */\n        unsigned const suspectUncompressible = (numSequences == 0) || (numLiterals / numSequences >= SUSPECT_UNCOMPRESSIBLE_LITERAL_RATIO);\n        size_t const litSize = (size_t)(seqStorePtr->lit - literals);\n        size_t const cSize = ZSTD_compressLiterals(\n                                    &prevEntropy->huf, &nextEntropy->huf,\n                                    cctxParams->cParams.strategy,\n                                    ZSTD_literalsCompressionIsDisabled(cctxParams),\n                                    op, dstCapacity,\n                                    literals, litSize,\n                                    entropyWorkspace, entropyWkspSize,\n                                    bmi2, suspectUncompressible);\n        FORWARD_IF_ERROR(cSize, \"ZSTD_compressLiterals failed\");\n        assert(cSize <= dstCapacity);\n        op += cSize;\n    }\n\n    /* Sequences Header */\n    RETURN_ERROR_IF((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/,\n                    dstSize_tooSmall, \"Can't fit seq hdr in output buf!\");\n    if (nbSeq < 128) {\n        *op++ = (BYTE)nbSeq;\n    } else if (nbSeq < LONGNBSEQ) {\n        op[0] = (BYTE)((nbSeq>>8) + 0x80);\n        op[1] = (BYTE)nbSeq;\n        op+=2;\n    } else {\n        op[0]=0xFF;\n        MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ));\n        op+=3;\n    }\n    assert(op <= oend);\n    if (nbSeq==0) {\n        /* Copy the old tables over as if we repeated them */\n        ZSTD_memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));\n        return (size_t)(op - ostart);\n    }\n    {   BYTE* seqHead = op++;\n        /* build stats for sequences */\n        const ZSTD_symbolEncodingTypeStats_t stats =\n                ZSTD_buildSequencesStatistics(seqStorePtr, nbSeq,\n                                             &prevEntropy->fse, &nextEntropy->fse,\n                                              op, oend,\n                                              strategy, count,\n                                              entropyWorkspace, entropyWkspSize);\n        FORWARD_IF_ERROR(stats.size, \"ZSTD_buildSequencesStatistics failed!\");\n        *seqHead = (BYTE)((stats.LLtype<<6) + (stats.Offtype<<4) + (stats.MLtype<<2));\n        lastCountSize = stats.lastCountSize;\n        op += stats.size;\n    }\n\n    {   size_t const bitstreamSize = ZSTD_encodeSequences(\n                                        op, (size_t)(oend - op),\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq,\n                                        longOffsets, bmi2);\n        FORWARD_IF_ERROR(bitstreamSize, \"ZSTD_encodeSequences failed\");\n        op += bitstreamSize;\n        assert(op <= oend);\n        /* zstd versions <= 1.3.4 mistakenly report corruption when\n         * FSE_readNCount() receives a buffer < 4 bytes.\n         * Fixed by https://github.com/facebook/zstd/pull/1146.\n         * This can happen when the last set_compressed table present is 2\n         * bytes and the bitstream is only one byte.\n         * In this exceedingly rare case, we will simply emit an uncompressed\n         * block, since it isn't worth optimizing.\n         */\n        if (lastCountSize && (lastCountSize + bitstreamSize) < 4) {\n            /* lastCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */\n            assert(lastCountSize + bitstreamSize == 3);\n            DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \"\n                        \"emitting an uncompressed block.\");\n            return 0;\n        }\n    }\n\n    DEBUGLOG(5, \"compressed block size : %u\", (unsigned)(op - ostart));\n    return (size_t)(op - ostart);\n}\nMEM_STATIC size_t\nZSTD_entropyCompressSeqStore(seqStore_t* seqStorePtr,\n                       const ZSTD_entropyCTables_t* prevEntropy,\n                             ZSTD_entropyCTables_t* nextEntropy,\n                       const ZSTD_CCtx_params* cctxParams,\n                             void* dst, size_t dstCapacity,\n                             size_t srcSize,\n                             void* entropyWorkspace, size_t entropyWkspSize,\n                             int bmi2)\n{\n    size_t const cSize = ZSTD_entropyCompressSeqStore_internal(\n                            seqStorePtr, prevEntropy, nextEntropy, cctxParams,\n                            dst, dstCapacity,\n                            entropyWorkspace, entropyWkspSize, bmi2);\n    if (cSize == 0) return 0;\n    /* When srcSize <= dstCapacity, there is enough space to write a raw uncompressed block.\n     * Since we ran out of space, block must be not compressible, so fall back to raw uncompressed block.\n     */\n    if ((cSize == ERROR(dstSize_tooSmall)) & (srcSize <= dstCapacity))\n        return 0;  /* block not compressed */\n    FORWARD_IF_ERROR(cSize, \"ZSTD_entropyCompressSeqStore_internal failed\");\n\n    /* Check compressibility */\n    {   size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, cctxParams->cParams.strategy);\n        if (cSize >= maxCSize) return 0;  /* block not compressed */\n    }\n    DEBUGLOG(4, \"ZSTD_entropyCompressSeqStore() cSize: %zu\", cSize);\n    return cSize;\n}\nstatic size_t\nZSTD_compressSequences_internal(ZSTD_CCtx* cctx,\n                                void* dst, size_t dstCapacity,\n                          const ZSTD_Sequence* inSeqs, size_t inSeqsSize,\n                          const void* src, size_t srcSize)\n{\n    size_t cSize = 0;\n    size_t remaining = srcSize;\n    ZSTD_sequencePosition seqPos = {0, 0, 0};\n\n    BYTE const* ip = (BYTE const*)src;\n    BYTE* op = (BYTE*)dst;\n    ZSTD_sequenceCopier const sequenceCopier = ZSTD_selectSequenceCopier(cctx->appliedParams.blockDelimiters);\n\n    DEBUGLOG(4, \"ZSTD_compressSequences_internal srcSize: %zu, inSeqsSize: %zu\", srcSize, inSeqsSize);\n    /* Special case: empty frame */\n    if (remaining == 0) {\n        U32 const cBlockHeader24 = 1 /* last block */ + (((U32)bt_raw)<<1);\n        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, \"No room for empty frame block header\");\n        MEM_writeLE32(op, cBlockHeader24);\n        op += ZSTD_blockHeaderSize;\n        dstCapacity -= ZSTD_blockHeaderSize;\n        cSize += ZSTD_blockHeaderSize;\n    }\n\n    while (remaining) {\n        size_t compressedSeqsSize;\n        size_t cBlockSize;\n        size_t additionalByteAdjustment;\n        size_t blockSize = determine_blockSize(cctx->appliedParams.blockDelimiters,\n                                        cctx->blockSize, remaining,\n                                        inSeqs, inSeqsSize, seqPos);\n        U32 const lastBlock = (blockSize == remaining);\n        FORWARD_IF_ERROR(blockSize, \"Error while trying to determine block size\");\n        assert(blockSize <= remaining);\n        ZSTD_resetSeqStore(&cctx->seqStore);\n        DEBUGLOG(5, \"Working on new block. Blocksize: %zu (total:%zu)\", blockSize, (ip - (const BYTE*)src) + blockSize);\n\n        additionalByteAdjustment = sequenceCopier(cctx, &seqPos, inSeqs, inSeqsSize, ip, blockSize);\n        FORWARD_IF_ERROR(additionalByteAdjustment, \"Bad sequence copy\");\n        blockSize -= additionalByteAdjustment;\n\n        /* If blocks are too small, emit as a nocompress block */\n        if (blockSize < MIN_CBLOCK_SIZE+ZSTD_blockHeaderSize+1) {\n            cBlockSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"Nocompress block failed\");\n            DEBUGLOG(5, \"Block too small, writing out nocompress block: cSize: %zu\", cBlockSize);\n            cSize += cBlockSize;\n            ip += blockSize;\n            op += cBlockSize;\n            remaining -= blockSize;\n            dstCapacity -= cBlockSize;\n            continue;\n        }\n\n        compressedSeqsSize = ZSTD_entropyCompressSeqStore(&cctx->seqStore,\n                                &cctx->blockState.prevCBlock->entropy, &cctx->blockState.nextCBlock->entropy,\n                                &cctx->appliedParams,\n                                op + ZSTD_blockHeaderSize /* Leave space for block header */, dstCapacity - ZSTD_blockHeaderSize,\n                                blockSize,\n                                cctx->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */,\n                                cctx->bmi2);\n        FORWARD_IF_ERROR(compressedSeqsSize, \"Compressing sequences of block failed\");\n        DEBUGLOG(5, \"Compressed sequences size: %zu\", compressedSeqsSize);\n\n        if (!cctx->isFirstBlock &&\n            ZSTD_maybeRLE(&cctx->seqStore) &&\n            ZSTD_isRLE((BYTE const*)src, srcSize)) {\n            /* We don't want to emit our first block as a RLE even if it qualifies because\n            * doing so will cause the decoder (cli only) to throw a \"should consume all input error.\"\n            * This is only an issue for zstd <= v1.4.3\n            */\n            compressedSeqsSize = 1;\n        }\n\n        if (compressedSeqsSize == 0) {\n            /* ZSTD_noCompressBlock writes the block header as well */\n            cBlockSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"Nocompress block failed\");\n            DEBUGLOG(5, \"Writing out nocompress block, size: %zu\", cBlockSize);\n        } else if (compressedSeqsSize == 1) {\n            cBlockSize = ZSTD_rleCompressBlock(op, dstCapacity, *ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"RLE compress block failed\");\n            DEBUGLOG(5, \"Writing out RLE block, size: %zu\", cBlockSize);\n        } else {\n            U32 cBlockHeader;\n            /* Error checking and repcodes update */\n            ZSTD_blockState_confirmRepcodesAndEntropyTables(&cctx->blockState);\n            if (cctx->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)\n                cctx->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;\n\n            /* Write block header into beginning of block*/\n            cBlockHeader = lastBlock + (((U32)bt_compressed)<<1) + (U32)(compressedSeqsSize << 3);\n            MEM_writeLE24(op, cBlockHeader);\n            cBlockSize = ZSTD_blockHeaderSize + compressedSeqsSize;\n            DEBUGLOG(5, \"Writing out compressed block, size: %zu\", cBlockSize);\n        }\n\n        cSize += cBlockSize;\n        DEBUGLOG(5, \"cSize running total: %zu\", cSize);\n\n        if (lastBlock) {\n            break;\n        } else {\n            ip += blockSize;\n            op += cBlockSize;\n            remaining -= blockSize;\n            dstCapacity -= cBlockSize;\n            cctx->isFirstBlock = 0;\n        }\n    }\n\n    DEBUGLOG(4, \"cSize final total: %zu\", cSize);\n    return cSize;\n}\nsize_t ZSTD_compressSequences(ZSTD_CCtx* cctx,\n                              void* dst, size_t dstCapacity,\n                              const ZSTD_Sequence* inSeqs, size_t inSeqsSize,\n                              const void* src, size_t srcSize)\n{\n    BYTE* op = (BYTE*)dst;\n    size_t cSize = 0;\n    size_t compressedBlocksSize = 0;\n    size_t frameHeaderSize = 0;\n\n    /* Transparent initialization stage, same as compressStream2() */\n    DEBUGLOG(3, \"ZSTD_compressSequences()\");\n    assert(cctx != NULL);\n    FORWARD_IF_ERROR(ZSTD_CCtx_init_compressStream2(cctx, ZSTD_e_end, srcSize), \"CCtx initialization failed\");\n    /* Begin writing output, starting with frame header */\n    frameHeaderSize = ZSTD_writeFrameHeader(op, dstCapacity, &cctx->appliedParams, srcSize, cctx->dictID);\n    op += frameHeaderSize;\n    dstCapacity -= frameHeaderSize;\n    cSize += frameHeaderSize;\n    if (cctx->appliedParams.fParams.checksumFlag && srcSize) {\n        XXH64_update(&cctx->xxhState, src, srcSize);\n    }\n    /* cSize includes block header size and compressed sequences size */\n    compressedBlocksSize = ZSTD_compressSequences_internal(cctx,\n                                                           op, dstCapacity,\n                                                           inSeqs, inSeqsSize,\n                                                           src, srcSize);\n    FORWARD_IF_ERROR(compressedBlocksSize, \"Compressing blocks failed!\");\n    cSize += compressedBlocksSize;\n    dstCapacity -= compressedBlocksSize;\n\n    if (cctx->appliedParams.fParams.checksumFlag) {\n        U32 const checksum = (U32) XXH64_digest(&cctx->xxhState);\n        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, \"no room for checksum\");\n        DEBUGLOG(4, \"Write checksum : %08X\", (unsigned)checksum);\n        MEM_writeLE32((char*)dst + cSize, checksum);\n        cSize += 4;\n    }\n\n    DEBUGLOG(3, \"Final compressed size: %zu\", cSize);\n    return cSize;\n}\nMEM_STATIC size_t ZSTD_noCompressBlock (void* dst, size_t dstCapacity, const void* src, size_t srcSize, U32 lastBlock)\n{\n    U32 const cBlockHeader24 = lastBlock + (((U32)bt_raw)<<1) + (U32)(srcSize << 3);\n    RETURN_ERROR_IF(srcSize + ZSTD_blockHeaderSize > dstCapacity,\n                    dstSize_tooSmall, \"dst buf too small for uncompressed block\");\n    MEM_writeLE24(dst, cBlockHeader24);\n    ZSTD_memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);\n    return ZSTD_blockHeaderSize + srcSize;\n}\nMEM_STATIC size_t ZSTD_rleCompressBlock (void* dst, size_t dstCapacity, BYTE src, size_t srcSize, U32 lastBlock)\n{\n    BYTE* const op = (BYTE*)dst;\n    U32 const cBlockHeader = lastBlock + (((U32)bt_rle)<<1) + (U32)(srcSize << 3);\n    RETURN_ERROR_IF(dstCapacity < 4, dstSize_tooSmall, \"\");\n    MEM_writeLE24(op, cBlockHeader);\n    op[3] = src;\n    return 4;\n}\nsize_t ZSTD_noCompressLiterals (void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    BYTE* const ostart = (BYTE*)dst;\n    U32   const flSize = 1 + (srcSize>31) + (srcSize>4095);\n\n    RETURN_ERROR_IF(srcSize + flSize > dstCapacity, dstSize_tooSmall, \"\");\n\n    switch(flSize)\n    {\n        case 1: /* 2 - 1 - 5 */\n            ostart[0] = (BYTE)((U32)set_basic + (srcSize<<3));\n            break;\n        case 2: /* 2 - 2 - 12 */\n            MEM_writeLE16(ostart, (U16)((U32)set_basic + (1<<2) + (srcSize<<4)));\n            break;\n        case 3: /* 2 - 2 - 20 */\n            MEM_writeLE32(ostart, (U32)((U32)set_basic + (3<<2) + (srcSize<<4)));\n            break;\n        default:   /* not necessary : flSize is {1,2,3} */\n            assert(0);\n    }\n\n    ZSTD_memcpy(ostart + flSize, src, srcSize);\n    DEBUGLOG(5, \"Raw (uncompressed) literals: %u -> %u\", (U32)srcSize, (U32)(srcSize + flSize));\n    return srcSize + flSize;\n}\nsize_t ZSTD_compressLiterals (ZSTD_hufCTables_t const* prevHuf,\n                              ZSTD_hufCTables_t* nextHuf,\n                              ZSTD_strategy strategy, int disableLiteralCompression,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize,\n                              void* entropyWorkspace, size_t entropyWorkspaceSize,\n                        const int bmi2,\n                        unsigned suspectUncompressible)\n{\n    size_t const minGain = ZSTD_minGain(srcSize, strategy);\n    size_t const lhSize = 3 + (srcSize >= 1 KB) + (srcSize >= 16 KB);\n    BYTE*  const ostart = (BYTE*)dst;\n    U32 singleStream = srcSize < 256;\n    symbolEncodingType_e hType = set_compressed;\n    size_t cLitSize;\n\n    DEBUGLOG(5,\"ZSTD_compressLiterals (disableLiteralCompression=%i srcSize=%u)\",\n                disableLiteralCompression, (U32)srcSize);\n\n    DEBUGLOG(6, \"Completed literals listing (%zu bytes)\", showHexa(src, srcSize));\n\n    /* Prepare nextEntropy assuming reusing the existing table */\n    ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n\n    if (disableLiteralCompression)\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n\n    /* small ? don't even attempt compression (speed opt) */\n#   define COMPRESS_LITERALS_SIZE_MIN 63\n    {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;\n        if (srcSize <= minLitSize) return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n\n    RETURN_ERROR_IF(dstCapacity < lhSize+1, dstSize_tooSmall, \"not enough space for compression\");\n    {   HUF_repeat repeat = prevHuf->repeatMode;\n        int const preferRepeat = (strategy < ZSTD_lazy) ? srcSize <= 1024 : 0;\n        typedef size_t (*huf_compress_f)(void*, size_t, const void*, size_t, unsigned, unsigned, void*, size_t, HUF_CElt*, HUF_repeat*, int, int, unsigned);\n        huf_compress_f huf_compress;\n        if (repeat == HUF_repeat_valid && lhSize == 3) singleStream = 1;\n        huf_compress = singleStream ? HUF_compress1X_repeat : HUF_compress4X_repeat;\n        cLitSize = huf_compress(ostart+lhSize, dstCapacity-lhSize,\n                                src, srcSize,\n                                HUF_SYMBOLVALUE_MAX, LitHufLog,\n                                entropyWorkspace, entropyWorkspaceSize,\n                                (HUF_CElt*)nextHuf->CTable,\n                                &repeat, preferRepeat,\n                                bmi2, suspectUncompressible);\n        if (repeat != HUF_repeat_none) {\n            /* reused the existing table */\n            DEBUGLOG(5, \"Reusing previous huffman table\");\n            hType = set_repeat;\n        }\n    }\n\n    if ((cLitSize==0) || (cLitSize >= srcSize - minGain) || ERR_isError(cLitSize)) {\n        ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n    if (cLitSize==1) {\n        ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_compressRleLiteralsBlock(dst, dstCapacity, src, srcSize);\n    }\n\n    if (hType == set_compressed) {\n        /* using a newly constructed table */\n        nextHuf->repeatMode = HUF_repeat_check;\n    }\n\n    /* Build header */\n    switch(lhSize)\n    {\n    case 3: /* 2 - 2 - 10 - 10 */\n        {   U32 const lhc = hType + ((U32)(!singleStream) << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<14);\n            MEM_writeLE24(ostart, lhc);\n            break;\n        }\n    case 4: /* 2 - 2 - 14 - 14 */\n        {   U32 const lhc = hType + (2 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<18);\n            MEM_writeLE32(ostart, lhc);\n            break;\n        }\n    case 5: /* 2 - 2 - 18 - 18 */\n        {   U32 const lhc = hType + (3 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<22);\n            MEM_writeLE32(ostart, lhc);\n            ostart[4] = (BYTE)(cLitSize >> 10);\n            break;\n        }\n    default:  /* not possible : lhSize is {3,4,5} */\n        assert(0);\n    }\n    DEBUGLOG(5, \"Compressed literals: %u -> %u\", (U32)srcSize, (U32)(lhSize+cLitSize));\n    return lhSize+cLitSize;\n}\n",
    "target": 1,
    "idx": 1044239,
    "stack_trace": [
      {
        "function_name": "ZSTD_noCompressLiterals",
        "function_body": "size_t ZSTD_noCompressLiterals (void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    BYTE* const ostart = (BYTE*)dst;\n    U32   const flSize = 1 + (srcSize>31) + (srcSize>4095);\n\n    DEBUGLOG(5, \"ZSTD_noCompressLiterals: srcSize=%zu, dstCapacity=%zu\", srcSize, dstCapacity);\n\n    RETURN_ERROR_IF(srcSize + flSize > dstCapacity, dstSize_tooSmall, \"\");\n\n    switch(flSize)\n    {\n        case 1: /* 2 - 1 - 5 */\n            ostart[0] = (BYTE)((U32)set_basic + (srcSize<<3));\n            break;\n        case 2: /* 2 - 2 - 12 */\n            MEM_writeLE16(ostart, (U16)((U32)set_basic + (1<<2) + (srcSize<<4)));\n            break;\n        case 3: /* 2 - 2 - 20 */\n            MEM_writeLE32(ostart, (U32)((U32)set_basic + (3<<2) + (srcSize<<4)));\n            break;\n        default:   /* not necessary : flSize is {1,2,3} */\n            assert(0);\n    }\n\n    ZSTD_memcpy(ostart + flSize, src, srcSize);\n    DEBUGLOG(5, \"Raw (uncompressed) literals: %u -> %u\", (U32)srcSize, (U32)(srcSize + flSize));\n    return srcSize + flSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress_literals.c",
        "crashing_line": "    {",
        "crashing_line_number": 49
      },
      {
        "function_name": "ZSTD_compressLiterals",
        "function_body": "size_t ZSTD_compressLiterals (ZSTD_hufCTables_t const* prevHuf,\n                              ZSTD_hufCTables_t* nextHuf,\n                              ZSTD_strategy strategy, int disableLiteralCompression,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize,\n                              void* entropyWorkspace, size_t entropyWorkspaceSize,\n                        const int bmi2,\n                        unsigned suspectUncompressible)\n{\n    size_t const minGain = ZSTD_minGain(srcSize, strategy);\n    size_t const lhSize = 3 + (srcSize >= 1 KB) + (srcSize >= 16 KB);\n    BYTE*  const ostart = (BYTE*)dst;\n    U32 singleStream = srcSize < 256;\n    symbolEncodingType_e hType = set_compressed;\n    size_t cLitSize;\n\n    DEBUGLOG(5,\"ZSTD_compressLiterals (disableLiteralCompression=%i, srcSize=%u, dstCapacity=%zu)\",\n                disableLiteralCompression, (U32)srcSize, dstCapacity);\n\n    DEBUGLOG(6, \"Completed literals listing (%zu bytes)\", showHexa(src, srcSize));\n\n    /* Prepare nextEntropy assuming reusing the existing table */\n    ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n\n    if (disableLiteralCompression)\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n\n    /* small ? don't even attempt compression (speed opt) */\n#   define COMPRESS_LITERALS_SIZE_MIN 63\n    {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;\n        if (srcSize <= minLitSize) return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n\n    RETURN_ERROR_IF(dstCapacity < lhSize+1, dstSize_tooSmall, \"not enough space for compression\");\n    {   HUF_repeat repeat = prevHuf->repeatMode;\n        int const preferRepeat = (strategy < ZSTD_lazy) ? srcSize <= 1024 : 0;\n        typedef size_t (*huf_compress_f)(void*, size_t, const void*, size_t, unsigned, unsigned, void*, size_t, HUF_CElt*, HUF_repeat*, int, int, unsigned);\n        huf_compress_f huf_compress;\n        if (repeat == HUF_repeat_valid && lhSize == 3) singleStream = 1;\n        huf_compress = singleStream ? HUF_compress1X_repeat : HUF_compress4X_repeat;\n        cLitSize = huf_compress(ostart+lhSize, dstCapacity-lhSize,\n                                src, srcSize,\n                                HUF_SYMBOLVALUE_MAX, LitHufLog,\n                                entropyWorkspace, entropyWorkspaceSize,\n                                (HUF_CElt*)nextHuf->CTable,\n                                &repeat, preferRepeat,\n                                bmi2, suspectUncompressible);\n        if (repeat != HUF_repeat_none) {\n            /* reused the existing table */\n            DEBUGLOG(5, \"Reusing previous huffman table\");\n            hType = set_repeat;\n        }\n    }\n\n    if ((cLitSize==0) || (cLitSize >= srcSize - minGain) || ERR_isError(cLitSize)) {\n        ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n    if (cLitSize==1) {\n        ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_compressRleLiteralsBlock(dst, dstCapacity, src, srcSize);\n    }\n\n    if (hType == set_compressed) {\n        /* using a newly constructed table */\n        nextHuf->repeatMode = HUF_repeat_check;\n    }\n\n    /* Build header */\n    switch(lhSize)\n    {\n    case 3: /* 2 - 2 - 10 - 10 */\n        {   U32 const lhc = hType + ((U32)(!singleStream) << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<14);\n            MEM_writeLE24(ostart, lhc);\n            break;\n        }\n    case 4: /* 2 - 2 - 14 - 14 */\n        {   U32 const lhc = hType + (2 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<18);\n            MEM_writeLE32(ostart, lhc);\n            break;\n        }\n    case 5: /* 2 - 2 - 18 - 18 */\n        {   U32 const lhc = hType + (3 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<22);\n            MEM_writeLE32(ostart, lhc);\n            ostart[4] = (BYTE)(cLitSize >> 10);\n            break;\n        }\n    default:  /* not possible : lhSize is {3,4,5} */\n        assert(0);\n    }\n    DEBUGLOG(5, \"Compressed literals: %u -> %u\", (U32)srcSize, (U32)(lhSize+cLitSize));\n    return lhSize+cLitSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress_literals.c",
        "crashing_line": "",
        "crashing_line_number": 118
      },
      {
        "function_name": "ZSTD_entropyCompressSeqStore_internal",
        "function_body": "MEM_STATIC size_t\nZSTD_entropyCompressSeqStore_internal(seqStore_t* seqStorePtr,\n                          const ZSTD_entropyCTables_t* prevEntropy,\n                                ZSTD_entropyCTables_t* nextEntropy,\n                          const ZSTD_CCtx_params* cctxParams,\n                                void* dst, size_t dstCapacity,\n                                void* entropyWorkspace, size_t entropyWkspSize,\n                          const int bmi2)\n{\n    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;\n    ZSTD_strategy const strategy = cctxParams->cParams.strategy;\n    unsigned* count = (unsigned*)entropyWorkspace;\n    FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;\n    FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;\n    FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;\n    const seqDef* const sequences = seqStorePtr->sequencesStart;\n    const size_t nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n    const BYTE* const ofCodeTable = seqStorePtr->ofCode;\n    const BYTE* const llCodeTable = seqStorePtr->llCode;\n    const BYTE* const mlCodeTable = seqStorePtr->mlCode;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    size_t lastCountSize;\n\n    entropyWorkspace = count + (MaxSeq + 1);\n    entropyWkspSize -= (MaxSeq + 1) * sizeof(*count);\n\n    DEBUGLOG(5, \"ZSTD_entropyCompressSeqStore_internal (nbSeq=%zu, dstCapacity=%zu)\", nbSeq, dstCapacity);\n    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));\n    assert(entropyWkspSize >= HUF_WORKSPACE_SIZE);\n\n    /* Compress literals */\n    {   const BYTE* const literals = seqStorePtr->litStart;\n        size_t const numSequences = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n        size_t const numLiterals = seqStorePtr->lit - seqStorePtr->litStart;\n        /* Base suspicion of uncompressibility on ratio of literals to sequences */\n        unsigned const suspectUncompressible = (numSequences == 0) || (numLiterals / numSequences >= SUSPECT_UNCOMPRESSIBLE_LITERAL_RATIO);\n        size_t const litSize = (size_t)(seqStorePtr->lit - literals);\n        size_t const cSize = ZSTD_compressLiterals(\n                                    &prevEntropy->huf, &nextEntropy->huf,\n                                    cctxParams->cParams.strategy,\n                                    ZSTD_literalsCompressionIsDisabled(cctxParams),\n                                    op, dstCapacity,\n                                    literals, litSize,\n                                    entropyWorkspace, entropyWkspSize,\n                                    bmi2, suspectUncompressible);\n        FORWARD_IF_ERROR(cSize, \"ZSTD_compressLiterals failed\");\n        assert(cSize <= dstCapacity);\n        op += cSize;\n    }\n\n    /* Sequences Header */\n    RETURN_ERROR_IF((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/,\n                    dstSize_tooSmall, \"Can't fit seq hdr in output buf!\");\n    if (nbSeq < 128) {\n        *op++ = (BYTE)nbSeq;\n    } else if (nbSeq < LONGNBSEQ) {\n        op[0] = (BYTE)((nbSeq>>8) + 0x80);\n        op[1] = (BYTE)nbSeq;\n        op+=2;\n    } else {\n        op[0]=0xFF;\n        MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ));\n        op+=3;\n    }\n    assert(op <= oend);\n    if (nbSeq==0) {\n        /* Copy the old tables over as if we repeated them */\n        ZSTD_memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));\n        return (size_t)(op - ostart);\n    }\n    {   BYTE* const seqHead = op++;\n        /* build stats for sequences */\n        const ZSTD_symbolEncodingTypeStats_t stats =\n                ZSTD_buildSequencesStatistics(seqStorePtr, nbSeq,\n                                             &prevEntropy->fse, &nextEntropy->fse,\n                                              op, oend,\n                                              strategy, count,\n                                              entropyWorkspace, entropyWkspSize);\n        FORWARD_IF_ERROR(stats.size, \"ZSTD_buildSequencesStatistics failed!\");\n        *seqHead = (BYTE)((stats.LLtype<<6) + (stats.Offtype<<4) + (stats.MLtype<<2));\n        lastCountSize = stats.lastCountSize;\n        op += stats.size;\n    }\n\n    {   size_t const bitstreamSize = ZSTD_encodeSequences(\n                                        op, (size_t)(oend - op),\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq,\n                                        longOffsets, bmi2);\n        FORWARD_IF_ERROR(bitstreamSize, \"ZSTD_encodeSequences failed\");\n        op += bitstreamSize;\n        assert(op <= oend);\n        /* zstd versions <= 1.3.4 mistakenly report corruption when\n         * FSE_readNCount() receives a buffer < 4 bytes.\n         * Fixed by https://github.com/facebook/zstd/pull/1146.\n         * This can happen when the last set_compressed table present is 2\n         * bytes and the bitstream is only one byte.\n         * In this exceedingly rare case, we will simply emit an uncompressed\n         * block, since it isn't worth optimizing.\n         */\n        if (lastCountSize && (lastCountSize + bitstreamSize) < 4) {\n            /* lastCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */\n            assert(lastCountSize + bitstreamSize == 3);\n            DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \"\n                        \"emitting an uncompressed block.\");\n            return 0;\n        }\n    }\n\n    DEBUGLOG(5, \"compressed block size : %u\", (unsigned)(op - ostart));\n    return (size_t)(op - ostart);\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "        size_t const cSize = ZSTD_compressLiterals(",
        "crashing_line_number": 2609
      },
      {
        "function_name": "ZSTD_entropyCompressSeqStore",
        "function_body": "MEM_STATIC size_t\nZSTD_entropyCompressSeqStore(seqStore_t* seqStorePtr,\n                       const ZSTD_entropyCTables_t* prevEntropy,\n                             ZSTD_entropyCTables_t* nextEntropy,\n                       const ZSTD_CCtx_params* cctxParams,\n                             void* dst, size_t dstCapacity,\n                             size_t srcSize,\n                             void* entropyWorkspace, size_t entropyWkspSize,\n                             int bmi2)\n{\n    size_t const cSize = ZSTD_entropyCompressSeqStore_internal(\n                            seqStorePtr, prevEntropy, nextEntropy, cctxParams,\n                            dst, dstCapacity,\n                            entropyWorkspace, entropyWkspSize, bmi2);\n    if (cSize == 0) return 0;\n    /* When srcSize <= dstCapacity, there is enough space to write a raw uncompressed block.\n     * Since we ran out of space, block must be not compressible, so fall back to raw uncompressed block.\n     */\n    if ((cSize == ERROR(dstSize_tooSmall)) & (srcSize <= dstCapacity)) {\n        DEBUGLOG(4, \"not enough dstCapacity (%zu) for ZSTD_entropyCompressSeqStore_internal()=> do not compress block\", dstCapacity);\n        return 0;  /* block not compressed */\n    }\n    FORWARD_IF_ERROR(cSize, \"ZSTD_entropyCompressSeqStore_internal failed\");\n\n    /* Check compressibility */\n    {   size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, cctxParams->cParams.strategy);\n        if (cSize >= maxCSize) return 0;  /* block not compressed */\n    }\n    DEBUGLOG(5, \"ZSTD_entropyCompressSeqStore() cSize: %zu\", cSize);\n    return cSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "    size_t const cSize = ZSTD_entropyCompressSeqStore_internal(",
        "crashing_line_number": 2697
      },
      {
        "function_name": "ZSTD_compressSequences_internal",
        "function_body": "static size_t\nZSTD_compressSequences_internal(ZSTD_CCtx* cctx,\n                                void* dst, size_t dstCapacity,\n                          const ZSTD_Sequence* inSeqs, size_t inSeqsSize,\n                          const void* src, size_t srcSize)\n{\n    size_t cSize = 0;\n    size_t remaining = srcSize;\n    ZSTD_sequencePosition seqPos = {0, 0, 0};\n\n    BYTE const* ip = (BYTE const*)src;\n    BYTE* op = (BYTE*)dst;\n    ZSTD_sequenceCopier const sequenceCopier = ZSTD_selectSequenceCopier(cctx->appliedParams.blockDelimiters);\n\n    DEBUGLOG(4, \"ZSTD_compressSequences_internal srcSize: %zu, inSeqsSize: %zu\", srcSize, inSeqsSize);\n    /* Special case: empty frame */\n    if (remaining == 0) {\n        U32 const cBlockHeader24 = 1 /* last block */ + (((U32)bt_raw)<<1);\n        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, \"No room for empty frame block header\");\n        MEM_writeLE32(op, cBlockHeader24);\n        op += ZSTD_blockHeaderSize;\n        dstCapacity -= ZSTD_blockHeaderSize;\n        cSize += ZSTD_blockHeaderSize;\n    }\n\n    while (remaining) {\n        size_t compressedSeqsSize;\n        size_t cBlockSize;\n        size_t additionalByteAdjustment;\n        size_t blockSize = determine_blockSize(cctx->appliedParams.blockDelimiters,\n                                        cctx->blockSize, remaining,\n                                        inSeqs, inSeqsSize, seqPos);\n        U32 const lastBlock = (blockSize == remaining);\n        FORWARD_IF_ERROR(blockSize, \"Error while trying to determine block size\");\n        assert(blockSize <= remaining);\n        ZSTD_resetSeqStore(&cctx->seqStore);\n        DEBUGLOG(5, \"Working on new block. Blocksize: %zu (total:%zu)\", blockSize, (ip - (const BYTE*)src) + blockSize);\n\n        additionalByteAdjustment = sequenceCopier(cctx, &seqPos, inSeqs, inSeqsSize, ip, blockSize);\n        FORWARD_IF_ERROR(additionalByteAdjustment, \"Bad sequence copy\");\n        blockSize -= additionalByteAdjustment;\n\n        /* If blocks are too small, emit as a nocompress block */\n        if (blockSize < MIN_CBLOCK_SIZE+ZSTD_blockHeaderSize+1) {\n            cBlockSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"Nocompress block failed\");\n            DEBUGLOG(5, \"Block too small, writing out nocompress block: cSize: %zu\", cBlockSize);\n            cSize += cBlockSize;\n            ip += blockSize;\n            op += cBlockSize;\n            remaining -= blockSize;\n            dstCapacity -= cBlockSize;\n            continue;\n        }\n\n        RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall, \"not enough dstCapacity to write a new compressed block\");\n        compressedSeqsSize = ZSTD_entropyCompressSeqStore(&cctx->seqStore,\n                                &cctx->blockState.prevCBlock->entropy, &cctx->blockState.nextCBlock->entropy,\n                                &cctx->appliedParams,\n                                op + ZSTD_blockHeaderSize /* Leave space for block header */, dstCapacity - ZSTD_blockHeaderSize,\n                                blockSize,\n                                cctx->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */,\n                                cctx->bmi2);\n        FORWARD_IF_ERROR(compressedSeqsSize, \"Compressing sequences of block failed\");\n        DEBUGLOG(5, \"Compressed sequences size: %zu\", compressedSeqsSize);\n\n        if (!cctx->isFirstBlock &&\n            ZSTD_maybeRLE(&cctx->seqStore) &&\n            ZSTD_isRLE((BYTE const*)src, srcSize)) {\n            /* We don't want to emit our first block as a RLE even if it qualifies because\n            * doing so will cause the decoder (cli only) to throw a \"should consume all input error.\"\n            * This is only an issue for zstd <= v1.4.3\n            */\n            compressedSeqsSize = 1;\n        }\n\n        if (compressedSeqsSize == 0) {\n            /* ZSTD_noCompressBlock writes the block header as well */\n            cBlockSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"ZSTD_noCompressBlock failed\");\n            DEBUGLOG(5, \"Writing out nocompress block, size: %zu\", cBlockSize);\n        } else if (compressedSeqsSize == 1) {\n            cBlockSize = ZSTD_rleCompressBlock(op, dstCapacity, *ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"ZSTD_rleCompressBlock failed\");\n            DEBUGLOG(5, \"Writing out RLE block, size: %zu\", cBlockSize);\n        } else {\n            U32 cBlockHeader;\n            /* Error checking and repcodes update */\n            ZSTD_blockState_confirmRepcodesAndEntropyTables(&cctx->blockState);\n            if (cctx->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)\n                cctx->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;\n\n            /* Write block header into beginning of block*/\n            cBlockHeader = lastBlock + (((U32)bt_compressed)<<1) + (U32)(compressedSeqsSize << 3);\n            MEM_writeLE24(op, cBlockHeader);\n            cBlockSize = ZSTD_blockHeaderSize + compressedSeqsSize;\n            DEBUGLOG(5, \"Writing out compressed block, size: %zu\", cBlockSize);\n        }\n\n        cSize += cBlockSize;\n\n        if (lastBlock) {\n            break;\n        } else {\n            ip += blockSize;\n            op += cBlockSize;\n            remaining -= blockSize;\n            dstCapacity -= cBlockSize;\n            cctx->isFirstBlock = 0;\n        }\n        DEBUGLOG(5, \"cSize running total: %zu (remaining dstCapacity=%zu)\", cSize, dstCapacity);\n    }\n\n    DEBUGLOG(4, \"cSize final total: %zu\", cSize);\n    return cSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "        }",
        "crashing_line_number": 6162
      },
      {
        "function_name": "ZSTD_compressSequences",
        "function_body": "size_t ZSTD_compressSequences(ZSTD_CCtx* cctx,\n                              void* dst, size_t dstCapacity,\n                              const ZSTD_Sequence* inSeqs, size_t inSeqsSize,\n                              const void* src, size_t srcSize)\n{\n    BYTE* op = (BYTE*)dst;\n    size_t cSize = 0;\n    size_t compressedBlocksSize = 0;\n    size_t frameHeaderSize = 0;\n\n    /* Transparent initialization stage, same as compressStream2() */\n    DEBUGLOG(4, \"ZSTD_compressSequences (dstCapacity=%zu)\", dstCapacity);\n    assert(cctx != NULL);\n    FORWARD_IF_ERROR(ZSTD_CCtx_init_compressStream2(cctx, ZSTD_e_end, srcSize), \"CCtx initialization failed\");\n    /* Begin writing output, starting with frame header */\n    frameHeaderSize = ZSTD_writeFrameHeader(op, dstCapacity, &cctx->appliedParams, srcSize, cctx->dictID);\n    op += frameHeaderSize;\n    dstCapacity -= frameHeaderSize;\n    cSize += frameHeaderSize;\n    if (cctx->appliedParams.fParams.checksumFlag && srcSize) {\n        XXH64_update(&cctx->xxhState, src, srcSize);\n    }\n    /* cSize includes block header size and compressed sequences size */\n    compressedBlocksSize = ZSTD_compressSequences_internal(cctx,\n                                                           op, dstCapacity,\n                                                           inSeqs, inSeqsSize,\n                                                           src, srcSize);\n    FORWARD_IF_ERROR(compressedBlocksSize, \"Compressing blocks failed!\");\n    cSize += compressedBlocksSize;\n    dstCapacity -= compressedBlocksSize;\n\n    if (cctx->appliedParams.fParams.checksumFlag) {\n        U32 const checksum = (U32) XXH64_digest(&cctx->xxhState);\n        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, \"no room for checksum\");\n        DEBUGLOG(4, \"Write checksum : %08X\", (unsigned)checksum);\n        MEM_writeLE32((char*)dst + cSize, checksum);\n        cSize += 4;\n    }\n\n    DEBUGLOG(4, \"Final compressed size: %zu\", cSize);\n    return cSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "        XXH64_update(&cctx->xxhState, src, srcSize);",
        "crashing_line_number": 6246
      },
      {
        "function_name": "roundTripTest",
        "function_body": "static size_t roundTripTest(void* result, size_t resultCapacity,\n                            void* compressed, size_t compressedCapacity,\n                            const void* src, size_t srcSize,\n                            const void* dict, size_t dictSize,\n                            const ZSTD_Sequence* seqs, size_t seqSize,\n                            int wLog, int cLevel, unsigned hasDict,\n                            ZSTD_sequenceFormat_e mode)\n{\n    size_t cSize;\n    size_t dSize;\n\n    ZSTD_CCtx_reset(cctx, ZSTD_reset_session_and_parameters);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_nbWorkers, 0);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_compressionLevel, cLevel);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_windowLog, wLog);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_minMatch, ZSTD_MINMATCH_MIN);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_validateSequences, 1);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_blockDelimiters, mode);\n    if (hasDict) {\n        FUZZ_ZASSERT(ZSTD_CCtx_loadDictionary(cctx, dict, dictSize));\n        FUZZ_ZASSERT(ZSTD_DCtx_loadDictionary(dctx, dict, dictSize));\n    }\n\n    cSize = ZSTD_compressSequences(cctx, compressed, compressedCapacity,\n                                   seqs, seqSize,\n                                   src, srcSize);\n    if ( (ZSTD_getErrorCode(cSize) == ZSTD_error_dstSize_tooSmall)\n      && (mode == ZSTD_sf_explicitBlockDelimiters) ) {\n        /* Valid scenario : in explicit delimiter mode,\n         * it might be possible for the compressed size to outgrow dstCapacity.\n         * In which case, it's still a valid fuzzer scenario,\n         * but no roundtrip shall be possible */\n        return 0;\n    }\n    /* round-trip */\n    FUZZ_ZASSERT(cSize);\n    dSize = ZSTD_decompressDCtx(dctx, result, resultCapacity, compressed, cSize);\n    FUZZ_ZASSERT(dSize);\n    FUZZ_ASSERT_MSG(dSize == srcSize, \"Incorrect regenerated size\");\n    FUZZ_ASSERT_MSG(!FUZZ_memcmp(src, result, srcSize), \"Corruption!\");\n    return dSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/sequence_compression_api.c",
        "crashing_line": "    cSize = ZSTD_compressSequences(cctx, compressed, compressedCapacity,",
        "crashing_line_number": 247
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void log_query(unsigned int flags, char *name, union all_addr *addr, char *arg)\n{\n  char *source, *dest = daemon->addrbuff;\n  char *verb = \"is\";\n  char *extra = \"\";\n  \n  if (!option_bool(OPT_LOG))\n    return;\n\n  name = sanitise(name);\n\n  if (addr)\n    {\n      if (flags & F_KEYTAG)\n\tsprintf(daemon->addrbuff, arg, addr->log.keytag, addr->log.algo, addr->log.digest);\n      else if (flags & F_RCODE)\n\t{\n\t  unsigned int rcode = addr->log.rcode;\n\n\t  if (rcode == SERVFAIL)\n\t    dest = \"SERVFAIL\";\n\t  else if (rcode == REFUSED)\n\t    dest = \"REFUSED\";\n\t  else if (rcode == NOTIMP)\n\t    dest = \"not implemented\";\n\t  else\n\t    sprintf(daemon->addrbuff, \"%u\", rcode);\n\n\t  if (addr->log.ede != EDE_UNSET)\n\t    {\n\t      extra = daemon->addrbuff;\n\t      sprintf(extra, \" (EDE: %s)\", edestr(addr->log.ede));\n\t    }\n\t}\n      else\n\tinet_ntop(flags & F_IPV4 ? AF_INET : AF_INET6,\n\t\t  addr, daemon->addrbuff, ADDRSTRLEN);\n      \n    }\n  else\n    dest = arg;\n\n  if (flags & F_REVERSE)\n    {\n      dest = name;\n      name = daemon->addrbuff;\n    }\n  \n  if (flags & F_NEG)\n    {\n      if (flags & F_NXDOMAIN)\n\tdest = \"NXDOMAIN\";\n      else\n\t{      \n\t  if (flags & F_IPV4)\n\t    dest = \"NODATA-IPv4\";\n\t  else if (flags & F_IPV6)\n\t    dest = \"NODATA-IPv6\";\n\t  else\n\t    dest = \"NODATA\";\n\t}\n    }\n  else if (flags & F_CNAME)\n    dest = \"<CNAME>\";\n  else if (flags & F_SRV)\n    dest = \"<SRV>\";\n  else if (flags & F_RRNAME)\n    dest = arg;\n    \n  if (flags & F_CONFIG)\n    source = \"config\";\n  else if (flags & F_DHCP)\n    source = \"DHCP\";\n  else if (flags & F_HOSTS)\n    source = arg;\n  else if (flags & F_UPSTREAM)\n    source = \"reply\";\n  else if (flags & F_SECSTAT)\n    {\n      if (addr && addr->log.ede != EDE_UNSET && option_bool(OPT_EXTRALOG))\n\t{\n\t  extra = daemon->addrbuff;\n\t  sprintf(extra, \" (EDE: %s)\", edestr(addr->log.ede));\n\t}\n      source = \"validation\";\n      dest = arg;\n    }\n  else if (flags & F_AUTH)\n    source = \"auth\";\n  else if (flags & F_SERVER)\n    {\n      source = \"forwarded\";\n      verb = \"to\";\n    }\n  else if (flags & F_QUERY)\n    {\n      source = arg;\n      verb = \"from\";\n    }\n  else if (flags & F_DNSSEC)\n    {\n      source = arg;\n      verb = \"to\";\n    }\n  else if (flags & F_IPSET)\n    {\n      source = \"ipset add\";\n      dest = name;\n      name = arg;\n      verb = daemon->addrbuff;\n    }\n  else\n    source = \"cached\";\n  \n  if (strlen(name) == 0)\n    name = \".\";\n\n  if (option_bool(OPT_EXTRALOG))\n    {\n      if (flags & F_NOEXTRA)\n\tmy_syslog(LOG_INFO, \"%u %s %s %s %s%s\", daemon->log_display_id, source, name, verb, dest, extra);\n      else\n\t{\n\t   int port = prettyprint_addr(daemon->log_source_addr, daemon->addrbuff2);\n\t   my_syslog(LOG_INFO, \"%u %s/%u %s %s %s %s%s\", daemon->log_display_id, daemon->addrbuff2, port, source, name, verb, dest, extra);\n\t}\n    }\n  else\n    my_syslog(LOG_INFO, \"%s %s %s %s%s\", source, name, verb, dest, extra);\n}\nstatic int find_soa(struct dns_header *header, size_t qlen, char *name, int *doctored)\n{\n  unsigned char *p;\n  int qtype, qclass, rdlen;\n  unsigned long ttl, minttl = ULONG_MAX;\n  int i, found_soa = 0;\n  \n  /* first move to NS section and find TTL from any SOA section */\n  if (!(p = skip_questions(header, qlen)) ||\n      !(p = do_doctor(p, ntohs(header->ancount), header, qlen, name, doctored)))\n    return 0;  /* bad packet */\n  \n  for (i = ntohs(header->nscount); i != 0; i--)\n    {\n      if (!(p = skip_name(p, header, qlen, 10)))\n\treturn 0; /* bad packet */\n      \n      GETSHORT(qtype, p); \n      GETSHORT(qclass, p);\n      GETLONG(ttl, p);\n      GETSHORT(rdlen, p);\n      \n      if ((qclass == C_IN) && (qtype == T_SOA))\n\t{\n\t  found_soa = 1;\n\t  if (ttl < minttl)\n\t    minttl = ttl;\n\n\t  /* MNAME */\n\t  if (!(p = skip_name(p, header, qlen, 0)))\n\t    return 0;\n\t  /* RNAME */\n\t  if (!(p = skip_name(p, header, qlen, 20)))\n\t    return 0;\n\t  p += 16; /* SERIAL REFRESH RETRY EXPIRE */\n\t  \n\t  GETLONG(ttl, p); /* minTTL */\n\t  if (ttl < minttl)\n\t    minttl = ttl;\n\t}\n      else if (!ADD_RDLEN(header, p, qlen, rdlen))\n\treturn 0; /* bad packet */\n    }\n  \n  /* rewrite addresses in additional section too */\n  if (!do_doctor(p, ntohs(header->arcount), header, qlen, NULL, doctored))\n    return 0;\n  \n  if (!found_soa)\n    minttl = daemon->neg_ttl;\n\n  return minttl;\n}\nint extract_addresses(struct dns_header *header, size_t qlen, char *name, time_t now, \n\t\t      char **ipsets, int is_sign, int check_rebind, int no_cache_dnssec,\n\t\t      int secure, int *doctored)\n{\n  unsigned char *p, *p1, *endrr, *namep;\n  int i, j, qtype, qclass, aqtype, aqclass, ardlen, res, searched_soa = 0;\n  unsigned long ttl = 0;\n  union all_addr addr;\n#ifdef HAVE_IPSET\n  char **ipsets_cur;\n#else\n  (void)ipsets; /* unused */\n#endif\n\n  \n  cache_start_insert();\n\n  /* find_soa is needed for dns_doctor and logging side-effects, so don't call it lazily if there are any. */\n  if (daemon->doctors || option_bool(OPT_LOG) || option_bool(OPT_DNSSEC_VALID))\n    {\n      searched_soa = 1;\n      ttl = find_soa(header, qlen, name, doctored);\n\n      if (*doctored)\n\t{\n\t  if (secure)\n\t    return 0;\n#ifdef HAVE_DNSSEC\n\t  if (option_bool(OPT_DNSSEC_VALID))\n\t    for (i = 0; i < ntohs(header->ancount); i++)\n\t      if (daemon->rr_status[i] != 0)\n\t\treturn 0;\n#endif\n\t}\n    }\n  \n  /* go through the questions. */\n  p = (unsigned char *)(header+1);\n  \n  for (i = ntohs(header->qdcount); i != 0; i--)\n    {\n      int found = 0, cname_count = CNAME_CHAIN;\n      struct crec *cpp = NULL;\n      int flags = RCODE(header) == NXDOMAIN ? F_NXDOMAIN : 0;\n#ifdef HAVE_DNSSEC\n      int cname_short = 0;\n#endif\n      unsigned long cttl = ULONG_MAX, attl;\n\n      namep = p;\n      if (!extract_name(header, qlen, &p, name, 1, 4))\n\treturn 0; /* bad packet */\n           \n      GETSHORT(qtype, p); \n      GETSHORT(qclass, p);\n      \n      if (qclass != C_IN)\n\tcontinue;\n\n      /* PTRs: we chase CNAMEs here, since we have no way to \n\t represent them in the cache. */\n      if (qtype == T_PTR)\n\t{ \n\t  int name_encoding = in_arpa_name_2_addr(name, &addr);\n\t  \n\t  if (!name_encoding)\n\t    continue;\n\n\t  if (!(flags & F_NXDOMAIN))\n\t    {\n\t    cname_loop:\n\t      if (!(p1 = skip_questions(header, qlen)))\n\t\treturn 0;\n\t      \n\t      for (j = 0; j < ntohs(header->ancount); j++) \n\t\t{\n\t\t  int secflag = 0;\n\t\t  unsigned char *tmp = namep;\n\t\t  /* the loop body overwrites the original name, so get it back here. */\n\t\t  if (!extract_name(header, qlen, &tmp, name, 1, 0) ||\n\t\t      !(res = extract_name(header, qlen, &p1, name, 0, 10)))\n\t\t    return 0; /* bad packet */\n\t\t  \n\t\t  GETSHORT(aqtype, p1); \n\t\t  GETSHORT(aqclass, p1);\n\t\t  GETLONG(attl, p1);\n\t\t  if ((daemon->max_ttl != 0) && (attl > daemon->max_ttl) && !is_sign)\n\t\t    {\n\t\t      (p1) -= 4;\n\t\t      PUTLONG(daemon->max_ttl, p1);\n\t\t    }\n\t\t  GETSHORT(ardlen, p1);\n\t\t  endrr = p1+ardlen;\n\t\t  \n\t\t  /* TTL of record is minimum of CNAMES and PTR */\n\t\t  if (attl < cttl)\n\t\t    cttl = attl;\n\n\t\t  if (aqclass == C_IN && res != 2 && (aqtype == T_CNAME || aqtype == T_PTR))\n\t\t    {\n\t\t      if (!extract_name(header, qlen, &p1, name, 1, 0))\n\t\t\treturn 0;\n#ifdef HAVE_DNSSEC\n\t\t      if (option_bool(OPT_DNSSEC_VALID) && daemon->rr_status[j] != 0)\n\t\t\t{\n\t\t\t  /* validated RR anywhere in CNAME chain, don't cache. */\n\t\t\t  if (cname_short || aqtype == T_CNAME)\n\t\t\t    return 0;\n\n\t\t\t  secflag = F_DNSSECOK;\n\t\t\t  /* limit TTL based on signature. */\n\t\t\t  if (daemon->rr_status[j] < cttl)\n\t\t\t    cttl = daemon->rr_status[j];\n\t\t\t}\n#endif\n\n\t\t      if (aqtype == T_CNAME)\n\t\t\t{\n\t\t\t  if (!cname_count--)\n\t\t\t    return 0; /* looped CNAMES, we can't cache. */\n#ifdef HAVE_DNSSEC\n\t\t\t  cname_short = 1;\n#endif\n\t\t\t  goto cname_loop;\n\t\t\t}\n\t\t      \n\t\t      cache_insert(name, &addr, C_IN, now, cttl, name_encoding | secflag | F_REVERSE);\n\t\t      found = 1; \n\t\t    }\n\t\t  \n\t\t  p1 = endrr;\n\t\t  if (!CHECK_LEN(header, p1, qlen, 0))\n\t\t    return 0; /* bad packet */\n\t\t}\n\t    }\n\t  \n\t   if (!found && !option_bool(OPT_NO_NEG))\n\t    {\n\t      if (!searched_soa)\n\t\t{\n\t\t  searched_soa = 1;\n\t\t  ttl = find_soa(header, qlen, NULL, doctored);\n\t\t}\n\t      if (ttl)\n\t\tcache_insert(NULL, &addr, C_IN, now, ttl, name_encoding | F_REVERSE | F_NEG | flags | (secure ?  F_DNSSECOK : 0));\t\n\t    }\n\t}\n      else\n\t{\n\t  /* everything other than PTR */\n\t  struct crec *newc;\n\t  int addrlen = 0;\n\n\t  if (qtype == T_A)\n\t    {\n\t      addrlen = INADDRSZ;\n\t      flags |= F_IPV4;\n\t    }\n\t  else if (qtype == T_AAAA)\n\t    {\n\t      addrlen = IN6ADDRSZ;\n\t      flags |= F_IPV6;\n\t    }\n\t  else if (qtype == T_SRV)\n\t    flags |= F_SRV;\n\t  else\n\t    continue;\n\t    \n\tcname_loop1:\n\t  if (!(p1 = skip_questions(header, qlen)))\n\t    return 0;\n\t  \n\t  for (j = 0; j < ntohs(header->ancount); j++) \n\t    {\n\t      int secflag = 0;\n\t      \n\t      if (!(res = extract_name(header, qlen, &p1, name, 0, 10)))\n\t\treturn 0; /* bad packet */\n\t      \n\t      GETSHORT(aqtype, p1); \n\t      GETSHORT(aqclass, p1);\n\t      GETLONG(attl, p1);\n\t      if ((daemon->max_ttl != 0) && (attl > daemon->max_ttl) && !is_sign)\n\t\t{\n\t\t  (p1) -= 4;\n\t\t  PUTLONG(daemon->max_ttl, p1);\n\t\t}\n\t      GETSHORT(ardlen, p1);\n\t      endrr = p1+ardlen;\n\t      \n\t      if (aqclass == C_IN && res != 2 && (aqtype == T_CNAME || aqtype == qtype))\n\t\t{\n#ifdef HAVE_DNSSEC\n\t\t  if (option_bool(OPT_DNSSEC_VALID) && daemon->rr_status[j] != 0)\n\t\t    {\n\t\t      secflag = F_DNSSECOK;\n\n\t\t      /* limit TTl based on sig. */\n\t\t      if (daemon->rr_status[j] < attl)\n\t\t\tattl = daemon->rr_status[j];\n\t\t    }\n#endif\t\t  \n\t\t  if (aqtype == T_CNAME)\n\t\t    {\n\t\t      if (!cname_count--)\n\t\t\treturn 0; /* looped CNAMES */\n\n\t\t      if ((newc = cache_insert(name, NULL, C_IN, now, attl, F_CNAME | F_FORWARD | secflag)))\n\t\t\t{\n\t\t\t  newc->addr.cname.target.cache = NULL;\n\t\t\t  newc->addr.cname.is_name_ptr = 0; \n\t\t\t  if (cpp)\n\t\t\t    {\n\t\t\t      next_uid(newc);\n\t\t\t      cpp->addr.cname.target.cache = newc;\n\t\t\t      cpp->addr.cname.uid = newc->uid;\n\t\t\t    }\n\t\t\t}\n\t\t      \n\t\t      cpp = newc;\n\t\t      if (attl < cttl)\n\t\t\tcttl = attl;\n\t\t      \n\t\t      namep = p1;\n\t\t      if (!extract_name(header, qlen, &p1, name, 1, 0))\n\t\t\treturn 0;\n\t\t      \n\t\t      goto cname_loop1;\n\t\t    }\n\t\t  else if (!(flags & F_NXDOMAIN))\n\t\t    {\n\t\t      found = 1;\n\t\t      \n\t\t      if (flags & F_SRV)\n\t\t\t{\n\t\t\t   unsigned char *tmp = namep;\n\n\t\t\t   if (!CHECK_LEN(header, p1, qlen, 6))\n\t\t\t     return 0; /* bad packet */\n\t\t\t   GETSHORT(addr.srv.priority, p1);\n\t\t\t   GETSHORT(addr.srv.weight, p1);\n\t\t\t   GETSHORT(addr.srv.srvport, p1);\n\t\t\t   if (!extract_name(header, qlen, &p1, name, 1, 0))\n\t\t\t     return 0;\n\t\t\t   addr.srv.targetlen = strlen(name) + 1; /* include terminating zero */\n\t\t\t   if (!(addr.srv.target = blockdata_alloc(name, addr.srv.targetlen)))\n\t\t\t     return 0;\n\t\t\t   \n\t\t\t   /* we overwrote the original name, so get it back here. */\n\t\t\t   if (!extract_name(header, qlen, &tmp, name, 1, 0))\n\t\t\t     return 0;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  /* copy address into aligned storage */\n\t\t\t  if (!CHECK_LEN(header, p1, qlen, addrlen))\n\t\t\t    return 0; /* bad packet */\n\t\t\t  memcpy(&addr, p1, addrlen);\n\t\t      \n\t\t\t  /* check for returned address in private space */\n\t\t\t  if (check_rebind)\n\t\t\t    {\n\t\t\t      if ((flags & F_IPV4) &&\n\t\t\t\t  private_net(addr.addr4, !option_bool(OPT_LOCAL_REBIND)))\n\t\t\t\treturn 1;\n\n\t\t\t      if ((flags & F_IPV6) &&\n\t\t\t\t  private_net6(&addr.addr6, !option_bool(OPT_LOCAL_REBIND)))\n\t\t\t\treturn 1;\n\t\t\t    }\n\n#ifdef HAVE_IPSET\n\t\t\t  if (ipsets && (flags & (F_IPV4 | F_IPV6)))\n\t\t\t    {\n\t\t\t      ipsets_cur = ipsets;\n\t\t\t      while (*ipsets_cur)\n\t\t\t\t{\n\t\t\t\t  log_query((flags & (F_IPV4 | F_IPV6)) | F_IPSET, name, &addr, *ipsets_cur);\n\t\t\t\t  add_to_ipset(*ipsets_cur++, &addr, flags, 0);\n\t\t\t\t}\n\t\t\t    }\n#endif\n\t\t\t}\n\t\t      \n\t\t      newc = cache_insert(name, &addr, C_IN, now, attl, flags | F_FORWARD | secflag);\n\t\t      if (newc && cpp)\n\t\t\t{\n\t\t\t  next_uid(newc);\n\t\t\t  cpp->addr.cname.target.cache = newc;\n\t\t\t  cpp->addr.cname.uid = newc->uid;\n\t\t\t}\n\t\t      cpp = NULL;\n\t\t    }\n\t\t}\n\t      \n\t      p1 = endrr;\n\t      if (!CHECK_LEN(header, p1, qlen, 0))\n\t\treturn 0; /* bad packet */\n\t    }\n\t  \n\t  if (!found && !option_bool(OPT_NO_NEG))\n\t    {\n\t      if (!searched_soa)\n\t\t{\n\t\t  searched_soa = 1;\n\t\t  ttl = find_soa(header, qlen, NULL, doctored);\n\t\t}\n\t      /* If there's no SOA to get the TTL from, but there is a CNAME \n\t\t pointing at this, inherit its TTL */\n\t      if (ttl || cpp)\n\t\t{\n\t\t  newc = cache_insert(name, NULL, C_IN, now, ttl ? ttl : cttl, F_FORWARD | F_NEG | flags | (secure ? F_DNSSECOK : 0));\t\n\t\t  if (newc && cpp)\n\t\t    {\n\t\t      next_uid(newc);\n\t\t      cpp->addr.cname.target.cache = newc;\n\t\t      cpp->addr.cname.uid = newc->uid;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  \n  /* Don't put stuff from a truncated packet into the cache.\n     Don't cache replies from non-recursive nameservers, since we may get a \n     reply containing a CNAME but not its target, even though the target \n     does exist. */\n  if (!(header->hb3 & HB3_TC) && \n      !(header->hb4 & HB4_CD) &&\n      (header->hb4 & HB4_RA) &&\n      !no_cache_dnssec)\n    cache_end_insert();\n\n  return 0;\n}\nstatic int safe_name(char *name)\n{\n  unsigned char *r;\n  \n  for (r = (unsigned char *)name; *r; r++)\n    if (!isprint((int)*r))\n      return 0;\n  \n  return 1;\n}\nvoid report_addresses(struct dns_header *header, size_t len, u32 mark)\n{\n  unsigned char *p, *endrr;\n  int i;\n  unsigned long attl;\n  struct allowlist *allowlists;\n  char **pattern_pos;\n  \n  if (RCODE(header) != NOERROR)\n    return;\n  \n  for (allowlists = daemon->allowlists; allowlists; allowlists = allowlists->next)\n    if (allowlists->mark == (mark & daemon->allowlist_mask & allowlists->mask))\n      for (pattern_pos = allowlists->patterns; *pattern_pos; pattern_pos++)\n\tif (!strcmp(*pattern_pos, \"*\"))\n\t  return;\n  \n  if (!(p = skip_questions(header, len)))\n    return;\n  for (i = ntohs(header->ancount); i != 0; i--)\n    {\n      int aqtype, aqclass, ardlen;\n      \n      if (!extract_name(header, len, &p, daemon->namebuff, 1, 10))\n\treturn;\n      \n      if (!CHECK_LEN(header, p, len, 10))\n\treturn;\n      GETSHORT(aqtype, p);\n      GETSHORT(aqclass, p);\n      GETLONG(attl, p);\n      GETSHORT(ardlen, p);\n      \n      if (!CHECK_LEN(header, p, len, ardlen))\n\treturn;\n      endrr = p+ardlen;\n      \n      if (aqclass == C_IN)\n\t{\n\t  if (aqtype == T_CNAME)\n\t    {\n\t      if (!extract_name(header, len, &p, daemon->workspacename, 1, 0))\n\t\treturn;\n\t      if (safe_name(daemon->namebuff) && safe_name(daemon->workspacename))\n\t\tubus_event_bcast_connmark_allowlist_resolved(mark, daemon->namebuff, daemon->workspacename, attl);\n\t    }\n\t  if (aqtype == T_A)\n\t    {\n\t      struct in_addr addr;\n\t      char ip[INET_ADDRSTRLEN];\n\t      if (ardlen != INADDRSZ)\n\t\treturn;\n\t      memcpy(&addr, p, ardlen);\n\t      if (inet_ntop(AF_INET, &addr, ip, sizeof ip) && safe_name(daemon->namebuff))\n\t\tubus_event_bcast_connmark_allowlist_resolved(mark, daemon->namebuff, ip, attl);\n\t    }\n\t  else if (aqtype == T_AAAA)\n\t    {\n\t      struct in6_addr addr;\n\t      char ip[INET6_ADDRSTRLEN];\n\t      if (ardlen != IN6ADDRSZ)\n\t\treturn;\n\t      memcpy(&addr, p, ardlen);\n\t      if (inet_ntop(AF_INET6, &addr, ip, sizeof ip) && safe_name(daemon->namebuff))\n\t\tubus_event_bcast_connmark_allowlist_resolved(mark, daemon->namebuff, ip, attl);\n\t    }\n\t}\n      \n      p = endrr;\n    }\n}\n",
    "target": 1,
    "idx": 1035865,
    "stack_trace": [
      {
        "function_name": "extract_name",
        "function_body": "int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, \n\t\t char *name, int isExtract, int extrabytes)\n{\n  unsigned char *cp = (unsigned char *)name, *p = *pp, *p1 = NULL;\n  unsigned int j, l, namelen = 0, hops = 0;\n  int retvalue = 1;\n  \n  if (isExtract)\n    *cp = 0;\n\n  while (1)\n    { \n      unsigned int label_type;\n\n      if (!CHECK_LEN(header, p, plen, 1))\n\treturn 0;\n      \n      if ((l = *p++) == 0) \n\t/* end marker */\n\t{\n\t  /* check that there are the correct no. of bytes after the name */\n\t  if (!CHECK_LEN(header, p1 ? p1 : p, plen, extrabytes))\n\t    return 0;\n\t  \n\t  if (isExtract)\n\t    {\n\t      if (cp != (unsigned char *)name)\n\t\tcp--;\n\t      *cp = 0; /* terminate: lose final period */\n\t    }\n\t  else if (*cp != 0)\n\t    retvalue = 2;\n\t  \n\t  if (p1) /* we jumped via compression */\n\t    *pp = p1;\n\t  else\n\t    *pp = p;\n\t  \n\t  return retvalue;\n\t}\n\n      label_type = l & 0xc0;\n      \n      if (label_type == 0xc0) /* pointer */\n\t{ \n\t  if (!CHECK_LEN(header, p, plen, 1))\n\t    return 0;\n\t      \n\t  /* get offset */\n\t  l = (l&0x3f) << 8;\n\t  l |= *p++;\n\t  \n\t  if (!p1) /* first jump, save location to go back to */\n\t    p1 = p;\n\t      \n\t  hops++; /* break malicious infinite loops */\n\t  if (hops > 255)\n\t    return 0;\n\t  \n\t  p = l + (unsigned char *)header;\n\t}\n      else if (label_type == 0x00)\n\t{ /* label_type = 0 -> label. */\n\t  namelen += l + 1; /* include period */\n\t  if (namelen >= MAXDNAME)\n\t    return 0;\n\t  if (!CHECK_LEN(header, p, plen, l))\n\t    return 0;\n\t  \n\t  for(j=0; j<l; j++, p++)\n\t    if (isExtract)\n\t      {\n\t\tunsigned char c = *p;\n#ifdef HAVE_DNSSEC\n\t\tif (option_bool(OPT_DNSSEC_VALID))\n\t\t  {\n\t\t    if (c == 0 || c == '.' || c == NAME_ESCAPE)\n\t\t      {\n\t\t\t*cp++ = NAME_ESCAPE;\n\t\t\t*cp++ = c+1;\n\t\t      }\n\t\t    else\n\t\t      *cp++ = c; \n\t\t  }\n\t\telse\n#endif\n\t\tif (c != 0 && c != '.')\n\t\t  *cp++ = c;\n\t\telse\n\t\t  return 0;\n\t      }\n\t    else \n\t      {\n\t\tunsigned char c1 = *cp, c2 = *p;\n\t\t\n\t\tif (c1 == 0)\n\t\t  retvalue = 2;\n\t\telse \n\t\t  {\n\t\t    cp++;\n\t\t    if (c1 >= 'A' && c1 <= 'Z')\n\t\t      c1 += 'a' - 'A';\n#ifdef HAVE_DNSSEC\n\t\t    if (option_bool(OPT_DNSSEC_VALID) && c1 == NAME_ESCAPE)\n\t\t      c1 = (*cp++)-1;\n#endif\n\t\t    \n\t\t    if (c2 >= 'A' && c2 <= 'Z')\n\t\t      c2 += 'a' - 'A';\n\t\t     \n\t\t    if (c1 != c2)\n\t\t      retvalue =  2;\n\t\t  }\n\t      }\n\t    \n\t  if (isExtract)\n\t    *cp++ = '.';\n\t  else if (*cp != 0 && *cp++ != '.')\n\t    retvalue = 2;\n\t}\n      else\n\treturn 0; /* label types 0x40 and 0x80 not supported */\n    }\n}",
        "file_path": "/src/dnsmasq/src/rfc1035.c",
        "crashing_line": "\t\t  *cp++ = c;",
        "crashing_line_number": 106
      },
      {
        "function_name": "extract_addresses",
        "function_body": "int extract_addresses(struct dns_header *header, size_t qlen, char *name, time_t now, \n\t\t      char **ipsets, int is_sign, int check_rebind, int no_cache_dnssec,\n\t\t      int secure, int *doctored)\n{\n  unsigned char *p, *p1, *endrr, *namep;\n  int i, j, qtype, qclass, aqtype, aqclass, ardlen, res, searched_soa = 0;\n  unsigned long ttl = 0;\n  union all_addr addr;\n#ifdef HAVE_IPSET\n  char **ipsets_cur;\n#else\n  (void)ipsets; /* unused */\n#endif\n  int found = 0, cname_count = CNAME_CHAIN;\n  struct crec *cpp = NULL;\n  int flags = RCODE(header) == NXDOMAIN ? F_NXDOMAIN : 0;\n#ifdef HAVE_DNSSEC\n  int cname_short = 0;\n#endif\n  unsigned long cttl = ULONG_MAX, attl;\n  \n  cache_start_insert();\n\n  /* find_soa is needed for dns_doctor side effects, so don't call it lazily if there are any. */\n  if (daemon->doctors || option_bool(OPT_DNSSEC_VALID))\n    {\n      searched_soa = 1;\n      ttl = find_soa(header, qlen, doctored);\n\n      if (*doctored)\n\t{\n\t  if (secure)\n\t    return 0;\n#ifdef HAVE_DNSSEC\n\t  if (option_bool(OPT_DNSSEC_VALID))\n\t    for (i = 0; i < ntohs(header->ancount); i++)\n\t      if (daemon->rr_status[i] != 0)\n\t\treturn 0;\n#endif\n\t}\n    }\n  \n  namep = p = (unsigned char *)(header+1);\n  \n  if (ntohs(header->qdcount) != 1 || !extract_name(header, qlen, &p, name, 1, 4))\n    return 0; /* bad packet */\n  \n  GETSHORT(qtype, p); \n  GETSHORT(qclass, p);\n  \n  if (qclass != C_IN)\n    return 0;\n  \n  /* PTRs: we chase CNAMEs here, since we have no way to \n     represent them in the cache. */\n  if (qtype == T_PTR)\n    { \n      int insert = 1, name_encoding = in_arpa_name_2_addr(name, &addr);\n      \n      if (!(flags & F_NXDOMAIN))\n\t{\n\tcname_loop:\n\t  if (!(p1 = skip_questions(header, qlen)))\n\t    return 0;\n\t  \n\t  for (j = 0; j < ntohs(header->ancount); j++) \n\t    {\n\t      int secflag = 0;\n\t      if (!(res = extract_name(header, qlen, &p1, name, 0, 10)))\n\t\treturn 0; /* bad packet */\n\t      \n\t      GETSHORT(aqtype, p1); \n\t      GETSHORT(aqclass, p1);\n\t      GETLONG(attl, p1);\n\t      \n\t      if ((daemon->max_ttl != 0) && (attl > daemon->max_ttl) && !is_sign)\n\t\t{\n\t\t  (p1) -= 4;\n\t\t  PUTLONG(daemon->max_ttl, p1);\n\t\t}\n\t      GETSHORT(ardlen, p1);\n\t      endrr = p1+ardlen;\n\t      \n\t      /* TTL of record is minimum of CNAMES and PTR */\n\t      if (attl < cttl)\n\t\tcttl = attl;\n\t      \n\t      if (aqclass == C_IN && res != 2 && (aqtype == T_CNAME || aqtype == T_PTR))\n\t\t{\n#ifdef HAVE_DNSSEC\n\t\t  if (option_bool(OPT_DNSSEC_VALID) && daemon->rr_status[j] != 0)\n\t\t    {\n\t\t      /* validated RR anywhere in CNAME chain, don't cache. */\n\t\t      if (cname_short || aqtype == T_CNAME)\n\t\t\tinsert = 0;\n\t\t      \n\t\t      secflag = F_DNSSECOK;\n\t\t      /* limit TTL based on signature. */\n\t\t      if (daemon->rr_status[j] < cttl)\n\t\t\tcttl = daemon->rr_status[j];\n\t\t    }\n#endif\n\n\t\t  if (aqtype == T_CNAME)\n\t\t    log_query(secflag | F_CNAME | F_FORWARD | F_UPSTREAM, name, NULL, NULL);\n\t\t  \n\t\t  if (!extract_name(header, qlen, &p1, name, 1, 0))\n\t\t    return 0;\n\t\t  \n\t\t  if (aqtype == T_CNAME)\n\t\t    {\n\t\t      if (!cname_count--)\n\t\t\treturn 0; /* looped CNAMES, we can't cache. */\n#ifdef HAVE_DNSSEC\n\t\t      cname_short = 1;\n#endif\n\t\t      goto cname_loop;\n\t\t    }\n\t\t  \n\t\t  found = 1; \n\t\t  \n\t\t  if (!name_encoding)\n\t\t    log_query(secflag | F_FORWARD | F_UPSTREAM, name, NULL, querystr(NULL, aqtype));\n\t\t  else\n\t\t    {\n\t\t      log_query(name_encoding | secflag | F_REVERSE | F_UPSTREAM, name, &addr, NULL);\n\t\t      if (insert)\n\t\t\tcache_insert(name, &addr, C_IN, now, cttl, name_encoding | secflag | F_REVERSE);\n\t\t    }\n\t\t}\n\n\t      p1 = endrr;\n\t      if (!CHECK_LEN(header, p1, qlen, 0))\n\t\treturn 0; /* bad packet */\n\t    }\n\t}\n      \n      if (!found && !option_bool(OPT_NO_NEG))\n\t{\n\t  if (!searched_soa)\n\t    {\n\t      searched_soa = 1;\n\t      ttl = find_soa(header, qlen, doctored);\n\t    }\n\t  \n\t  flags |= F_NEG | (secure ?  F_DNSSECOK : 0);\n\t  if (name_encoding && ttl)\n\t    {\n\t      flags |= F_REVERSE | name_encoding;\n\t      cache_insert(NULL, &addr, C_IN, now, ttl, flags);\n\t    }\n\t  \n\t  log_query(flags | F_UPSTREAM, name, &addr, NULL);\n\t}\n    }\n  else\n    {\n      /* everything other than PTR */\n      struct crec *newc;\n      int addrlen = 0, insert = 1;\n      \n      if (qtype == T_A)\n\t{\n\t  addrlen = INADDRSZ;\n\t  flags |= F_IPV4;\n\t}\n      else if (qtype == T_AAAA)\n\t{\n\t  addrlen = IN6ADDRSZ;\n\t  flags |= F_IPV6;\n\t}\n      else if (qtype == T_SRV)\n\tflags |= F_SRV;\n      else\n\tinsert = 0; /* NOTE: do not cache data from CNAME queries. */\n      \n    cname_loop1:\n      if (!(p1 = skip_questions(header, qlen)))\n\treturn 0;\n      \n      for (j = 0; j < ntohs(header->ancount); j++) \n\t{\n\t  int secflag = 0;\n\t  \n\t  if (!(res = extract_name(header, qlen, &p1, name, 0, 10)))\n\t    return 0; /* bad packet */\n\t  \n\t  GETSHORT(aqtype, p1); \n\t  GETSHORT(aqclass, p1);\n\t  GETLONG(attl, p1);\n\t  if ((daemon->max_ttl != 0) && (attl > daemon->max_ttl) && !is_sign)\n\t    {\n\t      (p1) -= 4;\n\t      PUTLONG(daemon->max_ttl, p1);\n\t    }\n\t  GETSHORT(ardlen, p1);\n\t  endrr = p1+ardlen;\n\t  \n\t  /* Not what we're looking for? */\n\t  if (aqclass != C_IN || res == 2)\n\t    {\n\t      p1 = endrr;\n\t      if (!CHECK_LEN(header, p1, qlen, 0))\n\t\treturn 0; /* bad packet */\n\t      continue;\n\t    }\n\t  \n#ifdef HAVE_DNSSEC\n\t  if (option_bool(OPT_DNSSEC_VALID) && daemon->rr_status[j] != 0)\n\t    {\n\t      secflag = F_DNSSECOK;\n\t      \n\t      /* limit TTl based on sig. */\n\t      if (daemon->rr_status[j] < attl)\n\t\tattl = daemon->rr_status[j];\n\t    }\n#endif\t  \n\t  \n\t  if (aqtype == T_CNAME)\n\t    {\n\t      if (!cname_count--)\n\t\treturn 0; /* looped CNAMES */\n\t      \n\t      log_query(secflag | F_CNAME | F_FORWARD | F_UPSTREAM, name, NULL, NULL);\n\t      \n\t      if (insert)\n\t\t{\n\t\t  if ((newc = cache_insert(name, NULL, C_IN, now, attl, F_CNAME | F_FORWARD | secflag)))\n\t\t    {\n\t\t      newc->addr.cname.target.cache = NULL;\n\t\t      newc->addr.cname.is_name_ptr = 0; \n\t\t      if (cpp)\n\t\t\t{\n\t\t\t  next_uid(newc);\n\t\t\t  cpp->addr.cname.target.cache = newc;\n\t\t\t  cpp->addr.cname.uid = newc->uid;\n\t\t\t}\n\t\t    }\n\t\t  \n\t\t  cpp = newc;\n\t\t  if (attl < cttl)\n\t\t    cttl = attl;\n\t\t}\n\t      \n\t      namep = p1;\n\t      if (!extract_name(header, qlen, &p1, name, 1, 0))\n\t\treturn 0;\n\t      \n\t      goto cname_loop1;\n\t    }\n\t  else if (aqtype != qtype)\n\t    {\n#ifdef HAVE_DNSSEC\n\t      if (!option_bool(OPT_DNSSEC_VALID) || aqtype != T_RRSIG)\n#endif\n\t\tlog_query(secflag | F_FORWARD | F_UPSTREAM, name, NULL, querystr(NULL, aqtype));\n\t    }\n\t  else if (!(flags & F_NXDOMAIN))\n\t    {\n\t      found = 1;\n\t      \n\t      if (flags & F_SRV)\n\t\t{\n\t\t  unsigned char *tmp = namep;\n\t\t  \n\t\t  if (!CHECK_LEN(header, p1, qlen, 6))\n\t\t    return 0; /* bad packet */\n\t\t  GETSHORT(addr.srv.priority, p1);\n\t\t  GETSHORT(addr.srv.weight, p1);\n\t\t  GETSHORT(addr.srv.srvport, p1);\n\t\t  if (!extract_name(header, qlen, &p1, name, 1, 0))\n\t\t    return 0;\n\t\t  addr.srv.targetlen = strlen(name) + 1; /* include terminating zero */\n\t\t  if (!(addr.srv.target = blockdata_alloc(name, addr.srv.targetlen)))\n\t\t    return 0;\n\t\t  \n\t\t  /* we overwrote the original name, so get it back here. */\n\t\t  if (!extract_name(header, qlen, &tmp, name, 1, 0))\n\t\t    return 0;\n\t\t}\n\t      else if (flags & (F_IPV4 | F_IPV6))\n\t\t{\n\t\t  /* copy address into aligned storage */\n\t\t  if (!CHECK_LEN(header, p1, qlen, addrlen))\n\t\t    return 0; /* bad packet */\n\t\t  memcpy(&addr, p1, addrlen);\n\t\t  \n\t\t  /* check for returned address in private space */\n\t\t  if (check_rebind)\n\t\t    {\n\t\t      if ((flags & F_IPV4) &&\n\t\t\t  private_net(addr.addr4, !option_bool(OPT_LOCAL_REBIND)))\n\t\t\treturn 1;\n\t\t      \n\t\t      if ((flags & F_IPV6) &&\n\t\t\t  private_net6(&addr.addr6, !option_bool(OPT_LOCAL_REBIND)))\n\t\t\treturn 1;\n\t\t    }\n\t\t  \n#ifdef HAVE_IPSET\n\t\t  if (ipsets && (flags & (F_IPV4 | F_IPV6)))\n\t\t    {\n\t\t      ipsets_cur = ipsets;\n\t\t      while (*ipsets_cur)\n\t\t\t{\n\t\t\t  log_query((flags & (F_IPV4 | F_IPV6)) | F_IPSET, name, &addr, *ipsets_cur);\n\t\t\t  add_to_ipset(*ipsets_cur++, &addr, flags, 0);\n\t\t\t}\n\t\t    }\n#endif\n\t\t}\n\t      \n\t      if (insert)\n\t\t{\n\t\t  newc = cache_insert(name, &addr, C_IN, now, attl, flags | F_FORWARD | secflag);\n\t\t  if (newc && cpp)\n\t\t    {\n\t\t      next_uid(newc);\n\t\t      cpp->addr.cname.target.cache = newc;\n\t\t      cpp->addr.cname.uid = newc->uid;\n\t\t    }\n\t\t  cpp = NULL;\n\t\t}\n\t      \n\t      if (aqtype == T_TXT)\n\t\t{\n\t\t  if (!print_txt(header, qlen, name, p1, ardlen))\n\t\t    return 0;\n\t\t}\n\t      else\n\t\tlog_query(flags | F_FORWARD | secflag | F_UPSTREAM, name, &addr, querystr(NULL, aqtype));\n\t    }\n\t  \n\t  p1 = endrr;\n\t  if (!CHECK_LEN(header, p1, qlen, 0))\n\t    return 0; /* bad packet */\n\t}\n      \n      if (!found && !option_bool(OPT_NO_NEG))\n\t{\n\t  if (!searched_soa)\n\t    {\n\t      searched_soa = 1;\n\t      ttl = find_soa(header, qlen, doctored);\n\t    }\n\t  \n\t  /* If there's no SOA to get the TTL from, but there is a CNAME \n\t     pointing at this, inherit its TTL */\n\t  if (ttl || cpp)\n\t    {\n\t      if (ttl == 0)\n\t\tttl = cttl;\n\t      \n\t      log_query(F_UPSTREAM | F_FORWARD | F_NEG | flags | (secure ? F_DNSSECOK : 0), name, NULL, NULL);\n\t      \n\t      if (insert)\n\t\t{\n\t\t  newc = cache_insert(name, NULL, C_IN, now, ttl, F_FORWARD | F_NEG | flags | (secure ? F_DNSSECOK : 0));\t\n\t\t  if (newc && cpp)\n\t\t    {\n\t\t      next_uid(newc);\n\t\t      cpp->addr.cname.target.cache = newc;\n\t\t      cpp->addr.cname.uid = newc->uid;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  \n  /* Don't put stuff from a truncated packet into the cache.\n     Don't cache replies from non-recursive nameservers, since we may get a \n     reply containing a CNAME but not its target, even though the target \n     does exist. */\n  if (!(header->hb3 & HB3_TC) && \n      !(header->hb4 & HB4_CD) &&\n      (header->hb4 & HB4_RA) &&\n      !no_cache_dnssec)\n    cache_end_insert();\n\n  return 0;\n}",
        "file_path": "/src/dnsmasq/src/rfc1035.c",
        "crashing_line": "  ",
        "crashing_line_number": 591
      },
      {
        "function_name": "FuzzExtractTheAddress",
        "function_body": "void FuzzExtractTheAddress(const uint8_t **data2, size_t *size2) {\n  const uint8_t *data = *data2;\n  size_t size = *size2;\n\n  char *new_name = NULL;\n  new_name = get_null_terminated(&data, &size);\n  pointer_arr[pointer_idx++] = (void*)new_name;\n\n  int check_rebind = get_int(&data, &size);\n  int is_sign = get_int(&data, &size);\n  int secure =  get_int(&data, &size);\n\n  if (size > (sizeof(struct dns_header) +50)) {\n    char *new_data = malloc(size);\n    memset(new_data, 0, size);\n    memcpy(new_data, data, size);\n    pointer_arr[pointer_idx++] = (void*)new_data;\n    \n    time_t now; \n    int doctored = 0;\n    extract_addresses((struct dns_header *)new_data, size, new_name, now, NULL, check_rebind, is_sign, 0, secure, &doctored);\n  }\n}",
        "file_path": "/src/fuzz_rfc1035.c",
        "crashing_line": "    extract_addresses((struct dns_header *)new_data, size, new_name, now, NULL, check_rebind, is_sign, 0, secure, &doctored);",
        "crashing_line_number": 38
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static void\ninsert_weight(fz_weights *weights, int j, int i, int weight)\n{\n\tint min, len, index;\n\n\t/* Move j from patch_l...patch_l+patch_w range to 0..patch_w range */\n\tj -= weights->patch_l;\n\tif (weights->new_line)\n\t{\n\t\t/* New line */\n\t\tweights->new_line = 0;\n\t\tindex = weights->index[j]; /* row pointer */\n\t\tweights->index[index] = i; /* min */\n\t\tweights->index[index+1] = 0; /* len */\n\t}\n\tindex = weights->index[j];\n\tmin = weights->index[index++];\n\tlen = weights->index[index++];\n\twhile (i < min)\n\t{\n\t\t/* This only happens in rare cases, but we need to insert\n\t\t * one earlier. In exceedingly rare cases we may need to\n\t\t * insert more than one earlier. */\n\t\tint k;\n\n\t\tfor (k = len; k > 0; k--)\n\t\t{\n\t\t\tweights->index[index+k] = weights->index[index+k-1];\n\t\t}\n\t\tweights->index[index] = 0;\n\t\tmin--;\n\t\tlen++;\n\t\tweights->index[index-2] = min;\n\t\tweights->index[index-1] = len;\n\t}\n\tif (i-min >= len)\n\t{\n\t\t/* The usual case */\n\t\twhile (i-min >= ++len)\n\t\t{\n\t\t\tweights->index[index+len-1] = 0;\n\t\t}\n\t\tassert(len-1 == i-min);\n\t\tweights->index[index+i-min] = weight;\n\t\tweights->index[index-1] = len;\n\t\tassert(len <= weights->max_len);\n\t}\n\telse\n\t{\n\t\t/* Infrequent case */\n\t\tweights->index[index+i-min] += weight;\n\t}\n}\nstatic void\nreorder_weights(fz_weights *weights, int j, int src_w)\n{\n\tint idx = weights->index[j - weights->patch_l];\n\tint min = weights->index[idx++];\n\tint len = weights->index[idx++];\n\tint max = weights->max_len;\n\tint tmp = idx+max;\n\tint i, off;\n\n\t/* Copy into the temporary area */\n\tmemcpy(&weights->index[tmp], &weights->index[idx], sizeof(int)*len);\n\n\t/* Pad out if required */\n\tassert(len <= max);\n\tassert(min+len <= src_w);\n\toff = 0;\n\tif (len < max)\n\t{\n\t\tmemset(&weights->index[tmp+len], 0, sizeof(int)*(max-len));\n\t\tlen = max;\n\t\tif (min + len > src_w)\n\t\t{\n\t\t\toff = min + len - src_w;\n\t\t\tmin = src_w - len;\n\t\t\tweights->index[idx-2] = min;\n\t\t}\n\t\tweights->index[idx-1] = len;\n\t}\n\n\t/* Copy back into the proper places */\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tweights->index[idx+((min+i+off) % max)] = weights->index[tmp+i];\n\t}\n}\n",
    "target": 1,
    "idx": 1060349,
    "stack_trace": [
      {
        "function_name": "reorder_weights",
        "function_body": "static void\nreorder_weights(fz_weights *weights, int j, int src_w)\n{\n\tint idx = weights->index[j - weights->patch_l];\n\tint min = weights->index[idx++];\n\tint len = weights->index[idx++];\n\tint max = weights->max_len;\n\tint tmp = idx+max;\n\tint i, off;\n\n\t/* Copy into the temporary area */\n\tmemcpy(&weights->index[tmp], &weights->index[idx], sizeof(int)*len);\n\n\t/* Pad out if required */\n\tassert(len <= max);\n\tassert(min+len <= src_w);\n\toff = 0;\n\tif (len < max)\n\t{\n\t\tmemset(&weights->index[tmp+len], 0, sizeof(int)*(max-len));\n\t\tlen = max;\n\t\tif (min + len > src_w)\n\t\t{\n\t\t\toff = min + len - src_w;\n\t\t\tmin = src_w - len;\n\t\t\tweights->index[idx-2] = min;\n\t\t}\n\t\tweights->index[idx-1] = len;\n\t}\n\n\t/* Copy back into the proper places */\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tweights->index[idx+((min+i+off) % max)] = weights->index[tmp+i];\n\t}\n}",
        "file_path": "/src/mupdf/source/fitz/draw-scale-simple.c",
        "crashing_line": "\tfor (i = 0; i < len; i++)",
        "crashing_line_number": 398
      },
      {
        "function_name": "make_weights",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/draw-scale-simple.c",
        "crashing_line": "",
        "crashing_line_number": 513
      },
      {
        "function_name": "fz_scale_pixmap_cached",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/draw-scale-simple.c",
        "crashing_line": "",
        "crashing_line_number": 1739
      },
      {
        "function_name": "fz_transform_pixmap",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/draw-device.c",
        "crashing_line": "",
        "crashing_line_number": 1639
      },
      {
        "function_name": "fz_draw_fill_image",
        "function_body": "static void\nfz_draw_fill_image(fz_context *ctx, fz_device *devp, fz_image *image, fz_matrix in_ctm, float alpha, fz_color_params color_params)\n{\n\tfz_draw_device *dev = (fz_draw_device*)devp;\n\tfz_matrix local_ctm = fz_concat(in_ctm, dev->transform);\n\tfz_pixmap *pixmap;\n\tint after;\n\tint dx, dy;\n\tfz_draw_state *state = &dev->stack[dev->top];\n\tfz_colorspace *model;\n\tfz_irect clip;\n\tfz_irect src_area;\n\tfz_colorspace *src_cs;\n\tfz_overprint op = { { 0 } };\n\tfz_overprint *eop = &op;\n\n\tif (alpha == 0)\n\t\treturn;\n\n\tif (dev->top == 0 && dev->resolve_spots)\n\t\tstate = push_group_for_separations(ctx, dev, color_params, dev->default_cs);\n\tmodel = state->dest->colorspace;\n\n\tclip = fz_intersect_irect(fz_pixmap_bbox(ctx, state->dest), state->scissor);\n\n\tif (image->w == 0 || image->h == 0 || fz_is_empty_irect(clip))\n\t\treturn;\n\n\tif (color_params.op == 0)\n\t\teop = NULL;\n\n\tif (!(dev->flags & FZ_DRAWDEV_FLAGS_TYPE3))\n\t\tlocal_ctm = fz_gridfit_matrix(devp->flags & FZ_DEVFLAG_GRIDFIT_AS_TILED, local_ctm);\n\n\tsrc_area = find_src_area_required(local_ctm, image, clip);\n\tif (fz_is_empty_irect(src_area))\n\t\treturn;\n\n\tpixmap = fz_get_pixmap_from_image(ctx, image, &src_area, &local_ctm, &dx, &dy);\n\tsrc_cs = fz_default_colorspace(ctx, dev->default_cs, pixmap->colorspace);\n\n\t/* convert images with more components (cmyk->rgb) before scaling */\n\t/* convert images with fewer components (gray->rgb) after scaling */\n\t/* convert images with expensive colorspace transforms after scaling */\n\n\tfz_var(pixmap);\n\n\tfz_try(ctx)\n\t{\n\t\tint conversion_required = (src_cs != model || fz_compare_separations(ctx, state->dest->seps, pixmap->seps));\n\n\t\tif (state->blendmode & FZ_BLEND_KNOCKOUT && alpha != 1)\n\t\t\tstate = fz_knockout_begin(ctx, dev);\n\n\t\tswitch (fz_colorspace_type(ctx, src_cs))\n\t\t{\n\t\tcase FZ_COLORSPACE_GRAY:\n\t\t\tafter = 1;\n\t\t\tbreak;\n\t\tcase FZ_COLORSPACE_INDEXED:\n\t\t\tafter = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fz_colorspace_n(ctx, src_cs) <= fz_colorspace_n(ctx, model))\n\t\t\t\tafter = 1;\n\t\t\telse\n\t\t\t\tafter = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (conversion_required && !after)\n\t\t\tpixmap = convert_pixmap_for_painting(ctx, pixmap, model, src_cs, state->dest, color_params, dev, &eop);\n\n\t\tif (!(devp->hints & FZ_DONT_INTERPOLATE_IMAGES) && ctx->tuning->image_scale(ctx->tuning->image_scale_arg, dx, dy, pixmap->w, pixmap->h))\n\t\t{\n\t\t\tint gridfit = alpha == 1.0f && !(dev->flags & FZ_DRAWDEV_FLAGS_TYPE3);\n\t\t\tfz_pixmap *scaled = fz_transform_pixmap(ctx, dev, pixmap, &local_ctm, state->dest->x, state->dest->y, dx, dy, gridfit, &clip);\n\t\t\tif (!scaled)\n\t\t\t{\n\t\t\t\tif (dx < 1)\n\t\t\t\t\tdx = 1;\n\t\t\t\tif (dy < 1)\n\t\t\t\t\tdy = 1;\n\t\t\t\tscaled = fz_scale_pixmap_cached(ctx, pixmap, pixmap->x, pixmap->y, dx, dy, NULL, dev->cache_x, dev->cache_y);\n\t\t\t}\n\t\t\tif (scaled)\n\t\t\t{\n\t\t\t\tfz_drop_pixmap(ctx, pixmap);\n\t\t\t\tpixmap = scaled;\n\t\t\t}\n\t\t}\n\n\t\tif (conversion_required && after)\n\t\t{\n#if FZ_PLOTTERS_RGB\n\t\t\tif (state->dest->seps == NULL &&\n\t\t\t\t((src_cs == fz_device_gray(ctx) && model == fz_device_rgb(ctx)) ||\n\t\t\t\t(src_cs == fz_device_gray(ctx) && model == fz_device_bgr(ctx))))\n\t\t\t{\n\t\t\t\t/* We have special case rendering code for gray -> rgb/bgr */\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t\tpixmap = convert_pixmap_for_painting(ctx, pixmap, model, src_cs, state->dest, color_params, dev, &eop);\n\t\t}\n\n\t\tfz_paint_image(ctx, state->dest, &state->scissor, state->shape, state->group_alpha, pixmap, local_ctm, alpha * 255, !(devp->hints & FZ_DONT_INTERPOLATE_IMAGES), eop);\n\n\t\tif (state->blendmode & FZ_BLEND_KNOCKOUT && alpha != 1)\n\t\t\tfz_knockout_end(ctx, dev);\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_pixmap(ctx, pixmap);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}",
        "file_path": "/src/mupdf/source/fitz/draw-device.c",
        "crashing_line": "\t\t\tfz_pixmap *scaled = fz_transform_pixmap(ctx, dev, pixmap, &local_ctm, state->dest->x, state->dest->y, dx, dy, gridfit, &clip);",
        "crashing_line_number": 1846
      },
      {
        "function_name": "fz_fill_image",
        "function_body": "void\nfz_fill_image(fz_context *ctx, fz_device *dev, fz_image *image, fz_matrix ctm, float alpha, fz_color_params color_params)\n{\n\tif (image->colorspace == NULL)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"argument to fill image must be a color image\");\n\tif (dev->fill_image)\n\t{\n\t\tfz_try(ctx)\n\t\t\tdev->fill_image(ctx, dev, image, ctm, alpha, color_params);\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tfz_disable_device(ctx, dev);\n\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}",
        "file_path": "/src/mupdf/source/fitz/device.c",
        "crashing_line": "\t\t\tdev->fill_image(ctx, dev, image, ctm, alpha, color_params);",
        "crashing_line_number": 355
      },
      {
        "function_name": "fz_run_display_list",
        "function_body": "void\nfz_run_display_list(fz_context *ctx, fz_display_list *list, fz_device *dev, fz_matrix top_ctm, fz_rect scissor, fz_cookie *cookie)\n{\n\tfz_display_node *node;\n\tfz_display_node *node_end;\n\tfz_display_node *next_node;\n\tint clipped = 0;\n\tint tiled = 0;\n\tint progress = 0;\n\n\t/* Current graphics state as unpacked from list */\n\tfz_path *path = NULL;\n\tfloat alpha = 1.0f;\n\tfz_matrix ctm = fz_identity;\n\tfz_stroke_state *stroke = NULL;\n\tfloat color[FZ_MAX_COLORS] = { 0 };\n\tfz_colorspace *colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));\n\tfz_color_params color_params;\n\tfz_rect rect = { 0 };\n\n\t/* Transformed versions of graphic state entries */\n\tfz_rect trans_rect;\n\tfz_matrix trans_ctm;\n\tint tile_skip_depth = 0;\n\n\tif (cookie)\n\t{\n\t\tcookie->progress_max = list->len;\n\t\tcookie->progress = 0;\n\t}\n\n\tcolor_params = fz_default_color_params;\n\n\tnode = list->list;\n\tnode_end = &list->list[list->len];\n\tfor (; node != node_end ; node = next_node)\n\t{\n\t\tint empty;\n\t\tfz_display_node n = *node;\n\t\tsize_t size = n.size;\n\n\t\tif (size == INDIRECT_NODE_THRESHOLD)\n\t\t{\n\t\t\tmemcpy(&size, &node[1], sizeof(size_t));\n\t\t\tnode += SIZE_IN_NODES(sizeof(size_t));\n\t\t\tsize -= SIZE_IN_NODES(sizeof(size_t));\n\t\t}\n\n\t\tnext_node = node + size;\n\n\t\t/* Check the cookie for aborting */\n\t\tif (cookie)\n\t\t{\n\t\t\tif (cookie->abort)\n\t\t\t\tbreak;\n\t\t\tcookie->progress = progress;\n\t\t\tprogress += (int)size;\n\t\t}\n\n\t\tnode++;\n\t\tif (n.rect)\n\t\t{\n\t\t\trect = *(fz_rect *)node;\n\t\t\tnode += SIZE_IN_NODES(sizeof(fz_rect));\n\t\t}\n\t\tif (n.cs)\n\t\t{\n\t\t\tint i, en;\n\n\t\t\tfz_drop_colorspace(ctx, colorspace);\n\t\t\tswitch (n.cs)\n\t\t\t{\n\t\t\tdefault:\n\t\t\tcase CS_GRAY_0:\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));\n\t\t\t\tcolor[0] = 0.0f;\n\t\t\t\tbreak;\n\t\t\tcase CS_GRAY_1:\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));\n\t\t\t\tcolor[0] = 1.0f;\n\t\t\t\tbreak;\n\t\t\tcase CS_RGB_0:\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_device_rgb(ctx));\n\t\t\t\tcolor[0] = 0.0f;\n\t\t\t\tcolor[1] = 0.0f;\n\t\t\t\tcolor[2] = 0.0f;\n\t\t\t\tbreak;\n\t\t\tcase CS_RGB_1:\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_device_rgb(ctx));\n\t\t\t\tcolor[0] = 1.0f;\n\t\t\t\tcolor[1] = 1.0f;\n\t\t\t\tcolor[2] = 1.0f;\n\t\t\t\tbreak;\n\t\t\tcase CS_CMYK_0:\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_device_cmyk(ctx));\n\t\t\t\tcolor[0] = 0.0f;\n\t\t\t\tcolor[1] = 0.0f;\n\t\t\t\tcolor[2] = 0.0f;\n\t\t\t\tcolor[3] = 0.0f;\n\t\t\t\tbreak;\n\t\t\tcase CS_CMYK_1:\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_device_cmyk(ctx));\n\t\t\t\tcolor[0] = 0.0f;\n\t\t\t\tcolor[1] = 0.0f;\n\t\t\t\tcolor[2] = 0.0f;\n\t\t\t\tcolor[3] = 1.0f;\n\t\t\t\tbreak;\n\t\t\tcase CS_OTHER_0:\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, *(fz_colorspace **)(node));\n\t\t\t\tnode += SIZE_IN_NODES(sizeof(fz_colorspace *));\n\t\t\t\ten = fz_colorspace_n(ctx, colorspace);\n\t\t\t\tfor (i = 0; i < en; i++)\n\t\t\t\t\tcolor[i] = 0.0f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (n.color)\n\t\t{\n\t\t\tint nc = fz_colorspace_n(ctx, colorspace);\n\t\t\tmemcpy(color, (float *)node, nc * sizeof(float));\n\t\t\tnode += SIZE_IN_NODES(nc * sizeof(float));\n\t\t}\n\t\tif (n.alpha)\n\t\t{\n\t\t\tswitch(n.alpha)\n\t\t\t{\n\t\t\tdefault:\n\t\t\tcase ALPHA_0:\n\t\t\t\talpha = 0.0f;\n\t\t\t\tbreak;\n\t\t\tcase ALPHA_1:\n\t\t\t\talpha = 1.0f;\n\t\t\t\tbreak;\n\t\t\tcase ALPHA_PRESENT:\n\t\t\t\talpha = *(float *)node;\n\t\t\t\tnode += SIZE_IN_NODES(sizeof(float));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (n.ctm != 0)\n\t\t{\n\t\t\tfloat *packed_ctm = (float *)node;\n\t\t\tif (n.ctm & CTM_CHANGE_AD)\n\t\t\t{\n\t\t\t\tctm.a = *packed_ctm++;\n\t\t\t\tctm.d = *packed_ctm++;\n\t\t\t\tnode += SIZE_IN_NODES(2*sizeof(float));\n\t\t\t}\n\t\t\tif (n.ctm & CTM_CHANGE_BC)\n\t\t\t{\n\t\t\t\tctm.b = *packed_ctm++;\n\t\t\t\tctm.c = *packed_ctm++;\n\t\t\t\tnode += SIZE_IN_NODES(2*sizeof(float));\n\t\t\t}\n\t\t\tif (n.ctm & CTM_CHANGE_EF)\n\t\t\t{\n\t\t\t\tctm.e = *packed_ctm++;\n\t\t\t\tctm.f = *packed_ctm;\n\t\t\t\tnode += SIZE_IN_NODES(2*sizeof(float));\n\t\t\t}\n\t\t}\n\t\tif (n.stroke)\n\t\t{\n\t\t\talign_node_for_pointer(&node);\n\t\t\tfz_drop_stroke_state(ctx, stroke);\n\t\t\tstroke = fz_keep_stroke_state(ctx, *(fz_stroke_state **)node);\n\t\t\tnode += SIZE_IN_NODES(sizeof(fz_stroke_state *));\n\t\t}\n\t\tif (n.path)\n\t\t{\n\t\t\talign_node_for_pointer(&node);\n\t\t\tfz_drop_path(ctx, path);\n\t\t\tpath = fz_keep_path(ctx, (fz_path *)node);\n\t\t\tnode += SIZE_IN_NODES(fz_packed_path_size(path));\n\t\t}\n\n\t\tif (tile_skip_depth > 0)\n\t\t{\n\t\t\tif (n.cmd == FZ_CMD_BEGIN_TILE)\n\t\t\t\ttile_skip_depth++;\n\t\t\telse if (n.cmd == FZ_CMD_END_TILE)\n\t\t\t\ttile_skip_depth--;\n\t\t\tif (tile_skip_depth > 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttrans_rect = fz_transform_rect(rect, top_ctm);\n\n\t\t/* cull objects to draw using a quick visibility test */\n\n\t\tif (tiled ||\n\t\t\tn.cmd == FZ_CMD_BEGIN_TILE || n.cmd == FZ_CMD_END_TILE ||\n\t\t\tn.cmd == FZ_CMD_RENDER_FLAGS || n.cmd == FZ_CMD_DEFAULT_COLORSPACES ||\n\t\t\tn.cmd == FZ_CMD_BEGIN_LAYER || n.cmd == FZ_CMD_END_LAYER ||\n\t\t\tn.cmd == FZ_CMD_BEGIN_STRUCTURE || n.cmd == FZ_CMD_END_STRUCTURE ||\n\t\t\tn.cmd == FZ_CMD_BEGIN_METATEXT || n.cmd == FZ_CMD_END_METATEXT\n\t\t\t)\n\t\t{\n\t\t\tempty = 0;\n\t\t}\n\t\telse if (n.cmd == FZ_CMD_FILL_PATH || n.cmd == FZ_CMD_STROKE_PATH)\n\t\t{\n\t\t\t/* Zero area paths are suitable for stroking. */\n\t\t\tempty = !fz_is_valid_rect(fz_intersect_rect(trans_rect, scissor));\n\t\t}\n\t\telse if (n.cmd == FZ_CMD_FILL_TEXT || n.cmd == FZ_CMD_STROKE_TEXT ||\n\t\t\tn.cmd == FZ_CMD_CLIP_TEXT || n.cmd == FZ_CMD_CLIP_STROKE_TEXT)\n\t\t{\n\t\t\t/* Zero area text (such as spaces) should be passed\n\t\t\t * through. Text that is completely outside the scissor\n\t\t\t * can be elided. */\n\t\t\tempty = !fz_is_valid_rect(fz_intersect_rect(trans_rect, scissor));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tempty = fz_is_empty_rect(fz_intersect_rect(trans_rect, scissor));\n\t\t}\n\n\t\tif (clipped || empty)\n\t\t{\n\t\t\tswitch (n.cmd)\n\t\t\t{\n\t\t\tcase FZ_CMD_CLIP_PATH:\n\t\t\tcase FZ_CMD_CLIP_STROKE_PATH:\n\t\t\tcase FZ_CMD_CLIP_TEXT:\n\t\t\tcase FZ_CMD_CLIP_STROKE_TEXT:\n\t\t\tcase FZ_CMD_CLIP_IMAGE_MASK:\n\t\t\tcase FZ_CMD_BEGIN_MASK:\n\t\t\tcase FZ_CMD_BEGIN_GROUP:\n\t\t\t\tclipped++;\n\t\t\t\tcontinue;\n\t\t\tcase FZ_CMD_POP_CLIP:\n\t\t\tcase FZ_CMD_END_GROUP:\n\t\t\t\tif (!clipped)\n\t\t\t\t\tgoto visible;\n\t\t\t\tclipped--;\n\t\t\t\tcontinue;\n\t\t\tcase FZ_CMD_END_MASK:\n\t\t\t\tif (!clipped)\n\t\t\t\t\tgoto visible;\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\nvisible:\n\t\ttrans_ctm = fz_concat(ctm, top_ctm);\n\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tswitch (n.cmd)\n\t\t\t{\n\t\t\tcase FZ_CMD_FILL_PATH:\n\t\t\t\tfz_unpack_color_params(&color_params, n.flags);\n\t\t\t\tfz_fill_path(ctx, dev, path, n.flags & 1, trans_ctm, colorspace, color, alpha, color_params);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_STROKE_PATH:\n\t\t\t\tfz_unpack_color_params(&color_params, n.flags);\n\t\t\t\tfz_stroke_path(ctx, dev, path, stroke, trans_ctm, colorspace, color, alpha, color_params);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_CLIP_PATH:\n\t\t\t\tfz_clip_path(ctx, dev, path, n.flags, trans_ctm, trans_rect);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_CLIP_STROKE_PATH:\n\t\t\t\tfz_clip_stroke_path(ctx, dev, path, stroke, trans_ctm, trans_rect);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_FILL_TEXT:\n\t\t\t\tfz_unpack_color_params(&color_params, n.flags);\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_fill_text(ctx, dev, *(fz_text **)node, trans_ctm, colorspace, color, alpha, color_params);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_STROKE_TEXT:\n\t\t\t\tfz_unpack_color_params(&color_params, n.flags);\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_stroke_text(ctx, dev, *(fz_text **)node, stroke, trans_ctm, colorspace, color, alpha, color_params);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_CLIP_TEXT:\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_clip_text(ctx, dev, *(fz_text **)node, trans_ctm, trans_rect);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_CLIP_STROKE_TEXT:\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_clip_stroke_text(ctx, dev, *(fz_text **)node, stroke, trans_ctm, trans_rect);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_IGNORE_TEXT:\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_ignore_text(ctx, dev, *(fz_text **)node, trans_ctm);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_FILL_SHADE:\n\t\t\t\tfz_unpack_color_params(&color_params, n.flags);\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_fill_shade(ctx, dev, *(fz_shade **)node, trans_ctm, alpha, color_params);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_FILL_IMAGE:\n\t\t\t\tfz_unpack_color_params(&color_params, n.flags);\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_fill_image(ctx, dev, *(fz_image **)node, trans_ctm, alpha, color_params);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_FILL_IMAGE_MASK:\n\t\t\t\tfz_unpack_color_params(&color_params, n.flags);\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_fill_image_mask(ctx, dev, *(fz_image **)node, trans_ctm, colorspace, color, alpha, color_params);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_CLIP_IMAGE_MASK:\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_clip_image_mask(ctx, dev, *(fz_image **)node, trans_ctm, trans_rect);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_POP_CLIP:\n\t\t\t\tfz_pop_clip(ctx, dev);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_BEGIN_MASK:\n\t\t\t\tfz_unpack_color_params(&color_params, n.flags);\n\t\t\t\tfz_begin_mask(ctx, dev, trans_rect, n.flags & 1, colorspace, color, color_params);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_END_MASK:\n\t\t\t\tfz_end_mask(ctx, dev);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_BEGIN_GROUP:\n\t\t\t\tfz_begin_group(ctx, dev, trans_rect, colorspace, (n.flags & ISOLATED) != 0, (n.flags & KNOCKOUT) != 0, (n.flags>>2), alpha);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_END_GROUP:\n\t\t\t\tfz_end_group(ctx, dev);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_BEGIN_TILE:\n\t\t\t{\n\t\t\t\tint cached;\n\t\t\t\tfz_list_tile_data *data;\n\t\t\t\tfz_rect tile_rect;\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tdata = (fz_list_tile_data *)node;\n\t\t\t\ttiled++;\n\t\t\t\ttile_rect = data->view;\n\t\t\t\tcached = fz_begin_tile_id(ctx, dev, rect, tile_rect, data->xstep, data->ystep, trans_ctm, data->id);\n\t\t\t\tif (cached)\n\t\t\t\t\ttile_skip_depth = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase FZ_CMD_END_TILE:\n\t\t\t\ttiled--;\n\t\t\t\tfz_end_tile(ctx, dev);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_RENDER_FLAGS:\n\t\t\t\tif (n.flags == 0)\n\t\t\t\t\tfz_render_flags(ctx, dev, 0, FZ_DEVFLAG_GRIDFIT_AS_TILED);\n\t\t\t\telse if (n.flags == 1)\n\t\t\t\t\tfz_render_flags(ctx, dev, FZ_DEVFLAG_GRIDFIT_AS_TILED, 0);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_DEFAULT_COLORSPACES:\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_set_default_colorspaces(ctx, dev, *(fz_default_colorspaces **)node);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_BEGIN_LAYER:\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tfz_begin_layer(ctx, dev, (const char *)node);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_END_LAYER:\n\t\t\t\tfz_end_layer(ctx, dev);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_BEGIN_STRUCTURE:\n\t\t\t{\n\t\t\t\tconst unsigned char *data;\n\t\t\t\tint uid;\n\t\t\t\talign_node_for_pointer(&node);\n\t\t\t\tdata = (const unsigned char *)node;\n\t\t\t\tmemcpy(&uid, data+1, sizeof(uid));\n\t\t\t\tfz_begin_structure(ctx, dev, (fz_structure)data[0], (const char *)(data[1+sizeof(uid)] == 0 ? NULL : &data[1+sizeof(uid)]), uid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase FZ_CMD_END_STRUCTURE:\n\t\t\t\tfz_end_structure(ctx, dev);\n\t\t\t\tbreak;\n\t\t\tcase FZ_CMD_BEGIN_METATEXT:\n\t\t\t{\n\t\t\t\tconst unsigned char *data;\n\t\t\t\tconst char *text;\n\t\t\t\tdata = (const unsigned char *)node;\n\t\t\t\ttext = (const char *)&data[1];\n\t\t\t\tfz_begin_metatext(ctx, dev, (fz_metatext)data[0], (text[0] == 0 ? NULL : text));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase FZ_CMD_END_METATEXT:\n\t\t\t\tfz_end_metatext(ctx, dev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\t/* Swallow the error */\n\t\t\tif (cookie)\n\t\t\t\tcookie->errors++;\n\t\t\tif (fz_caught(ctx) == FZ_ERROR_ABORT)\n\t\t\t\tbreak;\n\t\t\tfz_warn(ctx, \"Ignoring error during interpretation\");\n\t\t}\n\t}\n\tfz_drop_colorspace(ctx, colorspace);\n\tfz_drop_stroke_state(ctx, stroke);\n\tfz_drop_path(ctx, path);\n\tif (cookie)\n\t\tcookie->progress = progress;\n}",
        "file_path": "/src/mupdf/source/fitz/list-device.c",
        "crashing_line": "\t\t\t\tfz_fill_image(ctx, dev, *(fz_image **)node, trans_ctm, alpha, color_params);",
        "crashing_line_number": 1985
      },
      {
        "function_name": "fz_run_t3_glyph",
        "function_body": "void\nfz_run_t3_glyph(fz_context *ctx, fz_font *font, int gid, fz_matrix trm, fz_device *dev)\n{\n\tfz_display_list *list;\n\tfz_matrix ctm;\n\n\tlist = font->t3lists[gid];\n\tif (!list)\n\t\treturn;\n\n\tctm = fz_concat(font->t3matrix, trm);\n\tfz_run_display_list(ctx, list, dev, ctm, fz_infinite_rect, NULL);\n}",
        "file_path": "/src/mupdf/source/fitz/font.c",
        "crashing_line": "\tfz_run_display_list(ctx, list, dev, ctm, fz_infinite_rect, NULL);",
        "crashing_line_number": 1608
      },
      {
        "function_name": "fz_render_t3_glyph_pixmap",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/font.c",
        "crashing_line": "",
        "crashing_line_number": 1657
      },
      {
        "function_name": "fz_render_t3_glyph",
        "function_body": "void\nfz_render_t3_glyph_direct(fz_context *ctx, fz_device *dev, fz_font *font, int gid, fz_matrix trm, void *gstate, fz_default_colorspaces *def_cs)\n{\n\tfz_matrix ctm;\n\n\tif (gid < 0 || gid > 255)\n\t\treturn;\n\n\tif (font->t3flags[gid] & FZ_DEVFLAG_MASK)\n\t{\n\t\tif (font->t3flags[gid] & FZ_DEVFLAG_COLOR)\n\t\t\tfz_warn(ctx, \"type3 glyph claims to be both masked and colored\");\n\t}\n\telse if (!(font->t3flags[gid] & FZ_DEVFLAG_COLOR))\n\t{\n\t\tfz_warn(ctx, \"type3 glyph doesn't specify masked or colored\");\n\t}\n\n\tctm = fz_concat(font->t3matrix, trm);\n\tfont->t3run(ctx, font->t3doc, font->t3resources, font->t3procs[gid], dev, ctm, gstate, def_cs);\n}",
        "file_path": "/src/mupdf/source/fitz/font.c",
        "crashing_line": "",
        "crashing_line_number": 1694
      },
      {
        "function_name": "fz_render_glyph",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/draw-glyph.c",
        "crashing_line": "",
        "crashing_line_number": 363
      },
      {
        "function_name": "fz_draw_fill_text",
        "function_body": "static void\nfz_draw_fill_text(fz_context *ctx, fz_device *devp, const fz_text *text, fz_matrix in_ctm,\n\tfz_colorspace *colorspace_in, const float *color, float alpha, fz_color_params color_params)\n{\n\tfz_draw_device *dev = (fz_draw_device*)devp;\n\tfz_matrix ctm = fz_concat(in_ctm, dev->transform);\n\tfz_draw_state *state = &dev->stack[dev->top];\n\tfz_colorspace *model = state->dest->colorspace;\n\tunsigned char colorbv[FZ_MAX_COLORS + 1];\n\tunsigned char shapebv, shapebva;\n\tfz_text_span *span;\n\tint i;\n\tfz_colorspace *colorspace = NULL;\n\tfz_rasterizer *rast = dev->rast;\n\tfz_overprint op = { { 0 } };\n\tfz_overprint *eop;\n\n\tif (dev->top == 0 && dev->resolve_spots)\n\t\tstate = push_group_for_separations(ctx, dev, color_params, dev->default_cs);\n\n\tif (colorspace_in)\n\t\tcolorspace = fz_default_colorspace(ctx, dev->default_cs, colorspace_in);\n\n\tif (colorspace == NULL && model != NULL)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"color destination requires source color\");\n\n\tif (alpha == 0)\n\t\treturn;\n\n\tif (state->blendmode & FZ_BLEND_KNOCKOUT && alpha != 1)\n\t\tstate = fz_knockout_begin(ctx, dev);\n\n\teop = resolve_color(ctx, &op, color, colorspace, alpha, color_params, colorbv, state->dest, dev->overprint_possible);\n\tshapebv = 255;\n\tshapebva = 255 * alpha;\n\n\tfor (span = text->head; span; span = span->next)\n\t{\n\t\tfz_matrix tm, trm;\n\t\tfz_glyph *glyph;\n\t\tint gid;\n\n\t\ttm = span->trm;\n\n\t\tfor (i = 0; i < span->len; i++)\n\t\t{\n\t\t\tgid = span->items[i].gid;\n\t\t\tif (gid < 0)\n\t\t\t\tcontinue;\n\n\t\t\ttm.e = span->items[i].x;\n\t\t\ttm.f = span->items[i].y;\n\t\t\ttrm = fz_concat(tm, ctm);\n\n\t\t\tglyph = fz_render_glyph(ctx, span->font, gid, &trm, model, &state->scissor, state->dest->alpha, fz_rasterizer_text_aa_level(rast));\n\t\t\tif (glyph)\n\t\t\t{\n\t\t\t\tfz_pixmap *pixmap = glyph->pixmap;\n\t\t\t\tint x = floorf(trm.e);\n\t\t\t\tint y = floorf(trm.f);\n\t\t\t\tif (pixmap == NULL || pixmap->n == 1)\n\t\t\t\t{\n\t\t\t\t\tdraw_glyph(colorbv, state->dest, glyph, x, y, &state->scissor, eop);\n\t\t\t\t\tif (state->shape)\n\t\t\t\t\t\tdraw_glyph(&shapebv, state->shape, glyph, x, y, &state->scissor, 0);\n\t\t\t\t\tif (state->group_alpha)\n\t\t\t\t\t\tdraw_glyph(&shapebva, state->group_alpha, glyph, x, y, &state->scissor, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_matrix mat;\n\t\t\t\t\tmat.a = pixmap->w; mat.b = mat.c = 0; mat.d = pixmap->h;\n\t\t\t\t\tmat.e = x + pixmap->x; mat.f = y + pixmap->y;\n\t\t\t\t\tmat = fz_gridfit_matrix(devp->flags & FZ_DEVFLAG_GRIDFIT_AS_TILED, mat);\n\t\t\t\t\tfz_paint_image(ctx, state->dest, &state->scissor, state->shape, state->group_alpha, pixmap, mat, alpha * 255, !(devp->hints & FZ_DONT_INTERPOLATE_IMAGES), eop);\n\t\t\t\t}\n\t\t\t\tfz_drop_glyph(ctx, glyph);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfz_path *path = fz_outline_glyph(ctx, span->font, gid, tm);\n\t\t\t\tif (path)\n\t\t\t\t{\n\t\t\t\t\tfz_draw_fill_path(ctx, devp, path, 0, in_ctm, colorspace, color, alpha, color_params);\n\t\t\t\t\tfz_drop_path(ctx, path);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_warn(ctx, \"cannot render glyph\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (state->blendmode & FZ_BLEND_KNOCKOUT && alpha != 1)\n\t\tfz_knockout_end(ctx, dev);\n}",
        "file_path": "/src/mupdf/source/fitz/draw-device.c",
        "crashing_line": "\t\t\tglyph = fz_render_glyph(ctx, span->font, gid, &trm, model, &state->scissor, state->dest->alpha, fz_rasterizer_text_aa_level(rast));",
        "crashing_line_number": 1052
      },
      {
        "function_name": "fz_fill_text",
        "function_body": "void\nfz_fill_text(fz_context *ctx, fz_device *dev, const fz_text *text, fz_matrix ctm,\n\tfz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)\n{\n\tif (dev->fill_text)\n\t{\n\t\tfz_try(ctx)\n\t\t\tdev->fill_text(ctx, dev, text, ctm, colorspace, color, alpha, color_params);\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tfz_disable_device(ctx, dev);\n\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}",
        "file_path": "/src/mupdf/source/fitz/device.c",
        "crashing_line": "\t\t\tdev->fill_text(ctx, dev, text, ctm, colorspace, color, alpha, color_params);",
        "crashing_line_number": 237
      },
      {
        "function_name": "pdf_flush_text",
        "function_body": "",
        "file_path": "/src/mupdf/source/pdf/pdf-op-run.c",
        "crashing_line": "",
        "crashing_line_number": 893
      },
      {
        "function_name": "pdf_run_ET",
        "function_body": "static void pdf_run_ET(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_flush_text(ctx, pr);\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-op-run.c",
        "crashing_line": "\tpdf_flush_text(ctx, pr);",
        "crashing_line_number": 2359
      },
      {
        "function_name": "pdf_process_stream",
        "function_body": "static void\npdf_process_stream(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm)\n{\n\tpdf_document *doc = csi->doc;\n\tpdf_lexbuf *buf = csi->buf;\n\tfz_cookie *cookie = csi->cookie;\n\n\tpdf_token tok = PDF_TOK_ERROR;\n\tint in_text_array = 0;\n\tint syntax_errors = 0;\n\n\t/* make sure we have a clean slate if we come here from flush_text */\n\tpdf_clear_stack(ctx, csi);\n\n\tfz_var(in_text_array);\n\tfz_var(tok);\n\n\tif (cookie)\n\t{\n\t\tcookie->progress_max = -1;\n\t\tcookie->progress = 0;\n\t}\n\n\tdo\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\t/* Check the cookie */\n\t\t\t\tif (cookie)\n\t\t\t\t{\n\t\t\t\t\tif (cookie->abort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcookie->progress++;\n\t\t\t\t}\n\n\t\t\t\ttok = pdf_lex(ctx, stm, buf);\n\n\t\t\t\tif (in_text_array)\n\t\t\t\t{\n\t\t\t\t\tswitch(tok)\n\t\t\t\t\t{\n\t\t\t\t\tcase PDF_TOK_CLOSE_ARRAY:\n\t\t\t\t\t\tin_text_array = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\t\tpdf_array_push_real(ctx, csi->obj, buf->f);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\t\tpdf_array_push_int(ctx, csi->obj, buf->i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\t\tpdf_array_push_string(ctx, csi->obj, buf->scratch, buf->len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\t\tif (buf->scratch[0] == 'T' && (buf->scratch[1] == 'w' || buf->scratch[1] == 'c') && buf->scratch[2] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint n = pdf_array_len(ctx, csi->obj);\n\t\t\t\t\t\t\tif (n > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpdf_obj *o = pdf_array_get(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\tif (pdf_is_number(ctx, o))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcsi->stack[0] = pdf_to_real(ctx, o);\n\t\t\t\t\t\t\t\t\tpdf_array_delete(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Deliberate Fallthrough! */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in array\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse switch (tok)\n\t\t\t\t{\n\t\t\t\tcase PDF_TOK_ENDSTREAM:\n\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_ARRAY:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (csi->in_text)\n\t\t\t\t\t{\n\t\t\t\t\t\tin_text_array = 1;\n\t\t\t\t\t\tcsi->obj = pdf_new_array(ctx, doc, 4);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcsi->obj = pdf_parse_array(ctx, doc, stm, buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_DICT:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tcsi->obj = pdf_parse_dict(ctx, doc, stm, buf);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_NAME:\n\t\t\t\t\tif (csi->name[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\tcsi->obj = pdf_new_name(ctx, buf->scratch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_strlcpy(csi->name, buf->scratch, sizeof(csi->name));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->i;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->f;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\tif (buf->len <= sizeof(csi->string))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(csi->string, buf->scratch, buf->len);\n\t\t\t\t\t\tcsi->string_len = buf->len;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsi->obj = pdf_new_string(ctx, buf->scratch, buf->len);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\tpdf_clear_stack(ctx, csi);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in content stream\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (tok != PDF_TOK_EOF);\n\t\t}\n\t\tfz_always(ctx)\n\t\t{\n\t\t\tpdf_clear_stack(ctx, csi);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tint caught = fz_caught(ctx);\n\t\t\tif (cookie)\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t{\n\t\t\t\t\tcookie->incomplete++;\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t\t/* ignore minor errors */ ;\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* If we do catch an error, then reset ourselves to a base lexing state */\n\t\t\tin_text_array = 0;\n\t\t}\n\t}\n\twhile (tok != PDF_TOK_EOF);\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-interpret.c",
        "crashing_line": "\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);",
        "crashing_line_number": 991
      },
      {
        "function_name": "pdf_process_raw_contents",
        "function_body": "void\npdf_process_raw_contents(fz_context *ctx, pdf_processor *proc, pdf_document *doc, pdf_obj *rdb, pdf_obj *stmobj, fz_cookie *cookie)\n{\n\tpdf_csi csi;\n\tpdf_lexbuf buf;\n\tfz_stream *stm = NULL;\n\n\tif (!stmobj)\n\t\treturn;\n\n\tfz_var(stm);\n\n\tpdf_lexbuf_init(ctx, &buf, PDF_LEXBUF_SMALL);\n\tpdf_init_csi(ctx, &csi, doc, rdb, &buf, cookie);\n\n\tfz_try(ctx)\n\t{\n\t\tfz_defer_reap_start(ctx);\n\t\tstm = pdf_open_contents_stream(ctx, doc, stmobj);\n\t\tpdf_process_stream(ctx, proc, &csi, stm);\n\t\tpdf_process_end(ctx, proc, &csi);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_defer_reap_end(ctx);\n\t\tfz_drop_stream(ctx, stm);\n\t\tpdf_clear_stack(ctx, &csi);\n\t\tpdf_lexbuf_fin(ctx, &buf);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tproc->close_processor = NULL; /* aborted run, don't warn about unclosed processor */\n\t\tfz_rethrow(ctx);\n\t}\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-interpret.c",
        "crashing_line": "\t\tpdf_process_stream(ctx, proc, &csi, stm);",
        "crashing_line_number": 1095
      },
      {
        "function_name": "pdf_process_contents",
        "function_body": "void\npdf_process_contents(fz_context *ctx, pdf_processor *proc, pdf_document *doc, pdf_obj *rdb, pdf_obj *stmobj, fz_cookie *cookie, pdf_obj **out_res)\n{\n\tpdf_processor_push_resources(ctx, proc, rdb);\n\tfz_try(ctx)\n\t\tpdf_process_raw_contents(ctx, proc, doc, rdb, stmobj, cookie);\n\tfz_always(ctx)\n\t{\n\t\tpdf_obj *res = pdf_processor_pop_resources(ctx, proc);\n\t\tif (out_res)\n\t\t\t*out_res = res;\n\t\telse\n\t\t\tpdf_drop_obj(ctx, res);\n\t}\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-interpret.c",
        "crashing_line": "\t\tpdf_process_raw_contents(ctx, proc, doc, rdb, stmobj, cookie);",
        "crashing_line_number": 1117
      },
      {
        "function_name": "pdf_run_page_contents_with_usage_imp",
        "function_body": "static void\npdf_run_page_contents_with_usage_imp(fz_context *ctx, pdf_document *doc, pdf_page *page, fz_device *dev, fz_matrix ctm, const char *usage, fz_cookie *cookie)\n{\n\tfz_matrix page_ctm;\n\tpdf_obj *resources;\n\tpdf_obj *contents;\n\tfz_rect fitzbox;\n\tfz_rect mediabox, cropbox;\n\tpdf_processor *proc = NULL;\n\tfz_default_colorspaces *default_cs = NULL;\n\tfz_colorspace *colorspace = NULL;\n\tfz_path *path = NULL;\n\tint struct_parent_num = -1;\n\tpdf_obj *struct_parent;\n\n\tfz_var(proc);\n\tfz_var(colorspace);\n\tfz_var(default_cs);\n\tfz_var(path);\n\n\tif (cookie && page->super.incomplete)\n\t\tcookie->incomplete = 1;\n\n\tfz_try(ctx)\n\t{\n\t\tdefault_cs = pdf_load_default_colorspaces(ctx, doc, page);\n\t\tif (default_cs)\n\t\t\tfz_set_default_colorspaces(ctx, dev, default_cs);\n\n\t\tpdf_page_transform(ctx, page, &fitzbox, &page_ctm);\n\t\tctm = fz_concat(page_ctm, ctm);\n\t\tfitzbox = fz_transform_rect(fitzbox, ctm);\n\n\t\tresources = pdf_page_resources(ctx, page);\n\t\tcontents = pdf_page_contents(ctx, page);\n\n\t\tmediabox = pdf_page_mediabox(ctx, page);\n\t\tcropbox = pdf_page_cropbox(ctx, page);\n\n\t\tif (page->transparency)\n\t\t{\n\t\t\tpdf_obj *group = pdf_page_group(ctx, page);\n\n\t\t\tif (group)\n\t\t\t{\n\t\t\t\tpdf_obj *cs = pdf_dict_get(ctx, group, PDF_NAME(CS));\n\t\t\t\tif (cs)\n\t\t\t\t{\n\t\t\t\t\tfz_try(ctx)\n\t\t\t\t\t\tcolorspace = pdf_load_colorspace(ctx, cs);\n\t\t\t\t\tfz_catch(ctx)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t\t\t\t\tfz_warn(ctx, \"Ignoring Page blending colorspace.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fz_is_valid_blend_colorspace(ctx, colorspace))\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"Ignoring invalid Page blending colorspace: %s.\", colorspace->name);\n\t\t\t\t\t\tfz_drop_colorspace(ctx, colorspace);\n\t\t\t\t\t\tcolorspace = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_default_output_intent(ctx, default_cs));\n\n\t\t\tfz_begin_group(ctx, dev, fitzbox, colorspace, 1, 0, 0, 1);\n\t\t}\n\n\t\tstruct_parent = pdf_dict_get(ctx, page->obj, PDF_NAME(StructParents));\n\t\tif (pdf_is_number(ctx, struct_parent))\n\t\t\tstruct_parent_num = pdf_to_int(ctx, struct_parent);\n\n\t\t/* Clip content to CropBox if it is smaller than the MediaBox */\n\t\tif (cropbox.x0 > mediabox.x0 || cropbox.x1 < mediabox.x1 || cropbox.y0 > mediabox.y0 || cropbox.y1 < mediabox.y1)\n\t\t{\n\t\t\tpath = fz_new_path(ctx);\n\t\t\tfz_rectto(ctx, path, cropbox.x0, cropbox.y0, cropbox.x1, cropbox.y1);\n\t\t\tfz_clip_path(ctx, dev, path, 1, ctm, fz_infinite_rect);\n\t\t}\n\n\t\tproc = pdf_new_run_processor(ctx, page->doc, dev, ctm, struct_parent_num, usage, NULL, default_cs, cookie);\n\t\tpdf_process_contents(ctx, proc, doc, resources, contents, cookie, NULL);\n\t\tpdf_close_processor(ctx, proc);\n\n\t\tif (cropbox.x0 > mediabox.x0 || cropbox.x1 < mediabox.x1 || cropbox.y0 > mediabox.y0 || cropbox.y1 < mediabox.y1)\n\t\t{\n\t\t\tfz_pop_clip(ctx, dev);\n\t\t}\n\n\t\tif (page->transparency)\n\t\t{\n\t\t\tfz_end_group(ctx, dev);\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_path(ctx, path);\n\t\tpdf_drop_processor(ctx, proc);\n\t\tfz_drop_colorspace(ctx, colorspace);\n\t\tfz_drop_default_colorspaces(ctx, default_cs);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-run.c",
        "crashing_line": "\t\tpdf_process_contents(ctx, proc, doc, resources, contents, cookie, NULL);",
        "crashing_line_number": 199
      },
      {
        "function_name": "pdf_run_page_contents_with_usage",
        "function_body": "void pdf_run_page_contents_with_usage(fz_context *ctx, pdf_page *page, fz_device *dev, fz_matrix ctm, const char *usage, fz_cookie *cookie)\n{\n\tpdf_document *doc = page->doc;\n\tint nocache;\n\n\tnocache = !!(dev->hints & FZ_NO_CACHE);\n\tif (nocache)\n\t\tpdf_mark_xref(ctx, doc);\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_run_page_contents_with_usage_imp(ctx, doc, page, dev, ctm, usage, cookie);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tif (nocache)\n\t\t\tpdf_clear_xref_to_mark(ctx, doc);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-run.c",
        "crashing_line": "\t\tpdf_run_page_contents_with_usage_imp(ctx, doc, page, dev, ctm, usage, cookie);",
        "crashing_line_number": 236
      },
      {
        "function_name": "pdf_run_page_contents",
        "function_body": "void pdf_run_page_contents(fz_context *ctx, pdf_page *page, fz_device *dev, fz_matrix ctm, fz_cookie *cookie)\n{\n\tpdf_run_page_contents_with_usage(ctx, page, dev, ctm, \"View\", cookie);\n}",
        "file_path": "/src/mupdf/source/pdf/pdf-run.c",
        "crashing_line": "\tpdf_run_page_contents_with_usage(ctx, page, dev, ctm, \"View\", cookie);",
        "crashing_line_number": 251
      },
      {
        "function_name": "fz_run_page_contents",
        "function_body": "void\nfz_run_page_contents(fz_context *ctx, fz_page *page, fz_device *dev, fz_matrix transform, fz_cookie *cookie)\n{\n\tif (page && page->run_page_contents)\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tpage->run_page_contents(ctx, page, dev, transform, cookie);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tdev->close_device = NULL; /* aborted run, don't warn about unclosed device */\n\t\t\tif (fz_caught(ctx) != FZ_ERROR_ABORT)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}",
        "file_path": "/src/mupdf/source/fitz/document.c",
        "crashing_line": "\t\t\tpage->run_page_contents(ctx, page, dev, transform, cookie);",
        "crashing_line_number": 707
      },
      {
        "function_name": "fz_run_page",
        "function_body": "void\nfz_run_page(fz_context *ctx, fz_page *page, fz_device *dev, fz_matrix transform, fz_cookie *cookie)\n{\n\tfz_run_page_contents(ctx, page, dev, transform, cookie);\n\tfz_run_page_annots(ctx, page, dev, transform, cookie);\n\tfz_run_page_widgets(ctx, page, dev, transform, cookie);\n}",
        "file_path": "/src/mupdf/source/fitz/document.c",
        "crashing_line": "\tfz_run_page_contents(ctx, page, dev, transform, cookie);",
        "crashing_line_number": 757
      },
      {
        "function_name": "fz_new_pixmap_from_page_with_separations",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/util.c",
        "crashing_line": "",
        "crashing_line_number": 226
      },
      {
        "function_name": "fz_new_pixmap_from_page_number_with_separations",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/util.c",
        "crashing_line": "",
        "crashing_line_number": 256
      },
      {
        "function_name": "fz_new_pixmap_from_page_number",
        "function_body": "",
        "file_path": "/src/mupdf/source/fitz/util.c",
        "crashing_line": "",
        "crashing_line_number": 245
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static int\npiv_compute_signature(sc_card_t *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tpiv_private_data_t * priv = PIV_DATA(card);\n\tint r;\n\tint i;\n\tsize_t nLen;\n\tu8 rbuf[128]; /* For EC conversions  384 will fit */\n\tconst unsigned char *pseq, *pint, *ptemp, *pend;\n\tunsigned int cla, tag;\n\tsize_t seqlen;\n\tsize_t intlen;\n\tsize_t templen;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* The PIV returns a DER SEQUENCE{INTEGER, INTEGER}\n\t * Which may have leading 00 to force a positive integer\n\t * But PKCS11 just wants 2* field_length in bytes\n\t * So we have to strip out the integers\n\t * and pad on left if too short.\n\t */\n\n\tif (priv->alg_id == 0x11 || priv->alg_id == 0x14 ) {\n\t\tnLen = (priv->key_size + 7) / 8;\n\t\tif (outlen < 2*nLen) {\n\t\t\tsc_log(card->ctx,\n\t\t\t       \" output too small for EC signature %\"SC_FORMAT_LEN_SIZE_T\"u < %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       outlen, 2 * nLen);\n\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\tgoto err;\n\t\t}\n\t\tmemset(out, 0, outlen);\n\n\t\tr = piv_validate_general_authentication(card, data, datalen, rbuf, sizeof rbuf);\n\t\tif (r < 0)\n\t\t\tgoto err;\n\n\t\tpseq = rbuf;\n\t\tr = sc_asn1_read_tag(&pseq, r, &cla, &tag, &seqlen);\n\t\tif (pseq == NULL || r < 0 || seqlen == 0 || (cla|tag) != 0x30)\n\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"Can't find 0x30\");\n\n\t\tpint = pseq;\n\t\tpend = pseq + seqlen;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tr = sc_asn1_read_tag(&pint, (pend - pint), &cla, &tag, &intlen);\n\t\t\tif (pint == NULL || r < 0 || intlen == 0 || (cla|tag) != 0x02)\n\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"Can't find 0x02\");\n\t\t\tif (intlen > nLen + 1)\n\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA,\"Signature too long\");\n\n\t\t\tptemp = pint;\n\t\t\ttemplen = intlen;\n\t\t\tif (intlen > nLen) { /* drop leading 00 if present */\n\t\t\t\tif (*ptemp != 0x00) {\n\t\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA,\"Signature too long\");\n\t\t\t\t}\n\t\t\t\tptemp++;\n\t\t\t\ttemplen--;\n\t\t\t}\n\t\t\tmemcpy(out + nLen*i + nLen - templen, ptemp, templen);\n\t\t\tpint += intlen; /* next integer */\n\t\t\t\n\t\t}\n\t\tr = 2 * nLen;\n\t} else { /* RSA is all set */\n\t\tr = piv_validate_general_authentication(card, data, datalen, out, outlen);\n\t}\n\nerr:\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\nstatic int sc_hsm_decode_ecdsa_signature(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen) {\n\n\tint i, r;\n\tsize_t fieldsizebytes;\n\tconst u8 *body, *tag;\n\tsize_t bodylen, taglen;\n\n\t// Determine field size from length of signature\n\tif (datalen <= 58) {\t\t\t// 192 bit curve = 24 * 2 + 10 byte maximum DER signature\n\t\tfieldsizebytes = 24;\n\t} else if (datalen <= 66) {\t\t// 224 bit curve = 28 * 2 + 10 byte maximum DER signature\n\t\tfieldsizebytes = 28;\n\t} else if (datalen <= 74) {\t\t// 256 bit curve = 32 * 2 + 10 byte maximum DER signature\n\t\tfieldsizebytes = 32;\n\t} else if (datalen <= 90) {\t\t// 320 bit curve = 40 * 2 + 10 byte maximum DER signature\n\t\tfieldsizebytes = 40;\n\t} else if (datalen <= 106) {\t\t// 384 bit curve = 48 * 2 + 10 byte maximum DER signature\n\t\tfieldsizebytes = 48;\n\t} else if (datalen <= 137) {\t\t// 512 bit curve = 64 * 2 + 9 byte maximum DER signature\n\t\tfieldsizebytes = 64;\n\t} else {\n\t\tfieldsizebytes = 66;\n\t}\n\n\tsc_log(card->ctx,\n\t       \"Field size %\"SC_FORMAT_LEN_SIZE_T\"u, signature buffer size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       fieldsizebytes, outlen);\n\n\tif (outlen < (fieldsizebytes * 2)) {\n\t\tLOG_TEST_RET(card->ctx, SC_ERROR_INVALID_DATA, \"output too small for EC signature\");\n\t}\n\tmemset(out, 0, outlen);\n\n\t// Copied from card-piv.c. Thanks\n\tbody = sc_asn1_find_tag(card->ctx, data, datalen, 0x30, &bodylen);\n\n\tfor (i = 0; i<2; i++) {\n\t\tif (body) {\n\t\t\ttag = sc_asn1_find_tag(card->ctx, body,  bodylen, 0x02, &taglen);\n\t\t\tif (tag) {\n\t\t\t\tbodylen -= taglen - (tag - body);\n\t\t\t\tbody = tag + taglen;\n\n\t\t\t\tif (taglen > fieldsizebytes) { /* drop leading 00 if present */\n\t\t\t\t\tif (*tag != 0x00) {\n\t\t\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t\ttag++;\n\t\t\t\t\ttaglen--;\n\t\t\t\t}\n\t\t\t\tmemcpy(out + fieldsizebytes*i + fieldsizebytes - taglen , tag, taglen);\n\t\t\t} else {\n\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else  {\n\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tr = 2 * fieldsizebytes;\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n",
    "target": 1,
    "idx": 1050683,
    "stack_trace": [
      {
        "function_name": "sc_hsm_decode_ecdsa_signature",
        "function_body": "static int sc_hsm_decode_ecdsa_signature(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen) {\n\n\tint r;\n\tsize_t fieldsizebytes;\n\n\t// Determine field size from length of signature\n\tif (datalen <= 58) {\t\t\t// 192 bit curve = 24 * 2 + 10 byte maximum DER signature\n\t\tfieldsizebytes = 24;\n\t} else if (datalen <= 66) {\t\t// 224 bit curve = 28 * 2 + 10 byte maximum DER signature\n\t\tfieldsizebytes = 28;\n\t} else if (datalen <= 74) {\t\t// 256 bit curve = 32 * 2 + 10 byte maximum DER signature\n\t\tfieldsizebytes = 32;\n\t} else if (datalen <= 90) {\t\t// 320 bit curve = 40 * 2 + 10 byte maximum DER signature\n\t\tfieldsizebytes = 40;\n\t} else if (datalen <= 106) {\t\t// 384 bit curve = 48 * 2 + 10 byte maximum DER signature\n\t\tfieldsizebytes = 48;\n\t} else if (datalen <= 137) {\t\t// 512 bit curve = 64 * 2 + 9 byte maximum DER signature\n\t\tfieldsizebytes = 64;\n\t} else {\n\t\tfieldsizebytes = 66;\n\t}\n\n\tsc_log(card->ctx,\n\t       \"Field size %\"SC_FORMAT_LEN_SIZE_T\"u, signature buffer size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       fieldsizebytes, outlen);\n\n\tr = sc_asn1_decode_ecdsa_signature(card->ctx, data, datalen, fieldsizebytes, &out, outlen);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}",
        "file_path": "/src/opensc/src/libopensc/card-sc-hsm.c",
        "crashing_line": "",
        "crashing_line_number": 1086
      },
      {
        "function_name": "sc_hsm_compute_signature",
        "function_body": "static int sc_hsm_compute_signature(sc_card_t *card,\n\t\t\t\t     const u8 * data, size_t datalen,\n\t\t\t\t     u8 * out, size_t outlen)\n{\n\tint r;\n\tsc_apdu_t apdu;\n\tu8 rbuf[514];\n\tsc_hsm_private_data_t *priv;\n\n\tif (card == NULL || data == NULL || out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tpriv = (sc_hsm_private_data_t *) card->drv_data;\n\n\tif (priv->env == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OBJECT_NOT_FOUND);\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_EXT, 0x68, priv->env->key_ref[0], priv->algorithm);\n\tapdu.cla = 0x80;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 512;\n\n\tapdu.data = data;\n\tapdu.lc = datalen;\n\tapdu.datalen = datalen;\n\tr = sc_transmit_apdu(card, &apdu);\n\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\tint len;\n\n\t\tif ((priv->algorithm & 0xF0) == ALGO_EC_RAW) {\n\t\t\tlen = sc_hsm_decode_ecdsa_signature(card, apdu.resp, apdu.resplen, out, outlen);\n\t\t\tif (len < 0) {\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t\t\t}\n\t\t} else {\n\t\t\tlen = apdu.resplen > outlen ? outlen : apdu.resplen;\n\t\t\tmemcpy(out, apdu.resp, len);\n\t\t}\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}",
        "file_path": "/src/opensc/src/libopensc/card-sc-hsm.c",
        "crashing_line": "",
        "crashing_line_number": 1137
      },
      {
        "function_name": "sc_compute_signature",
        "function_body": "int sc_compute_signature(sc_card_t *card,\n\t\t\t const u8 * data, size_t datalen,\n\t\t\t u8 * out, size_t outlen)\n{\n\tint r;\n\n\tif (card == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (card->ops->compute_signature == NULL)\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_NOT_SUPPORTED);\n\tr = card->ops->compute_signature(card, data, datalen, out, outlen);\n        SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}",
        "file_path": "/src/opensc/src/libopensc/sec.c",
        "crashing_line": "\tr = card->ops->compute_signature(card, data, datalen, out, outlen);",
        "crashing_line_number": 65
      },
      {
        "function_name": "use_key",
        "function_body": "static int use_key(struct sc_pkcs15_card *p15card,\n\t\tconst struct sc_pkcs15_object *obj,\n\t\tsc_security_env_t *senv,\n\t\tint (*card_command)(sc_card_t *card,\n\t\t\t const u8 * in, size_t inlen,\n\t\t\t u8 * out, size_t outlen),\n\t\tconst u8 * in, size_t inlen, u8 * out, size_t outlen)\n{\n\tint r = SC_SUCCESS;\n\tint revalidated_cached_pin = 0;\n\tsc_path_t path;\n\tLOG_TEST_RET(p15card->card->ctx, get_file_path(obj, &path), \"Failed to get key file path.\");\n\n\tr = sc_lock(p15card->card);\n\tLOG_TEST_RET(p15card->card->ctx, r, \"sc_lock() failed\");\n\n\tdo {\n\t\tif (path.len != 0 || path.aid.len != 0) {\n\t\t\tr = select_key_file(p15card, obj, senv);\n\t\t\tif (r < 0) {\n\t\t\t\tsc_log(p15card->card->ctx,\n\t\t\t\t\t\t\"Unable to select private key file\");\n\t\t\t}\n\t\t}\n\t\tif (r == SC_SUCCESS)\n\t\t\tr = sc_set_security_env(p15card->card, senv, 0);\n\n\t\tif (r == SC_SUCCESS)\n\t\t\tr = card_command(p15card->card, in, inlen, out, outlen);\n\n\t\tif (revalidated_cached_pin)\n\t\t\t/* only re-validate once */\n\t\t\tbreak;\n\t\tif (r == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED) {\n\t\t\tr = sc_pkcs15_pincache_revalidate(p15card, obj);\n\t\t\tif (r < 0)\n\t\t\t\tbreak;\n\t\t\trevalidated_cached_pin = 1;\n\t\t}\n\t} while (revalidated_cached_pin);\n\n\tsc_unlock(p15card->card);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, r);\n}",
        "file_path": "/src/opensc/src/libopensc/pkcs15-sec.c",
        "crashing_line": "\t\t\tr = card_command(p15card->card, in, inlen, out, outlen);",
        "crashing_line_number": 154
      },
      {
        "function_name": "sc_pkcs15_compute_signature",
        "function_body": "int sc_pkcs15_compute_signature(struct sc_pkcs15_card *p15card,\n\t\t\t\tconst struct sc_pkcs15_object *obj,\n\t\t\t\tunsigned long flags, const u8 *in, size_t inlen,\n\t\t\t\tu8 *out, size_t outlen, void *pMechanism)\n{\n\tsc_context_t *ctx = p15card->card->ctx;\n\tint r;\n\tsc_security_env_t senv;\n\tsc_algorithm_info_t *alg_info;\n\tconst struct sc_pkcs15_prkey_info *prkey = (const struct sc_pkcs15_prkey_info *) obj->data;\n\tu8 *buf = NULL, *tmp;\n\tsize_t modlen = 0, buflen = 0;\n\tunsigned long pad_flags = 0, sec_flags = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (!(prkey->usage & (SC_PKCS15_PRKEY_USAGE_SIGN|SC_PKCS15_PRKEY_USAGE_SIGNRECOVER|\n\t\t\t\t\tSC_PKCS15_PRKEY_USAGE_NONREPUDIATION)))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_ALLOWED, \"This key cannot be used for signing\");\n\n\tr = format_senv(p15card, obj, &senv, &alg_info);\n\tLOG_TEST_RET(ctx, r, \"Could not initialize security environment\");\n\tsenv.operation = SC_SEC_OPERATION_SIGN;\n\n\tswitch (obj->type) {\n\t\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\t\t\tmodlen = (prkey->modulus_length + 7) / 8;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY_GOSTR3410:\n\t\t\tmodlen = (prkey->modulus_length + 7) / 8 * 2;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\tcase SC_PKCS15_TYPE_PRKEY_EDDSA:\n\t\tcase SC_PKCS15_TYPE_PRKEY_XEDDSA:\n\t\t\tmodlen = ((prkey->field_length +7) / 8) * 2;  /* 2*nLen */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Key type not supported\");\n\t}\n\n\t/* Probably never happens, but better make sure */\n\tif (outlen < modlen)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\n\tbuflen = inlen + modlen;\n\tbuf = sc_mem_secure_alloc(buflen);\n\tif (buf == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\tmemcpy(buf, in, inlen);\n\n\t/* revert data to sign when signing with the GOST key.\n\t * TODO: can it be confirmed by the GOST standard?\n\t * TODO: tested with RuTokenECP, has to be validated for RuToken. */\n\tif (obj->type == SC_PKCS15_TYPE_PRKEY_GOSTR3410) {\n\t\tr = sc_mem_reverse(buf, inlen);\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Reverse memory error\");\n\t}\n\n\ttmp = buf;\n\n\t/* flags: the requested algo\n\t * algo_info->flags: what is supported by the card\n\t * senv.algorithm_flags: what the card will have to do */\n\n\t/* if the card has SC_ALGORITHM_NEED_USAGE set, and the\n\t * key is for signing and decryption, we need to emulate signing */\n\n\tsc_log(ctx, \"supported algorithm flags 0x%X, private key usage 0x%X\", alg_info->flags, prkey->usage);\n\tif (obj->type == SC_PKCS15_TYPE_PRKEY_RSA) {\n\t\tif ((alg_info->flags & SC_ALGORITHM_NEED_USAGE) &&\n\t\t\t((prkey->usage & USAGE_ANY_SIGN) &&\n\t\t\t(prkey->usage & USAGE_ANY_DECIPHER)) ) {\n\t\t\tsize_t tmplen = buflen;\n\t\t\tif (flags & SC_ALGORITHM_RSA_RAW) {\n\t\t\t\tr = sc_pkcs15_decipher(p15card, obj, flags, in, inlen, out, outlen, NULL);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (modlen > tmplen)\n\t\t\t\tLOG_TEST_GOTO_ERR(ctx, SC_ERROR_NOT_ALLOWED, \"Buffer too small, needs recompile!\");\n\n\t\t\t/* XXX Assuming RSA key here */\n\t\t\tr = sc_pkcs1_encode(ctx, flags, in, inlen, buf, &tmplen, prkey->modulus_length, pMechanism);\n\n\t\t\t/* no padding needed - already done */\n\t\t\tflags &= ~SC_ALGORITHM_RSA_PADS;\n\t\t\t/* instead use raw rsa */\n\t\t\tflags |= SC_ALGORITHM_RSA_RAW;\n\n\t\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Unable to add padding\");\n\n\t\t\tr = sc_pkcs15_decipher(p15card, obj, flags, buf, modlen, out, outlen, NULL);\n\t\t\tgoto err;\n\t\t}\n\n\n\t\t/* If the card doesn't support the requested algorithm, we normally add the\n\t\t * padding here in software and ask the card to do a raw signature.  There's\n\t\t * one exception to that, where we might be able to get the signature to\n\t\t * succeed by stripping padding if the card only offers higher-level\n\t\t * signature operations.  The only thing we can strip is the DigestInfo\n\t\t * block from PKCS1 padding. */\n\t\tif ((flags == (SC_ALGORITHM_RSA_PAD_PKCS1 | SC_ALGORITHM_RSA_HASH_NONE)) &&\n\t\t    !(alg_info->flags & SC_ALGORITHM_RSA_RAW) &&\n\t\t    !(alg_info->flags & SC_ALGORITHM_RSA_HASH_NONE) &&\n\t\t    (alg_info->flags & SC_ALGORITHM_RSA_PAD_PKCS1)) {\n\t\t\tunsigned int algo;\n\t\t\tsize_t tmplen = buflen;\n\n\t\t\tr = sc_pkcs1_strip_digest_info_prefix(&algo, tmp, inlen, tmp, &tmplen);\n\t\t\tif (r != SC_SUCCESS || algo == SC_ALGORITHM_RSA_HASH_NONE) {\n\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tflags &= ~SC_ALGORITHM_RSA_HASH_NONE;\n\t\t\tflags |= algo;\n\t\t\tinlen = tmplen;\n\t\t}\n\t}\n\n\n\t/* ECDSA software hash has already been done, or is not needed, or card will do hash */\n\t/* if card can not do the hash, will use SC_ALGORITHM_ECDSA_RAW */\n\tif (obj->type == SC_PKCS15_TYPE_PRKEY_EC) {\n\t\tif ((alg_info->flags & SC_ALGORITHM_ECDSA_RAW)\n\t\t\t\t&& !(flags & SC_ALGORITHM_ECDSA_HASHES & alg_info->flags)) {\n\t\t\tsc_log(ctx, \"ECDSA using SC_ALGORITHM_ECDSA_RAW flags before 0x%8.8lx\", flags);\n\t\t\t\tflags |= SC_ALGORITHM_ECDSA_RAW;\n\t\t\t\tflags &= ~SC_ALGORITHM_ECDSA_HASHES;\n\t\t}\n\t}\n\n\tr = sc_get_encoding_flags(ctx, flags, alg_info->flags, &pad_flags, &sec_flags);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\t/* senv now has flags card or driver will do */\n\tsenv.algorithm_flags = sec_flags;\n\n\tsc_log(ctx, \"DEE flags:0x%8.8lx alg_info->flags:0x%8.8x pad:0x%8.8lx sec:0x%8.8lx\",\n\t\tflags, alg_info->flags, pad_flags, sec_flags);\n\n\t/* add the padding bytes (if necessary) */\n\tif (pad_flags != 0) {\n\t\tsize_t tmplen = buflen;\n\n\t\t/* XXX Assuming RSA key here */\n\t\tr = sc_pkcs1_encode(ctx, pad_flags, tmp, inlen, tmp, &tmplen,\n\t\t    prkey->modulus_length, pMechanism);\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Unable to add padding\");\n\t\tinlen = tmplen;\n\t}\n\telse if ( senv.algorithm == SC_ALGORITHM_RSA &&\n\t          (flags & SC_ALGORITHM_RSA_PADS) == SC_ALGORITHM_RSA_PAD_NONE) {\n\t\t/* Add zero-padding if input is shorter than the modulus */\n\t\tif (inlen < modlen) {\n\t\t\tif (modlen > buflen) {\n\t\t\t\tr = SC_ERROR_BUFFER_TOO_SMALL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tmemmove(tmp+modlen-inlen, tmp, inlen);\n\t\t\tmemset(tmp, 0, modlen-inlen);\n\t\t}\n\t\tinlen = modlen;\n\t}\n\t/* PKCS#11 MECHANISMS V2.30: 6.3.1 EC Signatures\n\t * If the length of the hash value is larger than the bit length of n, only\n\t * the leftmost bits of the hash up to the length of n will be used. Any\n\t * truncation is done by the token.\n\t * But if card is going to do the hash, pass in all the data\n\t */\n\telse if (senv.algorithm == SC_ALGORITHM_EC &&\n\t\t\t(senv.algorithm_flags & SC_ALGORITHM_ECDSA_HASHES) == 0) {\n\t\tinlen = MIN(inlen, (prkey->field_length+7)/8);\n\t}\n\n\n\tr = use_key(p15card, obj, &senv, sc_compute_signature, tmp, inlen,\n\t\t\tout, outlen);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"use_key() failed\");\n\n\t/* Some cards may return RSA signature as integer without leading zero bytes */\n\t/* Already know outlen >= modlen and r >= 0 */\n\tif (obj->type == SC_PKCS15_TYPE_PRKEY_RSA && (unsigned)r < modlen) {\n\t\tmemmove(out + modlen - r, out, r);\n\t\tmemset(out, 0, modlen - r);\n\t\tr = modlen;\n\t}\n\nerr:\n\tsc_mem_secure_clear_free(buf, buflen);\n\n\tLOG_FUNC_RETURN(ctx, r);\n}",
        "file_path": "/src/opensc/src/libopensc/pkcs15-sec.c",
        "crashing_line": "\tr = use_key(p15card, obj, &senv, sc_compute_signature, tmp, inlen,",
        "crashing_line_number": 769
      },
      {
        "function_name": "sign",
        "function_body": "static int sign(struct sc_pkcs15_object *obj)\n{\n\tu8 buf[1024], out[1024];\n\tstruct sc_pkcs15_prkey_info *key = (struct sc_pkcs15_prkey_info *) obj->data;\n\tint r, c, len;\n\n\tif (opt_input == NULL) {\n\t\tfprintf(stderr, \"No input file specified. Reading from stdin\\n\");\n\t}\n\n\tc = read_input(buf, sizeof(buf));\n\tif (c < 0)\n\t\treturn 2;\n\tlen = sizeof(out);\n\tif (obj->type == SC_PKCS15_TYPE_PRKEY_RSA\n\t\t\t&& !(opt_crypt_flags & SC_ALGORITHM_RSA_PAD_PKCS1)\n\t\t\t&& (size_t)c != key->modulus_length/8) {\n\t\tfprintf(stderr, \"Input has to be exactly %lu bytes, when using no padding.\\n\",\n\t\t\t(unsigned long) key->modulus_length/8);\n\t\treturn 2;\n\t}\n\tif (!key->native) {\n\t\tfprintf(stderr, \"Deprecated non-native key detected! Upgrade your smart cards.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tr = sc_pkcs15_compute_signature(p15card, obj, opt_crypt_flags, buf, c, out, len, NULL);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Compute signature failed: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\tlen = r;\n\n\tif (obj->type == SC_PKCS15_TYPE_PRKEY_EC)   {\n\t\tif (opt_sig_format &&  (!strcmp(opt_sig_format, \"openssl\") || !strcmp(opt_sig_format, \"sequence\")))   {\n\t\t\tunsigned char *seq;\n\t\t\tsize_t seqlen;\n\n\t\t\tif (sc_asn1_sig_value_rs_to_sequence(ctx, out, len, &seq, &seqlen))   {\n\t\t\t\tfprintf(stderr, \"Failed to convert signature to ASN1 sequence format.\\n\");\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tmemcpy(out, seq, seqlen);\n\t\t\tlen = seqlen;\n\n\t\t\tfree(seq);\n\t\t}\n\t}\n\n\tr = write_output(out, len);\n\n\treturn r;\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/tools/pkcs15-crypt.c",
        "crashing_line": "\tr = sc_pkcs15_compute_signature(p15card, obj, opt_crypt_flags, buf, c, out, len, NULL);",
        "crashing_line_number": 240
      },
      {
        "function_name": "_main",
        "function_body": "int main(int argc, char *argv[])\n{\n\tint err = 0, r, c, long_optind = 0;\n\tint do_decipher = 0;\n\tint do_sign = 0;\n\tint do_print_version = 0;\n\tint action_count = 0;\n\tstruct sc_pkcs15_object *key;\n\tsc_context_param_t ctx_param;\n\n\twhile (1) {\n\t\tc = getopt_long(argc, argv, \"sck:r:i:o:f:Rp:vw\", options, &long_optind);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tif (c == '?') {\n\t\t\tutil_print_usage(app_name, options, option_help, NULL);\n\t\t\treturn 2;\n\t\t}\n\t\tswitch (c) {\n\t\tcase OPT_VERSION:\n\t\t\tdo_print_version = 1;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tdo_sign++;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tdo_decipher++;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\topt_key_id = optarg;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\topt_reader = optarg;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\topt_input = optarg;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\topt_output = optarg;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\topt_sig_format = optarg;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\topt_raw = 1;\n\t\t\tbreak;\n\t\tcase OPT_SHA1:\n\t\t\topt_crypt_flags |= SC_ALGORITHM_RSA_HASH_SHA1;\n\t\t\tbreak;\n\t\tcase OPT_SHA256:\n\t\t\topt_crypt_flags |= SC_ALGORITHM_RSA_HASH_SHA256;\n\t\t\tbreak;\n\t\tcase OPT_SHA384:\n\t\t\topt_crypt_flags |= SC_ALGORITHM_RSA_HASH_SHA384;\n\t\t\tbreak;\n\t\tcase OPT_SHA512:\n\t\t\topt_crypt_flags |= SC_ALGORITHM_RSA_HASH_SHA512;\n\t\t\tbreak;\n\t\tcase OPT_SHA224:\n\t\t\topt_crypt_flags |= SC_ALGORITHM_RSA_HASH_SHA224;\n\t\t\tbreak;\n\t\tcase OPT_MD5:\n\t\t\topt_crypt_flags |= SC_ALGORITHM_RSA_HASH_MD5;\n\t\t\tbreak;\n\t\tcase OPT_PKCS1:\n\t\t\topt_crypt_flags |= SC_ALGORITHM_RSA_PAD_PKCS1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\topt_pincode = optarg;\n\t\t\tbreak;\n\t\tcase OPT_BIND_TO_AID:\n\t\t\topt_bind_to_aid = optarg;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\topt_wait = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (action_count == 0) {\n\t\tutil_print_usage(app_name, options, option_help, NULL);\n\t\treturn 2;\n\t}\n\n\tif (do_print_version)   {\n\t\tprintf(\"%s\\n\", OPENSC_SCM_REVISION);\n\t\taction_count--;\n\t}\n\n\tif (!(opt_crypt_flags & SC_ALGORITHM_RSA_HASHES))\n\t\topt_crypt_flags |= SC_ALGORITHM_RSA_HASH_NONE;\n\n\tmemset(&ctx_param, 0, sizeof(ctx_param));\n\tctx_param.ver      = 0;\n\tctx_param.app_name = app_name;\n\n\tr = sc_context_create(&ctx, &ctx_param);\n\tif (r) {\n\t\tfprintf(stderr, \"Failed to establish context: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\n\terr = util_connect_card_ex(ctx, &card, opt_reader, opt_wait, 0, verbose);\n\tif (err)\n\t\tgoto end;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Trying to find a PKCS #15 compatible card...\\n\");\n\tif (opt_bind_to_aid)   {\n\t\tstruct sc_aid aid;\n\n\t\taid.len = sizeof(aid.value);\n\t\tif (sc_hex_to_bin(opt_bind_to_aid, aid.value, &aid.len))   {\n\t\t\tfprintf(stderr, \"Invalid AID value: '%s'\\n\", opt_bind_to_aid);\n\t\t\terr = 1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tr = sc_pkcs15_bind(card, &aid, &p15card);\n\t}\n\telse   {\n\t\tr = sc_pkcs15_bind(card, NULL, &p15card);\n\t}\n\tif (r) {\n\t\tfprintf(stderr, \"PKCS #15 binding failed: %s\\n\", sc_strerror(r));\n\t\terr = 1;\n\t\tgoto end;\n\t}\n\tif (verbose)\n\t\tfprintf(stderr, \"Found %s!\\n\", p15card->tokeninfo->label);\n\n\tif (do_decipher) {\n\t\tif ((err = get_key(SC_PKCS15_PRKEY_USAGE_DECRYPT|SC_PKCS15_PRKEY_USAGE_UNWRAP, &key))\n\t\t || (err = decipher(key)))\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\n\tif (do_sign) {\n\t\tif ((err = get_key(SC_PKCS15_PRKEY_USAGE_SIGN|\n\t\t\t\t   SC_PKCS15_PRKEY_USAGE_SIGNRECOVER|\n\t\t\t\t   SC_PKCS15_PRKEY_USAGE_NONREPUDIATION, &key))\n\t\t || (err = sign(key)))\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\nend:\n\tif (p15card)\n\t\tsc_pkcs15_unbind(p15card);\n\tif (card) {\n\t\tsc_disconnect_card(card);\n\t}\n\tif (ctx)\n\t\tsc_release_context(ctx);\n\treturn err;\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/tools/pkcs15-crypt.c",
        "crashing_line": "\t\t || (err = sign(key)))",
        "crashing_line_number": 526
      },
      {
        "function_name": "test_operation",
        "function_body": "void test_operation(char *op, char *pin, const uint8_t *data, size_t size, char *filename,\n\t\t\t\t\tchar *hash, char *format, char *aid, char *id, uint8_t pad)\n{\n\tchar *argv[] = {\"./fuzz_pkcs15_crypt\", op, \"-p\", pin, \"-i\", filename,\n\t\t\t\t\thash, \"-f\", format, NULL, NULL, NULL, NULL, NULL, NULL};\n\tint argc = 9;\n\n\tif (aid) {\n\t\targv[argc++] = \"--aid\";\n\t\targv[argc++] = aid;\n\t}\n\tif (id) {\n\t\targv[argc++] = \"-k\";\n\t\targv[argc++] = id;\n\t}\n\tif (pad)\n\t\targv[argc++] = \"--pkcs1\";\n\n\treader_data = data;\n\treader_data_size = size;\n\t_main(argc, argv);\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/fuzz_pkcs15_crypt.c",
        "crashing_line": "\t_main(argc, argv);",
        "crashing_line_number": 91
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "ATTRIBUTE_MALLOC\nBITCODE_TU\nbit_utf8_to_TU (char *restrict str, const unsigned cquoted)\n{\n  BITCODE_TU wstr;\n  size_t i = 0;\n  size_t len = strlen (str);\n  unsigned char c;\n\n  if (len > 0xFFFE)\n    {\n      loglevel = 1;\n      LOG_WARN (\"Overlong string truncated (len=%lu)\",\n                (unsigned long)len);\n      len = UINT16_MAX - 1;\n    }\n  wstr = (BITCODE_TU)calloc (2, len + 1);\n  if (!wstr)\n    {\n      loglevel = 1;\n      LOG_ERROR (\"Out of memory\")\n      return NULL;\n    }\n  while (len > 0 && (c = *str++))\n    {\n      len--;\n      if (c < 128)\n        {\n          if (cquoted && c == '\\\\' && len > 1 &&\n              // skip \\\" to \" and \\\\ to \\.\n              (*str == '\"' || *str == '\\\\' || *str == 'r'\n               || *str == 'n'))\n            {\n              c = *str++;\n              if (c == 'r')\n                wstr[i++] = '\\r';\n              else if (c == 'n')\n                wstr[i++] = '\\n';\n              // else skip \\ and \" from \\\\ and \\\"\n              else\n                wstr[i++] = c;\n            }\n          else\n            wstr[i++] = c;\n        }\n      else if ((c & 0xe0) == 0xc0)\n        {\n          /* ignore invalid utf8 for now */\n          if (len >= 1)\n            wstr[i++] = ((c & 0x1f) << 6) | (str[1] & 0x3f);\n          len--;\n          str++;\n        }\n      else if ((c & 0xf0) == 0xe0)\n        {\n          /* ignore invalid utf8? */\n          if (len >= 2\n              && ((unsigned char)str[1] < 0x80 || (unsigned char)str[1] > 0xBF\n                  || (unsigned char)str[2] < 0x80\n                  || (unsigned char)str[2] > 0xBF))\n            {\n              LOG_WARN (\"utf-8: BAD_CONTINUATION_BYTE %s\", str);\n            }\n          if (len >= 1 && c == 0xe0 && (unsigned char)str[1] < 0xa0)\n            {\n              LOG_WARN (\"utf-8: NON_SHORTEST %s\", str);\n            }\n          if (len >= 2)\n            wstr[i++] = ((c & 0x0f) << 12) | ((str[1] & 0x3f) << 6)\n                        | (str[2] & 0x3f);\n          str++;\n          str++;\n          len--;\n          len--;\n        }\n      /* everything above 0xf0 exceeds ucs-2, 4-6 byte seqs */\n    }\n  return wstr;\n}\n",
    "target": 1,
    "idx": 1057587,
    "stack_trace": [
      {
        "function_name": "bit_utf8_to_TU",
        "function_body": "ATTRIBUTE_MALLOC\nBITCODE_TU\nbit_utf8_to_TU (char *restrict str, const unsigned cquoted)\n{\n  BITCODE_TU wstr;\n  size_t i = 0;\n  size_t len = strlen (str);\n  unsigned char c;\n\n  if (len > 0xFFFE)\n    {\n      loglevel = 1;\n      LOG_WARN (\"Overlong string truncated (len=%lu)\",\n                (unsigned long)len);\n      len = UINT16_MAX - 1;\n    }\n  wstr = (BITCODE_TU)calloc (2, len + 1);\n  if (!wstr)\n    {\n      loglevel = 1;\n      LOG_ERROR (\"Out of memory\")\n      return NULL;\n    }\n  while (len > 0 && (c = *str++))\n    {\n      len--;\n      if (c < 128)\n        {\n          if (cquoted && c == '\\\\' && len > 1 &&\n              // skip \\\" to \" and \\\\ to \\.\n              (*str == '\"' || *str == '\\\\' || *str == 'r'\n               || *str == 'n'))\n            {\n              c = *str++;\n              if (c == 'r')\n                wstr[i++] = '\\r';\n              else if (c == 'n')\n                wstr[i++] = '\\n';\n              // else skip \\ and \" from \\\\ and \\\"\n              else\n                wstr[i++] = c;\n            }\n          else\n            wstr[i++] = c;\n        }\n      else if ((c & 0xe0) == 0xc0)\n        {\n          /* ignore invalid utf8 for now */\n          if (len >= 1)\n            {\n              wstr[i++] = ((c & 0x1f) << 6) | (str[1] & 0x3f);\n              len--;\n              str++;\n            }\n        }\n      else if ((c & 0xf0) == 0xe0)\n        {\n          /* ignore invalid utf8? */\n          if (len >= 2\n              && ((unsigned char)str[1] < 0x80 || (unsigned char)str[1] > 0xBF\n                  || (unsigned char)str[2] < 0x80\n                  || (unsigned char)str[2] > 0xBF))\n            {\n              LOG_WARN (\"utf-8: BAD_CONTINUATION_BYTE %s\", str);\n            }\n          else if (len >= 1 && c == 0xe0 && (unsigned char)str[1] < 0xa0)\n            {\n              LOG_WARN (\"utf-8: NON_SHORTEST %s\", str);\n            }\n          else if (len >= 2)\n            {\n              wstr[i++] = ((c & 0x0f) << 12) | ((str[1] & 0x3f) << 6)\n                | (str[2] & 0x3f);\n              str++;\n              str++;\n              len--;\n              len--;\n            }\n        }\n      /* everything above 0xf0 exceeds ucs-2, 4-6 byte seqs */\n    }\n  return wstr;\n}",
        "file_path": "/src/libredwg/src/bits.c",
        "crashing_line": "            wstr[i++] = c;",
        "crashing_line_number": 2883
      },
      {
        "function_name": "json_wstring",
        "function_body": "ATTRIBUTE_MALLOC\nstatic BITCODE_TU\njson_wstring (Bit_Chain *restrict dat, jsmntokens_t *restrict tokens)\n{\n  const jsmntok_t *t = &tokens->tokens[tokens->index];\n  if (t->type != JSMN_STRING)\n    {\n      LOG_ERROR (\"Expected JSON STRING\");\n      json_advance_unknown (dat, tokens, t->type, 0);\n      return NULL;\n    }\n  tokens->index++;\n  JSON_TOKENS_CHECK_OVERFLOW_NULL\n  dat->chain[t->end] = '\\0';\n  return bit_utf8_to_TU ((char *)&dat->chain[t->start], 0);\n}",
        "file_path": "/src/libredwg/src/in_json.c",
        "crashing_line": "  return bit_utf8_to_TU ((char *)&dat->chain[t->start], 0);",
        "crashing_line_number": 421
      },
      {
        "function_name": "json_AppInfo",
        "function_body": "static int\njson_AppInfo (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n              jsmntokens_t *restrict tokens)\n{\n  const char *section = \"AppInfo\";\n  const jsmntok_t *t = &tokens->tokens[tokens->index];\n  Dwg_AppInfo *_obj = &dwg->appinfo;\n  int size;\n  if (t->type != JSMN_OBJECT)\n    {\n      LOG_ERROR (\"Unexpected %s at %u of %ld tokens, expected %s OBJECT\",\n                 t_typename[t->type], tokens->index, tokens->num_tokens,\n                 section);\n      json_advance_unknown (dat, tokens, t->type, 0);\n      return DWG_ERR_INVALIDTYPE;\n    }\n  size = t->size;\n  LOG_TRACE (\"\\n%s pos:%d [%d keys]\\n--------------------\\n\", section,\n             tokens->index, size);\n  tokens->index++;\n  for (int i = 0; i < size; i++)\n    {\n      char key[80];\n      JSON_TOKENS_CHECK_OVERFLOW_ERR\n      json_fixed_key (key, dat, tokens);\n      // LOG_TRACE (\"%s\\n\", key)\n      t = &tokens->tokens[tokens->index];\n\n      // clang-format off\n      if (0) ;\n      FIELD_RL (class_version, 0)\n      FIELD_TU16 (appinfo_name, 0)\n      FIELD_RL (num_strings, 0)\n      FIELD_TFFx (version_checksum, 16, 0)\n      FIELD_TU16 (version, 0)\n      FIELD_TFFx (comment_checksum, 16, 0)\n      FIELD_TU16 (comment, 0)\n      FIELD_TFFx (product_checksum, 16, 0)\n      FIELD_TU16 (product_info, 0)\n      else\n        {\n          LOG_ERROR (\"Unknown %s.%s ignored\", section, key);\n          json_advance_unknown (dat, tokens, t->type, 0);\n        }\n      // clang-format on\n    }\n\n  LOG_TRACE (\"End of %s\\n\", section)\n  tokens->index--;\n  return 0;\n}",
        "file_path": "/src/libredwg/src/in_json.c",
        "crashing_line": "      FIELD_TU16 (version, 0)",
        "crashing_line_number": 3688
      },
      {
        "function_name": "dwg_read_json",
        "function_body": "EXPORT int\ndwg_read_json (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Header *obj = &dwg->header;\n  jsmn_parser parser;\n  jsmntokens_t tokens;\n  unsigned int i;\n  int error = -1;\n  created_by = NULL;\n\n  dwg->opts |= (loglevel | DWG_OPTS_INJSON);\n  dat->opts |= (loglevel | DWG_OPTS_INJSON);\n  loglevel = dwg->opts & 0xf;\n  if (dat->fh && (!dat->chain || !*dat->chain))\n    {\n      error = dat_read_stream (dat, dat->fh);\n      if (error >= DWG_ERR_CRITICAL)\n        return error;\n      LOG_TRACE (\"  json file size: %lu\\n\", dat->size);\n    }\n  g_dat = dat;\n\n  jsmn_init (&parser);\n  // How big will it be? This is the max. memory variant.\n  // we could also use less, see jsmn/examples/jsondump.c for small devices.\n  tokens.num_tokens\n      = jsmn_parse (&parser, (char *)dat->chain, dat->size, NULL, 0);\n  if (tokens.num_tokens <= 0)\n    {\n      const int remaining = dat->size - parser.pos;\n      if (parser.pos > 10 && remaining > 10)\n        {\n          char err[21];\n          memcpy (&err, &dat->chain[parser.pos - 10], 20);\n          err[20] = 0;\n          LOG_ERROR (\"Invalid json. jsmn error at pos: %u (... %s ...)\",\n                     parser.pos, err);\n        }\n      else\n        {\n          LOG_ERROR (\"Invalid json. jsmn error at pos: %u (%.*s ...)\",\n                     parser.pos, remaining, &dat->chain[parser.pos]);\n        }\n      return DWG_ERR_INVALIDDWG;\n    }\n  LOG_TRACE (\"  num_tokens: %ld\\n\", tokens.num_tokens);\n  tokens.tokens\n      = (jsmntok_t *)calloc (tokens.num_tokens + 1024, sizeof (jsmntok_t));\n  if (!tokens.tokens)\n    return DWG_ERR_OUTOFMEM;\n\n  dwg->object_map = hash_new (tokens.num_tokens / 50);\n  if (!dwg->object_map) // we are obviously on a tiny system\n    {\n      dwg->object_map = hash_new (1024);\n      if (!dwg->object_map)\n        {\n          LOG_ERROR (\"Out of memory\");\n          json_free_globals (&tokens);\n          return DWG_ERR_OUTOFMEM;\n        }\n    }\n  dwg->dirty_refs = 1;\n  // set the target version earlier (than e.g. in DXF)\n  // we cannot write DWG >= R_2004 yet. avoid widestrings for now\n  /* if (!dwg->header.version)\n    dwg->header.version = dat->version = R_2000;\n  */\n  dat->version = R_2000;\n\n  jsmn_init (&parser); // reset pos to 0\n  error = jsmn_parse (&parser, (char *)dat->chain, dat->size, tokens.tokens,\n                      (unsigned int)tokens.num_tokens);\n  if (error < 0)\n    {\n      const int remaining = dat->size - parser.pos;\n      if (parser.pos > 10 && remaining > 10)\n        {\n          char err[21];\n          memcpy (&err, &dat->chain[parser.pos - 10], 20);\n          err[20] = 0;\n          LOG_ERROR (\"Invalid json. jsmn error %d at the %u-th token, pos: %u \"\n                     \"(... %s ...)\",\n                     error, parser.toknext, parser.pos, err);\n        }\n      else\n        {\n          LOG_ERROR (\"Invalid json. jsmn error %d at the %u-th token, pos: %u \"\n                     \"(%.*s ...)\",\n                     error, parser.toknext, parser.pos, remaining,\n                     &dat->chain[parser.pos]);\n        }\n      json_free_globals (&tokens);\n      return DWG_ERR_INVALIDDWG;\n    }\n\n  if (tokens.tokens[0].type != JSMN_OBJECT)\n    {\n      fprintf (stderr, \"First JSON element is not an object/hash\\n\");\n      json_free_globals (&tokens);\n      return DWG_ERR_INVALIDDWG;\n    }\n\n  // valid first level tokens:\n  // created_by: string\n  // section objects: FILEHEADER, HEADER, THUMBNAILIMAGE, R2004_Header,\n  //                  SummaryInfo, AppInfo,\n  //                  AppInfoHistory, FileDepList, Security, RevHistory,\n  //                  ObjFreeSpace, Template\n  // section arrays: CLASSES, OBJECTS, HANDLES\n  error = 0;\n  for (tokens.index = 1; tokens.index < (unsigned int)tokens.num_tokens;\n       tokens.index++)\n    {\n      char key[80];\n      const jsmntok_t *t = &tokens.tokens[tokens.index];\n      const int len = t->end - t->start;\n\n      if (t->type == JSMN_UNDEFINED)\n        break;\n      if (t->type != JSMN_STRING)\n        {\n          LOG_ERROR (\"Unexpected JSON key at %u of %ld tokens, got %s\",\n                     tokens.index, tokens.num_tokens, t_typename[t->type]);\n          json_free_globals (&tokens);\n          return DWG_ERR_INVALIDDWG;\n        }\n      if (len >= 80)\n        {\n          LOG_ERROR (\"Unknown JSON key at %u of %ld tokens, len %d > 80\",\n                     tokens.index, tokens.num_tokens, len);\n          json_free_globals (&tokens);\n          return DWG_ERR_INVALIDDWG;\n        }\n      memcpy (key, &dat->chain[t->start], len);\n      key[len] = '\\0';\n      tokens.index++;\n      if (tokens.index >= (unsigned int)tokens.num_tokens)\n        {\n          LOG_ERROR (\"Unexpected end of JSON at %u of %ld tokens %s:%d\",\n                     tokens.index, tokens.num_tokens, __FILE__, __LINE__);\n          json_free_globals (&tokens);\n          return DWG_ERR_INVALIDDWG;\n        }\n      if (strEQc (key, \"created_by\"))\n        error |= json_created_by (dat, dwg, &tokens);\n      else if (strEQc (key, \"FILEHEADER\"))\n        error |= json_FILEHEADER (dat, dwg, &tokens);\n      else if (strEQc (key, \"HEADER\"))\n        error |= json_HEADER (dat, dwg, &tokens);\n      else if (strEQc (key, \"CLASSES\"))\n        error |= json_CLASSES (dat, dwg, &tokens);\n      else if (strEQc (key, \"OBJECTS\"))\n        error |= json_OBJECTS (dat, dwg, &tokens);\n      else if (strEQc (key, \"THUMBNAILIMAGE\"))\n        error |= json_THUMBNAILIMAGE (dat, dwg, &tokens);\n      else if (strEQc (key, \"AuxHeader\"))\n        error |= json_AuxHeader (dat, dwg, &tokens);\n      else if (strEQc (key, \"R2004_Header\"))\n        error |= json_R2004_Header (dat, dwg, &tokens);\n      else if (strEQc (key, \"SummaryInfo\"))\n        error |= json_SummaryInfo (dat, dwg, &tokens);\n      else if (strEQc (key, \"VBAProject\"))\n        error |= json_VBAProject (dat, dwg, &tokens);\n      else if (strEQc (key, \"AppInfo\"))\n        error |= json_AppInfo (dat, dwg, &tokens);\n      else if (strEQc (key, \"AppInfoHistory\"))\n        error |= json_AppInfoHistory (dat, dwg, &tokens);\n      else if (strEQc (key, \"FileDepList\"))\n        error |= json_FileDepList (dat, dwg, &tokens);\n      else if (strEQc (key, \"Security\"))\n        error |= json_Security (dat, dwg, &tokens);\n      else if (strEQc (key, \"RevHistory\"))\n        error |= json_RevHistory (dat, dwg, &tokens);\n      else if (strEQc (key, \"ObjFreeSpace\"))\n        error |= json_ObjFreeSpace (dat, dwg, &tokens);\n      else if (strEQc (key, \"AcDs\"))\n        error |= json_AcDs (dat, dwg, &tokens);\n      else if (strEQc (key, \"Template\"))\n        error |= json_Template (dat, dwg, &tokens);\n      /* Only in json early versions <0.11 */\n      else if (strEQc (key, \"HANDLES\"))\n        error |= json_HANDLES (dat, dwg, &tokens);\n      else\n        {\n          LOG_ERROR (\"Unexpected JSON key %s at %u of %ld tokens. %s:%d\", key,\n                     tokens.index, tokens.num_tokens, __FUNCTION__, __LINE__);\n          LOG_TRACE (\"\\n\")\n          json_free_globals (&tokens);\n          return error | DWG_ERR_INVALIDTYPE;\n        }\n      if (error >= DWG_ERR_CRITICAL)\n        {\n          LOG_TRACE (\"\\n\")\n          json_free_globals (&tokens);\n          return error;\n        }\n    }\n\n  LOG_TRACE (\"\\n\")\n  if (dat->version <= R_2000 && dwg->header.from_version > R_2000)\n    dwg_fixup_BLOCKS_entities (dwg);\n\n  json_free_globals (&tokens);\n  created_by = NULL;\n  return error;\n}",
        "file_path": "/src/libredwg/src/in_json.c",
        "crashing_line": "        error |= json_AppInfo (dat, dwg, &tokens);",
        "crashing_line_number": 4541
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void Interpreter::ProcessService(int argc, char *argv[])\n{\n    otError error = OT_ERROR_NONE;\n\n    VerifyOrExit(argc > 0, error = OT_ERROR_INVALID_ARGS);\n\n    if (strcmp(argv[0], \"add\") == 0)\n    {\n        otServiceConfig cfg;\n        long            enterpriseNumber = 0;\n\n        VerifyOrExit(argc > 3, error = OT_ERROR_INVALID_ARGS);\n\n        SuccessOrExit(error = ParseLong(argv[1], enterpriseNumber));\n\n        cfg.mServiceDataLength = static_cast<uint8_t>(strlen(argv[2]));\n        memcpy(cfg.mServiceData, argv[2], cfg.mServiceDataLength);\n        cfg.mEnterpriseNumber               = static_cast<uint32_t>(enterpriseNumber);\n        cfg.mServerConfig.mStable           = true;\n        cfg.mServerConfig.mServerDataLength = static_cast<uint8_t>(strlen(argv[3]));\n        memcpy(cfg.mServerConfig.mServerData, argv[3], cfg.mServerConfig.mServerDataLength);\n\n        SuccessOrExit(error = otServerAddService(mInstance, &cfg));\n    }\n    else if (strcmp(argv[0], \"remove\") == 0)\n    {\n        long enterpriseNumber = 0;\n\n        VerifyOrExit(argc > 2, error = OT_ERROR_INVALID_ARGS);\n\n        SuccessOrExit(error = ParseLong(argv[1], enterpriseNumber));\n\n        SuccessOrExit(error = otServerRemoveService(mInstance, static_cast<uint32_t>(enterpriseNumber),\n                                                    reinterpret_cast<uint8_t *>(argv[2]),\n                                                    static_cast<uint8_t>(strlen(argv[2]))));\n    }\n    else\n    {\n        ExitNow(error = OT_ERROR_INVALID_ARGS);\n    }\n\nexit:\n    AppendResult(error);\n}\n",
    "target": 1,
    "idx": 1012642,
    "stack_trace": [
      {
        "function_name": "ProcessService",
        "function_body": "void Interpreter::ProcessService(int argc, char *argv[])\n{\n    otError error = OT_ERROR_NONE;\n\n    VerifyOrExit(argc > 0, error = OT_ERROR_INVALID_ARGS);\n\n    if (strcmp(argv[0], \"add\") == 0)\n    {\n        otServiceConfig cfg;\n        long            enterpriseNumber;\n        size_t          length;\n\n        VerifyOrExit(argc > 3, error = OT_ERROR_INVALID_ARGS);\n\n        SuccessOrExit(error = ParseLong(argv[1], enterpriseNumber));\n        cfg.mEnterpriseNumber = static_cast<uint32_t>(enterpriseNumber);\n\n        length = strlen(argv[2]);\n        VerifyOrExit(length <= sizeof(cfg.mServiceData), error = OT_ERROR_NO_BUFS);\n        cfg.mServiceDataLength = static_cast<uint8_t>(length);\n        memcpy(cfg.mServiceData, argv[2], cfg.mServiceDataLength);\n\n        length = strlen(argv[3]);\n        VerifyOrExit(length <= sizeof(cfg.mServerConfig.mServerData), error = OT_ERROR_NO_BUFS);\n        cfg.mServerConfig.mServerDataLength = static_cast<uint8_t>(length);\n        memcpy(cfg.mServerConfig.mServerData, argv[3], cfg.mServerConfig.mServerDataLength);\n\n        cfg.mServerConfig.mStable = true;\n\n        SuccessOrExit(error = otServerAddService(mInstance, &cfg));\n    }\n    else if (strcmp(argv[0], \"remove\") == 0)\n    {\n        long enterpriseNumber = 0;\n\n        VerifyOrExit(argc > 2, error = OT_ERROR_INVALID_ARGS);\n\n        SuccessOrExit(error = ParseLong(argv[1], enterpriseNumber));\n\n        SuccessOrExit(error = otServerRemoveService(mInstance, static_cast<uint32_t>(enterpriseNumber),\n                                                    reinterpret_cast<uint8_t *>(argv[2]),\n                                                    static_cast<uint8_t>(strlen(argv[2]))));\n    }\n    else\n    {\n        ExitNow(error = OT_ERROR_INVALID_ARGS);\n    }\n\nexit:\n    AppendResult(error);\n}",
        "file_path": "/src/openthread/src/cli/cli.cpp",
        "crashing_line": "        memcpy(cfg.mServiceData, argv[2], cfg.mServiceDataLength);",
        "crashing_line_number": 1644
      },
      {
        "function_name": "ProcessLine",
        "function_body": "void Interpreter::ProcessLine(char *aBuf, uint16_t aBufLength, Server &aServer)\n{\n    char *  argv[kMaxArgs] = {NULL};\n    char *  cmd;\n    uint8_t argc = 0, i = 0;\n\n    mServer = &aServer;\n\n    VerifyOrExit(aBuf != NULL && strnlen(aBuf, aBufLength + 1) <= aBufLength);\n\n    VerifyOrExit(Utils::CmdLineParser::ParseCmd(aBuf, argc, argv, kMaxArgs) == OT_ERROR_NONE,\n                 mServer->OutputFormat(\"Error: too many args (max %d)\\r\\n\", kMaxArgs));\n    VerifyOrExit(argc >= 1, mServer->OutputFormat(\"Error: no given command.\\r\\n\"));\n\n    cmd = argv[0];\n\n#if OPENTHREAD_ENABLE_DIAG\n    VerifyOrExit(\n        (!otDiagIsEnabled() || (strcmp(cmd, \"diag\") == 0)),\n        mServer->OutputFormat(\"under diagnostics mode, execute 'diag stop' before running any other commands.\\r\\n\"));\n#endif\n\n    for (i = 0; i < OT_ARRAY_LENGTH(sCommands); i++)\n    {\n        if (strcmp(cmd, sCommands[i].mName) == 0)\n        {\n            (this->*sCommands[i].mCommand)(argc - 1, &argv[1]);\n            break;\n        }\n    }\n\n    // Check user defined commands if built-in command\n    // has not been found\n    if (i == OT_ARRAY_LENGTH(sCommands))\n    {\n        for (i = 0; i < mUserCommandsLength; i++)\n        {\n            if (strcmp(cmd, mUserCommands[i].mName) == 0)\n            {\n                mUserCommands[i].mCommand(argc - 1, &argv[1]);\n                break;\n            }\n        }\n\n        if (i == mUserCommandsLength)\n        {\n            AppendResult(OT_ERROR_PARSE);\n        }\n    }\n\nexit:\n    return;\n}",
        "file_path": "/src/openthread/src/cli/cli.cpp",
        "crashing_line": "        mServer->OutputFormat(\"under diagnostics mode, execute 'diag stop' before running any other commands.\\r\\n\"));",
        "crashing_line_number": 3783
      },
      {
        "function_name": "ProcessCommand",
        "function_body": "otError Uart::ProcessCommand(void)\n{\n    otError error = OT_ERROR_NONE;\n\n    if (mRxBuffer[mRxLength - 1] == '\\n')\n    {\n        mRxBuffer[--mRxLength] = '\\0';\n    }\n\n    if (mRxBuffer[mRxLength - 1] == '\\r')\n    {\n        mRxBuffer[--mRxLength] = '\\0';\n    }\n\n#if OPENTHREAD_CONFIG_LOG_OUTPUT != OPENTHREAD_CONFIG_LOG_OUTPUT_NONE\n    /*\n     * Note this is here for this reason:\n     *\n     * TEXT (command) input ... in a test automation script occurs\n     * rapidly and often without gaps between the command and the\n     * terminal CR\n     *\n     * In contrast as a human is typing there is a delay between the\n     * last character of a command and the terminal CR which executes\n     * a command.\n     *\n     * During that human induced delay a tasklet may be scheduled and\n     * the LOG becomes confusing and it is hard to determine when\n     * something happened.  Which happened first? the command-CR or\n     * the tasklet.\n     *\n     * Yes, while rare it is a race condition that is hard to debug.\n     *\n     * Thus this is here to affirmatively LOG exactly when the CLI\n     * command is being executed.\n     */\n#if OPENTHREAD_ENABLE_MULTIPLE_INSTANCES\n    /* TODO: how exactly do we get the instance here? */\n#else\n    otLogInfoCli(\"execute command: %s\", mRxBuffer);\n#endif\n#endif\n    if (mRxLength > 0)\n    {\n        mInterpreter.ProcessLine(mRxBuffer, mRxLength, *this);\n    }\n\n    mRxLength = 0;\n\n    return error;\n}",
        "file_path": "/src/openthread/src/cli/cli_uart.cpp",
        "crashing_line": "        mInterpreter.ProcessLine(mRxBuffer, mRxLength, *this);",
        "crashing_line_number": 231
      },
      {
        "function_name": "ReceiveTask",
        "function_body": "void Uart::ReceiveTask(const uint8_t *aBuf, uint16_t aBufLength)\n{\n    static const char sCommandPrompt[] = {'>', ' '};\n\n#if OPENTHREAD_CONFIG_UART_CLI_RAW\n    if (aBufLength > 0)\n    {\n        memcpy(mRxBuffer + mRxLength, aBuf, aBufLength);\n        mRxLength += aBufLength;\n    }\n\n    if (aBuf[aBufLength - 1] == '\\r' || aBuf[aBufLength - 1] == '\\n')\n    {\n        mRxBuffer[mRxLength] = '\\0';\n        ProcessCommand();\n        Output(sCommandPrompt, sizeof(sCommandPrompt));\n    }\n#else // OPENTHREAD_CONFIG_UART_CLI_RAW\n    static const char sEraseString[] = {'\\b', ' ', '\\b'};\n    static const char CRNL[]         = {'\\r', '\\n'};\n    const uint8_t *   end;\n\n    end = aBuf + aBufLength;\n\n    for (; aBuf < end; aBuf++)\n    {\n        switch (*aBuf)\n        {\n        case '\\r':\n        case '\\n':\n            Output(CRNL, sizeof(CRNL));\n\n            if (mRxLength > 0)\n            {\n                mRxBuffer[mRxLength] = '\\0';\n                ProcessCommand();\n            }\n\n            Output(sCommandPrompt, sizeof(sCommandPrompt));\n\n            break;\n\n#if OPENTHREAD_POSIX\n\n        case 0x04: // ASCII for Ctrl-D\n            exit(EXIT_SUCCESS);\n            break;\n#endif\n\n        case '\\b':\n        case 127:\n            if (mRxLength > 0)\n            {\n                Output(sEraseString, sizeof(sEraseString));\n                mRxBuffer[--mRxLength] = '\\0';\n            }\n\n            break;\n\n        default:\n            if (mRxLength < kRxBufferSize - 1)\n            {\n                Output(reinterpret_cast<const char *>(aBuf), 1);\n                mRxBuffer[mRxLength++] = static_cast<char>(*aBuf);\n            }\n\n            break;\n        }\n    }\n#endif // OPENTHREAD_CONFIG_UART_CLI_RAW\n}",
        "file_path": "/src/openthread/src/cli/cli_uart.cpp",
        "crashing_line": "                ProcessCommand();",
        "crashing_line_number": 150
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static bool LoadTGA(QDataStream &s, const TgaHeader &tga, QImage &img)\n{\n    // Create image.\n    img = QImage(tga.width, tga.height, QImage::Format_RGB32);\n\n    TgaHeaderInfo info(tga);\n\n    // Bits 0-3 are the numbers of alpha bits (can be zero!)\n    const int numAlphaBits = tga.flags & 0xf;\n    // However alpha exists only in the 32 bit format.\n    if ((tga.pixel_size == 32) && (tga.flags & 0xf)) {\n        img = QImage(tga.width, tga.height, QImage::Format_ARGB32);\n\n        if (numAlphaBits > 8) {\n            return false;\n        }\n    }\n\n    uint pixel_size = (tga.pixel_size / 8);\n    qint64 size = qint64(tga.width) * qint64(tga.height) * pixel_size;\n\n    if (size < 1) {\n//          qDebug() << \"This TGA file is broken with size \" << size;\n        return false;\n    }\n\n    // Read palette.\n    char palette[768];\n    if (info.pal) {\n        // @todo Support palettes in other formats!\n        const int size = 3 * tga.colormap_length;\n        const int dataRead = s.readRawData(palette, size);\n        if (dataRead < size) {\n            memset(&palette[dataRead], 0, size - dataRead);\n        }\n    }\n\n    // Allocate image.\n    uchar *const image = reinterpret_cast<uchar*>(malloc(size));\n    if (!image) {\n        return false;\n    }\n\n    bool valid = true;\n\n    if (info.rle) {\n        // Decode image.\n        char *dst = (char *)image;\n        qint64 num = size;\n\n        while (num > 0) {\n            if (s.atEnd()) {\n                valid = false;\n                break;\n            }\n\n            // Get packet header.\n            uchar c;\n            s >> c;\n\n            uint count = (c & 0x7f) + 1;\n            num -= count * pixel_size;\n            if (num < 0) {\n                valid = false;\n                break;\n            }\n\n            if (c & 0x80) {\n                // RLE pixels.\n                assert(pixel_size <= 8);\n                char pixel[8];\n                s.readRawData(pixel, pixel_size);\n                do {\n                    memcpy(dst, pixel, pixel_size);\n                    dst += pixel_size;\n                } while (--count);\n            } else {\n                // Raw pixels.\n                count *= pixel_size;\n                s.readRawData(dst, count);\n                dst += count;\n            }\n        }\n    } else {\n        // Read raw image.\n        const int dataRead = s.readRawData((char *)image, size);\n        if (dataRead < size) {\n            memset(&image[dataRead], 0, size - dataRead);\n        }\n    }\n\n    if (!valid) {\n        free(image);\n        return false;\n    }\n\n    // Convert image to internal format.\n    int y_start, y_step, y_end;\n    if (tga.flags & TGA_ORIGIN_UPPER) {\n        y_start = 0;\n        y_step = 1;\n        y_end = tga.height;\n    } else {\n        y_start = tga.height - 1;\n        y_step = -1;\n        y_end = -1;\n    }\n\n    uchar *src = image;\n\n    for (int y = y_start; y != y_end; y += y_step) {\n        QRgb *scanline = (QRgb *) img.scanLine(y);\n\n        if (info.pal) {\n            // Paletted.\n            for (int x = 0; x < tga.width; x++) {\n                uchar idx = *src++;\n                scanline[x] = qRgb(palette[3 * idx + 2], palette[3 * idx + 1], palette[3 * idx + 0]);\n            }\n        } else if (info.grey) {\n            // Greyscale.\n            for (int x = 0; x < tga.width; x++) {\n                scanline[x] = qRgb(*src, *src, *src);\n                src++;\n            }\n        } else {\n            // True Color.\n            if (tga.pixel_size == 16) {\n                for (int x = 0; x < tga.width; x++) {\n                    Color555 c = *reinterpret_cast<Color555 *>(src);\n                    scanline[x] = qRgb((c.r << 3) | (c.r >> 2), (c.g << 3) | (c.g >> 2), (c.b << 3) | (c.b >> 2));\n                    src += 2;\n                }\n            } else if (tga.pixel_size == 24) {\n                for (int x = 0; x < tga.width; x++) {\n                    scanline[x] = qRgb(src[2], src[1], src[0]);\n                    src += 3;\n                }\n            } else if (tga.pixel_size == 32) {\n                for (int x = 0; x < tga.width; x++) {\n                    // ### TODO: verify with images having really some alpha data\n                    const uchar alpha = (src[3] << (8 - numAlphaBits));\n                    scanline[x] = qRgba(src[2], src[1], src[0], alpha);\n                    src += 4;\n                }\n            }\n        }\n    }\n\n    // Free image.\n    free(image);\n\n    return true;\n}\n",
    "target": 1,
    "idx": 1012818,
    "stack_trace": [
      {
        "function_name": "LoadTGA",
        "function_body": "static bool LoadTGA(QDataStream &s, const TgaHeader &tga, QImage &img)\n{\n    // Create image.\n    img = QImage(tga.width, tga.height, QImage::Format_RGB32);\n\n    TgaHeaderInfo info(tga);\n\n    // Bits 0-3 are the numbers of alpha bits (can be zero!)\n    const int numAlphaBits = tga.flags & 0xf;\n    // However alpha exists only in the 32 bit format.\n    if ((tga.pixel_size == 32) && (tga.flags & 0xf)) {\n        img = QImage(tga.width, tga.height, QImage::Format_ARGB32);\n\n        if (numAlphaBits > 8) {\n            return false;\n        }\n    }\n\n    uint pixel_size = (tga.pixel_size / 8);\n    qint64 size = qint64(tga.width) * qint64(tga.height) * pixel_size;\n\n    if (size < 1) {\n//          qDebug() << \"This TGA file is broken with size \" << size;\n        return false;\n    }\n\n    // Read palette.\n    char palette[768];\n    if (info.pal) {\n        // @todo Support palettes in other formats!\n        const int size = 3 * tga.colormap_length;\n        const int dataRead = s.readRawData(palette, size);\n        if (dataRead < 0) {\n            return false;\n        }\n        if (dataRead < size) {\n            memset(&palette[dataRead], 0, size - dataRead);\n        }\n    }\n\n    // Allocate image.\n    uchar *const image = reinterpret_cast<uchar*>(malloc(size));\n    if (!image) {\n        return false;\n    }\n\n    bool valid = true;\n\n    if (info.rle) {\n        // Decode image.\n        char *dst = (char *)image;\n        qint64 num = size;\n\n        while (num > 0) {\n            if (s.atEnd()) {\n                valid = false;\n                break;\n            }\n\n            // Get packet header.\n            uchar c;\n            s >> c;\n\n            uint count = (c & 0x7f) + 1;\n            num -= count * pixel_size;\n            if (num < 0) {\n                valid = false;\n                break;\n            }\n\n            if (c & 0x80) {\n                // RLE pixels.\n                assert(pixel_size <= 8);\n                char pixel[8];\n                s.readRawData(pixel, pixel_size);\n                do {\n                    memcpy(dst, pixel, pixel_size);\n                    dst += pixel_size;\n                } while (--count);\n            } else {\n                // Raw pixels.\n                count *= pixel_size;\n                s.readRawData(dst, count);\n                dst += count;\n            }\n        }\n    } else {\n        // Read raw image.\n        const int dataRead = s.readRawData((char *)image, size);\n        if (dataRead < 0) {\n            free(image);\n            return false;\n        }\n        if (dataRead < size) {\n            memset(&image[dataRead], 0, size - dataRead);\n        }\n    }\n\n    if (!valid) {\n        free(image);\n        return false;\n    }\n\n    // Convert image to internal format.\n    int y_start, y_step, y_end;\n    if (tga.flags & TGA_ORIGIN_UPPER) {\n        y_start = 0;\n        y_step = 1;\n        y_end = tga.height;\n    } else {\n        y_start = tga.height - 1;\n        y_step = -1;\n        y_end = -1;\n    }\n\n    uchar *src = image;\n\n    for (int y = y_start; y != y_end; y += y_step) {\n        QRgb *scanline = (QRgb *) img.scanLine(y);\n\n        if (info.pal) {\n            // Paletted.\n            for (int x = 0; x < tga.width; x++) {\n                uchar idx = *src++;\n                scanline[x] = qRgb(palette[3 * idx + 2], palette[3 * idx + 1], palette[3 * idx + 0]);\n            }\n        } else if (info.grey) {\n            // Greyscale.\n            for (int x = 0; x < tga.width; x++) {\n                scanline[x] = qRgb(*src, *src, *src);\n                src++;\n            }\n        } else {\n            // True Color.\n            if (tga.pixel_size == 16) {\n                for (int x = 0; x < tga.width; x++) {\n                    Color555 c = *reinterpret_cast<Color555 *>(src);\n                    scanline[x] = qRgb((c.r << 3) | (c.r >> 2), (c.g << 3) | (c.g >> 2), (c.b << 3) | (c.b >> 2));\n                    src += 2;\n                }\n            } else if (tga.pixel_size == 24) {\n                for (int x = 0; x < tga.width; x++) {\n                    scanline[x] = qRgb(src[2], src[1], src[0]);\n                    src += 3;\n                }\n            } else if (tga.pixel_size == 32) {\n                for (int x = 0; x < tga.width; x++) {\n                    // ### TODO: verify with images having really some alpha data\n                    const uchar alpha = (src[3] << (8 - numAlphaBits));\n                    scanline[x] = qRgba(src[2], src[1], src[0], alpha);\n                    src += 4;\n                }\n            }\n        }\n    }\n\n    // Free image.\n    free(image);\n\n    return true;\n}",
        "file_path": "/src/kimageformats/src/imageformats/tga.cpp",
        "crashing_line": "        // Read raw image.",
        "crashing_line_number": 264
      },
      {
        "function_name": "read",
        "function_body": "bool TGAHandler::read(QImage *outImage)\n{\n    //qDebug() << \"Loading TGA file!\";\n\n    QDataStream s(device());\n    s.setByteOrder(QDataStream::LittleEndian);\n\n    // Read image header.\n    TgaHeader tga;\n    s >> tga;\n    s.device()->seek(TgaHeader::SIZE + tga.id_length);\n\n    // Check image file format.\n    if (s.atEnd()) {\n//         qDebug() << \"This TGA file is not valid.\";\n        return false;\n    }\n\n    // Check supported file types.\n    if (!IsSupported(tga)) {\n//         qDebug() << \"This TGA file is not supported.\";\n        return false;\n    }\n\n    QImage img;\n    bool result = LoadTGA(s, tga, img);\n\n    if (result == false) {\n//         qDebug() << \"Error loading TGA file.\";\n        return false;\n    }\n\n    *outImage = img;\n    return true;\n}",
        "file_path": "/src/kimageformats/src/imageformats/tga.cpp",
        "crashing_line": "    // Check supported file types.",
        "crashing_line_number": 372
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "int ares_parse_a_reply(const unsigned char *abuf, int alen,\n                       struct hostent **host,\n                       struct ares_addrttl *addrttls, int *naddrttls)\n{\n  struct ares_addrinfo ai;\n  struct ares_addrinfo_node *next;\n  struct ares_addrinfo_cname *next_cname;\n  char **aliases = NULL;\n  char *question_hostname = NULL;\n  struct hostent *hostent = NULL;\n  struct in_addr *addrs = NULL;\n  int naliases = 0, naddrs = 0, alias = 0, i;\n  int cname_ttl = INT_MAX;\n  int status;\n\n  memset(&ai, 0, sizeof(ai));\n\n  status = ares__parse_into_addrinfo2(abuf, alen, &question_hostname, &ai);\n  if (status != ARES_SUCCESS)\n    {\n      ares_free(question_hostname);\n\n      if (naddrttls)\n        {\n          *naddrttls = naddrs;\n        }\n\n      return status;\n    }\n\n  hostent = ares_malloc(sizeof(struct hostent));\n  if (!hostent)\n    {\n      goto enomem;\n    }\n\n  next = ai.nodes;\n  while (next)\n    {\n      ++naddrs;\n      next = next->ai_next;\n    }\n\n  next_cname = ai.cnames;\n  while (next_cname)\n    {\n      if(next_cname->alias)\n        ++naliases;\n      next_cname = next_cname->next;\n    }\n\n  aliases = ares_malloc((naliases + 1) * sizeof(char *));\n  if (!aliases)\n    {\n      goto enomem;\n    }\n\n  if (naliases)\n    {\n      next_cname = ai.cnames;\n      while (next_cname)\n        {\n          if(next_cname->alias)\n            aliases[alias++] = strdup(next_cname->alias);\n          if(next_cname->ttl < cname_ttl)\n            cname_ttl = next_cname->ttl;\n          next_cname = next_cname->next;\n        }\n    }\n\n  aliases[alias] = NULL;\n\n  hostent->h_addr_list = ares_malloc((naddrs + 1) * sizeof(char *));\n  if (!hostent->h_addr_list)\n    {\n      goto enomem;\n    }\n\n  for (i = 0; i < naddrs + 1; ++i)\n    {\n      hostent->h_addr_list[i] = NULL;\n    }\n\n  if (ai.cnames)\n    {\n      hostent->h_name = strdup(ai.cnames->name);\n      ares_free(question_hostname);\n    }\n  else\n    {\n      hostent->h_name = question_hostname;\n    }\n\n  hostent->h_aliases = aliases;\n  hostent->h_addrtype = AF_INET;\n  hostent->h_length = sizeof(struct in_addr);\n\n  if (naddrs)\n    {\n      addrs = ares_malloc(naddrs * sizeof(struct in_addr));\n      if (!addrs)\n        {\n          goto enomem;\n        }\n\n      i = 0;\n      next = ai.nodes;\n      while (next)\n        {\n          if (next->ai_family == AF_INET)\n            {\n              hostent->h_addr_list[i] = (char *)&addrs[i];\n              memcpy(hostent->h_addr_list[i],\n                     &(((struct sockaddr_in *)next->ai_addr)->sin_addr),\n                     sizeof(struct in_addr));\n              if (naddrttls)\n                {\n                  if (next->ai_ttl > cname_ttl)\n                    addrttls[i].ttl = cname_ttl;\n                  else\n                    addrttls[i].ttl = next->ai_ttl;\n\n                  memcpy(&addrttls[i].ipaddr,\n                         &(((struct sockaddr_in *)next->ai_addr)->sin_addr),\n                         sizeof(struct in_addr));\n                }\n              ++i;\n            }\n          next = next->ai_next;\n        }\n    }\n\n  if (host)\n    {\n      *host = hostent;\n    }\n  else\n    {\n      ares_free_hostent(hostent);\n    }\n\n  if (naddrttls)\n    {\n      *naddrttls = naddrs;\n    }\n\n  ares__freeaddrinfo_cnames(ai.cnames);\n  ares__freeaddrinfo_nodes(ai.nodes);\n  return ARES_SUCCESS;\n\nenomem:\n  ares_free(aliases);\n  ares_free(hostent);\n  ares__freeaddrinfo_cnames(ai.cnames);\n  ares__freeaddrinfo_nodes(ai.nodes);\n  ares_free(question_hostname);\n  return ARES_ENOMEM;\n}\nint ares_parse_aaaa_reply(const unsigned char *abuf, int alen,\n                          struct hostent **host, struct ares_addr6ttl *addrttls,\n                          int *naddrttls)\n{\n  struct ares_addrinfo ai;\n  struct ares_addrinfo_node *next;\n  struct ares_addrinfo_cname *next_cname;\n  char **aliases = NULL;\n  char *question_hostname = NULL;\n  struct hostent *hostent = NULL;\n  struct ares_in6_addr *addrs = NULL;\n  int naliases = 0, naddrs = 0, alias = 0, i;\n  int cname_ttl = INT_MAX;\n  int status;\n\n  memset(&ai, 0, sizeof(ai));\n\n  status = ares__parse_into_addrinfo2(abuf, alen, &question_hostname, &ai);\n  if (status != ARES_SUCCESS)\n    {\n      ares_free(question_hostname);\n\n      if (naddrttls)\n        {\n          *naddrttls = naddrs;\n        }\n\n      return status;\n    }\n\n  hostent = ares_malloc(sizeof(struct hostent));\n  if (!hostent)\n    {\n      goto enomem;\n    }\n\n  next = ai.nodes;\n  while (next)\n    {\n      ++naddrs;\n      next = next->ai_next;\n    }\n\n  next_cname = ai.cnames;\n  while (next_cname)\n    {\n      if(next_cname->alias)\n        ++naliases;\n      next_cname = next_cname->next;\n    }\n\n  aliases = ares_malloc((naliases + 1) * sizeof(char *));\n  if (!aliases)\n    {\n      goto enomem;\n    }\n\n  if (naliases)\n    {\n      next_cname = ai.cnames;\n      while (next_cname)\n        {\n          if(next_cname->alias)\n            aliases[alias++] = strdup(next_cname->alias);\n          if(next_cname->ttl < cname_ttl)\n            cname_ttl = next_cname->ttl;\n          next_cname = next_cname->next;\n        }\n    }\n\n  aliases[alias] = NULL;\n\n  hostent->h_addr_list = ares_malloc((naddrs + 1) * sizeof(char *));\n  if (!hostent->h_addr_list)\n    {\n      goto enomem;\n    }\n\n  for (i = 0; i < naddrs + 1; ++i)\n    {\n      hostent->h_addr_list[i] = NULL;\n    }\n\n  if (ai.cnames)\n    {\n      hostent->h_name = strdup(ai.cnames->name);\n      ares_free(question_hostname);\n    }\n  else\n    {\n      hostent->h_name = question_hostname;\n    }\n\n  hostent->h_aliases = aliases;\n  hostent->h_addrtype = AF_INET6;\n  hostent->h_length = sizeof(struct ares_in6_addr);\n\n  if (naddrs)\n    {\n      addrs = ares_malloc(naddrs * sizeof(struct ares_in6_addr));\n      if (!addrs)\n        {\n          goto enomem;\n        }\n\n      i = 0;\n      next = ai.nodes;\n      while (next)\n        {\n          if(next->ai_family == AF_INET6)\n            {\n              hostent->h_addr_list[i] = (char*)&addrs[i];\n              memcpy(hostent->h_addr_list[i],\n                     &(((struct sockaddr_in6 *)next->ai_addr)->sin6_addr),\n                     sizeof(struct ares_in6_addr));\n              if (naddrttls)\n                {\n                    if(next->ai_ttl > cname_ttl)\n                      addrttls[i].ttl = cname_ttl;\n                    else\n                      addrttls[i].ttl = next->ai_ttl;\n\n                    memcpy(&addrttls[i].ip6addr,\n                           &(((struct sockaddr_in6 *)next->ai_addr)->sin6_addr),\n                           sizeof(struct ares_in6_addr));\n                }\n              ++i;\n            }\n          next = next->ai_next;\n        }\n    }\n\n  if (host)\n    {\n      *host = hostent;\n    }\n  else\n    {\n      ares_free_hostent(hostent);\n    }\n\n  if (naddrttls)\n    {\n      *naddrttls = naddrs;\n    }\n\n  ares__freeaddrinfo_cnames(ai.cnames);\n  ares__freeaddrinfo_nodes(ai.nodes);\n  return ARES_SUCCESS;\n\nenomem:\n  ares_free(aliases);\n  ares_free(hostent);\n  ares__freeaddrinfo_cnames(ai.cnames);\n  ares__freeaddrinfo_nodes(ai.nodes);\n  ares_free(question_hostname);\n  return ARES_ENOMEM;\n}\n",
    "target": 1,
    "idx": 1015459,
    "stack_trace": []
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\ndo_fileid(struct state *cur, int argc, char **argv)\n{\n\tstruct file_info *fi;\n\tstruct sc_file\t*df, *file = NULL;\n\tstruct sc_path\ttemp, *path = NULL;\n\n\tif (!cur->file) {\n\t\tparse_error(cur, \"Invalid state\\n\");\n\t\treturn 1;\n\t}\n\tfile = cur->file->file;\n\tpath = &file->path;\n\n\t/* sc_format_path doesn't return an error indication\n\t * when it's unable to parse the path */\n\tsc_format_path(argv[0], &temp);\n\tif (temp.len != 2) {\n\t\tparse_error(cur, \"Invalid file ID length\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Get the DF, if any */\n\tif ((fi = cur->file->parent) && (df = fi->file)) {\n\t\tif (!df->path.len && !df->path.aid.len) {\n\t\t\tparse_error(cur, \"No path/fileid set for parent DF\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (df->path.len + 2 > sizeof(df->path.value)) {\n\t\t\tparse_error(cur, \"File path too long\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t*path = df->path;\n\t}\n\tmemcpy(path->value + path->len, temp.value, 2);\n\tpath->len += 2;\n\n\tfile->id = (temp.value[0] << 8) | temp.value[1];\n\treturn 0;\n}\n",
    "target": 1,
    "idx": 1045430,
    "stack_trace": [
      {
        "function_name": "do_fileid",
        "function_body": "static int\ndo_fileid(struct state *cur, int argc, char **argv)\n{\n\tstruct file_info *fi;\n\tstruct sc_file\t*df, *file = NULL;\n\tstruct sc_path\ttemp, *path = NULL;\n\n\tif (!cur->file) {\n\t\tparse_error(cur, \"Invalid state\\n\");\n\t\treturn 1;\n\t}\n\tfile = cur->file->file;\n\tpath = &file->path;\n\n\t/* sc_format_path doesn't return an error indication\n\t * when it's unable to parse the path */\n\tsc_format_path(argv[0], &temp);\n\tif (temp.len != 2) {\n\t\tparse_error(cur, \"Invalid file ID length\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Get the DF, if any */\n\tif ((fi = cur->file->parent) && (df = fi->file)) {\n\t\tif (!df->path.len && !df->path.aid.len) {\n\t\t\tparse_error(cur, \"No path/fileid set for parent DF\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (df->path.len + 2 > sizeof(df->path.value)) {\n\t\t\tparse_error(cur, \"File path too long\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t*path = df->path;\n\t}\n\tif (path->len + 2 > sizeof(path->value)) {\n\t\tparse_error(cur, \"File path too long\\n\");\n\t\treturn 1;\n\t}\n\tmemcpy(path->value + path->len, temp.value, 2);\n\tpath->len += 2;\n\n\tfile->id = (temp.value[0] << 8) | temp.value[1];\n\treturn 0;\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/profile.c",
        "crashing_line": "\tif (path->len + 2 > sizeof(path->value)) {",
        "crashing_line_number": 1358
      },
      {
        "function_name": "process_command",
        "function_body": "static int\nprocess_command(struct state *cur, struct command *cmd_info, scconf_list *list)\n{\n\tconst char\t*cmd = cmd_info->name;\n\tchar\t\t*argv[32];\n\tint\t\targc, max = 32;\n\n\tif (cmd_info->max_args >= 0 && max > cmd_info->max_args)\n\t\tmax = cmd_info->max_args;\n\n\tif ((argc = build_argv(cur, cmd, list, argv, max)) < 0)\n\t\treturn argc;\n\n\tif (argc < cmd_info->min_args) {\n\t\tparse_error(cur, \"%s: not enough arguments\\n\", cmd);\n\t\treturn 1;\n\t}\n\treturn cmd_info->func(cur, argc, argv);\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/profile.c",
        "crashing_line": "\tif (argc < cmd_info->min_args) {",
        "crashing_line_number": 2027
      },
      {
        "function_name": "process_block",
        "function_body": "static int\nprocess_block(struct state *cur, struct block *info,\n\t\tconst char *name, scconf_block *blk)\n{\n\tscconf_item\t*item;\n\tstruct command\t*cp;\n\tstruct block\t*bp;\n\tconst char\t*cmd, *ident;\n\tint\t\tres = 0;\n\n\tfor (item = blk->items; res == 0 && item; item = item->next) {\n\t\tcmd = item->key;\n\t\tif (item->type == SCCONF_ITEM_TYPE_COMMENT)\n\t\t\tcontinue;\n\t\tif (!cmd) {\n\t\t\tparse_error(cur, \"Command can not be processed.\");\n\t\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t\t}\n\t\tif (item->type == SCCONF_ITEM_TYPE_BLOCK) {\n\t\t\tscconf_list *nlist;\n\n\t\t\tident = NULL;\n\t\t\tif ((nlist = item->value.block->name) != NULL) {\n\t\t\t\tif (nlist->next) {\n\t\t\t\t\tparse_error(cur, \"Too many name components in block name.\");\n\t\t\t\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t\t\t\t}\n\t\t\t\tident = nlist->data;\n\t\t\t}\n#ifdef DEBUG_PROFILE\n\t\t\tprintf(\"Processing %s %s\\n\", cmd, ident? ident : \"\");\n#endif\n\t\t\tif ((bp = find_block_handler(info->blk_info, cmd))) {\n\t\t\t\tres = bp->handler(cur, bp, ident, item->value.block);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (item->type == SCCONF_ITEM_TYPE_VALUE) {\n#ifdef DEBUG_PROFILE\n\t\t\tprintf(\"Processing %s\\n\", cmd);\n#endif\n\t\t\tif ((cp = find_cmd_handler(info->cmd_info, cmd))) {\n\t\t\t\tres = process_command(cur, cp, item->value.list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tparse_error(cur, \"Command \\\"%s\\\" not understood in this context.\", cmd);\n\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t}\n\n\tif (res > 0)\n\t\tres = SC_ERROR_SYNTAX_ERROR;\n\treturn res;\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/profile.c",
        "crashing_line": "#ifdef DEBUG_PROFILE",
        "crashing_line_number": 2096
      },
      {
        "function_name": "process_ef",
        "function_body": "static int\nprocess_ef(struct state *cur, struct block *info,\n\t\tconst char *name, scconf_block *blk)\n{\n\tstruct state\tstate;\n\n\tinit_state(cur, &state);\n\tif (name == NULL) {\n\t\tparse_error(cur, \"No name given for EF object.\");\n\t\treturn 1;\n\t}\n\tif (!(state.file = new_file(cur, name, SC_FILE_TYPE_WORKING_EF)))\n\t\treturn 1;\n\treturn process_block(&state, info, name, blk);\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/profile.c",
        "crashing_line": "\treturn process_block(&state, info, name, blk);",
        "crashing_line_number": 1031
      },
      {
        "function_name": "process_block",
        "function_body": "static int\nprocess_block(struct state *cur, struct block *info,\n\t\tconst char *name, scconf_block *blk)\n{\n\tscconf_item\t*item;\n\tstruct command\t*cp;\n\tstruct block\t*bp;\n\tconst char\t*cmd, *ident;\n\tint\t\tres = 0;\n\n\tfor (item = blk->items; res == 0 && item; item = item->next) {\n\t\tcmd = item->key;\n\t\tif (item->type == SCCONF_ITEM_TYPE_COMMENT)\n\t\t\tcontinue;\n\t\tif (!cmd) {\n\t\t\tparse_error(cur, \"Command can not be processed.\");\n\t\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t\t}\n\t\tif (item->type == SCCONF_ITEM_TYPE_BLOCK) {\n\t\t\tscconf_list *nlist;\n\n\t\t\tident = NULL;\n\t\t\tif ((nlist = item->value.block->name) != NULL) {\n\t\t\t\tif (nlist->next) {\n\t\t\t\t\tparse_error(cur, \"Too many name components in block name.\");\n\t\t\t\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t\t\t\t}\n\t\t\t\tident = nlist->data;\n\t\t\t}\n#ifdef DEBUG_PROFILE\n\t\t\tprintf(\"Processing %s %s\\n\", cmd, ident? ident : \"\");\n#endif\n\t\t\tif ((bp = find_block_handler(info->blk_info, cmd))) {\n\t\t\t\tres = bp->handler(cur, bp, ident, item->value.block);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (item->type == SCCONF_ITEM_TYPE_VALUE) {\n#ifdef DEBUG_PROFILE\n\t\t\tprintf(\"Processing %s\\n\", cmd);\n#endif\n\t\t\tif ((cp = find_cmd_handler(info->cmd_info, cmd))) {\n\t\t\t\tres = process_command(cur, cp, item->value.list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tparse_error(cur, \"Command \\\"%s\\\" not understood in this context.\", cmd);\n\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t}\n\n\tif (res > 0)\n\t\tres = SC_ERROR_SYNTAX_ERROR;\n\treturn res;\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/profile.c",
        "crashing_line": "#ifdef DEBUG_PROFILE",
        "crashing_line_number": 2087
      },
      {
        "function_name": "process_block",
        "function_body": "static int\nprocess_block(struct state *cur, struct block *info,\n\t\tconst char *name, scconf_block *blk)\n{\n\tscconf_item\t*item;\n\tstruct command\t*cp;\n\tstruct block\t*bp;\n\tconst char\t*cmd, *ident;\n\tint\t\tres = 0;\n\n\tfor (item = blk->items; res == 0 && item; item = item->next) {\n\t\tcmd = item->key;\n\t\tif (item->type == SCCONF_ITEM_TYPE_COMMENT)\n\t\t\tcontinue;\n\t\tif (!cmd) {\n\t\t\tparse_error(cur, \"Command can not be processed.\");\n\t\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t\t}\n\t\tif (item->type == SCCONF_ITEM_TYPE_BLOCK) {\n\t\t\tscconf_list *nlist;\n\n\t\t\tident = NULL;\n\t\t\tif ((nlist = item->value.block->name) != NULL) {\n\t\t\t\tif (nlist->next) {\n\t\t\t\t\tparse_error(cur, \"Too many name components in block name.\");\n\t\t\t\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t\t\t\t}\n\t\t\t\tident = nlist->data;\n\t\t\t}\n#ifdef DEBUG_PROFILE\n\t\t\tprintf(\"Processing %s %s\\n\", cmd, ident? ident : \"\");\n#endif\n\t\t\tif ((bp = find_block_handler(info->blk_info, cmd))) {\n\t\t\t\tres = bp->handler(cur, bp, ident, item->value.block);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (item->type == SCCONF_ITEM_TYPE_VALUE) {\n#ifdef DEBUG_PROFILE\n\t\t\tprintf(\"Processing %s\\n\", cmd);\n#endif\n\t\t\tif ((cp = find_cmd_handler(info->cmd_info, cmd))) {\n\t\t\t\tres = process_command(cur, cp, item->value.list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tparse_error(cur, \"Command \\\"%s\\\" not understood in this context.\", cmd);\n\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t}\n\n\tif (res > 0)\n\t\tres = SC_ERROR_SYNTAX_ERROR;\n\treturn res;\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/profile.c",
        "crashing_line": "#ifdef DEBUG_PROFILE",
        "crashing_line_number": 2087
      },
      {
        "function_name": "process_option",
        "function_body": "static int\nprocess_option(struct state *cur, struct block *info,\n\t\tconst char *name, scconf_block *blk)\n{\n\tsc_profile_t\t*profile = cur->profile;\n\tint\t\tmatch = 0, i;\n\n\tfor (i = 0; profile->options[i]; i++)\n\t\tmatch |= !strcmp(profile->options[i], name);\n\tif (!match && strcmp(\"default\", name))\n\t\treturn 0;\n\treturn process_block(cur, info, name, blk);\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/profile.c",
        "crashing_line": "\treturn process_block(cur, info, name, blk);",
        "crashing_line_number": 932
      },
      {
        "function_name": "process_block",
        "function_body": "static int\nprocess_block(struct state *cur, struct block *info,\n\t\tconst char *name, scconf_block *blk)\n{\n\tscconf_item\t*item;\n\tstruct command\t*cp;\n\tstruct block\t*bp;\n\tconst char\t*cmd, *ident;\n\tint\t\tres = 0;\n\n\tfor (item = blk->items; res == 0 && item; item = item->next) {\n\t\tcmd = item->key;\n\t\tif (item->type == SCCONF_ITEM_TYPE_COMMENT)\n\t\t\tcontinue;\n\t\tif (!cmd) {\n\t\t\tparse_error(cur, \"Command can not be processed.\");\n\t\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t\t}\n\t\tif (item->type == SCCONF_ITEM_TYPE_BLOCK) {\n\t\t\tscconf_list *nlist;\n\n\t\t\tident = NULL;\n\t\t\tif ((nlist = item->value.block->name) != NULL) {\n\t\t\t\tif (nlist->next) {\n\t\t\t\t\tparse_error(cur, \"Too many name components in block name.\");\n\t\t\t\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t\t\t\t}\n\t\t\t\tident = nlist->data;\n\t\t\t}\n#ifdef DEBUG_PROFILE\n\t\t\tprintf(\"Processing %s %s\\n\", cmd, ident? ident : \"\");\n#endif\n\t\t\tif ((bp = find_block_handler(info->blk_info, cmd))) {\n\t\t\t\tres = bp->handler(cur, bp, ident, item->value.block);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (item->type == SCCONF_ITEM_TYPE_VALUE) {\n#ifdef DEBUG_PROFILE\n\t\t\tprintf(\"Processing %s\\n\", cmd);\n#endif\n\t\t\tif ((cp = find_cmd_handler(info->cmd_info, cmd))) {\n\t\t\t\tres = process_command(cur, cp, item->value.list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tparse_error(cur, \"Command \\\"%s\\\" not understood in this context.\", cmd);\n\t\treturn SC_ERROR_SYNTAX_ERROR;\n\t}\n\n\tif (res > 0)\n\t\tres = SC_ERROR_SYNTAX_ERROR;\n\treturn res;\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/profile.c",
        "crashing_line": "#ifdef DEBUG_PROFILE",
        "crashing_line_number": 2087
      },
      {
        "function_name": "process_conf",
        "function_body": "static int\nprocess_conf(struct sc_profile *profile, scconf_context *conf)\n{\n\tstruct state\tstate;\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.filename = conf->filename;\n\tstate.profile = profile;\n\treturn process_block(&state, &root_ops, \"root\", conf->root);\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/profile.c",
        "crashing_line": "",
        "crashing_line_number": 2117
      },
      {
        "function_name": "fuzz_profile_load",
        "function_body": "int fuzz_profile_load(struct sc_profile *profile, const uint8_t *data, size_t size)\n{\n    int rv = 0;\n    scconf_context\t*conf = NULL;\n    conf = scconf_new(NULL);\n    if (!conf)\n        return 0;\n\n    if ((rv = scconf_parse_string(conf, (char *)data)) < 0) {\n        scconf_free(conf);\n        return rv;\n    }\n\n    rv = process_conf(profile, conf);\n    scconf_free(conf);\n    return rv;\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/fuzz_pkcs15init.c",
        "crashing_line": "    rv = process_conf(profile, conf);",
        "crashing_line_number": 46
      },
      {
        "function_name": "fuzz_pkcs15init_bind",
        "function_body": "void fuzz_pkcs15init_bind(struct sc_card *card, struct sc_profile **result,\n                          const uint8_t *data, size_t size)\n{\n    struct sc_profile *profile = NULL;\n    const char\t      *driver;\n    struct sc_pkcs15init_operations * (* func)(void) = NULL;\n    int r = 0;\n\n    if (!card || !card->driver || !result)\n        return;\n\n    *result = NULL;\n\n    r = sc_pkcs15init_set_lifecycle(card, SC_CARDCTRL_LIFECYCLE_ADMIN);\n    if (r < 0 && r != SC_ERROR_NOT_SUPPORTED) {\n        return;\n    }\n\n\tprofile = sc_profile_new();\n    if (!profile)\n        return;\n    profile->card = card;\n    driver = card->driver->short_name;\n\n    for (int i = 0; profile_operations[i].name; i++) {\n\t\tif (!strcasecmp(driver, profile_operations[i].name)) {\n\t\t\tfunc = (struct sc_pkcs15init_operations *(*)(void)) profile_operations[i].func;\n\t\t\tbreak;\n\t\t}\n\t}\n    if (func) {\n        profile->ops = func();\n    } else {\n        sc_profile_free(profile);\n        return;\n    }\n    profile->name = strdup(\"Fuzz profile\");\n\n    r = sc_pkcs15init_read_info(card, profile);\n    if (r < 0) {\n\t\tsc_profile_free(profile);\n        return;\n\t}\n\n    if (fuzz_profile_load(profile, data, size) < 0) {\n        sc_profile_free(profile);\n        return;\n    }\n\n    if (sc_profile_finish(profile, NULL) < 0) {\n        sc_profile_free(profile);\n        return;\n    }\n    *result = profile;\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/fuzz_pkcs15init.c",
        "crashing_line": "    if (fuzz_profile_load(profile, data, size) < 0) {",
        "crashing_line_number": 95
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static INLINE void ensure_mv_buffer(RefCntBuffer *buf, AV1_COMMON *cm) {\n  const int buf_rows = buf->mi_rows;\n  const int buf_cols = buf->mi_cols;\n  const CommonModeInfoParams *const mi_params = &cm->mi_params;\n\n  if (buf->seg_map == NULL || buf_rows != mi_params->mi_rows ||\n      buf_cols != mi_params->mi_cols) {\n    buf->mi_rows = mi_params->mi_rows;\n    buf->mi_cols = mi_params->mi_cols;\n    aom_free(buf->seg_map);\n    CHECK_MEM_ERROR(\n        cm, buf->seg_map,\n        (uint8_t *)aom_calloc(mi_params->mi_rows * mi_params->mi_cols,\n                              sizeof(*buf->seg_map)));\n  }\n  if (buf->mvs == NULL || buf_rows != mi_params->mi_rows ||\n      buf_cols != mi_params->mi_cols) {\n    if (cm->seq_params->order_hint_info.enable_ref_frame_mvs) {\n      aom_free(buf->mvs);\n      CHECK_MEM_ERROR(cm, buf->mvs,\n                      (MV_REF *)aom_calloc(((mi_params->mi_rows + 1) >> 1) *\n                                               ((mi_params->mi_cols + 1) >> 1),\n                                           sizeof(*buf->mvs)));\n    }\n  }\n\n  const int mem_size =\n      ((mi_params->mi_rows + MAX_MIB_SIZE) >> 1) * (mi_params->mi_stride >> 1);\n  int realloc = cm->tpl_mvs == NULL;\n  if (cm->tpl_mvs) realloc |= cm->tpl_mvs_mem_size < mem_size;\n\n  if (realloc) {\n    aom_free(cm->tpl_mvs);\n    CHECK_MEM_ERROR(cm, cm->tpl_mvs,\n                    (TPL_MV_REF *)aom_calloc(mem_size, sizeof(*cm->tpl_mvs)));\n    cm->tpl_mvs_mem_size = mem_size;\n  }\n}\n",
    "target": 1,
    "idx": 1049652,
    "stack_trace": [
      {
        "function_name": "intra_copy_frame_mvs",
        "function_body": "static void intra_copy_frame_mvs(AV1_COMMON *const cm, int mi_row, int mi_col,\n                                 int x_mis, int y_mis) {\n  const int frame_mvs_stride = ROUND_POWER_OF_TWO(cm->mi_params.mi_cols, 1);\n  MV_REF *frame_mvs =\n      cm->cur_frame->mvs + (mi_row >> 1) * frame_mvs_stride + (mi_col >> 1);\n  x_mis = ROUND_POWER_OF_TWO(x_mis, 1);\n  y_mis = ROUND_POWER_OF_TWO(y_mis, 1);\n\n  for (int h = 0; h < y_mis; h++) {\n    MV_REF *mv = frame_mvs;\n    for (int w = 0; w < x_mis; w++) {\n      mv->ref_frame = NONE_FRAME;\n      mv++;\n    }\n    frame_mvs += frame_mvs_stride;\n  }\n}",
        "file_path": "/src/aom/av1/decoder/decodemv.c",
        "crashing_line": "      mv->ref_frame = NONE_FRAME;",
        "crashing_line_number": 1558
      },
      {
        "function_name": "av1_read_mode_info",
        "function_body": "void av1_read_mode_info(AV1Decoder *const pbi, DecoderCodingBlock *dcb,\n                        aom_reader *r, int x_mis, int y_mis) {\n  AV1_COMMON *const cm = &pbi->common;\n  MACROBLOCKD *const xd = &dcb->xd;\n  MB_MODE_INFO *const mi = xd->mi[0];\n  mi->use_intrabc = 0;\n\n  if (frame_is_intra_only(cm)) {\n    read_intra_frame_mode_info(cm, dcb, r);\n    if (cm->seq_params->order_hint_info.enable_ref_frame_mvs)\n      intra_copy_frame_mvs(cm, xd->mi_row, xd->mi_col, x_mis, y_mis);\n  } else {\n    read_inter_frame_mode_info(pbi, dcb, r);\n    if (cm->seq_params->order_hint_info.enable_ref_frame_mvs)\n      av1_copy_frame_mvs(cm, mi, xd->mi_row, xd->mi_col, x_mis, y_mis);\n  }\n}",
        "file_path": "/src/aom/av1/decoder/decodemv.c",
        "crashing_line": "      intra_copy_frame_mvs(cm, xd->mi_row, xd->mi_col, x_mis, y_mis);",
        "crashing_line_number": 1575
      },
      {
        "function_name": "decode_mbmi_block",
        "function_body": "static AOM_INLINE void decode_mbmi_block(AV1Decoder *const pbi,\n                                         DecoderCodingBlock *dcb, int mi_row,\n                                         int mi_col, aom_reader *r,\n                                         PARTITION_TYPE partition,\n                                         BLOCK_SIZE bsize) {\n  AV1_COMMON *const cm = &pbi->common;\n  const SequenceHeader *const seq_params = cm->seq_params;\n  const int bw = mi_size_wide[bsize];\n  const int bh = mi_size_high[bsize];\n  const int x_mis = AOMMIN(bw, cm->mi_params.mi_cols - mi_col);\n  const int y_mis = AOMMIN(bh, cm->mi_params.mi_rows - mi_row);\n  MACROBLOCKD *const xd = &dcb->xd;\n\n#if CONFIG_ACCOUNTING\n  aom_accounting_set_context(&pbi->accounting, mi_col, mi_row);\n#endif\n  set_offsets(cm, xd, bsize, mi_row, mi_col, bw, bh, x_mis, y_mis);\n  xd->mi[0]->partition = partition;\n  av1_read_mode_info(pbi, dcb, r, x_mis, y_mis);\n  if (bsize >= BLOCK_8X8 &&\n      (seq_params->subsampling_x || seq_params->subsampling_y)) {\n    const BLOCK_SIZE uv_subsize =\n        ss_size_lookup[bsize][seq_params->subsampling_x]\n                      [seq_params->subsampling_y];\n    if (uv_subsize == BLOCK_INVALID)\n      aom_internal_error(xd->error_info, AOM_CODEC_CORRUPT_FRAME,\n                         \"Invalid block size.\");\n  }\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "  av1_read_mode_info(pbi, dcb, r, x_mis, y_mis);",
        "crashing_line_number": 376
      },
      {
        "function_name": "parse_decode_block",
        "function_body": "static AOM_INLINE void parse_decode_block(AV1Decoder *const pbi,\n                                          ThreadData *const td, int mi_row,\n                                          int mi_col, aom_reader *r,\n                                          PARTITION_TYPE partition,\n                                          BLOCK_SIZE bsize) {\n  DecoderCodingBlock *const dcb = &td->dcb;\n  MACROBLOCKD *const xd = &dcb->xd;\n  decode_mbmi_block(pbi, dcb, mi_row, mi_col, r, partition, bsize);\n\n  av1_visit_palette(pbi, xd, r, av1_decode_palette_tokens);\n\n  AV1_COMMON *cm = &pbi->common;\n  const int num_planes = av1_num_planes(cm);\n  MB_MODE_INFO *mbmi = xd->mi[0];\n  int inter_block_tx = is_inter_block(mbmi) || is_intrabc_block(mbmi);\n  if (cm->features.tx_mode == TX_MODE_SELECT && block_signals_txsize(bsize) &&\n      !mbmi->skip_txfm && inter_block_tx && !xd->lossless[mbmi->segment_id]) {\n    const TX_SIZE max_tx_size = max_txsize_rect_lookup[bsize];\n    const int bh = tx_size_high_unit[max_tx_size];\n    const int bw = tx_size_wide_unit[max_tx_size];\n    const int width = mi_size_wide[bsize];\n    const int height = mi_size_high[bsize];\n\n    for (int idy = 0; idy < height; idy += bh)\n      for (int idx = 0; idx < width; idx += bw)\n        read_tx_size_vartx(xd, mbmi, max_tx_size, 0, idy, idx, r);\n  } else {\n    mbmi->tx_size = read_tx_size(xd, cm->features.tx_mode, inter_block_tx,\n                                 !mbmi->skip_txfm, r);\n    if (inter_block_tx)\n      memset(mbmi->inter_tx_size, mbmi->tx_size, sizeof(mbmi->inter_tx_size));\n    set_txfm_ctxs(mbmi->tx_size, xd->width, xd->height,\n                  mbmi->skip_txfm && is_inter_block(mbmi), xd);\n  }\n\n  if (cm->delta_q_info.delta_q_present_flag) {\n    for (int i = 0; i < MAX_SEGMENTS; i++) {\n      const int current_qindex =\n          av1_get_qindex(&cm->seg, i, xd->current_base_qindex);\n      const CommonQuantParams *const quant_params = &cm->quant_params;\n      for (int j = 0; j < num_planes; ++j) {\n        const int dc_delta_q = j == 0 ? quant_params->y_dc_delta_q\n                                      : (j == 1 ? quant_params->u_dc_delta_q\n                                                : quant_params->v_dc_delta_q);\n        const int ac_delta_q = j == 0 ? 0\n                                      : (j == 1 ? quant_params->u_ac_delta_q\n                                                : quant_params->v_ac_delta_q);\n        xd->plane[j].seg_dequant_QTX[i][0] = av1_dc_quant_QTX(\n            current_qindex, dc_delta_q, cm->seq_params->bit_depth);\n        xd->plane[j].seg_dequant_QTX[i][1] = av1_ac_quant_QTX(\n            current_qindex, ac_delta_q, cm->seq_params->bit_depth);\n      }\n    }\n  }\n  if (mbmi->skip_txfm) av1_reset_entropy_context(xd, bsize, num_planes);\n\n  decode_token_recon_block(pbi, td, r, bsize);\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "  decode_mbmi_block(pbi, dcb, mi_row, mi_col, r, partition, bsize);",
        "crashing_line_number": 1121
      },
      {
        "function_name": "decode_partition",
        "function_body": "static AOM_INLINE void decode_partition(AV1Decoder *const pbi,\n                                        ThreadData *const td, int mi_row,\n                                        int mi_col, aom_reader *reader,\n                                        BLOCK_SIZE bsize,\n                                        int parse_decode_flag) {\n  assert(bsize < BLOCK_SIZES_ALL);\n  AV1_COMMON *const cm = &pbi->common;\n  DecoderCodingBlock *const dcb = &td->dcb;\n  MACROBLOCKD *const xd = &dcb->xd;\n  const int bw = mi_size_wide[bsize];\n  const int hbs = bw >> 1;\n  PARTITION_TYPE partition;\n  BLOCK_SIZE subsize;\n  const int quarter_step = bw / 4;\n  BLOCK_SIZE bsize2 = get_partition_subsize(bsize, PARTITION_SPLIT);\n  const int has_rows = (mi_row + hbs) < cm->mi_params.mi_rows;\n  const int has_cols = (mi_col + hbs) < cm->mi_params.mi_cols;\n\n  if (mi_row >= cm->mi_params.mi_rows || mi_col >= cm->mi_params.mi_cols)\n    return;\n\n  // parse_decode_flag takes the following values :\n  // 01 - do parse only\n  // 10 - do decode only\n  // 11 - do parse and decode\n  static const block_visitor_fn_t block_visit[4] = { NULL, parse_decode_block,\n                                                     decode_block,\n                                                     parse_decode_block };\n\n  if (parse_decode_flag & 1) {\n    const int num_planes = av1_num_planes(cm);\n    for (int plane = 0; plane < num_planes; ++plane) {\n      int rcol0, rcol1, rrow0, rrow1;\n      if (av1_loop_restoration_corners_in_sb(cm, plane, mi_row, mi_col, bsize,\n                                             &rcol0, &rcol1, &rrow0, &rrow1)) {\n        const int rstride = cm->rst_info[plane].horz_units_per_tile;\n        for (int rrow = rrow0; rrow < rrow1; ++rrow) {\n          for (int rcol = rcol0; rcol < rcol1; ++rcol) {\n            const int runit_idx = rcol + rrow * rstride;\n            loop_restoration_read_sb_coeffs(cm, xd, reader, plane, runit_idx);\n          }\n        }\n      }\n    }\n\n    partition = (bsize < BLOCK_8X8) ? PARTITION_NONE\n                                    : read_partition(xd, mi_row, mi_col, reader,\n                                                     has_rows, has_cols, bsize);\n  } else {\n    partition = get_partition(cm, mi_row, mi_col, bsize);\n  }\n  subsize = get_partition_subsize(bsize, partition);\n  if (subsize == BLOCK_INVALID) {\n    // When an internal error occurs ensure that xd->mi_row is set appropriately\n    // w.r.t. current tile, which is used to signal processing of current row is\n    // done.\n    xd->mi_row = mi_row;\n    aom_internal_error(xd->error_info, AOM_CODEC_CORRUPT_FRAME,\n                       \"Partition is invalid for block size %dx%d\",\n                       block_size_wide[bsize], block_size_high[bsize]);\n  }\n  // Check the bitstream is conformant: if there is subsampling on the\n  // chroma planes, subsize must subsample to a valid block size.\n  const struct macroblockd_plane *const pd_u = &xd->plane[1];\n  if (get_plane_block_size(subsize, pd_u->subsampling_x, pd_u->subsampling_y) ==\n      BLOCK_INVALID) {\n    // When an internal error occurs ensure that xd->mi_row is set appropriately\n    // w.r.t. current tile, which is used to signal processing of current row is\n    // done.\n    xd->mi_row = mi_row;\n    aom_internal_error(xd->error_info, AOM_CODEC_CORRUPT_FRAME,\n                       \"Block size %dx%d invalid with this subsampling mode\",\n                       block_size_wide[subsize], block_size_high[subsize]);\n  }\n\n#define DEC_BLOCK_STX_ARG\n#define DEC_BLOCK_EPT_ARG partition,\n#define DEC_BLOCK(db_r, db_c, db_subsize)                                  \\\n  block_visit[parse_decode_flag](pbi, td, DEC_BLOCK_STX_ARG(db_r), (db_c), \\\n                                 reader, DEC_BLOCK_EPT_ARG(db_subsize))\n#define DEC_PARTITION(db_r, db_c, db_subsize)                        \\\n  decode_partition(pbi, td, DEC_BLOCK_STX_ARG(db_r), (db_c), reader, \\\n                   (db_subsize), parse_decode_flag)\n\n  switch (partition) {\n    case PARTITION_NONE: DEC_BLOCK(mi_row, mi_col, subsize); break;\n    case PARTITION_HORZ:\n      DEC_BLOCK(mi_row, mi_col, subsize);\n      if (has_rows) DEC_BLOCK(mi_row + hbs, mi_col, subsize);\n      break;\n    case PARTITION_VERT:\n      DEC_BLOCK(mi_row, mi_col, subsize);\n      if (has_cols) DEC_BLOCK(mi_row, mi_col + hbs, subsize);\n      break;\n    case PARTITION_SPLIT:\n      DEC_PARTITION(mi_row, mi_col, subsize);\n      DEC_PARTITION(mi_row, mi_col + hbs, subsize);\n      DEC_PARTITION(mi_row + hbs, mi_col, subsize);\n      DEC_PARTITION(mi_row + hbs, mi_col + hbs, subsize);\n      break;\n    case PARTITION_HORZ_A:\n      DEC_BLOCK(mi_row, mi_col, bsize2);\n      DEC_BLOCK(mi_row, mi_col + hbs, bsize2);\n      DEC_BLOCK(mi_row + hbs, mi_col, subsize);\n      break;\n    case PARTITION_HORZ_B:\n      DEC_BLOCK(mi_row, mi_col, subsize);\n      DEC_BLOCK(mi_row + hbs, mi_col, bsize2);\n      DEC_BLOCK(mi_row + hbs, mi_col + hbs, bsize2);\n      break;\n    case PARTITION_VERT_A:\n      DEC_BLOCK(mi_row, mi_col, bsize2);\n      DEC_BLOCK(mi_row + hbs, mi_col, bsize2);\n      DEC_BLOCK(mi_row, mi_col + hbs, subsize);\n      break;\n    case PARTITION_VERT_B:\n      DEC_BLOCK(mi_row, mi_col, subsize);\n      DEC_BLOCK(mi_row, mi_col + hbs, bsize2);\n      DEC_BLOCK(mi_row + hbs, mi_col + hbs, bsize2);\n      break;\n    case PARTITION_HORZ_4:\n      for (int i = 0; i < 4; ++i) {\n        int this_mi_row = mi_row + i * quarter_step;\n        if (i > 0 && this_mi_row >= cm->mi_params.mi_rows) break;\n        DEC_BLOCK(this_mi_row, mi_col, subsize);\n      }\n      break;\n    case PARTITION_VERT_4:\n      for (int i = 0; i < 4; ++i) {\n        int this_mi_col = mi_col + i * quarter_step;\n        if (i > 0 && this_mi_col >= cm->mi_params.mi_cols) break;\n        DEC_BLOCK(mi_row, this_mi_col, subsize);\n      }\n      break;\n    default: assert(0 && \"Invalid partition type\");\n  }\n\n#undef DEC_PARTITION\n#undef DEC_BLOCK\n#undef DEC_BLOCK_EPT_ARG\n#undef DEC_BLOCK_STX_ARG\n\n  if (parse_decode_flag & 1)\n    update_ext_partition_context(xd, mi_row, mi_col, subsize, bsize, partition);\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "    case PARTITION_NONE: DEC_BLOCK(mi_row, mi_col, subsize); break;",
        "crashing_line_number": 1328
      },
      {
        "function_name": "parse_tile_row_mt",
        "function_body": "static AOM_INLINE void parse_tile_row_mt(AV1Decoder *pbi, ThreadData *const td,\n                                         TileDataDec *const tile_data) {\n  AV1_COMMON *const cm = &pbi->common;\n  const int sb_mi_size = mi_size_wide[cm->seq_params->sb_size];\n  const int num_planes = av1_num_planes(cm);\n  const TileInfo *const tile_info = &tile_data->tile_info;\n  int tile_row = tile_info->tile_row;\n  DecoderCodingBlock *const dcb = &td->dcb;\n  MACROBLOCKD *const xd = &dcb->xd;\n\n  av1_zero_above_context(cm, xd, tile_info->mi_col_start, tile_info->mi_col_end,\n                         tile_row);\n  av1_reset_loop_filter_delta(xd, num_planes);\n  av1_reset_loop_restoration(xd, num_planes);\n\n  for (int mi_row = tile_info->mi_row_start; mi_row < tile_info->mi_row_end;\n       mi_row += cm->seq_params->mib_size) {\n    av1_zero_left_context(xd);\n\n    for (int mi_col = tile_info->mi_col_start; mi_col < tile_info->mi_col_end;\n         mi_col += cm->seq_params->mib_size) {\n      set_cb_buffer(pbi, dcb, pbi->cb_buffer_base, num_planes, mi_row, mi_col);\n\n      // Bit-stream parsing of the superblock\n      decode_partition(pbi, td, mi_row, mi_col, td->bit_reader,\n                       cm->seq_params->sb_size, 0x1);\n\n      if (aom_reader_has_overflowed(td->bit_reader)) {\n        aom_merge_corrupted_flag(&dcb->corrupted, 1);\n        return;\n      }\n    }\n    signal_parse_sb_row_done(pbi, tile_data, sb_mi_size);\n  }\n\n  int corrupted =\n      (check_trailing_bits_after_symbol_coder(td->bit_reader)) ? 1 : 0;\n  aom_merge_corrupted_flag(&dcb->corrupted, corrupted);\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "      decode_partition(pbi, td, mi_row, mi_col, td->bit_reader,",
        "crashing_line_number": 3143
      },
      {
        "function_name": "row_mt_worker_hook",
        "function_body": "static int row_mt_worker_hook(void *arg1, void *arg2) {\n  DecWorkerData *const thread_data = (DecWorkerData *)arg1;\n  AV1Decoder *const pbi = (AV1Decoder *)arg2;\n  ThreadData *const td = thread_data->td;\n  uint8_t allow_update_cdf;\n  AV1DecRowMTInfo *frame_row_mt_info = &pbi->frame_row_mt_info;\n  td->dcb.corrupted = 0;\n\n  // The jmp_buf is valid only for the duration of the function that calls\n  // setjmp(). Therefore, this function must reset the 'setjmp' field to 0\n  // before it returns.\n  if (setjmp(thread_data->error_info.jmp)) {\n    thread_data->error_info.setjmp = 0;\n    thread_data->td->dcb.corrupted = 1;\n#if CONFIG_MULTITHREAD\n    pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n    frame_row_mt_info->row_mt_exit = 1;\n\n    // If any SB row (erroneous row) processed by a thread encounters an\n    // internal error, there is a need to indicate other threads that decoding\n    // of the erroneous row is complete. This ensures that other threads which\n    // wait upon the completion of SB's present in erroneous row are not waiting\n    // indefinitely.\n    signal_decoding_done_for_erroneous_row(pbi, &thread_data->td->dcb.xd);\n\n#if CONFIG_MULTITHREAD\n    pthread_cond_broadcast(pbi->row_mt_cond_);\n    pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n    return 0;\n  }\n  thread_data->error_info.setjmp = 1;\n\n  AV1_COMMON *cm = &pbi->common;\n  allow_update_cdf = cm->tiles.large_scale ? 0 : 1;\n  allow_update_cdf = allow_update_cdf && !cm->features.disable_cdf_update;\n\n  set_decode_func_pointers(td, 0x1);\n\n  assert(cm->tiles.cols > 0);\n  while (!td->dcb.corrupted) {\n    TileJobsDec *cur_job_info = get_dec_job_info(&pbi->tile_mt_info);\n\n    if (cur_job_info != NULL) {\n      const TileBufferDec *const tile_buffer = cur_job_info->tile_buffer;\n      TileDataDec *const tile_data = cur_job_info->tile_data;\n      tile_worker_hook_init(pbi, thread_data, tile_buffer, tile_data,\n                            allow_update_cdf);\n#if CONFIG_MULTITHREAD\n      pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n      tile_data->dec_row_mt_sync.num_threads_working++;\n#if CONFIG_MULTITHREAD\n      pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n      // decode tile\n      parse_tile_row_mt(pbi, td, tile_data);\n#if CONFIG_MULTITHREAD\n      pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n      tile_data->dec_row_mt_sync.num_threads_working--;\n#if CONFIG_MULTITHREAD\n      pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n    } else {\n      break;\n    }\n  }\n\n  if (td->dcb.corrupted) {\n    thread_data->error_info.setjmp = 0;\n#if CONFIG_MULTITHREAD\n    pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n    frame_row_mt_info->row_mt_exit = 1;\n#if CONFIG_MULTITHREAD\n    pthread_cond_broadcast(pbi->row_mt_cond_);\n    pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n    return 0;\n  }\n\n  set_decode_func_pointers(td, 0x2);\n\n  while (1) {\n    AV1DecRowMTJobInfo next_job_info;\n    int end_of_frame = 0;\n\n#if CONFIG_MULTITHREAD\n    pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n    while (!get_next_job_info(pbi, &next_job_info, &end_of_frame)) {\n#if CONFIG_MULTITHREAD\n      pthread_cond_wait(pbi->row_mt_cond_, pbi->row_mt_mutex_);\n#endif\n    }\n#if CONFIG_MULTITHREAD\n    pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n\n    if (end_of_frame) break;\n\n    int tile_row = next_job_info.tile_row;\n    int tile_col = next_job_info.tile_col;\n    int mi_row = next_job_info.mi_row;\n\n    TileDataDec *tile_data =\n        pbi->tile_data + tile_row * cm->tiles.cols + tile_col;\n    AV1DecRowMTSync *dec_row_mt_sync = &tile_data->dec_row_mt_sync;\n\n    av1_tile_init(&td->dcb.xd.tile, cm, tile_row, tile_col);\n    av1_init_macroblockd(cm, &td->dcb.xd);\n    td->dcb.xd.error_info = &thread_data->error_info;\n\n    decode_tile_sb_row(pbi, td, &tile_data->tile_info, mi_row);\n\n#if CONFIG_MULTITHREAD\n    pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n    dec_row_mt_sync->num_threads_working--;\n#if CONFIG_MULTITHREAD\n    pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n  }\n  thread_data->error_info.setjmp = 0;\n  return !td->dcb.corrupted;\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "      parse_tile_row_mt(pbi, td, tile_data);",
        "crashing_line_number": 3216
      },
      {
        "function_name": "execute",
        "function_body": "static void execute(AVxWorker *const worker) {\n  if (worker->hook != NULL) {\n    worker->had_error |= !worker->hook(worker->data1, worker->data2);\n  }\n}",
        "file_path": "/src/aom/aom_util/aom_thread.c",
        "crashing_line": "    worker->had_error |= !worker->hook(worker->data1, worker->data2);",
        "crashing_line_number": 163
      },
      {
        "function_name": "decode_tiles_row_mt",
        "function_body": "static AOM_INLINE void decode_tile(AV1Decoder *pbi, ThreadData *const td,\n                                   int tile_row, int tile_col) {\n  TileInfo tile_info;\n\n  AV1_COMMON *const cm = &pbi->common;\n  const int num_planes = av1_num_planes(cm);\n\n  av1_tile_set_row(&tile_info, cm, tile_row);\n  av1_tile_set_col(&tile_info, cm, tile_col);\n  DecoderCodingBlock *const dcb = &td->dcb;\n  MACROBLOCKD *const xd = &dcb->xd;\n\n  av1_zero_above_context(cm, xd, tile_info.mi_col_start, tile_info.mi_col_end,\n                         tile_row);\n  av1_reset_loop_filter_delta(xd, num_planes);\n  av1_reset_loop_restoration(xd, num_planes);\n\n  for (int mi_row = tile_info.mi_row_start; mi_row < tile_info.mi_row_end;\n       mi_row += cm->seq_params->mib_size) {\n    av1_zero_left_context(xd);\n\n    for (int mi_col = tile_info.mi_col_start; mi_col < tile_info.mi_col_end;\n         mi_col += cm->seq_params->mib_size) {\n      set_cb_buffer(pbi, dcb, &td->cb_buffer_base, num_planes, 0, 0);\n\n      // Bit-stream parsing and decoding of the superblock\n      decode_partition(pbi, td, mi_row, mi_col, td->bit_reader,\n                       cm->seq_params->sb_size, 0x3);\n\n      if (aom_reader_has_overflowed(td->bit_reader)) {\n        aom_merge_corrupted_flag(&dcb->corrupted, 1);\n        return;\n      }\n    }\n  }\n\n  int corrupted =\n      (check_trailing_bits_after_symbol_coder(td->bit_reader)) ? 1 : 0;\n  aom_merge_corrupted_flag(&dcb->corrupted, corrupted);\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "",
        "crashing_line_number": 3819
      },
      {
        "function_name": "av1_decode_tg_tiles_and_wrapup",
        "function_body": "void av1_decode_tg_tiles_and_wrapup(AV1Decoder *pbi, const uint8_t *data,\n                                    const uint8_t *data_end,\n                                    const uint8_t **p_data_end, int start_tile,\n                                    int end_tile, int initialize_flag) {\n  AV1_COMMON *const cm = &pbi->common;\n  CommonTileParams *const tiles = &cm->tiles;\n  MACROBLOCKD *const xd = &pbi->dcb.xd;\n  const int tile_count_tg = end_tile - start_tile + 1;\n\n  if (initialize_flag) setup_frame_info(pbi);\n  const int num_planes = av1_num_planes(cm);\n\n  if (pbi->max_threads > 1 && !(tiles->large_scale && !pbi->ext_tile_debug) &&\n      pbi->row_mt)\n    *p_data_end =\n        decode_tiles_row_mt(pbi, data, data_end, start_tile, end_tile);\n  else if (pbi->max_threads > 1 && tile_count_tg > 1 &&\n           !(tiles->large_scale && !pbi->ext_tile_debug))\n    *p_data_end = decode_tiles_mt(pbi, data, data_end, start_tile, end_tile);\n  else\n    *p_data_end = decode_tiles(pbi, data, data_end, start_tile, end_tile);\n\n  // If the bit stream is monochrome, set the U and V buffers to a constant.\n  if (num_planes < 3) {\n    set_planes_to_neutral_grey(cm->seq_params, xd->cur_buf, 1);\n  }\n\n  if (end_tile != tiles->rows * tiles->cols - 1) {\n    return;\n  }\n\n  av1_alloc_cdef_buffers(cm, &pbi->cdef_worker, &pbi->cdef_sync,\n                         pbi->num_workers, 1);\n  av1_alloc_cdef_sync(cm, &pbi->cdef_sync, pbi->num_workers);\n\n  if (!cm->features.allow_intrabc && !tiles->single_tile_decoding) {\n    if (cm->lf.filter_level[0] || cm->lf.filter_level[1]) {\n      av1_loop_filter_frame_mt(&cm->cur_frame->buf, cm, &pbi->dcb.xd, 0,\n                               num_planes, 0, pbi->tile_workers,\n                               pbi->num_workers, &pbi->lf_row_sync, 0);\n    }\n\n    const int do_cdef =\n        !pbi->skip_loop_filter && !cm->features.coded_lossless &&\n        (cm->cdef_info.cdef_bits || cm->cdef_info.cdef_strengths[0] ||\n         cm->cdef_info.cdef_uv_strengths[0]);\n    const int do_superres = av1_superres_scaled(cm);\n    const int optimized_loop_restoration = !do_cdef && !do_superres;\n    const int do_loop_restoration =\n        cm->rst_info[0].frame_restoration_type != RESTORE_NONE ||\n        cm->rst_info[1].frame_restoration_type != RESTORE_NONE ||\n        cm->rst_info[2].frame_restoration_type != RESTORE_NONE;\n    if (!optimized_loop_restoration) {\n      if (do_loop_restoration)\n        av1_loop_restoration_save_boundary_lines(&pbi->common.cur_frame->buf,\n                                                 cm, 0);\n\n      if (do_cdef) {\n        if (pbi->num_workers > 1) {\n          av1_cdef_frame_mt(cm, &pbi->dcb.xd, pbi->cdef_worker,\n                            pbi->tile_workers, &pbi->cdef_sync,\n                            pbi->num_workers, av1_cdef_init_fb_row_mt);\n        } else {\n          av1_cdef_frame(&pbi->common.cur_frame->buf, cm, &pbi->dcb.xd,\n                         av1_cdef_init_fb_row);\n        }\n      }\n\n      superres_post_decode(pbi);\n\n      if (do_loop_restoration) {\n        av1_loop_restoration_save_boundary_lines(&pbi->common.cur_frame->buf,\n                                                 cm, 1);\n        if (pbi->num_workers > 1) {\n          av1_loop_restoration_filter_frame_mt(\n              (YV12_BUFFER_CONFIG *)xd->cur_buf, cm, optimized_loop_restoration,\n              pbi->tile_workers, pbi->num_workers, &pbi->lr_row_sync,\n              &pbi->lr_ctxt);\n        } else {\n          av1_loop_restoration_filter_frame((YV12_BUFFER_CONFIG *)xd->cur_buf,\n                                            cm, optimized_loop_restoration,\n                                            &pbi->lr_ctxt);\n        }\n      }\n    } else {\n      // In no cdef and no superres case. Provide an optimized version of\n      // loop_restoration_filter.\n      if (do_loop_restoration) {\n        if (pbi->num_workers > 1) {\n          av1_loop_restoration_filter_frame_mt(\n              (YV12_BUFFER_CONFIG *)xd->cur_buf, cm, optimized_loop_restoration,\n              pbi->tile_workers, pbi->num_workers, &pbi->lr_row_sync,\n              &pbi->lr_ctxt);\n        } else {\n          av1_loop_restoration_filter_frame((YV12_BUFFER_CONFIG *)xd->cur_buf,\n                                            cm, optimized_loop_restoration,\n                                            &pbi->lr_ctxt);\n        }\n      }\n    }\n  }\n\n  if (!pbi->dcb.corrupted) {\n    if (cm->features.refresh_frame_context == REFRESH_FRAME_CONTEXT_BACKWARD) {\n      assert(pbi->context_update_tile_id < pbi->allocated_tiles);\n      *cm->fc = pbi->tile_data[pbi->context_update_tile_id].tctx;\n      av1_reset_cdf_symbol_counters(cm->fc);\n    }\n  } else {\n    aom_internal_error(&pbi->error, AOM_CODEC_CORRUPT_FRAME,\n                       \"Decode failed. Frame data is corrupted.\");\n  }\n\n#if CONFIG_INSPECTION\n  if (pbi->inspect_cb != NULL) {\n    (*pbi->inspect_cb)(pbi, pbi->inspect_ctx);\n  }\n#endif\n\n  // Non frame parallel update frame context here.\n  if (!tiles->large_scale) {\n    cm->cur_frame->frame_context = *cm->fc;\n  }\n\n  if (cm->show_frame && !cm->seq_params->order_hint_info.enable_order_hint) {\n    ++cm->current_frame.frame_number;\n  }\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "        decode_tiles_row_mt(pbi, data, data_end, start_tile, end_tile);",
        "crashing_line_number": 5246
      },
      {
        "function_name": "read_one_tile_group_obu",
        "function_body": "static uint32_t read_one_tile_group_obu(\n    AV1Decoder *pbi, struct aom_read_bit_buffer *rb, int is_first_tg,\n    const uint8_t *data, const uint8_t *data_end, const uint8_t **p_data_end,\n    int *is_last_tg, int tile_start_implicit) {\n  AV1_COMMON *const cm = &pbi->common;\n  int start_tile, end_tile;\n  int32_t header_size, tg_payload_size;\n\n  assert((rb->bit_offset & 7) == 0);\n  assert(rb->bit_buffer + aom_rb_bytes_read(rb) == data);\n\n  header_size = read_tile_group_header(pbi, rb, &start_tile, &end_tile,\n                                       tile_start_implicit);\n  if (header_size == -1 || byte_alignment(cm, rb)) return 0;\n  data += header_size;\n  av1_decode_tg_tiles_and_wrapup(pbi, data, data_end, p_data_end, start_tile,\n                                 end_tile, is_first_tg);\n\n  tg_payload_size = (uint32_t)(*p_data_end - data);\n\n  *is_last_tg = end_tile == cm->tiles.rows * cm->tiles.cols - 1;\n  return header_size + tg_payload_size;\n}",
        "file_path": "/src/aom/av1/decoder/obu.c",
        "crashing_line": "  av1_decode_tg_tiles_and_wrapup(pbi, data, data_end, p_data_end, start_tile,",
        "crashing_line_number": 361
      },
      {
        "function_name": "aom_decode_frame_from_obus",
        "function_body": "int aom_decode_frame_from_obus(struct AV1Decoder *pbi, const uint8_t *data,\n                               const uint8_t *data_end,\n                               const uint8_t **p_data_end) {\n  AV1_COMMON *const cm = &pbi->common;\n  int frame_decoding_finished = 0;\n  int is_first_tg_obu_received = 1;\n  // Whenever pbi->seen_frame_header is set to 1, frame_header is set to the\n  // beginning of the frame_header_obu and frame_header_size is set to its\n  // size. This allows us to check if a redundant frame_header_obu is a copy\n  // of the previous frame_header_obu.\n  //\n  // Initialize frame_header to a dummy nonnull pointer, otherwise the Clang\n  // Static Analyzer in clang 7.0.1 will falsely warn that a null pointer is\n  // passed as an argument to a 'nonnull' parameter of memcmp(). The initial\n  // value will not be used.\n  const uint8_t *frame_header = data;\n  uint32_t frame_header_size = 0;\n  ObuHeader obu_header;\n  memset(&obu_header, 0, sizeof(obu_header));\n  pbi->seen_frame_header = 0;\n  pbi->next_start_tile = 0;\n  pbi->num_tile_groups = 0;\n\n  if (data_end < data) {\n    pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n    return -1;\n  }\n\n  // Reset pbi->camera_frame_header_ready to 0 if cm->tiles.large_scale = 0.\n  if (!cm->tiles.large_scale) pbi->camera_frame_header_ready = 0;\n\n  // decode frame as a series of OBUs\n  while (!frame_decoding_finished && pbi->error.error_code == AOM_CODEC_OK) {\n    struct aom_read_bit_buffer rb;\n    size_t payload_size = 0;\n    size_t decoded_payload_size = 0;\n    size_t obu_payload_offset = 0;\n    size_t bytes_read = 0;\n    const size_t bytes_available = data_end - data;\n\n    if (bytes_available == 0 && !pbi->seen_frame_header) {\n      *p_data_end = data;\n      pbi->error.error_code = AOM_CODEC_OK;\n      break;\n    }\n\n    aom_codec_err_t status =\n        aom_read_obu_header_and_size(data, bytes_available, pbi->is_annexb,\n                                     &obu_header, &payload_size, &bytes_read);\n\n    if (status != AOM_CODEC_OK) {\n      pbi->error.error_code = status;\n      return -1;\n    }\n\n    // Record obu size header information.\n    pbi->obu_size_hdr.data = data + obu_header.size;\n    pbi->obu_size_hdr.size = bytes_read - obu_header.size;\n\n    // Note: aom_read_obu_header_and_size() takes care of checking that this\n    // doesn't cause 'data' to advance past 'data_end'.\n    data += bytes_read;\n\n    if ((size_t)(data_end - data) < payload_size) {\n      pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n      return -1;\n    }\n\n    cm->temporal_layer_id = obu_header.temporal_layer_id;\n    cm->spatial_layer_id = obu_header.spatial_layer_id;\n\n    if (obu_header.type != OBU_TEMPORAL_DELIMITER &&\n        obu_header.type != OBU_SEQUENCE_HEADER) {\n      // don't decode obu if it's not in current operating mode\n      if (!is_obu_in_current_operating_point(pbi, &obu_header)) {\n        data += payload_size;\n        continue;\n      }\n    }\n\n    av1_init_read_bit_buffer(pbi, &rb, data, data + payload_size);\n\n    switch (obu_header.type) {\n      case OBU_TEMPORAL_DELIMITER:\n        decoded_payload_size = read_temporal_delimiter_obu();\n        if (pbi->seen_frame_header) {\n          // A new temporal unit has started, but the frame in the previous\n          // temporal unit is incomplete.\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n        break;\n      case OBU_SEQUENCE_HEADER:\n        decoded_payload_size = read_sequence_header_obu(pbi, &rb);\n        if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n        // The sequence header should not change in the middle of a frame.\n        if (pbi->sequence_header_changed && pbi->seen_frame_header) {\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n        break;\n      case OBU_FRAME_HEADER:\n      case OBU_REDUNDANT_FRAME_HEADER:\n      case OBU_FRAME:\n        if (obu_header.type == OBU_REDUNDANT_FRAME_HEADER) {\n          if (!pbi->seen_frame_header) {\n            pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n            return -1;\n          }\n        } else {\n          // OBU_FRAME_HEADER or OBU_FRAME.\n          if (pbi->seen_frame_header) {\n            pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n            return -1;\n          }\n        }\n        // Only decode first frame header received\n        if (!pbi->seen_frame_header ||\n            (cm->tiles.large_scale && !pbi->camera_frame_header_ready)) {\n          frame_header_size = read_frame_header_obu(\n              pbi, &rb, data, p_data_end, obu_header.type != OBU_FRAME);\n          frame_header = data;\n          pbi->seen_frame_header = 1;\n          if (!pbi->ext_tile_debug && cm->tiles.large_scale)\n            pbi->camera_frame_header_ready = 1;\n        } else {\n          // Verify that the frame_header_obu is identical to the original\n          // frame_header_obu.\n          if (frame_header_size > payload_size ||\n              memcmp(data, frame_header, frame_header_size) != 0) {\n            pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n            return -1;\n          }\n          assert(rb.bit_offset == 0);\n          rb.bit_offset = 8 * frame_header_size;\n        }\n\n        decoded_payload_size = frame_header_size;\n        pbi->frame_header_size = frame_header_size;\n        cm->cur_frame->temporal_id = obu_header.temporal_layer_id;\n        cm->cur_frame->spatial_id = obu_header.spatial_layer_id;\n\n        if (cm->show_existing_frame) {\n          if (obu_header.type == OBU_FRAME) {\n            pbi->error.error_code = AOM_CODEC_UNSUP_BITSTREAM;\n            return -1;\n          }\n          frame_decoding_finished = 1;\n          pbi->seen_frame_header = 0;\n\n          if (cm->show_frame &&\n              !cm->seq_params->order_hint_info.enable_order_hint) {\n            ++cm->current_frame.frame_number;\n          }\n          break;\n        }\n\n        // In large scale tile coding, decode the common camera frame header\n        // before any tile list OBU.\n        if (!pbi->ext_tile_debug && pbi->camera_frame_header_ready) {\n          frame_decoding_finished = 1;\n          // Skip the rest of the frame data.\n          decoded_payload_size = payload_size;\n          // Update data_end.\n          *p_data_end = data_end;\n          break;\n        }\n\n        if (obu_header.type != OBU_FRAME) break;\n        obu_payload_offset = frame_header_size;\n        // Byte align the reader before reading the tile group.\n        // byte_alignment() has set pbi->error.error_code if it returns -1.\n        if (byte_alignment(cm, &rb)) return -1;\n        AOM_FALLTHROUGH_INTENDED;  // fall through to read tile group.\n      case OBU_TILE_GROUP:\n        if (!pbi->seen_frame_header) {\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n        if (obu_payload_offset > payload_size) {\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n        decoded_payload_size += read_one_tile_group_obu(\n            pbi, &rb, is_first_tg_obu_received, data + obu_payload_offset,\n            data + payload_size, p_data_end, &frame_decoding_finished,\n            obu_header.type == OBU_FRAME);\n        if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n        is_first_tg_obu_received = 0;\n        if (frame_decoding_finished) {\n          pbi->seen_frame_header = 0;\n          pbi->next_start_tile = 0;\n        }\n        pbi->num_tile_groups++;\n        break;\n      case OBU_METADATA:\n        decoded_payload_size = read_metadata(pbi, data, payload_size);\n        if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n        break;\n      case OBU_TILE_LIST:\n        if (CONFIG_NORMAL_TILE_MODE) {\n          pbi->error.error_code = AOM_CODEC_UNSUP_BITSTREAM;\n          return -1;\n        }\n\n        // This OBU type is purely for the large scale tile coding mode.\n        // The common camera frame header has to be already decoded.\n        if (!pbi->camera_frame_header_ready) {\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n\n        cm->tiles.large_scale = 1;\n        av1_set_single_tile_decoding_mode(cm);\n        decoded_payload_size =\n            read_and_decode_one_tile_list(pbi, &rb, data, data + payload_size,\n                                          p_data_end, &frame_decoding_finished);\n        if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n        break;\n      case OBU_PADDING:\n        decoded_payload_size = read_padding(cm, data, payload_size);\n        if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n        break;\n      default:\n        // Skip unrecognized OBUs\n        if (payload_size > 0 &&\n            get_last_nonzero_byte(data, payload_size) == 0) {\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n        decoded_payload_size = payload_size;\n        break;\n    }\n\n    // Check that the signalled OBU size matches the actual amount of data read\n    if (decoded_payload_size > payload_size) {\n      pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n      return -1;\n    }\n\n    // If there are extra padding bytes, they should all be zero\n    while (decoded_payload_size < payload_size) {\n      uint8_t padding_byte = data[decoded_payload_size++];\n      if (padding_byte != 0) {\n        pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n        return -1;\n      }\n    }\n\n    data += payload_size;\n  }\n\n  if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n  return frame_decoding_finished;\n}",
        "file_path": "/src/aom/av1/decoder/obu.c",
        "crashing_line": "        decoded_payload_size += read_one_tile_group_obu(",
        "crashing_line_number": 1030
      },
      {
        "function_name": "av1_receive_compressed_data",
        "function_body": "int av1_receive_compressed_data(AV1Decoder *pbi, size_t size,\n                                const uint8_t **psource) {\n  AV1_COMMON *volatile const cm = &pbi->common;\n  const uint8_t *source = *psource;\n  pbi->error.error_code = AOM_CODEC_OK;\n  pbi->error.has_detail = 0;\n\n  if (size == 0) {\n    // This is used to signal that we are missing frames.\n    // We do not know if the missing frame(s) was supposed to update\n    // any of the reference buffers, but we act conservative and\n    // mark only the last buffer as corrupted.\n    //\n    // TODO(jkoleszar): Error concealment is undefined and non-normative\n    // at this point, but if it becomes so, [0] may not always be the correct\n    // thing to do here.\n    RefCntBuffer *ref_buf = get_ref_frame_buf(cm, LAST_FRAME);\n    if (ref_buf != NULL) ref_buf->buf.corrupted = 1;\n  }\n\n  if (assign_cur_frame_new_fb(cm) == NULL) {\n    pbi->error.error_code = AOM_CODEC_MEM_ERROR;\n    return 1;\n  }\n\n  // The jmp_buf is valid only for the duration of the function that calls\n  // setjmp(). Therefore, this function must reset the 'setjmp' field to 0\n  // before it returns.\n  if (setjmp(pbi->error.jmp)) {\n    const AVxWorkerInterface *const winterface = aom_get_worker_interface();\n    int i;\n\n    pbi->error.setjmp = 0;\n\n    // Synchronize all threads immediately as a subsequent decode call may\n    // cause a resize invalidating some allocations.\n    winterface->sync(&pbi->lf_worker);\n    for (i = 0; i < pbi->num_workers; ++i) {\n      winterface->sync(&pbi->tile_workers[i]);\n    }\n\n    release_current_frame(pbi);\n    return -1;\n  }\n\n  pbi->error.setjmp = 1;\n\n  int frame_decoded =\n      aom_decode_frame_from_obus(pbi, source, source + size, psource);\n\n  if (frame_decoded < 0) {\n    assert(pbi->error.error_code != AOM_CODEC_OK);\n    release_current_frame(pbi);\n    pbi->error.setjmp = 0;\n    return 1;\n  }\n\n#if TXCOEFF_TIMER\n  cm->cum_txcoeff_timer += cm->txcoeff_timer;\n  fprintf(stderr,\n          \"txb coeff block number: %d, frame time: %ld, cum time %ld in us\\n\",\n          cm->txb_count, cm->txcoeff_timer, cm->cum_txcoeff_timer);\n  cm->txcoeff_timer = 0;\n  cm->txb_count = 0;\n#endif\n\n  // Note: At this point, this function holds a reference to cm->cur_frame\n  // in the buffer pool. This reference is consumed by update_frame_buffers().\n  update_frame_buffers(pbi, frame_decoded);\n\n  if (frame_decoded) {\n    pbi->decoding_first_frame = 0;\n  }\n\n  if (pbi->error.error_code != AOM_CODEC_OK) {\n    pbi->error.setjmp = 0;\n    return 1;\n  }\n\n  if (!cm->show_existing_frame) {\n    if (cm->seg.enabled) {\n      if (cm->prev_frame &&\n          (cm->mi_params.mi_rows == cm->prev_frame->mi_rows) &&\n          (cm->mi_params.mi_cols == cm->prev_frame->mi_cols)) {\n        cm->last_frame_seg_map = cm->prev_frame->seg_map;\n      } else {\n        cm->last_frame_seg_map = NULL;\n      }\n    }\n  }\n\n  // Update progress in frame parallel decode.\n  pbi->error.setjmp = 0;\n\n  return 0;\n}",
        "file_path": "/src/aom/av1/decoder/decoder.c",
        "crashing_line": "      aom_decode_frame_from_obus(pbi, source, source + size, psource);",
        "crashing_line_number": 469
      },
      {
        "function_name": "frame_worker_hook",
        "function_body": "static int frame_worker_hook(void *arg1, void *arg2) {\n  FrameWorkerData *const frame_worker_data = (FrameWorkerData *)arg1;\n  const uint8_t *data = frame_worker_data->data;\n  (void)arg2;\n\n  int result = av1_receive_compressed_data(frame_worker_data->pbi,\n                                           frame_worker_data->data_size, &data);\n  frame_worker_data->data_end = data;\n\n  if (result != 0) {\n    // Check decode result in serial decode.\n    frame_worker_data->pbi->need_resync = 1;\n  }\n  return !result;\n}",
        "file_path": "/src/aom/av1/av1_dx_iface.c",
        "crashing_line": "  int result = av1_receive_compressed_data(frame_worker_data->pbi,",
        "crashing_line_number": 409
      },
      {
        "function_name": "execute",
        "function_body": "static void execute(AVxWorker *const worker) {\n  if (worker->hook != NULL) {\n    worker->had_error |= !worker->hook(worker->data1, worker->data2);\n  }\n}",
        "file_path": "/src/aom/aom_util/aom_thread.c",
        "crashing_line": "    worker->had_error |= !worker->hook(worker->data1, worker->data2);",
        "crashing_line_number": 163
      },
      {
        "function_name": "decode_one",
        "function_body": "static aom_codec_err_t decode_one(aom_codec_alg_priv_t *ctx,\n                                  const uint8_t **data, size_t data_sz,\n                                  void *user_priv) {\n  const AVxWorkerInterface *const winterface = aom_get_worker_interface();\n\n  // Determine the stream parameters. Note that we rely on peek_si to\n  // validate that we have a buffer that does not wrap around the top\n  // of the heap.\n  if (!ctx->si.h) {\n    int is_intra_only = 0;\n    ctx->si.is_annexb = ctx->is_annexb;\n    const aom_codec_err_t res =\n        decoder_peek_si_internal(*data, data_sz, &ctx->si, &is_intra_only);\n    if (res != AOM_CODEC_OK) return res;\n\n    if (!ctx->si.is_kf && !is_intra_only) return AOM_CODEC_ERROR;\n  }\n\n  AVxWorker *const worker = ctx->frame_worker;\n  FrameWorkerData *const frame_worker_data = (FrameWorkerData *)worker->data1;\n  frame_worker_data->data = *data;\n  frame_worker_data->data_size = data_sz;\n  frame_worker_data->user_priv = user_priv;\n  frame_worker_data->received_frame = 1;\n\n  frame_worker_data->pbi->common.tiles.large_scale = ctx->tile_mode;\n  frame_worker_data->pbi->dec_tile_row = ctx->decode_tile_row;\n  frame_worker_data->pbi->dec_tile_col = ctx->decode_tile_col;\n  frame_worker_data->pbi->ext_tile_debug = ctx->ext_tile_debug;\n  frame_worker_data->pbi->row_mt = ctx->row_mt;\n  frame_worker_data->pbi->ext_refs = ctx->ext_refs;\n\n  frame_worker_data->pbi->is_annexb = ctx->is_annexb;\n\n  worker->had_error = 0;\n  winterface->execute(worker);\n\n  // Update data pointer after decode.\n  *data = frame_worker_data->data_end;\n\n  if (worker->had_error)\n    return update_error_state(ctx, &frame_worker_data->pbi->error);\n\n  check_resync(ctx, frame_worker_data->pbi);\n\n  return AOM_CODEC_OK;\n}",
        "file_path": "/src/aom/av1/av1_dx_iface.c",
        "crashing_line": "  winterface->execute(worker);",
        "crashing_line_number": 526
      },
      {
        "function_name": "decoder_decode",
        "function_body": "static aom_codec_err_t decoder_decode(aom_codec_alg_priv_t *ctx,\n                                      const uint8_t *data, size_t data_sz,\n                                      void *user_priv) {\n  aom_codec_err_t res = AOM_CODEC_OK;\n\n#if CONFIG_INSPECTION\n  if (user_priv != 0) {\n    return decoder_inspect(ctx, data, data_sz, user_priv);\n  }\n#endif\n\n  release_pending_output_frames(ctx);\n\n  /* Sanity checks */\n  /* NULL data ptr allowed if data_sz is 0 too */\n  if (data == NULL && data_sz == 0) {\n    ctx->flushed = 1;\n    return AOM_CODEC_OK;\n  }\n  if (data == NULL || data_sz == 0) return AOM_CODEC_INVALID_PARAM;\n\n  // Reset flushed when receiving a valid frame.\n  ctx->flushed = 0;\n\n  // Initialize the decoder worker on the first frame.\n  if (ctx->frame_worker == NULL) {\n    res = init_decoder(ctx);\n    if (res != AOM_CODEC_OK) return res;\n  }\n\n  const uint8_t *data_start = data;\n  const uint8_t *data_end = data + data_sz;\n\n  if (ctx->is_annexb) {\n    // read the size of this temporal unit\n    size_t length_of_size;\n    uint64_t temporal_unit_size;\n    if (aom_uleb_decode(data_start, data_sz, &temporal_unit_size,\n                        &length_of_size) != 0) {\n      return AOM_CODEC_CORRUPT_FRAME;\n    }\n    data_start += length_of_size;\n    if (temporal_unit_size > (size_t)(data_end - data_start))\n      return AOM_CODEC_CORRUPT_FRAME;\n    data_end = data_start + temporal_unit_size;\n  }\n\n  // Decode in serial mode.\n  while (data_start < data_end) {\n    uint64_t frame_size;\n    if (ctx->is_annexb) {\n      // read the size of this frame unit\n      size_t length_of_size;\n      if (aom_uleb_decode(data_start, (size_t)(data_end - data_start),\n                          &frame_size, &length_of_size) != 0) {\n        return AOM_CODEC_CORRUPT_FRAME;\n      }\n      data_start += length_of_size;\n      if (frame_size > (size_t)(data_end - data_start))\n        return AOM_CODEC_CORRUPT_FRAME;\n    } else {\n      frame_size = (uint64_t)(data_end - data_start);\n    }\n\n    res = decode_one(ctx, &data_start, (size_t)frame_size, user_priv);\n    if (res != AOM_CODEC_OK) return res;\n\n    // Allow extra zero bytes after the frame end\n    while (data_start < data_end) {\n      const uint8_t marker = data_start[0];\n      if (marker) break;\n      ++data_start;\n    }\n  }\n\n  return res;\n}",
        "file_path": "/src/aom/av1/av1_dx_iface.c",
        "crashing_line": "    res = decode_one(ctx, &data_start, (size_t)frame_size, user_priv);",
        "crashing_line_number": 713
      },
      {
        "function_name": "aom_codec_decode",
        "function_body": "aom_codec_err_t aom_codec_decode(aom_codec_ctx_t *ctx, const uint8_t *data,\n                                 size_t data_sz, void *user_priv) {\n  aom_codec_err_t res;\n\n  if (!ctx)\n    res = AOM_CODEC_INVALID_PARAM;\n  else if (!ctx->iface || !ctx->priv)\n    res = AOM_CODEC_ERROR;\n  else {\n    res = ctx->iface->dec.decode(get_alg_priv(ctx), data, data_sz, user_priv);\n  }\n\n  return SAVE_STATUS(ctx, res);\n}",
        "file_path": "/src/aom/aom/src/aom_decoder.c",
        "crashing_line": "    res = ctx->iface->dec.decode(get_alg_priv(ctx), data, data_sz, user_priv);",
        "crashing_line_number": 103
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "ARROW_EXPORT\nStatus ValidateArray(const Array& array) {\n  // First check the array layout conforms to the spec\n  const DataType& type = *array.type();\n  const auto layout = type.layout();\n  const ArrayData& data = *array.data();\n\n  if (array.length() < 0) {\n    return Status::Invalid(\"Array length is negative\");\n  }\n\n  if (array.null_count() > array.length()) {\n    return Status::Invalid(\"Null count exceeds array length\");\n  }\n\n  if (data.buffers.size() != layout.bit_widths.size()) {\n    return Status::Invalid(\"Expected \", layout.bit_widths.size(),\n                           \" buffers in array \"\n                           \"of type \",\n                           type.ToString(), \", got \", data.buffers.size());\n  }\n  if (type.id() != Type::EXTENSION) {\n    if (data.child_data.size() != static_cast<size_t>(type.num_children())) {\n      return Status::Invalid(\"Expected \", type.num_children(),\n                             \" child arrays in array \"\n                             \"of type \",\n                             type.ToString(), \", got \", data.child_data.size());\n    }\n  }\n  if (layout.has_dictionary && !data.dictionary) {\n    return Status::Invalid(\"Array of type \", type.ToString(),\n                           \" must have dictionary values\");\n  }\n  if (!layout.has_dictionary && data.dictionary) {\n    return Status::Invalid(\"Unexpected dictionary values in array of type \",\n                           type.ToString());\n  }\n\n  ValidateArrayVisitor visitor;\n  return VisitArrayInline(array, &visitor);\n}\n  Status CheckBounds(const Array& array, int64_t min_value, int64_t max_value) {\n    BoundsCheckVisitor visitor{min_value, max_value};\n    return VisitArrayInline(array, &visitor);\n  }\nARROW_EXPORT\nStatus ValidateArrayData(const Array& array) {\n  ValidateArrayDataVisitor visitor;\n  return VisitArrayInline(array, &visitor);\n}\n  void TestValidateOffsets() {\n    auto empty_values = ArrayFromJSON(int16(), \"[]\");\n    auto values = ArrayFromJSON(int16(), \"[1, 2, 3, 4, 5, 6, 7]\");\n\n    ASSERT_OK(ValidateOffsets(0, {0}, empty_values));\n    ASSERT_OK(ValidateOffsets(1, {0, 7}, values));\n    ASSERT_OK(ValidateOffsets(2, {0, 4, 7}, values));\n    ASSERT_OK(ValidateOffsets(3, {0, 4, 7, 7}, values));\n\n    // Non-zero array offset\n    ASSERT_OK(ValidateOffsets(1, {0, 4, 7}, values, 1));\n    ASSERT_OK(ValidateOffsets(0, {0, 4, 7}, values, 2));\n\n    // Not enough offsets\n    ASSERT_RAISES(Invalid, ValidateOffsets(1, {0}, values));\n    ASSERT_RAISES(Invalid, ValidateOffsets(2, {0, 0}, values, 1));\n\n    // First offset != 0\n    ASSERT_RAISES(Invalid, ValidateOffsets(1, {1, 7}, values));\n    // Offset out of bounds\n    ASSERT_RAISES(Invalid, ValidateOffsets(1, {0, 8}, values));\n    ASSERT_RAISES(Invalid, ValidateOffsets(1, {0, 8, 8}, values, 1));\n    // Negative offset\n    ASSERT_RAISES(Invalid, ValidateOffsets(1, {-1, 0}, values));\n    ASSERT_RAISES(Invalid, ValidateOffsets(1, {0, -1}, values));\n    ASSERT_RAISES(Invalid, ValidateOffsets(2, {0, -1, -1}, values, 1));\n    // Offsets non-monotonic\n    ASSERT_RAISES(Invalid, ValidateOffsets(2, {0, 7, 4}, values));\n  }\nStatus PropagateNulls(FunctionContext* ctx, const ArrayData& lhs, const ArrayData& rhs,\n                      ArrayData* output) {\n  return AssignNullIntersection(ctx, lhs, rhs, output);\n}\nStatus UnionFromFlatbuffer(const flatbuf::Union* union_data,\n                           const std::vector<std::shared_ptr<Field>>& children,\n                           std::shared_ptr<DataType>* out) {\n  UnionMode::type mode =\n      (union_data->mode() == flatbuf::UnionMode_Sparse ? UnionMode::SPARSE\n                                                       : UnionMode::DENSE);\n\n  std::vector<int8_t> type_codes;\n\n  const flatbuffers::Vector<int32_t>* fb_type_ids = union_data->typeIds();\n  if (fb_type_ids == nullptr) {\n    // TODO validate that children.size() <= 127?\n    for (int8_t i = 0; i < static_cast<int8_t>(children.size()); ++i) {\n      type_codes.push_back(i);\n    }\n  } else {\n    for (int32_t id : (*fb_type_ids)) {\n      // TODO(wesm): can these values exceed 127?\n      type_codes.push_back(static_cast<int8_t>(id));\n    }\n  }\n\n  *out = union_(children, type_codes, mode);\n  return Status::OK();\n}\n  Status ReadFooter() {\n    int magic_size = static_cast<int>(strlen(kArrowMagicBytes));\n\n    if (footer_offset_ <= magic_size * 2 + 4) {\n      return Status::Invalid(\"File is too small: \", footer_offset_);\n    }\n\n    int file_end_size = static_cast<int>(magic_size + sizeof(int32_t));\n    ARROW_ASSIGN_OR_RAISE(auto buffer,\n                          file_->ReadAt(footer_offset_ - file_end_size, file_end_size));\n\n    const int64_t expected_footer_size = magic_size + sizeof(int32_t);\n    if (buffer->size() < expected_footer_size) {\n      return Status::Invalid(\"Unable to read \", expected_footer_size, \"from end of file\");\n    }\n\n    if (memcmp(buffer->data() + sizeof(int32_t), kArrowMagicBytes, magic_size)) {\n      return Status::Invalid(\"Not an Arrow file\");\n    }\n\n    int32_t footer_length = *reinterpret_cast<const int32_t*>(buffer->data());\n\n    if (footer_length <= 0 || footer_length + magic_size * 2 + 4 > footer_offset_) {\n      return Status::Invalid(\"File is smaller than indicated metadata size\");\n    }\n\n    // Now read the footer\n    ARROW_ASSIGN_OR_RAISE(\n        footer_buffer_,\n        file_->ReadAt(footer_offset_ - footer_length - file_end_size, footer_length));\n\n    auto data = footer_buffer_->data();\n    flatbuffers::Verifier verifier(data, footer_buffer_->size(), 128);\n    if (!flatbuf::VerifyFooterBuffer(verifier)) {\n      return Status::IOError(\"Verification of flatbuffer-encoded Footer failed.\");\n    }\n    footer_ = flatbuf::GetFooter(data);\n\n    return Status::OK();\n  }\n  Status ReadMessageFromBlock(const FileBlock& block, std::unique_ptr<Message>* out) {\n    DCHECK(BitUtil::IsMultipleOf8(block.offset));\n    DCHECK(BitUtil::IsMultipleOf8(block.metadata_length));\n    DCHECK(BitUtil::IsMultipleOf8(block.body_length));\n\n    RETURN_NOT_OK(ReadMessage(block.offset, block.metadata_length, file_, out));\n\n    // TODO(wesm): this breaks integration tests, see ARROW-3256\n    // DCHECK_EQ((*out)->body_length(), block.body_length);\n    return Status::OK();\n  }\nUnionType::UnionType(const std::vector<std::shared_ptr<Field>>& fields,\n                     const std::vector<int8_t>& type_codes, UnionMode::type mode)\n    : NestedType(Type::UNION),\n      mode_(mode),\n      type_codes_(type_codes),\n      child_ids_(kMaxTypeCode + 1, kInvalidChildId) {\n  DCHECK_LE(fields.size(), type_codes.size()) << \"union field with unknown type id\";\n  DCHECK_GE(fields.size(), type_codes.size())\n      << \"type id provided without corresponding union field\";\n  children_ = fields;\n  for (int child_id = 0; child_id < static_cast<int>(type_codes_.size()); ++child_id) {\n    const auto type_code = type_codes_[child_id];\n    DCHECK_GE(type_code, 0);\n    DCHECK_LE(type_code, kMaxTypeCode);\n    child_ids_[type_code] = child_id;\n  }\n}\nDataTypeLayout UnionType::layout() const {\n  if (mode_ == UnionMode::SPARSE) {\n    return {{1, CHAR_BIT, DataTypeLayout::kAlwaysNullBuffer}, false};\n  } else {\n    return {{1, CHAR_BIT, sizeof(int32_t) * CHAR_BIT}, false};\n  }\n}\nuint8_t UnionType::max_type_code() const {\n  return type_codes_.size() == 0\n             ? 0\n             : *std::max_element(type_codes_.begin(), type_codes_.end());\n}\nstd::string UnionType::ToString() const {\n  std::stringstream s;\n\n  if (mode_ == UnionMode::SPARSE) {\n    s << \"union[sparse]<\";\n  } else {\n    s << \"union[dense]<\";\n  }\n\n  for (size_t i = 0; i < children_.size(); ++i) {\n    if (i) {\n      s << \", \";\n    }\n    s << children_[i]->ToString() << \"=\" << static_cast<int>(type_codes_[i]);\n  }\n  s << \">\";\n  return s.str();\n}\ntypename std::enable_if<\n    std::is_integral<Integer>::value && std::is_unsigned<Integer>::value, uint64_t>::type\nUpcastInt(Integer v) {\n  return v;\n}\n",
    "target": 1,
    "idx": 1020116,
    "stack_trace": [
      {
        "function_name": "UnionType",
        "function_body": "Result<std::shared_ptr<DataType>> UnionType::Make(\n    const std::vector<std::shared_ptr<Field>>& fields,\n    const std::vector<int8_t>& type_codes, UnionMode::type mode) {\n  RETURN_NOT_OK(ValidateParameters(fields, type_codes, mode));\n  return std::make_shared<UnionType>(fields, type_codes, mode);\n}",
        "file_path": "/src/arrow/cpp/src/arrow/type.cc",
        "crashing_line": "Result<std::shared_ptr<DataType>> UnionType::Make(",
        "crashing_line_number": 362
      },
      {
        "function_name": "union_",
        "function_body": "std::shared_ptr<DataType> union_(const std::vector<std::shared_ptr<Array>>& children,\n                                 const std::vector<std::string>& field_names,\n                                 const std::vector<int8_t>& given_type_codes,\n                                 UnionMode::type mode) {\n  std::vector<std::shared_ptr<Field>> fields;\n  std::vector<int8_t> type_codes(given_type_codes);\n  int8_t counter = 0;\n  for (const auto& child : children) {\n    if (field_names.size() == 0) {\n      fields.push_back(field(std::to_string(counter), child->type()));\n    } else {\n      fields.push_back(field(std::move(field_names[counter]), child->type()));\n    }\n    if (given_type_codes.size() == 0) {\n      type_codes.push_back(counter);\n    }\n    counter++;\n  }\n  return union_(fields, std::move(type_codes), mode);\n}",
        "file_path": "/src/arrow/cpp/src/arrow/type.cc",
        "crashing_line": "",
        "crashing_line_number": 1397
      },
      {
        "function_name": "UnionFromFlatbuffer",
        "function_body": "Status UnionFromFlatbuffer(const flatbuf::Union* union_data,\n                           const std::vector<std::shared_ptr<Field>>& children,\n                           std::shared_ptr<DataType>* out) {\n  UnionMode::type mode =\n      (union_data->mode() == flatbuf::UnionMode_Sparse ? UnionMode::SPARSE\n                                                       : UnionMode::DENSE);\n\n  std::vector<int8_t> type_codes;\n\n  const flatbuffers::Vector<int32_t>* fb_type_ids = union_data->typeIds();\n  if (fb_type_ids == nullptr) {\n    for (int8_t i = 0; i < static_cast<int8_t>(children.size()); ++i) {\n      type_codes.push_back(i);\n    }\n  } else {\n    for (int32_t id : (*fb_type_ids)) {\n      const auto type_code = static_cast<int8_t>(id);\n      if (id != type_code) {\n        return Status::Invalid(\"union type id out of bounds\");\n      }\n      type_codes.push_back(type_code);\n    }\n  }\n\n  return UnionType::Make(children, type_codes, mode).Value(out);\n}",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/metadata_internal.cc",
        "crashing_line": "  }",
        "crashing_line_number": 175
      },
      {
        "function_name": "",
        "function_body": "  Status Visit(const ExtensionType& type) {\n    RETURN_NOT_OK(VisitType(*type.storage_type()));\n    extra_type_metadata_[kExtensionTypeKeyName] = type.extension_name();\n    extra_type_metadata_[kExtensionMetadataKeyName] = type.Serialize();\n    return Status::OK();\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/metadata_internal.cc",
        "crashing_line": "",
        "crashing_line_number": 358
      },
      {
        "function_name": "TypeFromFlatbuffer",
        "function_body": "static Status TypeFromFlatbuffer(const flatbuf::Field* field,\n                                 const std::vector<std::shared_ptr<Field>>& children,\n                                 const KeyValueMetadata* field_metadata,\n                                 std::shared_ptr<DataType>* out) {\n  auto type_data = field->type();\n  if (type_data == nullptr) {\n    return Status::IOError(\n        \"Type-pointer in custom metadata of flatbuffer-encoded Field is null.\");\n  }\n  RETURN_NOT_OK(ConcreteTypeFromFlatbuffer(field->type_type(), type_data, children, out));\n\n  // Look for extension metadata in custom_metadata field\n  // TODO(wesm): Should this be part of the Field Flatbuffers table?\n  if (field_metadata != nullptr) {\n    int name_index = field_metadata->FindKey(kExtensionTypeKeyName);\n    if (name_index == -1) {\n      return Status::OK();\n    }\n    std::string type_name = field_metadata->value(name_index);\n    int data_index = field_metadata->FindKey(kExtensionMetadataKeyName);\n    std::string type_data = data_index == -1 ? \"\" : field_metadata->value(data_index);\n\n    std::shared_ptr<ExtensionType> type = GetExtensionType(type_name);\n    if (type == nullptr) {\n      // TODO(wesm): Extension type is unknown; we do not raise here and simply\n      // return the raw data\n      return Status::OK();\n    }\n    RETURN_NOT_OK(type->Deserialize(*out, type_data, out));\n  }\n  return Status::OK();\n}",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/metadata_internal.cc",
        "crashing_line": "  }",
        "crashing_line_number": 375
      },
      {
        "function_name": "",
        "function_body": "  Status Visit(const ExtensionType& type) {\n    RETURN_NOT_OK(VisitType(*type.storage_type()));\n    extra_type_metadata_[kExtensionTypeKeyName] = type.extension_name();\n    extra_type_metadata_[kExtensionMetadataKeyName] = type.Serialize();\n    return Status::OK();\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/metadata_internal.cc",
        "crashing_line": "",
        "crashing_line_number": 786
      },
      {
        "function_name": "GetSchema",
        "function_body": "Status GetSchema(const void* opaque_schema, DictionaryMemo* dictionary_memo,\n                 std::shared_ptr<Schema>* out) {\n  auto schema = static_cast<const flatbuf::Schema*>(opaque_schema);\n  if (schema->fields() == nullptr) {\n    return Status::IOError(\"Fields-pointer of flatbuffer-encoded Schema is null.\");\n  }\n  int num_fields = static_cast<int>(schema->fields()->size());\n\n  std::vector<std::shared_ptr<Field>> fields(num_fields);\n  for (int i = 0; i < num_fields; ++i) {\n    const flatbuf::Field* field = schema->fields()->Get(i);\n    if (field == nullptr) {\n      return Status::IOError(\"Field-pointer of flatbuffer-encoded Schema is null.\");\n    }\n    RETURN_NOT_OK(FieldFromFlatbuffer(field, dictionary_memo, &fields[i]));\n  }\n\n  auto fb_metadata = schema->custom_metadata();\n  std::shared_ptr<KeyValueMetadata> metadata;\n\n  if (fb_metadata != nullptr) {\n    RETURN_NOT_OK(KeyValueMetadataFromFlatbuffer(fb_metadata, &metadata));\n  }\n\n  *out = ::arrow::schema(std::move(fields), metadata);\n\n  return Status::OK();\n}",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/metadata_internal.cc",
        "crashing_line": "    }",
        "crashing_line_number": 1196
      },
      {
        "function_name": "ReadSchema",
        "function_body": "Status ReadSchema(const Message& message, DictionaryMemo* dictionary_memo,\n                  std::shared_ptr<Schema>* out) {\n  std::shared_ptr<RecordBatchReader> reader;\n  return internal::GetSchema(message.header(), dictionary_memo, &*out);\n}",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 480
      },
      {
        "function_name": "Open",
        "function_body": "  Status Open(io::RandomAccessFile* file, int64_t footer_offset) {\n    file_ = file;\n    footer_offset_ = footer_offset;\n    RETURN_NOT_OK(ReadFooter());\n    return ReadSchema();\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 466
      },
      {
        "function_name": "Open",
        "function_body": "  Status Open(io::RandomAccessFile* file, int64_t footer_offset) {\n    file_ = file;\n    footer_offset_ = footer_offset;\n    RETURN_NOT_OK(ReadFooter());\n    return ReadSchema();\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 585
      },
      {
        "function_name": "Open",
        "function_body": "  Status Open(io::RandomAccessFile* file, int64_t footer_offset) {\n    file_ = file;\n    footer_offset_ = footer_offset;\n    RETURN_NOT_OK(ReadFooter());\n    return ReadSchema();\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 601
      },
      {
        "function_name": "FuzzIpcStream",
        "function_body": "Status FuzzIpcStream(const uint8_t* data, int64_t size) {\n  auto buffer = std::make_shared<Buffer>(data, size);\n  io::BufferReader buffer_reader(buffer);\n\n  std::shared_ptr<RecordBatchReader> batch_reader;\n  RETURN_NOT_OK(RecordBatchStreamReader::Open(&buffer_reader, &batch_reader));\n\n  while (true) {\n    std::shared_ptr<arrow::RecordBatch> batch;\n    RETURN_NOT_OK(batch_reader->ReadNext(&batch));\n    if (batch == nullptr) {\n      break;\n    }\n    RETURN_NOT_OK(batch->ValidateFull());\n  }\n\n  return Status::OK();\n}",
        "file_path": "/src/arrow/cpp/src/arrow/ipc/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 1164
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "    (void) SetPixelChannelMask(image,channel_mask);\n  (void) AddValueToSplayTree(fx_info->symbols,ConstantString(key),\n    ConstantString(statistic));\n  return(QuantumScale*StringToDouble(statistic,(char **) NULL));\n}\n\nstatic double\n  FxEvaluateSubexpression(FxInfo *,const PixelChannel,const ssize_t,\n    const ssize_t,const char *,const size_t,double *,ExceptionInfo *);\n\nstatic inline MagickBooleanType IsFxFunction(const char *expression,\n  const char *name,const size_t length)\n",
    "target": 1,
    "idx": 1019769,
    "stack_trace": [
      {
        "function_name": "FxEvaluateSubexpression",
        "function_body": "          target=precedence;\n          subexpression=expression;\n        }\n    if (strchr(\"(\",(int) *expression) != (char *) NULL)\n      expression=FxSubexpression(expression,exception);\n    c=(int) (*expression++);\n  }\n  return(subexpression);\n}\n\nstatic double FxEvaluateSubexpression(FxInfo *fx_info,\n  const PixelChannel channel,const ssize_t x,const ssize_t y,\n  const char *expression,const size_t depth,double *beta,\n  ExceptionInfo *exception)\n{\n#define FxMaxParenthesisDepth  58\n#define FxMaxSubexpressionDepth  200\n#define FxReturn(value) \\\n{ \\\n  subexpression=DestroyString(subexpression); \\\n  return(value); \\\n}\n\n  char\n    *q,\n    *subexpression,\n    value[MagickPathExtent];\n\n  double\n    alpha,\n    gamma;\n\n  register const char\n    *p;\n\n  *beta=0.0;\n  subexpression=AcquireString(expression);\n  *subexpression='\\0';\n  if (depth > FxMaxSubexpressionDepth)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"UnableToParseExpression\",\"`%s'\",expression);\n      FxReturn(0.0);\n    }\n  if (exception->severity >= ErrorException)\n    FxReturn(0.0);\n  while (isspace((int) ((unsigned char) *expression)) != 0)\n    expression++;\n  if (*expression == '\\0')\n    FxReturn(0.0);\n  p=FxOperatorPrecedence(expression,exception);\n  if (p != (const char *) NULL)\n    {\n      (void) CopyMagickString(subexpression,expression,(size_t)\n        (p-expression+1));\n      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth+1,\n        beta,exception);\n      switch ((unsigned char) *p)\n      {\n        case '~':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          *beta=(double) (~(size_t) *beta);\n          FxReturn(*beta);\n        }\n        case '!':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(*beta == 0.0 ? 1.0 : 0.0);\n        }\n        case '^':\n        {\n          *beta=pow(alpha,FxEvaluateSubexpression(fx_info,channel,x,y,++p,\n            depth+1,beta,exception));\n          FxReturn(*beta);\n        }\n        case '*':\n        case ExponentialNotation:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(alpha*(*beta));\n        }\n        case '/':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(PerceptibleReciprocal(*beta)*alpha);\n        }\n        case '%':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          *beta=fabs(floor((*beta)+0.5));\n          FxReturn(fmod(alpha,*beta));\n        }\n        case '+':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(alpha+(*beta));\n        }\n        case '-':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(alpha-(*beta));\n        }\n        case PlusAssignmentOperator:\n        {\n          q=subexpression;\n          while (isalpha((int) ((unsigned char) *q)) != 0)\n            q++;\n          if (*q != '\\0')\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",subexpression);\n              FxReturn(0.0);\n            }\n          ClearMagickException(exception);\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",alpha+*beta);\n          (void) AddValueToSplayTree(fx_info->symbols,ConstantString(\n            subexpression),ConstantString(value));\n          FxReturn(*beta);\n        }\n        case SubtractAssignmentOperator:\n        {\n          q=subexpression;\n          while (isalpha((int) ((unsigned char) *q)) != 0)\n            q++;\n          if (*q != '\\0')\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",subexpression);\n              FxReturn(0.0);\n            }\n          ClearMagickException(exception);\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",alpha-*beta);\n          (void) AddValueToSplayTree(fx_info->symbols,ConstantString(\n            subexpression),ConstantString(value));\n          FxReturn(*beta);\n        }\n        case MultiplyAssignmentOperator:\n        {\n          q=subexpression;\n          while (isalpha((int) ((unsigned char) *q)) != 0)\n            q++;\n          if (*q != '\\0')\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",subexpression);\n              FxReturn(0.0);\n            }\n          ClearMagickException(exception);\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",alpha**beta);\n          (void) AddValueToSplayTree(fx_info->symbols,ConstantString(\n            subexpression),ConstantString(value));\n          FxReturn(*beta);\n        }\n        case DivideAssignmentOperator:\n        {\n          q=subexpression;\n          while (isalpha((int) ((unsigned char) *q)) != 0)\n            q++;\n          if (*q != '\\0')\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",subexpression);\n              FxReturn(0.0);\n            }\n          ClearMagickException(exception);\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n            alpha*PerceptibleReciprocal(*beta));\n          (void) AddValueToSplayTree(fx_info->symbols,ConstantString(\n            subexpression),ConstantString(value));\n          FxReturn(*beta);\n        }\n        case IncrementAssignmentOperator:\n        {\n          if (*subexpression == '\\0')\n            alpha=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n              exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",alpha+1.0);\n          if (*subexpression == '\\0')\n            (void) AddValueToSplayTree(fx_info->symbols,ConstantString(p),\n              ConstantString(value));\n          else\n            (void) AddValueToSplayTree(fx_info->symbols,ConstantString(\n              subexpression),ConstantString(value));\n          FxReturn(*beta);\n        }\n        case DecrementAssignmentOperator:\n        {\n          if (*subexpression == '\\0')\n            alpha=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n              exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",alpha-1.0);\n          if (*subexpression == '\\0')\n            (void) AddValueToSplayTree(fx_info->symbols,ConstantString(p),\n              ConstantString(value));\n          else\n            (void) AddValueToSplayTree(fx_info->symbols,ConstantString(\n              subexpression),ConstantString(value));\n          FxReturn(*beta);\n        }\n        case LeftShiftOperator:\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          if ((size_t) (gamma+0.5) >= (8*sizeof(size_t)))\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"ShiftCountOverflow\",\"`%s'\",subexpression);\n              FxReturn(0.0);\n            }\n          *beta=(double) ((size_t) (alpha+0.5) << (size_t) (gamma+0.5));\n          FxReturn(*beta);\n        }\n        case RightShiftOperator:\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          if ((size_t) (gamma+0.5) >= (8*sizeof(size_t)))\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"ShiftCountOverflow\",\"`%s'\",subexpression);\n              FxReturn(0.0);\n            }\n          *beta=(double) ((size_t) (alpha+0.5) >> (size_t) (gamma+0.5));\n          FxReturn(*beta);\n        }\n        case '<':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(alpha < *beta ? 1.0 : 0.0);\n        }\n        case LessThanEqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(alpha <= *beta ? 1.0 : 0.0);\n        }\n        case '>':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(alpha > *beta ? 1.0 : 0.0);\n        }\n        case GreaterThanEqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(alpha >= *beta ? 1.0 : 0.0);\n        }\n        case EqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(fabs(alpha-(*beta)) < MagickEpsilon ? 1.0 : 0.0);\n        }\n        case NotEqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(fabs(alpha-(*beta)) >= MagickEpsilon ? 1.0 : 0.0);\n        }\n        case '&':\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          *beta=(double) ((size_t) (alpha+0.5) & (size_t) (gamma+0.5));\n          FxReturn(*beta);\n        }\n        case '|':\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          *beta=(double) ((size_t) (alpha+0.5) | (size_t) (gamma+0.5));\n          FxReturn(*beta);\n        }\n        case LogicalAndOperator:\n        {\n          p++;\n          if (alpha <= 0.0)\n            {\n              *beta=0.0;\n              FxReturn(*beta);\n            }\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,\n            exception);\n          *beta=(gamma > 0.0) ? 1.0 : 0.0;\n          FxReturn(*beta);\n        }\n        case LogicalOrOperator:\n        {\n          p++;\n          if (alpha > 0.0)\n            {\n             *beta=1.0;\n             FxReturn(*beta);\n            }\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,\n            exception);\n          *beta=(gamma > 0.0) ? 1.0 : 0.0;\n          FxReturn(*beta);\n        }\n        case '?':\n        {\n          (void) CopyMagickString(subexpression,++p,MagickPathExtent);\n          q=subexpression;\n          p=StringToken(\":\",&q);\n          if (q == (char *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",subexpression);\n              FxReturn(0.0);\n            }\n          if (fabs(alpha) >= MagickEpsilon)\n            gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,\n              exception);\n          else\n            gamma=FxEvaluateSubexpression(fx_info,channel,x,y,q,depth+1,beta,\n              exception);\n          FxReturn(gamma);\n        }\n        case '=':\n        {\n          q=subexpression;\n          while (isalpha((int) ((unsigned char) *q)) != 0)\n            q++;\n          if (*q != '\\0')\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",subexpression);\n              FxReturn(0.0);\n            }\n          ClearMagickException(exception);\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",*beta);\n          (void) AddValueToSplayTree(fx_info->symbols,ConstantString(\n            subexpression),ConstantString(value));\n          FxReturn(*beta);\n        }\n        case ',':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(alpha);\n        }\n        case ';':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,\n            exception);\n          FxReturn(*beta);\n        }\n        default:\n        {\n          gamma=alpha*FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,\n            beta,exception);\n          FxReturn(gamma);\n        }\n      }\n    }\n  if (strchr(\"(\",(int) *expression) != (char *) NULL)\n    {\n      if (depth >= FxMaxParenthesisDepth)\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"ParenthesisNestedTooDeeply\",\"`%s'\",expression);\n      (void) CopyMagickString(subexpression,expression+1,MagickPathExtent);\n      if (strlen(subexpression) != 0)\n        subexpression[strlen(subexpression)-1]='\\0';\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth+1,\n        beta,exception);\n      FxReturn(gamma);\n    }\n  switch (*expression)\n  {\n    case '+':\n    {\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth+1,\n        beta,exception);\n      FxReturn(1.0*gamma);\n    }\n    case '-':\n    {\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth+1,\n        beta,exception);\n      FxReturn(-1.0*gamma);\n    }\n    case '~':\n    {\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth+1,\n        beta,exception);\n      FxReturn((double) (~(size_t) (gamma+0.5)));\n    }\n    case 'A':\n    case 'a':\n    {\n      if (IsFxFunction(expression,\"abs\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(fabs(alpha));\n        }\n#if defined(MAGICKCORE_HAVE_ACOSH)\n      if (IsFxFunction(expression,\"acosh\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          FxReturn(acosh(alpha));\n        }\n#endif\n      if (IsFxFunction(expression,\"acos\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          FxReturn(acos(alpha));\n        }\n#if defined(MAGICKCORE_HAVE_J1)\n      if (IsFxFunction(expression,\"airy\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          if (alpha == 0.0)\n            FxReturn(1.0);\n          gamma=2.0*j1((MagickPI*alpha))/(MagickPI*alpha);\n          FxReturn(gamma*gamma);\n        }\n#endif\n#if defined(MAGICKCORE_HAVE_ASINH)\n      if (IsFxFunction(expression,\"asinh\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          FxReturn(asinh(alpha));\n        }\n#endif\n      if (IsFxFunction(expression,\"asin\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          FxReturn(asin(alpha));\n        }\n      if (IsFxFunction(expression,\"alt\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(((ssize_t) alpha) & 0x01 ? -1.0 : 1.0);\n        }\n      if (IsFxFunction(expression,\"atan2\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          FxReturn(atan2(alpha,*beta));\n        }\n#if defined(MAGICKCORE_HAVE_ATANH)\n      if (IsFxFunction(expression,\"atanh\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          FxReturn(atanh(alpha));\n        }\n#endif\n      if (IsFxFunction(expression,\"atan\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          FxReturn(atan(alpha));\n        }\n      if (LocaleCompare(expression,\"a\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(expression,\"b\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'C':\n    case 'c':\n    {\n      if (IsFxFunction(expression,\"ceil\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          FxReturn(ceil(alpha));\n        }\n      if (IsFxFunction(expression,\"clamp\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          if (alpha < 0.0)\n            FxReturn(0.0);\n          if (alpha > 1.0)\n            FxReturn(1.0);\n          FxReturn(alpha);\n        }\n      if (IsFxFunction(expression,\"cosh\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          FxReturn(cosh(alpha));\n        }\n      if (IsFxFunction(expression,\"cos\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(cos(alpha));\n        }\n      if (LocaleCompare(expression,\"c\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (IsFxFunction(expression,\"debug\",5) != MagickFalse)\n        {\n          const char\n            *type;\n\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          switch (fx_info->images->colorspace)\n          {\n            case CMYKColorspace:\n            {\n              switch (channel)\n              {\n                case CyanPixelChannel: type=\"cyan\"; break;\n                case MagentaPixelChannel: type=\"magenta\"; break;\n                case YellowPixelChannel: type=\"yellow\"; break;\n                case AlphaPixelChannel: type=\"alpha\"; break;\n                case BlackPixelChannel: type=\"black\"; break;\n                default: type=\"unknown\"; break;\n              }\n              break;\n            }\n            case GRAYColorspace:\n            {\n              switch (channel)\n              {\n                case RedPixelChannel: type=\"gray\"; break;\n                case AlphaPixelChannel: type=\"alpha\"; break;\n                default: type=\"unknown\"; break;\n              }\n              break;\n            }\n            default:\n            {\n              switch (channel)\n              {\n                case RedPixelChannel: type=\"red\"; break;\n                case GreenPixelChannel: type=\"green\"; break;\n                case BluePixelChannel: type=\"blue\"; break;\n                case AlphaPixelChannel: type=\"alpha\"; break;\n                default: type=\"unknown\"; break;\n              }\n              break;\n            }\n          }\n          *subexpression='\\0';\n          if (strlen(expression) > 6)\n            (void) CopyMagickString(subexpression,expression+6,\n              MagickPathExtent);\n          if (strlen(subexpression) > 1)\n            subexpression[strlen(subexpression)-1]='\\0';\n          if (fx_info->file != (FILE *) NULL)\n            (void) FormatLocaleFile(fx_info->file,\"%s[%.20g,%.20g].%s: \"\n              \"%s=%.*g\\n\",fx_info->images->filename,(double) x,(double) y,type,\n              subexpression,GetMagickPrecision(),alpha);\n          FxReturn(0.0);\n        }\n      if (IsFxFunction(expression,\"drc\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn((alpha/(*beta*(alpha-1.0)+1.0)));\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare(expression,\"epsilon\") == 0)\n        FxReturn(MagickEpsilon);\n#if defined(MAGICKCORE_HAVE_ERF)\n      if (IsFxFunction(expression,\"erf\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(erf(alpha));\n        }\n#endif\n      if (IsFxFunction(expression,\"exp\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(exp(alpha));\n        }\n      if (LocaleCompare(expression,\"e\") == 0)\n        FxReturn(2.7182818284590452354);\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (IsFxFunction(expression,\"floor\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          FxReturn(floor(alpha));\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (IsFxFunction(expression,\"gauss\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          gamma=exp((-alpha*alpha/2.0))/sqrt(2.0*MagickPI);\n          FxReturn(gamma);\n        }\n      if (IsFxFunction(expression,\"gcd\",3) != MagickFalse)\n        {\n          MagickOffsetType\n            gcd;\n\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          gcd=FxGCD((MagickOffsetType) (alpha+0.5),(MagickOffsetType) (*beta+\n            0.5));\n          FxReturn((double) gcd);\n        }\n      if (LocaleCompare(expression,\"g\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(expression,\"h\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      if (LocaleCompare(expression,\"hue\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      if (IsFxFunction(expression,\"hypot\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          FxReturn(hypot(alpha,*beta));\n        }\n      break;\n    }\n    case 'K':\n    case 'k':\n    {\n      if (LocaleCompare(expression,\"k\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(expression,\"intensity\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      if (IsFxFunction(expression,\"int\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(floor(alpha));\n        }\n      if (IsFxFunction(expression,\"isnan\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          FxReturn((double) !!IsNaN(alpha));\n        }\n      if (LocaleCompare(expression,\"i\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'J':\n    case 'j':\n    {\n      if (LocaleCompare(expression,\"j\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n#if defined(MAGICKCORE_HAVE_J0)\n      if (IsFxFunction(expression,\"j0\",2) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,\n            depth+1,beta,exception);\n          FxReturn(j0(alpha));\n        }\n#endif\n#if defined(MAGICKCORE_HAVE_J1)\n      if (IsFxFunction(expression,\"j1\",2) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,\n            depth+1,beta,exception);\n          FxReturn(j1(alpha));\n        }\n#endif\n#if defined(MAGICKCORE_HAVE_J1)\n      if (IsFxFunction(expression,\"jinc\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          if (alpha == 0.0)\n            FxReturn(1.0);\n          gamma=(2.0*j1((MagickPI*alpha))/(MagickPI*alpha));\n          FxReturn(gamma);\n        }\n#endif\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (IsFxFunction(expression,\"ln\",2) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,\n            depth+1,beta,exception);\n          FxReturn(log(alpha));\n        }\n      if (IsFxFunction(expression,\"logtwo\",6) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+6,\n            depth+1,beta,exception);\n          FxReturn(log10(alpha)/log10(2.0));\n        }\n      if (IsFxFunction(expression,\"log\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(log10(alpha));\n        }\n      if (LocaleCompare(expression,\"lightness\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare(expression,\"MaxRGB\") == 0)\n        FxReturn(QuantumRange);\n      if (LocaleNCompare(expression,\"maxima\",6) == 0)\n        break;\n      if (IsFxFunction(expression,\"max\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(alpha > *beta ? alpha : *beta);\n        }\n      if (LocaleNCompare(expression,\"minima\",6) == 0)\n        break;\n      if (IsFxFunction(expression,\"min\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(alpha < *beta ? alpha : *beta);\n        }\n      if (IsFxFunction(expression,\"mod\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          gamma=alpha-floor((alpha*PerceptibleReciprocal(*beta)))*(*beta);\n          FxReturn(gamma);\n        }\n      if (LocaleCompare(expression,\"m\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'N':\n    case 'n':\n    {\n      if (IsFxFunction(expression,\"not\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn((double) (alpha < MagickEpsilon));\n        }\n      if (LocaleCompare(expression,\"n\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'O':\n    case 'o':\n    {\n      if (LocaleCompare(expression,\"Opaque\") == 0)\n        FxReturn(1.0);\n      if (LocaleCompare(expression,\"o\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(expression,\"phi\") == 0)\n        FxReturn(MagickPHI);\n      if (LocaleCompare(expression,\"pi\") == 0)\n        FxReturn(MagickPI);\n      if (IsFxFunction(expression,\"pow\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(pow(alpha,*beta));\n        }\n      if (LocaleCompare(expression,\"p\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'Q':\n    case 'q':\n    {\n      if (LocaleCompare(expression,\"QuantumRange\") == 0)\n        FxReturn(QuantumRange);\n      if (LocaleCompare(expression,\"QuantumScale\") == 0)\n        FxReturn(QuantumScale);\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (IsFxFunction(expression,\"rand\",4) != MagickFalse)\n        {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_FxEvaluateSubexpression)\n#endif\n          alpha=GetPseudoRandomValue(fx_info->random_info);\n          FxReturn(alpha);\n        }\n      if (IsFxFunction(expression,\"round\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          FxReturn(floor(alpha+0.5));\n        }\n      if (LocaleCompare(expression,\"r\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare(expression,\"saturation\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      if (IsFxFunction(expression,\"sign\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          FxReturn(alpha < 0.0 ? -1.0 : 1.0);\n        }\n      if (IsFxFunction(expression,\"sinc\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          if (alpha == 0)\n            FxReturn(1.0);\n          gamma=sin((MagickPI*alpha))/(MagickPI*alpha);\n          FxReturn(gamma);\n        }\n      if (IsFxFunction(expression,\"sinh\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          FxReturn(sinh(alpha));\n        }\n      if (IsFxFunction(expression,\"sin\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(sin(alpha));\n        }\n      if (IsFxFunction(expression,\"sqrt\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          FxReturn(sqrt(alpha));\n        }\n      if (IsFxFunction(expression,\"squish\",6) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+6,\n            depth+1,beta,exception);\n          FxReturn((1.0/(1.0+exp(-alpha))));\n        }\n      if (LocaleCompare(expression,\"s\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (IsFxFunction(expression,\"tanh\",4) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,\n            depth+1,beta,exception);\n          FxReturn(tanh(alpha));\n        }\n      if (IsFxFunction(expression,\"tan\",3) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,\n            depth+1,beta,exception);\n          FxReturn(tan(alpha));\n        }\n      if (LocaleCompare(expression,\"Transparent\") == 0)\n        FxReturn(0.0);\n      if (IsFxFunction(expression,\"trunc\",5) != MagickFalse)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n            depth+1,beta,exception);\n          if (alpha >= 0.0)\n            FxReturn(floor(alpha));\n          FxReturn(ceil(alpha));\n        }\n      if (LocaleCompare(expression,\"t\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(expression,\"u\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(expression,\"v\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'W':\n    case 'w':\n    {\n      if (IsFxFunction(expression,\"while\",5) != MagickFalse)\n        {\n          /*\n            Parse while(condition,expression).\n          */\n          (void) CopyMagickString(subexpression,expression+6,MagickPathExtent);\n          subexpression[strlen(subexpression)-1]='\\0';\n          q=subexpression;\n          p=StringToken(\",\",&q);\n          if ((p == (char *) NULL) || (strlen(p) < 1) || (q == (char *) NULL))\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",expression);\n              FxReturn(0.0);\n            }\n          for ( ; ; )\n          {\n            double sans = 0.0;\n            alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,&sans,\n              exception);\n            if (fabs(alpha) < MagickEpsilon)\n              FxReturn(*beta);\n            alpha=FxEvaluateSubexpression(fx_info,channel,x,y,q,depth+1,beta,\n              exception);\n          }\n        }\n      if (LocaleCompare(expression,\"w\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'Y':\n    case 'y':\n    {\n      if (LocaleCompare(expression,\"y\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }\n    case 'Z':\n    case 'z':\n    {\n      if (LocaleCompare(expression,\"z\") == 0)\n        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));\n      break;\n    }",
        "file_path": "/src/imagemagick/MagickCore/fx.c",
        "crashing_line": "        FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));",
        "crashing_line_number": 3105
      },
      {
        "function_name": "FxEvaluateChannelExpression",
        "function_body": "    status;\n\n  file=fx_info->file;\n  fx_info->file=(FILE *) NULL;\n  status=FxEvaluateChannelExpression(fx_info,GrayPixelChannel,0,0,alpha,\n    exception);\n  fx_info->file=file;\n  return(status);\n}\n\nMagickPrivate MagickBooleanType FxEvaluateChannelExpression(FxInfo *fx_info,\n  const PixelChannel channel,const ssize_t x,const ssize_t y,",
        "file_path": "/src/imagemagick/MagickCore/fx.c",
        "crashing_line": "  fx_info->file=file;",
        "crashing_line_number": 3190
      },
      {
        "function_name": "InterpretImageProperties",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/property.c",
        "crashing_line": "",
        "crashing_line_number": 3841
      },
      {
        "function_name": "ReadLABELImage",
        "function_body": "",
        "file_path": "/src/imagemagick/coders/label.c",
        "crashing_line": "",
        "crashing_line_number": 127
      },
      {
        "function_name": "ReadImage",
        "function_body": "",
        "file_path": "/src/imagemagick/MagickCore/constitute.c",
        "crashing_line": "",
        "crashing_line_number": 553
      },
      {
        "function_name": "read",
        "function_body": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}",
        "file_path": "/src/imagemagick/Magick++/lib/Image.cpp",
        "crashing_line": "",
        "crashing_line_number": 4094
      },
      {
        "function_name": "fuzzEncoderWithStringFilename",
        "function_body": "static int fuzzEncoderWithStringFilename(const std::string encoder, const uint8_t *Data, size_t Size, bool (*validate)(const std::string &) = NULL)\n{\n  // Allow a bit extra to make sure we do proper bounds checking in Magick++\n  if (Size > MagickPathExtent)\n    return 0;\n\n  std::string fileName(reinterpret_cast<const char*>(Data), Size);\n\n  // Can be used to deny specific file names\n  if ((validate != NULL) && (validate(fileName) == false))\n    return 0;\n\n  Magick::Image image;\n  try {\n    image.read(encoder + \":\" + fileName);\n  }\n  catch (Magick::Exception &e) {\n  }\n  return 0;\n}",
        "file_path": "/src/imagemagick/Magick++/fuzz/encoder_utils.cc",
        "crashing_line": "    image.read(encoder + \":\" + fileName);",
        "crashing_line_number": 15
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\nprint_insn (bfd_vma pc, disassemble_info *info)\n{\n  const struct dis386 *dp;\n  int i;\n  char *op_txt[MAX_OPERANDS];\n  int needcomma;\n  int sizeflag, orig_sizeflag;\n  const char *p;\n  struct dis_private priv;\n  int prefix_length;\n\n  priv.orig_sizeflag = AFLAG | DFLAG;\n  if ((info->mach & bfd_mach_i386_i386) != 0)\n    address_mode = mode_32bit;\n  else if (info->mach == bfd_mach_i386_i8086)\n    {\n      address_mode = mode_16bit;\n      priv.orig_sizeflag = 0;\n    }\n  else\n    address_mode = mode_64bit;\n\n  if (intel_syntax == (char) -1)\n    intel_syntax = (info->mach & bfd_mach_i386_intel_syntax) != 0;\n\n  for (p = info->disassembler_options; p != NULL; )\n    {\n      if (CONST_STRNEQ (p, \"amd64\"))\n\tisa64 = amd64;\n      else if (CONST_STRNEQ (p, \"intel64\"))\n\tisa64 = intel64;\n      else if (CONST_STRNEQ (p, \"x86-64\"))\n\t{\n\t  address_mode = mode_64bit;\n\t  priv.orig_sizeflag |= AFLAG | DFLAG;\n\t}\n      else if (CONST_STRNEQ (p, \"i386\"))\n\t{\n\t  address_mode = mode_32bit;\n\t  priv.orig_sizeflag |= AFLAG | DFLAG;\n\t}\n      else if (CONST_STRNEQ (p, \"i8086\"))\n\t{\n\t  address_mode = mode_16bit;\n\t  priv.orig_sizeflag &= ~(AFLAG | DFLAG);\n\t}\n      else if (CONST_STRNEQ (p, \"intel\"))\n\t{\n\t  intel_syntax = 1;\n\t  if (CONST_STRNEQ (p + 5, \"-mnemonic\"))\n\t    intel_mnemonic = 1;\n\t}\n      else if (CONST_STRNEQ (p, \"att\"))\n\t{\n\t  intel_syntax = 0;\n\t  if (CONST_STRNEQ (p + 3, \"-mnemonic\"))\n\t    intel_mnemonic = 0;\n\t}\n      else if (CONST_STRNEQ (p, \"addr\"))\n\t{\n\t  if (address_mode == mode_64bit)\n\t    {\n\t      if (p[4] == '3' && p[5] == '2')\n\t\tpriv.orig_sizeflag &= ~AFLAG;\n\t      else if (p[4] == '6' && p[5] == '4')\n\t\tpriv.orig_sizeflag |= AFLAG;\n\t    }\n\t  else\n\t    {\n\t      if (p[4] == '1' && p[5] == '6')\n\t\tpriv.orig_sizeflag &= ~AFLAG;\n\t      else if (p[4] == '3' && p[5] == '2')\n\t\tpriv.orig_sizeflag |= AFLAG;\n\t    }\n\t}\n      else if (CONST_STRNEQ (p, \"data\"))\n\t{\n\t  if (p[4] == '1' && p[5] == '6')\n\t    priv.orig_sizeflag &= ~DFLAG;\n\t  else if (p[4] == '3' && p[5] == '2')\n\t    priv.orig_sizeflag |= DFLAG;\n\t}\n      else if (CONST_STRNEQ (p, \"suffix\"))\n\tpriv.orig_sizeflag |= SUFFIX_ALWAYS;\n\n      p = strchr (p, ',');\n      if (p != NULL)\n\tp++;\n    }\n\n  if (address_mode == mode_64bit && sizeof (bfd_vma) < 8)\n    {\n      (*info->fprintf_func) (info->stream,\n\t\t\t     _(\"64-bit address is disabled\"));\n      return -1;\n    }\n\n  if (intel_syntax)\n    {\n      names64 = intel_names64;\n      names32 = intel_names32;\n      names16 = intel_names16;\n      names8 = intel_names8;\n      names8rex = intel_names8rex;\n      names_seg = intel_names_seg;\n      names_mm = intel_names_mm;\n      names_bnd = intel_names_bnd;\n      names_xmm = intel_names_xmm;\n      names_ymm = intel_names_ymm;\n      names_zmm = intel_names_zmm;\n      names_tmm = intel_names_tmm;\n      index64 = intel_index64;\n      index32 = intel_index32;\n      names_mask = intel_names_mask;\n      index16 = intel_index16;\n      open_char = '[';\n      close_char = ']';\n      separator_char = '+';\n      scale_char = '*';\n    }\n  else\n    {\n      names64 = att_names64;\n      names32 = att_names32;\n      names16 = att_names16;\n      names8 = att_names8;\n      names8rex = att_names8rex;\n      names_seg = att_names_seg;\n      names_mm = att_names_mm;\n      names_bnd = att_names_bnd;\n      names_xmm = att_names_xmm;\n      names_ymm = att_names_ymm;\n      names_zmm = att_names_zmm;\n      names_tmm = att_names_tmm;\n      index64 = att_index64;\n      index32 = att_index32;\n      names_mask = att_names_mask;\n      index16 = att_index16;\n      open_char = '(';\n      close_char =  ')';\n      separator_char = ',';\n      scale_char = ',';\n    }\n\n  /* The output looks better if we put 7 bytes on a line, since that\n     puts most long word instructions on a single line.  Use 8 bytes\n     for Intel L1OM.  */\n  if ((info->mach & bfd_mach_l1om) != 0)\n    info->bytes_per_line = 8;\n  else\n    info->bytes_per_line = 7;\n\n  info->private_data = &priv;\n  priv.max_fetched = priv.the_buffer;\n  priv.insn_start = pc;\n\n  obuf[0] = 0;\n  for (i = 0; i < MAX_OPERANDS; ++i)\n    {\n      op_out[i][0] = 0;\n      op_index[i] = -1;\n    }\n\n  the_info = info;\n  start_pc = pc;\n  start_codep = priv.the_buffer;\n  codep = priv.the_buffer;\n\n  if (OPCODES_SIGSETJMP (priv.bailout) != 0)\n    {\n      const char *name;\n\n      /* Getting here means we tried for data but didn't get it.  That\n\t means we have an incomplete instruction of some sort.  Just\n\t print the first byte as a prefix or a .byte pseudo-op.  */\n      if (codep > priv.the_buffer)\n\t{\n\t  name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\t  if (name != NULL)\n\t    (*info->fprintf_func) (info->stream, \"%s\", name);\n\t  else\n\t    {\n\t      /* Just print the first byte as a .byte instruction.  */\n\t      (*info->fprintf_func) (info->stream, \".byte 0x%x\",\n\t\t\t\t     (unsigned int) priv.the_buffer[0]);\n\t    }\n\n\t  return 1;\n\t}\n\n      return -1;\n    }\n\n  obufp = obuf;\n  sizeflag = priv.orig_sizeflag;\n\n  if (!ckprefix () || rex_used)\n    {\n      /* Too many prefixes or unused REX prefixes.  */\n      for (i = 0;\n\t   i < (int) ARRAY_SIZE (all_prefixes) && all_prefixes[i];\n\t   i++)\n\t(*info->fprintf_func) (info->stream, \"%s%s\",\n\t\t\t       i == 0 ? \"\" : \" \",\n\t\t\t       prefix_name (all_prefixes[i], sizeflag));\n      return i;\n    }\n\n  insn_codep = codep;\n\n  FETCH_DATA (info, codep + 1);\n  two_source_ops = (*codep == 0x62) || (*codep == 0xc8);\n\n  if (((prefixes & PREFIX_FWAIT)\n       && ((*codep < 0xd8) || (*codep > 0xdf))))\n    {\n      /* Handle prefixes before fwait.  */\n      for (i = 0; i < fwait_prefix && all_prefixes[i];\n\t   i++)\n\t(*info->fprintf_func) (info->stream, \"%s \",\n\t\t\t       prefix_name (all_prefixes[i], sizeflag));\n      (*info->fprintf_func) (info->stream, \"fwait\");\n      return i + 1;\n    }\n\n  if (*codep == 0x0f)\n    {\n      unsigned char threebyte;\n\n      codep++;\n      FETCH_DATA (info, codep + 1);\n      threebyte = *codep;\n      dp = &dis386_twobyte[threebyte];\n      need_modrm = twobyte_has_modrm[threebyte];\n      codep++;\n    }\n  else\n    {\n      dp = &dis386[*codep];\n      need_modrm = onebyte_has_modrm[*codep];\n      codep++;\n    }\n\n  /* Save sizeflag for printing the extra prefixes later before updating\n     it for mnemonic and operand processing.  The prefix names depend\n     only on the address mode.  */\n  orig_sizeflag = sizeflag;\n  if (prefixes & PREFIX_ADDR)\n    sizeflag ^= AFLAG;\n  if ((prefixes & PREFIX_DATA))\n    sizeflag ^= DFLAG;\n\n  end_codep = codep;\n  if (need_modrm)\n    {\n      FETCH_DATA (info, codep + 1);\n      modrm.mod = (*codep >> 6) & 3;\n      modrm.reg = (*codep >> 3) & 7;\n      modrm.rm = *codep & 7;\n    }\n  else\n    memset (&modrm, 0, sizeof (modrm));\n\n  need_vex = 0;\n  memset (&vex, 0, sizeof (vex));\n\n  if (dp->name == NULL && dp->op[0].bytemode == FLOATCODE)\n    {\n      get_sib (info, sizeflag);\n      dofloat (sizeflag);\n    }\n  else\n    {\n      dp = get_valid_dis386 (dp, info);\n      if (dp != NULL && putop (dp->name, sizeflag) == 0)\n\t{\n\t  get_sib (info, sizeflag);\n\t  for (i = 0; i < MAX_OPERANDS; ++i)\n\t    {\n\t      obufp = op_out[i];\n\t      op_ad = MAX_OPERANDS - 1 - i;\n\t      if (dp->op[i].rtn)\n\t\t(*dp->op[i].rtn) (dp->op[i].bytemode, sizeflag);\n\t      /* For EVEX instruction after the last operand masking\n\t\t should be printed.  */\n\t      if (i == 0 && vex.evex)\n\t\t{\n\t\t  /* Don't print {%k0}.  */\n\t\t  if (vex.mask_register_specifier)\n\t\t    {\n\t\t      oappend (\"{\");\n\t\t      oappend (names_mask[vex.mask_register_specifier]);\n\t\t      oappend (\"}\");\n\t\t    }\n\t\t  if (vex.zeroing)\n\t\t    oappend (\"{z}\");\n\t\t}\n\t    }\n\t}\n    }\n\n  /* Clear instruction information.  */\n  if (the_info)\n    {\n      the_info->insn_info_valid = 0;\n      the_info->branch_delay_insns = 0;\n      the_info->data_size = 0;\n      the_info->insn_type = dis_noninsn;\n      the_info->target = 0;\n      the_info->target2 = 0;\n    }\n\n  /* Reset jump operation indicator.  */\n  op_is_jump = FALSE;\n\n  {\n    int jump_detection = 0;\n\n    /* Extract flags.  */\n    for (i = 0; i < MAX_OPERANDS; ++i)\n      {\n\tif ((dp->op[i].rtn == OP_J)\n\t    || (dp->op[i].rtn == OP_indirE))\n\t  jump_detection |= 1;\n\telse if ((dp->op[i].rtn == BND_Fixup)\n\t\t || (!dp->op[i].rtn && !dp->op[i].bytemode))\n\t  jump_detection |= 2;\n\telse if ((dp->op[i].bytemode == cond_jump_mode)\n\t\t || (dp->op[i].bytemode == loop_jcxz_mode))\n\t  jump_detection |= 4;\n      }\n\n    /* Determine if this is a jump or branch.  */\n    if ((jump_detection & 0x3) == 0x3)\n      {\n\top_is_jump = TRUE;\n\tif (jump_detection & 0x4)\n\t  the_info->insn_type = dis_condbranch;\n\telse\n\t  the_info->insn_type =\n\t    (dp->name && !strncmp(dp->name, \"call\", 4))\n\t    ? dis_jsr : dis_branch;\n      }\n  }\n\n  /* If VEX.vvvv and EVEX.vvvv are unused, they must be all 1s, which\n     are all 0s in inverted form.  */\n  if (need_vex && vex.register_specifier != 0)\n    {\n      (*info->fprintf_func) (info->stream, \"(bad)\");\n      return end_codep - priv.the_buffer;\n    }\n\n  switch (dp->prefix_requirement)\n    {\n    case PREFIX_DATA:\n      /* If only the data prefix is marked as mandatory, its absence renders\n\t the encoding invalid.  Most other PREFIX_OPCODE rules still apply.  */\n      if (need_vex ? !vex.prefix : !(prefixes & PREFIX_DATA))\n\t{\n\t  (*info->fprintf_func) (info->stream, \"(bad)\");\n\t  return end_codep - priv.the_buffer;\n\t}\n      used_prefixes |= PREFIX_DATA;\n      /* Fall through.  */\n    case PREFIX_OPCODE:\n      /* If the mandatory PREFIX_REPZ/PREFIX_REPNZ/PREFIX_DATA prefix is\n\t unused, opcode is invalid.  Since the PREFIX_DATA prefix may be\n\t used by putop and MMX/SSE operand and may be overridden by the\n\t PREFIX_REPZ/PREFIX_REPNZ fix, we check the PREFIX_DATA prefix\n\t separately.  */\n      if (((need_vex\n\t    ? vex.prefix == REPE_PREFIX_OPCODE\n\t      || vex.prefix == REPNE_PREFIX_OPCODE\n\t    : (prefixes\n\t       & (PREFIX_REPZ | PREFIX_REPNZ)) != 0)\n\t   && (used_prefixes\n\t       & (PREFIX_REPZ | PREFIX_REPNZ)) == 0)\n\t  || (((need_vex\n\t\t? vex.prefix == DATA_PREFIX_OPCODE\n\t\t: ((prefixes\n\t\t    & (PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA))\n\t\t   == PREFIX_DATA))\n\t       && (used_prefixes & PREFIX_DATA) == 0))\n\t  || (vex.evex && dp->prefix_requirement != PREFIX_DATA\n\t      && !vex.w != !(used_prefixes & PREFIX_DATA)))\n\t{\n\t  (*info->fprintf_func) (info->stream, \"(bad)\");\n\t  return end_codep - priv.the_buffer;\n\t}\n      break;\n\n    case PREFIX_IGNORED:\n      /* Zap data size and rep prefixes from used_prefixes and reinstate their\n\t origins in all_prefixes.  */\n      used_prefixes &= ~PREFIX_OPCODE;\n      if (last_data_prefix >= 0)\n\tall_prefixes[last_repz_prefix] = 0x66;\n      if (last_repz_prefix >= 0)\n\tall_prefixes[last_repz_prefix] = 0xf3;\n      if (last_repnz_prefix >= 0)\n\tall_prefixes[last_repnz_prefix] = 0xf2;\n      break;\n    }\n\n  /* Check if the REX prefix is used.  */\n  if ((rex ^ rex_used) == 0 && !need_vex && last_rex_prefix >= 0)\n    all_prefixes[last_rex_prefix] = 0;\n\n  /* Check if the SEG prefix is used.  */\n  if ((prefixes & (PREFIX_CS | PREFIX_SS | PREFIX_DS | PREFIX_ES\n\t\t   | PREFIX_FS | PREFIX_GS)) != 0\n      && (used_prefixes & active_seg_prefix) != 0)\n    all_prefixes[last_seg_prefix] = 0;\n\n  /* Check if the ADDR prefix is used.  */\n  if ((prefixes & PREFIX_ADDR) != 0\n      && (used_prefixes & PREFIX_ADDR) != 0)\n    all_prefixes[last_addr_prefix] = 0;\n\n  /* Check if the DATA prefix is used.  */\n  if ((prefixes & PREFIX_DATA) != 0\n      && (used_prefixes & PREFIX_DATA) != 0\n      && !need_vex)\n    all_prefixes[last_data_prefix] = 0;\n\n  /* Print the extra prefixes.  */\n  prefix_length = 0;\n  for (i = 0; i < (int) ARRAY_SIZE (all_prefixes); i++)\n    if (all_prefixes[i])\n      {\n\tconst char *name;\n\tname = prefix_name (all_prefixes[i], orig_sizeflag);\n\tif (name == NULL)\n\t  abort ();\n\tprefix_length += strlen (name) + 1;\n\t(*info->fprintf_func) (info->stream, \"%s \", name);\n      }\n\n  /* Check maximum code length.  */\n  if ((codep - start_codep) > MAX_CODE_LENGTH)\n    {\n      (*info->fprintf_func) (info->stream, \"(bad)\");\n      return MAX_CODE_LENGTH;\n    }\n\n  obufp = mnemonicendp;\n  for (i = strlen (obuf) + prefix_length; i < 6; i++)\n    oappend (\" \");\n  oappend (\" \");\n  (*info->fprintf_func) (info->stream, \"%s\", obuf);\n\n  /* The enter and bound instructions are printed with operands in the same\n     order as the intel book; everything else is printed in reverse order.  */\n  if (intel_syntax || two_source_ops)\n    {\n      bfd_vma riprel;\n\n      for (i = 0; i < MAX_OPERANDS; ++i)\n\top_txt[i] = op_out[i];\n\n      if (intel_syntax && dp && dp->op[2].rtn == OP_Rounding\n          && dp->op[3].rtn == OP_E && dp->op[4].rtn == NULL)\n\t{\n\t  op_txt[2] = op_out[3];\n\t  op_txt[3] = op_out[2];\n\t}\n\n      for (i = 0; i < (MAX_OPERANDS >> 1); ++i)\n\t{\n\t  op_ad = op_index[i];\n\t  op_index[i] = op_index[MAX_OPERANDS - 1 - i];\n\t  op_index[MAX_OPERANDS - 1 - i] = op_ad;\n\t  riprel = op_riprel[i];\n\t  op_riprel[i] = op_riprel [MAX_OPERANDS - 1 - i];\n\t  op_riprel[MAX_OPERANDS - 1 - i] = riprel;\n\t}\n    }\n  else\n    {\n      for (i = 0; i < MAX_OPERANDS; ++i)\n\top_txt[MAX_OPERANDS - 1 - i] = op_out[i];\n    }\n\n  needcomma = 0;\n  for (i = 0; i < MAX_OPERANDS; ++i)\n    if (*op_txt[i])\n      {\n\tif (needcomma)\n\t  (*info->fprintf_func) (info->stream, \",\");\n\tif (op_index[i] != -1 && !op_riprel[i])\n\t  {\n\t    bfd_vma target = (bfd_vma) op_address[op_index[i]];\n\n\t    if (the_info && op_is_jump)\n\t      {\n\t\tthe_info->insn_info_valid = 1;\n\t\tthe_info->branch_delay_insns = 0;\n\t\tthe_info->data_size = 0;\n\t\tthe_info->target = target;\n\t\tthe_info->target2 = 0;\n\t      }\n\t    (*info->print_address_func) (target, info);\n\t  }\n\telse\n\t  (*info->fprintf_func) (info->stream, \"%s\", op_txt[i]);\n\tneedcomma = 1;\n      }\n\n  for (i = 0; i < MAX_OPERANDS; i++)\n    if (op_index[i] != -1 && op_riprel[i])\n      {\n\t(*info->fprintf_func) (info->stream, \"        # \");\n\t(*info->print_address_func) ((bfd_vma) (start_pc + (codep - start_codep)\n\t\t\t\t\t\t+ op_address[op_index[i]]), info);\n\tbreak;\n      }\n  return codep - priv.the_buffer;\n}\n",
    "target": 1,
    "idx": 1031961,
    "stack_trace": [
      {
        "function_name": "print_insn",
        "function_body": "static int\nprint_insn (bfd_vma pc, disassemble_info *info)\n{\n  const struct dis386 *dp;\n  int i;\n  char *op_txt[MAX_OPERANDS];\n  int needcomma;\n  int sizeflag, orig_sizeflag;\n  const char *p;\n  struct dis_private priv;\n  int prefix_length;\n\n  priv.orig_sizeflag = AFLAG | DFLAG;\n  if ((info->mach & bfd_mach_i386_i386) != 0)\n    address_mode = mode_32bit;\n  else if (info->mach == bfd_mach_i386_i8086)\n    {\n      address_mode = mode_16bit;\n      priv.orig_sizeflag = 0;\n    }\n  else\n    address_mode = mode_64bit;\n\n  if (intel_syntax == (char) -1)\n    intel_syntax = (info->mach & bfd_mach_i386_intel_syntax) != 0;\n\n  for (p = info->disassembler_options; p != NULL; )\n    {\n      if (CONST_STRNEQ (p, \"amd64\"))\n\tisa64 = amd64;\n      else if (CONST_STRNEQ (p, \"intel64\"))\n\tisa64 = intel64;\n      else if (CONST_STRNEQ (p, \"x86-64\"))\n\t{\n\t  address_mode = mode_64bit;\n\t  priv.orig_sizeflag |= AFLAG | DFLAG;\n\t}\n      else if (CONST_STRNEQ (p, \"i386\"))\n\t{\n\t  address_mode = mode_32bit;\n\t  priv.orig_sizeflag |= AFLAG | DFLAG;\n\t}\n      else if (CONST_STRNEQ (p, \"i8086\"))\n\t{\n\t  address_mode = mode_16bit;\n\t  priv.orig_sizeflag &= ~(AFLAG | DFLAG);\n\t}\n      else if (CONST_STRNEQ (p, \"intel\"))\n\t{\n\t  intel_syntax = 1;\n\t  if (CONST_STRNEQ (p + 5, \"-mnemonic\"))\n\t    intel_mnemonic = 1;\n\t}\n      else if (CONST_STRNEQ (p, \"att\"))\n\t{\n\t  intel_syntax = 0;\n\t  if (CONST_STRNEQ (p + 3, \"-mnemonic\"))\n\t    intel_mnemonic = 0;\n\t}\n      else if (CONST_STRNEQ (p, \"addr\"))\n\t{\n\t  if (address_mode == mode_64bit)\n\t    {\n\t      if (p[4] == '3' && p[5] == '2')\n\t\tpriv.orig_sizeflag &= ~AFLAG;\n\t      else if (p[4] == '6' && p[5] == '4')\n\t\tpriv.orig_sizeflag |= AFLAG;\n\t    }\n\t  else\n\t    {\n\t      if (p[4] == '1' && p[5] == '6')\n\t\tpriv.orig_sizeflag &= ~AFLAG;\n\t      else if (p[4] == '3' && p[5] == '2')\n\t\tpriv.orig_sizeflag |= AFLAG;\n\t    }\n\t}\n      else if (CONST_STRNEQ (p, \"data\"))\n\t{\n\t  if (p[4] == '1' && p[5] == '6')\n\t    priv.orig_sizeflag &= ~DFLAG;\n\t  else if (p[4] == '3' && p[5] == '2')\n\t    priv.orig_sizeflag |= DFLAG;\n\t}\n      else if (CONST_STRNEQ (p, \"suffix\"))\n\tpriv.orig_sizeflag |= SUFFIX_ALWAYS;\n\n      p = strchr (p, ',');\n      if (p != NULL)\n\tp++;\n    }\n\n  if (address_mode == mode_64bit && sizeof (bfd_vma) < 8)\n    {\n      (*info->fprintf_func) (info->stream,\n\t\t\t     _(\"64-bit address is disabled\"));\n      return -1;\n    }\n\n  if (intel_syntax)\n    {\n      names64 = intel_names64;\n      names32 = intel_names32;\n      names16 = intel_names16;\n      names8 = intel_names8;\n      names8rex = intel_names8rex;\n      names_seg = intel_names_seg;\n      names_mm = intel_names_mm;\n      names_bnd = intel_names_bnd;\n      names_xmm = intel_names_xmm;\n      names_ymm = intel_names_ymm;\n      names_zmm = intel_names_zmm;\n      names_tmm = intel_names_tmm;\n      index64 = intel_index64;\n      index32 = intel_index32;\n      names_mask = intel_names_mask;\n      index16 = intel_index16;\n      open_char = '[';\n      close_char = ']';\n      separator_char = '+';\n      scale_char = '*';\n    }\n  else\n    {\n      names64 = att_names64;\n      names32 = att_names32;\n      names16 = att_names16;\n      names8 = att_names8;\n      names8rex = att_names8rex;\n      names_seg = att_names_seg;\n      names_mm = att_names_mm;\n      names_bnd = att_names_bnd;\n      names_xmm = att_names_xmm;\n      names_ymm = att_names_ymm;\n      names_zmm = att_names_zmm;\n      names_tmm = att_names_tmm;\n      index64 = att_index64;\n      index32 = att_index32;\n      names_mask = att_names_mask;\n      index16 = att_index16;\n      open_char = '(';\n      close_char =  ')';\n      separator_char = ',';\n      scale_char = ',';\n    }\n\n  /* The output looks better if we put 7 bytes on a line, since that\n     puts most long word instructions on a single line.  Use 8 bytes\n     for Intel L1OM.  */\n  if ((info->mach & bfd_mach_l1om) != 0)\n    info->bytes_per_line = 8;\n  else\n    info->bytes_per_line = 7;\n\n  info->private_data = &priv;\n  priv.max_fetched = priv.the_buffer;\n  priv.insn_start = pc;\n\n  obuf[0] = 0;\n  for (i = 0; i < MAX_OPERANDS; ++i)\n    {\n      op_out[i][0] = 0;\n      op_index[i] = -1;\n    }\n\n  the_info = info;\n  start_pc = pc;\n  start_codep = priv.the_buffer;\n  codep = priv.the_buffer;\n\n  if (OPCODES_SIGSETJMP (priv.bailout) != 0)\n    {\n      const char *name;\n\n      /* Getting here means we tried for data but didn't get it.  That\n\t means we have an incomplete instruction of some sort.  Just\n\t print the first byte as a prefix or a .byte pseudo-op.  */\n      if (codep > priv.the_buffer)\n\t{\n\t  name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\t  if (name != NULL)\n\t    (*info->fprintf_func) (info->stream, \"%s\", name);\n\t  else\n\t    {\n\t      /* Just print the first byte as a .byte instruction.  */\n\t      (*info->fprintf_func) (info->stream, \".byte 0x%x\",\n\t\t\t\t     (unsigned int) priv.the_buffer[0]);\n\t    }\n\n\t  return 1;\n\t}\n\n      return -1;\n    }\n\n  obufp = obuf;\n  sizeflag = priv.orig_sizeflag;\n\n  if (!ckprefix () || rex_used)\n    {\n      /* Too many prefixes or unused REX prefixes.  */\n      for (i = 0;\n\t   i < (int) ARRAY_SIZE (all_prefixes) && all_prefixes[i];\n\t   i++)\n\t(*info->fprintf_func) (info->stream, \"%s%s\",\n\t\t\t       i == 0 ? \"\" : \" \",\n\t\t\t       prefix_name (all_prefixes[i], sizeflag));\n      return i;\n    }\n\n  insn_codep = codep;\n\n  FETCH_DATA (info, codep + 1);\n  two_source_ops = (*codep == 0x62) || (*codep == 0xc8);\n\n  if (((prefixes & PREFIX_FWAIT)\n       && ((*codep < 0xd8) || (*codep > 0xdf))))\n    {\n      /* Handle prefixes before fwait.  */\n      for (i = 0; i < fwait_prefix && all_prefixes[i];\n\t   i++)\n\t(*info->fprintf_func) (info->stream, \"%s \",\n\t\t\t       prefix_name (all_prefixes[i], sizeflag));\n      (*info->fprintf_func) (info->stream, \"fwait\");\n      return i + 1;\n    }\n\n  if (*codep == 0x0f)\n    {\n      unsigned char threebyte;\n\n      codep++;\n      FETCH_DATA (info, codep + 1);\n      threebyte = *codep;\n      dp = &dis386_twobyte[threebyte];\n      need_modrm = twobyte_has_modrm[threebyte];\n      codep++;\n    }\n  else\n    {\n      dp = &dis386[*codep];\n      need_modrm = onebyte_has_modrm[*codep];\n      codep++;\n    }\n\n  /* Save sizeflag for printing the extra prefixes later before updating\n     it for mnemonic and operand processing.  The prefix names depend\n     only on the address mode.  */\n  orig_sizeflag = sizeflag;\n  if (prefixes & PREFIX_ADDR)\n    sizeflag ^= AFLAG;\n  if ((prefixes & PREFIX_DATA))\n    sizeflag ^= DFLAG;\n\n  end_codep = codep;\n  if (need_modrm)\n    {\n      FETCH_DATA (info, codep + 1);\n      modrm.mod = (*codep >> 6) & 3;\n      modrm.reg = (*codep >> 3) & 7;\n      modrm.rm = *codep & 7;\n    }\n  else\n    memset (&modrm, 0, sizeof (modrm));\n\n  need_vex = 0;\n  memset (&vex, 0, sizeof (vex));\n\n  if (dp->name == NULL && dp->op[0].bytemode == FLOATCODE)\n    {\n      get_sib (info, sizeflag);\n      dofloat (sizeflag);\n    }\n  else\n    {\n      dp = get_valid_dis386 (dp, info);\n      if (dp != NULL && putop (dp->name, sizeflag) == 0)\n\t{\n\t  get_sib (info, sizeflag);\n\t  for (i = 0; i < MAX_OPERANDS; ++i)\n\t    {\n\t      obufp = op_out[i];\n\t      op_ad = MAX_OPERANDS - 1 - i;\n\t      if (dp->op[i].rtn)\n\t\t(*dp->op[i].rtn) (dp->op[i].bytemode, sizeflag);\n\t      /* For EVEX instruction after the last operand masking\n\t\t should be printed.  */\n\t      if (i == 0 && vex.evex)\n\t\t{\n\t\t  /* Don't print {%k0}.  */\n\t\t  if (vex.mask_register_specifier)\n\t\t    {\n\t\t      oappend (\"{\");\n\t\t      oappend (names_mask[vex.mask_register_specifier]);\n\t\t      oappend (\"}\");\n\t\t    }\n\t\t  if (vex.zeroing)\n\t\t    oappend (\"{z}\");\n\t\t}\n\t    }\n\t}\n    }\n\n  /* Clear instruction information.  */\n  if (the_info)\n    {\n      the_info->insn_info_valid = 0;\n      the_info->branch_delay_insns = 0;\n      the_info->data_size = 0;\n      the_info->insn_type = dis_noninsn;\n      the_info->target = 0;\n      the_info->target2 = 0;\n    }\n\n  /* Reset jump operation indicator.  */\n  op_is_jump = FALSE;\n\n  {\n    int jump_detection = 0;\n\n    /* Extract flags.  */\n    for (i = 0; i < MAX_OPERANDS; ++i)\n      {\n\tif ((dp->op[i].rtn == OP_J)\n\t    || (dp->op[i].rtn == OP_indirE))\n\t  jump_detection |= 1;\n\telse if ((dp->op[i].rtn == BND_Fixup)\n\t\t || (!dp->op[i].rtn && !dp->op[i].bytemode))\n\t  jump_detection |= 2;\n\telse if ((dp->op[i].bytemode == cond_jump_mode)\n\t\t || (dp->op[i].bytemode == loop_jcxz_mode))\n\t  jump_detection |= 4;\n      }\n\n    /* Determine if this is a jump or branch.  */\n    if ((jump_detection & 0x3) == 0x3)\n      {\n\top_is_jump = TRUE;\n\tif (jump_detection & 0x4)\n\t  the_info->insn_type = dis_condbranch;\n\telse\n\t  the_info->insn_type =\n\t    (dp->name && !strncmp(dp->name, \"call\", 4))\n\t    ? dis_jsr : dis_branch;\n      }\n  }\n\n  /* If VEX.vvvv and EVEX.vvvv are unused, they must be all 1s, which\n     are all 0s in inverted form.  */\n  if (need_vex && vex.register_specifier != 0)\n    {\n      (*info->fprintf_func) (info->stream, \"(bad)\");\n      return end_codep - priv.the_buffer;\n    }\n\n  switch (dp->prefix_requirement)\n    {\n    case PREFIX_DATA:\n      /* If only the data prefix is marked as mandatory, its absence renders\n\t the encoding invalid.  Most other PREFIX_OPCODE rules still apply.  */\n      if (need_vex ? !vex.prefix : !(prefixes & PREFIX_DATA))\n\t{\n\t  (*info->fprintf_func) (info->stream, \"(bad)\");\n\t  return end_codep - priv.the_buffer;\n\t}\n      used_prefixes |= PREFIX_DATA;\n      /* Fall through.  */\n    case PREFIX_OPCODE:\n      /* If the mandatory PREFIX_REPZ/PREFIX_REPNZ/PREFIX_DATA prefix is\n\t unused, opcode is invalid.  Since the PREFIX_DATA prefix may be\n\t used by putop and MMX/SSE operand and may be overridden by the\n\t PREFIX_REPZ/PREFIX_REPNZ fix, we check the PREFIX_DATA prefix\n\t separately.  */\n      if (((need_vex\n\t    ? vex.prefix == REPE_PREFIX_OPCODE\n\t      || vex.prefix == REPNE_PREFIX_OPCODE\n\t    : (prefixes\n\t       & (PREFIX_REPZ | PREFIX_REPNZ)) != 0)\n\t   && (used_prefixes\n\t       & (PREFIX_REPZ | PREFIX_REPNZ)) == 0)\n\t  || (((need_vex\n\t\t? vex.prefix == DATA_PREFIX_OPCODE\n\t\t: ((prefixes\n\t\t    & (PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA))\n\t\t   == PREFIX_DATA))\n\t       && (used_prefixes & PREFIX_DATA) == 0))\n\t  || (vex.evex && dp->prefix_requirement != PREFIX_DATA\n\t      && !vex.w != !(used_prefixes & PREFIX_DATA)))\n\t{\n\t  (*info->fprintf_func) (info->stream, \"(bad)\");\n\t  return end_codep - priv.the_buffer;\n\t}\n      break;\n\n    case PREFIX_IGNORED:\n      /* Zap data size and rep prefixes from used_prefixes and reinstate their\n\t origins in all_prefixes.  */\n      used_prefixes &= ~PREFIX_OPCODE;\n      if (last_data_prefix >= 0)\n\tall_prefixes[last_data_prefix] = 0x66;\n      if (last_repz_prefix >= 0)\n\tall_prefixes[last_repz_prefix] = 0xf3;\n      if (last_repnz_prefix >= 0)\n\tall_prefixes[last_repnz_prefix] = 0xf2;\n      break;\n    }\n\n  /* Check if the REX prefix is used.  */\n  if ((rex ^ rex_used) == 0 && !need_vex && last_rex_prefix >= 0)\n    all_prefixes[last_rex_prefix] = 0;\n\n  /* Check if the SEG prefix is used.  */\n  if ((prefixes & (PREFIX_CS | PREFIX_SS | PREFIX_DS | PREFIX_ES\n\t\t   | PREFIX_FS | PREFIX_GS)) != 0\n      && (used_prefixes & active_seg_prefix) != 0)\n    all_prefixes[last_seg_prefix] = 0;\n\n  /* Check if the ADDR prefix is used.  */\n  if ((prefixes & PREFIX_ADDR) != 0\n      && (used_prefixes & PREFIX_ADDR) != 0)\n    all_prefixes[last_addr_prefix] = 0;\n\n  /* Check if the DATA prefix is used.  */\n  if ((prefixes & PREFIX_DATA) != 0\n      && (used_prefixes & PREFIX_DATA) != 0\n      && !need_vex)\n    all_prefixes[last_data_prefix] = 0;\n\n  /* Print the extra prefixes.  */\n  prefix_length = 0;\n  for (i = 0; i < (int) ARRAY_SIZE (all_prefixes); i++)\n    if (all_prefixes[i])\n      {\n\tconst char *name;\n\tname = prefix_name (all_prefixes[i], orig_sizeflag);\n\tif (name == NULL)\n\t  abort ();\n\tprefix_length += strlen (name) + 1;\n\t(*info->fprintf_func) (info->stream, \"%s \", name);\n      }\n\n  /* Check maximum code length.  */\n  if ((codep - start_codep) > MAX_CODE_LENGTH)\n    {\n      (*info->fprintf_func) (info->stream, \"(bad)\");\n      return MAX_CODE_LENGTH;\n    }\n\n  obufp = mnemonicendp;\n  for (i = strlen (obuf) + prefix_length; i < 6; i++)\n    oappend (\" \");\n  oappend (\" \");\n  (*info->fprintf_func) (info->stream, \"%s\", obuf);\n\n  /* The enter and bound instructions are printed with operands in the same\n     order as the intel book; everything else is printed in reverse order.  */\n  if (intel_syntax || two_source_ops)\n    {\n      bfd_vma riprel;\n\n      for (i = 0; i < MAX_OPERANDS; ++i)\n\top_txt[i] = op_out[i];\n\n      if (intel_syntax && dp && dp->op[2].rtn == OP_Rounding\n          && dp->op[3].rtn == OP_E && dp->op[4].rtn == NULL)\n\t{\n\t  op_txt[2] = op_out[3];\n\t  op_txt[3] = op_out[2];\n\t}\n\n      for (i = 0; i < (MAX_OPERANDS >> 1); ++i)\n\t{\n\t  op_ad = op_index[i];\n\t  op_index[i] = op_index[MAX_OPERANDS - 1 - i];\n\t  op_index[MAX_OPERANDS - 1 - i] = op_ad;\n\t  riprel = op_riprel[i];\n\t  op_riprel[i] = op_riprel [MAX_OPERANDS - 1 - i];\n\t  op_riprel[MAX_OPERANDS - 1 - i] = riprel;\n\t}\n    }\n  else\n    {\n      for (i = 0; i < MAX_OPERANDS; ++i)\n\top_txt[MAX_OPERANDS - 1 - i] = op_out[i];\n    }\n\n  needcomma = 0;\n  for (i = 0; i < MAX_OPERANDS; ++i)\n    if (*op_txt[i])\n      {\n\tif (needcomma)\n\t  (*info->fprintf_func) (info->stream, \",\");\n\tif (op_index[i] != -1 && !op_riprel[i])\n\t  {\n\t    bfd_vma target = (bfd_vma) op_address[op_index[i]];\n\n\t    if (the_info && op_is_jump)\n\t      {\n\t\tthe_info->insn_info_valid = 1;\n\t\tthe_info->branch_delay_insns = 0;\n\t\tthe_info->data_size = 0;\n\t\tthe_info->target = target;\n\t\tthe_info->target2 = 0;\n\t      }\n\t    (*info->print_address_func) (target, info);\n\t  }\n\telse\n\t  (*info->fprintf_func) (info->stream, \"%s\", op_txt[i]);\n\tneedcomma = 1;\n      }\n\n  for (i = 0; i < MAX_OPERANDS; i++)\n    if (op_index[i] != -1 && op_riprel[i])\n      {\n\t(*info->fprintf_func) (info->stream, \"        # \");\n\t(*info->print_address_func) ((bfd_vma) (start_pc + (codep - start_codep)\n\t\t\t\t\t\t+ op_address[op_index[i]]), info);\n\tbreak;\n      }\n  return codep - priv.the_buffer;\n}",
        "file_path": "/src/binutils-gdb/opcodes/i386-dis.c",
        "crashing_line": "\tall_prefixes[last_data_prefix] = 0x66;",
        "crashing_line_number": 9786
      },
      {
        "function_name": "print_insn_i386",
        "function_body": "int\nprint_insn_i386 (bfd_vma pc, disassemble_info *info)\n{\n  intel_syntax = -1;\n\n  return print_insn (pc, info);\n}",
        "file_path": "/src/binutils-gdb/opcodes/i386-dis.c",
        "crashing_line": "  return print_insn (pc, info);",
        "crashing_line_number": 8892
      },
      {
        "function_name": "ExecuteFilesOnyByOne",
        "function_body": "static int ExecuteFilesOnyByOne(int argc, char **argv) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n  for (int i = 1; i < argc; i++) {\n\n    int fd = open(argv[i], O_RDONLY);\n    if (fd == -1) continue;\n    ssize_t length = read(fd, buf, MAX_FILE);\n    if (length > 0) {\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      LLVMFuzzerTestOneInput(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n  }\n\n  free(buf);\n  return 0;\n\n}",
        "file_path": "/src/aflplusplus/utils/aflpp_driver/aflpp_driver.c",
        "crashing_line": "      LLVMFuzzerTestOneInput(buf, length);",
        "crashing_line_number": 185
      },
      {
        "function_name": "main",
        "function_body": "int main(int argc, char **argv) {\n\n  printf(\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for afl++.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before re-spawning the process (default: \"\n      \"1000)\\n\"\n      \"======================================================\\n\",\n      argv[0], argv[0]);\n\n  output_file = stderr;\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize) {\n\n    fprintf(stderr, \"Running LLVMFuzzerInitialize ...\\n\");\n    LLVMFuzzerInitialize(&argc, &argv);\n    fprintf(stderr, \"continue...\\n\");\n\n  }\n\n  // Do any other expensive one-time initialization here.\n\n  uint8_t dummy_input[64] = {0};\n  memcpy(dummy_input, (void *)AFL_PERSISTENT, sizeof(AFL_PERSISTENT));\n  memcpy(dummy_input + 32, (void *)AFL_DEFER_FORKSVR,\n         sizeof(AFL_DEFER_FORKSVR));\n  int N = INT_MAX;\n  if (argc == 2 && argv[1][0] == '-')\n    N = atoi(argv[1] + 1);\n  else if (argc == 2 && (N = atoi(argv[1])) > 0)\n    printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n  else if (argc > 1) {\n\n    __afl_sharedmem_fuzzing = 0;\n    __afl_manual_init();\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  }\n\n  assert(N > 0);\n\n  //  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n  __afl_manual_init();\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n\n#ifdef _DEBUG\n    fprintf(stderr, \"CLIENT crc: %016llx len: %u\\n\",\n            hash64(__afl_fuzz_ptr, *__afl_fuzz_len, 0xa5b35705),\n            *__afl_fuzz_len);\n    fprintf(stderr, \"RECV:\");\n    for (int i = 0; i < *__afl_fuzz_len; i++)\n      fprintf(stderr, \"%02x\", __afl_fuzz_ptr[i]);\n    fprintf(stderr, \"\\n\");\n#endif\n    if (*__afl_fuzz_len) {\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len);\n\n    }\n\n  }\n\n  printf(\"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n\n}",
        "file_path": "/src/aflplusplus/utils/aflpp_driver/aflpp_driver.c",
        "crashing_line": "    return ExecuteFilesOnyByOne(argc, argv);",
        "crashing_line_number": 237
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                    uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  uint8_t* ip = (uint8_t*)input;\n  uint8_t* ip_limit = ip + input_len;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t* buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len <= 0)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip ++;\n  if (ndim != 2) {\n    fprintf(stderr, \"This codec only works for ndim = 2\");\n    return -1;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2];\n  uint32_t ind;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        printf(\"Literal copy \\n\");\n        return 0;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0){    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t)((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t*) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t)(1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t*) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)){ // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t*) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t*) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t*) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        printf(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return 0;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        printf(\"Output size is bigger than max \\n\");\n        return 0;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    printf(\"Output size is not compatible with embedded blockshape \\n\");\n    return 0;\n  }\n  if (ind > (uint32_t) output_len) {\n    printf(\"Output size is bigger than max \\n\");\n    return 0;\n  }\n\n  return (int)ind;\n}\nint ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  uint8_t* ip = (uint8_t*)input;\n  uint8_t* ip_limit = ip + input_len;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t* buffercpy;\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip ++;\n  if (ndim != 2) {\n    fprintf(stderr, \"This codec only works for ndim = 2\");\n    return -1;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / cell_shape;\n  }\n\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2];\n  uint32_t ind = 0;\n  uint8_t* local_buffer = malloc(cell_size);\n  uint8_t* cell_aux = malloc(cell_size);\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        printf(\"Literal copy \\n\");\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n      } else {\n        padding[0] = cell_shape;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n      } else {\n        padding[1] = cell_shape;\n      }\n      token = *ip++;\n      uint8_t match_type = (token >> 3U);\n      if (token == 0){    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t)((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t*) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t)(1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, cell_size);\n        ip++;\n      } else if (match_type == 21) {    // triple match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t*) ip);\n        ip += 2;\n        for (int l = 0; l < 3; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 2)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else if (match_type == 17) {    // pair match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t*) ip);\n        ip += 2;\n        for (int l = 0; l < 2; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 1)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else {\n        printf(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n\n      uint32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      for (uint32_t i = 0; i < (uint32_t) cell_shape; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        printf(\"Output size is bigger than max \\n\");\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n    }\n  }\n  ind += padding[1];\n\n  free(cell_aux);\n  free(local_buffer);\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    printf(\"Output size is not compatible with embedded blockshape \\n\");\n    return 0;\n  }\n  if (ind > (uint32_t) output_len) {\n    printf(\"Output size is bigger than max \\n\");\n    return 0;\n  }\n\n  return (int)ind;\n}\n",
    "target": 1,
    "idx": 1042537,
    "stack_trace": [
      {
        "function_name": "ndlz8_decompress",
        "function_body": "int ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  uint8_t* ip = (uint8_t*)input;\n  uint8_t* ip_limit = ip + input_len;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t* buffercpy;\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip ++;\n  if (ndim != 2) {\n    fprintf(stderr, \"This codec only works for ndim = 2\");\n    return -1;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / cell_shape;\n  }\n\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2];\n  uint32_t ind = 0;\n  uint8_t* local_buffer = malloc(cell_size);\n  uint8_t* cell_aux = malloc(cell_size);\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        printf(\"Literal copy \\n\");\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n      } else {\n        padding[0] = cell_shape;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n      } else {\n        padding[1] = cell_shape;\n      }\n      token = *ip++;\n      uint8_t match_type = (token >> 3U);\n      if (token == 0){    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t)((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t*) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t)(1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, cell_size);\n        ip++;\n      } else if (match_type == 21) {    // triple match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t*) ip);\n        ip += 2;\n        for (int l = 0; l < 3; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 2)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else if (match_type == 17) {    // pair match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t*) ip);\n        ip += 2;\n        for (int l = 0; l < 2; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 1)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else {\n        printf(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n\n      uint32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      for (uint32_t i = 0; i < (uint32_t) cell_shape; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        printf(\"Output size is bigger than max \\n\");\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n    }\n  }\n  ind += padding[1];\n\n  free(cell_aux);\n  free(local_buffer);\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    printf(\"Output size is not compatible with embedded blockshape \\n\");\n    return 0;\n  }\n  if (ind > (uint32_t) output_len) {\n    printf(\"Output size is bigger than max \\n\");\n    return 0;\n  }\n\n  return (int)ind;\n}",
        "file_path": "/src/c-blosc2/plugins/codecs/ndlz/ndlz8x8.c",
        "crashing_line": "  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {",
        "crashing_line_number": 462
      },
      {
        "function_name": "blosc_d",
        "function_body": "static int blosc_d(\n    struct thread_context* thread_context, int32_t bsize,\n    int32_t leftoverblock, bool memcpyed, const uint8_t* src, int32_t srcsize, int32_t src_offset,\n    int32_t nblock, uint8_t* dest, int32_t dest_offset, uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  uint8_t* filters = context->filters;\n  uint8_t *tmp3 = thread_context->tmp4;\n  int32_t compformat = (context->header_flags & (uint8_t)0xe0) >> 5u;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int32_t chunk_nbytes;\n  int32_t chunk_cbytes;\n  int nstreams;\n  int32_t neblock;\n  int32_t nbytes;                /* number of decompressed bytes in split */\n  int32_t cbytes;                /* number of compressed bytes in split */\n  int32_t ctbytes = 0;           /* number of compressed bytes in block */\n  int32_t ntbytes = 0;           /* number of uncompressed bytes in block */\n  uint8_t* _dest;\n  int32_t typesize = context->typesize;\n  bool instr_codec = context->blosc2_flags & BLOSC2_INSTR_CODEC;\n  const char* compname;\n  int rc;\n\n  rc = blosc2_cbuffer_sizes(src, &chunk_nbytes, &chunk_cbytes, NULL);\n  if (rc < 0) {\n    return rc;\n  }\n\n  if (context->block_maskout != NULL && context->block_maskout[nblock]) {\n    // Do not decompress, but act as if we successfully decompressed everything\n    return bsize;\n  }\n\n  // In some situations (lazychunks) the context can arrive uninitialized\n  // (but BITSHUFFLE needs it for accessing the format of the chunk)\n  if (context->src == NULL) {\n    context->src = src;\n  }\n\n  // Chunks with special values cannot be lazy\n  bool is_lazy = ((context->header_overhead == BLOSC_EXTENDED_HEADER_LENGTH) &&\n          (context->blosc2_flags & 0x08u) && !context->special_type);\n  if (is_lazy) {\n    // The chunk is on disk, so just lazily load the block\n    if (context->schunk == NULL) {\n      BLOSC_TRACE_ERROR(\"Lazy chunk needs an associated super-chunk.\");\n      return BLOSC2_ERROR_INVALID_PARAM;\n    }\n    if (context->schunk->frame == NULL) {\n      BLOSC_TRACE_ERROR(\"Lazy chunk needs an associated frame.\");\n      return BLOSC2_ERROR_INVALID_PARAM;\n    }\n    blosc2_frame_s* frame = (blosc2_frame_s*)context->schunk->frame;\n    char* urlpath = frame->urlpath;\n    size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH + context->nblocks * sizeof(int32_t);\n    int32_t nchunk;\n    int64_t chunk_offset;\n    // The nchunk and the offset of the current chunk are in the trailer\n    nchunk = *(int32_t*)(src + trailer_offset);\n    chunk_offset = *(int64_t*)(src + trailer_offset + sizeof(int32_t));\n    // Get the csize of the nblock\n    int32_t *block_csizes = (int32_t *)(src + trailer_offset + sizeof(int32_t) + sizeof(int64_t));\n    int32_t block_csize = block_csizes[nblock];\n    // Read the lazy block on disk\n    void* fp = NULL;\n    blosc2_io_cb *io_cb = blosc2_get_io_cb(context->schunk->storage->io->id);\n    if (io_cb == NULL) {\n      BLOSC_TRACE_ERROR(\"Error getting the input/output API\");\n      return BLOSC2_ERROR_PLUGIN_IO;\n    }\n\n    if (frame->sframe) {\n      // The chunk is not in the frame\n      char* chunkpath = malloc(strlen(frame->urlpath) + 1 + 8 + strlen(\".chunk\") + 1);\n      BLOSC_ERROR_NULL(chunkpath, BLOSC2_ERROR_MEMORY_ALLOC);\n      sprintf(chunkpath, \"%s/%08X.chunk\", frame->urlpath, nchunk);\n      fp = io_cb->open(chunkpath, \"rb\", context->schunk->storage->io->params);\n      BLOSC_ERROR_NULL(fp, BLOSC2_ERROR_FILE_OPEN);\n      free(chunkpath);\n      // The offset of the block is src_offset\n      io_cb->seek(fp, src_offset, SEEK_SET);\n    }\n    else {\n      fp = io_cb->open(urlpath, \"rb\", context->schunk->storage->io->params);\n      BLOSC_ERROR_NULL(fp, BLOSC2_ERROR_FILE_OPEN);\n      // The offset of the block is src_offset\n      io_cb->seek(fp, chunk_offset + src_offset, SEEK_SET);\n    }\n    // We can make use of tmp3 because it will be used after src is not needed anymore\n    int64_t rbytes = io_cb->read(tmp3, 1, block_csize, fp);\n    io_cb->close(fp);\n    if ((int32_t)rbytes != block_csize) {\n      BLOSC_TRACE_ERROR(\"Cannot read the (lazy) block out of the fileframe.\");\n      return BLOSC2_ERROR_READ_BUFFER;\n    }\n    src = tmp3;\n    src_offset = 0;\n    srcsize = block_csize;\n  }\n\n  // If the chunk is memcpyed, we just have to copy the block to dest and return\n  if (memcpyed) {\n    int bsize_ = leftoverblock ? chunk_nbytes % context->blocksize : bsize;\n    if (!context->special_type) {\n      if (chunk_nbytes + context->header_overhead != chunk_cbytes) {\n        return BLOSC2_ERROR_WRITE_BUFFER;\n      }\n      if (chunk_cbytes < context->header_overhead + (nblock * context->blocksize) + bsize_) {\n        /* Not enough input to copy block */\n        return BLOSC2_ERROR_READ_BUFFER;\n      }\n    }\n    if (!is_lazy) {\n      src += context->header_overhead + nblock * context->blocksize;\n    }\n    _dest = dest + dest_offset;\n    if (context->postfilter != NULL) {\n      // We are making use of a postfilter, so use a temp for destination\n      _dest = tmp;\n    }\n    rc = 0;\n    switch (context->special_type) {\n      case BLOSC2_SPECIAL_VALUE:\n        // All repeated values\n        rc = set_values(context->typesize, context->src, _dest, bsize_);\n        if (rc < 0) {\n          BLOSC_TRACE_ERROR(\"set_values failed\");\n          return BLOSC2_ERROR_DATA;\n        }\n        break;\n      case BLOSC2_SPECIAL_NAN:\n        rc = set_nans(context->typesize, _dest, bsize_);\n        if (rc < 0) {\n          BLOSC_TRACE_ERROR(\"set_nans failed\");\n          return BLOSC2_ERROR_DATA;\n        }\n        break;\n      case BLOSC2_SPECIAL_ZERO:\n        memset(_dest, 0, bsize_);\n        break;\n      case BLOSC2_SPECIAL_UNINIT:\n        // We do nothing here\n        break;\n      default:\n        memcpy(_dest, src, bsize_);\n    }\n    if (context->postfilter != NULL) {\n      // Create new postfilter parameters for this block (must be private for each thread)\n      blosc2_postfilter_params postparams;\n      memcpy(&postparams, context->postparams, sizeof(postparams));\n      postparams.in = tmp;\n      postparams.out = dest + dest_offset;\n      postparams.size = bsize;\n      postparams.typesize = typesize;\n      postparams.offset = nblock * context->blocksize;\n      postparams.nchunk = context->schunk != NULL ? context->schunk->current_nchunk : -1;\n      postparams.nblock = nblock;\n      postparams.tid = thread_context->tid;\n      postparams.ttmp = thread_context->tmp;\n      postparams.ttmp_nbytes = thread_context->tmp_nbytes;\n      postparams.ctx = context;\n\n      // Execute the postfilter (the processed block will be copied to dest)\n      if (context->postfilter(&postparams) != 0) {\n        BLOSC_TRACE_ERROR(\"Execution of postfilter function failed\");\n        return BLOSC2_ERROR_POSTFILTER;\n      }\n    }\n    context->zfp_cell_nitems = 0;\n    return bsize_;\n  }\n\n  if (!is_lazy && (src_offset <= 0 || src_offset >= srcsize)) {\n    /* Invalid block src offset encountered */\n    return BLOSC2_ERROR_DATA;\n  }\n\n  src += src_offset;\n  srcsize -= src_offset;\n\n  int last_filter_index = last_filter(filters, 'd');\n  if (instr_codec) {\n    // If instrumented, we don't want to run the filters\n    _dest = dest + dest_offset;\n  }\n  else if (((last_filter_index >= 0) &&\n       (next_filter(filters, BLOSC2_MAX_FILTERS, 'd') != BLOSC_DELTA)) ||\n    context->postfilter != NULL) {\n    // We are making use of some filter, so use a temp for destination\n    _dest = tmp;\n  }\n  else {\n    // If no filters, or only DELTA in pipeline\n    _dest = dest + dest_offset;\n  }\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !context->use_dict) {\n    // We don't want to split when in a training dict state\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n\n  neblock = bsize / nstreams;\n  if (neblock == 0) {\n    /* Not enough space to output bytes */\n    return -1;\n  }\n  for (int j = 0; j < nstreams; j++) {\n    if (srcsize < (signed)sizeof(int32_t)) {\n      /* Not enough input to read compressed size */\n      return BLOSC2_ERROR_READ_BUFFER;\n    }\n    srcsize -= sizeof(int32_t);\n    cbytes = sw32_(src);      /* amount of compressed bytes */\n    if (cbytes > 0) {\n      if (srcsize < cbytes) {\n        /* Not enough input to read compressed bytes */\n        return BLOSC2_ERROR_READ_BUFFER;\n      }\n      srcsize -= cbytes;\n    }\n    src += sizeof(int32_t);\n    ctbytes += (signed)sizeof(int32_t);\n\n    /* Uncompress */\n    if (cbytes == 0) {\n      // A run of 0's\n      memset(_dest, 0, (unsigned int)neblock);\n      nbytes = neblock;\n    }\n    else if (cbytes < 0) {\n      // A negative number means some encoding depending on the token that comes next\n      uint8_t token;\n\n      if (srcsize < (signed)sizeof(uint8_t)) {\n        // Not enough input to read token */\n        return BLOSC2_ERROR_READ_BUFFER;\n      }\n      srcsize -= sizeof(uint8_t);\n\n      token = src[0];\n      src += 1;\n      ctbytes += 1;\n\n      if (token & 0x1) {\n        // A run of bytes that are different than 0\n        if (cbytes < -255) {\n          // Runs can only encode a byte\n          return BLOSC2_ERROR_RUN_LENGTH;\n        }\n        uint8_t value = -cbytes;\n        memset(_dest, value, (unsigned int)neblock);\n      } else {\n        BLOSC_TRACE_ERROR(\"Invalid or unsupported compressed stream token value - %d\", token);\n        return BLOSC2_ERROR_RUN_LENGTH;\n      }\n      nbytes = neblock;\n      cbytes = 0;  // everything is encoded in the cbytes token\n    }\n    else if (cbytes == neblock) {\n      memcpy(_dest, src, (unsigned int)neblock);\n      nbytes = (int32_t)neblock;\n    }\n    else {\n      if (compformat == BLOSC_BLOSCLZ_FORMAT) {\n        nbytes = blosclz_decompress(src, cbytes, _dest, (int)neblock);\n      }\n      else if (compformat == BLOSC_LZ4_FORMAT) {\n        nbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,\n                                     (char*)_dest, (size_t)neblock);\n      }\n  #if defined(HAVE_ZLIB)\n      else if (compformat == BLOSC_ZLIB_FORMAT) {\n        nbytes = zlib_wrap_decompress((char*)src, (size_t)cbytes,\n                                      (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n      else if (compformat == BLOSC_ZSTD_FORMAT) {\n        nbytes = zstd_wrap_decompress(thread_context,\n                                      (char*)src, (size_t)cbytes,\n                                      (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_ZSTD */\n      else if (compformat == BLOSC_UDCODEC_FORMAT) {\n        bool getcell = false;\n\n#if defined(HAVE_PLUGINS)\n        if ((context->compcode == BLOSC_CODEC_ZFP_FIXED_RATE) && (context->zfp_cell_nitems > 0)) {\n          nbytes = zfp_getcell(context, src, cbytes, _dest, neblock);\n          if (nbytes < 0) {\n            return BLOSC2_ERROR_DATA;\n          }\n          if (nbytes == context->zfp_cell_nitems * typesize) {\n            getcell = true;\n          }\n        }\n#endif /* HAVE_PLUGINS */\n        if (!getcell) {\n          context->zfp_cell_nitems = 0;\n          for (int i = 0; i < g_ncodecs; ++i) {\n            if (g_codecs[i].compcode == context->compcode) {\n              blosc2_dparams dparams;\n              blosc2_ctx_get_dparams(context, &dparams);\n              nbytes = g_codecs[i].decoder(src,\n                                           cbytes,\n                                           _dest,\n                                           neblock,\n                                           context->compcode_meta,\n                                           &dparams,\n                                           context->src);\n              goto urcodecsuccess;\n            }\n          }\n          BLOSC_TRACE_ERROR(\"User-defined compressor codec %d not found during decompression\", context->compcode);\n          return BLOSC2_ERROR_CODEC_SUPPORT;\n        }\n      urcodecsuccess:\n        ;\n      }\n      else {\n        compname = clibcode_to_clibname(compformat);\n        BLOSC_TRACE_ERROR(\n                \"Blosc has not been compiled with decompression \"\n                \"support for '%s' format.  \"\n                \"Please recompile for adding this support.\", compname);\n        return BLOSC2_ERROR_CODEC_SUPPORT;\n      }\n\n      /* Check that decompressed bytes number is correct */\n      if ((nbytes != neblock) && (context->zfp_cell_nitems == 0)) {\n        return BLOSC2_ERROR_DATA;\n      }\n\n    }\n    src += cbytes;\n    ctbytes += cbytes;\n    _dest += nbytes;\n    ntbytes += nbytes;\n  } /* Closes j < nstreams */",
        "file_path": "/src/c-blosc2/blosc/blosc2.c",
        "crashing_line": "              nbytes = g_codecs[i].decoder(src,",
        "crashing_line_number": 1754
      },
      {
        "function_name": "serial_blosc",
        "function_body": "static int serial_blosc(struct thread_context* thread_context) {\n  blosc2_context* context = thread_context->parent_context;\n  int32_t j, bsize, leftoverblock;\n  int32_t cbytes;\n  int32_t ntbytes = (int32_t)context->output_bytes;\n  int32_t* bstarts = context->bstarts;\n  uint8_t* tmp = thread_context->tmp;\n  uint8_t* tmp2 = thread_context->tmp2;\n  int dict_training = context->use_dict && (context->dict_cdict == NULL);\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n  if (!context->do_compress && context->special_type) {\n    // Fake a runlen as if it was a memcpyed chunk\n    memcpyed = true;\n  }\n\n  for (j = 0; j < context->nblocks; j++) {\n    if (context->do_compress && !memcpyed && !dict_training) {\n      _sw32(bstarts + j, ntbytes);\n    }\n    bsize = context->blocksize;\n    leftoverblock = 0;\n    if ((j == context->nblocks - 1) && (context->leftover > 0)) {\n      bsize = context->leftover;\n      leftoverblock = 1;\n    }\n    if (context->do_compress) {\n      if (memcpyed && !context->prefilter) {\n        /* We want to memcpy only */\n        memcpy(context->dest + context->header_overhead + j * context->blocksize,\n               context->src + j * context->blocksize, (unsigned int)bsize);\n        cbytes = (int32_t)bsize;\n      }\n      else {\n        /* Regular compression */\n        cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,\n                         context->destsize, context->src, j * context->blocksize,\n                         context->dest + ntbytes, tmp, tmp2);\n        if (cbytes == 0) {\n          ntbytes = 0;              /* uncompressible data */\n          break;\n        }\n      }\n    }\n    else {\n      /* Regular decompression */\n      // If memcpyed we don't have a bstarts section (because it is not needed)\n      int32_t src_offset = memcpyed ?\n          context->header_overhead + j * context->blocksize : sw32_(bstarts + j);\n      cbytes = blosc_d(thread_context, bsize, leftoverblock, memcpyed,\n                       context->src, context->srcsize, src_offset, j,\n                       context->dest, j * context->blocksize, tmp, tmp2);\n    }\n\n    if (cbytes < 0) {\n      ntbytes = cbytes;         /* error in blosc_c or blosc_d */\n      break;\n    }\n    ntbytes += cbytes;\n  }\n\n  return ntbytes;\n}",
        "file_path": "/src/c-blosc2/blosc/blosc2.c",
        "crashing_line": "      cbytes = blosc_d(thread_context, bsize, leftoverblock, memcpyed,",
        "crashing_line_number": 1855
      },
      {
        "function_name": "do_job",
        "function_body": "static int do_job(blosc2_context* context) {\n  int32_t ntbytes;\n\n  /* Set sentinels */\n  context->dref_not_init = 1;\n\n  /* Check whether we need to restart threads */\n  check_nthreads(context);\n\n  /* Run the serial version when nthreads is 1 or when the buffers are\n     not larger than blocksize */\n  if (context->nthreads == 1 || (context->sourcesize / context->blocksize) <= 1) {\n    /* The context for this 'thread' has no been initialized yet */\n    if (context->serial_context == NULL) {\n      context->serial_context = create_thread_context(context, 0);\n    }\n    else if (context->blocksize != context->serial_context->tmp_blocksize) {\n      free_thread_context(context->serial_context);\n      context->serial_context = create_thread_context(context, 0);\n    }\n    BLOSC_ERROR_NULL(context->serial_context, BLOSC2_ERROR_THREAD_CREATE);\n    ntbytes = serial_blosc(context->serial_context);\n  }\n  else {\n    ntbytes = parallel_blosc(context);\n  }\n\n  return ntbytes;\n}",
        "file_path": "/src/c-blosc2/blosc/blosc2.c",
        "crashing_line": "    ntbytes = serial_blosc(context->serial_context);",
        "crashing_line_number": 2020
      },
      {
        "function_name": "blosc_run_decompression_with_context",
        "function_body": "int blosc_run_decompression_with_context(blosc2_context* context, const void* src, int32_t srcsize,\n                                         void* dest, int32_t destsize) {\n  blosc_header header;\n  int32_t ntbytes;\n  int rc;\n\n  rc = read_chunk_header(src, srcsize, true, &header);\n  if (rc < 0) {\n    return rc;\n  }\n\n  if (header.nbytes > destsize) {\n    // Not enough space for writing into the destination\n    return BLOSC2_ERROR_WRITE_BUFFER;\n  }\n\n  rc = initialize_context_decompression(context, &header, src, srcsize, dest, destsize);\n  if (rc < 0) {\n    return rc;\n  }\n\n  /* Do the actual decompression */\n  ntbytes = do_job(context);\n  if (ntbytes < 0) {\n    return ntbytes;\n  }\n\n  assert(ntbytes <= (int32_t)destsize);\n  return ntbytes;\n}",
        "file_path": "/src/c-blosc2/blosc/blosc2.c",
        "crashing_line": "  ntbytes = do_job(context);",
        "crashing_line_number": 2669
      },
      {
        "function_name": "blosc2_decompress",
        "function_body": "int blosc2_decompress(const void* src, int32_t srcsize, void* dest, int32_t destsize) {\n  int result;\n  char* envvar;\n  long nthreads;\n  blosc2_context *dctx;\n  blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n  /* Check for a BLOSC_NTHREADS environment variable */\n  envvar = getenv(\"BLOSC_NTHREADS\");\n  if (envvar != NULL) {\n    nthreads = strtol(envvar, NULL, 10);\n    if ((nthreads != EINVAL) && (nthreads > 0)) {\n      result = blosc_set_nthreads((int16_t)nthreads);\n      if (result < 0) { return result; }\n    }\n  }\n\n  /* Check for a BLOSC_NOLOCK environment variable.  It is important\n     that this should be the last env var so that it can take the\n     previous ones into account */\n  envvar = getenv(\"BLOSC_NOLOCK\");\n  if (envvar != NULL) {\n    dparams.nthreads = g_nthreads;\n    dctx = blosc2_create_dctx(dparams);\n    result = blosc2_decompress_ctx(dctx, src, srcsize, dest, destsize);\n    blosc2_free_ctx(dctx);\n    return result;\n  }\n\n  pthread_mutex_lock(&global_comp_mutex);\n\n  result = blosc_run_decompression_with_context(\n          g_global_context, src, srcsize, dest, destsize);\n\n  pthread_mutex_unlock(&global_comp_mutex);\n\n  return result;\n}",
        "file_path": "/src/c-blosc2/blosc/blosc2.c",
        "crashing_line": "  result = blosc_run_decompression_with_context(",
        "crashing_line_number": 2737
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void RgbFromSingle(const size_t xsize,\n                   const pixel_type* const JXL_RESTRICT row_in,\n                   const float factor, Image3F* decoded, size_t /*c*/, size_t y,\n                   Rect& rect) {\n  const HWY_FULL(float) df;\n  const Rebind<pixel_type, HWY_FULL(float)> di;  // assumes pixel_type <= float\n\n  float* const JXL_RESTRICT row_out_r = rect.PlaneRow(decoded, 0, y);\n  float* const JXL_RESTRICT row_out_g = rect.PlaneRow(decoded, 1, y);\n  float* const JXL_RESTRICT row_out_b = rect.PlaneRow(decoded, 2, y);\n\n  const auto factor_v = Set(df, factor);\n  for (size_t x = 0; x < xsize; x += Lanes(di)) {\n    const auto in = Load(di, row_in + x);\n    const auto out = ConvertTo(df, in) * factor_v;\n    Store(out, df, row_out_r + x);\n    Store(out, df, row_out_g + x);\n    Store(out, df, row_out_b + x);\n  }\n}\nvoid SingleFromSingle(const size_t xsize,\n                      const pixel_type* const JXL_RESTRICT row_in,\n                      const float factor, Image3F* decoded, size_t c, size_t y,\n                      Rect& rect) {\n  const HWY_FULL(float) df;\n  const Rebind<pixel_type, HWY_FULL(float)> di;  // assumes pixel_type <= float\n\n  float* const JXL_RESTRICT row_out = rect.PlaneRow(decoded, c, y);\n\n  const auto factor_v = Set(df, factor);\n  for (size_t x = 0; x < xsize; x += Lanes(di)) {\n    const auto in = Load(di, row_in + x);\n    const auto out = ConvertTo(df, in) * factor_v;\n    Store(out, df, row_out + x);\n  }\n}\nStatus ModularFrameDecoder::DecodeGroup(const Rect& rect, BitReader* reader,\n                                        int minShift, int maxShift,\n                                        const ModularStreamId& stream,\n                                        bool zerofill,\n                                        PassesDecoderState* dec_state,\n                                        ImageBundle* output) {\n  JXL_DASSERT(stream.kind == ModularStreamId::kModularDC ||\n              stream.kind == ModularStreamId::kModularAC);\n  const size_t xsize = rect.xsize();\n  const size_t ysize = rect.ysize();\n  Image gi(xsize, ysize, full_image.bitdepth, 0);\n  // start at the first bigger-than-groupsize non-metachannel\n  size_t c = full_image.nb_meta_channels;\n  for (; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    if (fc.w > frame_dim.group_dim || fc.h > frame_dim.group_dim) break;\n  }\n  size_t beginc = c;\n  for (; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    int shift = std::min(fc.hshift, fc.vshift);\n    if (shift > maxShift) continue;\n    if (shift < minShift) continue;\n    Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n           rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n    if (r.xsize() == 0 || r.ysize() == 0) continue;\n    Channel gc(r.xsize(), r.ysize());\n    gc.hshift = fc.hshift;\n    gc.vshift = fc.vshift;\n    gi.channel.emplace_back(std::move(gc));\n  }\n  if (zerofill) {\n    int gic = 0;\n    for (c = beginc; c < full_image.channel.size(); c++) {\n      Channel& fc = full_image.channel[c];\n      int shift = std::min(fc.hshift, fc.vshift);\n      if (shift > maxShift) continue;\n      if (shift < minShift) continue;\n      Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n             rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n      if (r.xsize() == 0 || r.ysize() == 0) continue;\n      for (size_t y = 0; y < r.ysize(); ++y) {\n        pixel_type* const JXL_RESTRICT row_out = r.Row(&fc.plane, y);\n        memset(row_out, 0, r.xsize() * sizeof(*row_out));\n      }\n      gic++;\n    }\n    return true;\n  }\n  ModularOptions options;\n  if (!ModularGenericDecompress(\n          reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,\n          /*undo_transforms=*/-1, &tree, &code, &context_map))\n    return JXL_FAILURE(\"Failed to decode modular group\");\n  if (minShift == 0) {\n    // Undo global transforms that have been pushed to the group level\n    for (auto t : global_transform) {\n      JXL_RETURN_IF_ERROR(t.Inverse(gi, global_header.wp_header));\n    }\n    if (!use_full_image) {\n      JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(\n          gi, dec_state, nullptr, output, rect.Crop(*output)));\n      return true;\n    }\n  }\n  int gic = 0;\n  for (c = beginc; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    int shift = std::min(fc.hshift, fc.vshift);\n    if (shift > maxShift) continue;\n    if (shift < minShift) continue;\n    Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n           rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n    if (r.xsize() == 0 || r.ysize() == 0) continue;\n    for (size_t y = 0; y < r.ysize(); ++y) {\n      pixel_type* const JXL_RESTRICT row_out = r.Row(&fc.plane, y);\n      const pixel_type* const JXL_RESTRICT row_in = gi.channel[gic].Row(y);\n      for (size_t x = 0; x < r.xsize(); ++x) {\n        row_out[x] = row_in[x];\n      }\n    }\n    gic++;\n  }\n  return true;\n}\nStatus ModularFrameDecoder::ModularImageToDecodedRect(\n    Image& gi, PassesDecoderState* dec_state, jxl::ThreadPool* pool,\n    ImageBundle* output, Rect rect) {\n  auto& decoded = dec_state->decoded;\n  const auto& frame_header = dec_state->shared->frame_header;\n  const auto* metadata = frame_header.nonserialized_metadata;\n  size_t xsize = rect.xsize();\n  size_t ysize = rect.ysize();\n\n  int c = 0;\n  if (do_color) {\n    const bool rgb_from_gray =\n        metadata->m.color_encoding.IsGray() &&\n        frame_header.color_transform == ColorTransform::kNone;\n    const bool fp = metadata->m.bit_depth.floating_point_sample;\n\n    for (; c < 3; c++) {\n      float factor = full_image.bitdepth < 32\n                         ? 1.f / ((1u << full_image.bitdepth) - 1)\n                         : 0;\n      int c_in = c;\n      if (frame_header.color_transform == ColorTransform::kXYB) {\n        factor = dec_state->shared->matrices.DCQuants()[c];\n        // XYB is encoded as YX(B-Y)\n        if (c < 2) c_in = 1 - c;\n      } else if (rgb_from_gray) {\n        c_in = 0;\n      }\n      Channel& ch_in = gi.channel[c_in];\n      // TODO(eustas): could we detect it on earlier stage?\n      if (ch_in.w == 0 || ch_in.h == 0) {\n        return JXL_FAILURE(\"Empty image\");\n      }\n      size_t xsize_shifted = DivCeil(xsize, 1 << ch_in.hshift);\n      size_t ysize_shifted = DivCeil(ysize, 1 << ch_in.vshift);\n      Rect r(rect.x0() >> ch_in.hshift, rect.y0() >> ch_in.vshift,\n             rect.xsize() >> ch_in.hshift, rect.ysize() >> ch_in.vshift,\n             DivCeil(decoded.xsize(), 1 << ch_in.hshift),\n             DivCeil(decoded.ysize(), 1 << ch_in.vshift));\n      if (r.ysize() != ch_in.h || r.xsize() != ch_in.w) {\n        return JXL_FAILURE(\n            \"Dimension mismatch: trying to fit a %zux%zu modular channel into \"\n            \"a %zux%zu rect\",\n            ch_in.w, ch_in.h, r.xsize(), r.ysize());\n      }\n      if (frame_header.color_transform == ColorTransform::kXYB && c == 2) {\n        JXL_ASSERT(!fp);\n        RunOnPool(\n            pool, 0, ysize_shifted, jxl::ThreadPool::SkipInit(),\n            [&](const int task, const int thread) {\n              const size_t y = task;\n              const pixel_type* const JXL_RESTRICT row_in = ch_in.Row(y);\n              const pixel_type* const JXL_RESTRICT row_in_Y =\n                  gi.channel[0].Row(y);\n              float* const JXL_RESTRICT row_out = r.PlaneRow(&decoded, c, y);\n              HWY_DYNAMIC_DISPATCH(MultiplySum)\n              (xsize_shifted, row_in, row_in_Y, factor, row_out);\n            },\n            \"ModularIntToFloat\");\n      } else if (fp) {\n        int bits = metadata->m.bit_depth.bits_per_sample;\n        int exp_bits = metadata->m.bit_depth.exponent_bits_per_sample;\n        RunOnPool(\n            pool, 0, ysize_shifted, jxl::ThreadPool::SkipInit(),\n            [&](const int task, const int thread) {\n              const size_t y = task;\n              const pixel_type* const JXL_RESTRICT row_in = ch_in.Row(y);\n              float* const JXL_RESTRICT row_out = r.PlaneRow(&decoded, c, y);\n              int_to_float(row_in, row_out, xsize_shifted, bits, exp_bits);\n            },\n            \"ModularIntToFloat_losslessfloat\");\n      } else {\n        RunOnPool(\n            pool, 0, ysize_shifted, jxl::ThreadPool::SkipInit(),\n            [&](const int task, const int thread) {\n              const size_t y = task;\n              const pixel_type* const JXL_RESTRICT row_in = ch_in.Row(y);\n              if (rgb_from_gray) {\n                HWY_DYNAMIC_DISPATCH(RgbFromSingle)\n                (xsize_shifted, row_in, factor, &decoded, c, y, r);\n              } else {\n                HWY_DYNAMIC_DISPATCH(SingleFromSingle)\n                (xsize_shifted, row_in, factor, &decoded, c, y, r);\n              }\n            },\n            \"ModularIntToFloat\");\n      }\n      if (rgb_from_gray) {\n        break;\n      }\n    }\n    if (rgb_from_gray) {\n      c = 1;\n    }\n  }\n  for (size_t ec = 0; ec < dec_state->extra_channels.size(); ec++, c++) {\n    const ExtraChannelInfo& eci = output->metadata()->extra_channel_info[ec];\n    int bits = eci.bit_depth.bits_per_sample;\n    int exp_bits = eci.bit_depth.exponent_bits_per_sample;\n    bool fp = eci.bit_depth.floating_point_sample;\n    JXL_ASSERT(fp || bits < 32);\n    const float mul = fp ? 0 : (1.0f / ((1u << bits) - 1));\n    size_t ecups = frame_header.extra_channel_upsampling[ec];\n    const size_t ec_xsize = DivCeil(frame_dim.xsize_upsampled, ecups);\n    const size_t ec_ysize = DivCeil(frame_dim.ysize_upsampled, ecups);\n    Channel& ch_in = gi.channel[c];\n    Rect r(rect.x0() >> ch_in.hshift, rect.y0() >> ch_in.vshift,\n           rect.xsize() >> ch_in.hshift, rect.ysize() >> ch_in.vshift, ec_xsize,\n           ec_ysize);\n    for (size_t y = 0; y < r.ysize(); ++y) {\n      float* const JXL_RESTRICT row_out =\n          r.Row(&dec_state->extra_channels[ec], y);\n      const pixel_type* const JXL_RESTRICT row_in = ch_in.Row(y);\n      if (fp) {\n        int_to_float(row_in, row_out, r.xsize(), bits, exp_bits);\n      } else {\n        for (size_t x = 0; x < r.xsize(); ++x) {\n          row_out[x] = row_in[x] * mul;\n        }\n      }\n    }\n  }\n  return true;\n}\n",
    "target": 1,
    "idx": 1036490,
    "stack_trace": [
      {
        "function_name": "CopyBytes<4, float, float>",
        "function_body": "HWY_API void CopyBytes(const From* from, To* to) {\n#if HWY_COMPILER_MSVC\n  const uint8_t* HWY_RESTRICT from_bytes =\n      reinterpret_cast<const uint8_t*>(from);\n  uint8_t* HWY_RESTRICT to_bytes = reinterpret_cast<uint8_t*>(to);\n  for (size_t i = 0; i < kBytes; ++i) {\n    to_bytes[i] = from_bytes[i];\n  }\n#else\n  // Avoids horrible codegen on Clang (series of PINSRB)\n  __builtin_memcpy(to, from, kBytes);\n#endif\n}",
        "file_path": "/src/libjxl/third_party/highway/hwy/base.h",
        "crashing_line": "  __builtin_memcpy(to, from, kBytes);",
        "crashing_line_number": 638
      },
      {
        "function_name": "Store<float>",
        "function_body": "HWY_INLINE void Store(const Vec1<T> v, Sisd<T> /* tag */,\n                      T* HWY_RESTRICT aligned) {\n  CopyBytes<sizeof(T)>(&v.raw, aligned);\n}",
        "file_path": "/src/libjxl/third_party/highway/hwy/ops/scalar-inl.h",
        "crashing_line": "  CopyBytes<sizeof(T)>(&v.raw, aligned);",
        "crashing_line_number": 806
      },
      {
        "function_name": "SingleFromSingle",
        "function_body": "void SingleFromSingle(const size_t xsize,\n                      const pixel_type* const JXL_RESTRICT row_in,\n                      const float factor, Image3F* decoded, size_t c, size_t y,\n                      Rect& rect) {\n  JXL_DASSERT(xsize <= rect.xsize());\n  const HWY_FULL(float) df;\n  const Rebind<pixel_type, HWY_FULL(float)> di;  // assumes pixel_type <= float\n\n  float* const JXL_RESTRICT row_out = rect.PlaneRow(decoded, c, y);\n\n  const auto factor_v = Set(df, factor);\n  for (size_t x = 0; x < xsize; x += Lanes(di)) {\n    const auto in = Load(di, row_in + x);\n    const auto out = ConvertTo(df, in) * factor_v;\n    Store(out, df, row_out + x);\n  }\n}",
        "file_path": "/src/libjxl/lib/jxl/dec_modular.cc",
        "crashing_line": "    const auto in = Load(di, row_in + x);",
        "crashing_line_number": 85
      },
      {
        "function_name": "SequentialRunnerStatic",
        "function_body": "JxlParallelRetCode ThreadPool::SequentialRunnerStatic(\n    void* runner_opaque, void* jpegxl_opaque, JxlParallelRunInit init,\n    JxlParallelRunFunction func, uint32_t start_range, uint32_t end_range) {\n  JxlParallelRetCode init_ret = (*init)(jpegxl_opaque, 1);\n  if (init_ret != 0) return init_ret;\n\n  for (uint32_t i = start_range; i < end_range; i++) {\n    (*func)(jpegxl_opaque, i, 0);\n  }\n  return 0;\n}",
        "file_path": "/src/libjxl/lib/jxl/base/data_parallel.cc",
        "crashing_line": "    (*func)(jpegxl_opaque, i, 0);",
        "crashing_line_number": 18
      },
      {
        "function_name": "Status",
        "function_body": "",
        "file_path": "/src/libjxl/lib/jxl/base/data_parallel.h",
        "crashing_line": "",
        "crashing_line_number": 51
      },
      {
        "function_name": "Run<",
        "function_body": "  bool Run(uint32_t begin, uint32_t end, const SkipInit /* tag */,\n           const DataFunc& data_func, const char* caller = \"\") {\n    return Run(begin, end, ReturnTrueInit, data_func, caller);\n  }",
        "file_path": "/src/libjxl/lib/jxl/base/data_parallel.h",
        "crashing_line": "    return Run(begin, end, ReturnTrueInit, data_func, caller);",
        "crashing_line_number": 60
      },
      {
        "function_name": "SkipInit,",
        "function_body": "",
        "file_path": "/src/libjxl/lib/jxl/base/data_parallel.h",
        "crashing_line": "",
        "crashing_line_number": 115
      },
      {
        "function_name": "ModularImageToDecodedRect",
        "function_body": "Status ModularFrameDecoder::ModularImageToDecodedRect(\n    Image& gi, PassesDecoderState* dec_state, jxl::ThreadPool* pool,\n    ImageBundle* output, Rect rect) {\n  auto& decoded = dec_state->decoded;\n  const auto& frame_header = dec_state->shared->frame_header;\n  const auto* metadata = frame_header.nonserialized_metadata;\n  size_t xsize = rect.xsize();\n  size_t ysize = rect.ysize();\n  if (!xsize || !ysize) {\n    return true;\n  }\n  JXL_DASSERT(rect.IsInside(decoded));\n\n  int c = 0;\n  if (do_color) {\n    const bool rgb_from_gray =\n        metadata->m.color_encoding.IsGray() &&\n        frame_header.color_transform == ColorTransform::kNone;\n    const bool fp = metadata->m.bit_depth.floating_point_sample;\n\n    for (; c < 3; c++) {\n      float factor = full_image.bitdepth < 32\n                         ? 1.f / ((1u << full_image.bitdepth) - 1)\n                         : 0;\n      int c_in = c;\n      if (frame_header.color_transform == ColorTransform::kXYB) {\n        factor = dec_state->shared->matrices.DCQuants()[c];\n        // XYB is encoded as YX(B-Y)\n        if (c < 2) c_in = 1 - c;\n      } else if (rgb_from_gray) {\n        c_in = 0;\n      }\n      Channel& ch_in = gi.channel[c_in];\n      // TODO(eustas): could we detect it on earlier stage?\n      if (ch_in.w == 0 || ch_in.h == 0) {\n        return JXL_FAILURE(\"Empty image\");\n      }\n      size_t xsize_shifted = DivCeil(xsize, 1 << ch_in.hshift);\n      size_t ysize_shifted = DivCeil(ysize, 1 << ch_in.vshift);\n      Rect r(rect.x0() >> ch_in.hshift, rect.y0() >> ch_in.vshift,\n             rect.xsize() >> ch_in.hshift, rect.ysize() >> ch_in.vshift,\n             DivCeil(decoded.xsize(), 1 << ch_in.hshift),\n             DivCeil(decoded.ysize(), 1 << ch_in.vshift));\n      if (r.ysize() != ch_in.h || r.xsize() != ch_in.w) {\n        return JXL_FAILURE(\n            \"Dimension mismatch: trying to fit a %zux%zu modular channel into \"\n            \"a %zux%zu rect\",\n            ch_in.w, ch_in.h, r.xsize(), r.ysize());\n      }\n      if (frame_header.color_transform == ColorTransform::kXYB && c == 2) {\n        JXL_ASSERT(!fp);\n        RunOnPool(\n            pool, 0, ysize_shifted, jxl::ThreadPool::SkipInit(),\n            [&](const int task, const int thread) {\n              const size_t y = task;\n              const pixel_type* const JXL_RESTRICT row_in = ch_in.Row(y);\n              const pixel_type* const JXL_RESTRICT row_in_Y =\n                  gi.channel[0].Row(y);\n              float* const JXL_RESTRICT row_out = r.PlaneRow(&decoded, c, y);\n              HWY_DYNAMIC_DISPATCH(MultiplySum)\n              (xsize_shifted, row_in, row_in_Y, factor, row_out);\n            },\n            \"ModularIntToFloat\");\n      } else if (fp) {\n        int bits = metadata->m.bit_depth.bits_per_sample;\n        int exp_bits = metadata->m.bit_depth.exponent_bits_per_sample;\n        RunOnPool(\n            pool, 0, ysize_shifted, jxl::ThreadPool::SkipInit(),\n            [&](const int task, const int thread) {\n              const size_t y = task;\n              const pixel_type* const JXL_RESTRICT row_in = ch_in.Row(y);\n              float* const JXL_RESTRICT row_out = r.PlaneRow(&decoded, c, y);\n              int_to_float(row_in, row_out, xsize_shifted, bits, exp_bits);\n            },\n            \"ModularIntToFloat_losslessfloat\");\n      } else {\n        RunOnPool(\n            pool, 0, ysize_shifted, jxl::ThreadPool::SkipInit(),\n            [&](const int task, const int thread) {\n              const size_t y = task;\n              const pixel_type* const JXL_RESTRICT row_in = ch_in.Row(y);\n              if (rgb_from_gray) {\n                HWY_DYNAMIC_DISPATCH(RgbFromSingle)\n                (xsize_shifted, row_in, factor, &decoded, c, y, r);\n              } else {\n                HWY_DYNAMIC_DISPATCH(SingleFromSingle)\n                (xsize_shifted, row_in, factor, &decoded, c, y, r);\n              }\n            },\n            \"ModularIntToFloat\");\n      }\n      if (rgb_from_gray) {\n        break;\n      }\n    }\n    if (rgb_from_gray) {\n      c = 1;\n    }\n  }\n  for (size_t ec = 0; ec < dec_state->extra_channels.size(); ec++, c++) {\n    const ExtraChannelInfo& eci = output->metadata()->extra_channel_info[ec];\n    int bits = eci.bit_depth.bits_per_sample;\n    int exp_bits = eci.bit_depth.exponent_bits_per_sample;\n    bool fp = eci.bit_depth.floating_point_sample;\n    JXL_ASSERT(fp || bits < 32);\n    const float mul = fp ? 0 : (1.0f / ((1u << bits) - 1));\n    size_t ecups = frame_header.extra_channel_upsampling[ec];\n    const size_t ec_xsize = DivCeil(frame_dim.xsize_upsampled, ecups);\n    const size_t ec_ysize = DivCeil(frame_dim.ysize_upsampled, ecups);\n    Channel& ch_in = gi.channel[c];\n    Rect r(rect.x0() >> ch_in.hshift, rect.y0() >> ch_in.vshift,\n           rect.xsize() >> ch_in.hshift, rect.ysize() >> ch_in.vshift, ec_xsize,\n           ec_ysize);\n    for (size_t y = 0; y < r.ysize(); ++y) {\n      float* const JXL_RESTRICT row_out =\n          r.Row(&dec_state->extra_channels[ec], y);\n      const pixel_type* const JXL_RESTRICT row_in = ch_in.Row(y);\n      if (fp) {\n        int_to_float(row_in, row_out, r.xsize(), bits, exp_bits);\n      } else {\n        for (size_t x = 0; x < r.xsize(); ++x) {\n          row_out[x] = row_in[x] * mul;\n        }\n      }\n    }\n  }\n  return true;\n}",
        "file_path": "/src/libjxl/lib/jxl/dec_modular.cc",
        "crashing_line": "              const pixel_type* const JXL_RESTRICT row_in = ch_in.Row(y);",
        "crashing_line_number": 526
      },
      {
        "function_name": "DecodeGroup",
        "function_body": "Status ModularFrameDecoder::DecodeGroup(const Rect& rect, BitReader* reader,\n                                        int minShift, int maxShift,\n                                        const ModularStreamId& stream,\n                                        bool zerofill,\n                                        PassesDecoderState* dec_state,\n                                        ImageBundle* output) {\n  JXL_DASSERT(stream.kind == ModularStreamId::kModularDC ||\n              stream.kind == ModularStreamId::kModularAC);\n  const size_t xsize = rect.xsize();\n  const size_t ysize = rect.ysize();\n  Image gi(xsize, ysize, full_image.bitdepth, 0);\n  // start at the first bigger-than-groupsize non-metachannel\n  size_t c = full_image.nb_meta_channels;\n  for (; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    if (fc.w > frame_dim.group_dim || fc.h > frame_dim.group_dim) break;\n  }\n  size_t beginc = c;\n  for (; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    int shift = std::min(fc.hshift, fc.vshift);\n    if (shift > maxShift) continue;\n    if (shift < minShift) continue;\n    Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n           rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n    if (r.xsize() == 0 || r.ysize() == 0) continue;\n    Channel gc(r.xsize(), r.ysize());\n    gc.hshift = fc.hshift;\n    gc.vshift = fc.vshift;\n    gi.channel.emplace_back(std::move(gc));\n  }\n  if (zerofill) {\n    int gic = 0;\n    for (c = beginc; c < full_image.channel.size(); c++) {\n      Channel& fc = full_image.channel[c];\n      int shift = std::min(fc.hshift, fc.vshift);\n      if (shift > maxShift) continue;\n      if (shift < minShift) continue;\n      Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n             rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n      if (r.xsize() == 0 || r.ysize() == 0) continue;\n      for (size_t y = 0; y < r.ysize(); ++y) {\n        pixel_type* const JXL_RESTRICT row_out = r.Row(&fc.plane, y);\n        memset(row_out, 0, r.xsize() * sizeof(*row_out));\n      }\n      gic++;\n    }\n    return true;\n  }\n  ModularOptions options;\n  if (!ModularGenericDecompress(\n          reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,\n          /*undo_transforms=*/-1, &tree, &code, &context_map))\n    return JXL_FAILURE(\"Failed to decode modular group\");\n  if (minShift == 0) {\n    // Undo global transforms that have been pushed to the group level\n    for (auto t : global_transform) {\n      JXL_RETURN_IF_ERROR(t.Inverse(gi, global_header.wp_header));\n    }\n    if (!use_full_image) {\n      JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(\n          gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded)));\n      return true;\n    }\n  }\n  int gic = 0;\n  for (c = beginc; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    int shift = std::min(fc.hshift, fc.vshift);\n    if (shift > maxShift) continue;\n    if (shift < minShift) continue;\n    Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n           rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n    if (r.xsize() == 0 || r.ysize() == 0) continue;\n    for (size_t y = 0; y < r.ysize(); ++y) {\n      pixel_type* const JXL_RESTRICT row_out = r.Row(&fc.plane, y);\n      const pixel_type* const JXL_RESTRICT row_in = gi.channel[gic].Row(y);\n      for (size_t x = 0; x < r.xsize(); ++x) {\n        row_out[x] = row_in[x];\n      }\n    }\n    gic++;\n  }\n  return true;\n}",
        "file_path": "/src/libjxl/lib/jxl/dec_modular.cc",
        "crashing_line": "    }",
        "crashing_line_number": 309
      },
      {
        "function_name": "ProcessACGroup",
        "function_body": "Status FrameDecoder::ProcessACGroup(size_t ac_group_id,\n                                    BitReader* JXL_RESTRICT* br,\n                                    size_t num_passes, size_t thread,\n                                    bool force_draw, bool dc_only) {\n  PROFILER_ZONE(\"process_group\");\n  const size_t gx = ac_group_id % frame_dim_.xsize_groups;\n  const size_t gy = ac_group_id / frame_dim_.xsize_groups;\n  const size_t x = gx * frame_dim_.group_dim;\n  const size_t y = gy * frame_dim_.group_dim;\n\n  if (frame_header_.encoding == FrameEncoding::kVarDCT) {\n    group_dec_caches_[thread].InitOnce(frame_header_.passes.num_passes,\n                                       dec_state_->used_acs);\n    JXL_RETURN_IF_ERROR(DecodeGroup(\n        br, num_passes, ac_group_id, dec_state_, &group_dec_caches_[thread],\n        thread, decoded_, decoded_passes_per_ac_group_[ac_group_id], force_draw,\n        dc_only));\n  }\n\n  // don't limit to image dimensions here (is done in DecodeGroup)\n  const Rect mrect(x, y, frame_dim_.group_dim, frame_dim_.group_dim);\n  for (size_t i = 0; i < frame_header_.passes.num_passes; i++) {\n    int minShift, maxShift;\n    frame_header_.passes.GetDownsamplingBracket(i, minShift, maxShift);\n    if (i >= decoded_passes_per_ac_group_[ac_group_id] &&\n        i < decoded_passes_per_ac_group_[ac_group_id] + num_passes) {\n      JXL_RETURN_IF_ERROR(modular_frame_decoder_.DecodeGroup(\n          mrect, br[i - decoded_passes_per_ac_group_[ac_group_id]], minShift,\n          maxShift, ModularStreamId::ModularAC(ac_group_id, i),\n          /*zerofill=*/false, dec_state_, decoded_));\n    } else if (i >= decoded_passes_per_ac_group_[ac_group_id] + num_passes &&\n               force_draw) {\n      JXL_RETURN_IF_ERROR(modular_frame_decoder_.DecodeGroup(\n          mrect, nullptr, minShift, maxShift,\n          ModularStreamId::ModularAC(ac_group_id, i), /*zerofill=*/true,\n          dec_state_, decoded_));\n    }\n  }\n  decoded_passes_per_ac_group_[ac_group_id] += num_passes;\n  return true;\n}",
        "file_path": "/src/libjxl/lib/jxl/dec_frame.cc",
        "crashing_line": "      JXL_RETURN_IF_ERROR(modular_frame_decoder_.DecodeGroup(",
        "crashing_line_number": 578
      },
      {
        "function_name": "operator",
        "function_body": "",
        "file_path": "/src/libjxl/lib/jxl/dec_frame.cc",
        "crashing_line": "",
        "crashing_line_number": 731
      },
      {
        "function_name": "ProcessSections",
        "function_body": "",
        "file_path": "/src/libjxl/lib/jxl/base/data_parallel.h",
        "crashing_line": "",
        "crashing_line_number": 88
      },
      {
        "function_name": "RunRange",
        "function_body": "void ThreadParallelRunner::RunRange(ThreadParallelRunner* self,\n                                    const WorkerCommand command,\n                                    const int thread) {\n  const uint32_t begin = command >> 32;\n  const uint32_t end = command & 0xFFFFFFFF;\n  const uint32_t num_tasks = end - begin;\n  const uint32_t num_worker_threads = self->num_worker_threads_;\n\n  // OpenMP introduced several \"schedule\" strategies:\n  // \"single\" (static assignment of exactly one chunk per thread): slower.\n  // \"dynamic\" (allocates k tasks at a time): competitive for well-chosen k.\n  // \"guided\" (allocates k tasks, decreases k): computing k = remaining/n\n  //   is faster than halving k each iteration. We prefer this strategy\n  //   because it avoids user-specified parameters.\n\n  for (;;) {\n#if 0\n      // dynamic\n      const uint32_t my_size = std::max(num_tasks / (num_worker_threads * 4), 1);\n#else\n    // guided\n    const uint32_t num_reserved =\n        self->num_reserved_.load(std::memory_order_relaxed);\n    const uint32_t num_remaining = num_tasks - num_reserved;\n    const uint32_t my_size =\n        std::max(num_remaining / (num_worker_threads * 4), 1u);\n#endif\n    const uint32_t my_begin = begin + self->num_reserved_.fetch_add(\n                                          my_size, std::memory_order_relaxed);\n    const uint32_t my_end = std::min(my_begin + my_size, begin + num_tasks);\n    // Another thread already reserved the last task.\n    if (my_begin >= my_end) {\n      break;\n    }\n    for (uint32_t task = my_begin; task < my_end; ++task) {\n      self->data_func_(self->jpegxl_opaque_, task, thread);\n    }\n  }\n}",
        "file_path": "/src/libjxl/lib/threads/thread_parallel_runner_internal.cc",
        "crashing_line": "      self->data_func_(self->jpegxl_opaque_, task, thread);",
        "crashing_line_number": 137
      },
      {
        "function_name": "ThreadFunc",
        "function_body": "void ThreadParallelRunner::ThreadFunc(ThreadParallelRunner* self,\n                                      const int thread) {\n  // Until kWorkerExit command received:\n  for (;;) {\n    std::unique_lock<std::mutex> lock(self->mutex_);\n    // Notify main thread that this thread is ready.\n    if (++self->workers_ready_ == self->num_threads_) {\n      self->workers_ready_cv_.notify_one();\n    }\n  RESUME_WAIT:\n    // Wait for a command.\n    self->worker_start_cv_.wait(lock);\n    const WorkerCommand command = self->worker_start_command_;\n    switch (command) {\n      case kWorkerWait:    // spurious wakeup:\n        goto RESUME_WAIT;  // lock still held, avoid incrementing ready.\n      case kWorkerOnce:\n        lock.unlock();\n        self->data_func_(self->jpegxl_opaque_, thread, thread);\n        break;\n      case kWorkerExit:\n        return;  // exits thread\n      default:\n        lock.unlock();\n        RunRange(self, command, thread);\n        break;\n    }\n  }\n}",
        "file_path": "/src/libjxl/lib/threads/thread_parallel_runner_internal.cc",
        "crashing_line": "        RunRange(self, command, thread);",
        "crashing_line_number": 167
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static AOM_INLINE void decode_partition(AV1Decoder *const pbi,\n                                        ThreadData *const td, int mi_row,\n                                        int mi_col, aom_reader *reader,\n                                        BLOCK_SIZE bsize,\n                                        int parse_decode_flag) {\n  assert(bsize < BLOCK_SIZES_ALL);\n  AV1_COMMON *const cm = &pbi->common;\n  DecoderCodingBlock *const dcb = &td->dcb;\n  MACROBLOCKD *const xd = &dcb->xd;\n  const int bw = mi_size_wide[bsize];\n  const int hbs = bw >> 1;\n  PARTITION_TYPE partition;\n  BLOCK_SIZE subsize;\n  const int quarter_step = bw / 4;\n  BLOCK_SIZE bsize2 = get_partition_subsize(bsize, PARTITION_SPLIT);\n  const int has_rows = (mi_row + hbs) < cm->mi_params.mi_rows;\n  const int has_cols = (mi_col + hbs) < cm->mi_params.mi_cols;\n\n  if (mi_row >= cm->mi_params.mi_rows || mi_col >= cm->mi_params.mi_cols)\n    return;\n\n  // parse_decode_flag takes the following values :\n  // 01 - do parse only\n  // 10 - do decode only\n  // 11 - do parse and decode\n  static const block_visitor_fn_t block_visit[4] = { NULL, parse_decode_block,\n                                                     decode_block,\n                                                     parse_decode_block };\n\n  if (parse_decode_flag & 1) {\n    const int num_planes = av1_num_planes(cm);\n    for (int plane = 0; plane < num_planes; ++plane) {\n#if CONFIG_REALTIME_ONLY\n      assert(cm->rst_info[plane].frame_restoration_type == RESTORE_NONE);\n#else\n      int rcol0, rcol1, rrow0, rrow1;\n      if (av1_loop_restoration_corners_in_sb(cm, plane, mi_row, mi_col, bsize,\n                                             &rcol0, &rcol1, &rrow0, &rrow1)) {\n        const int rstride = cm->rst_info[plane].horz_units_per_tile;\n        for (int rrow = rrow0; rrow < rrow1; ++rrow) {\n          for (int rcol = rcol0; rcol < rcol1; ++rcol) {\n            const int runit_idx = rcol + rrow * rstride;\n            loop_restoration_read_sb_coeffs(cm, xd, reader, plane, runit_idx);\n          }\n        }\n      }\n#endif\n    }\n\n    partition = (bsize < BLOCK_8X8) ? PARTITION_NONE\n                                    : read_partition(xd, mi_row, mi_col, reader,\n                                                     has_rows, has_cols, bsize);\n  } else {\n    partition = get_partition(cm, mi_row, mi_col, bsize);\n  }\n  subsize = get_partition_subsize(bsize, partition);\n  if (subsize == BLOCK_INVALID) {\n    aom_internal_error(xd->error_info, AOM_CODEC_CORRUPT_FRAME,\n                       \"Partition is invalid for block size %dx%d\",\n                       block_size_wide[bsize], block_size_high[bsize]);\n  }\n  // Check the bitstream is conformant: if there is subsampling on the\n  // chroma planes, subsize must subsample to a valid block size.\n  const struct macroblockd_plane *const pd_u = &xd->plane[1];\n  if (get_plane_block_size(subsize, pd_u->subsampling_x, pd_u->subsampling_y) ==\n      BLOCK_INVALID) {\n    aom_internal_error(xd->error_info, AOM_CODEC_CORRUPT_FRAME,\n                       \"Block size %dx%d invalid with this subsampling mode\",\n                       block_size_wide[subsize], block_size_high[subsize]);\n  }\n\n#define DEC_BLOCK_STX_ARG\n#define DEC_BLOCK_EPT_ARG partition,\n#define DEC_BLOCK(db_r, db_c, db_subsize)                                  \\\n  block_visit[parse_decode_flag](pbi, td, DEC_BLOCK_STX_ARG(db_r), (db_c), \\\n                                 reader, DEC_BLOCK_EPT_ARG(db_subsize))\n#define DEC_PARTITION(db_r, db_c, db_subsize)                        \\\n  decode_partition(pbi, td, DEC_BLOCK_STX_ARG(db_r), (db_c), reader, \\\n                   (db_subsize), parse_decode_flag)\n\n  switch (partition) {\n    case PARTITION_NONE: DEC_BLOCK(mi_row, mi_col, subsize); break;\n    case PARTITION_HORZ:\n      DEC_BLOCK(mi_row, mi_col, subsize);\n      if (has_rows) DEC_BLOCK(mi_row + hbs, mi_col, subsize);\n      break;\n    case PARTITION_VERT:\n      DEC_BLOCK(mi_row, mi_col, subsize);\n      if (has_cols) DEC_BLOCK(mi_row, mi_col + hbs, subsize);\n      break;\n    case PARTITION_SPLIT:\n      DEC_PARTITION(mi_row, mi_col, subsize);\n      DEC_PARTITION(mi_row, mi_col + hbs, subsize);\n      DEC_PARTITION(mi_row + hbs, mi_col, subsize);\n      DEC_PARTITION(mi_row + hbs, mi_col + hbs, subsize);\n      break;\n    case PARTITION_HORZ_A:\n      DEC_BLOCK(mi_row, mi_col, bsize2);\n      DEC_BLOCK(mi_row, mi_col + hbs, bsize2);\n      DEC_BLOCK(mi_row + hbs, mi_col, subsize);\n      break;\n    case PARTITION_HORZ_B:\n      DEC_BLOCK(mi_row, mi_col, subsize);\n      DEC_BLOCK(mi_row + hbs, mi_col, bsize2);\n      DEC_BLOCK(mi_row + hbs, mi_col + hbs, bsize2);\n      break;\n    case PARTITION_VERT_A:\n      DEC_BLOCK(mi_row, mi_col, bsize2);\n      DEC_BLOCK(mi_row + hbs, mi_col, bsize2);\n      DEC_BLOCK(mi_row, mi_col + hbs, subsize);\n      break;\n    case PARTITION_VERT_B:\n      DEC_BLOCK(mi_row, mi_col, subsize);\n      DEC_BLOCK(mi_row, mi_col + hbs, bsize2);\n      DEC_BLOCK(mi_row + hbs, mi_col + hbs, bsize2);\n      break;\n    case PARTITION_HORZ_4:\n      for (int i = 0; i < 4; ++i) {\n        int this_mi_row = mi_row + i * quarter_step;\n        if (i > 0 && this_mi_row >= cm->mi_params.mi_rows) break;\n        DEC_BLOCK(this_mi_row, mi_col, subsize);\n      }\n      break;\n    case PARTITION_VERT_4:\n      for (int i = 0; i < 4; ++i) {\n        int this_mi_col = mi_col + i * quarter_step;\n        if (i > 0 && this_mi_col >= cm->mi_params.mi_cols) break;\n        DEC_BLOCK(mi_row, this_mi_col, subsize);\n      }\n      break;\n    default: assert(0 && \"Invalid partition type\");\n  }\n\n#undef DEC_PARTITION\n#undef DEC_BLOCK\n#undef DEC_BLOCK_EPT_ARG\n#undef DEC_BLOCK_STX_ARG\n\n  if (parse_decode_flag & 1)\n    update_ext_partition_context(xd, mi_row, mi_col, subsize, bsize, partition);\n}\nstatic AOM_INLINE void setup_bool_decoder(\n    const uint8_t *data, const uint8_t *data_end, const size_t read_size,\n    struct aom_internal_error_info *error_info, aom_reader *r,\n    uint8_t allow_update_cdf) {\n  // Validate the calculated partition length. If the buffer\n  // described by the partition can't be fully read, then restrict\n  // it to the portion that can be (for EC mode) or throw an error.\n  if (!read_is_valid(data, read_size, data_end))\n    aom_internal_error(error_info, AOM_CODEC_CORRUPT_FRAME,\n                       \"Truncated packet or corrupt tile length\");\n\n  if (aom_reader_init(r, data, read_size))\n    aom_internal_error(error_info, AOM_CODEC_MEM_ERROR,\n                       \"Failed to allocate bool decoder %d\", 1);\n\n  r->allow_update_cdf = allow_update_cdf;\n}\nstatic AOM_INLINE void setup_segmentation(AV1_COMMON *const cm,\n                                          struct aom_read_bit_buffer *rb) {\n  struct segmentation *const seg = &cm->seg;\n\n  seg->update_map = 0;\n  seg->update_data = 0;\n  seg->temporal_update = 0;\n\n  seg->enabled = aom_rb_read_bit(rb);\n  if (!seg->enabled) {\n    if (cm->cur_frame->seg_map) {\n      memset(cm->cur_frame->seg_map, 0,\n             (cm->cur_frame->mi_rows * cm->cur_frame->mi_cols));\n    }\n\n    memset(seg, 0, sizeof(*seg));\n    segfeatures_copy(&cm->cur_frame->seg, seg);\n    return;\n  }\n  if (cm->seg.enabled && cm->prev_frame &&\n      (cm->mi_params.mi_rows == cm->prev_frame->mi_rows) &&\n      (cm->mi_params.mi_cols == cm->prev_frame->mi_cols)) {\n    cm->last_frame_seg_map = cm->prev_frame->seg_map;\n  } else {\n    cm->last_frame_seg_map = NULL;\n  }\n  // Read update flags\n  if (cm->features.primary_ref_frame == PRIMARY_REF_NONE) {\n    // These frames can't use previous frames, so must signal map + features\n    seg->update_map = 1;\n    seg->temporal_update = 0;\n    seg->update_data = 1;\n  } else {\n    seg->update_map = aom_rb_read_bit(rb);\n    if (seg->update_map) {\n      seg->temporal_update = aom_rb_read_bit(rb);\n    } else {\n      seg->temporal_update = 0;\n    }\n    seg->update_data = aom_rb_read_bit(rb);\n  }\n\n  // Segmentation data update\n  if (seg->update_data) {\n    av1_clearall_segfeatures(seg);\n\n    for (int i = 0; i < MAX_SEGMENTS; i++) {\n      for (int j = 0; j < SEG_LVL_MAX; j++) {\n        int data = 0;\n        const int feature_enabled = aom_rb_read_bit(rb);\n        if (feature_enabled) {\n          av1_enable_segfeature(seg, i, j);\n\n          const int data_max = av1_seg_feature_data_max(j);\n          const int data_min = -data_max;\n          const int ubits = get_unsigned_bits(data_max);\n\n          if (av1_is_segfeature_signed(j)) {\n            data = aom_rb_read_inv_signed_literal(rb, ubits);\n          } else {\n            data = aom_rb_read_literal(rb, ubits);\n          }\n\n          data = clamp(data, data_min, data_max);\n        }\n        av1_set_segdata(seg, i, j, data);\n      }\n    }\n    av1_calculate_segdata(seg);\n  } else if (cm->prev_frame) {\n    segfeatures_copy(seg, &cm->prev_frame->seg);\n  }\n  segfeatures_copy(&cm->cur_frame->seg, seg);\n}\nstatic AOM_INLINE void tile_worker_hook_init(\n    AV1Decoder *const pbi, DecWorkerData *const thread_data,\n    const TileBufferDec *const tile_buffer, TileDataDec *const tile_data,\n    uint8_t allow_update_cdf) {\n  AV1_COMMON *cm = &pbi->common;\n  ThreadData *const td = thread_data->td;\n  int tile_row = tile_data->tile_info.tile_row;\n  int tile_col = tile_data->tile_info.tile_col;\n\n  td->bit_reader = &tile_data->bit_reader;\n  av1_zero(td->cb_buffer_base.dqcoeff);\n\n  MACROBLOCKD *const xd = &td->dcb.xd;\n  av1_tile_init(&xd->tile, cm, tile_row, tile_col);\n  xd->current_base_qindex = cm->quant_params.base_qindex;\n  setup_bool_decoder(tile_buffer->data, thread_data->data_end,\n                     tile_buffer->size, &thread_data->error_info,\n                     td->bit_reader, allow_update_cdf);\n#if CONFIG_ACCOUNTING\n  if (pbi->acct_enabled) {\n    td->bit_reader->accounting = &pbi->accounting;\n    td->bit_reader->accounting->last_tell_frac =\n        aom_reader_tell_frac(td->bit_reader);\n  } else {\n    td->bit_reader->accounting = NULL;\n  }\n#endif\n  av1_init_macroblockd(cm, xd);\n  xd->error_info = &thread_data->error_info;\n  av1_init_above_context(&cm->above_contexts, av1_num_planes(cm), tile_row, xd);\n\n  // Initialise the tile context from the frame context\n  tile_data->tctx = *cm->fc;\n  xd->tile_ctx = &tile_data->tctx;\n#if CONFIG_ACCOUNTING\n  if (pbi->acct_enabled) {\n    tile_data->bit_reader.accounting->last_tell_frac =\n        aom_reader_tell_frac(&tile_data->bit_reader);\n  }\n#endif\n}\n",
    "target": 1,
    "idx": 1044862,
    "stack_trace": [
      {
        "function_name": "sync_write",
        "function_body": "static INLINE void sync_write(AV1DecRowMTSync *const dec_row_mt_sync, int r,\n                              int c, const int sb_cols) {\n#if CONFIG_MULTITHREAD\n  const int nsync = dec_row_mt_sync->sync_range;\n  int cur;\n  int sig = 1;\n\n  if (c < sb_cols - 1) {\n    cur = c;\n    if (c % nsync) sig = 0;\n  } else {\n    cur = sb_cols + nsync;\n  }\n\n  if (sig) {\n    pthread_mutex_lock(&dec_row_mt_sync->mutex_[r]);\n\n    dec_row_mt_sync->cur_sb_col[r] = cur;\n\n    pthread_cond_signal(&dec_row_mt_sync->cond_[r]);\n    pthread_mutex_unlock(&dec_row_mt_sync->mutex_[r]);\n  }\n#else\n  (void)dec_row_mt_sync;\n  (void)r;\n  (void)c;\n  (void)sb_cols;\n#endif  // CONFIG_MULTITHREAD\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "",
        "crashing_line_number": 2567
      },
      {
        "function_name": "signal_decoding_done_for_erroneous_row",
        "function_body": "static INLINE void signal_decoding_done_for_erroneous_row(\n    AV1Decoder *const pbi, const MACROBLOCKD *const xd) {\n  AV1_COMMON *const cm = &pbi->common;\n  const TileInfo *const tile = &xd->tile;\n  const int sb_row_in_tile =\n      ((xd->mi_row - tile->mi_row_start) >> cm->seq_params->mib_size_log2);\n  const int sb_cols_in_tile = av1_get_sb_cols_in_tile(cm, tile);\n  TileDataDec *const tile_data =\n      pbi->tile_data + tile->tile_row * cm->tiles.cols + tile->tile_col;\n  AV1DecRowMTSync *dec_row_mt_sync = &tile_data->dec_row_mt_sync;\n\n  sync_write(dec_row_mt_sync, sb_row_in_tile, sb_cols_in_tile - 1,\n             sb_cols_in_tile);\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "",
        "crashing_line_number": 2591
      },
      {
        "function_name": "row_mt_worker_hook",
        "function_body": "static int row_mt_worker_hook(void *arg1, void *arg2) {\n  DecWorkerData *const thread_data = (DecWorkerData *)arg1;\n  AV1Decoder *const pbi = (AV1Decoder *)arg2;\n  ThreadData *const td = thread_data->td;\n  uint8_t allow_update_cdf;\n  AV1DecRowMTInfo *frame_row_mt_info = &pbi->frame_row_mt_info;\n  td->dcb.corrupted = 0;\n\n  // The jmp_buf is valid only for the duration of the function that calls\n  // setjmp(). Therefore, this function must reset the 'setjmp' field to 0\n  // before it returns.\n  if (setjmp(thread_data->error_info.jmp)) {\n    thread_data->error_info.setjmp = 0;\n    thread_data->td->dcb.corrupted = 1;\n#if CONFIG_MULTITHREAD\n    pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n    frame_row_mt_info->row_mt_exit = 1;\n\n    // If any SB row (erroneous row) processed by a thread encounters an\n    // internal error, there is a need to indicate other threads that decoding\n    // of the erroneous row is complete. This ensures that other threads which\n    // wait upon the completion of SB's present in erroneous row are not waiting\n    // indefinitely.\n    signal_decoding_done_for_erroneous_row(pbi, &thread_data->td->dcb.xd);\n\n#if CONFIG_MULTITHREAD\n    pthread_cond_broadcast(pbi->row_mt_cond_);\n    pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n    return 0;\n  }\n  thread_data->error_info.setjmp = 1;\n\n  AV1_COMMON *cm = &pbi->common;\n  allow_update_cdf = cm->tiles.large_scale ? 0 : 1;\n  allow_update_cdf = allow_update_cdf && !cm->features.disable_cdf_update;\n\n  set_decode_func_pointers(td, 0x1);\n\n  assert(cm->tiles.cols > 0);\n  while (!td->dcb.corrupted) {\n    TileJobsDec *cur_job_info = get_dec_job_info(&pbi->tile_mt_info);\n\n    if (cur_job_info != NULL) {\n      const TileBufferDec *const tile_buffer = cur_job_info->tile_buffer;\n      TileDataDec *const tile_data = cur_job_info->tile_data;\n      tile_worker_hook_init(pbi, thread_data, tile_buffer, tile_data,\n                            allow_update_cdf);\n#if CONFIG_MULTITHREAD\n      pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n      tile_data->dec_row_mt_sync.num_threads_working++;\n#if CONFIG_MULTITHREAD\n      pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n      // decode tile\n      parse_tile_row_mt(pbi, td, tile_data);\n#if CONFIG_MULTITHREAD\n      pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n      tile_data->dec_row_mt_sync.num_threads_working--;\n#if CONFIG_MULTITHREAD\n      pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n    } else {\n      break;\n    }\n  }\n\n  if (td->dcb.corrupted) {\n    thread_data->error_info.setjmp = 0;\n#if CONFIG_MULTITHREAD\n    pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n    frame_row_mt_info->row_mt_exit = 1;\n#if CONFIG_MULTITHREAD\n    pthread_cond_broadcast(pbi->row_mt_cond_);\n    pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n    return 0;\n  }\n\n  set_decode_func_pointers(td, 0x2);\n\n  while (1) {\n    AV1DecRowMTJobInfo next_job_info;\n    int end_of_frame = 0;\n\n#if CONFIG_MULTITHREAD\n    pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n    while (!get_next_job_info(pbi, &next_job_info, &end_of_frame)) {\n#if CONFIG_MULTITHREAD\n      pthread_cond_wait(pbi->row_mt_cond_, pbi->row_mt_mutex_);\n#endif\n    }\n#if CONFIG_MULTITHREAD\n    pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n\n    if (end_of_frame) break;\n\n    int tile_row = next_job_info.tile_row;\n    int tile_col = next_job_info.tile_col;\n    int mi_row = next_job_info.mi_row;\n\n    TileDataDec *tile_data =\n        pbi->tile_data + tile_row * cm->tiles.cols + tile_col;\n    AV1DecRowMTSync *dec_row_mt_sync = &tile_data->dec_row_mt_sync;\n\n    av1_tile_init(&td->dcb.xd.tile, cm, tile_row, tile_col);\n    av1_init_macroblockd(cm, &td->dcb.xd);\n    td->dcb.xd.error_info = &thread_data->error_info;\n\n    decode_tile_sb_row(pbi, td, &tile_data->tile_info, mi_row);\n\n#if CONFIG_MULTITHREAD\n    pthread_mutex_lock(pbi->row_mt_mutex_);\n#endif\n    dec_row_mt_sync->num_threads_working--;\n#if CONFIG_MULTITHREAD\n    pthread_mutex_unlock(pbi->row_mt_mutex_);\n#endif\n  }\n  thread_data->error_info.setjmp = 0;\n  return !td->dcb.corrupted;\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "  ThreadData *const td = thread_data->td;",
        "crashing_line_number": 3185
      },
      {
        "function_name": "execute",
        "function_body": "static void execute(AVxWorker *const worker) {\n  if (worker->hook != NULL) {\n    worker->had_error |= !worker->hook(worker->data1, worker->data2);\n  }\n}",
        "file_path": "/src/aom/aom_util/aom_thread.c",
        "crashing_line": "    worker->had_error |= !worker->hook(worker->data1, worker->data2);",
        "crashing_line_number": 163
      },
      {
        "function_name": "decode_tiles_row_mt",
        "function_body": "static AOM_INLINE void decode_tile(AV1Decoder *pbi, ThreadData *const td,\n                                   int tile_row, int tile_col) {\n  TileInfo tile_info;\n\n  AV1_COMMON *const cm = &pbi->common;\n  const int num_planes = av1_num_planes(cm);\n\n  av1_tile_set_row(&tile_info, cm, tile_row);\n  av1_tile_set_col(&tile_info, cm, tile_col);\n  DecoderCodingBlock *const dcb = &td->dcb;\n  MACROBLOCKD *const xd = &dcb->xd;\n\n  av1_zero_above_context(cm, xd, tile_info.mi_col_start, tile_info.mi_col_end,\n                         tile_row);\n  av1_reset_loop_filter_delta(xd, num_planes);\n  av1_reset_loop_restoration(xd, num_planes);\n\n  for (int mi_row = tile_info.mi_row_start; mi_row < tile_info.mi_row_end;\n       mi_row += cm->seq_params->mib_size) {\n    av1_zero_left_context(xd);\n\n    for (int mi_col = tile_info.mi_col_start; mi_col < tile_info.mi_col_end;\n         mi_col += cm->seq_params->mib_size) {\n      set_cb_buffer(pbi, dcb, &td->cb_buffer_base, num_planes, 0, 0);\n\n      // Bit-stream parsing and decoding of the superblock\n      decode_partition(pbi, td, mi_row, mi_col, td->bit_reader,\n                       cm->seq_params->sb_size, 0x3);\n\n      if (aom_reader_has_overflowed(td->bit_reader)) {\n        aom_merge_corrupted_flag(&dcb->corrupted, 1);\n        return;\n      }\n    }\n  }\n\n  int corrupted =\n      (check_trailing_bits_after_symbol_coder(td->bit_reader)) ? 1 : 0;\n  aom_merge_corrupted_flag(&dcb->corrupted, corrupted);\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "",
        "crashing_line_number": 3819
      },
      {
        "function_name": "av1_decode_tg_tiles_and_wrapup",
        "function_body": "void av1_decode_tg_tiles_and_wrapup(AV1Decoder *pbi, const uint8_t *data,\n                                    const uint8_t *data_end,\n                                    const uint8_t **p_data_end, int start_tile,\n                                    int end_tile, int initialize_flag) {\n  AV1_COMMON *const cm = &pbi->common;\n  CommonTileParams *const tiles = &cm->tiles;\n  MACROBLOCKD *const xd = &pbi->dcb.xd;\n  const int tile_count_tg = end_tile - start_tile + 1;\n\n  if (initialize_flag) setup_frame_info(pbi);\n  const int num_planes = av1_num_planes(cm);\n\n  if (pbi->max_threads > 1 && !(tiles->large_scale && !pbi->ext_tile_debug) &&\n      pbi->row_mt)\n    *p_data_end =\n        decode_tiles_row_mt(pbi, data, data_end, start_tile, end_tile);\n  else if (pbi->max_threads > 1 && tile_count_tg > 1 &&\n           !(tiles->large_scale && !pbi->ext_tile_debug))\n    *p_data_end = decode_tiles_mt(pbi, data, data_end, start_tile, end_tile);\n  else\n    *p_data_end = decode_tiles(pbi, data, data_end, start_tile, end_tile);\n\n  // If the bit stream is monochrome, set the U and V buffers to a constant.\n  if (num_planes < 3) {\n    set_planes_to_neutral_grey(cm->seq_params, xd->cur_buf, 1);\n  }\n\n  if (end_tile != tiles->rows * tiles->cols - 1) {\n    return;\n  }\n\n  av1_alloc_cdef_buffers(cm, &pbi->cdef_worker, &pbi->cdef_sync,\n                         pbi->num_workers, 1);\n  av1_alloc_cdef_sync(cm, &pbi->cdef_sync, pbi->num_workers);\n\n  if (!cm->features.allow_intrabc && !tiles->single_tile_decoding) {\n    if (cm->lf.filter_level[0] || cm->lf.filter_level[1]) {\n      av1_loop_filter_frame_mt(&cm->cur_frame->buf, cm, &pbi->dcb.xd, 0,\n                               num_planes, 0, pbi->tile_workers,\n                               pbi->num_workers, &pbi->lf_row_sync, 0);\n    }\n\n    const int do_cdef =\n        !pbi->skip_loop_filter && !cm->features.coded_lossless &&\n        (cm->cdef_info.cdef_bits || cm->cdef_info.cdef_strengths[0] ||\n         cm->cdef_info.cdef_uv_strengths[0]);\n    const int do_superres = av1_superres_scaled(cm);\n    const int optimized_loop_restoration = !do_cdef && !do_superres;\n\n#if !CONFIG_REALTIME_ONLY\n    const int do_loop_restoration =\n        cm->rst_info[0].frame_restoration_type != RESTORE_NONE ||\n        cm->rst_info[1].frame_restoration_type != RESTORE_NONE ||\n        cm->rst_info[2].frame_restoration_type != RESTORE_NONE;\n    if (!optimized_loop_restoration) {\n      if (do_loop_restoration)\n        av1_loop_restoration_save_boundary_lines(&pbi->common.cur_frame->buf,\n                                                 cm, 0);\n\n      if (do_cdef) {\n        if (pbi->num_workers > 1) {\n          av1_cdef_frame_mt(cm, &pbi->dcb.xd, pbi->cdef_worker,\n                            pbi->tile_workers, &pbi->cdef_sync,\n                            pbi->num_workers, av1_cdef_init_fb_row_mt);\n        } else {\n          av1_cdef_frame(&pbi->common.cur_frame->buf, cm, &pbi->dcb.xd,\n                         av1_cdef_init_fb_row);\n        }\n      }\n\n      superres_post_decode(pbi);\n\n      if (do_loop_restoration) {\n        av1_loop_restoration_save_boundary_lines(&pbi->common.cur_frame->buf,\n                                                 cm, 1);\n        if (pbi->num_workers > 1) {\n          av1_loop_restoration_filter_frame_mt(\n              (YV12_BUFFER_CONFIG *)xd->cur_buf, cm, optimized_loop_restoration,\n              pbi->tile_workers, pbi->num_workers, &pbi->lr_row_sync,\n              &pbi->lr_ctxt);\n        } else {\n          av1_loop_restoration_filter_frame((YV12_BUFFER_CONFIG *)xd->cur_buf,\n                                            cm, optimized_loop_restoration,\n                                            &pbi->lr_ctxt);\n        }\n      }\n    } else {\n      // In no cdef and no superres case. Provide an optimized version of\n      // loop_restoration_filter.\n      if (do_loop_restoration) {\n        if (pbi->num_workers > 1) {\n          av1_loop_restoration_filter_frame_mt(\n              (YV12_BUFFER_CONFIG *)xd->cur_buf, cm, optimized_loop_restoration,\n              pbi->tile_workers, pbi->num_workers, &pbi->lr_row_sync,\n              &pbi->lr_ctxt);\n        } else {\n          av1_loop_restoration_filter_frame((YV12_BUFFER_CONFIG *)xd->cur_buf,\n                                            cm, optimized_loop_restoration,\n                                            &pbi->lr_ctxt);\n        }\n      }\n    }\n#else\n    if (!optimized_loop_restoration) {\n      if (do_cdef) {\n        if (pbi->num_workers > 1) {\n          av1_cdef_frame_mt(cm, &pbi->dcb.xd, pbi->cdef_worker,\n                            pbi->tile_workers, &pbi->cdef_sync,\n                            pbi->num_workers, av1_cdef_init_fb_row_mt);\n        } else {\n          av1_cdef_frame(&pbi->common.cur_frame->buf, cm, &pbi->dcb.xd,\n                         av1_cdef_init_fb_row);\n        }\n      }\n    }\n#endif  // !CONFIG_REALTIME_ONLY\n  }\n\n  if (!pbi->dcb.corrupted) {\n    if (cm->features.refresh_frame_context == REFRESH_FRAME_CONTEXT_BACKWARD) {\n      assert(pbi->context_update_tile_id < pbi->allocated_tiles);\n      *cm->fc = pbi->tile_data[pbi->context_update_tile_id].tctx;\n      av1_reset_cdf_symbol_counters(cm->fc);\n    }\n  } else {\n    aom_internal_error(&pbi->error, AOM_CODEC_CORRUPT_FRAME,\n                       \"Decode failed. Frame data is corrupted.\");\n  }\n\n#if CONFIG_INSPECTION\n  if (pbi->inspect_cb != NULL) {\n    (*pbi->inspect_cb)(pbi, pbi->inspect_ctx);\n  }\n#endif\n\n  // Non frame parallel update frame context here.\n  if (!tiles->large_scale) {\n    cm->cur_frame->frame_context = *cm->fc;\n  }\n}",
        "file_path": "/src/aom/av1/decoder/decodeframe.c",
        "crashing_line": "",
        "crashing_line_number": 5244
      },
      {
        "function_name": "read_one_tile_group_obu",
        "function_body": "static uint32_t read_one_tile_group_obu(\n    AV1Decoder *pbi, struct aom_read_bit_buffer *rb, int is_first_tg,\n    const uint8_t *data, const uint8_t *data_end, const uint8_t **p_data_end,\n    int *is_last_tg, int tile_start_implicit) {\n  AV1_COMMON *const cm = &pbi->common;\n  int start_tile, end_tile;\n  int32_t header_size, tg_payload_size;\n\n  assert((rb->bit_offset & 7) == 0);\n  assert(rb->bit_buffer + aom_rb_bytes_read(rb) == data);\n\n  header_size = read_tile_group_header(pbi, rb, &start_tile, &end_tile,\n                                       tile_start_implicit);\n  if (header_size == -1 || byte_alignment(cm, rb)) return 0;\n  data += header_size;\n  av1_decode_tg_tiles_and_wrapup(pbi, data, data_end, p_data_end, start_tile,\n                                 end_tile, is_first_tg);\n\n  tg_payload_size = (uint32_t)(*p_data_end - data);\n\n  *is_last_tg = end_tile == cm->tiles.rows * cm->tiles.cols - 1;\n  return header_size + tg_payload_size;\n}",
        "file_path": "/src/aom/av1/decoder/obu.c",
        "crashing_line": "  av1_decode_tg_tiles_and_wrapup(pbi, data, data_end, p_data_end, start_tile,",
        "crashing_line_number": 361
      },
      {
        "function_name": "aom_decode_frame_from_obus",
        "function_body": "int aom_decode_frame_from_obus(struct AV1Decoder *pbi, const uint8_t *data,\n                               const uint8_t *data_end,\n                               const uint8_t **p_data_end) {\n  AV1_COMMON *const cm = &pbi->common;\n  int frame_decoding_finished = 0;\n  int is_first_tg_obu_received = 1;\n  // Whenever pbi->seen_frame_header is set to 1, frame_header is set to the\n  // beginning of the frame_header_obu and frame_header_size is set to its\n  // size. This allows us to check if a redundant frame_header_obu is a copy\n  // of the previous frame_header_obu.\n  //\n  // Initialize frame_header to a dummy nonnull pointer, otherwise the Clang\n  // Static Analyzer in clang 7.0.1 will falsely warn that a null pointer is\n  // passed as an argument to a 'nonnull' parameter of memcmp(). The initial\n  // value will not be used.\n  const uint8_t *frame_header = data;\n  uint32_t frame_header_size = 0;\n  ObuHeader obu_header;\n  memset(&obu_header, 0, sizeof(obu_header));\n  pbi->seen_frame_header = 0;\n  pbi->next_start_tile = 0;\n  pbi->num_tile_groups = 0;\n\n  if (data_end < data) {\n    pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n    return -1;\n  }\n\n  // Reset pbi->camera_frame_header_ready to 0 if cm->tiles.large_scale = 0.\n  if (!cm->tiles.large_scale) pbi->camera_frame_header_ready = 0;\n\n  // decode frame as a series of OBUs\n  while (!frame_decoding_finished && pbi->error.error_code == AOM_CODEC_OK) {\n    struct aom_read_bit_buffer rb;\n    size_t payload_size = 0;\n    size_t decoded_payload_size = 0;\n    size_t obu_payload_offset = 0;\n    size_t bytes_read = 0;\n    const size_t bytes_available = data_end - data;\n\n    if (bytes_available == 0 && !pbi->seen_frame_header) {\n      *p_data_end = data;\n      pbi->error.error_code = AOM_CODEC_OK;\n      break;\n    }\n\n    aom_codec_err_t status =\n        aom_read_obu_header_and_size(data, bytes_available, pbi->is_annexb,\n                                     &obu_header, &payload_size, &bytes_read);\n\n    if (status != AOM_CODEC_OK) {\n      pbi->error.error_code = status;\n      return -1;\n    }\n\n    // Record obu size header information.\n    pbi->obu_size_hdr.data = data + obu_header.size;\n    pbi->obu_size_hdr.size = bytes_read - obu_header.size;\n\n    // Note: aom_read_obu_header_and_size() takes care of checking that this\n    // doesn't cause 'data' to advance past 'data_end'.\n    data += bytes_read;\n\n    if ((size_t)(data_end - data) < payload_size) {\n      pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n      return -1;\n    }\n\n    cm->temporal_layer_id = obu_header.temporal_layer_id;\n    cm->spatial_layer_id = obu_header.spatial_layer_id;\n\n    if (obu_header.type != OBU_TEMPORAL_DELIMITER &&\n        obu_header.type != OBU_SEQUENCE_HEADER) {\n      // don't decode obu if it's not in current operating mode\n      if (!is_obu_in_current_operating_point(pbi, &obu_header)) {\n        data += payload_size;\n        continue;\n      }\n    }\n\n    av1_init_read_bit_buffer(pbi, &rb, data, data + payload_size);\n\n    switch (obu_header.type) {\n      case OBU_TEMPORAL_DELIMITER:\n        decoded_payload_size = read_temporal_delimiter_obu();\n        if (pbi->seen_frame_header) {\n          // A new temporal unit has started, but the frame in the previous\n          // temporal unit is incomplete.\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n        break;\n      case OBU_SEQUENCE_HEADER:\n        decoded_payload_size = read_sequence_header_obu(pbi, &rb);\n        if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n        // The sequence header should not change in the middle of a frame.\n        if (pbi->sequence_header_changed && pbi->seen_frame_header) {\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n        break;\n      case OBU_FRAME_HEADER:\n      case OBU_REDUNDANT_FRAME_HEADER:\n      case OBU_FRAME:\n        if (obu_header.type == OBU_REDUNDANT_FRAME_HEADER) {\n          if (!pbi->seen_frame_header) {\n            pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n            return -1;\n          }\n        } else {\n          // OBU_FRAME_HEADER or OBU_FRAME.\n          if (pbi->seen_frame_header) {\n            pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n            return -1;\n          }\n        }\n        // Only decode first frame header received\n        if (!pbi->seen_frame_header ||\n            (cm->tiles.large_scale && !pbi->camera_frame_header_ready)) {\n          frame_header_size = read_frame_header_obu(\n              pbi, &rb, data, p_data_end, obu_header.type != OBU_FRAME);\n          frame_header = data;\n          pbi->seen_frame_header = 1;\n          if (!pbi->ext_tile_debug && cm->tiles.large_scale)\n            pbi->camera_frame_header_ready = 1;\n        } else {\n          // Verify that the frame_header_obu is identical to the original\n          // frame_header_obu.\n          if (frame_header_size > payload_size ||\n              memcmp(data, frame_header, frame_header_size) != 0) {\n            pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n            return -1;\n          }\n          assert(rb.bit_offset == 0);\n          rb.bit_offset = 8 * frame_header_size;\n        }\n\n        decoded_payload_size = frame_header_size;\n        pbi->frame_header_size = frame_header_size;\n        cm->cur_frame->temporal_id = obu_header.temporal_layer_id;\n        cm->cur_frame->spatial_id = obu_header.spatial_layer_id;\n\n        if (cm->show_existing_frame) {\n          if (obu_header.type == OBU_FRAME) {\n            pbi->error.error_code = AOM_CODEC_UNSUP_BITSTREAM;\n            return -1;\n          }\n          frame_decoding_finished = 1;\n          pbi->seen_frame_header = 0;\n          break;\n        }\n\n        // In large scale tile coding, decode the common camera frame header\n        // before any tile list OBU.\n        if (!pbi->ext_tile_debug && pbi->camera_frame_header_ready) {\n          frame_decoding_finished = 1;\n          // Skip the rest of the frame data.\n          decoded_payload_size = payload_size;\n          // Update data_end.\n          *p_data_end = data_end;\n          break;\n        }\n\n        if (obu_header.type != OBU_FRAME) break;\n        obu_payload_offset = frame_header_size;\n        // Byte align the reader before reading the tile group.\n        // byte_alignment() has set pbi->error.error_code if it returns -1.\n        if (byte_alignment(cm, &rb)) return -1;\n        AOM_FALLTHROUGH_INTENDED;  // fall through to read tile group.\n      case OBU_TILE_GROUP:\n        if (!pbi->seen_frame_header) {\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n        if (obu_payload_offset > payload_size) {\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n        decoded_payload_size += read_one_tile_group_obu(\n            pbi, &rb, is_first_tg_obu_received, data + obu_payload_offset,\n            data + payload_size, p_data_end, &frame_decoding_finished,\n            obu_header.type == OBU_FRAME);\n        if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n        is_first_tg_obu_received = 0;\n        if (frame_decoding_finished) {\n          pbi->seen_frame_header = 0;\n          pbi->next_start_tile = 0;\n        }\n        pbi->num_tile_groups++;\n        break;\n      case OBU_METADATA:\n        decoded_payload_size = read_metadata(pbi, data, payload_size);\n        if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n        break;\n      case OBU_TILE_LIST:\n        if (CONFIG_NORMAL_TILE_MODE) {\n          pbi->error.error_code = AOM_CODEC_UNSUP_BITSTREAM;\n          return -1;\n        }\n\n        // This OBU type is purely for the large scale tile coding mode.\n        // The common camera frame header has to be already decoded.\n        if (!pbi->camera_frame_header_ready) {\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n\n        cm->tiles.large_scale = 1;\n        av1_set_single_tile_decoding_mode(cm);\n        decoded_payload_size =\n            read_and_decode_one_tile_list(pbi, &rb, data, data + payload_size,\n                                          p_data_end, &frame_decoding_finished);\n        if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n        break;\n      case OBU_PADDING:\n        decoded_payload_size = read_padding(cm, data, payload_size);\n        if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n        break;\n      default:\n        // Skip unrecognized OBUs\n        if (payload_size > 0 &&\n            get_last_nonzero_byte(data, payload_size) == 0) {\n          pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n          return -1;\n        }\n        decoded_payload_size = payload_size;\n        break;\n    }\n\n    // Check that the signalled OBU size matches the actual amount of data read\n    if (decoded_payload_size > payload_size) {\n      pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n      return -1;\n    }\n\n    // If there are extra padding bytes, they should all be zero\n    while (decoded_payload_size < payload_size) {\n      uint8_t padding_byte = data[decoded_payload_size++];\n      if (padding_byte != 0) {\n        pbi->error.error_code = AOM_CODEC_CORRUPT_FRAME;\n        return -1;\n      }\n    }\n\n    data += payload_size;\n  }\n\n  if (pbi->error.error_code != AOM_CODEC_OK) return -1;\n  return frame_decoding_finished;\n}",
        "file_path": "/src/aom/av1/decoder/obu.c",
        "crashing_line": "        decoded_payload_size += read_one_tile_group_obu(",
        "crashing_line_number": 1025
      },
      {
        "function_name": "av1_receive_compressed_data",
        "function_body": "int av1_receive_compressed_data(AV1Decoder *pbi, size_t size,\n                                const uint8_t **psource) {\n  AV1_COMMON *volatile const cm = &pbi->common;\n  const uint8_t *source = *psource;\n  pbi->error.error_code = AOM_CODEC_OK;\n  pbi->error.has_detail = 0;\n\n  if (size == 0) {\n    // This is used to signal that we are missing frames.\n    // We do not know if the missing frame(s) was supposed to update\n    // any of the reference buffers, but we act conservative and\n    // mark only the last buffer as corrupted.\n    //\n    // TODO(jkoleszar): Error concealment is undefined and non-normative\n    // at this point, but if it becomes so, [0] may not always be the correct\n    // thing to do here.\n    RefCntBuffer *ref_buf = get_ref_frame_buf(cm, LAST_FRAME);\n    if (ref_buf != NULL) ref_buf->buf.corrupted = 1;\n  }\n\n  if (assign_cur_frame_new_fb(cm) == NULL) {\n    pbi->error.error_code = AOM_CODEC_MEM_ERROR;\n    return 1;\n  }\n\n  // The jmp_buf is valid only for the duration of the function that calls\n  // setjmp(). Therefore, this function must reset the 'setjmp' field to 0\n  // before it returns.\n  if (setjmp(pbi->error.jmp)) {\n    const AVxWorkerInterface *const winterface = aom_get_worker_interface();\n    int i;\n\n    pbi->error.setjmp = 0;\n\n    // Synchronize all threads immediately as a subsequent decode call may\n    // cause a resize invalidating some allocations.\n    winterface->sync(&pbi->lf_worker);\n    for (i = 0; i < pbi->num_workers; ++i) {\n      winterface->sync(&pbi->tile_workers[i]);\n    }\n\n    release_current_frame(pbi);\n    return -1;\n  }\n\n  pbi->error.setjmp = 1;\n\n  int frame_decoded =\n      aom_decode_frame_from_obus(pbi, source, source + size, psource);\n\n  if (frame_decoded < 0) {\n    assert(pbi->error.error_code != AOM_CODEC_OK);\n    release_current_frame(pbi);\n    pbi->error.setjmp = 0;\n    return 1;\n  }\n\n#if TXCOEFF_TIMER\n  cm->cum_txcoeff_timer += cm->txcoeff_timer;\n  fprintf(stderr,\n          \"txb coeff block number: %d, frame time: %ld, cum time %ld in us\\n\",\n          cm->txb_count, cm->txcoeff_timer, cm->cum_txcoeff_timer);\n  cm->txcoeff_timer = 0;\n  cm->txb_count = 0;\n#endif\n\n  // Note: At this point, this function holds a reference to cm->cur_frame\n  // in the buffer pool. This reference is consumed by update_frame_buffers().\n  update_frame_buffers(pbi, frame_decoded);\n\n  if (frame_decoded) {\n    pbi->decoding_first_frame = 0;\n  }\n\n  if (pbi->error.error_code != AOM_CODEC_OK) {\n    pbi->error.setjmp = 0;\n    return 1;\n  }\n\n  if (!cm->show_existing_frame) {\n    if (cm->seg.enabled) {\n      if (cm->prev_frame &&\n          (cm->mi_params.mi_rows == cm->prev_frame->mi_rows) &&\n          (cm->mi_params.mi_cols == cm->prev_frame->mi_cols)) {\n        cm->last_frame_seg_map = cm->prev_frame->seg_map;\n      } else {\n        cm->last_frame_seg_map = NULL;\n      }\n    }\n  }\n\n  // Update progress in frame parallel decode.\n  pbi->error.setjmp = 0;\n\n  return 0;\n}",
        "file_path": "/src/aom/av1/decoder/decoder.c",
        "crashing_line": "      aom_decode_frame_from_obus(pbi, source, source + size, psource);",
        "crashing_line_number": 474
      },
      {
        "function_name": "frame_worker_hook",
        "function_body": "static int frame_worker_hook(void *arg1, void *arg2) {\n  FrameWorkerData *const frame_worker_data = (FrameWorkerData *)arg1;\n  const uint8_t *data = frame_worker_data->data;\n  (void)arg2;\n\n  int result = av1_receive_compressed_data(frame_worker_data->pbi,\n                                           frame_worker_data->data_size, &data);\n  frame_worker_data->data_end = data;\n\n  if (result != 0) {\n    // Check decode result in serial decode.\n    frame_worker_data->pbi->need_resync = 1;\n  }\n  return !result;\n}",
        "file_path": "/src/aom/av1/av1_dx_iface.c",
        "crashing_line": "  int result = av1_receive_compressed_data(frame_worker_data->pbi,",
        "crashing_line_number": 412
      },
      {
        "function_name": "execute",
        "function_body": "static void execute(AVxWorker *const worker) {\n  if (worker->hook != NULL) {\n    worker->had_error |= !worker->hook(worker->data1, worker->data2);\n  }\n}",
        "file_path": "/src/aom/aom_util/aom_thread.c",
        "crashing_line": "    worker->had_error |= !worker->hook(worker->data1, worker->data2);",
        "crashing_line_number": 163
      },
      {
        "function_name": "decode_one",
        "function_body": "static aom_codec_err_t decode_one(aom_codec_alg_priv_t *ctx,\n                                  const uint8_t **data, size_t data_sz,\n                                  void *user_priv) {\n  const AVxWorkerInterface *const winterface = aom_get_worker_interface();\n\n  // Determine the stream parameters. Note that we rely on peek_si to\n  // validate that we have a buffer that does not wrap around the top\n  // of the heap.\n  if (!ctx->si.h) {\n    int is_intra_only = 0;\n    ctx->si.is_annexb = ctx->is_annexb;\n    const aom_codec_err_t res =\n        decoder_peek_si_internal(*data, data_sz, &ctx->si, &is_intra_only);\n    if (res != AOM_CODEC_OK) return res;\n\n    if (!ctx->si.is_kf && !is_intra_only) return AOM_CODEC_ERROR;\n  }\n\n  AVxWorker *const worker = ctx->frame_worker;\n  FrameWorkerData *const frame_worker_data = (FrameWorkerData *)worker->data1;\n  frame_worker_data->data = *data;\n  frame_worker_data->data_size = data_sz;\n  frame_worker_data->user_priv = user_priv;\n  frame_worker_data->received_frame = 1;\n\n  frame_worker_data->pbi->common.tiles.large_scale = ctx->tile_mode;\n  frame_worker_data->pbi->dec_tile_row = ctx->decode_tile_row;\n  frame_worker_data->pbi->dec_tile_col = ctx->decode_tile_col;\n  frame_worker_data->pbi->ext_tile_debug = ctx->ext_tile_debug;\n  frame_worker_data->pbi->row_mt = ctx->row_mt;\n  frame_worker_data->pbi->ext_refs = ctx->ext_refs;\n\n  frame_worker_data->pbi->is_annexb = ctx->is_annexb;\n\n  worker->had_error = 0;\n  winterface->execute(worker);\n\n  // Update data pointer after decode.\n  *data = frame_worker_data->data_end;\n\n  if (worker->had_error)\n    return update_error_state(ctx, &frame_worker_data->pbi->error);\n\n  check_resync(ctx, frame_worker_data->pbi);\n\n  return AOM_CODEC_OK;\n}",
        "file_path": "/src/aom/av1/av1_dx_iface.c",
        "crashing_line": "  winterface->execute(worker);",
        "crashing_line_number": 529
      },
      {
        "function_name": "decoder_decode",
        "function_body": "static aom_codec_err_t decoder_decode(aom_codec_alg_priv_t *ctx,\n                                      const uint8_t *data, size_t data_sz,\n                                      void *user_priv) {\n  aom_codec_err_t res = AOM_CODEC_OK;\n\n#if CONFIG_INSPECTION\n  if (user_priv != 0) {\n    return decoder_inspect(ctx, data, data_sz, user_priv);\n  }\n#endif\n\n  release_pending_output_frames(ctx);\n\n  /* Sanity checks */\n  /* NULL data ptr allowed if data_sz is 0 too */\n  if (data == NULL && data_sz == 0) {\n    ctx->flushed = 1;\n    return AOM_CODEC_OK;\n  }\n  if (data == NULL || data_sz == 0) return AOM_CODEC_INVALID_PARAM;\n\n  // Reset flushed when receiving a valid frame.\n  ctx->flushed = 0;\n\n  // Initialize the decoder worker on the first frame.\n  if (ctx->frame_worker == NULL) {\n    res = init_decoder(ctx);\n    if (res != AOM_CODEC_OK) return res;\n  }\n\n  const uint8_t *data_start = data;\n  const uint8_t *data_end = data + data_sz;\n\n  if (ctx->is_annexb) {\n    // read the size of this temporal unit\n    size_t length_of_size;\n    uint64_t temporal_unit_size;\n    if (aom_uleb_decode(data_start, data_sz, &temporal_unit_size,\n                        &length_of_size) != 0) {\n      return AOM_CODEC_CORRUPT_FRAME;\n    }\n    data_start += length_of_size;\n    if (temporal_unit_size > (size_t)(data_end - data_start))\n      return AOM_CODEC_CORRUPT_FRAME;\n    data_end = data_start + temporal_unit_size;\n  }\n\n  // Decode in serial mode.\n  while (data_start < data_end) {\n    uint64_t frame_size;\n    if (ctx->is_annexb) {\n      // read the size of this frame unit\n      size_t length_of_size;\n      if (aom_uleb_decode(data_start, (size_t)(data_end - data_start),\n                          &frame_size, &length_of_size) != 0) {\n        return AOM_CODEC_CORRUPT_FRAME;\n      }\n      data_start += length_of_size;\n      if (frame_size > (size_t)(data_end - data_start))\n        return AOM_CODEC_CORRUPT_FRAME;\n    } else {\n      frame_size = (uint64_t)(data_end - data_start);\n    }\n\n    res = decode_one(ctx, &data_start, (size_t)frame_size, user_priv);\n    if (res != AOM_CODEC_OK) return res;\n\n    // Allow extra zero bytes after the frame end\n    while (data_start < data_end) {\n      const uint8_t marker = data_start[0];\n      if (marker) break;\n      ++data_start;\n    }\n  }\n\n  return res;\n}",
        "file_path": "/src/aom/av1/av1_dx_iface.c",
        "crashing_line": "    res = decode_one(ctx, &data_start, (size_t)frame_size, user_priv);",
        "crashing_line_number": 716
      },
      {
        "function_name": "aom_codec_decode",
        "function_body": "aom_codec_err_t aom_codec_decode(aom_codec_ctx_t *ctx, const uint8_t *data,\n                                 size_t data_sz, void *user_priv) {\n  aom_codec_err_t res;\n\n  if (!ctx)\n    res = AOM_CODEC_INVALID_PARAM;\n  else if (!ctx->iface || !ctx->priv)\n    res = AOM_CODEC_ERROR;\n  else {\n    res = ctx->iface->dec.decode(get_alg_priv(ctx), data, data_sz, user_priv);\n  }\n\n  return SAVE_STATUS(ctx, res);\n}",
        "file_path": "/src/aom/aom/src/aom_decoder.c",
        "crashing_line": "    res = ctx->iface->dec.decode(get_alg_priv(ctx), data, data_sz, user_priv);",
        "crashing_line_number": 103
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "ssize_t fr_tacacs_decode(TALLOC_CTX *ctx, fr_pair_list_t *out, uint8_t const *buffer, size_t buffer_len,\n\t\t\t const uint8_t *original, char const * const secret, size_t secret_len, int *code)\n{\n\tfr_tacacs_packet_t const *pkt;\n\tfr_pair_t\t\t*vp;\n\tuint8_t const  \t\t*p, *body, *argv, *attrs, *end;\n\tuint8_t\t\t\t*decrypted = NULL;\n\n\t/*\n\t * 3.4. The TACACS+ Packet Header\n\t *\n\t * 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t * +----------------+----------------+----------------+----------------+\n\t * |major  | minor  |                |                |                |\n\t * |version| version|      type      |     seq_no     |   flags        |\n\t * +----------------+----------------+----------------+----------------+\n\t * |                                                                   |\n\t * |                            session_id                             |\n\t * +----------------+----------------+----------------+----------------+\n\t * |                                                                   |\n\t * |                              length                               |\n\t * +----------------+----------------+----------------+----------------+\n\t */\n\tpkt = (fr_tacacs_packet_t const *) buffer;\n\n\t/*\n\t *\tp\tmiscellaneous pointer for decoding things\n\t *\tbody\tpoints to just past the (randomly sized) per-packet header,\n\t *\t\twhere the various user / server messages are.\n\t *\t\tsometimes this is after \"argv\".\n\t *\targv\tpoints to the array of argv[i] length entries\n\t *\tattrs\tpoints to the attributes we need to decode as \"foo=bar\".\n\t */\n\targv = attrs = NULL;\n\tend = buffer + buffer_len;\n\n\t/*\n\t *\tCheck that we have a full TACACS+ header before\n\t *\tdecoding anything.\n\t */\n\tif (buffer_len < sizeof(pkt->hdr)) {\n\t\tfr_strerror_printf(\"Packet is too small (%zu < 12) to be TACACS+.\", buffer_len);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tTACACS major / minor version MUST be 12.0 or 12.1\n\t */\n\tif (!(pkt->hdr.ver.major == 12 && (pkt->hdr.ver.minor == 0 || pkt->hdr.ver.minor == 1))) {\n\t\tfr_strerror_printf(\"Unsupported TACACS+ version %d.%d (%02x)\", pkt->hdr.ver.major, pkt->hdr.ver.minor, buffer[0]);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tThere's no reason to accept 64K TACACS+ packets.\n\t *\n\t *\tIn any case, the largest possible packet has the\n\t *\theader, plus 2 16-bit fields, plus 255 8-bit fields,\n\t *\twhich is a bit under 2^18.\n\t */\n\tif ((buffer[8] != 0) || (buffer[9] != 0)) {\n\t\tfr_strerror_const(\"Packet is too large.  Our limit is 64K\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tAs a stream protocol, the TACACS+ packet MUST fit\n\t *\texactly into however many bytes we read.\n\t */\n\tif ((buffer + sizeof(pkt->hdr) + ntohl(pkt->hdr.length)) != end) {\n\t\tfr_strerror_const(\"Packet does not exactly fill buffer\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tThere are only 3 types of packets which are supported.\n\t */\n\tif (!((pkt->hdr.type == FR_TAC_PLUS_AUTHEN) ||\n\t      (pkt->hdr.type == FR_TAC_PLUS_AUTHOR) ||\n\t      (pkt->hdr.type == FR_TAC_PLUS_ACCT))) {\n\t\tfr_strerror_printf(\"Unknown packet type %u\", pkt->hdr.type);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tCheck that the session IDs are correct.\n\t */\n\tif (original && (memcmp(original + 4, buffer + 4, 4) != 0)) {\n\t\tfr_strerror_printf(\"Session ID %08x does not match expected number %08x\",\n\t\t\t\t   fr_nbo_to_uint32(buffer + 4), fr_nbo_to_uint32(original + 4));\n\t\treturn -1;\n\t}\n\n\tif (!secret && packet_is_encrypted(pkt)) {\n\t\tfr_strerror_const(\"Packet is encrypted, but there is no secret to decrypt it\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tCall the struct encoder to do the actual work.\n\t */\n\tif (fr_struct_from_network(ctx, out, attr_tacacs_packet, buffer, buffer_len, false, NULL, NULL, NULL) < 0) {\n\t\tfr_strerror_printf(\"Failed decoding TACACS header - %s\", fr_strerror());\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\t3.6. Encryption\n\t *\n\t *\tIf there's a secret, we alway decrypt the packets.\n\t */\n\tif (secret && packet_is_encrypted(pkt)) {\n\t\tsize_t length;\n\n\t\tif (!secret_len) {\n\t\t\tfr_strerror_const(\"Packet should be encrypted, but the secret has zero length\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tlength = ntohl(pkt->hdr.length);\n\n\t\t/*\n\t\t *\tWe need that to decrypt the body content.\n\t\t */\n\t\tdecrypted = talloc_memdup(ctx, buffer, buffer_len);\n\t\tif (!decrypted) {\n\t\t\tfr_strerror_const(\"Out of Memory\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tpkt = (fr_tacacs_packet_t const *) decrypted;\n\t\tend = decrypted + buffer_len;\n\n\t\tif (fr_tacacs_body_xor(pkt, decrypted + sizeof(pkt->hdr), length, secret, secret_len) < 0) {\n\t\tfail:\n\t\t\ttalloc_free(decrypted);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdecrypted[3] |= FR_TAC_PLUS_UNENCRYPTED_FLAG;\n\n\t\tFR_PROTO_HEX_DUMP(decrypted, buffer_len, \"fr_tacacs_packet_t (unencrypted)\");\n\n\t\tif (code) {\n\t\t\t*code = fr_tacacs_packet_to_code((fr_tacacs_packet_t const *) decrypted);\n\t\t\tif (*code < 0) goto fail;\n\t\t}\n\t}\n\n#ifndef NDEBUG\n\tif (fr_debug_lvl >= L_DBG_LVL_4) fr_tacacs_packet_log_hex(&default_log, pkt);\n#endif\n\n\tswitch (pkt->hdr.type) {\n\t\tsize_t data_len;\n\n\tcase FR_TAC_PLUS_AUTHEN:\n\t\tif (packet_is_authen_start_request(pkt)) {\n\t\t\tuint8_t want;\n\t\t\tbool raw;\n\t\t\tfr_dict_attr_t const *da, *challenge;\n\n\t\t\t/**\n\t\t\t * 4.1. The Authentication START Packet Body\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    action      |    priv_lvl    |  authen_type   | authen_service |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    user_len    |    port_len    |  rem_addr_len  |    data_len    |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    user ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    port ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    rem_addr ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    data...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\t\t\tPACKET_HEADER_CHECK(\"Authentication-Start\", pkt->authen_start);\n\n\t\t\tdata_len += p[4] + p[5] + p[6] + p[7];\n\t\t\tif (data_len > (size_t) (end - p)) {\n\t\t\toverflow:\n\t\t\t\tfr_strerror_const(\"Data overflows the packet\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (data_len < (size_t) (end - p)) {\n\t\t\tunderflow:\n\t\t\t\tfr_strerror_const(\"Data underflows the packet\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_START);\n\n\t\t\t/*\n\t\t\t *\tDecode 4 octets of various flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_action, pkt->authen_start.action);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_privilege_level, pkt->authen_start.priv_lvl);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_type, pkt->authen_start.authen_type);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_service, pkt->authen_start.authen_service);\n\n\t\t\t/*\n\t\t\t *\tDecode 4 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_user_name, pkt->authen_start.user_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_client_port, pkt->authen_start.port_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_remote_address, pkt->authen_start.rem_addr_len);\n\n\t\t\t/*\n\t\t\t *\tCheck the length on the various\n\t\t\t *\tauthentication types.\n\t\t\t */\n\t\t\traw = false;\n\t\t\tchallenge = NULL;\n\n\t\t\tswitch (pkt->authen_start.authen_type) {\n\t\t\tdefault:\n\t\t\t\traw = true;\n\t\t\t\twant = pkt->authen_start.data_len;\n\t\t\t\tda = attr_tacacs_data;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_PAP:\n\t\t\t\twant = pkt->authen_start.data_len;\n\t\t\t\tda = attr_tacacs_user_password;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_CHAP:\n\t\t\t\twant = 1 + 16; /* id + HOPEFULLY 8 octets of challenge + 16 hash */\n\t\t\t\tda = attr_tacacs_chap_password;\n\t\t\t\tchallenge = attr_tacacs_chap_challenge;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_MSCHAP:\n\t\t\t\twant = 1 + 49; /* id + HOPEFULLY 8 octets of challenge + 49 MS-CHAP stuff */\n\t\t\t\tda = attr_tacacs_mschap_response;\n\t\t\t\tchallenge = attr_tacacs_mschap_challenge;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_MSCHAPV2:\n\t\t\t\twant = 1 + 16 + 49; /* id + HOPEFULLY 16 octets of challenge + 49 MS-CHAP stuff */\n\t\t\t\tda = attr_tacacs_mschap2_response;\n\t\t\t\tchallenge = attr_tacacs_mschap_challenge;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tIf we have enough data, decode it as\n\t\t\t *\tthe claimed authentication type.\n\t\t\t *\n\t\t\t *\tOtherwise, decode the entire field as an unknown\n\t\t\t *\tattribute.\n\t\t\t */\n\t\t\tif (raw || (pkt->authen_start.data_len < want)) {\n\t\t\t\tfr_dict_attr_t *da_unknown;\n\n\t\t\t\tda_unknown = fr_dict_unknown_attr_afrom_da(ctx, attr_tacacs_data);\n\t\t\t\tif (!da_unknown) goto fail;\n\n\t\t\t\tda_unknown->flags.is_raw = 1;\n\t\t\t\twant = pkt->authen_start.data_len;\n\n\t\t\t\tDECODE_FIELD_STRING8(da_unknown, want);\n\t\t\t\ttalloc_free(da_unknown);\n\n\t\t\t} else if (!challenge) {\n\t\t\t\tDECODE_FIELD_STRING8(da, want);\n\n\t\t\t} else if (pkt->authen_start.data_len == want)  {\n\t\t\t\tfr_strerror_printf(\"%s has zero length\", challenge->name);\n\t\t\t\tgoto fail;\n\n\t\t\t} else { /* 1 of ID + ??? of challenge + (want-1) of data */\n\t\t\t\tuint8_t challenge_len = pkt->authen_start.data_len - want;\n\t\t\t\tuint8_t hash[50];\n\n\t\t\t\t/*\n\t\t\t\t *\tRework things to make sense.\n\t\t\t\t */\n\t\t\t\thash[0] = p[0];\n\t\t\t\tmemcpy(hash + 1, p + 1 + challenge_len, want - 1);\n\n\t\t\t\tvp = fr_pair_afrom_da(ctx, da);\n\t\t\t\tif (!vp) goto fail;\n\n\t\t\t\tfr_pair_append(out, vp);\n\n\t\t\t\t/*\n\t\t\t\t *\tID + hash\n\t\t\t\t */\n\t\t\t\tif (fr_pair_value_memdup(vp, hash, want, true) < 0) goto fail;\n\n\t\t\t\t/*\n\t\t\t\t *\tAnd then the challenge.\n\t\t\t\t */\n\t\t\t\tvp = fr_pair_afrom_da(ctx, challenge);\n\t\t\t\tif (!vp) goto fail;\n\n\t\t\t\tfr_pair_append(out, vp);\n\n\t\t\t\tif (fr_pair_value_memdup(vp, p + 1, challenge_len, true) < 0) goto fail;\n\n\t\t\t\tp += pkt->authen_start.data_len;\n\t\t\t}\n\n\t\t} else if (packet_is_authen_continue(pkt)) {\n\t\t\t/*\n\t\t\t * 4.3. The Authentication CONTINUE Packet Body\n\t\t\t *\n\t\t\t * This packet is sent from the client to the server following the receipt of\n\t\t\t * a REPLY packet.\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |          user_msg len           |            data_len             |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     flags      |  user_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    data ...\n\t\t\t * +----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tVersion 1 is ONLY used for PAP / CHAP\n\t\t\t *\t/ MS-CHAP start and reply packets.\n\t\t\t */\n\t\t\tif (pkt->hdr.ver.minor != 0) {\n\t\t\tinvalid_version:\n\t\t\t\tfr_strerror_const(\"Invalid TACACS+ version\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tPACKET_HEADER_CHECK(\"Authentication-Continue\", pkt->authen_cont);\n\t\t\tdata_len += fr_nbo_to_uint16(p) + fr_nbo_to_uint16(p + 2);\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\tif (data_len < (size_t) (end - p)) goto underflow;\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_CONTINUE);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_user_message, pkt->authen_cont.user_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->authen_cont.data_len);\n\n\t\t\t/*\n\t\t\t *\tAnd finally the flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_continue_flags, pkt->authen_cont.flags);\n\n\t\t} else if (packet_is_authen_reply(pkt)) {\n\t\t\t/*\n\t\t\t * 4.2. The Authentication REPLY Packet Body\n\t\t\t *\n\t\t\t * 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     status     |      flags     |        server_msg_len           |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |           data_len              |        server_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |           data ...\n\t\t\t * +----------------+----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tWe don't care about versions for replies.\n\t\t\t *\tWe just echo whatever was sent in the request.\n\t\t\t */\n\t\t\tPACKET_HEADER_CHECK(\"Authentication-Reply\", pkt->authen_reply);\n\t\t\tdata_len += fr_nbo_to_uint16(p + 2) + fr_nbo_to_uint16(p + 4);\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\tif (data_len < (size_t) (end - p)) goto underflow;\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REPLY);\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_status, pkt->authen_reply.status);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_flags, pkt->authen_reply.flags);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_server_message, pkt->authen_reply.server_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->authen_reply.data_len);\n\n\t\t} else {\n\t\t\tfr_strerror_const(\"Unknown authentication packet\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\n\tcase FR_TAC_PLUS_AUTHOR:\n\t\tif (packet_is_author_request(pkt)) {\n\t\t\t/*\n\t\t\t * 5.1. The Authorization REQUEST Packet Body\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |  authen_method |    priv_lvl    |  authen_type   | authen_service |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    user_len    |    port_len    |  rem_addr_len  |    arg_cnt     |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1_len    |   arg_2_len    |      ...       |   arg_N_len    |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   user ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   port ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   rem_addr ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_2 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\n\t\t\tif (pkt->hdr.ver.minor != 0) goto invalid_version;\n\n\t\t\tPACKET_HEADER_CHECK(\"Authorization-Request\", pkt->author_req);\n\t\t\tdata_len += p[4] + p[5] + p[6] + p[7];\n\n\t\t\tARG_COUNT_CHECK(\"Authorization-Request\", pkt->author_req);\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REQUEST);\n\n\t\t\t/*\n\t\t\t *\tDecode 4 octets of various flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_method, pkt->author_req.authen_method);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_privilege_level, pkt->author_req.priv_lvl);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_type, pkt->author_req.authen_type);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_service, pkt->author_req.authen_service);\n\n\t\t\t/*\n\t\t\t *\tDecode 3 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_user_name, pkt->author_req.user_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_client_port, pkt->author_req.port_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_remote_address, pkt->author_req.rem_addr_len);\n\n\t\t\t/*\n\t\t\t *\tDecode 'arg_N' arguments (horrible format)\n\t\t\t */\n\t\t\tif (tacacs_decode_args(ctx, out, attr_tacacs_argument_list,\n\t\t\t\t\t       pkt->author_req.arg_cnt, argv, attrs, end) < 0) goto fail;\n\n\t\t} else if (packet_is_author_reply(pkt)) {\n\t\t\t/*\n\t\t\t * 5.2. The Authorization RESPONSE Packet Body\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    status      |     arg_cnt    |         server_msg len          |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * +            data_len             |    arg_1_len   |    arg_2_len   |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |      ...       |   arg_N_len    |         server_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   data ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_2 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tWe don't care about versions for replies.\n\t\t\t *\tWe just echo whatever was sent in the request.\n\t\t\t */\n\n\t\t\tPACKET_HEADER_CHECK(\"Authorization-Reply\", pkt->author_reply);\n\t\t\tdata_len += p[1] + fr_nbo_to_uint16(p + 2) + fr_nbo_to_uint16(p + 4);\n\n\t\t\tARG_COUNT_CHECK(\"Authorization-Reply\", pkt->author_reply);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_RESPONSE);\n\n\t\t\t/*\n\t\t\t *\tDecode 1 octets\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authorization_status, pkt->author_reply.status);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_server_message, pkt->author_reply.server_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->author_reply.data_len);\n\n\t\t\t/*\n\t\t\t *\tDecode 'arg_N' arguments (horrible format)\n\t\t\t */\n\t\t\tif (tacacs_decode_args(ctx, out, attr_tacacs_argument_list,\n\t\t\t\t\tpkt->author_reply.arg_cnt, argv, attrs, end) < 0) goto fail;\n\n\t\t} else {\n\t\t\tfr_strerror_const(\"Unknown authorization packet\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\n\tcase FR_TAC_PLUS_ACCT:\n\t\tif (packet_is_acct_request(pkt)) {\n\t\t\t/**\n\t\t\t * 6.1. The Account REQUEST Packet Body\n\t\t\t *\n\t\t\t 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |      flags     |  authen_method |    priv_lvl    |  authen_type   |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * | authen_service |    user_len    |    port_len    |  rem_addr_len  |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    arg_cnt     |   arg_1_len    |   arg_2_len    |      ...       |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N_len    |    user ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   port ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   rem_addr ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_2 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\n\t\t\tif (pkt->hdr.ver.minor != 0) goto invalid_version;\n\n\t\t\tPACKET_HEADER_CHECK(\"Accounting-Request\", pkt->acct_req);\n\t\t\tdata_len += p[5] + p[6] + p[7] + p[8];\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\t/* can't check for underflow, as we have argv[argc] */\n\n\t\t\tARG_COUNT_CHECK(\"Accounting-Request\", pkt->acct_req);\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REQUEST);\n\n\t\t\t/*\n\t\t\t *\tDecode 5 octets of various flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_accounting_flags, pkt->acct_req.flags);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_method, pkt->acct_req.authen_method);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_privilege_level, pkt->acct_req.priv_lvl);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_type, pkt->acct_req.authen_type);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_service, pkt->acct_req.authen_service);\n\n\t\t\t/*\n\t\t\t *\tDecode 3 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_user_name, pkt->acct_req.user_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_client_port, pkt->acct_req.port_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_remote_address, pkt->acct_req.rem_addr_len);\n\n\t\t\t/*\n\t\t\t *\tDecode 'arg_N' arguments (horrible format)\n\t\t\t */\n\t\t\tif (tacacs_decode_args(ctx, out, attr_tacacs_argument_list,\n\t\t\t\t\tpkt->acct_req.arg_cnt, argv, attrs, end) < 0) goto fail;\n\n\t\t} else if (packet_is_acct_reply(pkt)) {\n\t\t\t/**\n\t\t\t * 6.2. The Accounting REPLY Packet Body\n\t\t\t *\n\t\t\t * 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |         server_msg len          |            data_len             |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     status     |         server_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     data ...\n\t\t\t * +----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tWe don't care about versions for replies.\n\t\t\t *\tWe just echo whatever was sent in the request.\n\t\t\t */\n\n\t\t\tPACKET_HEADER_CHECK(\"Accounting-Reply\", pkt->acct_reply);\n\t\t\tdata_len += fr_nbo_to_uint16(p) + fr_nbo_to_uint16(p + 2);\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\tif (data_len < (size_t) (end - p)) goto underflow;\n\n\t\t\tp = BODY(acct_reply);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REPLY);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_server_message, pkt->acct_reply.server_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->acct_reply.data_len);\n\n\t\t\t/* Decode 1 octet */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_accounting_status, pkt->acct_reply.status);\n\t\t} else {\n\t\t\tfr_strerror_const(\"Unknown accounting packet\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfr_strerror_printf(\"decode: Unsupported packet type %u\", pkt->hdr.type);\n\t\tgoto fail;\n\t}\n\n\ttalloc_free(decrypted);\n\treturn buffer_len;\n}\n",
    "target": 1,
    "idx": 1055982,
    "stack_trace": [
      {
        "function_name": "fr_tacacs_decode",
        "function_body": "ssize_t fr_tacacs_decode(TALLOC_CTX *ctx, fr_pair_list_t *out, uint8_t const *buffer, size_t buffer_len,\n\t\t\t const uint8_t *original, char const * const secret, size_t secret_len, int *code)\n{\n\tfr_tacacs_packet_t const *pkt;\n\tfr_pair_t\t\t*vp;\n\tuint8_t const  \t\t*p, *body, *argv, *attrs, *end;\n\tuint8_t\t\t\t*decrypted = NULL;\n\n\t/*\n\t * 3.4. The TACACS+ Packet Header\n\t *\n\t * 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t * +----------------+----------------+----------------+----------------+\n\t * |major  | minor  |                |                |                |\n\t * |version| version|      type      |     seq_no     |   flags        |\n\t * +----------------+----------------+----------------+----------------+\n\t * |                                                                   |\n\t * |                            session_id                             |\n\t * +----------------+----------------+----------------+----------------+\n\t * |                                                                   |\n\t * |                              length                               |\n\t * +----------------+----------------+----------------+----------------+\n\t */\n\tpkt = (fr_tacacs_packet_t const *) buffer;\n\n\t/*\n\t *\tp\tmiscellaneous pointer for decoding things\n\t *\tbody\tpoints to just past the (randomly sized) per-packet header,\n\t *\t\twhere the various user / server messages are.\n\t *\t\tsometimes this is after \"argv\".\n\t *\targv\tpoints to the array of argv[i] length entries\n\t *\tattrs\tpoints to the attributes we need to decode as \"foo=bar\".\n\t */\n\targv = attrs = NULL;\n\tend = buffer + buffer_len;\n\n\t/*\n\t *\tCheck that we have a full TACACS+ header before\n\t *\tdecoding anything.\n\t */\n\tif (buffer_len < sizeof(pkt->hdr)) {\n\t\tfr_strerror_printf(\"Packet is too small (%zu < 12) to be TACACS+.\", buffer_len);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tTACACS major / minor version MUST be 12.0 or 12.1\n\t */\n\tif (!(pkt->hdr.ver.major == 12 && (pkt->hdr.ver.minor == 0 || pkt->hdr.ver.minor == 1))) {\n\t\tfr_strerror_printf(\"Unsupported TACACS+ version %d.%d (%02x)\", pkt->hdr.ver.major, pkt->hdr.ver.minor, buffer[0]);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tThere's no reason to accept 64K TACACS+ packets.\n\t *\n\t *\tIn any case, the largest possible packet has the\n\t *\theader, plus 2 16-bit fields, plus 255 8-bit fields,\n\t *\twhich is a bit under 2^18.\n\t */\n\tif ((buffer[8] != 0) || (buffer[9] != 0)) {\n\t\tfr_strerror_const(\"Packet is too large.  Our limit is 64K\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tAs a stream protocol, the TACACS+ packet MUST fit\n\t *\texactly into however many bytes we read.\n\t */\n\tif ((buffer + sizeof(pkt->hdr) + ntohl(pkt->hdr.length)) != end) {\n\t\tfr_strerror_const(\"Packet does not exactly fill buffer\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tThere are only 3 types of packets which are supported.\n\t */\n\tif (!((pkt->hdr.type == FR_TAC_PLUS_AUTHEN) ||\n\t      (pkt->hdr.type == FR_TAC_PLUS_AUTHOR) ||\n\t      (pkt->hdr.type == FR_TAC_PLUS_ACCT))) {\n\t\tfr_strerror_printf(\"Unknown packet type %u\", pkt->hdr.type);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tCheck that the session IDs are correct.\n\t */\n\tif (original && (memcmp(original + 4, buffer + 4, 4) != 0)) {\n\t\tfr_strerror_printf(\"Session ID %08x does not match expected number %08x\",\n\t\t\t\t   fr_nbo_to_uint32(buffer + 4), fr_nbo_to_uint32(original + 4));\n\t\treturn -1;\n\t}\n\n\tif (!secret && packet_is_encrypted(pkt)) {\n\t\tfr_strerror_const(\"Packet is encrypted, but there is no secret to decrypt it\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tCall the struct encoder to do the actual work.\n\t */\n\tif (fr_struct_from_network(ctx, out, attr_tacacs_packet, buffer, buffer_len, false, NULL, NULL, NULL) < 0) {\n\t\tfr_strerror_printf(\"Failed decoding TACACS header - %s\", fr_strerror());\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\t3.6. Encryption\n\t *\n\t *\tIf there's a secret, we alway decrypt the packets.\n\t */\n\tif (secret && packet_is_encrypted(pkt)) {\n\t\tsize_t length;\n\n\t\tif (!secret_len) {\n\t\t\tfr_strerror_const(\"Packet should be encrypted, but the secret has zero length\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tlength = ntohl(pkt->hdr.length);\n\n\t\t/*\n\t\t *\tWe need that to decrypt the body content.\n\t\t */\n\t\tdecrypted = talloc_memdup(ctx, buffer, buffer_len);\n\t\tif (!decrypted) {\n\t\t\tfr_strerror_const(\"Out of Memory\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tpkt = (fr_tacacs_packet_t const *) decrypted;\n\t\tend = decrypted + buffer_len;\n\n\t\tif (fr_tacacs_body_xor(pkt, decrypted + sizeof(pkt->hdr), length, secret, secret_len) < 0) {\n\t\tfail:\n\t\t\ttalloc_free(decrypted);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdecrypted[3] |= FR_TAC_PLUS_UNENCRYPTED_FLAG;\n\n\t\tFR_PROTO_HEX_DUMP(decrypted, buffer_len, \"fr_tacacs_packet_t (unencrypted)\");\n\n\t\tif (code) {\n\t\t\t*code = fr_tacacs_packet_to_code((fr_tacacs_packet_t const *) decrypted);\n\t\t\tif (*code < 0) goto fail;\n\t\t}\n\t}\n\n#ifndef NDEBUG\n\tif (fr_debug_lvl >= L_DBG_LVL_4) fr_tacacs_packet_log_hex(&default_log, pkt);\n#endif\n\n\tswitch (pkt->hdr.type) {\n\t\tsize_t data_len;\n\n\tcase FR_TAC_PLUS_AUTHEN:\n\t\tif (packet_is_authen_start_request(pkt)) {\n\t\t\tuint8_t want;\n\t\t\tbool raw;\n\t\t\tfr_dict_attr_t const *da, *challenge;\n\n\t\t\t/**\n\t\t\t * 4.1. The Authentication START Packet Body\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    action      |    priv_lvl    |  authen_type   | authen_service |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    user_len    |    port_len    |  rem_addr_len  |    data_len    |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    user ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    port ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    rem_addr ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    data...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\t\t\tPACKET_HEADER_CHECK(\"Authentication-Start\", pkt->authen_start);\n\n\t\t\tdata_len += p[4] + p[5] + p[6] + p[7];\n\t\t\tif (data_len > (size_t) (end - p)) {\n\t\t\toverflow:\n\t\t\t\tfr_strerror_const(\"Data overflows the packet\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (data_len < (size_t) (end - p)) {\n\t\t\tunderflow:\n\t\t\t\tfr_strerror_const(\"Data underflows the packet\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_START);\n\n\t\t\t/*\n\t\t\t *\tDecode 4 octets of various flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_action, pkt->authen_start.action);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_privilege_level, pkt->authen_start.priv_lvl);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_type, pkt->authen_start.authen_type);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_service, pkt->authen_start.authen_service);\n\n\t\t\t/*\n\t\t\t *\tDecode 4 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_user_name, pkt->authen_start.user_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_client_port, pkt->authen_start.port_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_remote_address, pkt->authen_start.rem_addr_len);\n\n\t\t\t/*\n\t\t\t *\tCheck the length on the various\n\t\t\t *\tauthentication types.\n\t\t\t */\n\t\t\traw = false;\n\t\t\tchallenge = NULL;\n\n\t\t\tswitch (pkt->authen_start.authen_type) {\n\t\t\tdefault:\n\t\t\t\traw = true;\n\t\t\t\twant = pkt->authen_start.data_len;\n\t\t\t\tda = attr_tacacs_data;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_PAP:\n\t\t\t\twant = pkt->authen_start.data_len;\n\t\t\t\tda = attr_tacacs_user_password;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_CHAP:\n\t\t\t\twant = 1 + 16; /* id + HOPEFULLY 8 octets of challenge + 16 hash */\n\t\t\t\tda = attr_tacacs_chap_password;\n\t\t\t\tchallenge = attr_tacacs_chap_challenge;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_MSCHAP:\n\t\t\t\twant = 1 + 49; /* id + HOPEFULLY 8 octets of challenge + 49 MS-CHAP stuff */\n\t\t\t\tda = attr_tacacs_mschap_response;\n\t\t\t\tchallenge = attr_tacacs_mschap_challenge;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_MSCHAPV2:\n\t\t\t\twant = 1 + 49; /* id + HOPEFULLY 16 octets of challenge + 49 MS-CHAP stuff */\n\t\t\t\tda = attr_tacacs_mschap2_response;\n\t\t\t\tchallenge = attr_tacacs_mschap_challenge;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tIf we have enough data, decode it as\n\t\t\t *\tthe claimed authentication type.\n\t\t\t *\n\t\t\t *\tOtherwise, decode the entire field as an unknown\n\t\t\t *\tattribute.\n\t\t\t */\n\t\t\tif (raw || (pkt->authen_start.data_len < want)) {\n\t\t\t\tfr_dict_attr_t *da_unknown;\n\n\t\t\t\tda_unknown = fr_dict_unknown_attr_afrom_da(ctx, attr_tacacs_data);\n\t\t\t\tif (!da_unknown) goto fail;\n\n\t\t\t\tda_unknown->flags.is_raw = 1;\n\t\t\t\twant = pkt->authen_start.data_len;\n\n\t\t\t\tDECODE_FIELD_STRING8(da_unknown, want);\n\t\t\t\ttalloc_free(da_unknown);\n\n\t\t\t} else if (!challenge) {\n\t\t\t\tDECODE_FIELD_STRING8(da, want);\n\n\t\t\t} else if (pkt->authen_start.data_len == want)  {\n\t\t\t\tfr_strerror_printf(\"%s has zero length\", challenge->name);\n\t\t\t\tgoto fail;\n\n\t\t\t} else { /* 1 of ID + ??? of challenge + (want-1) of data */\n\t\t\t\tuint8_t challenge_len = pkt->authen_start.data_len - want;\n\t\t\t\tuint8_t hash[50];\n\n\t\t\t\t/*\n\t\t\t\t *\tRework things to make sense.\n\t\t\t\t */\n\t\t\t\thash[0] = p[0];\n\t\t\t\tmemcpy(hash + 1, p + 1 + challenge_len, want - 1);\n\n\t\t\t\tvp = fr_pair_afrom_da(ctx, da);\n\t\t\t\tif (!vp) goto fail;\n\n\t\t\t\tfr_pair_append(out, vp);\n\n\t\t\t\t/*\n\t\t\t\t *\tID + hash\n\t\t\t\t */\n\t\t\t\tif (fr_pair_value_memdup(vp, hash, want, true) < 0) goto fail;\n\n\t\t\t\t/*\n\t\t\t\t *\tAnd then the challenge.\n\t\t\t\t */\n\t\t\t\tvp = fr_pair_afrom_da(ctx, challenge);\n\t\t\t\tif (!vp) goto fail;\n\n\t\t\t\tfr_pair_append(out, vp);\n\n\t\t\t\tif (fr_pair_value_memdup(vp, p + 1, challenge_len, true) < 0) goto fail;\n\n\t\t\t\tp += pkt->authen_start.data_len;\n\t\t\t}\n\n\t\t} else if (packet_is_authen_continue(pkt)) {\n\t\t\t/*\n\t\t\t * 4.3. The Authentication CONTINUE Packet Body\n\t\t\t *\n\t\t\t * This packet is sent from the client to the server following the receipt of\n\t\t\t * a REPLY packet.\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |          user_msg len           |            data_len             |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     flags      |  user_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    data ...\n\t\t\t * +----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tVersion 1 is ONLY used for PAP / CHAP\n\t\t\t *\t/ MS-CHAP start and reply packets.\n\t\t\t */\n\t\t\tif (pkt->hdr.ver.minor != 0) {\n\t\t\tinvalid_version:\n\t\t\t\tfr_strerror_const(\"Invalid TACACS+ version\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tPACKET_HEADER_CHECK(\"Authentication-Continue\", pkt->authen_cont);\n\t\t\tdata_len += fr_nbo_to_uint16(p) + fr_nbo_to_uint16(p + 2);\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\tif (data_len < (size_t) (end - p)) goto underflow;\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_CONTINUE);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_user_message, pkt->authen_cont.user_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->authen_cont.data_len);\n\n\t\t\t/*\n\t\t\t *\tAnd finally the flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_continue_flags, pkt->authen_cont.flags);\n\n\t\t} else if (packet_is_authen_reply(pkt)) {\n\t\t\t/*\n\t\t\t * 4.2. The Authentication REPLY Packet Body\n\t\t\t *\n\t\t\t * 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     status     |      flags     |        server_msg_len           |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |           data_len              |        server_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |           data ...\n\t\t\t * +----------------+----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tWe don't care about versions for replies.\n\t\t\t *\tWe just echo whatever was sent in the request.\n\t\t\t */\n\t\t\tPACKET_HEADER_CHECK(\"Authentication-Reply\", pkt->authen_reply);\n\t\t\tdata_len += fr_nbo_to_uint16(p + 2) + fr_nbo_to_uint16(p + 4);\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\tif (data_len < (size_t) (end - p)) goto underflow;\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REPLY);\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_status, pkt->authen_reply.status);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_flags, pkt->authen_reply.flags);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_server_message, pkt->authen_reply.server_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->authen_reply.data_len);\n\n\t\t} else {\n\t\t\tfr_strerror_const(\"Unknown authentication packet\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\n\tcase FR_TAC_PLUS_AUTHOR:\n\t\tif (packet_is_author_request(pkt)) {\n\t\t\t/*\n\t\t\t * 5.1. The Authorization REQUEST Packet Body\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |  authen_method |    priv_lvl    |  authen_type   | authen_service |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    user_len    |    port_len    |  rem_addr_len  |    arg_cnt     |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1_len    |   arg_2_len    |      ...       |   arg_N_len    |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   user ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   port ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   rem_addr ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_2 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\n\t\t\tif (pkt->hdr.ver.minor != 0) goto invalid_version;\n\n\t\t\tPACKET_HEADER_CHECK(\"Authorization-Request\", pkt->author_req);\n\t\t\tdata_len += p[4] + p[5] + p[6] + p[7];\n\n\t\t\tARG_COUNT_CHECK(\"Authorization-Request\", pkt->author_req);\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REQUEST);\n\n\t\t\t/*\n\t\t\t *\tDecode 4 octets of various flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_method, pkt->author_req.authen_method);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_privilege_level, pkt->author_req.priv_lvl);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_type, pkt->author_req.authen_type);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_service, pkt->author_req.authen_service);\n\n\t\t\t/*\n\t\t\t *\tDecode 3 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_user_name, pkt->author_req.user_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_client_port, pkt->author_req.port_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_remote_address, pkt->author_req.rem_addr_len);\n\n\t\t\t/*\n\t\t\t *\tDecode 'arg_N' arguments (horrible format)\n\t\t\t */\n\t\t\tif (tacacs_decode_args(ctx, out, attr_tacacs_argument_list,\n\t\t\t\t\t       pkt->author_req.arg_cnt, argv, attrs, end) < 0) goto fail;\n\n\t\t} else if (packet_is_author_reply(pkt)) {\n\t\t\t/*\n\t\t\t * 5.2. The Authorization RESPONSE Packet Body\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    status      |     arg_cnt    |         server_msg len          |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * +            data_len             |    arg_1_len   |    arg_2_len   |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |      ...       |   arg_N_len    |         server_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   data ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_2 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tWe don't care about versions for replies.\n\t\t\t *\tWe just echo whatever was sent in the request.\n\t\t\t */\n\n\t\t\tPACKET_HEADER_CHECK(\"Authorization-Reply\", pkt->author_reply);\n\t\t\tdata_len += p[1] + fr_nbo_to_uint16(p + 2) + fr_nbo_to_uint16(p + 4);\n\n\t\t\tARG_COUNT_CHECK(\"Authorization-Reply\", pkt->author_reply);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_RESPONSE);\n\n\t\t\t/*\n\t\t\t *\tDecode 1 octets\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authorization_status, pkt->author_reply.status);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_server_message, pkt->author_reply.server_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->author_reply.data_len);\n\n\t\t\t/*\n\t\t\t *\tDecode 'arg_N' arguments (horrible format)\n\t\t\t */\n\t\t\tif (tacacs_decode_args(ctx, out, attr_tacacs_argument_list,\n\t\t\t\t\tpkt->author_reply.arg_cnt, argv, attrs, end) < 0) goto fail;\n\n\t\t} else {\n\t\t\tfr_strerror_const(\"Unknown authorization packet\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\n\tcase FR_TAC_PLUS_ACCT:\n\t\tif (packet_is_acct_request(pkt)) {\n\t\t\t/**\n\t\t\t * 6.1. The Account REQUEST Packet Body\n\t\t\t *\n\t\t\t 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |      flags     |  authen_method |    priv_lvl    |  authen_type   |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * | authen_service |    user_len    |    port_len    |  rem_addr_len  |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    arg_cnt     |   arg_1_len    |   arg_2_len    |      ...       |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N_len    |    user ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   port ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   rem_addr ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_2 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\n\t\t\tif (pkt->hdr.ver.minor != 0) goto invalid_version;\n\n\t\t\tPACKET_HEADER_CHECK(\"Accounting-Request\", pkt->acct_req);\n\t\t\tdata_len += p[5] + p[6] + p[7] + p[8];\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\t/* can't check for underflow, as we have argv[argc] */\n\n\t\t\tARG_COUNT_CHECK(\"Accounting-Request\", pkt->acct_req);\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REQUEST);\n\n\t\t\t/*\n\t\t\t *\tDecode 5 octets of various flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_accounting_flags, pkt->acct_req.flags);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_method, pkt->acct_req.authen_method);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_privilege_level, pkt->acct_req.priv_lvl);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_type, pkt->acct_req.authen_type);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_service, pkt->acct_req.authen_service);\n\n\t\t\t/*\n\t\t\t *\tDecode 3 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_user_name, pkt->acct_req.user_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_client_port, pkt->acct_req.port_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_remote_address, pkt->acct_req.rem_addr_len);\n\n\t\t\t/*\n\t\t\t *\tDecode 'arg_N' arguments (horrible format)\n\t\t\t */\n\t\t\tif (tacacs_decode_args(ctx, out, attr_tacacs_argument_list,\n\t\t\t\t\tpkt->acct_req.arg_cnt, argv, attrs, end) < 0) goto fail;\n\n\t\t} else if (packet_is_acct_reply(pkt)) {\n\t\t\t/**\n\t\t\t * 6.2. The Accounting REPLY Packet Body\n\t\t\t *\n\t\t\t * 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |         server_msg len          |            data_len             |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     status     |         server_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     data ...\n\t\t\t * +----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tWe don't care about versions for replies.\n\t\t\t *\tWe just echo whatever was sent in the request.\n\t\t\t */\n\n\t\t\tPACKET_HEADER_CHECK(\"Accounting-Reply\", pkt->acct_reply);\n\t\t\tdata_len += fr_nbo_to_uint16(p) + fr_nbo_to_uint16(p + 2);\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\tif (data_len < (size_t) (end - p)) goto underflow;\n\n\t\t\tp = BODY(acct_reply);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REPLY);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_server_message, pkt->acct_reply.server_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->acct_reply.data_len);\n\n\t\t\t/* Decode 1 octet */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_accounting_status, pkt->acct_reply.status);\n\t\t} else {\n\t\t\tfr_strerror_const(\"Unknown accounting packet\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfr_strerror_printf(\"decode: Unsupported packet type %u\", pkt->hdr.type);\n\t\tgoto fail;\n\t}\n\n\ttalloc_free(decrypted);\n\treturn buffer_len;\n}",
        "file_path": "/src/freeradius-server/src/protocols/tacacs/decode.c",
        "crashing_line": "\t\t\t\tmemcpy(hash + 1, p + 1 + challenge_len, want - 1);",
        "crashing_line_number": 624
      },
      {
        "function_name": "fr_tacacs_decode_proto",
        "function_body": "static ssize_t fr_tacacs_decode_proto(TALLOC_CTX *ctx, fr_pair_list_t *out, uint8_t const *data, size_t data_len, void *proto_ctx)\n{\n\tfr_tacacs_ctx_t\t*test_ctx = talloc_get_type_abort(proto_ctx, fr_tacacs_ctx_t);\n\n\treturn fr_tacacs_decode(ctx, out, data, data_len, NULL,\n\t\t\t\ttest_ctx->secret, (talloc_array_length(test_ctx->secret)-1), false);\n}",
        "file_path": "/src/freeradius-server/src/protocols/tacacs/decode.c",
        "crashing_line": "\treturn fr_tacacs_decode(ctx, out, data, data_len, NULL,",
        "crashing_line_number": 974
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "    simdutf_really_inline size_t convert(const char* in, size_t size, char16_t* utf16_output) {\n      size_t pos = 0;\n      char16_t* start{utf16_output};\n      // In the worst case, we have the haswell kernel which can cause an overflow of\n      // 8 bytes when calling convert_masked_utf8_to_utf16. If you skip the last 16 bytes,\n      // and if the data is valid, then it is entirely safe because 16 UTF-8 bytes generate\n      // much more than 8 bytes.\n      const size_t safety_margin = 16; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf16<endian>(utf16_output);\n          utf16_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf16<endian>(in + pos,\n                            utf8_end_of_code_point_mask, utf16_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) { return 0; }\n      if(pos < size) {\n        size_t howmany  = scalar::utf8_to_utf16::convert<endian>(in + pos, size - pos, utf16_output);\n        if(howmany == 0) { return 0; }\n        utf16_output += howmany;\n      }\n      return utf16_output - start;\n    }\n    simdutf_really_inline result convert_with_errors(const char* in, size_t size, char16_t* utf16_output) {\n      size_t pos = 0;\n      char16_t* start{utf16_output};\n      const size_t safety_margin = 16; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf16<endian>(utf16_output);\n          utf16_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          if (errors()) {\n            // rewind_and_convert_with_errors will seek a potential error from in+pos onward,\n            // with the ability to go back up to pos bytes, and read size-pos bytes forward.\n            result res = scalar::utf8_to_utf16::rewind_and_convert_with_errors<endian>(pos, in + pos, size - pos, utf16_output);\n            res.count += pos;\n            return res;\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf16<endian>(in + pos,\n                            utf8_end_of_code_point_mask, utf16_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) {\n        // rewind_and_convert_with_errors will seek a potential error from in+pos onward,\n        // with the ability to go back up to pos bytes, and read size-pos bytes forward.\n        result res = scalar::utf8_to_utf16::rewind_and_convert_with_errors<endian>(pos, in + pos, size - pos, utf16_output);\n        res.count += pos;\n        return res;\n      }\n      if(pos < size) {\n        // rewind_and_convert_with_errors will seek a potential error from in+pos onward,\n        // with the ability to go back up to pos bytes, and read size-pos bytes forward.\n        result res = scalar::utf8_to_utf16::rewind_and_convert_with_errors<endian>(pos, in + pos, size - pos, utf16_output);\n        if (res.error) {    // In case of error, we want the error position\n          res.count += pos;\n          return res;\n        } else {    // In case of success, we want the number of word written\n          utf16_output += res.count;\n        }\n      }\n      return result(error_code::SUCCESS, utf16_output - start);\n    }\n    simdutf_really_inline size_t convert(const char* in, size_t size, char32_t* utf32_output) {\n      size_t pos = 0;\n      char32_t* start{utf32_output};\n      // In the worst case, we have the haswell kernel which can cause an overflow of\n      // 8 bytes when calling convert_masked_utf8_to_utf16. If you skip the last 16 bytes,\n      // and if the data is valid, then it is entirely safe because 16 UTF-8 bytes generate\n      // much more than 8 bytes.\n      const size_t safety_margin = 16; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf32(utf32_output);\n          utf32_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf32(in + pos,\n                            utf8_end_of_code_point_mask, utf32_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) { return 0; }\n      if(pos < size) {\n        size_t howmany  = scalar::utf8_to_utf32::convert(in + pos, size - pos, utf32_output);\n        if(howmany == 0) { return 0; }\n        utf32_output += howmany;\n      }\n      return utf32_output - start;\n    }\n    simdutf_really_inline result convert_with_errors(const char* in, size_t size, char32_t* utf32_output) {\n      size_t pos = 0;\n      char32_t* start{utf32_output};\n      const size_t safety_margin = 16; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf32(utf32_output);\n          utf32_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          if (errors()) {\n            result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n            res.count += pos;\n            return res;\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf32(in + pos,\n                            utf8_end_of_code_point_mask, utf32_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) {\n        result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n        res.count += pos;\n        return res;\n      }\n      if(pos < size) {\n        result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n        if (res.error) {    // In case of error, we want the error position\n          res.count += pos;\n          return res;\n        } else {    // In case of success, we want the number of word written\n          utf32_output += res.count;\n        }\n      }\n      return result(error_code::SUCCESS, utf32_output - start);\n    }\n",
    "target": 1,
    "idx": 1057673,
    "stack_trace": []
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   // original size\n    size_t dsize;                  // decoded size\n    unsigned char *buf = 0;\n\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\n\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}\n",
    "target": 1,
    "idx": 1026674,
    "stack_trace": [
      {
        "function_name": "decode_chars",
        "function_body": "",
        "file_path": "/src/libass/libass/ass.c",
        "crashing_line": "",
        "crashing_line_number": 830
      },
      {
        "function_name": "decode_font",
        "function_body": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   // original size\n    size_t dsize;                  // decoded size\n    unsigned char *buf = 0;\n\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4, 1) - 1);\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4, 1) - 1);\n\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\n\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}",
        "file_path": "/src/libass/libass/ass.c",
        "crashing_line": "        q = decode_chars(p, q, 4);",
        "crashing_line_number": 866
      },
      {
        "function_name": "process_text",
        "function_body": "static int process_text(ASS_Track *track, char *str)\n{\n    char *p = str;\n    while (1) {\n        char *q;\n        while (1) {\n            if ((*p == '\\r') || (*p == '\\n'))\n                ++p;\n            else if (p[0] == '\\xef' && p[1] == '\\xbb' && p[2] == '\\xbf')\n                p += 3;         // U+FFFE (BOM)\n            else\n                break;\n        }\n        for (q = p; ((*q != '\\0') && (*q != '\\r') && (*q != '\\n')); ++q) {\n        };\n        if (q == p)\n            break;\n        if (*q != '\\0')\n            *(q++) = '\\0';\n        process_line(track, p);\n        if (*q == '\\0')\n            break;\n        p = q;\n    }\n    // there is no explicit end-of-font marker in ssa/ass\n    if (track->parser_priv->fontname)\n        decode_font(track);\n    return 0;\n}",
        "file_path": "/src/libass/libass/ass.c",
        "crashing_line": "        decode_font(track);",
        "crashing_line_number": 1000
      },
      {
        "function_name": "parse_memory",
        "function_body": "",
        "file_path": "/src/libass/libass/ass.c",
        "crashing_line": "",
        "crashing_line_number": 1296
      },
      {
        "function_name": "ass_read_memory",
        "function_body": "",
        "file_path": "/src/libass/libass/ass.c",
        "crashing_line": "",
        "crashing_line_number": 1346
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int MqttEncode_Connect(byte *tx_buf, int tx_buf_len, MqttConnect *mc_connect)\n{\n    int header_len, remain_len;\n#ifdef WOLFMQTT_V5\n    word32 props_len = 0, lwt_props_len = 0;\n#endif\n    MqttConnectPacket packet = MQTT_CONNECT_INIT;\n    byte *tx_payload;\n\n    /* Validate required arguments */\n    if (tx_buf == NULL || mc_connect == NULL || mc_connect->client_id == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Determine packet length */\n    /* MQTT Version 4/5 header is 10 bytes */\n    remain_len = sizeof(MqttConnectPacket);\n\n#ifdef WOLFMQTT_V5\n    if (mc_connect->protocol_level >= MQTT_CONNECT_PROTOCOL_LEVEL_5) {\n        /* Determine length of properties */\n        remain_len += props_len = MqttEncode_Props(MQTT_PACKET_TYPE_CONNECT,\n                mc_connect->props, NULL);\n\n        /* Determine the length of the \"property length\" */\n        remain_len += MqttEncode_Vbi(NULL, props_len);\n    }\n#endif\n\n    remain_len += (int)XSTRLEN(mc_connect->client_id) + MQTT_DATA_LEN_SIZE;\n    if (mc_connect->enable_lwt) {\n        /* Verify all required fields are present */\n        if (mc_connect->lwt_msg == NULL ||\n            mc_connect->lwt_msg->topic_name == NULL ||\n            (mc_connect->lwt_msg->buffer == NULL &&\n             mc_connect->lwt_msg->total_len != 0))\n        {\n            return MQTT_CODE_ERROR_BAD_ARG;\n        }\n\n        remain_len += (int)XSTRLEN(mc_connect->lwt_msg->topic_name);\n        remain_len += MQTT_DATA_LEN_SIZE;\n        remain_len += mc_connect->lwt_msg->total_len;\n        remain_len += MQTT_DATA_LEN_SIZE;\n#ifdef WOLFMQTT_V5\n    if (mc_connect->protocol_level >= MQTT_CONNECT_PROTOCOL_LEVEL_5) {\n        /* Determine length of properties */\n        remain_len += lwt_props_len = MqttEncode_Props(MQTT_PACKET_TYPE_CONNECT,\n                mc_connect->lwt_msg->props, NULL);\n\n        /* Determine the length of the \"lwt property length\" */\n        remain_len += MqttEncode_Vbi(NULL, lwt_props_len);\n    }\n#endif\n    }\n    if (mc_connect->username) {\n        remain_len += (int)XSTRLEN(mc_connect->username) + MQTT_DATA_LEN_SIZE;\n    }\n    if (mc_connect->password) {\n        remain_len += (int)XSTRLEN(mc_connect->password) + MQTT_DATA_LEN_SIZE;\n    }\n\n    /* Encode fixed header */\n    header_len = MqttEncode_FixedHeader(tx_buf, tx_buf_len, remain_len,\n        MQTT_PACKET_TYPE_CONNECT, 0, 0, 0);\n    if (header_len < 0) {\n        return header_len;\n    }\n    /* Check for buffer room */\n    if (tx_buf_len < header_len + remain_len) {\n        return MQTT_CODE_ERROR_OUT_OF_BUFFER;\n    }\n    tx_payload = &tx_buf[header_len];\n\n    /* Encode variable header */\n    /* Protocol version */\n    if (mc_connect->protocol_level != 0) {\n        packet.protocol_level = mc_connect->protocol_level;\n    }\n\n    /* Set connection flags */\n    if (mc_connect->clean_session) {\n        packet.flags |= MQTT_CONNECT_FLAG_CLEAN_SESSION;\n    }\n    if (mc_connect->enable_lwt) {\n        packet.flags |= MQTT_CONNECT_FLAG_WILL_FLAG;\n\n        if (mc_connect->lwt_msg->qos) {\n            packet.flags |= MQTT_CONNECT_FLAG_SET_QOS(mc_connect->lwt_msg->qos);\n        }\n        if (mc_connect->lwt_msg->retain) {\n            packet.flags |= MQTT_CONNECT_FLAG_WILL_RETAIN;\n        }\n    }\n    if (mc_connect->username) {\n        packet.flags |= MQTT_CONNECT_FLAG_USERNAME;\n    }\n    if (mc_connect->password) {\n        packet.flags |= MQTT_CONNECT_FLAG_PASSWORD;\n    }\n    MqttEncode_Num((byte*)&packet.keep_alive, mc_connect->keep_alive_sec);\n    XMEMCPY(tx_payload, &packet, sizeof(MqttConnectPacket));\n    tx_payload += sizeof(MqttConnectPacket);\n\n#ifdef WOLFMQTT_V5\n    if (mc_connect->protocol_level >= MQTT_CONNECT_PROTOCOL_LEVEL_5) {\n        /* Encode the property length */\n        tx_payload += MqttEncode_Vbi(tx_payload, props_len);\n\n        /* Encode properties */\n        tx_payload += MqttEncode_Props(MQTT_PACKET_TYPE_CONNECT, mc_connect->props,\n                        tx_payload);\n    }\n#endif\n\n    /* Encode payload */\n    tx_payload += MqttEncode_String(tx_payload, mc_connect->client_id);\n    if (mc_connect->enable_lwt) {\n#ifdef WOLFMQTT_V5\n    if (mc_connect->protocol_level >= MQTT_CONNECT_PROTOCOL_LEVEL_5) {\n        /* Encode the lwt property length */\n        tx_payload += MqttEncode_Vbi(tx_payload, lwt_props_len);\n\n        /* Encode lwt properties */\n        tx_payload += MqttEncode_Props(MQTT_PACKET_TYPE_CONNECT,\n                mc_connect->lwt_msg->props, tx_payload);\n    }\n#endif\n        tx_payload += MqttEncode_String(tx_payload,\n            mc_connect->lwt_msg->topic_name);\n        tx_payload += MqttEncode_Data(tx_payload,\n            mc_connect->lwt_msg->buffer, (word16)mc_connect->lwt_msg->total_len);\n    }\n    if (mc_connect->username) {\n        tx_payload += MqttEncode_String(tx_payload, mc_connect->username);\n    }\n    else {\n        /* A Server MAY allow a Client to supply a ClientID that has a length\n         * of zero bytes, however if it does so the Server MUST treat this as a\n         * special case and assign a unique ClientID to that Client\n         * [MQTT-3.1.3-6]. It MUST then process the CONNECT packet as if the\n         * Client had provided that unique ClientID, and MUST return the\n         * Assigned Client Identifier in the CONNACK packet [MQTT-3.1.3-7].\n         */\n        tx_payload += MqttEncode_Num(tx_payload, (word16)0);\n    }\n    if (mc_connect->password) {\n        tx_payload += MqttEncode_String(tx_payload, mc_connect->password);\n    }\n    (void)tx_payload;\n\n    /* Return total length of packet */\n    return header_len + remain_len;\n}\n",
    "target": 1,
    "idx": 1030181,
    "stack_trace": [
      {
        "function_name": "MqttEncode_Num",
        "function_body": "int MqttEncode_Num(byte *buf, word16 len)\n{\n    if (buf != NULL) {\n        buf[0] = len >> 8;\n        buf[1] = len & 0xFF;\n    }\n    return MQTT_DATA_LEN_SIZE;\n}",
        "file_path": "/src/wolfmqtt/src/mqtt_packet.c",
        "crashing_line": "        buf[0] = len >> 8;",
        "crashing_line_number": 281
      },
      {
        "function_name": "MqttEncode_Connect",
        "function_body": "int MqttEncode_Connect(byte *tx_buf, int tx_buf_len, MqttConnect *mc_connect)\n{\n    int header_len, remain_len;\n#ifdef WOLFMQTT_V5\n    word32 props_len = 0, lwt_props_len = 0;\n#endif\n    MqttConnectPacket packet = MQTT_CONNECT_INIT;\n    byte *tx_payload;\n\n    /* Validate required arguments */\n    if (tx_buf == NULL || mc_connect == NULL || mc_connect->client_id == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Determine packet length */\n    /* MQTT Version 4/5 header is 10 bytes */\n    remain_len = sizeof(MqttConnectPacket);\n\n#ifdef WOLFMQTT_V5\n    if (mc_connect->protocol_level >= MQTT_CONNECT_PROTOCOL_LEVEL_5) {\n        /* Determine length of properties */\n        remain_len += props_len = MqttEncode_Props(MQTT_PACKET_TYPE_CONNECT,\n                mc_connect->props, NULL);\n\n        /* Determine the length of the \"property length\" */\n        remain_len += MqttEncode_Vbi(NULL, props_len);\n    }\n#endif\n\n    remain_len += (int)XSTRLEN(mc_connect->client_id) + MQTT_DATA_LEN_SIZE;\n    if (mc_connect->enable_lwt) {\n        /* Verify all required fields are present */\n        if (mc_connect->lwt_msg == NULL ||\n            mc_connect->lwt_msg->topic_name == NULL ||\n            (mc_connect->lwt_msg->buffer == NULL &&\n             mc_connect->lwt_msg->total_len != 0))\n        {\n            return MQTT_CODE_ERROR_BAD_ARG;\n        }\n\n        remain_len += (int)XSTRLEN(mc_connect->lwt_msg->topic_name);\n        remain_len += MQTT_DATA_LEN_SIZE;\n        remain_len += mc_connect->lwt_msg->total_len;\n        remain_len += MQTT_DATA_LEN_SIZE;\n#ifdef WOLFMQTT_V5\n    if (mc_connect->protocol_level >= MQTT_CONNECT_PROTOCOL_LEVEL_5) {\n        /* Determine length of properties */\n        remain_len += lwt_props_len = MqttEncode_Props(MQTT_PACKET_TYPE_CONNECT,\n                mc_connect->lwt_msg->props, NULL);\n\n        /* Determine the length of the \"lwt property length\" */\n        remain_len += MqttEncode_Vbi(NULL, lwt_props_len);\n    }\n#endif\n    }\n    if (mc_connect->username) {\n        remain_len += (int)XSTRLEN(mc_connect->username) + MQTT_DATA_LEN_SIZE;\n    }\n    if (mc_connect->password) {\n        remain_len += (int)XSTRLEN(mc_connect->password) + MQTT_DATA_LEN_SIZE;\n    }\n\n    /* Encode fixed header */\n    header_len = MqttEncode_FixedHeader(tx_buf, tx_buf_len, remain_len,\n        MQTT_PACKET_TYPE_CONNECT, 0, 0, 0);\n    if (header_len < 0) {\n        return header_len;\n    }\n    /* Check for buffer room */\n    if (tx_buf_len < header_len + remain_len) {\n        return MQTT_CODE_ERROR_OUT_OF_BUFFER;\n    }\n    tx_payload = &tx_buf[header_len];\n\n    /* Encode variable header */\n    /* Protocol version */\n    if (mc_connect->protocol_level != 0) {\n        packet.protocol_level = mc_connect->protocol_level;\n    }\n\n    /* Set connection flags */\n    if (mc_connect->clean_session) {\n        packet.flags |= MQTT_CONNECT_FLAG_CLEAN_SESSION;\n    }\n    if (mc_connect->enable_lwt) {\n        packet.flags |= MQTT_CONNECT_FLAG_WILL_FLAG;\n\n        if (mc_connect->lwt_msg->qos) {\n            packet.flags |= MQTT_CONNECT_FLAG_SET_QOS(mc_connect->lwt_msg->qos);\n        }\n        if (mc_connect->lwt_msg->retain) {\n            packet.flags |= MQTT_CONNECT_FLAG_WILL_RETAIN;\n        }\n    }\n    if (mc_connect->username) {\n        packet.flags |= MQTT_CONNECT_FLAG_USERNAME;\n    }\n    if (mc_connect->password) {\n        packet.flags |= MQTT_CONNECT_FLAG_PASSWORD;\n    }\n    MqttEncode_Num((byte*)&packet.keep_alive, mc_connect->keep_alive_sec);\n    XMEMCPY(tx_payload, &packet, sizeof(MqttConnectPacket));\n    tx_payload += sizeof(MqttConnectPacket);\n\n#ifdef WOLFMQTT_V5\n    if (mc_connect->protocol_level >= MQTT_CONNECT_PROTOCOL_LEVEL_5) {\n        /* Encode the property length */\n        tx_payload += MqttEncode_Vbi(tx_payload, props_len);\n\n        /* Encode properties */\n        tx_payload += MqttEncode_Props(MQTT_PACKET_TYPE_CONNECT, mc_connect->props,\n                        tx_payload);\n    }\n#endif\n\n    /* Encode payload */\n    tx_payload += MqttEncode_String(tx_payload, mc_connect->client_id);\n    if (mc_connect->enable_lwt) {\n#ifdef WOLFMQTT_V5\n    if (mc_connect->protocol_level >= MQTT_CONNECT_PROTOCOL_LEVEL_5) {\n        /* Encode the lwt property length */\n        tx_payload += MqttEncode_Vbi(tx_payload, lwt_props_len);\n\n        /* Encode lwt properties */\n        tx_payload += MqttEncode_Props(MQTT_PACKET_TYPE_CONNECT,\n                mc_connect->lwt_msg->props, tx_payload);\n    }\n#endif\n        tx_payload += MqttEncode_String(tx_payload,\n            mc_connect->lwt_msg->topic_name);\n        tx_payload += MqttEncode_Data(tx_payload,\n            mc_connect->lwt_msg->buffer, (word16)mc_connect->lwt_msg->total_len);\n    }\n    if (mc_connect->username) {\n        tx_payload += MqttEncode_String(tx_payload, mc_connect->username);\n    }\n    if (mc_connect->password) {\n        tx_payload += MqttEncode_String(tx_payload, mc_connect->password);\n    }\n    (void)tx_payload;\n\n    /* Return total length of packet */\n    return header_len + remain_len;\n}",
        "file_path": "/src/wolfmqtt/src/mqtt_packet.c",
        "crashing_line": "",
        "crashing_line_number": 755
      },
      {
        "function_name": "MqttClient_Connect",
        "function_body": "int MqttClient_Connect(MqttClient *client, MqttConnect *mc_connect)\n{\n    int rc, len = 0;\n\n    /* Validate required arguments */\n    if (client == NULL || mc_connect == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (mc_connect->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n    #ifdef WOLFMQTT_V5\n        /* Use specified protocol version if set */\n        mc_connect->protocol_level = client->protocol_level;\n    #endif\n\n        /* Encode the connect packet */\n        rc = MqttEncode_Connect(client->tx_buf, client->tx_buf_len, mc_connect);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_CONNECT),\n            MQTT_PACKET_TYPE_CONNECT, 0, 0);\n    #endif\n        if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_CONNECT_ACK, 0,\n                &mc_connect->pendResp, &mc_connect->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send connect packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n            return rc;\n        }\n    #ifdef WOLFMQTT_V5\n        /* Enhanced authentication */\n        if (client->enable_eauth == 1) {\n            mc_connect->stat = MQTT_MSG_AUTH;\n        }\n        else\n    #endif\n        {\n            mc_connect->stat = MQTT_MSG_WAIT;\n        }\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Enhanced authentication */\n    if (mc_connect->protocol_level > MQTT_CONNECT_PROTOCOL_LEVEL_4 && \n            mc_connect->stat == MQTT_MSG_AUTH)\n    {\n        MqttAuth auth, *p_auth = &auth;\n        MqttProp* prop, *conn_prop;\n\n        /* Find the AUTH property in the connect structure */\n        for (conn_prop = mc_connect->props;\n             (conn_prop != NULL) && (conn_prop->type != MQTT_PROP_AUTH_METHOD);\n             conn_prop = conn_prop->next) {\n        }\n        if (conn_prop == NULL) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            /* AUTH property was not set in connect structure */\n            return MQTT_CODE_ERROR_BAD_ARG;\n        }\n\n        XMEMSET((void*)p_auth, 0, sizeof(MqttAuth));\n\n        /* Set the authentication reason */\n        p_auth->reason_code = MQTT_REASON_CONT_AUTH;\n\n        /* Use the same authentication method property from connect */\n        prop = MqttProps_Add(&p_auth->props);\n        prop->type = MQTT_PROP_AUTH_METHOD;\n        prop->data_str.str = conn_prop->data_str.str;\n        prop->data_str.len = conn_prop->data_str.len;\n\n        /* Send the AUTH packet */\n        rc = MqttClient_Auth(client, p_auth);\n        MqttClient_PropsFree(p_auth->props);\n    #ifdef WOLFMQTT_NONBLOCK\n        if (rc == MQTT_CODE_CONTINUE)\n            return rc;\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n    }\n#endif /* WOLFMQTT_V5 */\n\n    /* Wait for connect ack packet */\n    rc = MqttClient_WaitType(client, &mc_connect->ack,\n        MQTT_PACKET_TYPE_CONNECT_ACK, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    mc_connect->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}",
        "file_path": "/src/wolfmqtt/src/mqtt_client.c",
        "crashing_line": "        rc = MqttEncode_Connect(client->tx_buf, client->tx_buf_len, mc_connect);",
        "crashing_line_number": 1086
      },
      {
        "function_name": "Initialize",
        "function_body": "bool wolfMQTTFuzzer::Initialize(void) {\n    bool ret = false;\n\n    try {\n        /* net */\n        {\n            memset(&net, 0, sizeof(net));\n\n            net.connect = mqtt_connect;\n            net.read = mqtt_recv;\n            net.write = mqtt_write;\n            net.disconnect = mqtt_disconnect;\n            net.context = this;\n        }\n\n        /* client */\n        {\n            memset(&client, 0, sizeof(client));\n\n            tx_size = ds.Get<uint16_t>();\n            tx_size = 4096;\n            tx_buf = (uint8_t*)this->malloc(tx_size);\n            rx_size = ds.Get<uint16_t>();\n            rx_size = 4096;\n            rx_buf = (uint8_t*)this->malloc(rx_size);\n            memset(tx_buf, 0, tx_size);\n            memset(rx_buf, 0, rx_size);\n\n            client.msg_cb = mqtt_message_cb;\n            client.tx_buf = tx_buf;\n            client.tx_buf_len = tx_size;\n            client.rx_buf = rx_buf;\n            client.rx_buf_len = rx_size;\n            client.cmd_timeout_ms = 1000;\n        }\n\n        /* connect */\n        MqttMessage lwt_msg;\n        {\n            memset(&connect, 0, sizeof(connect));\n\n            connect.keep_alive_sec = 1;\n            connect.clean_session = ds.Get<bool>() ? 1 : 0;\n            client_id = ds.Get<std::string>();\n            connect.client_id = client_id.c_str();\n            connect.enable_lwt = ds.Get<bool>() ? 1 : 0;\n        }\n            \n        std::string lwt_topic_name;\n        std::vector<uint8_t> lwt_buffer;\n\n        if ( connect.enable_lwt ) {\n            lwt_topic_name = ds.Get<std::string>();\n            lwt_buffer = ds.GetData(0);\n\n            connect.lwt_msg = &lwt_msg;\n            lwt_msg.qos = GetQoS();\n            lwt_msg.retain = ds.Get<bool>() ? 1 : 0;\n            lwt_msg.topic_name = lwt_topic_name.c_str();\n            lwt_msg.buffer = lwt_buffer.data();\n            lwt_msg.total_len = lwt_buffer.size();\n        }\n\n        CHECK_EQ(MqttSocket_Init(&client, &net), MQTT_CODE_SUCCESS);\n\n#if 0\n        if ( ds.Get<bool>() ) {\n            //CHECK_EQ(MqttClient_SetPropertyCallback(&client, mqtt_property_cb, NULL);\n        }\n#endif\n\n        CHECK_EQ(MqttClient_NetConnect(&client, \"dummy\", 12345, 1000, 0, NULL), MQTT_CODE_SUCCESS);\n        CHECK_EQ(MqttClient_Connect(&client, &connect), MQTT_CODE_SUCCESS);\n\n        ret = true;\n\n    } catch ( ... ) {\n        return false;\n    }\n\nend:\n    return ret;\n}",
        "file_path": "/src/wolfmqtt-fuzzers/fuzzer.cpp",
        "crashing_line": "        CHECK_EQ(MqttClient_Connect(&client, &connect), MQTT_CODE_SUCCESS);",
        "crashing_line_number": 430
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "    simdutf_really_inline size_t convert(const char* in, size_t size, char16_t* utf16_output) {\n      size_t pos = 0;\n      char16_t* start{utf16_output};\n      // In the worst case, we have the haswell kernel which can cause an overflow of\n      // 8 bytes when calling convert_masked_utf8_to_utf16. If you skip the last 16 bytes,\n      // and if the data is valid, then it is entirely safe because 16 UTF-8 bytes generate\n      // much more than 8 bytes.\n      const size_t safety_margin = 16; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf16<endian>(utf16_output);\n          utf16_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf16<endian>(in + pos,\n                            utf8_end_of_code_point_mask, utf16_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) { return 0; }\n      if(pos < size) {\n        size_t howmany  = scalar::utf8_to_utf16::convert<endian>(in + pos, size - pos, utf16_output);\n        if(howmany == 0) { return 0; }\n        utf16_output += howmany;\n      }\n      return utf16_output - start;\n    }\n    simdutf_really_inline result convert_with_errors(const char* in, size_t size, char16_t* utf16_output) {\n      size_t pos = 0;\n      char16_t* start{utf16_output};\n      const size_t safety_margin = 16; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf16<endian>(utf16_output);\n          utf16_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          if (errors()) {\n            // rewind_and_convert_with_errors will seek a potential error from in+pos onward,\n            // with the ability to go back up to pos bytes, and read size-pos bytes forward.\n            result res = scalar::utf8_to_utf16::rewind_and_convert_with_errors<endian>(pos, in + pos, size - pos, utf16_output);\n            res.count += pos;\n            return res;\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf16<endian>(in + pos,\n                            utf8_end_of_code_point_mask, utf16_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) {\n        // rewind_and_convert_with_errors will seek a potential error from in+pos onward,\n        // with the ability to go back up to pos bytes, and read size-pos bytes forward.\n        result res = scalar::utf8_to_utf16::rewind_and_convert_with_errors<endian>(pos, in + pos, size - pos, utf16_output);\n        res.count += pos;\n        return res;\n      }\n      if(pos < size) {\n        // rewind_and_convert_with_errors will seek a potential error from in+pos onward,\n        // with the ability to go back up to pos bytes, and read size-pos bytes forward.\n        result res = scalar::utf8_to_utf16::rewind_and_convert_with_errors<endian>(pos, in + pos, size - pos, utf16_output);\n        if (res.error) {    // In case of error, we want the error position\n          res.count += pos;\n          return res;\n        } else {    // In case of success, we want the number of word written\n          utf16_output += res.count;\n        }\n      }\n      return result(error_code::SUCCESS, utf16_output - start);\n    }\n    simdutf_really_inline size_t convert(const char* in, size_t size, char32_t* utf32_output) {\n      size_t pos = 0;\n      char32_t* start{utf32_output};\n      // In the worst case, we have the haswell kernel which can cause an overflow of\n      // 8 bytes when calling convert_masked_utf8_to_utf16. If you skip the last 16 bytes,\n      // and if the data is valid, then it is entirely safe because 16 UTF-8 bytes generate\n      // much more than 8 bytes.\n      const size_t safety_margin = 16; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf32(utf32_output);\n          utf32_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf32(in + pos,\n                            utf8_end_of_code_point_mask, utf32_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) { return 0; }\n      if(pos < size) {\n        size_t howmany  = scalar::utf8_to_utf32::convert(in + pos, size - pos, utf32_output);\n        if(howmany == 0) { return 0; }\n        utf32_output += howmany;\n      }\n      return utf32_output - start;\n    }\n    simdutf_really_inline result convert_with_errors(const char* in, size_t size, char32_t* utf32_output) {\n      size_t pos = 0;\n      char32_t* start{utf32_output};\n      const size_t safety_margin = 16; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf32(utf32_output);\n          utf32_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          if (errors()) {\n            result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n            res.count += pos;\n            return res;\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf32(in + pos,\n                            utf8_end_of_code_point_mask, utf32_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) {\n        result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n        res.count += pos;\n        return res;\n      }\n      if(pos < size) {\n        result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n        if (res.error) {    // In case of error, we want the error position\n          res.count += pos;\n          return res;\n        } else {    // In case of success, we want the number of word written\n          utf32_output += res.count;\n        }\n      }\n      return result(error_code::SUCCESS, utf32_output - start);\n    }\n",
    "target": 1,
    "idx": 1057670,
    "stack_trace": []
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int fuzz_reader_connect(sc_reader_t *reader)\n{\n    uint16_t chunk_size;\n    const uint8_t *chunk;\n\n    fuzz_get_chunk(reader, &chunk, &chunk_size);\n\n    if (chunk_size > reader->atr.len && reader->atr.len > 0)\n        chunk_size = reader->atr.len;\n    else\n        reader->atr.len = chunk_size;\n\n    if (chunk_size > 0)\n        memcpy(reader->atr.value, chunk, chunk_size);\n\n    return SC_SUCCESS;\n}\n",
    "target": 1,
    "idx": 1020188,
    "stack_trace": [
      {
        "function_name": "fuzz_reader_connect",
        "function_body": "static int fuzz_reader_connect(sc_reader_t *reader)\n{\n    uint16_t chunk_size;\n    const uint8_t *chunk;\n\n    fuzz_get_chunk(reader, &chunk, &chunk_size);\n\n    if (chunk_size > SC_MAX_ATR_SIZE)\n        chunk_size = SC_MAX_ATR_SIZE;\n    else\n        reader->atr.len = chunk_size;\n\n    if (chunk_size > 0)\n        memcpy(reader->atr.value, chunk, chunk_size);\n\n    return SC_SUCCESS;\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/fuzz_pkcs15_reader.c",
        "crashing_line": "        memcpy(reader->atr.value, chunk, chunk_size);",
        "crashing_line_number": 112
      },
      {
        "function_name": "sc_connect_card",
        "function_body": "int sc_connect_card(sc_reader_t *reader, sc_card_t **card_out)\n{\n\tsc_card_t *card;\n\tsc_context_t *ctx;\n\tstruct sc_card_driver *driver;\n\tint i, r = 0, idx, connected = 0;\n\n\tif (card_out == NULL || reader == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tctx = reader->ctx;\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (reader->ops->connect == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tcard = sc_card_new(ctx);\n\tif (card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\tr = reader->ops->connect(reader);\n\tif (r)\n\t\tgoto err;\n\n\tconnected = 1;\n\tcard->reader = reader;\n\tcard->ctx = ctx;\n\n\tif (reader->flags & SC_READER_ENABLE_ESCAPE)\n\t\tsc_detect_escape_cmds(reader);\n\n\tmemcpy(&card->atr, &reader->atr, sizeof(card->atr));\n\tmemcpy(&card->uid, &reader->uid, sizeof(card->uid));\n\n\t_sc_parse_atr(reader);\n\n\t/* See if the ATR matches any ATR specified in the config file */\n\tif ((driver = ctx->forced_driver) == NULL) {\n\t\tsc_log(ctx, \"matching configured ATRs\");\n\t\tfor (i = 0; ctx->card_drivers[i] != NULL; i++) {\n\t\t\tdriver = ctx->card_drivers[i];\n\n\t\t\tif (driver->atr_map == NULL ||\n\t\t\t    !strcmp(driver->short_name, \"default\")) {\n\t\t\t\tdriver = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsc_log(ctx, \"trying driver '%s'\", driver->short_name);\n\t\t\tidx = _sc_match_atr(card, driver->atr_map, NULL);\n\t\t\tif (idx >= 0) {\n\t\t\t\tstruct sc_atr_table *src = &driver->atr_map[idx];\n\n\t\t\t\tsc_log(ctx, \"matched driver '%s'\", driver->name);\n\t\t\t\t/* It's up to card driver to notice these correctly */\n\t\t\t\tcard->name = src->name;\n\t\t\t\tcard->type = src->type;\n\t\t\t\tcard->flags = src->flags;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdriver = NULL;\n\t\t}\n\t}\n\n\tif (driver != NULL) {\n\t\t/* Forced driver, or matched via ATR mapping from config file */\n\t\tcard->driver = driver;\n\n\t\tmemcpy(card->ops, card->driver->ops, sizeof(struct sc_card_operations));\n\t\tif (card->ops->match_card != NULL)\n\t\t\tif (card->ops->match_card(card) != 1)\n\t\t\t\tsc_log(ctx, \"driver '%s' match_card() failed: %s (will continue anyway)\", card->driver->name, sc_strerror(r));\n\n\t\tif (card->ops->init != NULL) {\n\t\t\tr = card->ops->init(card);\n\t\t\tif (r) {\n\t\t\t\tsc_log(ctx, \"driver '%s' init() failed: %s\", card->driver->name, sc_strerror(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tsc_card_t uninitialized = *card;\n\t\tsc_log(ctx, \"matching built-in ATRs\");\n\t\tfor (i = 0; ctx->card_drivers[i] != NULL; i++) {\n\t\t\t/* FIXME If we had a clean API description, we'd propably get a\n\t\t\t * cleaner implementation of the driver's match_card and init,\n\t\t\t * which should normally *not* modify the card object if\n\t\t\t * unsuccessful. However, after years of relentless hacking, reality\n\t\t\t * is different: The card object is changed in virtually every card\n\t\t\t * driver so in order to prevent unwanted interaction, we reset the\n\t\t\t * card object here and hope that the card driver at least doesn't\n\t\t\t * allocate any internal ressources that need to be freed. If we\n\t\t\t * had more time, we should refactor the existing code to not\n\t\t\t * modify sc_card_t until complete success (possibly by combining\n\t\t\t * `match_card()` and `init()`) */\n\t\t\t*card = uninitialized;\n\n\t\t\tstruct sc_card_driver *drv = ctx->card_drivers[i];\n\t\t\tconst struct sc_card_operations *ops = drv->ops;\n\n\t\t\tsc_log(ctx, \"trying driver '%s'\", drv->short_name);\n\t\t\tif (ops == NULL || ops->match_card == NULL)   {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (!(ctx->flags & SC_CTX_FLAG_ENABLE_DEFAULT_DRIVER)\n\t\t\t\t   \t&& !strcmp(\"default\", drv->short_name))   {\n\t\t\t\tsc_log(ctx , \"ignore 'default' card driver\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Needed if match_card() needs to talk with the card (e.g. card-muscle) */\n\t\t\t*card->ops = *ops;\n\t\t\tif (ops->match_card(card) != 1)\n\t\t\t\tcontinue;\n\t\t\tsc_log(ctx, \"matched: %s\", drv->name);\n\t\t\tmemcpy(card->ops, ops, sizeof(struct sc_card_operations));\n\t\t\tcard->driver = drv;\n\t\t\tr = ops->init(card);\n\t\t\tif (r) {\n\t\t\t\tsc_log(ctx, \"driver '%s' init() failed: %s\", drv->name, sc_strerror(r));\n\t\t\t\tif (r == SC_ERROR_INVALID_CARD) {\n\t\t\t\t\tcard->driver = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (card->driver == NULL) {\n\t\tsc_log(ctx, \"unable to find driver for inserted card\");\n\t\tr = SC_ERROR_INVALID_CARD;\n\t\tgoto err;\n\t}\n\tif (card->name == NULL)\n\t\tcard->name = card->driver->name;\n\n\t/* initialize max_send_size/max_recv_size to a meaningful value */\n\tcard->max_recv_size = sc_get_max_recv_size(card);\n\tcard->max_send_size = sc_get_max_send_size(card);\n\n\tsc_log(ctx,\n\t       \"card info name:'%s', type:%i, flags:0x%lX, max_send/recv_size:%\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card->name, card->type, card->flags, card->max_send_size,\n\t       card->max_recv_size);\n\n#ifdef ENABLE_SM\n        /* Check, if secure messaging module present. */\n\tr = sc_card_sm_check(card);\n\tif (r)   {\n\t\tsc_log(ctx, \"cannot load secure messaging module\");\n\t\tgoto err;\n\t}\n#endif\n\t*card_out = card;\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerr:\n\tif (connected)\n\t\treader->ops->disconnect(reader);\n\tif (card != NULL)\n\t\tsc_card_free(card);\n\tLOG_FUNC_RETURN(ctx, r);\n}",
        "file_path": "/src/opensc/src/libopensc/card.c",
        "crashing_line": "\tr = reader->ops->connect(reader);",
        "crashing_line_number": 261
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "size_t HUF_writeCTable_wksp(void* dst, size_t maxDstSize,\n                            const HUF_CElt* CTable, unsigned maxSymbolValue, unsigned huffLog,\n                            void* workspace, size_t workspaceSize)\n{\n    BYTE* op = (BYTE*)dst;\n    U32 n;\n    HUF_WriteCTableWksp* wksp = (HUF_WriteCTableWksp*)workspace;\n\n    /* check conditions */\n    if (workspaceSize < sizeof(HUF_WriteCTableWksp)) return ERROR(GENERIC);\n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);\n\n    /* convert to weight */\n    wksp->bitsToWeight[0] = 0;\n    for (n=1; n<huffLog+1; n++)\n        wksp->bitsToWeight[n] = (BYTE)(huffLog + 1 - n);\n    for (n=0; n<maxSymbolValue; n++)\n        wksp->huffWeight[n] = wksp->bitsToWeight[CTable[n].nbBits];\n\n    /* attempt weights compression by FSE */\n    {   CHECK_V_F(hSize, HUF_compressWeights(op+1, maxDstSize-1, wksp->huffWeight, maxSymbolValue, &wksp->wksp, sizeof(wksp->wksp)) );\n        if ((hSize>1) & (hSize < maxSymbolValue/2)) {   /* FSE compressed */\n            op[0] = (BYTE)hSize;\n            return hSize+1;\n    }   }\n\n    /* write raw values as 4-bits (max : 15) */\n    if (maxSymbolValue > (256-128)) return ERROR(GENERIC);   /* should not happen : likely means source cannot be compressed */\n    if (((maxSymbolValue+1)/2) + 1 > maxDstSize) return ERROR(dstSize_tooSmall);   /* not enough space within dst buffer */\n    op[0] = (BYTE)(128 /*special case*/ + (maxSymbolValue-1));\n    wksp->huffWeight[maxSymbolValue] = 0;   /* to be sure it doesn't cause msan issue in final combination */\n    for (n=0; n<maxSymbolValue; n+=2)\n        op[(n/2)+1] = (BYTE)((wksp->huffWeight[n] << 4) + wksp->huffWeight[n+1]);\n    return ((maxSymbolValue+1)/2) + 1;\n}\nstatic size_t ZSTD_compressSeqStore_singleBlock(ZSTD_CCtx* zc, seqStore_t* const seqStore,\n                                                repcodes_t* const dRep, repcodes_t* const cRep,\n                                                void* dst, size_t dstCapacity,\n                                                const void* src, size_t srcSize,\n                                                U32 lastBlock, U32 isPartition) {\n    const U32 rleMaxLength = 25;\n    BYTE* op = (BYTE*)dst;\n    const BYTE* ip = (const BYTE*)src;\n    size_t cSize;\n    size_t cSeqsSize;\n\n    /* In case of an RLE or raw block, the simulated decompression repcode history must be reset */\n    repcodes_t const dRepOriginal = *dRep;\n    if (isPartition)\n        ZSTD_seqStore_resolveOffCodes(dRep, cRep, seqStore, (U32)(seqStore->sequences - seqStore->sequencesStart));\n\n    cSeqsSize = ZSTD_entropyCompressSeqStore(seqStore,\n                &zc->blockState.prevCBlock->entropy, &zc->blockState.nextCBlock->entropy,\n                &zc->appliedParams,\n                op + ZSTD_blockHeaderSize, dstCapacity - ZSTD_blockHeaderSize,\n                srcSize,\n                zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */,\n                zc->bmi2);\n    FORWARD_IF_ERROR(cSeqsSize, \"ZSTD_entropyCompressSeqStore failed!\");\n\n    if (!zc->isFirstBlock &&\n        cSeqsSize < rleMaxLength &&\n        ZSTD_isRLE((BYTE const*)src, srcSize)) {\n        /* We don't want to emit our first block as a RLE even if it qualifies because\n        * doing so will cause the decoder (cli only) to throw a \"should consume all input error.\"\n        * This is only an issue for zstd <= v1.4.3\n        */\n        cSeqsSize = 1;\n    }\n\n    if (zc->seqCollector.collectSequences) {\n        ZSTD_copyBlockSequences(zc);\n        ZSTD_blockState_confirmRepcodesAndEntropyTables(&zc->blockState);\n        return 0;\n    }\n\n    if (cSeqsSize == 0) {\n        cSize = ZSTD_noCompressBlock(op, dstCapacity, ip, srcSize, lastBlock);\n        FORWARD_IF_ERROR(cSize, \"Nocompress block failed\");\n        DEBUGLOG(4, \"Writing out nocompress block, size: %zu\", cSize);\n        *dRep = dRepOriginal; /* reset simulated decompression repcode history */\n    } else if (cSeqsSize == 1) {\n        cSize = ZSTD_rleCompressBlock(op, dstCapacity, *ip, srcSize, lastBlock);\n        FORWARD_IF_ERROR(cSize, \"RLE compress block failed\");\n        DEBUGLOG(4, \"Writing out RLE block, size: %zu\", cSize);\n        *dRep = dRepOriginal; /* reset simulated decompression repcode history */\n    } else {\n        ZSTD_blockState_confirmRepcodesAndEntropyTables(&zc->blockState);\n        writeBlockHeader(op, cSeqsSize, srcSize, lastBlock);\n        cSize = ZSTD_blockHeaderSize + cSeqsSize;\n        DEBUGLOG(4, \"Writing out compressed block, size: %zu\", cSize);\n    }\n\n    if (zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)\n        zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;\n\n    return cSize;\n}\n",
    "target": 1,
    "idx": 1035209,
    "stack_trace": [
      {
        "function_name": "FSE_writeNCount_generic",
        "function_body": "static size_t\nFSE_writeNCount_generic (void* header, size_t headerBufferSize,\n                   const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog,\n                         unsigned writeIsSafe)\n{\n    BYTE* const ostart = (BYTE*) header;\n    BYTE* out = ostart;\n    BYTE* const oend = ostart + headerBufferSize;\n    int nbBits;\n    const int tableSize = 1 << tableLog;\n    int remaining;\n    int threshold;\n    U32 bitStream = 0;\n    int bitCount = 0;\n    unsigned symbol = 0;\n    unsigned const alphabetSize = maxSymbolValue + 1;\n    int previousIs0 = 0;\n\n    /* Table Size */\n    bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;\n    bitCount  += 4;\n\n    /* Init */\n    remaining = tableSize+1;   /* +1 for extra accuracy */\n    threshold = tableSize;\n    nbBits = tableLog+1;\n\n    while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */\n        if (previousIs0) {\n            unsigned start = symbol;\n            while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;\n            if (symbol == alphabetSize) break;   /* incorrect distribution */\n            while (symbol >= start+24) {\n                start+=24;\n                bitStream += 0xFFFFU << bitCount;\n                if ((!writeIsSafe) && (out > oend-2))\n                    return ERROR(dstSize_tooSmall);   /* Buffer overflow */\n                out[0] = (BYTE) bitStream;\n                out[1] = (BYTE)(bitStream>>8);\n                out+=2;\n                bitStream>>=16;\n            }\n            while (symbol >= start+3) {\n                start+=3;\n                bitStream += 3 << bitCount;\n                bitCount += 2;\n            }\n            bitStream += (symbol-start) << bitCount;\n            bitCount += 2;\n            if (bitCount>16) {\n                if ((!writeIsSafe) && (out > oend - 2))\n                    return ERROR(dstSize_tooSmall);   /* Buffer overflow */\n                out[0] = (BYTE)bitStream;\n                out[1] = (BYTE)(bitStream>>8);\n                out += 2;\n                bitStream >>= 16;\n                bitCount -= 16;\n        }   }\n        {   int count = normalizedCounter[symbol++];\n            int const max = (2*threshold-1) - remaining;\n            remaining -= count < 0 ? -count : count;\n            count++;   /* +1 for extra accuracy */\n            if (count>=threshold)\n                count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */\n            bitStream += count << bitCount;\n            bitCount  += nbBits;\n            bitCount  -= (count<max);\n            previousIs0  = (count==1);\n            if (remaining<1) return ERROR(GENERIC);\n            while (remaining<threshold) { nbBits--; threshold>>=1; }\n        }\n        if (bitCount>16) {\n            if ((!writeIsSafe) && (out > oend - 2))\n                return ERROR(dstSize_tooSmall);   /* Buffer overflow */\n            out[0] = (BYTE)bitStream;\n            out[1] = (BYTE)(bitStream>>8);\n            out += 2;\n            bitStream >>= 16;\n            bitCount -= 16;\n    }   }\n\n    if (remaining != 1)\n        return ERROR(GENERIC);  /* incorrect normalized distribution */\n    assert(symbol <= alphabetSize);\n\n    /* flush remaining bitStream */\n    if ((!writeIsSafe) && (out > oend - 2))\n        return ERROR(dstSize_tooSmall);   /* Buffer overflow */\n    out[0] = (BYTE)bitStream;\n    out[1] = (BYTE)(bitStream>>8);\n    out+= (bitCount+7) /8;\n\n    return (out-ostart);\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/fse_compress.c",
        "crashing_line": "            out[0] = (BYTE)bitStream;",
        "crashing_line_number": 270
      },
      {
        "function_name": "HUF_compressWeights",
        "function_body": "static size_t HUF_compressWeights(void* dst, size_t dstSize, const void* weightTable, size_t wtSize, void* workspace, size_t workspaceSize)\n{\n    BYTE* const ostart = (BYTE*) dst;\n    BYTE* op = ostart;\n    BYTE* const oend = ostart + dstSize;\n\n    unsigned maxSymbolValue = HUF_TABLELOG_MAX;\n    U32 tableLog = MAX_FSE_TABLELOG_FOR_HUFF_HEADER;\n    HUF_CompressWeightsWksp* wksp = (HUF_CompressWeightsWksp*)workspace;\n\n    if (workspaceSize < sizeof(HUF_CompressWeightsWksp)) return ERROR(GENERIC);\n\n    /* init conditions */\n    if (wtSize <= 1) return 0;  /* Not compressible */\n\n    /* Scan input and build symbol stats */\n    {   unsigned const maxCount = HIST_count_simple(wksp->count, &maxSymbolValue, weightTable, wtSize);   /* never fails */\n        if (maxCount == wtSize) return 1;   /* only a single symbol in src : rle */\n        if (maxCount == 1) return 0;        /* each symbol present maximum once => not compressible */\n    }\n\n    tableLog = FSE_optimalTableLog(tableLog, wtSize, maxSymbolValue);\n    CHECK_F( FSE_normalizeCount(wksp->norm, tableLog, wksp->count, wtSize, maxSymbolValue, /* useLowProbCount */ 0) );\n\n    /* Write table description header */\n    {   CHECK_V_F(hSize, FSE_writeNCount(op, (size_t)(oend-op), wksp->norm, maxSymbolValue, tableLog) );\n        op += hSize;\n    }\n\n    /* Compress */\n    CHECK_F( FSE_buildCTable_wksp(wksp->CTable, wksp->norm, maxSymbolValue, tableLog, wksp->scratchBuffer, sizeof(wksp->scratchBuffer)) );\n    {   CHECK_V_F(cSize, FSE_compress_usingCTable(op, (size_t)(oend - op), weightTable, wtSize, wksp->CTable) );\n        if (cSize == 0) return 0;   /* not enough space for compressed data */\n        op += cSize;\n    }\n\n    return (size_t)(op-ostart);\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/huf_compress.c",
        "crashing_line": "    {   CHECK_V_F(hSize, FSE_writeNCount(op, (size_t)(oend-op), wksp->norm, maxSymbolValue, tableLog) );",
        "crashing_line_number": 95
      },
      {
        "function_name": "HUF_writeCTable_wksp",
        "function_body": "size_t HUF_writeCTable_wksp(void* dst, size_t maxDstSize,\n                            const HUF_CElt* CTable, unsigned maxSymbolValue, unsigned huffLog,\n                            void* workspace, size_t workspaceSize)\n{\n    BYTE* op = (BYTE*)dst;\n    U32 n;\n    HUF_WriteCTableWksp* wksp = (HUF_WriteCTableWksp*)workspace;\n\n    /* check conditions */\n    if (workspaceSize < sizeof(HUF_WriteCTableWksp)) return ERROR(GENERIC);\n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);\n\n    /* convert to weight */\n    wksp->bitsToWeight[0] = 0;\n    for (n=1; n<huffLog+1; n++)\n        wksp->bitsToWeight[n] = (BYTE)(huffLog + 1 - n);\n    for (n=0; n<maxSymbolValue; n++)\n        wksp->huffWeight[n] = wksp->bitsToWeight[CTable[n].nbBits];\n\n    /* attempt weights compression by FSE */\n    if (maxDstSize < 1) return ERROR(dstSize_tooSmall);\n    {   CHECK_V_F(hSize, HUF_compressWeights(op+1, maxDstSize-1, wksp->huffWeight, maxSymbolValue, &wksp->wksp, sizeof(wksp->wksp)) );\n        if ((hSize>1) & (hSize < maxSymbolValue/2)) {   /* FSE compressed */\n            op[0] = (BYTE)hSize;\n            return hSize+1;\n    }   }\n\n    /* write raw values as 4-bits (max : 15) */\n    if (maxSymbolValue > (256-128)) return ERROR(GENERIC);   /* should not happen : likely means source cannot be compressed */\n    if (((maxSymbolValue+1)/2) + 1 > maxDstSize) return ERROR(dstSize_tooSmall);   /* not enough space within dst buffer */\n    op[0] = (BYTE)(128 /*special case*/ + (maxSymbolValue-1));\n    wksp->huffWeight[maxSymbolValue] = 0;   /* to be sure it doesn't cause msan issue in final combination */\n    for (n=0; n<maxSymbolValue; n+=2)\n        op[(n/2)+1] = (BYTE)((wksp->huffWeight[n] << 4) + wksp->huffWeight[n+1]);\n    return ((maxSymbolValue+1)/2) + 1;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/huf_compress.c",
        "crashing_line": "    if (maxDstSize < 1) return ERROR(dstSize_tooSmall);",
        "crashing_line_number": 136
      },
      {
        "function_name": "HUF_compress_internal",
        "function_body": "static size_t\nHUF_compress_internal (void* dst, size_t dstSize,\n                 const void* src, size_t srcSize,\n                       unsigned maxSymbolValue, unsigned huffLog,\n                       HUF_nbStreams_e nbStreams,\n                       void* workSpace_align4, size_t wkspSize,\n                       HUF_CElt* oldHufTable, HUF_repeat* repeat, int preferRepeat,\n                 const int bmi2)\n{\n    HUF_compress_tables_t* const table = (HUF_compress_tables_t*)workSpace_align4;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstSize;\n    BYTE* op = ostart;\n\n    HUF_STATIC_ASSERT(sizeof(*table) <= HUF_WORKSPACE_SIZE);\n    assert(((size_t)workSpace_align4 & 3) == 0);   /* must be aligned on 4-bytes boundaries */\n\n    /* checks & inits */\n    if (wkspSize < HUF_WORKSPACE_SIZE) return ERROR(workSpace_tooSmall);\n    if (!srcSize) return 0;  /* Uncompressed */\n    if (!dstSize) return 0;  /* cannot fit anything within dst budget */\n    if (srcSize > HUF_BLOCKSIZE_MAX) return ERROR(srcSize_wrong);   /* current block size limit */\n    if (huffLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);\n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);\n    if (!maxSymbolValue) maxSymbolValue = HUF_SYMBOLVALUE_MAX;\n    if (!huffLog) huffLog = HUF_TABLELOG_DEFAULT;\n\n    /* Heuristic : If old table is valid, use it for small inputs */\n    if (preferRepeat && repeat && *repeat == HUF_repeat_valid) {\n        return HUF_compressCTable_internal(ostart, op, oend,\n                                           src, srcSize,\n                                           nbStreams, oldHufTable, bmi2);\n    }\n\n    /* Scan input and build symbol stats */\n    {   CHECK_V_F(largest, HIST_count_wksp (table->count, &maxSymbolValue, (const BYTE*)src, srcSize, workSpace_align4, wkspSize) );\n        if (largest == srcSize) { *ostart = ((const BYTE*)src)[0]; return 1; }   /* single symbol, rle */\n        if (largest <= (srcSize >> 7)+4) return 0;   /* heuristic : probably not compressible enough */\n    }\n\n    /* Check validity of previous table */\n    if ( repeat\n      && *repeat == HUF_repeat_check\n      && !HUF_validateCTable(oldHufTable, table->count, maxSymbolValue)) {\n        *repeat = HUF_repeat_none;\n    }\n    /* Heuristic : use existing table for small inputs */\n    if (preferRepeat && repeat && *repeat != HUF_repeat_none) {\n        return HUF_compressCTable_internal(ostart, op, oend,\n                                           src, srcSize,\n                                           nbStreams, oldHufTable, bmi2);\n    }\n\n    /* Build Huffman Tree */\n    huffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue);\n    {   size_t const maxBits = HUF_buildCTable_wksp(table->CTable, table->count,\n                                            maxSymbolValue, huffLog,\n                                            &table->wksps.buildCTable_wksp, sizeof(table->wksps.buildCTable_wksp));\n        CHECK_F(maxBits);\n        huffLog = (U32)maxBits;\n        /* Zero unused symbols in CTable, so we can check it for validity */\n        ZSTD_memset(table->CTable + (maxSymbolValue + 1), 0,\n               sizeof(table->CTable) - ((maxSymbolValue + 1) * sizeof(HUF_CElt)));\n    }\n\n    /* Write table description header */\n    {   CHECK_V_F(hSize, HUF_writeCTable_wksp(op, dstSize, table->CTable, maxSymbolValue, huffLog,\n                                              &table->wksps.writeCTable_wksp, sizeof(table->wksps.writeCTable_wksp)) );\n        /* Check if using previous huffman table is beneficial */\n        if (repeat && *repeat != HUF_repeat_none) {\n            size_t const oldSize = HUF_estimateCompressedSize(oldHufTable, table->count, maxSymbolValue);\n            size_t const newSize = HUF_estimateCompressedSize(table->CTable, table->count, maxSymbolValue);\n            if (oldSize <= hSize + newSize || hSize + 12 >= srcSize) {\n                return HUF_compressCTable_internal(ostart, op, oend,\n                                                   src, srcSize,\n                                                   nbStreams, oldHufTable, bmi2);\n        }   }\n\n        /* Use the new huffman table */\n        if (hSize + 12ul >= srcSize) { return 0; }\n        op += hSize;\n        if (repeat) { *repeat = HUF_repeat_none; }\n        if (oldHufTable)\n            ZSTD_memcpy(oldHufTable, table->CTable, sizeof(table->CTable));  /* Save new table */\n    }\n    return HUF_compressCTable_internal(ostart, op, oend,\n                                       src, srcSize,\n                                       nbStreams, table->CTable, bmi2);\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/huf_compress.c",
        "crashing_line": "    /* Write table description header */",
        "crashing_line_number": 829
      },
      {
        "function_name": "HUF_compress4X_repeat",
        "function_body": "size_t HUF_compress4X_repeat (void* dst, size_t dstSize,\n                      const void* src, size_t srcSize,\n                      unsigned maxSymbolValue, unsigned huffLog,\n                      void* workSpace, size_t wkspSize,\n                      HUF_CElt* hufTable, HUF_repeat* repeat, int preferRepeat, int bmi2)\n{\n    return HUF_compress_internal(dst, dstSize, src, srcSize,\n                                 maxSymbolValue, huffLog, HUF_fourStreams,\n                                 workSpace, wkspSize,\n                                 hufTable, repeat, preferRepeat, bmi2);\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/huf_compress.c",
        "crashing_line": "{",
        "crashing_line_number": 900
      },
      {
        "function_name": "ZSTD_compressLiterals",
        "function_body": "size_t ZSTD_compressLiterals (ZSTD_hufCTables_t const* prevHuf,\n                              ZSTD_hufCTables_t* nextHuf,\n                              ZSTD_strategy strategy, int disableLiteralCompression,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize,\n                              void* entropyWorkspace, size_t entropyWorkspaceSize,\n                        const int bmi2)\n{\n    size_t const minGain = ZSTD_minGain(srcSize, strategy);\n    size_t const lhSize = 3 + (srcSize >= 1 KB) + (srcSize >= 16 KB);\n    BYTE*  const ostart = (BYTE*)dst;\n    U32 singleStream = srcSize < 256;\n    symbolEncodingType_e hType = set_compressed;\n    size_t cLitSize;\n\n    DEBUGLOG(5,\"ZSTD_compressLiterals (disableLiteralCompression=%i srcSize=%u)\",\n                disableLiteralCompression, (U32)srcSize);\n\n    /* Prepare nextEntropy assuming reusing the existing table */\n    ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n\n    if (disableLiteralCompression)\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n\n    /* small ? don't even attempt compression (speed opt) */\n#   define COMPRESS_LITERALS_SIZE_MIN 63\n    {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;\n        if (srcSize <= minLitSize) return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n\n    RETURN_ERROR_IF(dstCapacity < lhSize+1, dstSize_tooSmall, \"not enough space for compression\");\n    {   HUF_repeat repeat = prevHuf->repeatMode;\n        int const preferRepeat = strategy < ZSTD_lazy ? srcSize <= 1024 : 0;\n        if (repeat == HUF_repeat_valid && lhSize == 3) singleStream = 1;\n        cLitSize = singleStream ?\n            HUF_compress1X_repeat(\n                ostart+lhSize, dstCapacity-lhSize, src, srcSize,\n                HUF_SYMBOLVALUE_MAX, HUF_TABLELOG_DEFAULT, entropyWorkspace, entropyWorkspaceSize,\n                (HUF_CElt*)nextHuf->CTable, &repeat, preferRepeat, bmi2) :\n            HUF_compress4X_repeat(\n                ostart+lhSize, dstCapacity-lhSize, src, srcSize,\n                HUF_SYMBOLVALUE_MAX, HUF_TABLELOG_DEFAULT, entropyWorkspace, entropyWorkspaceSize,\n                (HUF_CElt*)nextHuf->CTable, &repeat, preferRepeat, bmi2);\n        if (repeat != HUF_repeat_none) {\n            /* reused the existing table */\n            DEBUGLOG(5, \"Reusing previous huffman table\");\n            hType = set_repeat;\n        }\n    }\n\n    if ((cLitSize==0) || (cLitSize >= srcSize - minGain) || ERR_isError(cLitSize)) {\n        ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n    if (cLitSize==1) {\n        ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_compressRleLiteralsBlock(dst, dstCapacity, src, srcSize);\n    }\n\n    if (hType == set_compressed) {\n        /* using a newly constructed table */\n        nextHuf->repeatMode = HUF_repeat_check;\n    }\n\n    /* Build header */\n    switch(lhSize)\n    {\n    case 3: /* 2 - 2 - 10 - 10 */\n        {   U32 const lhc = hType + ((!singleStream) << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<14);\n            MEM_writeLE24(ostart, lhc);\n            break;\n        }\n    case 4: /* 2 - 2 - 14 - 14 */\n        {   U32 const lhc = hType + (2 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<18);\n            MEM_writeLE32(ostart, lhc);\n            break;\n        }\n    case 5: /* 2 - 2 - 18 - 18 */\n        {   U32 const lhc = hType + (3 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<22);\n            MEM_writeLE32(ostart, lhc);\n            ostart[4] = (BYTE)(cLitSize >> 10);\n            break;\n        }\n    default:  /* not possible : lhSize is {3,4,5} */\n        assert(0);\n    }\n    DEBUGLOG(5, \"Compressed literals: %u -> %u\", (U32)srcSize, (U32)(lhSize+cLitSize));\n    return lhSize+cLitSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress_literals.c",
        "crashing_line": "            HUF_compress4X_repeat(",
        "crashing_line_number": 109
      },
      {
        "function_name": "ZSTD_entropyCompressSeqStore_internal",
        "function_body": "MEM_STATIC size_t\nZSTD_entropyCompressSeqStore_internal(seqStore_t* seqStorePtr,\n                          const ZSTD_entropyCTables_t* prevEntropy,\n                                ZSTD_entropyCTables_t* nextEntropy,\n                          const ZSTD_CCtx_params* cctxParams,\n                                void* dst, size_t dstCapacity,\n                                void* entropyWorkspace, size_t entropyWkspSize,\n                          const int bmi2)\n{\n    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;\n    ZSTD_strategy const strategy = cctxParams->cParams.strategy;\n    unsigned* count = (unsigned*)entropyWorkspace;\n    FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;\n    FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;\n    FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;\n    const seqDef* const sequences = seqStorePtr->sequencesStart;\n    const size_t nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n    const BYTE* const ofCodeTable = seqStorePtr->ofCode;\n    const BYTE* const llCodeTable = seqStorePtr->llCode;\n    const BYTE* const mlCodeTable = seqStorePtr->mlCode;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    size_t lastCountSize;\n\n    entropyWorkspace = count + (MaxSeq + 1);\n    entropyWkspSize -= (MaxSeq + 1) * sizeof(*count);\n\n    DEBUGLOG(4, \"ZSTD_entropyCompressSeqStore_internal (nbSeq=%zu)\", nbSeq);\n    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));\n    assert(entropyWkspSize >= HUF_WORKSPACE_SIZE);\n\n    /* Compress literals */\n    {   const BYTE* const literals = seqStorePtr->litStart;\n        size_t const litSize = (size_t)(seqStorePtr->lit - literals);\n        size_t const cSize = ZSTD_compressLiterals(\n                                    &prevEntropy->huf, &nextEntropy->huf,\n                                    cctxParams->cParams.strategy,\n                                    ZSTD_disableLiteralsCompression(cctxParams),\n                                    op, dstCapacity,\n                                    literals, litSize,\n                                    entropyWorkspace, entropyWkspSize,\n                                    bmi2);\n        FORWARD_IF_ERROR(cSize, \"ZSTD_compressLiterals failed\");\n        assert(cSize <= dstCapacity);\n        op += cSize;\n    }\n\n    /* Sequences Header */\n    RETURN_ERROR_IF((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/,\n                    dstSize_tooSmall, \"Can't fit seq hdr in output buf!\");\n    if (nbSeq < 128) {\n        *op++ = (BYTE)nbSeq;\n    } else if (nbSeq < LONGNBSEQ) {\n        op[0] = (BYTE)((nbSeq>>8) + 0x80);\n        op[1] = (BYTE)nbSeq;\n        op+=2;\n    } else {\n        op[0]=0xFF;\n        MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ));\n        op+=3;\n    }\n    assert(op <= oend);\n    if (nbSeq==0) {\n        /* Copy the old tables over as if we repeated them */\n        ZSTD_memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));\n        return (size_t)(op - ostart);\n    }\n    {\n        ZSTD_symbolEncodingTypeStats_t stats;\n        BYTE* seqHead = op++;\n        /* build stats for sequences */\n        stats = ZSTD_buildSequencesStatistics(seqStorePtr, nbSeq,\n                                             &prevEntropy->fse, &nextEntropy->fse,\n                                              op, oend,\n                                              strategy, count,\n                                              entropyWorkspace, entropyWkspSize);\n        FORWARD_IF_ERROR(stats.size, \"ZSTD_buildSequencesStatistics failed!\");\n        *seqHead = (BYTE)((stats.LLtype<<6) + (stats.Offtype<<4) + (stats.MLtype<<2));\n        lastCountSize = stats.lastCountSize;\n        op += stats.size;\n    }\n\n    {   size_t const bitstreamSize = ZSTD_encodeSequences(\n                                        op, (size_t)(oend - op),\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq,\n                                        longOffsets, bmi2);\n        FORWARD_IF_ERROR(bitstreamSize, \"ZSTD_encodeSequences failed\");\n        op += bitstreamSize;\n        assert(op <= oend);\n        /* zstd versions <= 1.3.4 mistakenly report corruption when\n         * FSE_readNCount() receives a buffer < 4 bytes.\n         * Fixed by https://github.com/facebook/zstd/pull/1146.\n         * This can happen when the last set_compressed table present is 2\n         * bytes and the bitstream is only one byte.\n         * In this exceedingly rare case, we will simply emit an uncompressed\n         * block, since it isn't worth optimizing.\n         */\n        if (lastCountSize && (lastCountSize + bitstreamSize) < 4) {\n            /* lastCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */\n            assert(lastCountSize + bitstreamSize == 3);\n            DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \"\n                        \"emitting an uncompressed block.\");\n            return 0;\n        }\n    }\n\n    DEBUGLOG(5, \"compressed block size : %u\", (unsigned)(op - ostart));\n    return (size_t)(op - ostart);\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "        size_t const cSize = ZSTD_compressLiterals(",
        "crashing_line_number": 2595
      },
      {
        "function_name": "ZSTD_entropyCompressSeqStore",
        "function_body": "MEM_STATIC size_t\nZSTD_entropyCompressSeqStore(seqStore_t* seqStorePtr,\n                       const ZSTD_entropyCTables_t* prevEntropy,\n                             ZSTD_entropyCTables_t* nextEntropy,\n                       const ZSTD_CCtx_params* cctxParams,\n                             void* dst, size_t dstCapacity,\n                             size_t srcSize,\n                             void* entropyWorkspace, size_t entropyWkspSize,\n                             int bmi2)\n{\n    size_t const cSize = ZSTD_entropyCompressSeqStore_internal(\n                            seqStorePtr, prevEntropy, nextEntropy, cctxParams,\n                            dst, dstCapacity,\n                            entropyWorkspace, entropyWkspSize, bmi2);\n    if (cSize == 0) return 0;\n    /* When srcSize <= dstCapacity, there is enough space to write a raw uncompressed block.\n     * Since we ran out of space, block must be not compressible, so fall back to raw uncompressed block.\n     */\n    if ((cSize == ERROR(dstSize_tooSmall)) & (srcSize <= dstCapacity))\n        return 0;  /* block not compressed */\n    FORWARD_IF_ERROR(cSize, \"ZSTD_entropyCompressSeqStore_internal failed\");\n\n    /* Check compressibility */\n    {   size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, cctxParams->cParams.strategy);\n        if (cSize >= maxCSize) return 0;  /* block not compressed */\n    }\n    DEBUGLOG(4, \"ZSTD_entropyCompressSeqStore() cSize: %zu\", cSize);\n    return cSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "    size_t const cSize = ZSTD_entropyCompressSeqStore_internal(",
        "crashing_line_number": 2684
      },
      {
        "function_name": "ZSTD_compressSeqStore_singleBlock",
        "function_body": "static size_t ZSTD_compressSeqStore_singleBlock(ZSTD_CCtx* zc, seqStore_t* const seqStore,\n                                                repcodes_t* const dRep, repcodes_t* const cRep,\n                                                void* dst, size_t dstCapacity,\n                                                const void* src, size_t srcSize,\n                                                U32 lastBlock, U32 isPartition) {\n    const U32 rleMaxLength = 25;\n    BYTE* op = (BYTE*)dst;\n    const BYTE* ip = (const BYTE*)src;\n    size_t cSize;\n    size_t cSeqsSize;\n\n    /* In case of an RLE or raw block, the simulated decompression repcode history must be reset */\n    repcodes_t const dRepOriginal = *dRep;\n    if (isPartition)\n        ZSTD_seqStore_resolveOffCodes(dRep, cRep, seqStore, (U32)(seqStore->sequences - seqStore->sequencesStart));\n\n    RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall, \"Block header doesn't fit\");\n    cSeqsSize = ZSTD_entropyCompressSeqStore(seqStore,\n                &zc->blockState.prevCBlock->entropy, &zc->blockState.nextCBlock->entropy,\n                &zc->appliedParams,\n                op + ZSTD_blockHeaderSize, dstCapacity - ZSTD_blockHeaderSize,\n                srcSize,\n                zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */,\n                zc->bmi2);\n    FORWARD_IF_ERROR(cSeqsSize, \"ZSTD_entropyCompressSeqStore failed!\");\n\n    if (!zc->isFirstBlock &&\n        cSeqsSize < rleMaxLength &&\n        ZSTD_isRLE((BYTE const*)src, srcSize)) {\n        /* We don't want to emit our first block as a RLE even if it qualifies because\n        * doing so will cause the decoder (cli only) to throw a \"should consume all input error.\"\n        * This is only an issue for zstd <= v1.4.3\n        */\n        cSeqsSize = 1;\n    }\n\n    if (zc->seqCollector.collectSequences) {\n        ZSTD_copyBlockSequences(zc);\n        ZSTD_blockState_confirmRepcodesAndEntropyTables(&zc->blockState);\n        return 0;\n    }\n\n    if (cSeqsSize == 0) {\n        cSize = ZSTD_noCompressBlock(op, dstCapacity, ip, srcSize, lastBlock);\n        FORWARD_IF_ERROR(cSize, \"Nocompress block failed\");\n        DEBUGLOG(4, \"Writing out nocompress block, size: %zu\", cSize);\n        *dRep = dRepOriginal; /* reset simulated decompression repcode history */\n    } else if (cSeqsSize == 1) {\n        cSize = ZSTD_rleCompressBlock(op, dstCapacity, *ip, srcSize, lastBlock);\n        FORWARD_IF_ERROR(cSize, \"RLE compress block failed\");\n        DEBUGLOG(4, \"Writing out RLE block, size: %zu\", cSize);\n        *dRep = dRepOriginal; /* reset simulated decompression repcode history */\n    } else {\n        ZSTD_blockState_confirmRepcodesAndEntropyTables(&zc->blockState);\n        writeBlockHeader(op, cSeqsSize, srcSize, lastBlock);\n        cSize = ZSTD_blockHeaderSize + cSeqsSize;\n        DEBUGLOG(4, \"Writing out compressed block, size: %zu\", cSize);\n    }\n\n    if (zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)\n        zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;\n\n    return cSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "    RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall, \"Block header doesn't fit\");",
        "crashing_line_number": 3489
      },
      {
        "function_name": "ZSTD_compressBlock_splitBlock_internal",
        "function_body": "static size_t ZSTD_compressBlock_splitBlock_internal(ZSTD_CCtx* zc, void* dst, size_t dstCapacity,\n                                                     const void* src, size_t blockSize, U32 lastBlock, U32 nbSeq) {\n    size_t cSize = 0;\n    const BYTE* ip = (const BYTE*)src;\n    BYTE* op = (BYTE*)dst;\n    U32 partitions[MAX_NB_SPLITS];\n    size_t i = 0;\n    size_t srcBytesTotal = 0;\n    size_t numSplits = ZSTD_deriveBlockSplits(zc, partitions, nbSeq);\n    seqStore_t nextSeqStore;\n    seqStore_t currSeqStore;\n\n    /* If a block is split and some partitions are emitted as RLE/uncompressed, then repcode history\n     * may become invalid. In order to reconcile potentially invalid repcodes, we keep track of two\n     * separate repcode histories that simulate repcode history on compression and decompression side,\n     * and use the histories to determine whether we must replace a particular repcode with its raw offset.\n     *\n     * 1) cRep gets updated for each partition, regardless of whether the block was emitted as uncompressed\n     *    or RLE. This allows us to retrieve the offset value that an invalid repcode references within\n     *    a nocompress/RLE block.\n     * 2) dRep gets updated only for compressed partitions, and when a repcode gets replaced, will use\n     *    the replacement offset value rather than the original repcode to update the repcode history.\n     *    dRep also will be the final repcode history sent to the next block.\n     *\n     * See ZSTD_seqStore_resolveOffCodes() for more details.\n     */\n    repcodes_t dRep;\n    repcodes_t cRep;\n    ZSTD_memcpy(dRep.rep, zc->blockState.prevCBlock->rep, sizeof(repcodes_t));\n    ZSTD_memcpy(cRep.rep, zc->blockState.prevCBlock->rep, sizeof(repcodes_t));\n\n    DEBUGLOG(4, \"ZSTD_compressBlock_splitBlock_internal (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u)\",\n                (unsigned)dstCapacity, (unsigned)zc->blockState.matchState.window.dictLimit,\n                (unsigned)zc->blockState.matchState.nextToUpdate);\n\n    if (numSplits == 0) {\n        size_t cSizeSingleBlock = ZSTD_compressSeqStore_singleBlock(zc, &zc->seqStore,\n                                                                   &dRep, &cRep,\n                                                                    op, dstCapacity,\n                                                                    ip, blockSize,\n                                                                    lastBlock, 0 /* isPartition */);\n        FORWARD_IF_ERROR(cSizeSingleBlock, \"Compressing single block from splitBlock_internal() failed!\");\n        DEBUGLOG(5, \"ZSTD_compressBlock_splitBlock_internal: No splits\");\n        assert(cSizeSingleBlock <= ZSTD_BLOCKSIZE_MAX + ZSTD_blockHeaderSize);\n        return cSizeSingleBlock;\n    }\n\n    ZSTD_deriveSeqStoreChunk(&currSeqStore, &zc->seqStore, 0, partitions[0]);\n    for (i = 0; i <= numSplits; ++i) {\n        size_t srcBytes;\n        size_t cSizeChunk;\n        U32 const lastPartition = (i == numSplits);\n        U32 lastBlockEntireSrc = 0;\n\n        srcBytes = ZSTD_countSeqStoreLiteralsBytes(&currSeqStore) + ZSTD_countSeqStoreMatchBytes(&currSeqStore);\n        srcBytesTotal += srcBytes;\n        if (lastPartition) {\n            /* This is the final partition, need to account for possible last literals */\n            srcBytes += blockSize - srcBytesTotal;\n            lastBlockEntireSrc = lastBlock;\n        } else {\n            ZSTD_deriveSeqStoreChunk(&nextSeqStore, &zc->seqStore, partitions[i], partitions[i+1]);\n        }\n\n        cSizeChunk = ZSTD_compressSeqStore_singleBlock(zc, &currSeqStore,\n                                                      &dRep, &cRep,\n                                                       op, dstCapacity,\n                                                       ip, srcBytes,\n                                                       lastBlockEntireSrc, 1 /* isPartition */);\n        DEBUGLOG(5, \"Estimated size: %zu actual size: %zu\", ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(&currSeqStore, zc), cSizeChunk);\n        FORWARD_IF_ERROR(cSizeChunk, \"Compressing chunk failed!\");\n\n        ip += srcBytes;\n        op += cSizeChunk;\n        dstCapacity -= cSizeChunk;\n        cSize += cSizeChunk;\n        currSeqStore = nextSeqStore;\n        assert(cSizeChunk <= ZSTD_BLOCKSIZE_MAX + ZSTD_blockHeaderSize);\n    }\n    /* cRep and dRep may have diverged during the compression. If so, we use the dRep repcodes\n     * for the next block.\n     */\n    ZSTD_memcpy(zc->blockState.prevCBlock->rep, dRep.rep, sizeof(repcodes_t));\n    return cSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "",
        "crashing_line_number": 3677
      },
      {
        "function_name": "ZSTD_compressBlock_splitBlock",
        "function_body": "static size_t ZSTD_compressBlock_splitBlock(ZSTD_CCtx* zc,\n                                        void* dst, size_t dstCapacity,\n                                        const void* src, size_t srcSize, U32 lastBlock) {\n    const BYTE* ip = (const BYTE*)src;\n    BYTE* op = (BYTE*)dst;\n    U32 nbSeq;\n    size_t cSize;\n    DEBUGLOG(4, \"ZSTD_compressBlock_splitBlock\");\n\n    {   const size_t bss = ZSTD_buildSeqStore(zc, src, srcSize);\n        FORWARD_IF_ERROR(bss, \"ZSTD_buildSeqStore failed\");\n        if (bss == ZSTDbss_noCompress) {\n            if (zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)\n                zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;\n            cSize = ZSTD_noCompressBlock(op, dstCapacity, ip, srcSize, lastBlock);\n            FORWARD_IF_ERROR(cSize, \"ZSTD_noCompressBlock failed\");\n            DEBUGLOG(4, \"ZSTD_compressBlock_splitBlock: Nocompress block\");\n            return cSize;\n        }\n        nbSeq = (U32)(zc->seqStore.sequences - zc->seqStore.sequencesStart);\n    }\n\n    assert(zc->appliedParams.splitBlocks == 1);\n    cSize = ZSTD_compressBlock_splitBlock_internal(zc, dst, dstCapacity, src, srcSize, lastBlock, nbSeq);\n    FORWARD_IF_ERROR(cSize, \"Splitting blocks failed!\");\n    return cSize;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "    assert(zc->appliedParams.splitBlocks == 1);",
        "crashing_line_number": 3722
      },
      {
        "function_name": "ZSTD_compress_frameChunk",
        "function_body": "static size_t ZSTD_compress_frameChunk(ZSTD_CCtx* cctx,\n                                     void* dst, size_t dstCapacity,\n                               const void* src, size_t srcSize,\n                                     U32 lastFrameChunk)\n{\n    size_t blockSize = cctx->blockSize;\n    size_t remaining = srcSize;\n    const BYTE* ip = (const BYTE*)src;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* op = ostart;\n    U32 const maxDist = (U32)1 << cctx->appliedParams.cParams.windowLog;\n\n    assert(cctx->appliedParams.cParams.windowLog <= ZSTD_WINDOWLOG_MAX);\n\n    DEBUGLOG(4, \"ZSTD_compress_frameChunk (blockSize=%u)\", (unsigned)blockSize);\n    if (cctx->appliedParams.fParams.checksumFlag && srcSize)\n        XXH64_update(&cctx->xxhState, src, srcSize);\n\n    while (remaining) {\n        ZSTD_matchState_t* const ms = &cctx->blockState.matchState;\n        U32 const lastBlock = lastFrameChunk & (blockSize >= remaining);\n\n        RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize + MIN_CBLOCK_SIZE,\n                        dstSize_tooSmall,\n                        \"not enough space to store compressed block\");\n        if (remaining < blockSize) blockSize = remaining;\n\n        ZSTD_overflowCorrectIfNeeded(\n            ms, &cctx->workspace, &cctx->appliedParams, ip, ip + blockSize);\n        ZSTD_checkDictValidity(&ms->window, ip + blockSize, maxDist, &ms->loadedDictEnd, &ms->dictMatchState);\n        ZSTD_window_enforceMaxDist(&ms->window, ip, maxDist, &ms->loadedDictEnd, &ms->dictMatchState);\n\n        /* Ensure hash/chain table insertion resumes no sooner than lowlimit */\n        if (ms->nextToUpdate < ms->window.lowLimit) ms->nextToUpdate = ms->window.lowLimit;\n\n        {   size_t cSize;\n            if (ZSTD_useTargetCBlockSize(&cctx->appliedParams)) {\n                cSize = ZSTD_compressBlock_targetCBlockSize(cctx, op, dstCapacity, ip, blockSize, lastBlock);\n                FORWARD_IF_ERROR(cSize, \"ZSTD_compressBlock_targetCBlockSize failed\");\n                assert(cSize > 0);\n                assert(cSize <= blockSize + ZSTD_blockHeaderSize);\n            } else if (ZSTD_blockSplitterEnabled(&cctx->appliedParams)) {\n                cSize = ZSTD_compressBlock_splitBlock(cctx, op, dstCapacity, ip, blockSize, lastBlock);\n                FORWARD_IF_ERROR(cSize, \"ZSTD_compressBlock_splitBlock failed\");\n                assert(cSize > 0 || cctx->seqCollector.collectSequences == 1);\n            } else {\n                cSize = ZSTD_compressBlock_internal(cctx,\n                                        op+ZSTD_blockHeaderSize, dstCapacity-ZSTD_blockHeaderSize,\n                                        ip, blockSize, 1 /* frame */);\n                FORWARD_IF_ERROR(cSize, \"ZSTD_compressBlock_internal failed\");\n\n                if (cSize == 0) {  /* block is not compressible */\n                    cSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);\n                    FORWARD_IF_ERROR(cSize, \"ZSTD_noCompressBlock failed\");\n                } else {\n                    U32 const cBlockHeader = cSize == 1 ?\n                        lastBlock + (((U32)bt_rle)<<1) + (U32)(blockSize << 3) :\n                        lastBlock + (((U32)bt_compressed)<<1) + (U32)(cSize << 3);\n                    MEM_writeLE24(op, cBlockHeader);\n                    cSize += ZSTD_blockHeaderSize;\n                }\n            }\n\n\n            ip += blockSize;\n            assert(remaining >= blockSize);\n            remaining -= blockSize;\n            op += cSize;\n            assert(dstCapacity >= cSize);\n            dstCapacity -= cSize;\n            cctx->isFirstBlock = 0;\n            DEBUGLOG(5, \"ZSTD_compress_frameChunk: adding a block of size %u\",\n                        (unsigned)cSize);\n    }   }\n\n    if (lastFrameChunk && (op>ostart)) cctx->stage = ZSTDcs_ending;\n    return (size_t)(op-ostart);\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "            } else if (ZSTD_blockSplitterEnabled(&cctx->appliedParams)) {",
        "crashing_line_number": 3944
      },
      {
        "function_name": "ZSTD_compressContinue_internal",
        "function_body": "static size_t ZSTD_compressContinue_internal (ZSTD_CCtx* cctx,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize,\n                               U32 frame, U32 lastFrameChunk)\n{\n    ZSTD_matchState_t* const ms = &cctx->blockState.matchState;\n    size_t fhSize = 0;\n\n    DEBUGLOG(5, \"ZSTD_compressContinue_internal, stage: %u, srcSize: %u\",\n                cctx->stage, (unsigned)srcSize);\n    RETURN_ERROR_IF(cctx->stage==ZSTDcs_created, stage_wrong,\n                    \"missing init (ZSTD_compressBegin)\");\n\n    if (frame && (cctx->stage==ZSTDcs_init)) {\n        fhSize = ZSTD_writeFrameHeader(dst, dstCapacity, &cctx->appliedParams,\n                                       cctx->pledgedSrcSizePlusOne-1, cctx->dictID);\n        FORWARD_IF_ERROR(fhSize, \"ZSTD_writeFrameHeader failed\");\n        assert(fhSize <= dstCapacity);\n        dstCapacity -= fhSize;\n        dst = (char*)dst + fhSize;\n        cctx->stage = ZSTDcs_ongoing;\n    }\n\n    if (!srcSize) return fhSize;  /* do not generate an empty block if no input */\n\n    if (!ZSTD_window_update(&ms->window, src, srcSize, ms->forceNonContiguous)) {\n        ms->forceNonContiguous = 0;\n        ms->nextToUpdate = ms->window.dictLimit;\n    }\n    if (cctx->appliedParams.ldmParams.enableLdm) {\n        ZSTD_window_update(&cctx->ldmState.window, src, srcSize, /* forceNonContiguous */ 0);\n    }\n\n    if (!frame) {\n        /* overflow check and correction for block mode */\n        ZSTD_overflowCorrectIfNeeded(\n            ms, &cctx->workspace, &cctx->appliedParams,\n            src, (BYTE const*)src + srcSize);\n    }\n\n    DEBUGLOG(5, \"ZSTD_compressContinue_internal (blockSize=%u)\", (unsigned)cctx->blockSize);\n    {   size_t const cSize = frame ?\n                             ZSTD_compress_frameChunk (cctx, dst, dstCapacity, src, srcSize, lastFrameChunk) :\n                             ZSTD_compressBlock_internal (cctx, dst, dstCapacity, src, srcSize, 0 /* frame */);\n        FORWARD_IF_ERROR(cSize, \"%s\", frame ? \"ZSTD_compress_frameChunk failed\" : \"ZSTD_compressBlock_internal failed\");\n        cctx->consumedSrcSize += srcSize;\n        cctx->producedCSize += (cSize + fhSize);\n        assert(!(cctx->appliedParams.fParams.contentSizeFlag && cctx->pledgedSrcSizePlusOne == 0));\n        if (cctx->pledgedSrcSizePlusOne != 0) {  /* control src size */\n            ZSTD_STATIC_ASSERT(ZSTD_CONTENTSIZE_UNKNOWN == (unsigned long long)-1);\n            RETURN_ERROR_IF(\n                cctx->consumedSrcSize+1 > cctx->pledgedSrcSizePlusOne,\n                srcSize_wrong,\n                \"error : pledgedSrcSize = %u, while realSrcSize >= %u\",\n                (unsigned)cctx->pledgedSrcSizePlusOne-1,\n                (unsigned)cctx->consumedSrcSize);\n        }\n        return cSize + fhSize;\n    }\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "    {   size_t const cSize = frame ?",
        "crashing_line_number": 4119
      },
      {
        "function_name": "ZSTD_compressEnd",
        "function_body": "size_t ZSTD_compressEnd (ZSTD_CCtx* cctx,\n                         void* dst, size_t dstCapacity,\n                   const void* src, size_t srcSize)\n{\n    size_t endResult;\n    size_t const cSize = ZSTD_compressContinue_internal(cctx,\n                                dst, dstCapacity, src, srcSize,\n                                1 /* frame mode */, 1 /* last chunk */);\n    FORWARD_IF_ERROR(cSize, \"ZSTD_compressContinue_internal failed\");\n    endResult = ZSTD_writeEpilogue(cctx, (char*)dst + cSize, dstCapacity-cSize);\n    FORWARD_IF_ERROR(endResult, \"ZSTD_writeEpilogue failed\");\n    assert(!(cctx->appliedParams.fParams.contentSizeFlag && cctx->pledgedSrcSizePlusOne == 0));\n    if (cctx->pledgedSrcSizePlusOne != 0) {  /* control src size */\n        ZSTD_STATIC_ASSERT(ZSTD_CONTENTSIZE_UNKNOWN == (unsigned long long)-1);\n        DEBUGLOG(4, \"end of frame : controlling src size\");\n        RETURN_ERROR_IF(\n            cctx->pledgedSrcSizePlusOne != cctx->consumedSrcSize+1,\n            srcSize_wrong,\n             \"error : pledgedSrcSize = %u, while realSrcSize = %u\",\n            (unsigned)cctx->pledgedSrcSizePlusOne-1,\n            (unsigned)cctx->consumedSrcSize);\n    }\n    ZSTD_CCtx_trace(cctx, endResult);\n    return cSize + endResult;\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "    size_t endResult;",
        "crashing_line_number": 4623
      },
      {
        "function_name": "ZSTD_compress_advanced_internal",
        "function_body": "size_t ZSTD_compress_advanced_internal(\n        ZSTD_CCtx* cctx,\n        void* dst, size_t dstCapacity,\n        const void* src, size_t srcSize,\n        const void* dict,size_t dictSize,\n        const ZSTD_CCtx_params* params)\n{\n    DEBUGLOG(4, \"ZSTD_compress_advanced_internal (srcSize:%u)\", (unsigned)srcSize);\n    FORWARD_IF_ERROR( ZSTD_compressBegin_internal(cctx,\n                         dict, dictSize, ZSTD_dct_auto, ZSTD_dtlm_fast, NULL,\n                         params, srcSize, ZSTDb_not_buffered) , \"\");\n    return ZSTD_compressEnd(cctx, dst, dstCapacity, src, srcSize);\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "                         params, srcSize, ZSTDb_not_buffered) , \"\");",
        "crashing_line_number": 4672
      },
      {
        "function_name": "ZSTD_compress_usingDict",
        "function_body": "size_t ZSTD_compress_usingDict(ZSTD_CCtx* cctx,\n                               void* dst, size_t dstCapacity,\n                         const void* src, size_t srcSize,\n                         const void* dict, size_t dictSize,\n                               int compressionLevel)\n{\n    {\n        ZSTD_parameters const params = ZSTD_getParams_internal(compressionLevel, srcSize, dict ? dictSize : 0, ZSTD_cpm_noAttachDict);\n        assert(params.fParams.contentSizeFlag == 1);\n        ZSTD_CCtxParams_init_internal(&cctx->simpleApiParams, &params, (compressionLevel == 0) ? ZSTD_CLEVEL_DEFAULT: compressionLevel);\n    }\n    DEBUGLOG(4, \"ZSTD_compress_usingDict (srcSize=%u)\", (unsigned)srcSize);\n    return ZSTD_compress_advanced_internal(cctx, dst, dstCapacity, src, srcSize, dict, dictSize, &cctx->simpleApiParams);\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "    DEBUGLOG(4, \"ZSTD_compress_usingDict (srcSize=%u)\", (unsigned)srcSize);",
        "crashing_line_number": 4687
      },
      {
        "function_name": "ZSTD_compressCCtx",
        "function_body": "size_t ZSTD_compressCCtx(ZSTD_CCtx* cctx,\n                         void* dst, size_t dstCapacity,\n                   const void* src, size_t srcSize,\n                         int compressionLevel)\n{\n    DEBUGLOG(4, \"ZSTD_compressCCtx (srcSize=%u)\", (unsigned)srcSize);\n    assert(cctx != NULL);\n    return ZSTD_compress_usingDict(cctx, dst, dstCapacity, src, srcSize, NULL, 0, compressionLevel);\n}",
        "file_path": "/src/zstd/tests/fuzz/../../lib/compress/zstd_compress.c",
        "crashing_line": "    assert(cctx != NULL);",
        "crashing_line_number": 4697
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static int GetDhPublicKey(WOLFSSL* ssl, const byte* input, word32 size,\n                          DskeArgs* args)\n{\n    int             ret = 0;\n    word16          length;\n#ifdef HAVE_FFDHE\n    const DhParams* params = NULL;\n    int             group = 0;\n#endif\n\n    if (ssl->buffers.weOwnDH) {\n        if (ssl->buffers.serverDH_P.buffer) {\n            XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,\n                    DYNAMIC_TYPE_PUBLIC_KEY);\n            ssl->buffers.serverDH_P.buffer = NULL;\n        }\n\n        if (ssl->buffers.serverDH_G.buffer) {\n            XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap,\n                    DYNAMIC_TYPE_PUBLIC_KEY);\n            ssl->buffers.serverDH_G.buffer = NULL;\n        }\n\n        if (ssl->buffers.serverDH_Pub.buffer) {\n            XFREE(ssl->buffers.serverDH_Pub.buffer, ssl->heap,\n                    DYNAMIC_TYPE_PUBLIC_KEY);\n            ssl->buffers.serverDH_Pub.buffer = NULL;\n        }\n    }\n\n    /* p */\n    if ((args->idx - args->begin) + OPAQUE16_LEN > size) {\n        ERROR_OUT(BUFFER_ERROR, exit_gdpk);\n    }\n\n    ato16(input + args->idx, &length);\n    args->idx += OPAQUE16_LEN;\n\n    if ((args->idx - args->begin) + length > size) {\n        ERROR_OUT(BUFFER_ERROR, exit_gdpk);\n    }\n\n    if (length < ssl->options.minDhKeySz) {\n        WOLFSSL_MSG(\"Server using a DH key that is too small\");\n        SendAlert(ssl, alert_fatal, handshake_failure);\n        ERROR_OUT(DH_KEY_SIZE_E, exit_gdpk);\n    }\n    if (length > ssl->options.maxDhKeySz) {\n        WOLFSSL_MSG(\"Server using a DH key that is too big\");\n        SendAlert(ssl, alert_fatal, handshake_failure);\n        ERROR_OUT(DH_KEY_SIZE_E, exit_gdpk);\n    }\n\n    ssl->buffers.serverDH_P.buffer =\n        (byte*)XMALLOC(length, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);\n    if (ssl->buffers.serverDH_P.buffer) {\n        ssl->buffers.serverDH_P.length = length;\n    }\n    else {\n        ERROR_OUT(MEMORY_ERROR, exit_gdpk);\n    }\n\n    XMEMCPY(ssl->buffers.serverDH_P.buffer, input + args->idx,\n                                                        length);\n    args->idx += length;\n\n    ssl->options.dhKeySz = length;\n\n    /* g */\n    if ((args->idx - args->begin) + OPAQUE16_LEN > size) {\n        XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,\n                DYNAMIC_TYPE_PUBLIC_KEY);\n        ssl->buffers.serverDH_P.buffer = NULL;\n        ERROR_OUT(BUFFER_ERROR, exit_gdpk);\n    }\n\n    ato16(input + args->idx, &length);\n    args->idx += OPAQUE16_LEN;\n\n    if ((args->idx - args->begin) + length > size) {\n        XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,\n                DYNAMIC_TYPE_PUBLIC_KEY);\n        ssl->buffers.serverDH_P.buffer = NULL;\n        ERROR_OUT(BUFFER_ERROR, exit_gdpk);\n    }\n\n    ssl->buffers.serverDH_G.buffer =\n        (byte*)XMALLOC(length, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);\n    if (ssl->buffers.serverDH_G.buffer) {\n        ssl->buffers.serverDH_G.length = length;\n    }\n    else {\n        XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,\n                DYNAMIC_TYPE_PUBLIC_KEY);\n        ssl->buffers.serverDH_P.buffer = NULL;\n        ERROR_OUT(MEMORY_ERROR, exit_gdpk);\n    }\n\n    XMEMCPY(ssl->buffers.serverDH_G.buffer, input + args->idx,\n                                                        length);\n    args->idx += length;\n\n    /* pub */\n    if ((args->idx - args->begin) + OPAQUE16_LEN > size) {\n        XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,\n                DYNAMIC_TYPE_PUBLIC_KEY);\n        ssl->buffers.serverDH_P.buffer = NULL;\n        XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap,\n                DYNAMIC_TYPE_PUBLIC_KEY);\n        ssl->buffers.serverDH_G.buffer = NULL;\n        ERROR_OUT(BUFFER_ERROR, exit_gdpk);\n    }\n\n    ato16(input + args->idx, &length);\n    args->idx += OPAQUE16_LEN;\n\n    if ((args->idx - args->begin) + length > size) {\n        XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,\n                DYNAMIC_TYPE_PUBLIC_KEY);\n        ssl->buffers.serverDH_P.buffer = NULL;\n        XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap,\n                DYNAMIC_TYPE_PUBLIC_KEY);\n        ssl->buffers.serverDH_G.buffer = NULL;\n        ERROR_OUT(BUFFER_ERROR, exit_gdpk);\n    }\n\n    ssl->buffers.serverDH_Pub.buffer =\n        (byte*)XMALLOC(length, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);\n    if (ssl->buffers.serverDH_Pub.buffer) {\n        ssl->buffers.serverDH_Pub.length = length;\n    }\n    else {\n        XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap,\n                DYNAMIC_TYPE_PUBLIC_KEY);\n        ssl->buffers.serverDH_P.buffer = NULL;\n        XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap,\n                DYNAMIC_TYPE_PUBLIC_KEY);\n        ssl->buffers.serverDH_G.buffer = NULL;\n        ERROR_OUT(MEMORY_ERROR, exit_gdpk);\n    }\n\n    XMEMCPY(ssl->buffers.serverDH_Pub.buffer, input + args->idx,\n                                                        length);\n    ssl->buffers.weOwnDH = 1;\n    args->idx += length;\n\n#ifdef HAVE_FFDHE\n    switch (ssl->options.dhKeySz) {\n    #ifdef HAVE_FFDHE_2048\n        case 2048/8:\n            params = wc_Dh_ffdhe2048_Get();\n            group = WOLFSSL_FFDHE_2048;\n            break;\n    #endif\n    #ifdef HAVE_FFDHE_3072\n        case 3072/8:\n            params = wc_Dh_ffdhe3072_Get();\n            group = WOLFSSL_FFDHE_3072;\n            break;\n    #endif\n    #ifdef HAVE_FFDHE_4096\n        case 4096/8:\n            params = wc_Dh_ffdhe4096_Get();\n            group = WOLFSSL_FFDHE_4096;\n            break;\n    #endif\n    #ifdef HAVE_FFDHE_6144\n        case 6144/8:\n            params = wc_Dh_ffdhe6144_Get();\n            group = WOLFSSL_FFDHE_6144;\n            break;\n    #endif\n    #ifdef HAVE_FFDHE_8192\n        case 8192/8:\n            params = wc_Dh_ffdhe8192_Get();\n            group = WOLFSSL_FFDHE_8192;\n            break;\n    #endif\n        default:\n            break;\n    }\n\n    if (params == NULL || params->g_len != ssl->buffers.serverDH_G.length ||\n            (XMEMCMP(ssl->buffers.serverDH_G.buffer, params->g,\n                    params->g_len) != 0) ||\n            (XMEMCMP(ssl->buffers.serverDH_P.buffer, params->p,\n                    params->p_len) != 0)) {\n        WOLFSSL_MSG(\"Server not using FFDHE parameters\");\n    #ifdef WOLFSSL_REQUIRE_FFDHE\n        SendAlert(ssl, alert_fatal, handshake_failure);\n        ERROR_OUT(DH_PARAMS_NOT_FFDHE_E, exit_gdpk);\n    #endif\n    }\n    else {\n        ssl->namedGroup = group;\n    #if !defined(WOLFSSL_OLD_PRIME_CHECK) && !defined(HAVE_FIPS) && \\\n        !defined(HAVE_SELFTEST)\n        ssl->options.dhDoKeyTest = 0;\n    #endif\n    }\n#endif /* HAVE_FFDHE */\n\nexit_gdpk:\n    return ret;\n}\nstatic int GeneratePrivateDh(DhKey* key, WC_RNG* rng, byte* priv,\n                             word32* privSz)\n{\n#ifndef WC_NO_RNG\n    int ret = 0;\n    word32 sz = 0;\n\n#ifndef WOLFSSL_NO_DH186\n    if (mp_iszero(&key->q) == MP_NO) {\n\n        /* q param available, use NIST FIPS 186-4, \"B.1.1 Key Pair\n         * Generation Using Extra Random Bits\" */\n        ret = GeneratePrivateDh186(key, rng, priv, privSz);\n\n    } else\n#endif\n    {\n\n        sz = mp_unsigned_bin_size(&key->p);\n\n        /* Table of predetermined values from the operation\n           2 * DiscreteLogWorkFactor(sz * WOLFSSL_BIT_SIZE) /\n           WOLFSSL_BIT_SIZE + 1\n           Sizes in table checked against RFC 3526\n         */\n        WOLFSSL_DH_ROUND(sz); /* if using fixed points only, then round up */\n        switch (sz) {\n            case 128:  sz = 21; break;\n            case 256:  sz = 29; break;\n            case 384:  sz = 34; break;\n            case 512:  sz = 39; break;\n            case 640:  sz = 42; break;\n            case 768:  sz = 46; break;\n            case 896:  sz = 49; break;\n            case 1024: sz = 52; break;\n            default:\n            #ifndef WOLFSSL_DH_CONST\n                /* if using floating points and size of p is not in table */\n                sz = min(sz, 2 * DiscreteLogWorkFactor(sz * WOLFSSL_BIT_SIZE) /\n                                           WOLFSSL_BIT_SIZE + 1);\n                break;\n            #else\n                return BAD_FUNC_ARG;\n            #endif\n        }\n\n        ret = wc_RNG_GenerateBlock(rng, priv, sz);\n\n        if (ret == 0) {\n            priv[0] |= 0x0C;\n            *privSz = sz;\n        }\n    }\n\n    return ret;\n#else\n    (void)key;\n    (void)rng;\n    (void)priv;\n    (void)privSz;\n    return NOT_COMPILED_IN;\n#endif /* WC_NO_RNG */\n}\nstatic int GeneratePublicDh(DhKey* key, byte* priv, word32 privSz,\n    byte* pub, word32* pubSz)\n{\n    int ret = 0;\n#ifndef WOLFSSL_SP_MATH\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int* x;\n    mp_int* y;\n#else\n    mp_int x[1];\n    mp_int y[1];\n#endif\n#endif\n\n#ifdef WOLFSSL_HAVE_SP_DH\n#ifndef WOLFSSL_SP_NO_2048\n    if (mp_count_bits(&key->p) == 2048)\n        return sp_DhExp_2048(&key->g, priv, privSz, &key->p, pub, pubSz);\n#endif\n#ifndef WOLFSSL_SP_NO_3072\n    if (mp_count_bits(&key->p) == 3072)\n        return sp_DhExp_3072(&key->g, priv, privSz, &key->p, pub, pubSz);\n#endif\n#ifdef WOLFSSL_SP_4096\n    if (mp_count_bits(&key->p) == 4096)\n        return sp_DhExp_4096(&key->g, priv, privSz, &key->p, pub, pubSz);\n#endif\n#endif\n\n#ifndef WOLFSSL_SP_MATH\n#ifdef WOLFSSL_SMALL_STACK\n    x = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_DH);\n    if (x == NULL)\n        return MEMORY_E;\n    y = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_DH);\n    if (y == NULL) {\n        XFREE(x, key->heap, DYNAMIC_TYPE_DH);\n        return MEMORY_E;\n    }\n#endif\n    if (mp_init_multi(x, y, 0, 0, 0, 0) != MP_OKAY) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(y, key->heap, DYNAMIC_TYPE_DH);\n        XFREE(x, key->heap, DYNAMIC_TYPE_DH);\n    #endif\n        return MP_INIT_E;\n    }\n\n    if (mp_read_unsigned_bin(x, priv, privSz) != MP_OKAY)\n        ret = MP_READ_E;\n\n    if (ret == 0 && mp_exptmod(&key->g, x, &key->p, y) != MP_OKAY)\n        ret = MP_EXPTMOD_E;\n\n    if (ret == 0 && mp_to_unsigned_bin(y, pub) != MP_OKAY)\n        ret = MP_TO_E;\n\n    if (ret == 0)\n        *pubSz = mp_unsigned_bin_size(y);\n\n    mp_clear(y);\n    mp_clear(x);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(y, key->heap, DYNAMIC_TYPE_DH);\n    XFREE(x, key->heap, DYNAMIC_TYPE_DH);\n#endif\n#else\n    ret = WC_KEY_SIZE_E;\n#endif\n\n    return ret;\n}\nstatic int dh_test_ffdhe(WC_RNG *rng, const DhParams* params)\n{\n    int    ret;\n    word32 privSz, pubSz, privSz2, pubSz2;\n#ifdef WOLFSSL_SMALL_STACK\n    byte   *priv = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte   *pub = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte   *priv2 = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte   *pub2 = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte   *agree = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte   *agree2 = (byte *)XMALLOC(FFDHE_KEY_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    DhKey  *key = (DhKey *)XMALLOC(sizeof *key, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    DhKey  *key2 = (DhKey *)XMALLOC(sizeof *key2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n#else\n    byte   priv[FFDHE_KEY_SIZE];\n    byte   pub[FFDHE_KEY_SIZE];\n    byte   priv2[FFDHE_KEY_SIZE];\n    byte   pub2[FFDHE_KEY_SIZE];\n    byte   agree[FFDHE_KEY_SIZE];\n    byte   agree2[FFDHE_KEY_SIZE];\n    DhKey  key_buf, *key = &key_buf;\n    DhKey  key2_buf, *key2 = &key2_buf;\n#endif\n    word32 agreeSz = FFDHE_KEY_SIZE;\n    word32 agreeSz2 = FFDHE_KEY_SIZE;\n\n#ifdef WOLFSSL_SMALL_STACK\n    if ((priv == NULL) ||\n        (pub == NULL) ||\n        (priv2 == NULL) ||\n        (pub2 == NULL) ||\n        (agree == NULL) ||\n        (agree2 == NULL) ||\n        (key == NULL) ||\n        (key2 == NULL))\n        ERROR_OUT(-7835, done);\n#endif\n\n    XMEMSET(key, 0, sizeof *key);\n    XMEMSET(key2, 0, sizeof *key2);\n\n    ret = wc_InitDhKey_ex(key, HEAP_HINT, devId);\n    if (ret != 0) {\n        ERROR_OUT(-7826, done);\n    }\n    ret = wc_InitDhKey_ex(key2, HEAP_HINT, devId);\n    if (ret != 0) {\n        ERROR_OUT(-7827, done);\n    }\n\n    ret = wc_DhSetKey(key, params->p, params->p_len, params->g, params->g_len);\n    if (ret != 0) {\n        ERROR_OUT(-7828, done);\n    }\n\n    ret = wc_DhSetKey(key2, params->p, params->p_len, params->g,\n                                                                 params->g_len);\n    if (ret != 0) {\n        ERROR_OUT(-7829, done);\n    }\n\n    ret = wc_DhGenerateKeyPair(key, rng, priv, &privSz, pub, &pubSz);\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, key.asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0) {\n        ERROR_OUT(-7830, done);\n    }\n\n    ret = wc_DhGenerateKeyPair(key2, rng, priv2, &privSz2, pub2, &pubSz2);\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, key2.asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0) {\n        ERROR_OUT(-7831, done);\n    }\n\n    ret = wc_DhAgree(key, agree, &agreeSz, priv, privSz, pub2, pubSz2);\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, key.asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0) {\n        ERROR_OUT(-7832, done);\n    }\n\n    ret = wc_DhAgree(key2, agree2, &agreeSz2, priv2, privSz2, pub, pubSz);\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, key2.asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0) {\n        ERROR_OUT(-7833, done);\n    }\n\n    if (agreeSz != agreeSz2 || XMEMCMP(agree, agree2, agreeSz)) {\n        ERROR_OUT(-7834, done);\n    }\n\ndone:\n\n#ifdef WOLFSSL_SMALL_STACK\n    if (priv)\n      XFREE(priv, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (pub)\n      XFREE(pub, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (priv2)\n      XFREE(priv2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (pub2)\n      XFREE(pub2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (agree)\n      XFREE(agree, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (agree2)\n      XFREE(agree2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (key) {\n        wc_FreeDhKey(key);\n        XFREE(key, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    if (key2) {\n        wc_FreeDhKey(key2);\n        XFREE(key2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#else\n    wc_FreeDhKey(key);\n    wc_FreeDhKey(key2);\n#endif\n\n    return ret;\n}\nstatic int dh_test(void)\n{\n    int    ret;\n    word32 bytes;\n    word32 idx = 0, privSz, pubSz, privSz2, pubSz2;\n    WC_RNG rng;\n    int keyInit = 0;\n\n#define DH_TEST_TMP_SIZE 1024\n#if !defined(USE_CERT_BUFFERS_3072) && !defined(USE_CERT_BUFFERS_4096)\n    #define DH_TEST_BUF_SIZE 256\n#else\n    #define DH_TEST_BUF_SIZE 512\n#endif\n    word32 agreeSz = DH_TEST_BUF_SIZE;\n    word32 agreeSz2 = DH_TEST_BUF_SIZE;\n\n#ifdef WOLFSSL_SMALL_STACK\n    DhKey  *key = (DhKey *)XMALLOC(sizeof *key, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    DhKey  *key2 = (DhKey *)XMALLOC(sizeof *key2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte *tmp = (byte *)XMALLOC(DH_TEST_TMP_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte *priv = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte *pub = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte *priv2 = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte *pub2 = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte *agree = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    byte *agree2 = (byte *)XMALLOC(DH_TEST_BUF_SIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n\n    if ((tmp == NULL) || (priv == NULL) || (pub == NULL) ||\n\t(priv2 == NULL) || (pub2 == NULL) || (agree == NULL) ||\n\t(agree2 == NULL))\n        ERROR_OUT(-7960, done);\n#else\n    DhKey  key_buf, *key = &key_buf;\n    DhKey  key2_buf, *key2 = &key2_buf;\n    byte tmp[DH_TEST_TMP_SIZE];\n    byte priv[DH_TEST_BUF_SIZE];\n    byte pub[DH_TEST_BUF_SIZE];\n    byte priv2[DH_TEST_BUF_SIZE];\n    byte pub2[DH_TEST_BUF_SIZE];\n    byte agree[DH_TEST_BUF_SIZE];\n    byte agree2[DH_TEST_BUF_SIZE];\n#endif\n\n#ifdef USE_CERT_BUFFERS_1024\n    XMEMCPY(tmp, dh_key_der_1024, (size_t)sizeof_dh_key_der_1024);\n    bytes = (size_t)sizeof_dh_key_der_1024;\n#elif defined(USE_CERT_BUFFERS_2048)\n    XMEMCPY(tmp, dh_key_der_2048, (size_t)sizeof_dh_key_der_2048);\n    bytes = (size_t)sizeof_dh_key_der_2048;\n#elif defined(USE_CERT_BUFFERS_3072)\n    XMEMCPY(tmp, dh_key_der_3072, (size_t)sizeof_dh_key_der_3072);\n    bytes = (size_t)sizeof_dh_key_der_3072;\n#elif defined(USE_CERT_BUFFERS_4096)\n    XMEMCPY(tmp, dh_key_der_4096, (size_t)sizeof_dh_key_der_4096);\n    bytes = (size_t)sizeof_dh_key_der_4096;\n#elif defined(NO_ASN)\n    /* don't use file, no DER parsing */\n#elif !defined(NO_FILESYSTEM)\n    {\n        XFILE file = XFOPEN(dhParamsFile, \"rb\");\n        if (! file)\n            ERROR_OUT(-7900, done);\n\n        bytes = (word32) XFREAD(tmp, 1, DH_TEST_TMP_SIZE, file);\n        XFCLOSE(file);\n    }\n#else\n    /* No DH key to use. */\n    ERROR_OUT(-7901, done);\n#endif /* USE_CERT_BUFFERS */\n\n    (void)idx;\n    (void)tmp;\n    (void)bytes;\n\n    XMEMSET(&rng, 0, sizeof(rng));\n    /* Use API for coverage. */\n    ret = wc_InitDhKey(key);\n    if (ret != 0) {\n        ERROR_OUT(-7902, done);\n    }\n    wc_FreeDhKey(key);\n\n    ret = wc_InitDhKey_ex(key, HEAP_HINT, devId);\n    if (ret != 0) {\n        ERROR_OUT(-7903, done);\n    }\n    keyInit = 1;\n    ret = wc_InitDhKey_ex(key2, HEAP_HINT, devId);\n    if (ret != 0) {\n        ERROR_OUT(-7904, done);\n    }\n\n#ifdef NO_ASN\n    ret = wc_DhSetKey(key, dh_p, sizeof(dh_p), dh_g, sizeof(dh_g));\n    if (ret != 0) {\n        ERROR_OUT(-7905, done);\n    }\n\n    ret = wc_DhSetKey(key2, dh_p, sizeof(dh_p), dh_g, sizeof(dh_g));\n    if (ret != 0) {\n        ERROR_OUT(-7906, done);\n    }\n#else\n    ret = wc_DhKeyDecode(tmp, &idx, key, bytes);\n    if (ret != 0) {\n        ERROR_OUT(-7907, done);\n    }\n\n    idx = 0;\n    ret = wc_DhKeyDecode(tmp, &idx, key2, bytes);\n    if (ret != 0) {\n        ERROR_OUT(-7908, done);\n    }\n#endif\n\n#ifndef HAVE_FIPS\n    ret = wc_InitRng_ex(&rng, HEAP_HINT, devId);\n#else\n    ret = wc_InitRng(&rng);\n#endif\n    if (ret != 0) {\n        ERROR_OUT(-7909, done);\n    }\n\n    ret = wc_DhGenerateKeyPair(key, &rng, priv, &privSz, pub, &pubSz);\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, key.asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0) {\n        ERROR_OUT(-7910, done);\n    }\n\n    ret = wc_DhGenerateKeyPair(key2, &rng, priv2, &privSz2, pub2, &pubSz2);\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, key2.asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0) {\n        ERROR_OUT(-7911, done);\n    }\n\n    ret = wc_DhAgree(key, agree, &agreeSz, priv, privSz, pub2, pubSz2);\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, key.asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0) {\n        ERROR_OUT(-7912, done);\n    }\n\n    ret = wc_DhAgree(key2, agree2, &agreeSz2, priv2, privSz2, pub, pubSz);\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, key2.asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0) {\n        ERROR_OUT(-7913, done);\n    }\n\n    if (agreeSz != agreeSz2 || XMEMCMP(agree, agree2, agreeSz)) {\n        ERROR_OUT(-7914, done);\n    }\n\n#if defined(WOLFSSL_KEY_GEN) && !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)\n    if (wc_DhCheckPrivKey(NULL, NULL, 0) != BAD_FUNC_ARG)\n        ERROR_OUT(-7915, done);\n\n    if (wc_DhCheckPrivKey(key, priv, privSz) != 0)\n        ERROR_OUT(-7916, done);\n\n    if (wc_DhExportParamsRaw(NULL, NULL, NULL, NULL, NULL, NULL, NULL) != BAD_FUNC_ARG)\n        ERROR_OUT(-7917, done);\n    {\n        word32 pSz, qSz, gSz;\n        if (wc_DhExportParamsRaw(key, NULL, &pSz, NULL, &qSz, NULL, &gSz) != LENGTH_ONLY_E)\n            ERROR_OUT(-7918, done);\n    }\n#endif\n\n    /* Test DH key import / export */\n#if defined(WOLFSSL_DH_EXTRA) && (!defined(HAVE_FIPS) || \\\n        (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2)))\n    wc_FreeDhKey(key);\n    ret = wc_InitDhKey_ex(key, HEAP_HINT, devId);\n    if (ret != 0) {\n        ERROR_OUT(-7949, done);\n    }\n\n#if !defined(NO_ASN) && !defined(NO_FILESYSTEM)\n    {\n        XFILE file = XFOPEN(dhKeyFile, \"rb\");\n        if (!file)\n            ERROR_OUT(-7950, done);\n        bytes = (word32)XFREAD(tmp, 1, DH_TEST_TMP_SIZE, file);\n        XFCLOSE(file);\n    }\n\n    idx = 0;\n    ret = wc_DhKeyDecode(tmp, &idx, key, bytes);\n    if (ret != 0) {\n        ERROR_OUT(-7951, done);\n    }\n#endif\n\n    privSz = DH_TEST_BUF_SIZE;\n    pubSz = DH_TEST_BUF_SIZE;\n    ret = wc_DhExportKeyPair(key, priv, &privSz, pub, &pubSz);\n    if (ret != 0) {\n        ERROR_OUT(-7952, done);\n    }\n    ret = wc_DhImportKeyPair(key2, priv, privSz, pub, pubSz);\n    if (ret != 0) {\n        ERROR_OUT(-7953, done);\n    }\n#endif /* WOLFSSL_DH_EXTRA */\n\n    ret = dh_generate_test(&rng);\n    if (ret != 0)\n        ERROR_OUT(-7954, done);\n\n    ret = dh_fips_generate_test(&rng);\n    if (ret != 0)\n        ERROR_OUT(-7955, done);\n\n#if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)\n    ret = dh_test_check_pubvalue();\n    if (ret != 0)\n        ERROR_OUT(-7956, done);\n#endif\n\n    /* Specialized code for key gen when using FFDHE-2048 and FFDHE-3072. */\n    #ifdef HAVE_FFDHE_2048\n    ret = dh_test_ffdhe(&rng, wc_Dh_ffdhe2048_Get());\n    if (ret != 0)\n        ERROR_OUT(-7957, done);\n    #endif\n    #ifdef HAVE_FFDHE_3072\n    ret = dh_test_ffdhe(&rng, wc_Dh_ffdhe3072_Get());\n    if (ret != 0)\n        ERROR_OUT(-7958, done);\n    #endif\n\n    wc_FreeDhKey(key);\n    keyInit = 0;\n\n#if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST) && \\\n    !defined(WOLFSSL_OLD_PRIME_CHECK)\n    /* Test Check Key */\n    ret = wc_DhSetCheckKey(key, dh_p, sizeof(dh_p), dh_g, sizeof(dh_g),\n                           NULL, 0, 0, &rng);\n    if (ret != 0)\n        ERROR_OUT(-7959, done);\n    keyInit = 1; /* DhSetCheckKey also initializes the key, free it */\n#endif\n\ndone:\n\n    wc_FreeRng(&rng);\n\n#ifdef WOLFSSL_SMALL_STACK\n    if (key) {\n        if (keyInit)\n            wc_FreeDhKey(key);\n        XFREE(key, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    if (key2) {\n        wc_FreeDhKey(key2);\n        XFREE(key2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    if (tmp)\n        XFREE(tmp, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (priv)\n        XFREE(priv, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (pub)\n        XFREE(pub, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (priv2)\n        XFREE(priv2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (pub2)\n        XFREE(pub2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (agree)\n        XFREE(agree, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n    if (agree2)\n        XFREE(agree2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);\n#else\n    if (keyInit)\n        wc_FreeDhKey(key);\n    wc_FreeDhKey(key2);\n#endif\n\n    return ret;\n#undef DH_TEST_BUF_SIZE\n#undef DH_TEST_TMP_SIZE\n}\n",
    "target": 1,
    "idx": 1026295,
    "stack_trace": [
      {
        "function_name": "fp_to_unsigned_bin_at_pos",
        "function_body": "int fp_to_unsigned_bin_at_pos(int x, fp_int *t, unsigned char *b)\n{\n#if DIGIT_BIT == 64 || DIGIT_BIT == 32\n   int i, j;\n   fp_digit n;\n\n   for (j=0,i=0; i<t->used-1; ) {\n       b[x++] = (unsigned char)(t->dp[i] >> j);\n       j += 8;\n       i += j == DIGIT_BIT;\n       j &= DIGIT_BIT - 1;\n   }\n   n = t->dp[i];\n   while (n != 0) {\n       b[x++] = (unsigned char)n;\n       n >>= 8;\n   }\n   return x;\n#else\n   while (fp_iszero (t) == FP_NO) {\n      b[x++] = (unsigned char) (t->dp[0] & 255);\n      fp_div_2d (t, 8, t, NULL);\n  }\n  return x;\n#endif\n}",
        "file_path": "/src/wolf-ssl-ssh-fuzzers/oss-fuzz/projects/wolf-ssl-ssh/fuzzers/wolfssl/wolfssl/wolfcrypt/src/tfm.c",
        "crashing_line": "       b[x++] = (unsigned char)(t->dp[i] >> j);",
        "crashing_line_number": 3617
      },
      {
        "function_name": "fp_to_unsigned_bin",
        "function_body": "int fp_to_unsigned_bin(fp_int *a, unsigned char *b)\n{\n  int     x;\n#ifndef WOLFSSL_SMALL_STACK\n   fp_int t[1];\n#else\n   fp_int *t;\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);\n   if (t == NULL)\n       return FP_MEM;\n#endif\n\n  fp_init_copy(t, a);\n\n  x = fp_to_unsigned_bin_at_pos(0, t, b);\n  fp_reverse (b, x);\n\n#ifdef WOLFSSL_SMALL_STACK\n  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);\n#endif\n  return FP_OKAY;\n}",
        "file_path": "/src/wolf-ssl-ssh-fuzzers/oss-fuzz/projects/wolf-ssl-ssh/fuzzers/wolfssl/wolfssl/wolfcrypt/src/tfm.c",
        "crashing_line": "  x = fp_to_unsigned_bin_at_pos(0, t, b);",
        "crashing_line_number": 3654
      },
      {
        "function_name": "mp_to_unsigned_bin",
        "function_body": "int mp_to_unsigned_bin (mp_int * a, unsigned char *b)\n{\n  return fp_to_unsigned_bin(a,b);\n}",
        "file_path": "/src/wolf-ssl-ssh-fuzzers/oss-fuzz/projects/wolf-ssl-ssh/fuzzers/wolfssl/wolfssl/wolfcrypt/src/tfm.c",
        "crashing_line": "  return fp_to_unsigned_bin(a,b);",
        "crashing_line_number": 4251
      },
      {
        "function_name": "GeneratePublicDh",
        "function_body": "static int GeneratePublicDh(DhKey* key, byte* priv, word32 privSz,\n    byte* pub, word32* pubSz)\n{\n    int ret = 0;\n#ifndef WOLFSSL_SP_MATH\n#ifdef WOLFSSL_SMALL_STACK\n    mp_int* x;\n    mp_int* y;\n#else\n    mp_int x[1];\n    mp_int y[1];\n#endif\n#endif\n\n#ifdef WOLFSSL_HAVE_SP_DH\n#ifndef WOLFSSL_SP_NO_2048\n    if (mp_count_bits(&key->p) == 2048)\n        return sp_DhExp_2048(&key->g, priv, privSz, &key->p, pub, pubSz);\n#endif\n#ifndef WOLFSSL_SP_NO_3072\n    if (mp_count_bits(&key->p) == 3072)\n        return sp_DhExp_3072(&key->g, priv, privSz, &key->p, pub, pubSz);\n#endif\n#ifdef WOLFSSL_SP_4096\n    if (mp_count_bits(&key->p) == 4096)\n        return sp_DhExp_4096(&key->g, priv, privSz, &key->p, pub, pubSz);\n#endif\n#endif\n\n#ifndef WOLFSSL_SP_MATH\n#ifdef WOLFSSL_SMALL_STACK\n    x = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_DH);\n    if (x == NULL)\n        return MEMORY_E;\n    y = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_DH);\n    if (y == NULL) {\n        XFREE(x, key->heap, DYNAMIC_TYPE_DH);\n        return MEMORY_E;\n    }\n#endif\n    if (mp_init_multi(x, y, 0, 0, 0, 0) != MP_OKAY) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(y, key->heap, DYNAMIC_TYPE_DH);\n        XFREE(x, key->heap, DYNAMIC_TYPE_DH);\n    #endif\n        return MP_INIT_E;\n    }\n\n    if (mp_read_unsigned_bin(x, priv, privSz) != MP_OKAY)\n        ret = MP_READ_E;\n\n    if (ret == 0 && mp_exptmod(&key->g, x, &key->p, y) != MP_OKAY)\n        ret = MP_EXPTMOD_E;\n\n    if (ret == 0 && mp_to_unsigned_bin(y, pub) != MP_OKAY)\n        ret = MP_TO_E;\n\n    if (ret == 0)\n        *pubSz = mp_unsigned_bin_size(y);\n\n    mp_clear(y);\n    mp_clear(x);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(y, key->heap, DYNAMIC_TYPE_DH);\n    XFREE(x, key->heap, DYNAMIC_TYPE_DH);\n#endif\n#else\n    ret = WC_KEY_SIZE_E;\n#endif\n\n    return ret;\n}",
        "file_path": "/src/wolf-ssl-ssh-fuzzers/oss-fuzz/projects/wolf-ssl-ssh/fuzzers/wolfssl/wolfssl/wolfcrypt/src/dh.c",
        "crashing_line": "    if (ret == 0 && mp_to_unsigned_bin(y, pub) != MP_OKAY)",
        "crashing_line_number": 1285
      },
      {
        "function_name": "wc_DhGenerateKeyPair_Sync",
        "function_body": "static int wc_DhGenerateKeyPair_Sync(DhKey* key, WC_RNG* rng,\n    byte* priv, word32* privSz, byte* pub, word32* pubSz)\n{\n    int ret;\n\n    if (key == NULL || rng == NULL || priv == NULL || privSz == NULL ||\n        pub == NULL || pubSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    ret = GeneratePrivateDh(key, rng, priv, privSz);\n\n    return (ret != 0) ? ret : GeneratePublicDh(key, priv, *privSz, pub, pubSz);\n}",
        "file_path": "/src/wolf-ssl-ssh-fuzzers/oss-fuzz/projects/wolf-ssl-ssh/fuzzers/wolfssl/wolfssl/wolfcrypt/src/dh.c",
        "crashing_line": "    return (ret != 0) ? ret : GeneratePublicDh(key, priv, *privSz, pub, pubSz);",
        "crashing_line_number": 1316
      },
      {
        "function_name": "wc_DhGenerateKeyPair",
        "function_body": "int wc_DhGenerateKeyPair(DhKey* key, WC_RNG* rng,\n    byte* priv, word32* privSz, byte* pub, word32* pubSz)\n{\n    int ret;\n\n    if (key == NULL || rng == NULL || priv == NULL || privSz == NULL ||\n                                                pub == NULL || pubSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_DH)\n    if (key->asyncDev.marker == WOLFSSL_ASYNC_MARKER_DH) {\n        ret = wc_DhGenerateKeyPair_Async(key, rng, priv, privSz, pub, pubSz);\n    }\n    else\n#endif\n    {\n        ret = wc_DhGenerateKeyPair_Sync(key, rng, priv, privSz, pub, pubSz);\n    }\n\n    return ret;\n}",
        "file_path": "/src/wolf-ssl-ssh-fuzzers/oss-fuzz/projects/wolf-ssl-ssh/fuzzers/wolfssl/wolfssl/wolfcrypt/src/dh.c",
        "crashing_line": "        ret = wc_DhGenerateKeyPair_Sync(key, rng, priv, privSz, pub, pubSz);",
        "crashing_line_number": 1833
      },
      {
        "function_name": "DhGenKeyPair",
        "function_body": "int DhGenKeyPair(WOLFSSL* ssl, DhKey* dhKey,\n    byte* priv, word32* privSz,\n    byte* pub, word32* pubSz)\n{\n    int ret;\n\n    WOLFSSL_ENTER(\"DhGenKeyPair\");\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    /* initialize event */\n    ret = wolfSSL_AsyncInit(ssl, &dhKey->asyncDev, WC_ASYNC_FLAG_NONE);\n    if (ret != 0)\n        return ret;\n#endif\n\n    ret = wc_DhGenerateKeyPair(dhKey, ssl->rng, priv, privSz, pub, pubSz);\n\n    /* Handle async pending response */\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == WC_PENDING_E) {\n        ret = wolfSSL_AsyncPush(ssl, &dhKey->asyncDev);\n    }\n#endif /* WOLFSSL_ASYNC_CRYPT */\n\n    WOLFSSL_LEAVE(\"DhGenKeyPair\", ret);\n\n    return ret;\n}",
        "file_path": "/src/wolf-ssl-ssh-fuzzers/oss-fuzz/projects/wolf-ssl-ssh/fuzzers/wolfssl/wolfssl/src/internal.c",
        "crashing_line": "    ret = wc_DhGenerateKeyPair(dhKey, ssl->rng, priv, privSz, pub, pubSz);",
        "crashing_line_number": 4950
      },
      {
        "function_name": "SendServerKeyExchange",
        "function_body": "",
        "file_path": "/src/wolf-ssl-ssh-fuzzers/oss-fuzz/projects/wolf-ssl-ssh/fuzzers/wolfssl/wolfssl/src/internal.c",
        "crashing_line": "",
        "crashing_line_number": 25216
      },
      {
        "function_name": "wolfSSL_accept",
        "function_body": "    WOLFSSL_ABI\n    int wolfSSL_accept(WOLFSSL* ssl)\n    {\n#if !(defined(WOLFSSL_NO_TLS12) && defined(NO_OLD_TLS) && defined(WOLFSSL_TLS13))\n        word16 havePSK = 0;\n        word16 haveAnon = 0;\n        word16 haveMcast = 0;\n#endif\n\n        if (ssl == NULL)\n            return WOLFSSL_FATAL_ERROR;\n\n    #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EITHER_SIDE)\n        if (ssl->options.side == WOLFSSL_NEITHER_END) {\n            WOLFSSL_MSG(\"Setting WOLFSSL_SSL to be server side\");\n            ssl->error = InitSSL_Side(ssl, WOLFSSL_SERVER_END);\n            if (ssl->error != WOLFSSL_SUCCESS) {\n                WOLFSSL_ERROR(ssl->error);\n                return WOLFSSL_FATAL_ERROR;\n            }\n            ssl->error = 0; /* expected to be zero here */\n        }\n    #endif /* OPENSSL_EXTRA || WOLFSSL_EITHER_SIDE */\n\n#if defined(WOLFSSL_NO_TLS12) && defined(NO_OLD_TLS) && defined(WOLFSSL_TLS13)\n        return wolfSSL_accept_TLSv13(ssl);\n#else\n    #ifdef WOLFSSL_TLS13\n        if (ssl->options.tls1_3)\n            return wolfSSL_accept_TLSv13(ssl);\n    #endif\n        WOLFSSL_ENTER(\"SSL_accept()\");\n\n        #ifdef HAVE_ERRNO_H\n            errno = 0;\n        #endif\n\n        #ifndef NO_PSK\n            havePSK = ssl->options.havePSK;\n        #endif\n        (void)havePSK;\n\n        #ifdef HAVE_ANON\n            haveAnon = ssl->options.haveAnon;\n        #endif\n        (void)haveAnon;\n\n        #ifdef WOLFSSL_MULTICAST\n            haveMcast = ssl->options.haveMcast;\n        #endif\n        (void)haveMcast;\n\n        if (ssl->options.side != WOLFSSL_SERVER_END) {\n            WOLFSSL_ERROR(ssl->error = SIDE_ERROR);\n            return WOLFSSL_FATAL_ERROR;\n        }\n\n    #ifndef NO_CERTS\n        /* in case used set_accept_state after init */\n        /* allow no private key if using PK callbacks and CB is set */\n        if (!havePSK && !haveAnon && !haveMcast) {\n            if (!ssl->buffers.certificate ||\n                !ssl->buffers.certificate->buffer) {\n\n                WOLFSSL_MSG(\"accept error: server cert required\");\n                WOLFSSL_ERROR(ssl->error = NO_PRIVATE_KEY);\n                return WOLFSSL_FATAL_ERROR;\n            }\n\n        #ifdef HAVE_PK_CALLBACKS\n            if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)) {\n                WOLFSSL_MSG(\"Using PK for server private key\");\n            }\n            else\n        #endif\n            if (!ssl->buffers.key || !ssl->buffers.key->buffer) {\n                WOLFSSL_MSG(\"accept error: server key required\");\n                WOLFSSL_ERROR(ssl->error = NO_PRIVATE_KEY);\n                return WOLFSSL_FATAL_ERROR;\n            }\n        }\n    #endif\n\n    #ifdef WOLFSSL_DTLS\n        if (ssl->version.major == DTLS_MAJOR) {\n            ssl->options.dtls   = 1;\n            ssl->options.tls    = 1;\n            ssl->options.tls1_1 = 1;\n        }\n    #endif\n\n        if (ssl->buffers.outputBuffer.length > 0\n        #ifdef WOLFSSL_ASYNC_CRYPT\n            /* do not send buffered or advance state if last error was an\n                async pending operation */\n            && ssl->error != WC_PENDING_E\n        #endif\n        ) {\n            if ( (ssl->error = SendBuffered(ssl)) == 0) {\n                /* fragOffset is non-zero when sending fragments. On the last\n                 * fragment, fragOffset is zero again, and the state can be\n                 * advanced. */\n                if (ssl->fragOffset == 0) {\n                    ssl->options.acceptState++;\n                    WOLFSSL_MSG(\"accept state: \"\n                                \"Advanced from last buffered fragment send\");\n                }\n                else {\n                    WOLFSSL_MSG(\"accept state: \"\n                                \"Not advanced, more fragments to send\");\n                }\n            }\n            else {\n                WOLFSSL_ERROR(ssl->error);\n                return WOLFSSL_FATAL_ERROR;\n            }\n        }\n\n        switch (ssl->options.acceptState) {\n\n        case ACCEPT_BEGIN :\n#ifdef HAVE_SECURE_RENEGOTIATION\n        case ACCEPT_BEGIN_RENEG:\n#endif\n            /* get response */\n            while (ssl->options.clientState < CLIENT_HELLO_COMPLETE)\n                if ( (ssl->error = ProcessReply(ssl)) < 0) {\n                    WOLFSSL_ERROR(ssl->error);\n                    return WOLFSSL_FATAL_ERROR;\n                }\n#ifdef WOLFSSL_TLS13\n            ssl->options.acceptState = ACCEPT_CLIENT_HELLO_DONE;\n            WOLFSSL_MSG(\"accept state ACCEPT_CLIENT_HELLO_DONE\");\n            FALL_THROUGH;\n\n        case ACCEPT_CLIENT_HELLO_DONE :\n            if (ssl->options.tls1_3) {\n                return wolfSSL_accept_TLSv13(ssl);\n            }\n#endif\n            ssl->options.acceptState = ACCEPT_FIRST_REPLY_DONE;\n            WOLFSSL_MSG(\"accept state ACCEPT_FIRST_REPLY_DONE\");\n            FALL_THROUGH;\n\n        case ACCEPT_FIRST_REPLY_DONE :\n            if ( (ssl->error = SendServerHello(ssl)) != 0) {\n                WOLFSSL_ERROR(ssl->error);\n                return WOLFSSL_FATAL_ERROR;\n            }\n            ssl->options.acceptState = SERVER_HELLO_SENT;\n            WOLFSSL_MSG(\"accept state SERVER_HELLO_SENT\");\n            FALL_THROUGH;\n\n        case SERVER_HELLO_SENT :\n        #ifdef WOLFSSL_TLS13\n            if (ssl->options.tls1_3) {\n                return wolfSSL_accept_TLSv13(ssl);\n            }\n        #endif\n            #ifndef NO_CERTS\n                if (!ssl->options.resuming)\n                    if ( (ssl->error = SendCertificate(ssl)) != 0) {\n                        WOLFSSL_ERROR(ssl->error);\n                        return WOLFSSL_FATAL_ERROR;\n                    }\n            #endif\n            ssl->options.acceptState = CERT_SENT;\n            WOLFSSL_MSG(\"accept state CERT_SENT\");\n            FALL_THROUGH;\n\n        case CERT_SENT :\n            #ifndef NO_CERTS\n            if (!ssl->options.resuming)\n                if ( (ssl->error = SendCertificateStatus(ssl)) != 0) {\n                    WOLFSSL_ERROR(ssl->error);\n                    return WOLFSSL_FATAL_ERROR;\n                }\n            #endif\n            ssl->options.acceptState = CERT_STATUS_SENT;\n            WOLFSSL_MSG(\"accept state CERT_STATUS_SENT\");\n            FALL_THROUGH;\n\n        case CERT_STATUS_SENT :\n        #ifdef WOLFSSL_TLS13\n            if (ssl->options.tls1_3) {\n                return wolfSSL_accept_TLSv13(ssl);\n            }\n        #endif\n            if (!ssl->options.resuming)\n                if ( (ssl->error = SendServerKeyExchange(ssl)) != 0) {\n                    WOLFSSL_ERROR(ssl->error);\n                    return WOLFSSL_FATAL_ERROR;\n                }\n            ssl->options.acceptState = KEY_EXCHANGE_SENT;\n            WOLFSSL_MSG(\"accept state KEY_EXCHANGE_SENT\");\n            FALL_THROUGH;\n\n        case KEY_EXCHANGE_SENT :\n            #ifndef NO_CERTS\n                if (!ssl->options.resuming) {\n                    if (ssl->options.verifyPeer) {\n                        if ( (ssl->error = SendCertificateRequest(ssl)) != 0) {\n                            WOLFSSL_ERROR(ssl->error);\n                            return WOLFSSL_FATAL_ERROR;\n                        }\n                    }\n                }\n            #endif\n            ssl->options.acceptState = CERT_REQ_SENT;\n            WOLFSSL_MSG(\"accept state CERT_REQ_SENT\");\n            FALL_THROUGH;\n\n        case CERT_REQ_SENT :\n            if (!ssl->options.resuming)\n                if ( (ssl->error = SendServerHelloDone(ssl)) != 0) {\n                    WOLFSSL_ERROR(ssl->error);\n                    return WOLFSSL_FATAL_ERROR;\n                }\n            ssl->options.acceptState = SERVER_HELLO_DONE;\n            WOLFSSL_MSG(\"accept state SERVER_HELLO_DONE\");\n            FALL_THROUGH;\n\n        case SERVER_HELLO_DONE :\n            if (!ssl->options.resuming) {\n                while (ssl->options.clientState < CLIENT_FINISHED_COMPLETE)\n                    if ( (ssl->error = ProcessReply(ssl)) < 0) {\n                        WOLFSSL_ERROR(ssl->error);\n                        return WOLFSSL_FATAL_ERROR;\n                    }\n            }\n            ssl->options.acceptState = ACCEPT_SECOND_REPLY_DONE;\n            WOLFSSL_MSG(\"accept state  ACCEPT_SECOND_REPLY_DONE\");\n            FALL_THROUGH;\n\n        case ACCEPT_SECOND_REPLY_DONE :\n#ifdef HAVE_SESSION_TICKET\n            if (ssl->options.createTicket) {\n                if ( (ssl->error = SendTicket(ssl)) != 0) {\n                    WOLFSSL_ERROR(ssl->error);\n                    return WOLFSSL_FATAL_ERROR;\n                }\n            }\n#endif /* HAVE_SESSION_TICKET */\n            ssl->options.acceptState = TICKET_SENT;\n            WOLFSSL_MSG(\"accept state  TICKET_SENT\");\n            FALL_THROUGH;\n\n        case TICKET_SENT:\n            if ( (ssl->error = SendChangeCipher(ssl)) != 0) {\n                WOLFSSL_ERROR(ssl->error);\n                return WOLFSSL_FATAL_ERROR;\n            }\n            ssl->options.acceptState = CHANGE_CIPHER_SENT;\n            WOLFSSL_MSG(\"accept state  CHANGE_CIPHER_SENT\");\n            FALL_THROUGH;\n\n        case CHANGE_CIPHER_SENT :\n            if ( (ssl->error = SendFinished(ssl)) != 0) {\n                WOLFSSL_ERROR(ssl->error);\n                return WOLFSSL_FATAL_ERROR;\n            }\n\n            ssl->options.acceptState = ACCEPT_FINISHED_DONE;\n            WOLFSSL_MSG(\"accept state ACCEPT_FINISHED_DONE\");\n            FALL_THROUGH;\n\n        case ACCEPT_FINISHED_DONE :\n            if (ssl->options.resuming)\n                while (ssl->options.clientState < CLIENT_FINISHED_COMPLETE)\n                    if ( (ssl->error = ProcessReply(ssl)) < 0) {\n                        WOLFSSL_ERROR(ssl->error);\n                        return WOLFSSL_FATAL_ERROR;\n                    }\n\n            ssl->options.acceptState = ACCEPT_THIRD_REPLY_DONE;\n            WOLFSSL_MSG(\"accept state ACCEPT_THIRD_REPLY_DONE\");\n            FALL_THROUGH;\n\n        case ACCEPT_THIRD_REPLY_DONE :\n#ifndef NO_HANDSHAKE_DONE_CB\n            if (ssl->hsDoneCb) {\n                int cbret = ssl->hsDoneCb(ssl, ssl->hsDoneCtx);\n                if (cbret < 0) {\n                    ssl->error = cbret;\n                    WOLFSSL_MSG(\"HandShake Done Cb don't continue error\");\n                    return WOLFSSL_FATAL_ERROR;\n                }\n            }\n#endif /* NO_HANDSHAKE_DONE_CB */\n\n            if (!ssl->options.dtls) {\n                if (!ssl->options.keepResources) {\n                    FreeHandshakeResources(ssl);\n                }\n            }\n#ifdef WOLFSSL_DTLS\n            else {\n                ssl->options.dtlsHsRetain = 1;\n            }\n#endif /* WOLFSSL_DTLS */\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(HAVE_SECURE_RENEGOTIATION)\n            /* This may be necessary in async so that we don't try to\n             * renegotiate again */\n            if (ssl->secure_renegotiation && ssl->secure_renegotiation->startScr) {\n                ssl->secure_renegotiation->startScr = 0;\n            }\n#endif /* WOLFSSL_ASYNC_CRYPT && HAVE_SECURE_RENEGOTIATION */\n\n#ifdef WOLFSSL_SESSION_EXPORT\n            if (ssl->dtls_export) {\n                if ((ssl->error = wolfSSL_send_session(ssl)) != 0) {\n                    WOLFSSL_MSG(\"Export DTLS session error\");\n                    WOLFSSL_ERROR(ssl->error);\n                    return WOLFSSL_FATAL_ERROR;\n                }\n            }\n#endif\n\n            WOLFSSL_LEAVE(\"SSL_accept()\", WOLFSSL_SUCCESS);\n            return WOLFSSL_SUCCESS;\n\n        default :\n            WOLFSSL_MSG(\"Unknown accept state ERROR\");\n            return WOLFSSL_FATAL_ERROR;\n        }\n#endif /* !WOLFSSL_NO_TLS12 */\n    }",
        "file_path": "/src/wolf-ssl-ssh-fuzzers/oss-fuzz/projects/wolf-ssl-ssh/fuzzers/wolfssl/wolfssl/src/ssl.c",
        "crashing_line": "                if ( (ssl->error = SendServerKeyExchange(ssl)) != 0) {",
        "crashing_line_number": 12303
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "size_t IDnsResource::decodeName(const char* encodedName, char* result, int iteration)\n{\n\tsize_t encodedNameLength = 0;\n\tsize_t decodedNameLength = 0;\n\tchar* resultPtr = result;\n\tresultPtr[0] = 0;\n\n\tsize_t curOffsetInLayer = (uint8_t*)encodedName - m_DnsLayer->m_Data;\n\tif (curOffsetInLayer + 1 > m_DnsLayer->m_DataLen)\n\t\treturn encodedNameLength;\n\n\tif (iteration > 20)\n\t{\n\t\treturn encodedNameLength;\n\t}\n\n\tuint8_t wordLength = encodedName[0];\n\n\t// A string to parse\n\twhile (wordLength != 0)\n\t{\n\t\t// A pointer to another place in the packet\n\t\tif ((wordLength & 0xc0) == 0xc0)\n\t\t{\n\t\t\tif (curOffsetInLayer + 2 > m_DnsLayer->m_DataLen || encodedNameLength > 255)\n\t\t\t\treturn encodedNameLength;\n\n\t\t\tuint16_t offsetInLayer = (wordLength & 0x3f)*256 + (0xFF & encodedName[1]) + m_DnsLayer->m_OffsetAdjustment;\n\t\t\tif (offsetInLayer < sizeof(dnshdr) || offsetInLayer >= m_DnsLayer->m_DataLen)\n\t\t\t{\n\t\t\t\tPCPP_LOG_ERROR(\"DNS parsing error: name pointer is illegal\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tchar tempResult[256];\n\t\t\tmemset(tempResult, 0, 256);\n\t\t\tint i = 0;\n\t\t\tdecodeName((const char*)(m_DnsLayer->m_Data + offsetInLayer), tempResult, iteration+1);\n\t\t\twhile (tempResult[i] != 0 && decodedNameLength < 255)\n\t\t\t{\n\t\t\t\tresultPtr[0] = tempResult[i++];\n\t\t\t\tresultPtr++;\n\t\t\t\tdecodedNameLength++;\n\t\t\t}\n\n\t\t\tresultPtr[0] = 0;\n\n\t\t\t// in this case the length of the pointer is: 1 byte for 0xc0 + 1 byte for the offset itself\n\t\t\treturn encodedNameLength + sizeof(uint16_t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// return if next word would be outside of the DNS layer or overflow the buffer behind resultPtr\n\t\t\tif (curOffsetInLayer + wordLength + 1 > m_DnsLayer->m_DataLen || encodedNameLength + wordLength > 255)\n\t\t\t{\n\t\t\t\t// add the last '\\0' to the decoded string\n\t\t\t\tif (encodedNameLength == 256)\n\t\t\t\t{\n\t\t\t\t\tresultPtr--;\n\t\t\t\t\tdecodedNameLength--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tencodedNameLength++;\n\t\t\t\t}\n\n\t\t\t\tresultPtr[0] = 0;\n\t\t\t\treturn encodedNameLength;\n\t\t\t}\n\n\n\t\t\tmemcpy(resultPtr, encodedName+1, wordLength);\n\t\t\tresultPtr += wordLength;\n\t\t\tresultPtr[0] = '.';\n\t\t\tresultPtr++;\n\t\t\tdecodedNameLength += wordLength + 1;\n\t\t\tencodedName += wordLength + 1;\n\t\t\tencodedNameLength += wordLength + 1;\n\n\t\t\tcurOffsetInLayer = (uint8_t*)encodedName - m_DnsLayer->m_Data;\n\t\t\tif (curOffsetInLayer + 1 > m_DnsLayer->m_DataLen)\n\t\t\t{\n\t\t\t\t// add the last '\\0' to the decoded string\n\t\t\t\tif (encodedNameLength == 256)\n\t\t\t\t{\n\t\t\t\t\tdecodedNameLength--;\n\t\t\t\t\tresultPtr--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tencodedNameLength++;\n\t\t\t\t}\n\n\t\t\t\tresultPtr[0] = 0;\n\t\t\t\treturn encodedNameLength;\n\t\t\t}\n\n\t\t\twordLength = encodedName[0];\n\t\t}\n\t}\n\n\t// remove the last \".\"\n\tif (resultPtr > result)\n\t{\n\t\tresult[resultPtr - result - 1] = 0;\n\t}\n\n\t// add the last '\\0' to encodedNameLength\n\tresultPtr[0] = 0;\n\tencodedNameLength++;\n\n\treturn encodedNameLength;\n}\n",
    "target": 1,
    "idx": 1043847,
    "stack_trace": [
      {
        "function_name": "decodeName",
        "function_body": "size_t IDnsResource::decodeName(const char* encodedName, char* result, int iteration)\n{\n\tsize_t encodedNameLength = 0;\n\tsize_t decodedNameLength = 0;\n\tchar* resultPtr = result;\n\tresultPtr[0] = 0;\n\n\tsize_t curOffsetInLayer = (uint8_t*)encodedName - m_DnsLayer->m_Data;\n\tif (curOffsetInLayer + 1 > m_DnsLayer->m_DataLen)\n\t\treturn encodedNameLength;\n\n\tif (iteration > 20)\n\t{\n\t\treturn encodedNameLength;\n\t}\n\n\tuint8_t wordLength = encodedName[0];\n\n\t// A string to parse\n\twhile (wordLength != 0)\n\t{\n\t\t// A pointer to another place in the packet\n\t\tif ((wordLength & 0xc0) == 0xc0)\n\t\t{\n\t\t\tif (curOffsetInLayer + 2 > m_DnsLayer->m_DataLen || encodedNameLength > 255)\n\t\t\t\treturn encodedNameLength;\n\n\t\t\tuint16_t offsetInLayer = (wordLength & 0x3f)*256 + (0xFF & encodedName[1]) + m_DnsLayer->m_OffsetAdjustment;\n\t\t\tif (offsetInLayer < sizeof(dnshdr) || offsetInLayer >= m_DnsLayer->m_DataLen)\n\t\t\t{\n\t\t\t\tPCPP_LOG_ERROR(\"DNS parsing error: name pointer is illegal\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tchar tempResult[256];\n\t\t\tmemset(tempResult, 0, 256);\n\t\t\tint i = 0;\n\t\t\tdecodeName((const char*)(m_DnsLayer->m_Data + offsetInLayer), tempResult, iteration+1);\n\t\t\twhile (tempResult[i] != 0 && decodedNameLength < 255)\n\t\t\t{\n\t\t\t\tresultPtr[0] = tempResult[i++];\n\t\t\t\tresultPtr++;\n\t\t\t\tdecodedNameLength++;\n\t\t\t}\n\n\t\t\tresultPtr[0] = 0;\n\n\t\t\t// in this case the length of the pointer is: 1 byte for 0xc0 + 1 byte for the offset itself\n\t\t\treturn encodedNameLength + sizeof(uint16_t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// return if next word would be outside of the DNS layer or overflow the buffer behind resultPtr\n\t\t\tif (curOffsetInLayer + wordLength + 1 > m_DnsLayer->m_DataLen || encodedNameLength + wordLength > 255)\n\t\t\t{\n\t\t\t\t// add the last '\\0' to the decoded string\n\t\t\t\tif (encodedNameLength == 256)\n\t\t\t\t{\n\t\t\t\t\tresultPtr--;\n\t\t\t\t\tdecodedNameLength--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tencodedNameLength++;\n\t\t\t\t}\n\n\t\t\t\tresultPtr[0] = 0;\n\t\t\t\treturn encodedNameLength;\n\t\t\t}\n\n\n\t\t\tmemcpy(resultPtr, encodedName+1, wordLength);\n\t\t\tresultPtr += wordLength;\n\t\t\tresultPtr[0] = '.';\n\t\t\tresultPtr++;\n\t\t\tdecodedNameLength += wordLength + 1;\n\t\t\tencodedName += wordLength + 1;\n\t\t\tencodedNameLength += wordLength + 1;\n\n\t\t\tcurOffsetInLayer = (uint8_t*)encodedName - m_DnsLayer->m_Data;\n\t\t\tif (curOffsetInLayer + 1 > m_DnsLayer->m_DataLen)\n\t\t\t{\n\t\t\t\t// add the last '\\0' to the decoded string\n\t\t\t\tif (encodedNameLength == 256)\n\t\t\t\t{\n\t\t\t\t\tdecodedNameLength--;\n\t\t\t\t\tresultPtr--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tencodedNameLength++;\n\t\t\t\t}\n\n\t\t\t\tresultPtr[0] = 0;\n\t\t\t\treturn encodedNameLength;\n\t\t\t}\n\n\t\t\twordLength = encodedName[0];\n\t\t}\n\t}\n\n\t// remove the last \".\"\n\tif (resultPtr > result)\n\t{\n\t\tresult[resultPtr - result - 1] = 0;\n\t}\n\n\tif (resultPtr - result < 256)\n\t{\n\t\t// add the last '\\0' to encodedNameLength\n\t\tresultPtr[0] = 0;\n\t\tencodedNameLength++;\n\t}\n\n\treturn encodedNameLength;\n}",
        "file_path": "/src/PcapPlusPlus/Packet++/src/DnsResource.cpp",
        "crashing_line": "\t{",
        "crashing_line_number": 142
      },
      {
        "function_name": "IDnsResource",
        "function_body": "bool IDnsResource::setName(const std::string& newName)\n{\n\tchar encodedName[256];\n\tsize_t encodedNameLen = 0;\n\tencodeName(newName, encodedName, encodedNameLen);\n\tif (m_DnsLayer != NULL)\n\t{\n\t\tif (encodedNameLen > m_NameLength)\n\t\t{\n\t\t\tif (!m_DnsLayer->extendLayer(m_OffsetInLayer, encodedNameLen-m_NameLength, this))\n\t\t\t{\n\t\t\t\tPCPP_LOG_ERROR(\"Couldn't set name for DNS query, unable to extend layer\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (encodedNameLen < m_NameLength)\n\t\t{\n\t\t\tif (!m_DnsLayer->shortenLayer(m_OffsetInLayer, m_NameLength-encodedNameLen, this))\n\t\t\t{\n\t\t\t\tPCPP_LOG_ERROR(\"Couldn't set name for DNS query, unable to shorten layer\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tsize_t size = getSize();\n\t\tchar* tempData = new char[size];\n\t\tmemcpy(tempData, m_ExternalRawData, size);\n\t\tmemcpy(m_ExternalRawData + encodedNameLen, tempData, size);\n\t\tdelete[] tempData;\n\t}\n\n\tmemcpy(getRawData(), encodedName, encodedNameLen);\n\tm_NameLength = encodedNameLen;\n\tm_DecodedName = newName;\n\n\treturn true;\n}",
        "file_path": "/src/PcapPlusPlus/Packet++/src/DnsResource.cpp",
        "crashing_line": "",
        "crashing_line_number": 16
      },
      {
        "function_name": "DnsQuery",
        "function_body": "\t\tvirtual ~DnsQuery() {}",
        "file_path": "/src/PcapPlusPlus/Packet++/./header/DnsResource.h",
        "crashing_line": "",
        "crashing_line_number": 133
      },
      {
        "function_name": "parseResources",
        "function_body": "void DnsLayer::parseResources()\n{\n\tsize_t offsetInPacket = getBasicHeaderSize();\n\tIDnsResource* curResource = m_ResourceList;\n\n\tuint16_t numOfQuestions = be16toh(getDnsHeader()->numberOfQuestions);\n\tuint16_t numOfAnswers = be16toh(getDnsHeader()->numberOfAnswers);\n\tuint16_t numOfAuthority = be16toh(getDnsHeader()->numberOfAuthority);\n\tuint16_t numOfAdditional = be16toh(getDnsHeader()->numberOfAdditional);\n\n\tuint32_t numOfOtherResources = numOfQuestions + numOfAnswers + numOfAuthority + numOfAdditional;\n\n\tif (numOfOtherResources > 300)\n\t{\n\t\tPCPP_LOG_ERROR(\"DNS layer contains more than 300 resources, probably a bad packet. \"\n\t\t\t\t\"Skipping parsing DNS resources\");\n\t\treturn;\n\t}\n\n\tfor (uint32_t i = 0; i < numOfOtherResources; i++)\n\t{\n\t\tDnsResourceType resType;\n\t\tif (numOfQuestions > 0)\n\t\t{\n\t\t\tresType = DnsQueryType;\n\t\t\tnumOfQuestions--;\n\t\t}\n\t\telse if (numOfAnswers > 0)\n\t\t{\n\t\t\tresType = DnsAnswerType;\n\t\t\tnumOfAnswers--;\n\t\t}\n\t\telse if (numOfAuthority > 0)\n\t\t{\n\t\t\tresType = DnsAuthorityType;\n\t\t\tnumOfAuthority--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresType = DnsAdditionalType;\n\t\t\tnumOfAdditional--;\n\t\t}\n\n\t\tDnsResource* newResource = NULL;\n\t\tDnsQuery* newQuery = NULL;\n\t\tIDnsResource* newGenResource = NULL;\n\t\tif (resType == DnsQueryType)\n\t\t{\n\t\t\tnewQuery = new DnsQuery(this, offsetInPacket);\n\t\t\tnewGenResource = newQuery;\n\t\t\toffsetInPacket += newQuery->getSize();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnewResource = new DnsResource(this, offsetInPacket, resType);\n\t\t\tnewGenResource = newResource;\n\t\t\toffsetInPacket += newResource->getSize();\n\t\t}\n\n\t\tif (offsetInPacket > m_DataLen)\n\t\t{\n\t\t\t//Parse packet failed, DNS resource is out of bounds. Probably a bad packet\n\t\t\tdelete newGenResource;\n\t\t\treturn;\n\t\t}\n\n\t\t// this resource is the first resource\n\t\tif (m_ResourceList == NULL)\n\t\t{\n\t\t\tm_ResourceList = newGenResource;\n\t\t\tcurResource = m_ResourceList;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurResource->setNexResource(newGenResource);\n\t\t\tcurResource = curResource->getNextResource();\n\t\t}\n\n\t\tif (resType == DnsQueryType && m_FirstQuery == NULL)\n\t\t\tm_FirstQuery = newQuery;\n\t\telse if (resType == DnsAnswerType && m_FirstAnswer == NULL)\n\t\t\tm_FirstAnswer = newResource;\n\t\telse if (resType == DnsAuthorityType && m_FirstAuthority == NULL)\n\t\t\tm_FirstAuthority = newResource;\n\t\telse if (resType == DnsAdditionalType && m_FirstAdditional == NULL)\n\t\t\tm_FirstAdditional = newResource;\n\t}\n\n}",
        "file_path": "/src/PcapPlusPlus/Packet++/src/DnsLayer.cpp",
        "crashing_line": "\t\t\tnewQuery = new DnsQuery(this, offsetInPacket);",
        "crashing_line_number": 190
      },
      {
        "function_name": "init",
        "function_body": "void DnsLayer::init(size_t offsetAdjustment, bool callParseResource)\n{\n\tm_OffsetAdjustment = offsetAdjustment;\n\tm_Protocol = DNS;\n\tm_ResourceList = NULL;\n\n\tm_FirstQuery = NULL;\n\tm_FirstAnswer = NULL;\n\tm_FirstAuthority = NULL;\n\tm_FirstAdditional = NULL;\n\n\tif (callParseResource)\n\t\tparseResources();\n}",
        "file_path": "/src/PcapPlusPlus/Packet++/src/DnsLayer.cpp",
        "crashing_line": "\t\tparseResources();",
        "crashing_line_number": 86
      },
      {
        "function_name": "DnsLayer",
        "function_body": "void DnsLayer::init(size_t offsetAdjustment, bool callParseResource)\n{\n\tm_OffsetAdjustment = offsetAdjustment;\n\tm_Protocol = DNS;\n\tm_ResourceList = NULL;\n\n\tm_FirstQuery = NULL;\n\tm_FirstAnswer = NULL;\n\tm_FirstAuthority = NULL;\n\tm_FirstAdditional = NULL;\n\n\tif (callParseResource)\n\t\tparseResources();\n}",
        "file_path": "/src/PcapPlusPlus/Packet++/src/DnsLayer.cpp",
        "crashing_line": "",
        "crashing_line_number": 22
      },
      {
        "function_name": "parseNextLayer",
        "function_body": "void UdpLayer::parseNextLayer()\n{\n\tif (m_DataLen <= sizeof(udphdr))\n\t\treturn;\n\n\tuint16_t portDst = getDstPort();\n\tuint16_t portSrc = getSrcPort();\n\n\tuint8_t* udpData = m_Data + sizeof(udphdr);\n\tsize_t udpDataLen = m_DataLen - sizeof(udphdr);\n\n\tif ((portSrc == 68 && portDst == 67) || (portSrc == 67 && portDst == 68) || (portSrc == 67 && portDst == 67))\n\t\tm_NextLayer = new DhcpLayer(udpData, udpDataLen, this, m_Packet);\n\telse if (VxlanLayer::isVxlanPort(portDst))\n\t\tm_NextLayer = new VxlanLayer(udpData, udpDataLen, this, m_Packet);\n\telse if (DnsLayer::isDataValid(udpData, udpDataLen) && (DnsLayer::isDnsPort(portDst) || DnsLayer::isDnsPort(portSrc)))\n\t\tm_NextLayer = new DnsLayer(udpData, udpDataLen, this, m_Packet);\n\telse if(SipLayer::isSipPort(portDst) || SipLayer::isSipPort(portSrc))\n\t{\n\t\tif (SipRequestFirstLine::parseMethod((char*)udpData, udpDataLen) != SipRequestLayer::SipMethodUnknown)\n\t\t\tm_NextLayer = new SipRequestLayer(udpData, udpDataLen, this, m_Packet);\n\t\telse if (SipResponseFirstLine::parseStatusCode((char*)udpData, udpDataLen) != SipResponseLayer::SipStatusCodeUnknown\n\t\t\t\t\t\t&& SipResponseFirstLine::parseVersion((char*)udpData, udpDataLen) != \"\")\n\t\t\tm_NextLayer = new SipResponseLayer(udpData, udpDataLen, this, m_Packet);\n\t\telse\n\t\t\tm_NextLayer = new PayloadLayer(udpData, udpDataLen, this, m_Packet);\n\t}\n\telse if ((RadiusLayer::isRadiusPort(portDst) || RadiusLayer::isRadiusPort(portSrc)) && RadiusLayer::isDataValid(udpData, udpDataLen))\n\t\tm_NextLayer = new RadiusLayer(udpData, udpDataLen, this, m_Packet);\n\telse if ((GtpV1Layer::isGTPv1Port(portDst) || GtpV1Layer::isGTPv1Port(portSrc)) && GtpV1Layer::isGTPv1(udpData, udpDataLen))\n\t\tm_NextLayer = new GtpV1Layer(udpData, udpDataLen, this, m_Packet);\n\telse if ((DhcpV6Layer::isDhcpV6Port(portSrc) || DhcpV6Layer::isDhcpV6Port(portDst)) && (DhcpV6Layer::isDataValid(udpData, udpDataLen)))\n\t\tm_NextLayer = new DhcpV6Layer(udpData, udpDataLen, this, m_Packet);\n\telse if ((NtpLayer::isNTPPort(portSrc) || NtpLayer::isNTPPort(portDst)) && NtpLayer::isDataValid(udpData, udpDataLen))\n\t\tm_NextLayer = new NtpLayer(udpData, udpDataLen, this, m_Packet);\n\telse\n\t\tm_NextLayer = new PayloadLayer(udpData, udpDataLen, this, m_Packet);\n}",
        "file_path": "/src/PcapPlusPlus/Packet++/src/UdpLayer.cpp",
        "crashing_line": "\t\tm_NextLayer = new DnsLayer(udpData, udpDataLen, this, m_Packet);",
        "crashing_line_number": 117
      },
      {
        "function_name": "setRawPacket",
        "function_body": "void Packet::setRawPacket(RawPacket* rawPacket, bool freeRawPacket, ProtocolType parseUntil, OsiModelLayer parseUntilLayer)\n{\n\tdestructPacketData();\n\n\tm_FirstLayer = NULL;\n\tm_LastLayer = NULL;\n\tm_ProtocolTypes = UnknownProtocol;\n\tm_MaxPacketLen = rawPacket->getRawDataLen();\n\tm_FreeRawPacket = freeRawPacket;\n\tm_RawPacket = rawPacket;\n\tm_CanReallocateData = true;\n\tif (m_RawPacket == NULL)\n\t\treturn;\n\n\tLinkLayerType linkType = m_RawPacket->getLinkLayerType();\n\n\tm_FirstLayer = createFirstLayer(linkType);\n\n\tm_LastLayer = m_FirstLayer;\n\tLayer* curLayer = m_FirstLayer;\n\twhile (curLayer != NULL && (curLayer->getProtocol() & parseUntil) == 0 && curLayer->getOsiModelLayer() <= parseUntilLayer)\n\t{\n\t\tm_ProtocolTypes |= curLayer->getProtocol();\n\t\tcurLayer->parseNextLayer();\n\t\tcurLayer->m_IsAllocatedInPacket = true;\n\t\tcurLayer = curLayer->getNextLayer();\n\t\tif (curLayer != NULL)\n\t\t\tm_LastLayer = curLayer;\n\t}\n\n\tif (curLayer != NULL && (curLayer->getProtocol() & parseUntil) != 0)\n\t{\n\t\tm_ProtocolTypes |= curLayer->getProtocol();\n\t\tcurLayer->m_IsAllocatedInPacket = true;\n\t}\n\n\tif (curLayer != NULL &&  curLayer->getOsiModelLayer() > parseUntilLayer)\n\t{\n\t\tm_LastLayer = curLayer->getPrevLayer();\n\t\tdelete curLayer;\n\t\tm_LastLayer->m_NextLayer = NULL;\n\t}\n\n\tif (m_LastLayer != NULL && parseUntil == UnknownProtocol && parseUntilLayer == OsiModelLayerUnknown)\n\t{\n\t\t// find if there is data left in the raw packet that doesn't belong to any layer. In that case it's probably a packet trailer.\n\t\t// create a PacketTrailerLayer layer and add it at the end of the packet\n\t\tint trailerLen = (int)((m_RawPacket->getRawData() + m_RawPacket->getRawDataLen()) - (m_LastLayer->getData() + m_LastLayer->getDataLen()));\n\t\tif (trailerLen > 0)\n\t\t{\n\t\t\tPacketTrailerLayer* trailerLayer = new PacketTrailerLayer(\n\t\t\t\t\t(uint8_t*)(m_LastLayer->getData() + m_LastLayer->getDataLen()),\n\t\t\t\t\ttrailerLen,\n\t\t\t\t\tm_LastLayer,\n\t\t\t\t\tthis);\n\n\t\t\ttrailerLayer->m_IsAllocatedInPacket = true;\n\t\t\tm_LastLayer->setNextLayer(trailerLayer);\n\t\t\tm_LastLayer = trailerLayer;\n\t\t\tm_ProtocolTypes |= trailerLayer->getProtocol();\n\t\t}\n\t}\n}",
        "file_path": "/src/PcapPlusPlus/Packet++/src/Packet.cpp",
        "crashing_line": "\t\tcurLayer->parseNextLayer();",
        "crashing_line_number": 80
      },
      {
        "function_name": "Packet",
        "function_body": "Packet::Packet(RawPacket* rawPacket, OsiModelLayer parseUntilLayer)\n{\n\tm_FreeRawPacket = false;\n\tm_RawPacket = NULL;\n\tm_FirstLayer = NULL;\n\tsetRawPacket(rawPacket, false, UnknownProtocol, parseUntilLayer);\n}",
        "file_path": "/src/PcapPlusPlus/Packet++/src/Packet.cpp",
        "crashing_line": "",
        "crashing_line_number": 126
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void LibRaw::kodak_jpeg_load_raw()\n{\n  if (data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr pub;\n  cinfo.err = jpeg_std_error(&pub);\n  pub.error_exit = jpegErrorExit_k;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  std::vector<uchar> pixel_buf(width * 3);\n  jpeg_create_decompress(&cinfo);\n\n  fread(jpg_buf, data_size, 1, ifp);\n  libraw_swab(jpg_buf, data_size);\n  try\n  {\n    jpeg_mem_src(&cinfo, jpg_buf, data_size);\n    int rc = jpeg_read_header(&cinfo, TRUE);\n    if (rc != 1)\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n    jpeg_start_decompress(&cinfo);\n    if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) ||\n        (cinfo.output_components != 3))\n    {\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n\n    unsigned char *buf[1];\n    buf[0] = pixel_buf.data();\n\n    while (cinfo.output_scanline < cinfo.output_height)\n    {\n      checkCancel();\n      row = cinfo.output_scanline * 2;\n      jpeg_read_scanlines(&cinfo, buf, 1);\n      unsigned char(*pixel)[3] = (unsigned char(*)[3])buf[0];\n      for (col = 0; col < width; col += 2)\n      {\n        RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n        RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n        RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n        RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n      }\n    }\n  }\n  catch (...)\n  {\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    free(jpg_buf);\n    throw;\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  free(jpg_buf);\n  maximum = 0xff << 1;\n}\nvoid LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (INT64(T.theight) * INT64(T.twidth) < 64ULL)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n\n  if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n          kodak_ycbcr_load_raw();\n      else if(Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)\n        kodak_rgb_load_raw();\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n        kodak_thumb_load_raw();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n\n  float out[3], out_cam[3][4] = {{2.81761312f, -1.98369181f, 0.166078627f, 0},\n                                 {-0.111855984f, 1.73688626f, -0.625030339f, 0},\n                                 {-0.0379119813f, -0.891268849f, 1.92918086f, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int rr = 0; rr < S.height; rr++, soff += rstep)\n    {\n      char *ppm = T.thumb + rr * S.width * P1.colors;\n      for (int cc = 0; cc < S.width; cc++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[cc * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n",
    "target": 1,
    "idx": 1052672,
    "stack_trace": [
      {
        "function_name": "kodak_rgb_load_raw",
        "function_body": "void LibRaw::kodak_rgb_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n    checkCancel();\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n        if (load_flags == 12)\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        else\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}",
        "file_path": "/src/libraw/src/decoders/kodak_decoders.cpp",
        "crashing_line": "      ret = kodak_65000_decode(buf, len * 3);",
        "crashing_line_number": 503
      },
      {
        "function_name": "kodak_thumb_loader",
        "function_body": "void LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (INT64(T.theight) * INT64(T.twidth) < 64ULL)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if(T.twidth < 16 || T.twidth > 8192 || T.theight < 16 || T.theight > 8192)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n\n  if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n          kodak_ycbcr_load_raw();\n      else if(Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)\n        kodak_rgb_load_raw();\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n        kodak_thumb_load_raw();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n\n  float out[3], out_cam[3][4] = {{2.81761312f, -1.98369181f, 0.166078627f, 0},\n                                 {-0.111855984f, 1.73688626f, -0.625030339f, 0},\n                                 {-0.0379119813f, -0.891268849f, 1.92918086f, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int rr = 0; rr < S.height; rr++, soff += rstep)\n    {\n      char *ppm = T.thumb + rr * S.width * P1.colors;\n      for (int cc = 0; cc < S.width; cc++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[cc * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}",
        "file_path": "/src/libraw/src/utils/thumb_utils.cpp",
        "crashing_line": "      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)",
        "crashing_line_number": 66
      },
      {
        "function_name": "unpack_thumb",
        "function_body": "int LibRaw::unpack_thumb(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n#define THUMB_SIZE_CHECKT(A) \\\n  do { \\\n    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(A) > 0 &&  INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n#define THUMB_SIZE_CHECKTNZ(A) \\\n  do { \\\n    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n\n#define THUMB_SIZE_CHECKWH(W,H) \\\n  do { \\\n    if (INT64(W)*INT64(H) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(W)*INT64(H) < 64ULL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n  try\n  {\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n    int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;\n\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                         load_raw == &LibRaw::broadcom_load_raw)  // RPi\n#ifdef USE_6BY9RPI\n        && !(imgdata.thumbnail.tlength > 0 && libraw_internal_data.unpacker_data.load_flags & 0x4000\n            && (load_raw == &LibRaw::rpi_load_raw8 || load_raw == &LibRaw::nokia_load_raw ||\n           load_raw == &LibRaw::rpi_load_raw12 || load_raw == &LibRaw::rpi_load_raw14))\n#endif\n    )\n    {\n      return LIBRAW_NO_THUMBNAIL;\n    }\n    else if ((Tformat >= LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n\t\t&& ((Tformat <= LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)))\n    {\n      kodak_thumb_loader();\n      T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n      return 0;\n    }\n    else\n    {\n#ifdef USE_X3FTOOLS\n\tif (Tformat == LIBRAW_INTERNAL_THUMBNAIL_X3F)\n      {\n        INT64 tsize = x3f_thumb_size();\n        if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        THUMB_SIZE_CHECKT(tsize);\n      }\n#else\n\tif (0) {}\n#endif\n      else\n      {\n        if (INT64(ID.toffset) + INT64(T.tlength) < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + INT64(T.tlength) >\n            ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n\n      ID.input->seek(ID.toffset, SEEK_SET);\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_JPEG)\n      {\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)malloc(T.tlength);\n        ID.input->read(T.thumb, 1, T.tlength);\n\t\tunsigned char *tthumb = (unsigned char *)T.thumb;\n\t\tif (load_raw == &LibRaw::crxLoadRaw && T.tlength > 0xE0)\n\t\t{\n\t\t\t// Check if it is canon H.265 preview:  CISZ at bytes 4-6, CISZ prefix is 000n\n\t\t\tif (tthumb[0] == 0 && tthumb[1] == 0 && tthumb[2] == 0 && !memcmp(tthumb + 4, \"CISZ\", 4))\n\t\t\t{\n\t\t\t\tT.tformat = LIBRAW_THUMBNAIL_H265;\n\t\t\t\tSET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n        tthumb[0] = 0xff;\n        tthumb[1] = 0xd8;\n#ifdef NO_JPEG\n        T.tcolors = 3;\n#else\n        {\n          jpegErrorManager jerr;\n          struct jpeg_decompress_struct cinfo;\n          cinfo.err = jpeg_std_error(&jerr.pub);\n          jerr.pub.error_exit = jpegErrorExit;\n          if (setjmp(jerr.setjmp_buffer))\n          {\n          err2:\n            // Error in original JPEG thumb, read it again because\n            // original bytes 0-1 was damaged above\n            jpeg_destroy_decompress(&cinfo);\n            T.tcolors = 3;\n            T.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n            ID.input->seek(ID.toffset, SEEK_SET);\n            ID.input->read(T.thumb, 1, T.tlength);\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n          jpeg_create_decompress(&cinfo);\n          jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);\n          int rc = jpeg_read_header(&cinfo, TRUE);\n          if (rc != 1)\n            goto err2;\n          T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3)\n                          ? cinfo.num_components\n                          : 3;\n          jpeg_destroy_decompress(&cinfo);\n        }\n#endif\n        T.tformat = LIBRAW_THUMBNAIL_JPEG;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_LAYER)\n      {\n        int colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n        if (colors != 1 && colors != 3)\n          return LIBRAW_UNSUPPORTED_THUMBNAIL;\n\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)calloc(colors, tlength);\n        unsigned char *tbuf = (unsigned char *)calloc(colors, tlength);\n        // Avoid OOB of tbuf, should use tlength\n        ID.input->read(tbuf, colors, tlength);\n        if (libraw_internal_data.unpacker_data.thumb_misc >> 8 &&\n            colors == 3) // GRB order\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i + tlength];\n            T.thumb[i * 3 + 1] = tbuf[i];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 3) // RGB or 1-channel\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i];\n            T.thumb[i * 3 + 1] = tbuf[i + tlength];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 1)\n        {\n          free(T.thumb);\n          T.thumb = (char *)tbuf;\n          tbuf = 0;\n        }\n        if (tbuf)\n          free(tbuf);\n        T.tcolors = colors;\n        T.tlength = colors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_ROLLEI)\n      {\n        int i;\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.tcolors = 3;\n        T.thumb = (char *)calloc(T.tcolors, tlength);\n        unsigned short *tbuf = (unsigned short *)calloc(2, tlength);\n        read_shorts(tbuf, tlength);\n        for (i = 0; i < tlength; i++)\n        {\n          T.thumb[i * 3] = (tbuf[i] << 3) & 0xff;\n          T.thumb[i * 3 + 1] = (tbuf[i] >> 5 << 2) & 0xff;\n          T.thumb[i * 3 + 2] = (tbuf[i] >> 11 << 3) & 0xff;\n        }\n        free(tbuf);\n        T.tlength = T.tcolors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_PPM)\n      {\n        if (t_bytesps > 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 8-bit thumb, but parsed for more\n                                             // bits\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int t_length = T.twidth * T.theight * t_colors;\n\n        if (T.tlength &&\n            (int)T.tlength < t_length) // try to find tiff ifd with needed offset\n        {\n          int pifd = find_ifd_by_offset(libraw_internal_data.internal_data.toffset);\n          if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count &&\n              tiff_ifd[pifd].strip_byte_counts_count)\n          {\n            // We found it, calculate final size\n            unsigned total_size = 0;\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)\n              total_size += tiff_ifd[pifd].strip_byte_counts[i];\n            if (total_size != (unsigned)t_length) // recalculate colors\n            {\n              if (total_size == T.twidth * T.tlength * 3)\n                T.tcolors = 3;\n              else if (total_size == T.twidth * T.tlength)\n                T.tcolors = 1;\n            }\n            T.tlength = total_size;\n            THUMB_SIZE_CHECKTNZ(T.tlength);\n            if (T.thumb)\n              free(T.thumb);\n            T.thumb = (char *)malloc(T.tlength);\n\n            char *dest = T.thumb;\n            INT64 pos = ID.input->tell();\n\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count &&\n                            i < tiff_ifd[pifd].strip_offsets_count;\n                 i++)\n            {\n              int remain = T.tlength;\n              int sz = tiff_ifd[pifd].strip_byte_counts[i];\n              int off = tiff_ifd[pifd].strip_offsets[i];\n              if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)\n              {\n                ID.input->seek(off, SEEK_SET);\n                ID.input->read(dest, sz, 1);\n                remain -= sz;\n                dest += sz;\n              }\n            }\n            ID.input->seek(pos, SEEK_SET);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        }\n\n        if (!T.tlength)\n          T.tlength = t_length;\n        if (T.thumb)\n          free(T.thumb);\n\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        T.thumb = (char *)malloc(T.tlength);\n        if (!T.tcolors)\n          T.tcolors = t_colors;\n\n        ID.input->read(T.thumb, 1, T.tlength);\n\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_PPM16)\n      {\n        if (t_bytesps > 2)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 16-bit thumb, but parsed for\n                                             // more bits\n        int o_bps = (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS) ? 2 : 1;\n        int o_length = T.twidth * T.theight * t_colors * o_bps;\n        int i_length = T.twidth * T.theight * t_colors * 2;\n        if (!T.tlength)\n          T.tlength = o_length;\n        THUMB_SIZE_CHECKTNZ(o_length);\n        THUMB_SIZE_CHECKTNZ(i_length);\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        ushort *t_thumb = (ushort *)calloc(i_length, 1);\n        ID.input->read(t_thumb, 1, i_length);\n        if ((libraw_internal_data.unpacker_data.order == 0x4949) ==\n            (ntohs(0x1234) == 0x1234))\n          libraw_swab(t_thumb, i_length);\n\n        if (T.thumb)\n          free(T.thumb);\n        if ((imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS))\n        {\n          T.thumb = (char *)t_thumb;\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP16;\n        }\n        else\n        {\n          T.thumb = (char *)malloc(o_length);\n          for (int i = 0; i < o_length; i++)\n            T.thumb[i] = t_thumb[i] >> 8;\n          free(t_thumb);\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        }\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#ifdef USE_X3FTOOLS\n\t  else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_X3F)\n      {\n        x3f_thumb_loader();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#endif\n      else\n      {\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL; /* warned as unreachable*/\n  }\n  catch (const LibRaw_exceptions& err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}",
        "file_path": "/src/libraw/src/decoders/unpack_thumb.cpp",
        "crashing_line": "      kodak_thumb_loader();",
        "crashing_line_number": 98
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int ndpi_add_host_ip_subprotocol(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\tchar *value, u_int16_t protocol_id,\n\t\t\t\t\tu_int8_t is_ipv6) {\n  ndpi_patricia_node_t *node;\n  struct in_addr pin;\n  struct in6_addr pin6;\n  int bits = 32;\n  char *ptr = strrchr(value, '/');\n  u_int16_t port = 0; /* Format ip:8.248.73.247 */\n                      /* Format ipv6:[fe80::76ac:b9ff:fe6c:c124]/64 */\n  char *double_column = NULL;\n  struct hostent *h;\n  bool value_ready = false;\n  \n  if(!ndpi_str->protocols_ptree)\n    return(-1);\n\n  if(value[0] == '[') {\n    is_ipv6 = 1;\n    bits = 128;\n    value += 1;\n  }\n\n  if(ptr) {\n    ptr[0] = '\\0';\n    ptr++;\n\n    if((double_column = strrchr(ptr, ':')) != NULL) {\n      double_column[0] = '\\0';\n      port = atoi(&double_column[1]);\n    }\n\n    if(!is_ipv6) {\n      if(atoi(ptr) >= 0 && atoi(ptr) <= 32)\n        bits = atoi(ptr);\n    } else {\n      if(atoi(ptr) >= 0 && atoi(ptr) <= 128)\n        bits = atoi(ptr);\n\n      ptr = strrchr(value, ']');\n      if(ptr)\n        *ptr = '\\0';\n    }\n  } else {\n    /*\n      Let's check if there is the port defined\n\n      Example: ip:8.248.73.247:443@AmazonPrime\n      Example: ipv6:[fe80::76ac:b9ff:fe6c:c124]:36818@CustomProtocolF\n    */\n    if(!is_ipv6) {\n      double_column = strrchr(value, ':');\n    } else {\n      ptr = strrchr(value, ']');\n      if(ptr) {\n        double_column = strrchr(ptr, ':');\n        *ptr = '\\0';\n      }\n    }\n\n    if(double_column) {\n      double_column[0] = '\\0';\n      port = atoi(&double_column[1]);\n    }\n  }\n\n  if(!is_ipv6) {\n    /* Check if the IP address is symbolic or numeric */\n    unsigned int d[4];\n    char tail[16] = { '\\0' };\n    int c = sscanf(value, \"%3u.%3u.%3u.%3u%s\", &d[0], &d[1], &d[2], &d[3], tail);\n\n    if ((c != 4) || tail[0]) {\n      /* This might be a symbolic IPv4 address */\n\n      if((h = gethostbyname2(value, AF_INET)) != NULL) {\n\tmemcpy(&pin, h->h_addr_list[0], sizeof(pin));\n\tvalue_ready = true;\n      }\n    }\n\n    if(!value_ready) {\n      if(inet_pton(AF_INET, value, &pin) != 1)\n\treturn(-1);\n    }\n\n    node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, bits);\n  } else {\n    if(strchr(value, ':') == NULL) {\n      /* This might be a symbolic IPv6 address */\n\n      if((h = gethostbyname2(value, AF_INET6)) != NULL) {\n\tmemcpy(&pin6, h->h_addr_list[0], sizeof(pin6));\n\tvalue_ready = true;\n      }\n    }\n\n    if(!value_ready) {\n      if(inet_pton(AF_INET6, value, &pin6) != 1)\n\treturn(-1);\n    }\n    \n    node = add_to_ptree(ndpi_str->protocols_ptree6, AF_INET6, &pin6, bits);\n  }\n\n  if(node != NULL) {\n    int i;\n    struct patricia_uv16_list *item;\n\n    for(i=0; i<UV16_MAX_USER_VALUES; i++) {\n      if(node->value.u.uv16[i].user_value == 0) {\n\tnode->value.u.uv16[i].user_value = protocol_id, node->value.u.uv16[i].additional_user_value = htons(port);\n\n\treturn(0);\n      }\n    } /* for */\n\n    /*\n      If we're here it means that we don't have\n      enough room for our custom value\n    */\n    item = (struct patricia_uv16_list*)ndpi_malloc(sizeof(struct patricia_uv16_list));\n\n    if(item != NULL) {\n      item->value.user_value = protocol_id,\n\titem->value.additional_user_value = htons(port),\n\titem->next = (struct patricia_uv16_list*)node->data;\n\n      node->data = item;\n\n      return(0);\n    }\n\n    return(-1); /* All slots are full */\n  }\n\n  return(0);\n}\n",
    "target": 1,
    "idx": 1063746,
    "stack_trace": [
      {
        "function_name": "ndpi_add_host_ip_subprotocol",
        "function_body": "static int ndpi_add_host_ip_subprotocol(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\tchar *value, u_int16_t protocol_id,\n\t\t\t\t\tu_int8_t is_ipv6) {\n  ndpi_patricia_node_t *node;\n  struct in_addr pin;\n  struct in6_addr pin6;\n  int bits = 32;\n  char *ptr = strrchr(value, '/');\n  u_int16_t port = 0; /* Format ip:8.248.73.247 */\n                      /* Format ipv6:[fe80::76ac:b9ff:fe6c:c124]/64 */\n  char *double_column = NULL;\n  struct hostent *h;\n  bool value_ready = false;\n  \n  if(!ndpi_str->protocols_ptree)\n    return(-1);\n\n  if(value[0] == '[') {\n    is_ipv6 = 1;\n    bits = 128;\n    value += 1;\n  }\n\n  if(ptr) {\n    ptr[0] = '\\0';\n    ptr++;\n\n    if((double_column = strrchr(ptr, ':')) != NULL) {\n      double_column[0] = '\\0';\n      port = atoi(&double_column[1]);\n    }\n\n    if(!is_ipv6) {\n      if(atoi(ptr) >= 0 && atoi(ptr) <= 32)\n        bits = atoi(ptr);\n    } else {\n      if(atoi(ptr) >= 0 && atoi(ptr) <= 128)\n        bits = atoi(ptr);\n\n      ptr = strrchr(value, ']');\n      if(ptr)\n        *ptr = '\\0';\n    }\n  } else {\n    /*\n      Let's check if there is the port defined\n\n      Example: ip:8.248.73.247:443@AmazonPrime\n      Example: ipv6:[fe80::76ac:b9ff:fe6c:c124]:36818@CustomProtocolF\n    */\n    if(!is_ipv6) {\n      double_column = strrchr(value, ':');\n    } else {\n      ptr = strrchr(value, ']');\n      if(ptr) {\n        double_column = strrchr(ptr, ':');\n        *ptr = '\\0';\n      }\n    }\n\n    if(double_column) {\n      double_column[0] = '\\0';\n      port = atoi(&double_column[1]);\n    }\n  }\n\n  if(!is_ipv6) {\n    /* Check if the IP address is symbolic or numeric */\n    unsigned int d[4];\n    char tail[16] = { '\\0' };\n    int c = sscanf(value, \"%3u.%3u.%3u.%3u%15s\", &d[0], &d[1], &d[2], &d[3], tail);\n\n    if ((c != 4) || tail[0]) {\n      /* This might be a symbolic IPv4 address */\n\n      if((h = gethostbyname2(value, AF_INET)) != NULL) {\n\tmemcpy(&pin, h->h_addr_list[0], sizeof(pin));\n\tvalue_ready = true;\n      }\n    }\n\n    if(!value_ready) {\n      if(inet_pton(AF_INET, value, &pin) != 1)\n\treturn(-1);\n    }\n\n    node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, bits);\n  } else {\n    if(strchr(value, ':') == NULL) {\n      /* This might be a symbolic IPv6 address */\n\n      if((h = gethostbyname2(value, AF_INET6)) != NULL) {\n\tmemcpy(&pin6, h->h_addr_list[0], sizeof(pin6));\n\tvalue_ready = true;\n      }\n    }\n\n    if(!value_ready) {\n      if(inet_pton(AF_INET6, value, &pin6) != 1)\n\treturn(-1);\n    }\n    \n    node = add_to_ptree(ndpi_str->protocols_ptree6, AF_INET6, &pin6, bits);\n  }\n\n  if(node != NULL) {\n    int i;\n    struct patricia_uv16_list *item;\n\n    for(i=0; i<UV16_MAX_USER_VALUES; i++) {\n      if(node->value.u.uv16[i].user_value == 0) {\n\tnode->value.u.uv16[i].user_value = protocol_id, node->value.u.uv16[i].additional_user_value = htons(port);\n\n\treturn(0);\n      }\n    } /* for */\n\n    /*\n      If we're here it means that we don't have\n      enough room for our custom value\n    */\n    item = (struct patricia_uv16_list*)ndpi_malloc(sizeof(struct patricia_uv16_list));\n\n    if(item != NULL) {\n      item->value.user_value = protocol_id,\n\titem->value.additional_user_value = htons(port),\n\titem->next = (struct patricia_uv16_list*)node->data;\n\n      node->data = item;\n\n      return(0);\n    }\n\n    return(-1); /* All slots are full */\n  }\n\n  return(0);\n}",
        "file_path": "/src/ndpi/src/lib/ndpi_main.c",
        "crashing_line": "    int c = sscanf(value, \"%3u.%3u.%3u.%3u%15s\", &d[0], &d[1], &d[2], &d[3], tail);",
        "crashing_line_number": 2771
      },
      {
        "function_name": "ndpi_handle_rule",
        "function_body": "int ndpi_handle_rule(struct ndpi_detection_module_struct *ndpi_str,\n\t\t     char *rule, u_int8_t do_add) {\n  char *at, *proto, *elem;\n  ndpi_proto_defaults_t *def;\n  u_int subprotocol_id, i;\n  int id, ret = 0;\n\n  at = strrchr(rule, '@');\n  if(at == NULL) {\n    /* This looks like a mask rule or an invalid rule */\n    char _rule[256], *rule_type, *key;\n\n    ndpi_snprintf(_rule, sizeof(_rule), \"%s\", rule);\n    rule_type = strtok(rule, \":\");\n\n    if(!rule_type) {\n      NDPI_LOG_ERR(ndpi_str, \"Invalid rule '%s'\\n\", rule);\n      return(-1);\n    }\n\n    if(!strcmp(rule_type, \"trusted_issuer_dn\"))\n      return(ndpi_add_trusted_issuer_dn(ndpi_str, strtok(NULL, \":\")));\n\n    key = strtok(NULL, \"=\");\n    if(key) {\n      char *value = strtok(NULL, \"=\");\n\n      if(value) {\n\tndpi_risk risk_mask = (ndpi_risk)atoll(value);\n\n\tif(!strcmp(rule_type, \"ip_risk_mask\") ||\n\t   !strcmp(rule_type, \"ipv6_risk_mask\")) {\n\t  return(ndpi_add_ip_risk_mask(ndpi_str, key, risk_mask));\n\t} else if(!strcmp(rule_type, \"host_risk_mask\")) {\n\t  return(ndpi_add_host_risk_mask(ndpi_str, key, risk_mask));\n\t}\n      }\n    }\n\n    NDPI_LOG_ERR(ndpi_str, \"Unknown rule '%s'\\n\", rule);\n    return(-1);\n  } else\n    at[0] = 0, proto = &at[1];\n\n  for(i = 0; proto[i] != '\\0'; i++) {\n    switch(proto[i]) {\n    case '/':\n    case '&':\n    case '^':\n    case ':':\n    case ';':\n    case '\\'':\n    case '\"':\n    case ' ':\n      proto[i] = '_';\n      break;\n    }\n  }\n\n  if((id = ndpi_get_protocol_id(ndpi_str, proto)) != -1) {\n    subprotocol_id = (u_int)id;\n    def = &ndpi_str->proto_defaults[subprotocol_id];\n  } else\n    def = NULL;\n\n  if(def == NULL) {\n    if(!do_add) {\n      /* We need to remove a rule */\n      NDPI_LOG_ERR(ndpi_str, \"Unable to find protocol '%s': skipping rule '%s'\\n\", proto, rule);\n      return(-3);\n    } else {\n      ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];\n      char *equal = strchr(proto, '=');\n      u_int16_t user_proto_id = ndpi_str->ndpi_num_supported_protocols;\n\n      if(equal != NULL) {\n\t/* PROTO=VALUE */\n\n\tequal[0] = '\\0';\n\tuser_proto_id = atoi(&equal[1]);\n\n\t/* NOTE: ndpi_str->ndpi_num_supported_protocols >= NDPI_MAX_SUPPORTED_PROTOCOLS */\n\tndpi_add_user_proto_id_mapping(ndpi_str, ndpi_str->ndpi_num_supported_protocols, user_proto_id);\n\n\t/* printf(\"***** ADDING MAPPING %s: %u -> %u\\n\", proto, ndpi_str->ndpi_num_supported_protocols, user_proto_id); */\n      } else\n\tndpi_add_user_proto_id_mapping(ndpi_str, ndpi_str->ndpi_num_supported_protocols,\n\t\t\t\t       ndpi_str->ndpi_num_supported_protocols);\n\n      if(ndpi_str->ndpi_num_custom_protocols >= (NDPI_MAX_NUM_CUSTOM_PROTOCOLS - 1)) {\n\tNDPI_LOG_ERR(ndpi_str, \"Too many protocols defined (%u): skipping protocol %s\\n\",\n\t\t     ndpi_str->ndpi_num_custom_protocols, proto);\n\treturn(-2);\n      }\n\n      ndpi_set_proto_defaults(ndpi_str, 1 /* is_cleartext */,\n\t\t\t      1 /* is_app_protocol */,\n\t\t\t      NDPI_PROTOCOL_ACCEPTABLE, /* breed*/\n\t\t\t      ndpi_str->ndpi_num_supported_protocols /* protoId */,\n\t\t\t      proto, /* protoName */\n\t\t\t      NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, /* TODO add protocol category support in rules */\n\t\t\t      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,\n\t\t\t      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);\n\n      def = &ndpi_str->proto_defaults[ndpi_str->ndpi_num_supported_protocols];\n      subprotocol_id = ndpi_str->ndpi_num_supported_protocols;\n      ndpi_str->ndpi_num_supported_protocols++, ndpi_str->ndpi_num_custom_protocols++;\n    }\n  }\n\n  while((elem = strsep(&rule, \",\")) != NULL) {\n    char *attr = elem, *value = NULL;\n    ndpi_port_range range;\n    int is_tcp = 0, is_udp = 0, is_ip = 0;\n    u_int8_t is_ipv6_ip = 0;\n\n    if(strncmp(attr, \"tcp:\", 4) == 0)\n      is_tcp = 1, value = &attr[4];\n    else if(strncmp(attr, \"udp:\", 4) == 0)\n      is_udp = 1, value = &attr[4];\n    else if(strncmp(attr, \"ipv6:\", 5) == 0)\n      is_ip = 1, is_ipv6_ip = 1, value = &attr[5];\n    else if(strncmp(attr, \"ip:\", 3) == 0)\n      is_ip = 1, value = &attr[3];\n    else if(strncmp(attr, \"host:\", 5) == 0) {\n      /* host:\"<value>\",host:\"<value>\",.....@<subproto> */\n      value = &attr[5];\n      if(value[0] == '\"')\n\tvalue++; /* remove leading \" */\n\n      if(value[0] != '\\0') {\n\tu_int i, max_len = strlen(value) - 1;\n\n\tif(value[max_len] == '\"')\n\t  value[max_len] = '\\0'; /* remove trailing \" */\n\n\tfor(i=0; i<max_len; i++)\n\t  value[i] = tolower(value[i]);\n      }\n    } else if(strncmp(attr, \"nbpf:\", 5) == 0) {\n#ifdef HAVE_NBPF\n      char *filter = &attr[5];\n\n      if(ndpi_str->num_nbpf_custom_proto >= MAX_NBPF_CUSTOM_PROTO) {\n\tNDPI_LOG_ERR(ndpi_str, \"nBPF: too many protocols\\n\");\n\treturn(-4); /* Too many protocols */\n      }\n\n      if(filter[0] == '\"') {\n\tu_int len;\n\n\tfilter = &filter[1];\n\tlen = strlen(filter);\n\n\tif(len > 0)\n\t  filter[len-1] = '\\0';\n      }\n\n      if((ndpi_str->nbpf_custom_proto[ndpi_str->num_nbpf_custom_proto].tree =\n\t  nbpf_parse(filter, NULL)) == NULL) {\n\tNDPI_LOG_ERR(ndpi_str, \"nBPF invalid filter: %s\\n\", filter)\n\treturn(-5); /* Invalid filter */\n      } else\n\tndpi_str->nbpf_custom_proto[ndpi_str->num_nbpf_custom_proto].l7_protocol = subprotocol_id;\n\n    ndpi_str->num_nbpf_custom_proto++;\n#else\n      NDPI_LOG_INFO(ndpi_str, \"nDPI compiled without nBPF support: skipping rule\\n\");\n      return(-6);\n#endif\n    }\n\n    if(is_tcp || is_udp) {\n      u_int p_low, p_high;\n      int rc;\n\n      if(sscanf(value, \"%u-%u\", &p_low, &p_high) == 2)\n\trange.port_low = p_low, range.port_high = p_high;\n      else\n\trange.port_low = range.port_high = atoi(&elem[4]);\n\n      if(do_add)\n\trc = addDefaultPort(ndpi_str, &range, def, 1 /* Custom user proto */,\n\t\t       is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot, __FUNCTION__, __LINE__);\n      else\n\trc = removeDefaultPort(&range, def, is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot);\n\n      if(rc != 0) ret = rc;\n    } else if(is_ip) {\n      int rc = ndpi_add_host_ip_subprotocol(ndpi_str, value, subprotocol_id, is_ipv6_ip);\n\n      if(rc != 0)\n\treturn(rc);\n    } else {\n      if(do_add)\n\tndpi_add_host_url_subprotocol(ndpi_str, value, subprotocol_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,\n\t\t\t\t      NDPI_PROTOCOL_ACCEPTABLE, 0);\n      else\n\tndpi_remove_host_url_subprotocol(ndpi_str, value, subprotocol_id);\n    }\n  }\n\n  return(ret);\n}",
        "file_path": "/src/ndpi/src/lib/ndpi_main.c",
        "crashing_line": "      int rc = ndpi_add_host_ip_subprotocol(ndpi_str, value, subprotocol_id, is_ipv6_ip);",
        "crashing_line_number": 4411
      },
      {
        "function_name": "ndpi_load_protocols_file_fd",
        "function_body": "int ndpi_load_protocols_file_fd(struct ndpi_detection_module_struct *ndpi_str, FILE *fd) {\n  char *buffer, *old_buffer;\n  int chunk_len = 1024, buffer_len = chunk_len, old_buffer_len;\n  int i;\n\n  if(!ndpi_str || !fd)\n    return -1;\n\n  buffer = ndpi_malloc(buffer_len);\n  if(buffer == NULL) {\n    NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");\n    return -2;\n  }\n\n  while(1) {\n    char *line = buffer;\n    int line_len = buffer_len;\n\n    while(((line = fgets(line, line_len, fd)) != NULL)\n\t  && strlen(line) > 0\n\t  && (line[strlen(line) - 1] != '\\n')) {\n      i = strlen(line);\n      old_buffer = buffer;\n      old_buffer_len = buffer_len;\n      buffer_len += chunk_len;\n\n      buffer = ndpi_realloc(old_buffer, old_buffer_len, buffer_len);\n      if(buffer == NULL) {\n\tNDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");\n\tndpi_free(old_buffer);\n\treturn -2;\n      }\n\n      line = &buffer[i];\n      line_len = chunk_len;\n    } /* while */\n\n    if(!line) /* safety check */\n      break;\n\n    i = strlen(buffer);\n    if((i <= 1) || (buffer[0] == '#'))\n      continue;\n    else {\n      buffer[i - 1] = '\\0';\n      i--;\n\n      if((i > 0) && (buffer[i-1] == '\\r'))\n\tbuffer[i - 1] = '\\0';\n\n      if(buffer[0] == '\\0')\n\tcontinue;\n    }\n\n    /* printf(\"Processing: \\\"%s\\\"\\n\", buffer); */\n\n    if(ndpi_handle_rule(ndpi_str, buffer, 1) != 0)\n      NDPI_LOG_INFO(ndpi_str, \"Discraded rule '%s'\\n\", buffer);\n  }\n\n  ndpi_free(buffer);\n\n  return 0;\n}",
        "file_path": "/src/ndpi/src/lib/ndpi_main.c",
        "crashing_line": "    if(ndpi_handle_rule(ndpi_str, buffer, 1) != 0)",
        "crashing_line_number": 4901
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void BmffImage::brotliUncompress(const byte* compressedBuf, size_t compressedBufSize, DataBuf& arr) {\n  BrotliDecoderWrapper decoder;\n  size_t uncompressedLen = compressedBufSize * 2;  // just a starting point\n  BrotliDecoderResult result;\n  int dos = 0;\n  size_t available_in = compressedBufSize;\n  const byte* next_in = compressedBuf;\n  size_t available_out;\n  byte* next_out;\n  size_t total_out = 0;\n\n  do {\n    arr.alloc(uncompressedLen);\n    available_out = uncompressedLen - total_out;\n    next_out = arr.data() + total_out;\n    result =\n        BrotliDecoderDecompressStream(decoder.get(), &available_in, &next_in, &available_out, &next_out, &total_out);\n    if (result == BROTLI_DECODER_RESULT_SUCCESS) {\n      arr.resize(total_out);\n    } else if (result == BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT) {\n      uncompressedLen *= 2;\n      // DoS protection - can't be bigger than 128k\n      if (uncompressedLen > 131072) {\n        if (++dos > 1)\n          break;\n        uncompressedLen = 131072;\n      }\n    } else if (result == BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT) {\n      // compressed input buffer in incomplete\n      throw Error(ErrorCode::kerFailedToReadImageData);\n    } else {\n      // something bad happened\n      throw Error(ErrorCode::kerErrorMessage, BrotliDecoderErrorString(BrotliDecoderGetErrorCode(decoder.get())));\n    }\n  } while (result != BROTLI_DECODER_RESULT_SUCCESS);\n\n  if (result != BROTLI_DECODER_RESULT_SUCCESS) {\n    throw Error(ErrorCode::kerFailedToReadImageData);\n  }\n}\n",
    "target": 1,
    "idx": 1061675,
    "stack_trace": [
      {
        "function_name": "brotliUncompress",
        "function_body": "void BmffImage::brotliUncompress(const byte* compressedBuf, size_t compressedBufSize, DataBuf& arr) {\n  BrotliDecoderWrapper decoder;\n  size_t uncompressedLen = compressedBufSize * 2;  // just a starting point\n  BrotliDecoderResult result;\n  int dos = 0;\n  size_t available_in = compressedBufSize;\n  const byte* next_in = compressedBuf;\n  size_t available_out;\n  byte* next_out;\n  size_t total_out = 0;\n\n  do {\n    arr.alloc(uncompressedLen);\n    available_out = uncompressedLen - total_out;\n    next_out = arr.data() + total_out;\n    result =\n        BrotliDecoderDecompressStream(decoder.get(), &available_in, &next_in, &available_out, &next_out, &total_out);\n    if (result == BROTLI_DECODER_RESULT_SUCCESS) {\n      arr.resize(total_out);\n    } else if (result == BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT) {\n      uncompressedLen *= 2;\n      // DoS protection - can't be bigger than 128k\n      if (uncompressedLen > 131072) {\n        if (++dos > 1 || total_out > 131072)\n          break;\n        uncompressedLen = 131072;\n      }\n    } else if (result == BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT) {\n      // compressed input buffer in incomplete\n      throw Error(ErrorCode::kerFailedToReadImageData);\n    } else {\n      // something bad happened\n      throw Error(ErrorCode::kerErrorMessage, BrotliDecoderErrorString(BrotliDecoderGetErrorCode(decoder.get())));\n    }\n  } while (result != BROTLI_DECODER_RESULT_SUCCESS);\n\n  if (result != BROTLI_DECODER_RESULT_SUCCESS) {\n    throw Error(ErrorCode::kerFailedToReadImageData);\n  }\n}",
        "file_path": "/src/exiv2/src/bmffimage.cpp",
        "crashing_line": "        BrotliDecoderDecompressStream(decoder.get(), &available_in, &next_in, &available_out, &next_out, &total_out);",
        "crashing_line_number": 212
      },
      {
        "function_name": "boxHandler",
        "function_body": "uint64_t BmffImage::boxHandler(std::ostream& out /* = std::cout*/, Exiv2::PrintStructureOption option /* = kpsNone */,\n                               uint64_t pbox_end, size_t depth) {\n  const size_t address = io_->tell();\n  // never visit a box twice!\n  if (depth == 0)\n    visits_.clear();\n  if (visits_.find(address) != visits_.end() || visits_.size() > visits_max_) {\n    throw Error(ErrorCode::kerCorruptedMetadata);\n  }\n  visits_.insert(address);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n  bool bTrace = true;\n#else\n  bool bTrace = option == kpsBasic || option == kpsRecursive;\n#endif\n\n  // 8-byte buffer for parsing the box length and type.\n  byte hdrbuf[2 * sizeof(uint32_t)];\n\n  size_t hdrsize = sizeof(hdrbuf);\n  Internal::enforce(hdrsize <= static_cast<size_t>(pbox_end - address), Exiv2::ErrorCode::kerCorruptedMetadata);\n  if (io_->read(hdrbuf, sizeof(hdrbuf)) != sizeof(hdrbuf))\n    return pbox_end;\n\n  // The box length is encoded as a uint32_t by default, but the special value 1 means\n  // that it's a uint64_t.\n  uint64_t box_length = getULong(&hdrbuf[0], endian_);\n  uint32_t box_type = getULong(&hdrbuf[sizeof(uint32_t)], endian_);\n  bool bLF = true;\n\n  if (bTrace) {\n    bLF = true;\n    out << Internal::indent(depth) << \"Exiv2::BmffImage::boxHandler: \" << toAscii(box_type)\n        << Internal::stringFormat(\" %8zd->%\" PRIu64 \" \", address, box_length);\n  }\n\n  if (box_length == 1) {\n    // The box size is encoded as a uint64_t, so we need to read another 8 bytes.\n    hdrsize += 8;\n    Internal::enforce(hdrsize <= static_cast<size_t>(pbox_end - address), Exiv2::ErrorCode::kerCorruptedMetadata);\n    DataBuf data(8);\n    io_->read(data.data(), data.size());\n    box_length = data.read_uint64(0, endian_);\n  }\n\n  if (box_length == 0) {\n    // Zero length is also valid and indicates box extends to the end of file.\n    box_length = pbox_end - address;\n  }\n\n  // read data in box and restore file position\n  const size_t restore = io_->tell();\n  Internal::enforce(box_length >= hdrsize, Exiv2::ErrorCode::kerCorruptedMetadata);\n  Internal::enforce(box_length - hdrsize <= pbox_end - restore, Exiv2::ErrorCode::kerCorruptedMetadata);\n\n  const auto buffer_size = box_length - hdrsize;\n  if (skipBox(box_type)) {\n    if (bTrace) {\n      out << std::endl;\n    }\n    // The enforce() above checks that restore + buffer_size won't\n    // exceed pbox_end, and by implication, won't exceed LONG_MAX\n    return restore + buffer_size;\n  }\n\n  DataBuf data(static_cast<size_t>(buffer_size));\n  const size_t box_end = restore + data.size();\n  io_->read(data.data(), data.size());\n  io_->seek(restore, BasicIo::beg);\n\n  size_t skip = 0;  // read position in data.pData_\n  uint8_t version = 0;\n  uint32_t flags = 0;\n\n  if (fullBox(box_type)) {\n    Internal::enforce(data.size() - skip >= 4, Exiv2::ErrorCode::kerCorruptedMetadata);\n    flags = data.read_uint32(skip, endian_);  // version/flags\n    version = static_cast<uint8_t>(flags >> 24);\n    flags &= 0x00ffffff;\n    skip += 4;\n  }\n\n  switch (box_type) {\n    //  See notes in skipBox()\n    case TAG_ftyp: {\n      Internal::enforce(data.size() >= 4, Exiv2::ErrorCode::kerCorruptedMetadata);\n      fileType_ = data.read_uint32(0, endian_);\n      if (bTrace) {\n        out << \"brand: \" << toAscii(fileType_);\n      }\n    } break;\n\n    // 8.11.6.1\n    case TAG_iinf: {\n      if (bTrace) {\n        out << std::endl;\n        bLF = false;\n      }\n\n      Internal::enforce(data.size() - skip >= 2, Exiv2::ErrorCode::kerCorruptedMetadata);\n      uint16_t n = data.read_uint16(skip, endian_);\n      skip += 2;\n\n      io_->seek(skip, BasicIo::cur);\n      while (n-- > 0) {\n        io_->seek(boxHandler(out, option, box_end, depth + 1), BasicIo::beg);\n      }\n    } break;\n\n    // 8.11.6.2\n    case TAG_infe: {  // .__._.__hvc1_ 2 0 0 1 0 1 0 0 104 118 99 49 0\n      Internal::enforce(data.size() - skip >= 8, Exiv2::ErrorCode::kerCorruptedMetadata);\n      /* getULong (data.pData_+skip,endian_) ; */ skip += 4;\n      uint16_t ID = data.read_uint16(skip, endian_);\n      skip += 2;\n      /* getShort(data.pData_+skip,endian_) ; */ skip += 2;  // protection\n      std::string id;\n      // Check that the string has a '\\0' terminator.\n      const char* str = data.c_str(skip);\n      const size_t maxlen = data.size() - skip;\n      Internal::enforce(maxlen > 0 && strnlen(str, maxlen) < maxlen, Exiv2::ErrorCode::kerCorruptedMetadata);\n      std::string name(str);\n      if (Internal::contains(name, \"Exif\")) {  // \"Exif\" or \"ExifExif\"\n        exifID_ = ID;\n        id = \" *** Exif ***\";\n      } else if (Internal::contains(name, \"mime\\0xmp\") || Internal::contains(name, \"mime\\0application/rdf+xml\")) {\n        xmpID_ = ID;\n        id = \" *** XMP ***\";\n      }\n      if (bTrace) {\n        out << Internal::stringFormat(\"ID = %3d \", ID) << name << \" \" << id;\n      }\n    } break;\n\n    case TAG_moov:\n    case TAG_iprp:\n    case TAG_ipco:\n    case TAG_meta: {\n      if (bTrace) {\n        out << std::endl;\n        bLF = false;\n      }\n      io_->seek(skip, BasicIo::cur);\n      while (io_->tell() < box_end) {\n        io_->seek(boxHandler(out, option, box_end, depth + 1), BasicIo::beg);\n      }\n      // post-process meta box to recover Exif and XMP\n      if (box_type == TAG_meta) {\n        if (ilocs_.find(exifID_) != ilocs_.end()) {\n          const Iloc& iloc = ilocs_.find(exifID_)->second;\n          if (bTrace) {\n            out << Internal::indent(depth) << \"Exiv2::BMFF Exif: \" << iloc.toString() << std::endl;\n          }\n          parseTiff(Internal::Tag::root, iloc.length_, iloc.start_);\n        }\n        if (ilocs_.find(xmpID_) != ilocs_.end()) {\n          const Iloc& iloc = ilocs_.find(xmpID_)->second;\n          if (bTrace) {\n            out << Internal::indent(depth) << \"Exiv2::BMFF XMP: \" << iloc.toString() << std::endl;\n          }\n          parseXmp(iloc.length_, iloc.start_);\n        }\n        ilocs_.clear();\n      }\n    } break;\n\n    // 8.11.3.1\n    case TAG_iloc: {\n      Internal::enforce(data.size() - skip >= 2, Exiv2::ErrorCode::kerCorruptedMetadata);\n      uint8_t u = data.read_uint8(skip++);\n      uint16_t offsetSize = u >> 4;\n      uint16_t lengthSize = u & 0xF;\n#if 0\n                uint16_t indexSize  = 0       ;\n                u             = data.read_uint8(skip++);\n                if ( version == 1 || version == 2 ) {\n                    indexSize = u & 0xF ;\n                }\n#else\n      skip++;\n#endif\n      Internal::enforce(data.size() - skip >= (version < 2u ? 2u : 4u), Exiv2::ErrorCode::kerCorruptedMetadata);\n      uint32_t itemCount = version < 2 ? data.read_uint16(skip, endian_) : data.read_uint32(skip, endian_);\n      skip += version < 2 ? 2 : 4;\n      if (itemCount && itemCount < box_length / 14 && offsetSize == 4 && lengthSize == 4 &&\n          ((box_length - 16) % itemCount) == 0) {\n        if (bTrace) {\n          out << std::endl;\n          bLF = false;\n        }\n        auto step = (static_cast<size_t>(box_length) - 16) / itemCount;  // length of data per item.\n        size_t base = skip;\n        for (uint32_t i = 0; i < itemCount; i++) {\n          skip = base + i * step;  // move in 14, 16 or 18 byte steps\n          Internal::enforce(data.size() - skip >= (version > 2u ? 4u : 2u), Exiv2::ErrorCode::kerCorruptedMetadata);\n          Internal::enforce(data.size() - skip >= step, Exiv2::ErrorCode::kerCorruptedMetadata);\n          uint32_t ID = version > 2 ? data.read_uint32(skip, endian_) : data.read_uint16(skip, endian_);\n          auto offset = [&data, skip, step] {\n            if (step == 14 || step == 16)\n              return data.read_uint32(skip + step - 8, endian_);\n            if (step == 18)\n              return data.read_uint32(skip + 4, endian_);\n            return 0u;\n          }();\n\n          uint32_t ldata = data.read_uint32(skip + step - 4, endian_);\n          if (bTrace) {\n            out << Internal::indent(depth)\n                << Internal::stringFormat(\"%8zd | %8zd |   ID | %4u | %6u,%6u\", address + skip, step, ID, offset, ldata)\n                << std::endl;\n          }\n          // save data for post-processing in meta box\n          if (offset && ldata && ID != unknownID_) {\n            ilocs_[ID] = Iloc{ID, offset, ldata};\n          }\n        }\n      }\n    } break;\n\n    case TAG_ispe: {\n      Internal::enforce(data.size() - skip >= 12, Exiv2::ErrorCode::kerCorruptedMetadata);\n      skip += 4;\n      uint32_t width = data.read_uint32(skip, endian_);\n      skip += 4;\n      uint32_t height = data.read_uint32(skip, endian_);\n      skip += 4;\n      if (bTrace) {\n        out << \"pixelWidth_, pixelHeight_ = \" << Internal::stringFormat(\"%d, %d\", width, height);\n      }\n      // HEIC files can have multiple ispe records\n      // Store largest width/height\n      if (width > pixelWidth_ && height > pixelHeight_) {\n        pixelWidth_ = width;\n        pixelHeight_ = height;\n      }\n    } break;\n\n    // 12.1.5.2\n    case TAG_colr: {\n      if (data.size() >= (skip + 4 + 8)) {  // .____.HLino..__mntrR 2 0 0 0 0 12 72 76 105 110 111 2 16 ...\n        // https://www.ics.uci.edu/~dan/class/267/papers/jpeg2000.pdf\n        uint8_t meth = data.read_uint8(skip + 0);\n        uint8_t prec = data.read_uint8(skip + 1);\n        uint8_t approx = data.read_uint8(skip + 2);\n        auto colour_type = std::string(data.c_str(), 4);\n        skip += 4;\n        if (colour_type == \"rICC\" || colour_type == \"prof\") {\n          DataBuf profile(data.c_data(skip), data.size() - skip);\n          setIccProfile(std::move(profile));\n        } else if (meth == 2 && prec == 0 && approx == 0) {\n          // JP2000 files have a 3 byte head // 2 0 0 icc......\n          skip -= 1;\n          DataBuf profile(data.c_data(skip), data.size() - skip);\n          setIccProfile(std::move(profile));\n        }\n      }\n    } break;\n\n    case TAG_uuid: {\n      DataBuf uuid(16);\n      io_->read(uuid.data(), uuid.size());\n      std::string name = uuidName(uuid);\n      if (bTrace) {\n        out << \" uuidName \" << name << std::endl;\n        bLF = false;\n      }\n      if (name == \"cano\" || name == \"canp\") {\n        if (name == \"canp\") {\n          // based on\n          // https://github.com/lclevy/canon_cr3/blob/7be75d6/parse_cr3.py#L271\n          io_->seek(8, BasicIo::cur);\n        }\n        while (io_->tell() < box_end) {\n          io_->seek(boxHandler(out, option, box_end, depth + 1), BasicIo::beg);\n        }\n      } else if (name == \"xmp\") {\n        parseXmp(box_length, io_->tell());\n      }\n    } break;\n\n    case TAG_cmt1:\n      parseTiff(Internal::Tag::root, box_length);\n      break;\n    case TAG_cmt2:\n      parseTiff(Internal::Tag::cmt2, box_length);\n      break;\n    case TAG_cmt3:\n      parseTiff(Internal::Tag::cmt3, box_length);\n      break;\n    case TAG_cmt4:\n      parseTiff(Internal::Tag::cmt4, box_length);\n      break;\n    case TAG_exif:\n      parseTiff(Internal::Tag::root, buffer_size, io_->tell());\n      break;\n    case TAG_xml:\n      parseXmp(buffer_size, io_->tell());\n      break;\n    case TAG_brob: {\n      Internal::enforce(data.size() >= 4, Exiv2::ErrorCode::kerCorruptedMetadata);\n      uint32_t realType = data.read_uint32(0, endian_);\n      if (bTrace) {\n        out << \"type: \" << toAscii(realType);\n      }\n#ifdef EXV_HAVE_BROTLI\n      DataBuf arr;\n      brotliUncompress(data.c_data(4), data.size() - 4, arr);\n      if (realType == TAG_exif) {\n        uint32_t offset = Safe::add(arr.read_uint32(0, endian_), 4u);\n        Internal::enforce(Safe::add(offset, 4u) < arr.size(), Exiv2::ErrorCode::kerCorruptedMetadata);\n        Internal::TiffParserWorker::decode(exifData(), iptcData(), xmpData(), arr.c_data(offset), arr.size() - offset,\n                                           Internal::Tag::root, Internal::TiffMapping::findDecoder);\n      } else if (realType == TAG_xml) {\n        try {\n          Exiv2::XmpParser::decode(xmpData(), std::string(arr.c_str(), arr.size()));\n        } catch (...) {\n          throw Error(ErrorCode::kerFailedToReadImageData);\n        }\n      }\n#endif\n    } break;\n    case TAG_thmb:\n      switch (version) {\n        case 0:  // JPEG\n          parseCr3Preview(data, out, bTrace, version, skip, skip + 2, skip + 4, skip + 12);\n          break;\n        case 1:  // HDR\n          parseCr3Preview(data, out, bTrace, version, skip + 2, skip + 4, skip + 8, skip + 12);\n          break;\n        default:\n          break;\n      }\n      break;\n    case TAG_prvw:\n      switch (version) {\n        case 0:  // JPEG\n        case 1:  // HDR\n          parseCr3Preview(data, out, bTrace, version, skip + 2, skip + 4, skip + 8, skip + 12);\n          break;\n        default:\n          break;\n      }\n      break;\n\n    default:\n      break; /* do nothing */\n  }\n  if (bLF && bTrace)\n    out << std::endl;\n\n  // return address of next box\n  return box_end;\n}",
        "file_path": "/src/exiv2/src/bmffimage.cpp",
        "crashing_line": "      brotliUncompress(data.c_data(4), data.size() - 4, arr);",
        "crashing_line_number": 545
      },
      {
        "function_name": "readMetadata",
        "function_body": "void BmffImage::readMetadata() {\n  openOrThrow();\n  IoCloser closer(*io_);\n\n  clearMetadata();\n  ilocs_.clear();\n  visits_max_ = io_->size() / 16;\n  unknownID_ = 0xffff;\n  exifID_ = unknownID_;\n  xmpID_ = unknownID_;\n\n  uint64_t address = 0;\n  const auto file_end = io_->size();\n  while (address < file_end) {\n    io_->seek(address, BasicIo::beg);\n    address = boxHandler(std::cout, kpsNone, file_end, 0);\n  }\n  bReadMetadata_ = true;\n}  // BmffImage::readMetadata",
        "file_path": "/src/exiv2/src/bmffimage.cpp",
        "crashing_line": "    address = boxHandler(std::cout, kpsNone, file_end, 0);",
        "crashing_line_number": 731
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int flb_http_do(struct flb_http_client *c, size_t *bytes)\n{\n    int ret;\n    int r_bytes;\n    int crlf = 2;\n    int new_size;\n    ssize_t available;\n    size_t out_size;\n    size_t bytes_header = 0;\n    size_t bytes_body = 0;\n    char *tmp;\n\n    /* Append pending headers */\n    ret = http_headers_compose(c);\n    if (ret == -1) {\n        return -1;\n    }\n\n    /* check enough space for the ending CRLF */\n    if (header_available(c, crlf) != 0) {\n        new_size = c->header_size + 2;\n        tmp = flb_realloc(c->header_buf, new_size);\n        if (!tmp) {\n            return -1;\n        }\n        c->header_buf = tmp;\n        c->header_len = new_size;\n    }\n\n    /* Append the ending header CRLF */\n    c->header_buf[c->header_len++] = '\\r';\n    c->header_buf[c->header_len++] = '\\n';\n\n#ifdef FLB_HAVE_HTTP_CLIENT_DEBUG\n    /* debug: request_headers callback */\n    flb_http_client_debug_cb(c, \"_debug.http.request_headers\");\n\n    /* debug: request_payload callback */\n    if (c->body_len > 0) {\n        flb_http_client_debug_cb(c, \"_debug.http.request_payload\");\n    }\n#endif\n\n    flb_debug(\"[http_client] header=%s\", c->header_buf);\n    /* Write the header */\n    ret = flb_io_net_write(c->u_conn,\n                           c->header_buf, c->header_len,\n                           &bytes_header);\n    if (ret == -1) {\n        /* errno might be changed from the original call */\n        if (errno != 0) {\n            flb_errno();\n        }\n        return -1;\n    }\n\n    if (c->body_len > 0) {\n        ret = flb_io_net_write(c->u_conn,\n                               c->body_buf, c->body_len,\n                               &bytes_body);\n        if (ret == -1) {\n            flb_errno();\n            return -1;\n        }\n    }\n\n    /* number of sent bytes */\n    *bytes = (bytes_header + bytes_body);\n\n    /* Read the server response, we need at least 19 bytes */\n    c->resp.data_len = 0;\n    while (1) {\n        available = flb_http_buffer_available(c) - 1;\n        if (available <= 1) {\n            /*\n             * If there is no more space available on our buffer, try to\n             * increase it.\n             */\n            ret = flb_http_buffer_increase(c, FLB_HTTP_DATA_CHUNK,\n                                           &out_size);\n            if (ret == -1) {\n                /*\n                 * We could not allocate more space, let the caller handle\n                 * this.\n                 */\n                flb_upstream_conn_recycle(c->u_conn, FLB_FALSE);\n                return 0;\n            }\n            available = flb_http_buffer_available(c) - 1;\n        }\n\n        r_bytes = flb_io_net_read(c->u_conn,\n                                  c->resp.data + c->resp.data_len,\n                                  available);\n        if (r_bytes <= 0) {\n            if (c->flags & FLB_HTTP_10) {\n                break;\n            }\n        }\n\n        /* Always append a NULL byte */\n        if (r_bytes >= 0) {\n            c->resp.data_len += r_bytes;\n            c->resp.data[c->resp.data_len] = '\\0';\n\n            ret = process_data(c);\n            if (ret == FLB_HTTP_ERROR) {\n                return -1;\n            }\n            else if (ret == FLB_HTTP_OK) {\n                break;\n            }\n            else if (ret == FLB_HTTP_MORE) {\n                continue;\n            }\n        }\n        else {\n            flb_error(\"[http_client] broken connection to %s:%i ?\",\n                      c->u_conn->u->tcp_host, c->u_conn->u->tcp_port);\n            return -1;\n        }\n    }\n\n    /* Check 'Connection' response header */\n    ret = check_connection(c);\n    if (ret == FLB_HTTP_OK) {\n        /*\n         * If the server replied that the connection will be closed\n         * and our Upstream connection is in keepalive mode, we must\n         * inactivate the connection.\n         */\n        if (c->resp.connection_close == FLB_TRUE) {\n            /* Do not recycle the connection (no more keepalive) */\n            flb_upstream_conn_recycle(c->u_conn, FLB_FALSE);\n            flb_debug(\"[http_client] server %s:%i will close connection #%i\",\n                      c->u_conn->u->tcp_host, c->u_conn->u->tcp_port,\n                      c->u_conn->fd);\n        }\n    }\n\n#ifdef FLB_HAVE_HTTP_CLIENT_DEBUG\n    flb_http_client_debug_cb(c, \"_debug.http.response_headers\");\n    if (c->resp.payload_size > 0) {\n        flb_http_client_debug_cb(c, \"_debug.http.response_payload\");\n    }\n#endif\n\n    return 0;\n}\n",
    "target": 1,
    "idx": 1028256,
    "stack_trace": [
      {
        "function_name": "flb_http_do",
        "function_body": "int flb_http_do(struct flb_http_client *c, size_t *bytes)\n{\n    int ret;\n    int r_bytes;\n    int crlf = 2;\n    int new_size;\n    ssize_t available;\n    size_t out_size;\n    size_t bytes_header = 0;\n    size_t bytes_body = 0;\n    char *tmp;\n\n    /* Append pending headers */\n    ret = http_headers_compose(c);\n    if (ret == -1) {\n        return -1;\n    }\n\n    /* check enough space for the ending CRLF */\n    if (header_available(c, crlf) != 0) {\n        new_size = c->header_size + 2;\n        tmp = flb_realloc(c->header_buf, new_size);\n        if (!tmp) {\n            return -1;\n        }\n        c->header_buf  = tmp;\n        c->header_size = new_size;\n    }\n\n    /* Append the ending header CRLF */\n    c->header_buf[c->header_len++] = '\\r';\n    c->header_buf[c->header_len++] = '\\n';\n\n#ifdef FLB_HAVE_HTTP_CLIENT_DEBUG\n    /* debug: request_headers callback */\n    flb_http_client_debug_cb(c, \"_debug.http.request_headers\");\n\n    /* debug: request_payload callback */\n    if (c->body_len > 0) {\n        flb_http_client_debug_cb(c, \"_debug.http.request_payload\");\n    }\n#endif\n\n    flb_debug(\"[http_client] header=%s\", c->header_buf);\n    /* Write the header */\n    ret = flb_io_net_write(c->u_conn,\n                           c->header_buf, c->header_len,\n                           &bytes_header);\n    if (ret == -1) {\n        /* errno might be changed from the original call */\n        if (errno != 0) {\n            flb_errno();\n        }\n        return -1;\n    }\n\n    if (c->body_len > 0) {\n        ret = flb_io_net_write(c->u_conn,\n                               c->body_buf, c->body_len,\n                               &bytes_body);\n        if (ret == -1) {\n            flb_errno();\n            return -1;\n        }\n    }\n\n    /* number of sent bytes */\n    *bytes = (bytes_header + bytes_body);\n\n    /* Read the server response, we need at least 19 bytes */\n    c->resp.data_len = 0;\n    while (1) {\n        available = flb_http_buffer_available(c) - 1;\n        if (available <= 1) {\n            /*\n             * If there is no more space available on our buffer, try to\n             * increase it.\n             */\n            ret = flb_http_buffer_increase(c, FLB_HTTP_DATA_CHUNK,\n                                           &out_size);\n            if (ret == -1) {\n                /*\n                 * We could not allocate more space, let the caller handle\n                 * this.\n                 */\n                flb_upstream_conn_recycle(c->u_conn, FLB_FALSE);\n                return 0;\n            }\n            available = flb_http_buffer_available(c) - 1;\n        }\n\n        r_bytes = flb_io_net_read(c->u_conn,\n                                  c->resp.data + c->resp.data_len,\n                                  available);\n        if (r_bytes <= 0) {\n            if (c->flags & FLB_HTTP_10) {\n                break;\n            }\n        }\n\n        /* Always append a NULL byte */\n        if (r_bytes >= 0) {\n            c->resp.data_len += r_bytes;\n            c->resp.data[c->resp.data_len] = '\\0';\n\n            ret = process_data(c);\n            if (ret == FLB_HTTP_ERROR) {\n                return -1;\n            }\n            else if (ret == FLB_HTTP_OK) {\n                break;\n            }\n            else if (ret == FLB_HTTP_MORE) {\n                continue;\n            }\n        }\n        else {\n            flb_error(\"[http_client] broken connection to %s:%i ?\",\n                      c->u_conn->u->tcp_host, c->u_conn->u->tcp_port);\n            return -1;\n        }\n    }\n\n    /* Check 'Connection' response header */\n    ret = check_connection(c);\n    if (ret == FLB_HTTP_OK) {\n        /*\n         * If the server replied that the connection will be closed\n         * and our Upstream connection is in keepalive mode, we must\n         * inactivate the connection.\n         */\n        if (c->resp.connection_close == FLB_TRUE) {\n            /* Do not recycle the connection (no more keepalive) */\n            flb_upstream_conn_recycle(c->u_conn, FLB_FALSE);\n            flb_debug(\"[http_client] server %s:%i will close connection #%i\",\n                      c->u_conn->u->tcp_host, c->u_conn->u->tcp_port,\n                      c->u_conn->fd);\n        }\n    }\n\n#ifdef FLB_HAVE_HTTP_CLIENT_DEBUG\n    flb_http_client_debug_cb(c, \"_debug.http.response_headers\");\n    if (c->resp.payload_size > 0) {\n        flb_http_client_debug_cb(c, \"_debug.http.response_payload\");\n    }\n#endif\n\n    return 0;\n}",
        "file_path": "/src/fluent-bit/src/flb_http_client.c",
        "crashing_line": "    c->header_buf[c->header_len++] = '\\r';",
        "crashing_line_number": 1130
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int msc_partial_update_object(sc_card_t *card, msc_id objectId, int offset, const u8 *data, size_t dataLength)\n{\n\tu8 buffer[MSC_MAX_APDU];\n\tsc_apdu_t apdu;\n\tint r;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x54, 0x00, 0x00);\n\tapdu.lc = dataLength + 9;\n\tif (card->ctx->debug >= 2)\n\t\tsc_log(card->ctx, \n\t\t\t \"WRITE: Offset: %x\\tLength: %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t\t offset, dataLength);\n\t\n\tmemcpy(buffer, objectId.id, 4);\n\tulong2bebytes(buffer + 4, offset);\n\tbuffer[8] = (u8)dataLength;\n\tmemcpy(buffer + 9, data, dataLength);\n\tapdu.data = buffer;\n\tapdu.datalen = apdu.lc;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif(apdu.sw1 == 0x90 && apdu.sw2 == 0x00)\n\t\treturn dataLength;\n\tif(apdu.sw1 == 0x9C) {\n\t\tif(apdu.sw2 == 0x07) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_FILE_NOT_FOUND);\n\t\t} else if(apdu.sw2 == 0x06) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_NOT_ALLOWED);\n\t\t} else if(apdu.sw2 == 0x0F) {\n\t\t\t/* GUESSED */\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t\t}\n\t}\n\tif (card->ctx->debug >= 2) {\n\t\tsc_log(card->ctx,  \"got strange SWs: 0x%02X 0x%02X\\n\",\n\t\t     apdu.sw1, apdu.sw2);\n\t}\n\treturn dataLength;\n}\n",
    "target": 1,
    "idx": 1054312,
    "stack_trace": [
      {
        "function_name": "msc_partial_update_object",
        "function_body": "int msc_partial_update_object(sc_card_t *card, msc_id objectId, int offset, const u8 *data, size_t dataLength)\n{\n\tu8 buffer[MSC_MAX_APDU];\n\tsc_apdu_t apdu;\n\tint r;\n\n\tif (dataLength + 9 > MSC_MAX_APDU)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x54, 0x00, 0x00);\n\tapdu.lc = dataLength + 9;\n\tif (card->ctx->debug >= 2)\n\t\tsc_log(card->ctx, \n\t\t\t \"WRITE: Offset: %x\\tLength: %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t\t offset, dataLength);\n\t\n\tmemcpy(buffer, objectId.id, 4);\n\tulong2bebytes(buffer + 4, offset);\n\tbuffer[8] = (u8)dataLength;\n\tmemcpy(buffer + 9, data, dataLength);\n\tapdu.data = buffer;\n\tapdu.datalen = apdu.lc;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif(apdu.sw1 == 0x90 && apdu.sw2 == 0x00)\n\t\treturn dataLength;\n\tif(apdu.sw1 == 0x9C) {\n\t\tif(apdu.sw2 == 0x07) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_FILE_NOT_FOUND);\n\t\t} else if(apdu.sw2 == 0x06) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_NOT_ALLOWED);\n\t\t} else if(apdu.sw2 == 0x0F) {\n\t\t\t/* GUESSED */\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t\t}\n\t}\n\tif (card->ctx->debug >= 2) {\n\t\tsc_log(card->ctx,  \"got strange SWs: 0x%02X 0x%02X\\n\",\n\t\t     apdu.sw1, apdu.sw2);\n\t}\n\treturn dataLength;\n}",
        "file_path": "/src/opensc/src/libopensc/muscle.c",
        "crashing_line": "\tmemcpy(buffer, objectId.id, 4);",
        "crashing_line_number": 194
      },
      {
        "function_name": "msc_zero_object",
        "function_body": "int msc_zero_object(sc_card_t *card, msc_id objectId, size_t dataLength)\n{\n\tu8 zeroBuffer[MSC_MAX_APDU];\n\tsize_t i;\n\tsize_t max_write_unit = MIN(MSC_MAX_APDU, MSC_MAX_SEND - 9); /* - 9 for object ID+length */\n\n\tmemset(zeroBuffer, 0, max_write_unit);\n\tfor(i = 0; i < dataLength; i += max_write_unit) {\n\t\tint r = msc_partial_update_object(card, objectId, i, zeroBuffer, MIN(dataLength - i, max_write_unit));\n\t\tLOG_TEST_RET(card->ctx, r, \"Error in zeroing file update\");\n\t}\n\treturn 0;\n}",
        "file_path": "/src/opensc/src/libopensc/muscle.c",
        "crashing_line": "\t\tint r = msc_partial_update_object(card, objectId, i, zeroBuffer, MIN(dataLength - i, max_write_unit));",
        "crashing_line_number": 134
      },
      {
        "function_name": "msc_create_object",
        "function_body": "int msc_create_object(sc_card_t *card, msc_id objectId, size_t objectSize, unsigned short readAcl, unsigned short writeAcl, unsigned short deleteAcl)\n{\n\tu8 buffer[14];\n\tsc_apdu_t apdu;\n\tint r;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x5A, 0x00, 0x00);\n\tapdu.lc = 14;\n\tapdu.data = buffer,\n\tapdu.datalen = 14;\n\t\n\tmemcpy(buffer, objectId.id, 4);\n\tulong2bebytes(buffer + 4, objectSize);\n\tushort2bebytes(buffer + 8, readAcl);\n\tushort2bebytes(buffer + 10, writeAcl);\n\tushort2bebytes(buffer + 12, deleteAcl);\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif(apdu.sw1 == 0x90 && apdu.sw2 == 0x00)\n\t\treturn objectSize;\n\tif(apdu.sw1 == 0x9C) {\n\t\tif(apdu.sw2 == 0x01) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_MEMORY_FAILURE);\n\t\t} else if(apdu.sw2 == 0x08) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_FILE_ALREADY_EXISTS);\n\t\t} else if(apdu.sw2 == 0x06) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_NOT_ALLOWED);\n\t\t}\n\t}\n\tif (card->ctx->debug >= 2) {\n\t\tsc_log(card->ctx,  \"got strange SWs: 0x%02X 0x%02X\\n\",\n\t\t     apdu.sw1, apdu.sw2);\n\t}\n\tmsc_zero_object(card, objectId, objectSize);\n\treturn objectSize;\n}",
        "file_path": "/src/opensc/src/libopensc/muscle.c",
        "crashing_line": "\tmsc_zero_object(card, objectId, objectSize);",
        "crashing_line_number": 173
      },
      {
        "function_name": "muscle_create_directory",
        "function_body": "static int muscle_create_directory(sc_card_t *card, sc_file_t *file)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmsc_id objectId;\n\tu8* oid = objectId.id;\n\tunsigned id = file->id;\n\tunsigned short read_perm = 0, write_perm = 0, delete_perm = 0;\n\tint objectSize;\n\tint r;\n\tif(id == 0) /* No null name files */\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\t/* No nesting directories */\n\tif(fs->currentPath[0] != 0x3F || fs->currentPath[1] != 0x00)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\toid[0] = ((id & 0xFF00) >> 8) & 0xFF;\n\toid[1] = id & 0xFF;\n\toid[2] = oid[3] = 0;\n\n\tobjectSize = file->size;\n\n\tmuscle_parse_acls(file, &read_perm, &write_perm, &delete_perm);\n\tr = msc_create_object(card, objectId, objectSize, read_perm, write_perm, delete_perm);\n\tmscfs_clear_cache(fs);\n\tif(r >= 0) return 0;\n\treturn r;\n}",
        "file_path": "/src/opensc/src/libopensc/card-muscle.c",
        "crashing_line": "\tr = msc_create_object(card, objectId, objectSize, read_perm, write_perm, delete_perm);",
        "crashing_line_number": 171
      },
      {
        "function_name": "muscle_create_file",
        "function_body": "static int muscle_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tint objectSize = file->size;\n\tunsigned short read_perm = 0, write_perm = 0, delete_perm = 0;\n\tmsc_id objectId;\n\tint r;\n\tif(file->type == SC_FILE_TYPE_DF)\n\t\treturn muscle_create_directory(card, file);\n\tif(file->type != SC_FILE_TYPE_WORKING_EF)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\tif(file->id == 0) /* No null name files */\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tmuscle_parse_acls(file, &read_perm, &write_perm, &delete_perm);\n\n\tmscfs_lookup_local(fs, file->id, &objectId);\n\tr = msc_create_object(card, objectId, objectSize, read_perm, write_perm, delete_perm);\n\tmscfs_clear_cache(fs);\n\tif(r >= 0) return 0;\n\treturn r;\n}",
        "file_path": "/src/opensc/src/libopensc/card-muscle.c",
        "crashing_line": "\t\treturn muscle_create_directory(card, file);",
        "crashing_line_number": 186
      },
      {
        "function_name": "sc_create_file",
        "function_body": "int sc_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tint r;\n\tchar pbuf[SC_MAX_PATH_STRING_SIZE];\n\tconst sc_path_t *in_path;\n\n\tif (card == NULL || file == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tin_path = &file->path;\n\tr = sc_path_print(pbuf, sizeof(pbuf), in_path);\n\tif (r != SC_SUCCESS)\n\t\tpbuf[0] = '\\0';\n\n\tsc_log(card->ctx,\n\t       \"called; type=%d, path=%s, id=%04i, size=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_path->type, pbuf, file->id, file->size);\n\t/* ISO 7816-4: \"Number of data bytes in the file, including structural information if any\"\n\t * can not be bigger than two bytes */\n\tif (file->size > 0xFFFF)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tif (card->ops->create_file == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tr = card->ops->create_file(card, file);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}",
        "file_path": "/src/opensc/src/libopensc/card.c",
        "crashing_line": "\tr = card->ops->create_file(card, file);",
        "crashing_line_number": 601
      },
      {
        "function_name": "sc_pkcs15init_create_file",
        "function_body": "int\nsc_pkcs15init_create_file(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_file *file)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file\t*parent = NULL;\n\tint\t\tr;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!file) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tsc_log(ctx, \"create file '%s'\", sc_print_path(&file->path));\n\t/* Select parent DF and verify PINs/key as necessary */\n\tr = do_select_parent(profile, p15card, file, &parent);\n\tLOG_TEST_RET(ctx, r, \"Cannot create file: select parent error\");\n\n\tr = sc_pkcs15init_authenticate(profile, p15card, parent, SC_AC_OP_CREATE);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Cannot create file: 'CREATE' authentication failed\");\n\n\t/* Fix up the file's ACLs */\n\tr = sc_pkcs15init_fixup_file(profile, p15card, file);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Cannot create file: file fixup failed\");\n\n\t/* ensure we are in the correct lifecycle */\n\tr = sc_pkcs15init_set_lifecycle(p15card->card, SC_CARDCTRL_LIFECYCLE_ADMIN);\n\tif (r != SC_ERROR_NOT_SUPPORTED)\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Cannot create file: failed to set lifecycle 'ADMIN'\");\n\n\tr = sc_create_file(p15card->card, file);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Create file failed\");\n\nerr:\n\tsc_file_free(parent);\n\tLOG_FUNC_RETURN(ctx, r);\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/pkcs15-lib.c",
        "crashing_line": "\tr = sc_create_file(p15card->card, file);",
        "crashing_line_number": 4104
      },
      {
        "function_name": "muscle_create_dir",
        "function_body": "static int\nmuscle_create_dir(sc_profile_t *profile, sc_pkcs15_card_t *p15card, sc_file_t *df)\n{\n\tint\tr;\n\tstruct sc_file *file;\n\tstruct sc_path path;\n\tmemset(&file, 0, sizeof(file));\n\tsc_format_path(\"3F00\", &path);\n\tif ((r = sc_select_file(p15card->card, &path, &file)) < 0)\n\t\treturn r;\n\tif ((r = sc_pkcs15init_authenticate(profile, p15card, file, SC_AC_OP_CREATE)) < 0) {\n\t\tsc_file_free(file);\n\t\treturn r;\n\t}\n\tsc_file_free(file);\n\n\t/* Create the application DF */\n\tif ((r = sc_pkcs15init_create_file(profile, p15card, df)) < 0)\n\t\treturn r;\n\n\tif ((r = sc_select_file(p15card->card, &df->path, NULL)) < 0)\n\t\treturn r;\n\n\n\treturn 0;\n}",
        "file_path": "/src/opensc/src/pkcs15init/pkcs15-muscle.c",
        "crashing_line": "\tif ((r = sc_pkcs15init_create_file(profile, p15card, df)) < 0)",
        "crashing_line_number": 85
      },
      {
        "function_name": "sc_pkcs15init_add_app",
        "function_body": "int\nsc_pkcs15init_add_app(struct sc_card *card, struct sc_profile *profile,\n\t\tstruct sc_pkcs15init_initargs *args)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pkcs15_card\t*p15card = profile->p15_spec;\n\tstruct sc_pkcs15_auth_info pin_ainfo, puk_ainfo;\n\tstruct sc_pkcs15_pin_attributes *pin_attrs = &pin_ainfo.attrs.pin;\n\tstruct sc_pkcs15_object\t*pin_obj = NULL;\n\tstruct sc_app_info\t*app;\n\tstruct sc_file\t\t*df = profile->df_info->file;\n\tint\t\t\tr = SC_SUCCESS;\n\tint\t\t\thas_so_pin = args->so_pin_len != 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\tp15card->card = card;\n\n\t/* FIXME:\n\t * Some cards need pincache\n\t *  for ex. to create temporary CHV key with the value of default AUTH key.\n\t */\n\tp15card->opts.use_pin_cache = 1;\n\n\tif (card->app_count >= SC_MAX_CARD_APPS)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_TOO_MANY_OBJECTS, \"Too many applications on this card.\");\n\n\t/* In case of pinpad readers check if SO PIN is defined in a profile */\n\tif (!has_so_pin && (card->reader->capabilities & SC_READER_CAP_PIN_PAD)) {\n\t\tsc_profile_get_pin_info(profile, SC_PKCS15INIT_SO_PIN, &pin_ainfo);\n\t\t/* If found, assume we want SO PIN */\n\t\thas_so_pin = pin_ainfo.attrs.pin.reference != -1;\n\t}\n\n\t/* If the profile requires an SO PIN, check min/max length */\n\tif (has_so_pin) {\n\t\tconst char\t*pin_label;\n\n\t\tif (args->so_pin_len) {\n\t\t\tsc_profile_get_pin_info(profile, SC_PKCS15INIT_SO_PIN, &pin_ainfo);\n\t\t\tr = sc_pkcs15init_qualify_pin(card, \"SO PIN\", args->so_pin_len, &pin_ainfo);\n\t\t\tLOG_TEST_RET(ctx, r, \"Failed to qualify SO PIN\");\n\t\t}\n\n\t\t/* Path encoded only for local SO PIN */\n\t\tif (pin_attrs->flags & SC_PKCS15_PIN_FLAG_LOCAL)\n\t\t\tpin_ainfo.path = df->path;\n\n\t\t/* Select the PIN reference */\n\t\tif (profile->ops->select_pin_reference) {\n\t\t\tr = profile->ops->select_pin_reference(profile, p15card, &pin_ainfo);\n\t\t\tLOG_TEST_RET(ctx, r, \"Failed to select card specific PIN reference\");\n\t\t}\n\n\t\tsc_profile_get_pin_info(profile, SC_PKCS15INIT_SO_PUK, &puk_ainfo);\n\t\tr = sc_pkcs15init_qualify_pin(card, \"SO PUK\", args->so_puk_len, &puk_ainfo);\n\t\tLOG_TEST_RET(ctx, r, \"Failed to qualify SO PUK\");\n\n\t\tif (!(pin_label = args->so_pin_label)) {\n\t\t\tif (pin_attrs->flags & SC_PKCS15_PIN_FLAG_SO_PIN)\n\t\t\t\tpin_label = \"Security Officer PIN\";\n\t\t\telse\n\t\t\t\tpin_label = \"User PIN\";\n\t\t}\n\n\t\tif (args->so_puk_len == 0)\n\t\t\tpin_attrs->flags |= SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED;\n\n\t\tpin_obj = sc_pkcs15init_new_object(SC_PKCS15_TYPE_AUTH_PIN, pin_label, NULL, &pin_ainfo);\n\t\tif (pin_obj)   {\n\t\t\t/* When composing ACLs to create 'DIR' DF,\n\t\t\t *\tthe references of the not-yet-existing PINs can be requested.\n\t\t\t * For this, create a 'virtual' AUTH object 'SO PIN', accessible by the card specific part,\n\t\t\t * but not yet written into the on-card PKCS#15.\n\t\t\t */\n\t\t\tsc_log(ctx, \"Add virtual SO_PIN('%.*s',flags:%X,reference:%i,path:'%s')\", (int) sizeof pin_obj->label, pin_obj->label,\n\t\t\t\t\tpin_attrs->flags, pin_attrs->reference, sc_print_path(&pin_ainfo.path));\n\n\t\t\tr = sc_pkcs15_add_object(p15card, pin_obj);\n\t\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Failed to add 'SOPIN' AUTH object\");\n\t\t}\n\t}\n\n\t/* Perform card-specific initialization */\n\tif (profile->ops->init_card)   {\n\t\tr = profile->ops->init_card(profile, p15card);\n\t\tif (r < 0 && pin_obj)   {\n\t\t\tsc_pkcs15_remove_object(p15card, pin_obj);\n\t\t}\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Card specific init failed\");\n\t}\n\n\t/* Create the application directory */\n\tif (profile->ops->create_dir) {\n\t\tr = profile->ops->create_dir(profile, p15card, df);\n\t\tif (r < 0 && pin_obj)   {\n\t\t\tsc_pkcs15_remove_object(p15card, pin_obj);\n\t\t}\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Create 'DIR' error\");\n\t}\n\n\t/* Store SO PIN */\n\tif (pin_obj && profile->ops->create_pin)\n\t\tr = profile->ops->create_pin(profile, p15card, df, pin_obj,\n\t\t\t\targs->so_pin, args->so_pin_len,\n\t\t\t\targs->so_puk, args->so_puk_len);\n\n\tif (pin_obj)\n\t\t/* Remove 'virtual' AUTH object . */\n\t\tsc_pkcs15_remove_object(p15card, pin_obj);\n\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Card specific create application DF failed\");\n\n\t/* Store the PKCS15 information on the card */\n\tapp = (struct sc_app_info *)calloc(1, sizeof(*app));\n\tif (app == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Failed to allocate application info\");\n\t}\n\n\tapp->path = p15card->file_app->path;\n\tif (p15card->file_app->namelen <= SC_MAX_AID_SIZE) {\n\t\tapp->aid.len = p15card->file_app->namelen;\n\t\tmemcpy(app->aid.value, p15card->file_app->name, app->aid.len);\n\t}\n\n\t/* set serial number if explicitly specified */\n\tif (args->serial)   {\n\t\tsc_pkcs15init_set_serial(profile, args->serial);\n\t}\n\telse {\n\t\t/* otherwise try to get the serial number from the card */\n\t\tstruct sc_serial_number serialnr;\n\n\t\tr = sc_card_ctl(card, SC_CARDCTL_GET_SERIALNR, &serialnr);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tchar hex_serial[SC_MAX_SERIALNR * 2 + 1];\n\n\t\t\tsc_bin_to_hex(serialnr.value, serialnr.len, hex_serial, sizeof(hex_serial), 0);\n\t\t\tsc_pkcs15init_set_serial(profile, hex_serial);\n\t\t}\n\t}\n\n\tif (args->label) {\n\t\tif (p15card->tokeninfo->label)\n\t\t\tfree(p15card->tokeninfo->label);\n\t\tp15card->tokeninfo->label = strdup(args->label);\n\t}\n\tapp->label = strdup(p15card->tokeninfo->label);\n\n\t/* See if we've set an SO PIN */\n\tr = sc_pkcs15init_add_object(p15card, profile, SC_PKCS15_AODF, pin_obj);\n\tif (r >= 0) {\n\t\tr = sc_pkcs15init_update_dir(p15card, profile, app);\n\t\tif (r >= 0) {\n\t\t\tr = sc_pkcs15init_update_tokeninfo(p15card, profile);\n\t\t} else {\n\t\t\t/* FIXED: what to do if sc_pkcs15init_update_dir failed? */\n\t\t\t/* sc_pkcs15init_update_dir may add app to card->app[] */\n\t\t\tint found = 0;\n\t\t\tint i;\n\t\t\tfor (i = 0; i < card->app_count; i++) {\n\t\t\t\tif (card->app[i] == app) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found == 0) { /* not in card->app[] free it */\n\t\t\t\tfree(app->label);\n\t\t\t\tfree(app); /* unused */\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfree(app->label);\n\t\tfree(app); /* unused */\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Failed to add pin object.\");\n\t}\n\n\tsc_pkcs15init_write_info(p15card, profile, pin_obj);\n\tpin_obj = NULL;\n\nerr:\n\tsc_pkcs15_free_object(pin_obj);\n\tLOG_FUNC_RETURN(ctx, r);\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/../../../src/pkcs15init/pkcs15-lib.c",
        "crashing_line": "\t\tr = profile->ops->create_dir(profile, p15card, df);",
        "crashing_line_number": 879
      },
      {
        "function_name": "do_init_app",
        "function_body": "void do_init_app(struct sc_profile *profile, struct sc_pkcs15_card *p15card, sc_card_t *card,\n                 unsigned char *so_pin, unsigned char *so_puk)\n{\n    struct sc_pkcs15init_initargs init_args;\n    sc_pkcs15_auth_info_t         info;\n    int                           so_puk_disabled = 0;\n\n    memset(&init_args, 0, sizeof(init_args));\n    sc_pkcs15init_get_pin_info(profile, SC_PKCS15INIT_SO_PIN, &info);\n    if ((info.attrs.pin.flags & SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED) &&\n        (info.attrs.pin.flags & SC_PKCS15_PIN_FLAG_SO_PIN))\n        so_puk_disabled = 1;\n\n    sc_pkcs15init_get_pin_info(profile, SC_PKCS15INIT_SO_PUK, &info);\n\n    init_args.so_pin = so_pin;\n    init_args.so_pin_len = 8;\n\n    if (!so_puk_disabled) {\n        init_args.so_puk = so_puk;\n        init_args.so_puk_len = 8;\n    }\n\n    sc_pkcs15init_add_app(card, profile, &init_args);\n}",
        "file_path": "/src/opensc/src/tests/fuzzing/fuzz_pkcs15init.c",
        "crashing_line": "    sc_pkcs15init_add_app(card, profile, &init_args);",
        "crashing_line_number": 144
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "MRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n    ptrdiff_t voff = -1;\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {\n      voff = argv - mrb->c->stbase;\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend(mrb, argc + 3);\n    if (MRB_METHOD_UNDEF_P(m) || argc >= 15) {\n      mrb_value args = mrb_ary_new_from_values(mrb, argc, argv);\n\n      ci->stack[n+1] = args;\n      argc = 15;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      mrb_sym missing = MRB_SYM(method_missing);\n      mrb_value args = ci->stack[n+1];\n\n      m = mrb_method_search_vm(mrb, &c, missing);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_method_missing(mrb, mid, self, args);\n      }\n      mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));\n      mrb_stack_extend(mrb, n+2);\n      ci->stack[n+1] = args;\n      argc = 15;\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    if (voff >= 0) {\n      argv = mrb->c->stbase + voff;\n    }\n    ci->stack[0] = self;\n    if (argc < 15) {\n      if (argc > 0)\n        stack_copy(ci->stack+1, argv, argc);\n      ci->stack[argc+1] = blk;\n    }\n    else {\n      ci->stack[2] = blk;\n    }\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\n",
    "target": 1,
    "idx": 1039937,
    "stack_trace": [
      {
        "function_name": "mrb_instance_new",
        "function_body": "mrb_value\nmrb_instance_new(mrb_state *mrb, mrb_value cv)\n{\n  mrb_value obj, blk;\n  const mrb_value *argv;\n  mrb_int argc;\n  mrb_sym init;\n\n  mrb_get_args(mrb, \"*!&\", &argv, &argc, &blk);\n  obj = mrb_instance_alloc(mrb, cv);\n  init = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, init, mrb_bob_init)) {\n    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);\n  }\n  return obj;\n}",
        "file_path": "/src/mruby/src/class.c",
        "crashing_line": "    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);",
        "crashing_line_number": 1953
      },
      {
        "function_name": "mrb_funcall_with_block",
        "function_body": "MRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n    ptrdiff_t voff = -1;\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {\n      voff = argv - mrb->c->stbase;\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend(mrb, n + argc + 3);\n    if (MRB_METHOD_UNDEF_P(m) || argc >= 15) {\n      mrb_value args = mrb_ary_new_from_values(mrb, argc, argv);\n\n      ci->stack[n+1] = args;\n      argc = 15;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      mrb_sym missing = MRB_SYM(method_missing);\n      mrb_value args = ci->stack[n+1];\n\n      m = mrb_method_search_vm(mrb, &c, missing);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_method_missing(mrb, mid, self, args);\n      }\n      mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));\n      mrb_stack_extend(mrb, n+2);\n      ci->stack[n+1] = args;\n      argc = 15;\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    if (voff >= 0) {\n      argv = mrb->c->stbase + voff;\n    }\n    ci->stack[0] = self;\n    if (argc < 15) {\n      if (argc > 0)\n        stack_copy(ci->stack+1, argv, argc);\n      ci->stack[argc+1] = blk;\n    }\n    else {\n      ci->stack[2] = blk;\n    }\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "      val = MRB_METHOD_CFUNC(m)(mrb, self);",
        "crashing_line_number": 525
      },
      {
        "function_name": "mrb_funcall_argv",
        "function_body": "MRB_API mrb_value\nmrb_funcall_argv(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv)\n{\n  return mrb_funcall_with_block(mrb, self, mid, argc, argv, mrb_nil_value());\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "  return mrb_funcall_with_block(mrb, self, mid, argc, argv, mrb_nil_value());",
        "crashing_line_number": 541
      },
      {
        "function_name": "mrb_make_exception",
        "function_body": "MRB_API mrb_value\nmrb_make_exception(mrb_state *mrb, mrb_int argc, const mrb_value *argv)\n{\n  mrb_value mesg;\n  int n;\n\n  mesg = mrb_nil_value();\n  switch (argc) {\n    case 0:\n    break;\n    case 1:\n      if (mrb_nil_p(argv[0]))\n        break;\n      if (mrb_string_p(argv[0])) {\n        mesg = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, argv[0]);\n        break;\n      }\n      n = 0;\n      goto exception_call;\n\n    case 2:\n    case 3:\n      n = 1;\nexception_call:\n      {\n        mrb_sym exc = MRB_SYM(exception);\n        if (mrb_respond_to(mrb, argv[0], exc)) {\n          mesg = mrb_funcall_argv(mrb, argv[0], exc, n, argv+1);\n        }\n        else {\n          /* undef */\n          mrb_raise(mrb, E_TYPE_ERROR, \"exception class/object expected\");\n        }\n      }\n\n      break;\n    default:\n      mrb_argnum_error(mrb, argc, 0, 3);\n      break;\n  }\n  if (argc > 0) {\n    if (!mrb_obj_is_kind_of(mrb, mesg, mrb->eException_class))\n      mrb_raise(mrb, mrb->eException_class, \"exception object expected\");\n    if (argc > 2)\n      set_backtrace(mrb, mesg, argv[2]);\n  }\n\n  return mesg;\n}",
        "file_path": "/src/mruby/src/error.c",
        "crashing_line": "          mesg = mrb_funcall_argv(mrb, argv[0], exc, n, argv+1);",
        "crashing_line_number": 514
      },
      {
        "function_name": "mrb_f_raise",
        "function_body": "MRB_API mrb_value\nmrb_f_raise(mrb_state *mrb, mrb_value self)\n{\n  mrb_value a[2], exc;\n  mrb_int argc;\n\n  argc = mrb_get_args(mrb, \"|oo\", &a[0], &a[1]);\n  mrb->c->ci->mid = 0;\n  switch (argc) {\n  case 0:\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"\");\n    break;\n  case 1:\n    if (mrb_string_p(a[0])) {\n      a[1] = a[0];\n      argc = 2;\n      a[0] = mrb_obj_value(E_RUNTIME_ERROR);\n    }\n    /* fall through */\n  default:\n    exc = mrb_make_exception(mrb, argc, a);\n    mrb_exc_raise(mrb, exc);\n    break;\n  }\n  return mrb_nil_value();            /* not reached */\n}",
        "file_path": "/src/mruby/src/kernel.c",
        "crashing_line": "    exc = mrb_make_exception(mrb, argc, a);",
        "crashing_line_number": 437
      },
      {
        "function_name": "mrb_vm_run",
        "function_body": "MRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "  result = mrb_vm_exec(mrb, proc, irep->iseq);",
        "crashing_line_number": 1070
      },
      {
        "function_name": "FuzzRB",
        "function_body": "int FuzzRB(const uint8_t *Data, size_t size) {\n\tmrb_value v;\n\tmrb_state *mrb = mrb_open();\n\tif (!mrb)\n\t\treturn 0;\n\n\tchar *code = (char *)malloc(size+1);\n\tif (!code)\n\t\treturn 0;\n\tmemcpy(code, Data, size);\n\tcode[size] = '\\0';\n\n\tif (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n\t\t// With libFuzzer binary run this to generate an RB file x.rb:\n\t\t// PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n\t\tstd::ofstream of(dump_path);\n\t\tof.write(code, size);\n\t}\n\tv = mrb_load_string(mrb, code);\n\tmrb_close(mrb);\n\n\tfree(code);\n\treturn 0;\n}",
        "file_path": "/src/mruby/oss-fuzz/mruby_proto_fuzzer.cpp",
        "crashing_line": "\tv = mrb_load_string(mrb, code);",
        "crashing_line_number": 33
      },
      {
        "function_name": "TestOneProtoInput",
        "function_body": "",
        "file_path": "/src/mruby/oss-fuzz/mruby_proto_fuzzer.cpp",
        "crashing_line": "",
        "crashing_line_number": 43
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\nread_file_header (Bit_Chain *restrict dat,\n                  r2007_file_header *restrict file_header)\n{\n  BITCODE_RC data[0x3d8]; // 0x400 - 5 long\n  BITCODE_RC *pedata;\n  uint64_t seqence_crc;\n  uint64_t seqence_key;\n  uint64_t compr_crc;\n  int32_t compr_len, len2;\n  int i;\n  int error = 0, errcount = 0;\n  const int pedata_size = 3 * 239; // size of pedata\n\n  dat->byte = 0x80;\n  LOG_TRACE (\"\\n=== File header ===\\n\")\n  memset (file_header, 0, sizeof (r2007_file_header));\n  memset (data, 0, 0x3d8);\n  bit_read_fixed (dat, data, 0x3d8);\n  pedata = decode_rs (data, 3, 239, 0x3d8);\n  if (!pedata)\n    return DWG_ERR_OUTOFMEM;\n\n  // Note: This is unportable to big-endian\n  seqence_crc = *((uint64_t *)pedata);\n  seqence_key = *((uint64_t *)&pedata[8]);\n  compr_crc = *((uint64_t *)&pedata[16]);\n  compr_len = *((int32_t *)&pedata[24]);\n  len2 = *((int32_t *)&pedata[28]);\n  LOG_TRACE (\"seqence_crc64: %016lX\\n\", (unsigned long)seqence_crc);\n  LOG_TRACE (\"seqence_key:   %016lX\\n\", (unsigned long)seqence_key);\n  LOG_TRACE (\"compr_crc64:   %016lX\\n\", (unsigned long)compr_crc);\n  LOG_TRACE (\"compr_len:     %d\\n\", (int)compr_len); // only this is used\n  LOG_TRACE (\"len2:          %d\\n\", (int)len2);      // 0 when compressed\n\n  if (compr_len > 0)\n    error = decompress_r2007 ((BITCODE_RC *)file_header, sizeof (r2007_file_header) + 1,\n                              &pedata[32], MIN (compr_len, pedata_size - 32));\n  else\n    memcpy (file_header, &pedata[32], sizeof (r2007_file_header));\n\n  // check validity, for debugging only\n  if (!error)\n    {\n\n#define VALID_SIZE(var)                                                       \\\n  if (var < 0 || (unsigned)var > dat->size)                                   \\\n    {                                                                         \\\n      errcount++;                                                             \\\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      LOG_ERROR (\"%s Invalid %s %ld > MAX_SIZE\", __FUNCTION__, #var,          \\\n                 (long)var)                                                   \\\n      var = 0;                                                                \\\n    }\n#define VALID_COUNT(var)                                                      \\\n  if (var < 0 || (unsigned)var > dat->size)                                   \\\n    {                                                                         \\\n      errcount++;                                                             \\\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      LOG_ERROR (\"%s Invalid %s %ld > MAX_COUNT\", __FUNCTION__, #var,         \\\n                 (long)var)                                                   \\\n      var = 0;                                                                \\\n    }\n\n      VALID_SIZE (file_header->header_size);\n      VALID_SIZE (file_header->file_size);\n      VALID_SIZE (file_header->pages_map_offset);\n      VALID_SIZE (file_header->header2_offset);\n      VALID_SIZE (file_header->pages_map_offset);\n      VALID_SIZE (file_header->pages_map_size_comp);\n      VALID_SIZE (file_header->pages_map_size_uncomp);\n      VALID_COUNT (file_header->pages_maxid);\n      VALID_COUNT (file_header->pages_amount);\n      VALID_COUNT (file_header->num_sections);\n    }\n\n  free (pedata);\n  return error;\n}\n",
    "target": 1,
    "idx": 1044432,
    "stack_trace": [
      {
        "function_name": "copy_bytes",
        "function_body": "static void\ncopy_bytes (BITCODE_RC *dst, uint32_t length, uint32_t offset)\n{\n  BITCODE_RC *src = dst - offset;\n\n  while (length-- > 0)\n    *dst++ = *src++;\n}",
        "file_path": "/src/libredwg/src/decode_r2007.c",
        "crashing_line": "    *dst++ = *src++;",
        "crashing_line_number": 228
      },
      {
        "function_name": "decompress_r2007",
        "function_body": "static int\ndecompress_r2007 (BITCODE_RC *restrict dst, const unsigned dst_size,\n                  BITCODE_RC *restrict src, const unsigned src_size)\n{\n  uint32_t length = 0;\n  uint32_t offset = 0;\n\n  BITCODE_RC *dst_start = dst;\n  BITCODE_RC *dst_end = dst + dst_size;\n  BITCODE_RC *src_end = src + src_size;\n  unsigned char opcode;\n\n  LOG_INSANE (\"decompress_r2007 (%p, %d, %p, %d)\\n\", dst, dst_size, src, src_size);\n  if (!dst || !src || !dst_size || src_size < 2)\n    {\n      LOG_ERROR (\"Invalid argument to %s\\n\", __FUNCTION__);\n      return DWG_ERR_INTERNALERROR;\n    }\n\n  opcode = *src++;\n  if ((opcode & 0xf0) == 0x20)\n    {\n      src += 2;\n      length = *src++ & 0x07;\n      if (length == 0)\n        {\n          LOG_ERROR (\"Decompression error: zero length\")\n          return DWG_ERR_INTERNALERROR;\n        }\n    }\n\n  while (src < src_end)\n    {\n      if (length == 0)\n        length = read_literal_length (&src, opcode);\n\n      if ((dst + length) >= dst_end || (src + length) > src_end)\n        {\n          if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n            {\n              if ((dst + length) >= dst_end)\n                HANDLER(OUTPUT, \"copy_compressed_bytes: dst %p + %u >= %p\\n\",\n                        dst, (unsigned)length, dst_end);\n              else\n                HANDLER(OUTPUT, \"copy_compressed_bytes: src %p + %u > %p\\n\",\n                        src, (unsigned)length, src_end);\n            }\n          LOG_ERROR (\"Decompression error: length overflow\");\n          return DWG_ERR_INTERNALERROR;\n        }\n\n      LOG_INSANE (\n          \"copy_compressed_bytes (%p, %p, %u). remaining src: %ld, dst: %ld\\n\",\n          dst, src, (unsigned)length, (long)(src_end - src), (long)(dst_end - dst));\n      copy_compressed_bytes (dst, src, length);\n\n      dst += length;\n      src += length;\n\n      length = 0;\n\n      if (src >= src_end)\n        return 0;\n\n      opcode = *src++;\n\n      read_instructions (&src, &opcode, &offset, &length);\n\n      while (1)\n        {\n          if ((dst + length) > dst_end)\n            {\n              LOG_HANDLE(\"copy_bytes: dst %p + %u > %p\\n\", dst, (unsigned)length, dst_end);\n              LOG_ERROR (\"Decompression error: length overflow\");\n              return DWG_ERR_INTERNALERROR;\n            }\n          if (offset > (uint32_t) (dst - dst_start))\n            {\n              LOG_HANDLE(\"copy_bytes: offset %u > %p - %p\\n\", (unsigned)offset, dst, dst_start);\n              LOG_ERROR (\"Decompression error: offset underflow\");\n              return DWG_ERR_INTERNALERROR;\n            }\n          LOG_INSANE (\"copy_bytes (%p, %u, [%u])\\n\", dst, (unsigned)length, (unsigned)offset);\n          copy_bytes (dst, length, offset);\n\n          dst += length;\n          length = (opcode & 7);\n\n          if (length != 0 || src >= src_end)\n            break;\n\n          opcode = *src++;\n\n          if ((opcode >> 4) == 0)\n            break;\n\n          if ((opcode >> 4) == 0x0f)\n            opcode &= 0xf;\n\n          read_instructions ((unsigned char **)&src, &opcode, &offset,\n                             &length);\n        }\n    }\n\n  return 0;\n}",
        "file_path": "/src/libredwg/src/decode_r2007.c",
        "crashing_line": "          copy_bytes (dst, length, offset);",
        "crashing_line_number": 563
      },
      {
        "function_name": "read_file_header",
        "function_body": "static int\nread_file_header (Bit_Chain *restrict dat,\n                  r2007_file_header *restrict file_header)\n{\n  BITCODE_RC data[0x3d8]; // 0x400 - 5 long\n  BITCODE_RC *pedata;\n  uint64_t seqence_crc;\n  uint64_t seqence_key;\n  uint64_t compr_crc;\n  int32_t compr_len, len2;\n  int i;\n  int error = 0, errcount = 0;\n  const int pedata_size = 3 * 239; // size of pedata\n\n  dat->byte = 0x80;\n  LOG_TRACE (\"\\n=== File header ===\\n\")\n  memset (file_header, 0, sizeof (r2007_file_header));\n  memset (data, 0, 0x3d8);\n  bit_read_fixed (dat, data, 0x3d8);\n  pedata = decode_rs (data, 3, 239, 0x3d8);\n  if (!pedata)\n    return DWG_ERR_OUTOFMEM;\n\n  // Note: This is unportable to big-endian\n  seqence_crc = *((uint64_t *)pedata);\n  seqence_key = *((uint64_t *)&pedata[8]);\n  compr_crc = *((uint64_t *)&pedata[16]);\n  compr_len = *((int32_t *)&pedata[24]);\n  len2 = *((int32_t *)&pedata[28]);\n  LOG_TRACE (\"seqence_crc64: %016lX\\n\", (unsigned long)seqence_crc);\n  LOG_TRACE (\"seqence_key:   %016lX\\n\", (unsigned long)seqence_key);\n  LOG_TRACE (\"compr_crc64:   %016lX\\n\", (unsigned long)compr_crc);\n  LOG_TRACE (\"compr_len:     %d\\n\", (int)compr_len); // only this is used\n  LOG_TRACE (\"len2:          %d\\n\", (int)len2);      // 0 when compressed\n\n  if (compr_len > 0)\n    error = decompress_r2007 ((BITCODE_RC *)file_header, sizeof (r2007_file_header),\n                              &pedata[32], MIN (compr_len, pedata_size - 32));\n  else\n    memcpy (file_header, &pedata[32], sizeof (r2007_file_header));\n\n  // check validity, for debugging only\n  if (!error)\n    {\n\n#define VALID_SIZE(var)                                                       \\\n  if (var < 0 || (unsigned)var > dat->size)                                   \\\n    {                                                                         \\\n      errcount++;                                                             \\\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      LOG_ERROR (\"%s Invalid %s %ld > MAX_SIZE\", __FUNCTION__, #var,          \\\n                 (long)var)                                                   \\\n      var = 0;                                                                \\\n    }\n#define VALID_COUNT(var)                                                      \\\n  if (var < 0 || (unsigned)var > dat->size)                                   \\\n    {                                                                         \\\n      errcount++;                                                             \\\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      LOG_ERROR (\"%s Invalid %s %ld > MAX_COUNT\", __FUNCTION__, #var,         \\\n                 (long)var)                                                   \\\n      var = 0;                                                                \\\n    }\n\n      VALID_SIZE (file_header->header_size);\n      VALID_SIZE (file_header->file_size);\n      VALID_SIZE (file_header->pages_map_offset);\n      VALID_SIZE (file_header->header2_offset);\n      VALID_SIZE (file_header->pages_map_offset);\n      VALID_SIZE (file_header->pages_map_size_comp);\n      VALID_SIZE (file_header->pages_map_size_uncomp);\n      VALID_COUNT (file_header->pages_maxid);\n      VALID_COUNT (file_header->pages_amount);\n      VALID_COUNT (file_header->num_sections);\n    }\n\n  free (pedata);\n  return error;\n}",
        "file_path": "/src/libredwg/src/decode_r2007.c",
        "crashing_line": "    error = decompress_r2007 ((BITCODE_RC *)file_header, sizeof (r2007_file_header),",
        "crashing_line_number": 1247
      },
      {
        "function_name": "read_r2007_meta_data",
        "function_body": "int\nread_r2007_meta_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                      Dwg_Data *restrict dwg)\n{\n  r2007_file_header file_header;\n  r2007_page *restrict pages_map = NULL, *restrict page;\n  r2007_section *restrict sections_map = NULL;\n  int error;\n#ifdef USE_TRACING\n  char *probe;\n#endif\n\n  read_r2007_init (dwg);\n#ifdef USE_TRACING\n  probe = getenv (\"LIBREDWG_TRACE\");\n  if (probe)\n    loglevel = atoi (probe);\n#endif\n  // @ 0x62\n  error = read_file_header (dat, &file_header);\n  if (error >= DWG_ERR_VALUEOUTOFBOUNDS)\n    return error;\n\n  // Pages Map\n  dat->byte += 0x28; // overread check data\n  dat->byte += file_header.pages_map_offset;\n  if ((unsigned long)file_header.pages_map_size_comp\n      > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"%s Invalid pages_map_size_comp %lu > %lu bytes left\",\n                 __FUNCTION__,\n                 (unsigned long)file_header.pages_map_size_comp,\n                 dat->size - dat->byte)\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      goto error;\n    }\n  pages_map = read_pages_map (dat, file_header.pages_map_size_comp,\n                              file_header.pages_map_size_uncomp,\n                              file_header.pages_map_correction);\n  if (!pages_map)\n    return DWG_ERR_PAGENOTFOUND; // Error already logged\n\n  // Sections Map\n  page = get_page (pages_map, file_header.sections_map_id);\n  if (!page)\n    {\n      LOG_ERROR (\"Failed to find sections page map %d\",\n                 (int)file_header.sections_map_id);\n      error |= DWG_ERR_SECTIONNOTFOUND;\n      goto error;\n    }\n  dat->byte = page->offset;\n  if ((unsigned long)file_header.sections_map_size_comp\n      > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"%s Invalid comp_data_size %lu > %lu bytes left\",\n                 __FUNCTION__,\n                 (unsigned long)file_header.sections_map_size_comp,\n                 dat->size - dat->byte)\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      goto error;\n    }\n  sections_map = read_sections_map (dat, file_header.sections_map_size_comp,\n                                    file_header.sections_map_size_uncomp,\n                                    file_header.sections_map_correction);\n  if (!sections_map)\n    goto error;\n\n  error = read_2007_section_header (dat, hdl_dat, dwg, sections_map,\n                                    pages_map);\n  if (dwg->header.summaryinfo_address)\n    error |= read_2007_section_summary (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_classes (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_handles (dat, hdl_dat, dwg, sections_map,\n                                      pages_map);\n  error |= read_2007_section_auxheader (dat, dwg, sections_map, pages_map);\n  if (dwg->header.thumbnail_address)\n    error |= read_2007_section_preview (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_appinfo (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_appinfohistory (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_filedeplist (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_security (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_revhistory (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_objfreespace (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_template (dat, dwg, sections_map, pages_map);\n  if (dwg->header.vbaproj_address)\n    error |= read_2007_section_vbaproject (dat, dwg, sections_map, pages_map);\n  //error |= read_2007_section_signature (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_acds (dat, dwg, sections_map, pages_map);\n  // read_2007_blocks (dat, hdl_dat, dwg, sections_map, pages_map);\n\nerror:\n  pages_destroy (pages_map);\n  if (sections_map)\n    sections_destroy (sections_map);\n\n  return error;\n}",
        "file_path": "/src/libredwg/src/decode_r2007.c",
        "crashing_line": "  error = read_file_header (dat, &file_header);",
        "crashing_line_number": 2354
      },
      {
        "function_name": "decode_R2007",
        "function_body": "static int\ndecode_R2007 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain hdl_dat = { 0 };\n  int error;\n\n  hdl_dat = *dat;\n  {\n    int i;\n    Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n\n  // this includes classes, header, handles + objects\n  error = read_r2007_meta_data (dat, &hdl_dat, dwg);\n\n  LOG_INFO (\"\\nnum_objects: %lu\\n\", (unsigned long)dwg->num_objects)\n  LOG_TRACE (\"num_object_refs: %lu\\n\", (unsigned long)dwg->num_object_refs)\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read 2007 meta data\")\n      return error;\n    }\n\n  LOG_TRACE (\"Resolving pointers from ObjectRef vector:\\n\")\n  return error | resolve_objectref_vector (dat, dwg);\n}",
        "file_path": "/src/libredwg/src/decode.c",
        "crashing_line": "  error = read_r2007_meta_data (dat, &hdl_dat, dwg);",
        "crashing_line_number": 3238
      },
      {
        "function_name": "dwg_decode",
        "function_body": "EXPORT int\ndwg_decode (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int i;\n  char magic[8];\n\n  dwg->num_object_refs = 0;\n  // dwg->num_layers = 0; // see now dwg->layer_control->num_entries\n  dwg->num_entities = 0;\n  dwg->num_objects = 0;\n  dwg->num_classes = 0;\n  dwg->thumbnail.size = 0;\n  dwg->thumbnail.chain = NULL;\n  dwg->header.numsections = 0;\n  dwg->header.section_infohdr.num_desc = 0;\n  dwg->dwg_class = NULL;\n  dwg->object_ref = NULL;\n  dwg->object = NULL;\n  dwg->object_map = hash_new (dat->size / 1000);\n  if (!dwg->object_map)\n    {\n      // whatever, we are obviously on a tiny system\n      dwg->object_map = hash_new (1024);\n      if (!dwg->object_map)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n    }\n  dwg->dirty_refs = 1;\n\n  //memset (&dwg->header, 0, sizeof (dwg->header)); // no, needed for magic\n  memset (&dwg->header_vars, 0, sizeof (dwg->header_vars));\n  memset (&dwg->summaryinfo, 0, sizeof (dwg->summaryinfo));\n  memset (&dwg->r2004_header, 0, sizeof (dwg->r2004_header));\n  memset (&dwg->auxheader, 0, sizeof (dwg->auxheader));\n  memset (&dwg->second_header, 0, sizeof (dwg->second_header));\n\n  if (dwg->opts)\n    {\n      loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n      dat->opts = dwg->opts;\n    }\n\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  /* Version */\n  dat->byte = 0;\n  dat->bit = 0;\n  if (!dat->chain || dat->size < 58) // saw the smallest r2.10 DWG with 1095 bytes\n    {\n      LOG_ERROR (\"dwg too small: %lu bytes\", dat->size);\n      return DWG_ERR_INVALIDDWG;\n    }\n  strncpy (magic, (const char *)dat->chain, 6);\n  if (memcmp (dat->chain, \"AC103-4\", 7) == 0)\n    {\n      magic[6] = '4';\n      magic[7] = '\\0';\n    }\n  else\n    magic[6] = '\\0';\n\n  dwg->header.from_version = dwg_version_hdr_type (magic);\n  if (!dwg->header.from_version)\n    {\n      if (strncmp (magic, \"AC\", 2)) // let's ignore MC0.0 for now\n        {\n          LOG_ERROR (\"Invalid DWG, magic: %s\", magic);\n        }\n      else\n        {\n          LOG_ERROR (\"Invalid or unimplemented DWG version code %s\", magic);\n        }\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->from_version = dwg->header.from_version;\n  if (!dwg->header.version) // target version not set\n    {\n      dat->version = dwg->header.version = dat->from_version;\n    }\n  LOG_INFO (\"This file's version code is: %s (%s)\\n\", magic,\n            dwg_version_type (dat->from_version))\n\n  PRE (R_13) {\n    Dwg_Object *ctrl;\n    int error = decode_preR13 (dat, dwg);\n    ctrl = &dwg->object[0];\n    dwg->block_control = *ctrl->tio.object->tio.BLOCK_CONTROL;\n    return error;\n  }\n  VERSIONS (R_13, R_2000) { return decode_R13_R2000 (dat, dwg); }\n  VERSION (R_2004) { return decode_R2004 (dat, dwg); }\n  VERSION (R_2007) { return decode_R2007 (dat, dwg); }\n  SINCE (R_2010)\n  {\n    read_r2007_init (dwg); // sets loglevel only for now\n    return decode_R2004 (dat, dwg);\n  }\n\n  // This line should not be reached\n  LOG_ERROR (\"LibreDWG does not support this DWG version: %s (%s).\",\n\t     magic, dwg_version_type (dat->from_version))\n  return DWG_ERR_INVALIDDWG;\n}",
        "file_path": "/src/libredwg/src/decode.c",
        "crashing_line": "  VERSION (R_2007) { return decode_R2007 (dat, dwg); }",
        "crashing_line_number": 218
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void bn_lsh(bn_t c, const bn_t a, uint_t bits) {\n\tint digits;\n\tdig_t carry;\n\n\tRLC_RIP(bits, digits, bits);\n\n\tRLC_TRY {\n\t\tbn_grow(c, c->used + digits + (bits > 0));\n\n\t\tc->used = a->used + digits;\n\t\tif (digits > 0) {\n\t\t\tdv_lshd(c->dp, a->dp, c->used, digits);\n\t\t} else {\n\t\t\tdv_copy(c->dp, a->dp, a->used);\n\t\t}\n\t\tc->sign = a->sign;\n\n\t\tif (bits > 0) {\n\t\t\tcarry = bn_lshb_low(c->dp + digits, c->dp + digits,\n\t\t\t\tc->used - digits, bits);\n\t\t\tif (carry != 0) {\n\t\t\t\tc->dp[c->used] = carry;\n\t\t\t\t(c->used)++;\n\t\t\t}\n\t\t}\n\t\tbn_trim(c);\n\t} RLC_CATCH_ANY {\n",
    "target": 1,
    "idx": 1053919,
    "stack_trace": [
      {
        "function_name": "dv_copy",
        "function_body": "void dv_copy(dig_t *c, const dig_t *a, size_t digits) {\n\tmemcpy(c, a, digits * sizeof(dig_t));\n}",
        "file_path": "/src/relic/src/dv/relic_dv_util.c",
        "crashing_line": "\tmemcpy(c, a, digits * sizeof(dig_t));",
        "crashing_line_number": 70
      },
      {
        "function_name": "bn_lsh",
        "function_body": "void bn_lsh(bn_t c, const bn_t a, uint_t bits) {\n\tint digits;\n\tdig_t carry;\n\n\tRLC_RIP(bits, digits, bits);\n\n\tRLC_TRY {\n\t\tbn_grow(c, a->used + digits + (bits > 0));\n\n\t\tc->used = a->used + digits;\n\t\tif (digits > 0) {\n\t\t\tdv_lshd(c->dp, a->dp, c->used, digits);\n\t\t} else {\n\t\t\tdv_copy(c->dp, a->dp, a->used);\n\t\t}\n\t\tc->sign = a->sign;\n\n\t\tif (bits > 0) {\n\t\t\tcarry = bn_lshb_low(c->dp + digits, c->dp + digits,\n\t\t\t\tc->used - digits, bits);\n\t\t\tif (carry != 0) {\n\t\t\t\tc->dp[c->used] = carry;\n\t\t\t\t(c->used)++;\n\t\t\t}\n\t\t}\n\t\tbn_trim(c);\n\t} RLC_CATCH_ANY {",
        "file_path": "/src/relic/src/bn/relic_bn_shift.c",
        "crashing_line": "\t\t\tdv_copy(c->dp, a->dp, a->used);",
        "crashing_line_number": 79
      },
      {
        "function_name": "Run",
        "function_body": "bool Add::Run(Datasource& ds, Bignum& res, std::vector<Bignum>& bn) const {\n    (void)ds;\n\n    RLC_TRY {\n        /* noret */ bn_add(res.Get(), bn[0].Get(), bn[1].Get());\n    } RLC_CATCH_ANY {",
        "file_path": "/src/cryptofuzz/modules/relic/bn_ops.cpp",
        "crashing_line": "",
        "crashing_line_number": 310
      },
      {
        "function_name": "OpBignumCalc",
        "function_body": "std::optional<component::Bignum> relic::OpBignumCalc(operation::BignumCalc& op) {\n    std::optional<component::Bignum> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    relic_bignum::Bignum res(ds);\n    std::vector<relic_bignum::Bignum> bn = {\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n    };\n\n    std::unique_ptr<relic_bignum::Operation> opRunner = nullptr;\n\n    CF_CHECK_TRUE(res.Set(\"0\"));\n    CF_CHECK_TRUE(bn[0].Set(op.bn0.ToString(ds)));\n    CF_CHECK_TRUE(bn[1].Set(op.bn1.ToString(ds)));\n    CF_CHECK_TRUE(bn[2].Set(op.bn2.ToString(ds)));\n    CF_CHECK_TRUE(bn[3].Set(op.bn3.ToString(ds)));\n\n    switch ( op.calcOp.Get() ) {\n        case    CF_CALCOP(\"Add(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Add>();\n            break;\n        case    CF_CALCOP(\"Sub(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Sub>();\n            break;\n        case    CF_CALCOP(\"Mul(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Mul>();\n            break;\n        case    CF_CALCOP(\"Sqr(A)\"):\n            opRunner = std::make_unique<relic_bignum::Sqr>();\n            break;\n        case    CF_CALCOP(\"Div(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Div>();\n            break;\n        case    CF_CALCOP(\"GCD(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::GCD>();\n            break;\n        case    CF_CALCOP(\"ExtGCD_X(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::ExtGCD_X>();\n            break;\n        case    CF_CALCOP(\"ExtGCD_Y(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::ExtGCD_Y>();\n            break;\n        case    CF_CALCOP(\"LCM(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::LCM>();\n            break;\n        case    CF_CALCOP(\"InvMod(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::InvMod>();\n            break;\n        case    CF_CALCOP(\"LShift1(A)\"):\n            opRunner = std::make_unique<relic_bignum::LShift1>();\n            break;\n        case    CF_CALCOP(\"Jacobi(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Jacobi>();\n            break;\n        case    CF_CALCOP(\"Cmp(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Cmp>();\n            break;\n        case    CF_CALCOP(\"Mod(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Mod>();\n            break;\n        case    CF_CALCOP(\"IsEven(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsEven>();\n            break;\n        case    CF_CALCOP(\"IsOdd(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsOdd>();\n            break;\n        case    CF_CALCOP(\"IsZero(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsZero>();\n            break;\n        case    CF_CALCOP(\"Neg(A)\"):\n            opRunner = std::make_unique<relic_bignum::Neg>();\n            break;\n        case    CF_CALCOP(\"Sqrt(A)\"):\n            opRunner = std::make_unique<relic_bignum::Sqrt>();\n            break;\n        case    CF_CALCOP(\"Abs(A)\"):\n            opRunner = std::make_unique<relic_bignum::Abs>();\n            break;\n        case    CF_CALCOP(\"ExpMod(A,B,C)\"):\n            opRunner = std::make_unique<relic_bignum::ExpMod>();\n            break;\n        case    CF_CALCOP(\"NumBits(A)\"):\n            opRunner = std::make_unique<relic_bignum::NumBits>();\n            break;\n        case    CF_CALCOP(\"CmpAbs(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::CmpAbs>();\n            break;\n        case    CF_CALCOP(\"RShift(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::RShift>();\n            break;\n        case    CF_CALCOP(\"Bit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Bit>();\n            break;\n        case    CF_CALCOP(\"SetBit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::SetBit>();\n            break;\n        case    CF_CALCOP(\"ClearBit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::ClearBit>();\n            break;\n    }\n\n    CF_CHECK_NE(opRunner, nullptr);\n    CF_CHECK_EQ(opRunner->Run(ds, res, bn), true);\n\n    ret = res.ToComponentBignum();\n\nend:\n    return ret;\n}",
        "file_path": "/src/cryptofuzz/modules/relic/module.cpp",
        "crashing_line": "    CF_CHECK_EQ(opRunner->Run(ds, res, bn), true);",
        "crashing_line_number": 839
      },
      {
        "function_name": "callModule",
        "function_body": "std::optional<component::Bignum> ExecutorBignumCalc::callModule(std::shared_ptr<Module> module, operation::BignumCalc& op) const {\n    RETURN_IF_DISABLED(options.calcOps, op.calcOp.Get());\n\n    /* Prevent timeouts */\n    if ( op.bn0.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.modulo != std::nullopt && !module->SupportsModularBignumCalc() ) {\n        return std::nullopt;\n    }\n\n    switch ( op.calcOp.Get() ) {\n        case    CF_CALCOP(\"SetBit(A,B)\"):\n            /* Don't allow setting very high bit positions (risk of memory exhaustion) */\n            if ( op.bn1.GetSize() > 4 ) {\n                return std::nullopt;\n            }\n            break;\n        case    CF_CALCOP(\"Exp(A,B)\"):\n            if ( op.bn0.GetSize() > 5 || op.bn1.GetSize() > 2 ) {\n                return std::nullopt;\n            }\n            break;\n        case    CF_CALCOP(\"ModLShift(A,B,C)\"):\n            if ( op.bn1.GetSize() > 4 ) {\n                return std::nullopt;\n            }\n            break;\n        case    CF_CALCOP(\"Exp2(A)\"):\n            if ( op.bn0.GetSize() > 4 ) {\n                return std::nullopt;\n            }\n            break;\n    }\n\n    return module->OpBignumCalc(op);\n}",
        "file_path": "/src/cryptofuzz/executor.cpp",
        "crashing_line": "    return module->OpBignumCalc(op);",
        "crashing_line_number": 974
      },
      {
        "function_name": "Run",
        "function_body": "void ExecutorBase<ResultType, OperationType>::Run(Datasource& parentDs, const uint8_t* data, const size_t size) const {\n    typename ExecutorBase<ResultType, OperationType>::ResultSet results;\n\n    std::vector< std::pair<std::shared_ptr<Module>, OperationType> > operations;\n\n    do {\n        auto op = getOp(&parentDs, data, size);\n        auto module = getModule(parentDs);\n        if ( module == nullptr ) {\n            continue;\n        }\n\n        operations.push_back( {module, op} );\n\n        /* Limit number of operations per run to prevent time-outs */\n        if ( operations.size() == OperationType::MaxOperations() ) {\n            break;\n        }\n    } while ( parentDs.Get<bool>() == true );\n\n    if ( operations.empty() == true ) {\n        return;\n    }\n\n    /* Enable this to run every operation on every loaded module */\n#if 1\n    {\n        std::set<uint64_t> moduleIDs;\n        for (const auto& m : modules ) {\n            const auto moduleID = m.first;\n\n            /* Skip if this is a disabled module */\n            if ( options.disableModules.HaveExplicit(moduleID) ) {\n                continue;\n            }\n\n            moduleIDs.insert(moduleID);\n        }\n\n        std::set<uint64_t> operationModuleIDs;\n        for (const auto& op : operations) {\n            operationModuleIDs.insert(op.first->ID);\n        }\n\n        std::vector<uint64_t> addModuleIDs(moduleIDs.size());\n        auto it = std::set_difference(moduleIDs.begin(), moduleIDs.end(), operationModuleIDs.begin(), operationModuleIDs.end(), addModuleIDs.begin());\n        addModuleIDs.resize(it - addModuleIDs.begin());\n\n        for (const auto& id : addModuleIDs) {\n            operations.push_back({ modules.at(id), operations[0].second});\n        }\n    }\n#endif\n\n    if ( operations.size() < options.minModules ) {\n        return;\n    }\n\n    if ( options.debug == true && !operations.empty() ) {\n        printf(\"Running:\\n%s\\n\", operations[0].second.ToString().c_str());\n    }\n    for (size_t i = 0; i < operations.size(); i++) {\n        auto& operation = operations[i];\n\n        auto& module = operation.first;\n        auto& op = operation.second;\n\n        if ( i > 0 ) {\n            auto& prevModule = operations[i-1].first;\n            auto& prevOp = operations[i].second;\n\n            if ( prevModule == module && prevOp.modifier == op.modifier ) {\n                auto& curModifier = op.modifier.GetVectorPtr();\n                if ( curModifier.size() == 0 ) {\n                    for (size_t j = 0; j < 512; j++) {\n                        curModifier.push_back(1);\n                    }\n                } else {\n                    for (auto& c : curModifier) {\n                        c++;\n                    }\n                }\n            }\n        }\n\n        if ( options.debug == true ) {\n            printf(\"modifier: %s\\n\", util::HexDump(op.modifier.Get()).c_str());\n        }\n\n        results.push_back( {module, std::move(callModule(module, op))} );\n\n        const auto& result = results.back();\n\n        if ( result.second != std::nullopt ) {\n            if ( options.jsonDumpFP != std::nullopt ) {\n                nlohmann::json j;\n                j[\"operation\"] = op.ToJSON();\n                j[\"result\"] = util::ToJSON(*result.second);\n                fprintf(*options.jsonDumpFP, \"%s\\n\", j.dump().c_str());\n            }\n        }\n\n        if ( options.debug == true ) {\n            printf(\"Module %s result:\\n\\n%s\\n\\n\",\n                    result.first->name.c_str(),\n                    result.second == std::nullopt ?\n                        \"(empty)\" :\n                        util::ToString(*result.second).c_str());\n        }\n\n        if ( options.disableTests == false ) {\n            tests::test(op, result.second);\n        }\n\n        postprocess(module, op, result);\n    }\n\n    if ( options.noCompare == false ) {\n        compare(operations, results, data, size);\n    }\n}",
        "file_path": "/src/cryptofuzz/executor.cpp",
        "crashing_line": "        results.push_back( {module, std::move(callModule(module, op))} );",
        "crashing_line_number": 2369
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int blosc_read_header(const uint8_t* src, int32_t srcsize, bool extended_header, blosc_header* header)\n{\n  memset(header, 0, sizeof(blosc_header));\n\n  if (srcsize < BLOSC_MIN_HEADER_LENGTH) {\n    BLOSC_TRACE_ERROR(\"Not enough space to read Blosc header.\");\n    return BLOSC2_ERROR_READ_BUFFER;\n  }\n\n  memcpy(header, src, BLOSC_MIN_HEADER_LENGTH);\n\n  bool little_endian = is_little_endian();\n\n  if (!little_endian) {\n    header->nbytes = bswap32_(header->nbytes);\n    header->blocksize = bswap32_(header->blocksize);\n    header->cbytes = bswap32_(header->cbytes);\n  }\n\n  if (header->version > BLOSC_VERSION_FORMAT) {\n    /* Version from future */\n    return BLOSC2_ERROR_VERSION_SUPPORT;\n  }\n  if (header->cbytes < BLOSC_MIN_HEADER_LENGTH) {\n    BLOSC_TRACE_ERROR(\"`cbytes` is too small to read min header.\");\n    return BLOSC2_ERROR_INVALID_HEADER;\n  }\n  if (header->blocksize <= 0 || header->blocksize > header->nbytes) {\n    BLOSC_TRACE_ERROR(\"`blocksize` is zero or greater than uncompressed size\");\n    return BLOSC2_ERROR_INVALID_HEADER;\n  }\n  if (header->typesize <= 0 || header->typesize > BLOSC_MAX_TYPESIZE) {\n    BLOSC_TRACE_ERROR(\"`typesize` is zero or greater than max allowed.\");\n    return BLOSC2_ERROR_INVALID_HEADER;\n  }\n\n  /* Read extended header if it is wanted */\n  if ((extended_header) && (header->flags & BLOSC_DOSHUFFLE) && (header->flags & BLOSC_DOBITSHUFFLE)) {\n    if (header->cbytes < BLOSC_EXTENDED_HEADER_LENGTH) {\n      BLOSC_TRACE_ERROR(\"`cbytes` is too small to read extended header.\");\n      return BLOSC2_ERROR_INVALID_HEADER;\n    }\n    if (srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {\n      BLOSC_TRACE_ERROR(\"Not enough space to read Blosc extended header.\");\n      return BLOSC2_ERROR_READ_BUFFER;\n    }\n\n    memcpy((uint8_t *)header + BLOSC_MIN_HEADER_LENGTH, src + BLOSC_MIN_HEADER_LENGTH,\n      BLOSC_EXTENDED_HEADER_LENGTH - BLOSC_MIN_HEADER_LENGTH);\n\n    int32_t runlen_type = (header->blosc2_flags >> 4) & BLOSC2_RUNLEN_MASK;\n    if (runlen_type != 0) {\n      if (header->nbytes % header->typesize != 0) {\n        BLOSC_TRACE_ERROR(\"`nbytes` is not a multiple of typesize\");\n        return BLOSC2_ERROR_INVALID_HEADER;\n      }\n      if (runlen_type == BLOSC2_VALUE_RUNLEN) {\n        if (header->cbytes < BLOSC_EXTENDED_HEADER_LENGTH + header->typesize) {\n          BLOSC_TRACE_ERROR(\"`cbytes` is too small for run length encoding\");\n          return BLOSC2_ERROR_READ_BUFFER;\n        }\n      }\n    }\n    // The number of filters depends on the version of the header. Blosc2 alpha series\n    // did not initialize filters to zero beyond the max supported.\n    if (header->version == BLOSC2_VERSION_FORMAT_ALPHA) {\n      header->filter_codes[5] = 0;\n      header->filter_meta[5] = 0;\n    }\n  }\n  else {\n    flags_to_filters(header->flags, header->filter_codes);\n  }\n  return 0;\n}\n",
    "target": 1,
    "idx": 1032040,
    "stack_trace": [
      {
        "function_name": "bshuf_shuffle_bit_eightelem_sse2",
        "function_body": "int64_t bshuf_shuffle_bit_eightelem_sse2(void* in, void* out, const size_t size,\n                                         const size_t elem_size) {\n  /*  With a bit of care, this could be written such that such that it is */\n  /*  in_buf = out_buf safe. */\n  char* in_b = (char*)in;\n  uint16_t* out_ui16 = (uint16_t*)out;\n\n  size_t nbyte = elem_size * size;\n\n  __m128i xmm;\n  int32_t bt;\n  size_t ii, jj, kk;\n  size_t ind;\n\n  CHECK_MULT_EIGHT(size);\n\n  if (elem_size % 2) {\n    bshuf_shuffle_bit_eightelem_scal(in, out, size, elem_size);\n  } else {\n    for (ii = 0; ii + 8 * elem_size - 1 < nbyte;\n         ii += 8 * elem_size) {\n      for (jj = 0; jj + 15 < 8 * elem_size; jj += 16) {\n        xmm = _mm_loadu_si128((__m128i*)&in_b[ii + jj]);\n        for (kk = 0; kk < 8; kk++) {\n          bt = _mm_movemask_epi8(xmm);\n          xmm = _mm_slli_epi16(xmm, 1);\n          ind = (ii + jj / 8 + (7 - kk) * elem_size);\n          out_ui16[ind / 2] = (uint16_t)bt;\n        }\n      }\n    }\n  }\n  return size * elem_size;\n}",
        "file_path": "/src/c-blosc2/blosc/bitshuffle-sse2.c",
        "crashing_line": "          out_ui16[ind / 2] = (uint16_t)bt;",
        "crashing_line_number": 445
      },
      {
        "function_name": "bshuf_shuffle_bit_eightelem_avx2",
        "function_body": "int64_t bshuf_shuffle_bit_eightelem_avx2(void* in, void* out, const size_t size,\n                                         const size_t elem_size) {\n\n  CHECK_MULT_EIGHT(size);\n\n  /*  With a bit of care, this could be written such that such that it is */\n  /*  in_buf = out_buf safe. */\n  char* in_b = (char*)in;\n  char* out_b = (char*)out;\n\n  size_t nbyte = elem_size * size;\n  size_t ii, jj, kk, ind;\n\n  __m256i ymm;\n  int32_t bt;\n\n  if (elem_size % 4) {\n    return bshuf_shuffle_bit_eightelem_sse2(in, out, size, elem_size);\n  } else {\n    for (jj = 0; jj + 31 < 8 * elem_size; jj += 32) {\n      for (ii = 0; ii + 8 * elem_size - 1 < nbyte;\n           ii += 8 * elem_size) {\n        ymm = _mm256_loadu_si256((__m256i*)&in_b[ii + jj]);\n        for (kk = 0; kk < 8; kk++) {\n          bt = _mm256_movemask_epi8(ymm);\n          ymm = _mm256_slli_epi16(ymm, 1);\n          ind = (ii + jj / 8 + (7 - kk) * elem_size);\n          *(int32_t*)&out_b[ind] = bt;\n        }\n      }\n    }\n  }\n  return size * elem_size;\n}",
        "file_path": "/src/c-blosc2/blosc/bitshuffle-avx2.c",
        "crashing_line": "    return bshuf_shuffle_bit_eightelem_sse2(in, out, size, elem_size);",
        "crashing_line_number": 216
      },
      {
        "function_name": "bshuf_untrans_bit_elem_avx2",
        "function_body": "int64_t bshuf_untrans_bit_elem_avx2(void* in, void* out, const size_t size,\n                                    const size_t elem_size, void* tmp_buf) {\n\n  int64_t count;\n\n  CHECK_MULT_EIGHT(size);\n\n  count = bshuf_trans_byte_bitrow_avx2(in, tmp_buf, size, elem_size);\n  CHECK_ERR(count);\n  count = bshuf_shuffle_bit_eightelem_avx2(tmp_buf, out, size, elem_size);\n\n  return count;\n}",
        "file_path": "/src/c-blosc2/blosc/bitshuffle-avx2.c",
        "crashing_line": "  count = bshuf_shuffle_bit_eightelem_avx2(tmp_buf, out, size, elem_size);",
        "crashing_line_number": 245
      },
      {
        "function_name": "bitunshuffle",
        "function_body": "int32_t bitunshuffle(const int32_t bytesoftype, const int32_t blocksize,\n                     const uint8_t *_src, const uint8_t *_dest,\n                     const uint8_t *_tmp, const uint8_t format_version) {\n  /* Initialize the shuffle implementation if necessary. */\n  init_shuffle_implementation();\n  size_t size = blocksize / bytesoftype;\n\n  if (format_version == 2) {\n    /* Starting from version 3, bitshuffle() works differently */\n    if ((size % 8) == 0) {\n      /* The number of elems is a multiple of 8 which is supported by\n         bitshuffle. */\n      int ret = (int) (host_implementation.bitunshuffle)((void *) _src, (void *) _dest,\n                                                   blocksize / bytesoftype,\n                                                   bytesoftype, (void *) _tmp);\n      if (ret < 0) {\n        // Some error in bitshuffle (should not happen)\n        fprintf(stderr, \"the impossible happened: the bitunshuffle filter failed!\");\n        return ret;\n      }\n      /* Copy the leftovers (we do so starting from c-blosc 1.18 on) */\n      size_t offset = size * bytesoftype;\n      memcpy((void *) (_dest + offset), (void *) (_src + offset), blocksize - offset);\n    }\n    else {\n      memcpy((void *) _dest, (void *) _src, blocksize);\n    }\n  }\n  else {\n    /* bitshuffle only supports a number of bytes that is a multiple of 8. */\n    size -= size % 8;\n    int ret = (int) (host_implementation.bitunshuffle)((void *) _src, (void *) _dest,\n                                                 size, bytesoftype, (void *) _tmp);\n    if (ret < 0) {\n      fprintf(stderr, \"the impossible happened: the bitunshuffle filter failed!\");\n      return ret;\n    }\n\n    /* Copy the leftovers */\n    size_t offset = size * bytesoftype;\n    memcpy((void *) (_dest + offset), (void *) (_src + offset), blocksize - offset);\n  }\n\n  return blocksize;\n}",
        "file_path": "/src/c-blosc2/blosc/shuffle.c",
        "crashing_line": "      int ret = (int) (host_implementation.bitunshuffle)((void *) _src, (void *) _dest,",
        "crashing_line_number": 454
      },
      {
        "function_name": "pipeline_d",
        "function_body": "int pipeline_d(struct thread_context* thread_context, const int32_t bsize, uint8_t* dest,\n               const int32_t offset, uint8_t* src, uint8_t* tmp,\n               uint8_t* tmp2, int last_filter_index) {\n  blosc2_context* context = thread_context->parent_context;\n  int32_t typesize = context->typesize;\n  uint8_t* filters = context->filters;\n  uint8_t* filters_meta = context->filters_meta;\n  uint8_t* _src = src;\n  uint8_t* _dest = tmp;\n  uint8_t* _tmp = tmp2;\n  int errcode = 0;\n\n  for (int i = BLOSC2_MAX_FILTERS - 1; i >= 0; i--) {\n    // Delta filter requires the whole chunk ready\n    int last_copy_filter = (last_filter_index == i) || (next_filter(filters, i, 'd') == BLOSC_DELTA);\n    if (last_copy_filter && context->postfilter == NULL) {\n      _dest = dest + offset;\n    }\n    switch (filters[i]) {\n      case BLOSC_SHUFFLE:\n        for (int j = 0; j <= filters_meta[i]; j++) {\n          unshuffle(typesize, bsize, _src, _dest);\n          // Cycle filters when required\n          if (j < filters_meta[i]) {\n            _src = _dest;\n            _dest = _tmp;\n            _tmp = _src;\n          }\n          // Check whether we have to copy the intermediate _dest buffer to final destination\n          if (last_copy_filter && (filters_meta[i] % 2) == 1 && j == filters_meta[i]) {\n            memcpy(dest + offset, _dest, (unsigned int)bsize);\n          }\n        }\n        break;\n      case BLOSC_BITSHUFFLE:\n        if (bitunshuffle(typesize, bsize, _src, _dest, _tmp, context->src[BLOSC2_CHUNK_VERSION]) < 0) {\n          return BLOSC2_ERROR_FILTER_PIPELINE;\n        }\n        break;\n      case BLOSC_DELTA:\n        if (context->nthreads == 1) {\n          /* Serial mode */\n          delta_decoder(dest, offset, bsize, typesize, _dest);\n        } else {\n          /* Force the thread in charge of the block 0 to go first */\n          pthread_mutex_lock(&context->delta_mutex);\n          if (context->dref_not_init) {\n            if (offset != 0) {\n              pthread_cond_wait(&context->delta_cv, &context->delta_mutex);\n            } else {\n              delta_decoder(dest, offset, bsize, typesize, _dest);\n              context->dref_not_init = 0;\n              pthread_cond_broadcast(&context->delta_cv);\n            }\n          }\n          pthread_mutex_unlock(&context->delta_mutex);\n          if (offset != 0) {\n            delta_decoder(dest, offset, bsize, typesize, _dest);\n          }\n        }\n        break;\n      case BLOSC_TRUNC_PREC:\n        // TRUNC_PREC filter does not need to be undone\n        break;\n      default:\n        if (filters[i] != BLOSC_NOFILTER) {\n          BLOSC_TRACE_ERROR(\"Filter %d not handled during decompression.\",\n                            filters[i]);\n\n          errcode = -1;\n        }\n    }\n    // Cycle buffers when required\n    if ((filters[i] != BLOSC_NOFILTER) && (filters[i] != BLOSC_TRUNC_PREC)) {\n      _src = _dest;\n      _dest = _tmp;\n      _tmp = _src;\n    }\n    if (last_filter_index == i) {\n      break;\n    }\n  }\n\n  /* Postfilter function */\n  if (context->postfilter != NULL) {\n    // Create new postfilter parameters for this block (must be private for each thread)\n    blosc2_postfilter_params postparams;\n    memcpy(&postparams, context->postparams, sizeof(postparams));\n    postparams.in = _src;\n    postparams.out = dest + offset;\n    postparams.size = bsize;\n    postparams.typesize = typesize;\n    postparams.offset = offset;\n    postparams.tid = thread_context->tid;\n    postparams.ttmp = thread_context->tmp;\n    postparams.ttmp_nbytes = thread_context->tmp_nbytes;\n    postparams.ctx = context;\n\n    if (context->postfilter(&postparams) != 0) {\n      BLOSC_TRACE_ERROR(\"Execution of postfilter function failed\");\n      return BLOSC2_ERROR_POSTFILTER;\n    }\n  }\n\n  return errcode;\n}",
        "file_path": "/src/c-blosc2/blosc/blosc2.c",
        "crashing_line": "          }",
        "crashing_line_number": 1154
      },
      {
        "function_name": "blosc_d",
        "function_body": "static int blosc_d(\n    struct thread_context* thread_context, int32_t bsize,\n    int32_t leftoverblock, bool memcpyed, const uint8_t* src, int32_t srcsize, int32_t src_offset,\n    int32_t nblock, uint8_t* dest, int32_t dest_offset, uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  uint8_t* filters = context->filters;\n  uint8_t *tmp3 = thread_context->tmp4;\n  int32_t compformat = (context->header_flags & (uint8_t)0xe0) >> 5u;\n  int dont_split = (context->header_flags & (uint8_t)0x10) >> 4u;\n  int32_t chunk_nbytes;\n  int32_t chunk_cbytes;\n  int nstreams;\n  int32_t neblock;\n  int32_t nbytes;                /* number of decompressed bytes in split */\n  int32_t cbytes;                /* number of compressed bytes in split */\n  int32_t ctbytes = 0;           /* number of compressed bytes in block */\n  int32_t ntbytes = 0;           /* number of uncompressed bytes in block */\n  uint8_t* _dest;\n  int32_t typesize = context->typesize;\n  const char* compname;\n  int rc;\n\n  rc = blosc2_cbuffer_sizes(src, &chunk_nbytes, &chunk_cbytes, NULL);\n  if (rc < 0) {\n    return rc;\n  }\n\n  if (context->block_maskout != NULL && context->block_maskout[nblock]) {\n    // Do not decompress, but act as if we successfully decompressed everything\n    return bsize;\n  }\n\n  // In some situations (lazychunks) the context can arrive uninitialized\n  // (but BITSHUFFLE needs it for accessing the format of the chunk)\n  if (context->src == NULL) {\n    context->src = src;\n  }\n\n  // Chunks with special values cannot be lazy\n  bool is_lazy = ((context->header_overhead == BLOSC_EXTENDED_HEADER_LENGTH) &&\n          (context->blosc2_flags & 0x08u) && (context->runlen_type == BLOSC2_NO_RUNLEN));\n  if (is_lazy) {\n    // The chunk is on disk, so just lazily load the block\n    if (context->schunk == NULL) {\n      BLOSC_TRACE_ERROR(\"Lazy chunk needs an associated super-chunk.\");\n      return BLOSC2_ERROR_INVALID_PARAM;\n    }\n    if (context->schunk->frame == NULL) {\n      BLOSC_TRACE_ERROR(\"Lazy chunk needs an associated frame.\");\n      return BLOSC2_ERROR_INVALID_PARAM;\n    }\n    blosc2_frame_s* frame = (blosc2_frame_s*)context->schunk->frame;\n    char* urlpath = frame->urlpath;\n    int32_t trailer_len = sizeof(int32_t) + sizeof(int64_t) + context->nblocks * sizeof(int32_t);\n    size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH + context->nblocks * sizeof(int32_t);\n    int32_t nchunk;\n    int64_t chunk_offset;\n    // The nchunk and the offset of the current chunk are in the trailer\n    nchunk = *(int32_t*)(src + trailer_offset);\n    chunk_offset = *(int64_t*)(src + trailer_offset + sizeof(int32_t));\n    // Get the csize of the nblock\n    int32_t *block_csizes = (int32_t *)(src + trailer_offset + sizeof(int32_t) + sizeof(int64_t));\n    int32_t block_csize = block_csizes[nblock];\n    // Read the lazy block on disk\n    FILE* fp = NULL;\n    if (frame->sframe) {\n      // The chunk is not in the frame\n      char* chunkpath = malloc(strlen(frame->urlpath) + 1 + 8 + strlen(\".chunk\") + 1);\n      BLOSC_ERROR_NULL(chunkpath, BLOSC2_ERROR_MEMORY_ALLOC);\n      sprintf(chunkpath, \"%s/%08X.chunk\", frame->urlpath, nchunk);\n      fp = fopen(chunkpath, \"rb\");\n      free(chunkpath);\n      // The offset of the block is src_offset\n      fseek(fp, src_offset, SEEK_SET);\n    }\n    else {\n      fp = fopen(urlpath, \"rb\");\n      // The offset of the block is src_offset\n      fseek(fp, chunk_offset + src_offset, SEEK_SET);\n    }\n    // We can make use of tmp3 because it will be used after src is not needed anymore\n    size_t rbytes = fread(tmp3, 1, block_csize, fp);\n    fclose(fp);\n    if ((int32_t)rbytes != block_csize) {\n      BLOSC_TRACE_ERROR(\"Cannot read the (lazy) block out of the fileframe.\");\n      return BLOSC2_ERROR_READ_BUFFER;\n    }\n    src = tmp3;\n    src_offset = 0;\n    srcsize = block_csize;\n  }\n\n  // If the chunk is memcpyed, we just have to copy the block to dest and return\n  if (memcpyed) {\n    int bsize_ = leftoverblock ? chunk_nbytes % context->blocksize : bsize;\n    if (context->runlen_type == BLOSC2_NO_RUNLEN) {\n      if (chunk_nbytes + context->header_overhead != chunk_cbytes) {\n        return BLOSC2_ERROR_WRITE_BUFFER;\n      }\n      if (chunk_cbytes < context->header_overhead + (nblock * context->blocksize) + bsize_) {\n        /* Not enough input to copy block */\n        return BLOSC2_ERROR_READ_BUFFER;\n      }\n    }\n    if (!is_lazy) {\n      src += context->header_overhead + nblock * context->blocksize;\n    }\n    _dest = dest + dest_offset;\n    if (context->postfilter != NULL) {\n      // We are making use of a postfilter, so use a temp for destination\n      _dest = tmp;\n    }\n    rc = 0;\n    switch (context->runlen_type) {\n      case BLOSC2_VALUE_RUNLEN:\n        // All repeated values\n        rc = set_values(context->typesize, context->src, _dest, bsize_);\n        if (rc < 0) {\n          BLOSC_TRACE_ERROR(\"set_values failed\");\n          return BLOSC2_ERROR_DATA;\n        }\n        break;\n      case BLOSC2_NAN_RUNLEN:\n        rc = set_nans(context->typesize, _dest, bsize_);\n        if (rc < 0) {\n          BLOSC_TRACE_ERROR(\"set_nans failed\");\n          return BLOSC2_ERROR_DATA;\n        }\n        break;\n      case BLOSC2_ZERO_RUNLEN:\n        memset(_dest, 0, bsize_);\n        break;\n      default:\n        memcpy(_dest, src, bsize_);\n    }\n    if (context->postfilter != NULL) {\n      // Create new postfilter parameters for this block (must be private for each thread)\n      blosc2_postfilter_params postparams;\n      memcpy(&postparams, context->postparams, sizeof(postparams));\n      postparams.in = tmp;\n      postparams.out = dest + dest_offset;\n      postparams.size = bsize;\n      postparams.typesize = typesize;\n      postparams.offset = dest_offset;\n      postparams.tid = thread_context->tid;\n      postparams.ttmp = thread_context->tmp;\n      postparams.ttmp_nbytes = thread_context->tmp_nbytes;\n      postparams.ctx = context;\n\n      // Execute the postfilter (the processed block will be copied to dest)\n      if (context->postfilter(&postparams) != 0) {\n        BLOSC_TRACE_ERROR(\"Execution of postfilter function failed\");\n        return BLOSC2_ERROR_POSTFILTER;\n      }\n    }\n    return bsize_;\n  }\n\n  if (!is_lazy && (src_offset <= 0 || src_offset >= srcsize)) {\n    /* Invalid block src offset encountered */\n    return BLOSC2_ERROR_DATA;\n  }\n\n  src += src_offset;\n  srcsize -= src_offset;\n\n  int last_filter_index = last_filter(filters, 'd');\n\n  if (((last_filter_index >= 0) &&\n      (next_filter(filters, BLOSC2_MAX_FILTERS, 'd') != BLOSC_DELTA)) ||\n      context->postfilter != NULL) {\n   // We are making use of some filter, so use a temp for destination\n   _dest = tmp;\n  } else {\n    // If no filters, or only DELTA in pipeline\n   _dest = dest + dest_offset;\n  }\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !context->use_dict) {\n    // We don't want to split when in a training dict state\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n\n  neblock = bsize / nstreams;\n  if (neblock == 0) {\n    /* Not enough space to output bytes */\n    return -1;\n  }\n  for (int j = 0; j < nstreams; j++) {\n    if (srcsize < (signed)sizeof(int32_t)) {\n      /* Not enough input to read compressed size */\n      return BLOSC2_ERROR_READ_BUFFER;\n    }\n    srcsize -= sizeof(int32_t);\n    cbytes = sw32_(src);      /* amount of compressed bytes */\n    if (cbytes > 0) {\n      if (srcsize < cbytes) {\n        /* Not enough input to read compressed bytes */\n        return BLOSC2_ERROR_READ_BUFFER;\n      }\n      srcsize -= cbytes;\n    }\n    src += sizeof(int32_t);\n    ctbytes += (signed)sizeof(int32_t);\n\n    /* Uncompress */\n    if (cbytes == 0) {\n      // A run of 0's\n      memset(_dest, 0, (unsigned int)neblock);\n      nbytes = neblock;\n    }\n    else if (cbytes < 0) {\n      // A negative number means some encoding depending on the token that comes next\n      uint8_t token;\n\n      if (srcsize < (signed)sizeof(uint8_t)) {\n        // Not enough input to read token */\n        return BLOSC2_ERROR_READ_BUFFER;\n      }\n      srcsize -= sizeof(uint8_t);\n\n      token = src[0];\n      src += 1;\n      ctbytes += 1;\n\n      if (token & 0x1) {\n        // A run of bytes that are different than 0\n        if (cbytes < -255) {\n          // Runs can only encode a byte\n          return BLOSC2_ERROR_RUN_LENGTH;\n        }\n        uint8_t value = -cbytes;\n        memset(_dest, value, (unsigned int)neblock);\n      } else {\n        BLOSC_TRACE_ERROR(\"Invalid or unsupported compressed stream token value - %d\", token);\n        return BLOSC2_ERROR_RUN_LENGTH;\n      }\n      nbytes = neblock;\n      cbytes = 0;  // everything is encoded in the cbytes token\n    }\n    else if (cbytes == neblock) {\n      memcpy(_dest, src, (unsigned int)neblock);\n      nbytes = (int32_t)neblock;\n    }\n    else {\n      if (compformat == BLOSC_BLOSCLZ_FORMAT) {\n        nbytes = blosclz_decompress(src, cbytes, _dest, (int)neblock);\n      }\n  #if defined(HAVE_LZ4)\n      else if (compformat == BLOSC_LZ4_FORMAT) {\n        nbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,\n                                     (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_LZ4 */\n  #if defined(HAVE_SNAPPY)\n      else if (compformat == BLOSC_SNAPPY_FORMAT) {\n        nbytes = snappy_wrap_decompress((char*)src, (size_t)cbytes,\n                                        (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n      else if (compformat == BLOSC_ZLIB_FORMAT) {\n        nbytes = zlib_wrap_decompress((char*)src, (size_t)cbytes,\n                                      (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n      else if (compformat == BLOSC_ZSTD_FORMAT) {\n        nbytes = zstd_wrap_decompress(thread_context,\n                                      (char*)src, (size_t)cbytes,\n                                      (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_ZSTD */\n      else {\n        compname = clibcode_to_clibname(compformat);\n        BLOSC_TRACE_ERROR(\n                \"Blosc has not been compiled with decompression \"\n                \"support for '%s' format.  \"\n                \"Please recompile for adding this support.\", compname);\n        return BLOSC2_ERROR_CODEC_SUPPORT;\n      }\n\n      /* Check that decompressed bytes number is correct */\n      if (nbytes != neblock) {\n        return BLOSC2_ERROR_DATA;\n      }\n\n    }\n    src += cbytes;\n    ctbytes += cbytes;\n    _dest += nbytes;\n    ntbytes += nbytes;\n  } /* Closes j < nstreams */\n\n  if (last_filter_index >= 0 || context->postfilter != NULL) {\n    /* Apply regular filter pipeline */\n    int errcode = pipeline_d(thread_context, bsize, dest, dest_offset, tmp, tmp2, tmp3,\n                             last_filter_index);\n    if (errcode < 0)\n      return errcode;\n  }\n\n  /* Return the number of uncompressed bytes */\n  return (int)ntbytes;\n}",
        "file_path": "/src/c-blosc2/blosc/blosc2.c",
        "crashing_line": "  } /* Closes j < nstreams */",
        "crashing_line_number": 1618
      },
      {
        "function_name": "_blosc_getitem",
        "function_body": "int _blosc_getitem(blosc2_context* context, blosc_header* header, const void* src, int32_t srcsize,\n                   int start, int nitems, void* dest, int32_t destsize) {\n  uint8_t* _src = (uint8_t*)(src);  /* current pos for source buffer */\n  int32_t ntbytes = 0;              /* the number of uncompressed bytes */\n  int32_t bsize, bsize2, ebsize, leftoverblock;\n  int32_t cbytes;\n  int32_t startb, stopb;\n  int32_t stop = start + nitems;\n  int j, rc;\n\n  if (nitems == 0) {\n    // We have nothing to do\n    return 0;\n  }\n  if (nitems * header->typesize > destsize) {\n    BLOSC_TRACE_ERROR(\"`nitems`*`typesize` out of dest bounds.\");\n    return BLOSC2_ERROR_WRITE_BUFFER;\n  }\n\n  context->bstarts = (int32_t*)(_src + context->header_overhead);\n\n  /* Check region boundaries */\n  if ((start < 0) || (start * header->typesize > header->nbytes)) {\n    BLOSC_TRACE_ERROR(\"`start` out of bounds.\");\n    return BLOSC2_ERROR_INVALID_PARAM;\n  }\n\n  if ((stop < 0) || (stop * header->typesize > header->nbytes)) {\n    BLOSC_TRACE_ERROR(\"`start`+`nitems` out of bounds.\");\n    return BLOSC2_ERROR_INVALID_PARAM;\n  }\n\n  if (_src + srcsize < (uint8_t *)(context->bstarts + context->nblocks)) {\n    BLOSC_TRACE_ERROR(\"`bstarts` out of bounds.\");\n    return BLOSC2_ERROR_READ_BUFFER;\n  }\n\n  ebsize = header->blocksize + header->typesize * (signed)sizeof(int32_t);\n\n  for (j = 0; j < context->nblocks; j++) {\n    bsize = header->blocksize;\n    leftoverblock = 0;\n    if ((j == context->nblocks - 1) && (context->leftover > 0)) {\n      bsize = context->leftover;\n      leftoverblock = 1;\n    }\n\n    /* Compute start & stop for each block */\n    startb = start * header->typesize - j * header->blocksize;\n    stopb = stop * header->typesize - j * header->blocksize;\n    if (stopb <= 0) {\n      // We can exit as soon as this block is beyond stop\n      break;\n    }\n    if (startb >= header->blocksize) {\n      continue;\n    }\n    if (startb < 0) {\n      startb = 0;\n    }\n    if (stopb > header->blocksize) {\n      stopb = header->blocksize;\n    }\n    bsize2 = stopb - startb;\n\n    /* Do the actual data copy */\n    struct thread_context* scontext = context->serial_context;\n\n    /* Resize the temporaries in serial context if needed */\n    if (header->blocksize > scontext->tmp_blocksize) {\n      my_free(scontext->tmp);\n      scontext->tmp_nbytes = (size_t)4 * ebsize;\n      scontext->tmp = my_malloc(scontext->tmp_nbytes);\n      BLOSC_ERROR_NULL(scontext->tmp, BLOSC2_ERROR_MEMORY_ALLOC);\n      scontext->tmp2 = scontext->tmp + ebsize;\n      scontext->tmp3 = scontext->tmp2 + ebsize;\n      scontext->tmp4 = scontext->tmp3 + ebsize;\n      scontext->tmp_blocksize = (int32_t)header->blocksize;\n    }\n\n    // Regular decompression.  Put results in tmp2.\n    // If the block is aligned and the worst case fits in destination, let's avoid a copy\n    bool get_single_block = ((startb == 0) && (bsize == nitems * header->typesize));\n    uint8_t* tmp2 = get_single_block ? dest : scontext->tmp2;\n    bool memcpyed = header->flags & (uint8_t)BLOSC_MEMCPYED;\n    if (context->runlen_type != BLOSC2_NO_RUNLEN) {\n      // Fake a runlen as if its a memcpyed chunk\n      memcpyed = true;\n    }\n\n    // If memcpyed we don't have a bstarts section (because it is not needed)\n    int32_t src_offset = memcpyed ?\n      context->header_overhead + j * bsize : sw32_(context->bstarts + j);\n\n    cbytes = blosc_d(context->serial_context, bsize, leftoverblock, memcpyed,\n                     src, srcsize, src_offset, j,\n                     tmp2, 0, scontext->tmp, scontext->tmp3);\n    if (cbytes < 0) {\n      ntbytes = cbytes;\n      break;\n    }\n    if (!get_single_block) {\n      /* Copy to destination */\n      memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);\n    }\n    cbytes = (int)bsize2;\n    ntbytes += cbytes;\n  }\n\n  return ntbytes;\n}",
        "file_path": "/src/c-blosc2/blosc/blosc2.c",
        "crashing_line": "    // If memcpyed we don't have a bstarts section (because it is not needed)",
        "crashing_line_number": 2646
      },
      {
        "function_name": "blosc2_getitem_ctx",
        "function_body": "int blosc2_getitem_ctx(blosc2_context* context, const void* src, int32_t srcsize,\n    int start, int nitems, void* dest, int32_t destsize) {\n  blosc_header header;\n  int result;\n\n  /* Minimally populate the context */\n  result = blosc_read_header((uint8_t *)src, srcsize, true, &header);\n  if (result < 0) {\n    return result;\n  }\n\n  context->src = src;\n  context->srcsize = srcsize;\n  context->dest = dest;\n  context->destsize = destsize;\n\n  result = blosc2_initialize_context_from_header(context, &header);\n  if (result < 0) {\n    return result;\n  }\n\n  if (context->serial_context == NULL) {\n    context->serial_context = create_thread_context(context, 0);\n  }\n  BLOSC_ERROR_NULL(context->serial_context, BLOSC2_ERROR_THREAD_CREATE);\n  /* Call the actual getitem function */\n  result = _blosc_getitem(context, &header, src, srcsize, start, nitems, dest, destsize);\n\n  return result;\n}",
        "file_path": "/src/c-blosc2/blosc/blosc2.c",
        "crashing_line": "    context->serial_context = create_thread_context(context, 0);",
        "crashing_line_number": 2716
      },
      {
        "function_name": "blosc2_getitem",
        "function_body": "int blosc2_getitem(const void* src, int32_t srcsize, int start, int nitems, void* dest, int32_t destsize) {\n  blosc2_context context;\n  int result;\n\n  /* Minimally populate the context */\n  memset(&context, 0, sizeof(blosc2_context));\n\n  context.schunk = g_schunk;\n  context.nthreads = 1;  // force a serial decompression; fixes #95\n\n  /* Call the actual getitem function */\n  result = blosc2_getitem_ctx(&context, src, srcsize, start, nitems, dest, destsize);\n\n  /* Release resources */\n  if (context.serial_context != NULL) {\n    free_thread_context(context.serial_context);\n  }\n  return result;\n}",
        "file_path": "/src/c-blosc2/blosc/blosc2.c",
        "crashing_line": "  context.schunk = g_schunk;",
        "crashing_line_number": 2675
      },
      {
        "function_name": "get_coffset",
        "function_body": "int get_coffset(blosc2_frame_s* frame, int32_t header_len, int64_t cbytes, int32_t nchunk, int64_t *offset) {\n  int32_t off_cbytes;\n  // Get the offset to nchunk\n  uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &off_cbytes);\n  if (coffsets == NULL) {\n    BLOSC_TRACE_ERROR(\"Cannot get the offset for chunk %d for the frame.\", nchunk);\n    return BLOSC2_ERROR_DATA;\n  }\n\n  // Get the 64-bit offset\n  int rc = blosc2_getitem(coffsets, off_cbytes, nchunk, 1, offset, (int32_t)sizeof(int64_t));\n  if (rc < 0) {\n    BLOSC_TRACE_ERROR(\"Problems retrieving a chunk offset.\");\n  } else if (*offset > frame->len) {\n    BLOSC_TRACE_ERROR(\"Cannot read chunk %d outside of frame boundary.\", nchunk);\n    rc = BLOSC2_ERROR_READ_BUFFER;\n  }\n\n  return rc;\n}",
        "file_path": "/src/c-blosc2/blosc/frame.c",
        "crashing_line": "  int rc = blosc2_getitem(coffsets, off_cbytes, nchunk, 1, offset, (int32_t)sizeof(int64_t));",
        "crashing_line_number": 1713
      },
      {
        "function_name": "frame_get_lazychunk",
        "function_body": "int frame_get_lazychunk(blosc2_frame_s *frame, int nchunk, uint8_t **chunk, bool *needs_free) {\n  int32_t header_len;\n  int64_t frame_len;\n  int64_t nbytes;\n  int64_t cbytes;\n  int32_t blocksize;\n  int32_t chunksize;\n  int32_t nchunks;\n  int32_t typesize;\n  int32_t lazychunk_cbytes;\n  int64_t offset;\n  FILE* fp = NULL;\n\n  *chunk = NULL;\n  *needs_free = false;\n  int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,\n                           &blocksize, &chunksize, &nchunks,\n                           &typesize, NULL, NULL, NULL, NULL);\n  if (rc < 0) {\n    BLOSC_TRACE_ERROR(\"Unable to get meta info from frame.\");\n    return rc;\n  }\n\n  if (nchunk >= nchunks) {\n    BLOSC_TRACE_ERROR(\"nchunk ('%d') exceeds the number of chunks \"\n                      \"('%d') in frame.\", nchunk, nchunks);\n    return BLOSC2_ERROR_INVALID_PARAM;\n  }\n\n  // Get the offset to nchunk\n  rc = get_coffset(frame, header_len, cbytes, nchunk, &offset);\n  if (rc < 0) {\n    BLOSC_TRACE_ERROR(\"Unable to get offset to chunk %d.\", nchunk);\n    return rc;\n  }\n\n  if (offset < 0) {\n    // Special value\n    lazychunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;\n    rc = frame_special_chunk(offset, chunksize, typesize, chunk,\n                             (int32_t)lazychunk_cbytes, needs_free);\n    goto end;\n  }\n\n  if (frame->cframe == NULL) {\n    // TODO: make this portable across different endianness\n    // Get info for building a lazy chunk\n    int32_t chunk_nbytes;\n    int32_t chunk_cbytes;\n    int32_t chunk_blocksize;\n    uint8_t header[BLOSC_EXTENDED_HEADER_LENGTH];\n    if (frame->sframe) {\n      // The chunk is not in the frame\n      fp = sframe_open_chunk(frame->urlpath, offset, \"rb\");\n    }\n    else {\n      fp = fopen(frame->urlpath, \"rb\");\n      fseek(fp, header_len + offset, SEEK_SET);\n    }\n    size_t rbytes = fread(header, 1, BLOSC_EXTENDED_HEADER_LENGTH, fp);\n    if (rbytes != BLOSC_EXTENDED_HEADER_LENGTH) {\n      BLOSC_TRACE_ERROR(\"Cannot read the header for chunk in the frame.\");\n      rc = BLOSC2_ERROR_FILE_READ;\n      goto end;\n    }\n    rc = blosc2_cbuffer_sizes(header, &chunk_nbytes, &chunk_cbytes, &chunk_blocksize);\n    if (rc < 0) {\n      goto end;\n    }\n    size_t nblocks = chunk_nbytes / chunk_blocksize;\n    size_t leftover_block = chunk_nbytes % chunk_blocksize;\n    nblocks = leftover_block ? nblocks + 1 : nblocks;\n    // Allocate space for the lazy chunk\n    size_t trailer_len;\n    int32_t runlen_type = (header[BLOSC2_CHUNK_BLOSC2_FLAGS] >> 4) & BLOSC2_RUNLEN_MASK;\n    size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH;\n    if (runlen_type == 0) {\n      // Regular values have offsets for blocks\n      trailer_offset += nblocks * sizeof(int32_t);\n      trailer_len = sizeof(int32_t) + sizeof(int64_t) + nblocks * sizeof(int32_t);\n      lazychunk_cbytes = trailer_offset + trailer_len;\n    }\n    else if (runlen_type == BLOSC2_VALUE_RUNLEN) {\n      trailer_offset += typesize;\n      trailer_len = 0;\n      lazychunk_cbytes = trailer_offset + trailer_len;\n    }\n    else {\n      rc = BLOSC2_ERROR_INVALID_HEADER;\n      goto end;\n    }\n    *chunk = malloc(lazychunk_cbytes);\n    *needs_free = true;\n\n    // Read just the full header and bstarts section too (lazy partial length)\n    if (frame->sframe) {\n      fseek(fp, 0, SEEK_SET);\n    }\n    else {\n      fseek(fp, header_len + offset, SEEK_SET);\n    }\n\n    rbytes = fread(*chunk, 1, trailer_offset, fp);\n    if (rbytes != trailer_offset) {\n      BLOSC_TRACE_ERROR(\"Cannot read the (lazy) chunk out of the frame.\");\n      rc = BLOSC2_ERROR_FILE_READ;\n      goto end;\n    }\n    if (runlen_type == BLOSC2_VALUE_RUNLEN) {\n      // Value runlen is not returning a lazy chunk.  We are done.\n      goto end;\n    }\n\n    // Mark chunk as lazy\n    uint8_t* blosc2_flags = *chunk + BLOSC2_CHUNK_BLOSC2_FLAGS;\n    *blosc2_flags |= 0x08U;\n\n    // Add the trailer (currently, nchunk + offset + block_csizes)\n    if (frame->sframe) {\n      *(int32_t*)(*chunk + trailer_offset) = (int32_t)offset;   // offset is nchunk for sframes\n      *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = offset;\n    }\n    else {\n      *(int32_t*)(*chunk + trailer_offset) = nchunk;\n      *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = header_len + offset;\n    }\n\n    int32_t* block_csizes = malloc(nblocks * sizeof(int32_t));\n\n    int memcpyed = *(*chunk + BLOSC2_CHUNK_FLAGS) & (uint8_t)BLOSC_MEMCPYED;\n    if (memcpyed) {\n      // When memcpyed the blocksizes are trivial to compute\n      for (int i = 0; i < (int)nblocks; i++) {\n        block_csizes[i] = (int)chunk_blocksize;\n      }\n    }\n    else {\n      // In regular, compressed chunks, we need to sort the bstarts (they can be out\n      // of order because of multi-threading), and get a reverse index too.\n      memcpy(block_csizes, *chunk + BLOSC_EXTENDED_HEADER_LENGTH, nblocks * sizeof(int32_t));\n      // Helper structure to keep track of original indexes\n      struct csize_idx *csize_idx = malloc(nblocks * sizeof(struct csize_idx));\n      for (int n = 0; n < (int)nblocks; n++) {\n        csize_idx[n].val = block_csizes[n];\n        csize_idx[n].idx = n;\n      }\n      qsort(csize_idx, nblocks, sizeof(struct csize_idx), &sort_offset);\n      // Compute the actual csizes\n      int idx;\n      for (int n = 0; n < (int)nblocks - 1; n++) {\n        idx = csize_idx[n].idx;\n        block_csizes[idx] = csize_idx[n + 1].val - csize_idx[n].val;\n      }\n      idx = csize_idx[nblocks - 1].idx;\n      block_csizes[idx] = (int)chunk_cbytes - csize_idx[nblocks - 1].val;\n      free(csize_idx);\n    }\n    // Copy the csizes at the end of the trailer\n    void *trailer_csizes = *chunk + lazychunk_cbytes - nblocks * sizeof(int32_t);\n    memcpy(trailer_csizes, block_csizes, nblocks * sizeof(int32_t));\n    free(block_csizes);\n  } else {\n    // The chunk is in memory and just one pointer away\n    int64_t chunk_header_offset = header_len + offset;\n    int64_t chunk_cbytes_offset = chunk_header_offset + BLOSC_MIN_HEADER_LENGTH;\n\n    *chunk = frame->cframe + chunk_header_offset;\n\n    if (chunk_cbytes_offset > frame->len) {\n      BLOSC_TRACE_ERROR(\"Cannot read the header for chunk in the (contiguous) frame.\");\n      rc = BLOSC2_ERROR_READ_BUFFER;\n    } else {\n      rc = blosc2_cbuffer_sizes(*chunk, NULL, &lazychunk_cbytes, NULL);\n      if (rc && chunk_cbytes_offset + lazychunk_cbytes > frame_len) {\n        BLOSC_TRACE_ERROR(\"Compressed bytes exceed beyond frame length.\");\n        rc = BLOSC2_ERROR_READ_BUFFER;\n      }\n    }\n  }\n\n  end:\n  if (fp != NULL) {\n    fclose(fp);\n  }\n  if (rc < 0) {\n    if (*needs_free) {\n      free(*chunk);\n      *chunk = NULL;\n    }\n    return rc;\n  }\n\n  return (int)lazychunk_cbytes;\n}",
        "file_path": "/src/c-blosc2/blosc/frame.c",
        "crashing_line": "  rc = get_coffset(frame, header_len, cbytes, nchunk, &offset);",
        "crashing_line_number": 1904
      },
      {
        "function_name": "frame_decompress_chunk",
        "function_body": "int frame_decompress_chunk(blosc2_context *dctx, blosc2_frame_s* frame, int nchunk, void *dest, int32_t nbytes) {\n  uint8_t* src;\n  bool needs_free;\n  int32_t chunk_nbytes;\n  int32_t chunk_cbytes;\n  int rc;\n\n  // Use a lazychunk here in order to do a potential parallel read.\n  rc = frame_get_lazychunk(frame, nchunk, &src, &needs_free);\n  if (rc < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot get the chunk in position %d.\", nchunk);\n    return rc;\n  }\n  chunk_cbytes = rc;\n  if (chunk_cbytes < (signed)sizeof(int32_t)) {\n    /* Not enough input to read `nbytes` */\n    return BLOSC2_ERROR_READ_BUFFER;\n  }\n\n  rc = blosc2_cbuffer_sizes(src, &chunk_nbytes, &chunk_cbytes, NULL);\n  if (rc < 0) {\n    return rc;\n  }\n\n  /* Create a buffer for destination */\n  if (chunk_nbytes > (size_t)nbytes) {\n    BLOSC_TRACE_ERROR(\"Not enough space for decompressing in dest.\");\n    return BLOSC2_ERROR_WRITE_BUFFER;\n  }\n  /* And decompress it */\n  dctx->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;\n  int32_t chunksize = blosc2_decompress_ctx(dctx, src, chunk_cbytes, dest, nbytes);\n  if (chunksize < 0 || chunksize != chunk_nbytes) {\n    BLOSC_TRACE_ERROR(\"Error in decompressing chunk.\");\n    if (chunksize < 0)\n      return chunksize;\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (needs_free) {\n    free(src);\n  }\n  return (int)chunksize;\n}",
        "file_path": "/src/c-blosc2/blosc/frame.c",
        "crashing_line": "  rc = frame_get_lazychunk(frame, nchunk, &src, &needs_free);",
        "crashing_line_number": 2785
      },
      {
        "function_name": "blosc2_schunk_decompress_chunk",
        "function_body": "int blosc2_schunk_decompress_chunk(blosc2_schunk *schunk, int nchunk,\n                                   void *dest, int32_t nbytes) {\n  int32_t chunk_nbytes;\n  int32_t chunk_cbytes;\n  int chunksize;\n  int rc;\n  blosc2_frame_s* frame = (blosc2_frame_s*)schunk->frame;\n\n  if (frame == NULL) {\n    if (nchunk >= schunk->nchunks) {\n      BLOSC_TRACE_ERROR(\"nchunk ('%d') exceeds the number of chunks \"\n                        \"('%d') in super-chunk.\", nchunk, schunk->nchunks);\n      return BLOSC2_ERROR_INVALID_PARAM;\n    }\n    uint8_t* src = schunk->data[nchunk];\n    if (src == 0) {\n      return 0;\n    }\n\n    rc = blosc2_cbuffer_sizes(src, &chunk_nbytes, &chunk_cbytes, NULL);\n    if (rc < 0) {\n      return rc;\n    }\n\n    if (nbytes < chunk_nbytes) {\n      BLOSC_TRACE_ERROR(\"Buffer size is too small for the decompressed buffer \"\n                        \"('%d' bytes, but '%d' are needed).\", nbytes, chunk_nbytes);\n      return BLOSC2_ERROR_INVALID_PARAM;\n    }\n\n    chunksize = blosc2_decompress_ctx(schunk->dctx, src, chunk_cbytes, dest, nbytes);\n    if (chunksize < 0 || chunksize != chunk_nbytes) {\n      BLOSC_TRACE_ERROR(\"Error in decompressing chunk.\");\n      if (chunksize < 0)\n        return chunksize;\n      return BLOSC2_ERROR_FAILURE;\n    }\n  } else {\n    chunksize = frame_decompress_chunk(schunk->dctx, frame, nchunk, dest, nbytes);\n    if (chunksize < 0) {\n      return chunksize;\n    }\n  }\n  return chunksize;\n}",
        "file_path": "/src/c-blosc2/blosc/schunk.c",
        "crashing_line": "    chunksize = frame_decompress_chunk(schunk->dctx, frame, nchunk, dest, nbytes);",
        "crashing_line_number": 819
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static void\nudiv(mrb_state *mrb, mpz_t *qq, mpz_t *rr, mpz_t *xx, mpz_t *yy)\n{\n  /* simple cases */\n  int cmp = ucmp(xx, yy);\n  if (cmp == 0) {\n    mpz_set_int(mrb, qq, 1);\n    zero(rr);\n    return;\n  }\n  else if (cmp < 0) {\n    zero(qq);\n    mpz_set(mrb, rr, xx);\n    return;\n  }\n\n  mpz_t q, x, y;\n  size_t i;\n\n  mrb_assert(!uzero(yy));       /* divided by zero */\n  mpz_init(mrb, &q);\n  mpz_init(mrb, &x);\n  mpz_init(mrb, &y);\n  mpz_realloc(mrb, &x, xx->sz+1);\n  size_t yd = digits(yy);\n  size_t ns = lzb(yy->p[yd-1]);\n  ulshift(mrb, &x, xx, ns);\n  ulshift(mrb, &y, yy, ns);\n  size_t xd = digits(&x);\n  mpz_realloc(mrb, &q, xd);\n  mp_dbl_limb z = y.p[yd-1];\n  for (size_t j=xd-yd;; j--) {\n    mp_dbl_limb_signed b=0;\n    mp_dbl_limb qhat;\n\n    if (j+yd == xd)\n      qhat = x.p[j+yd-1] / z;\n    else\n      qhat = (((mp_dbl_limb)x.p[j+yd] << DIG_SIZE) + x.p[j+yd-1]) / z;\n    if (qhat) {\n      for (i=0; i<yd; i++) {\n        mp_dbl_limb zz = qhat * y.p[i];\n        mp_dbl_limb_signed u = LOW(b)+x.p[i+j]-LOW(zz);\n        x.p[i+j] = LOW(u);\n        b = HIGH(b) - HIGH(zz) + HIGH(u);\n      }\n      b += x.p[i+j];\n    }\n    for (; b!=0; qhat--) {\n      mp_dbl_limb c = 0;\n      for (i=0; i<yd; i++) {\n        c += (mp_dbl_limb)x.p[i+j] + (mp_dbl_limb)y.p[i];\n        x.p[i+j] = LOW(c);\n        c = HIGH(c);\n      }\n      b += c;\n    }\n    q.p[j] = (mp_limb)qhat;\n    if (j == 0) break;\n  }\n  x.sz = yy->sz;\n  urshift(mrb, rr, &x, ns);\n  trim(&q);\n  mpz_move(mrb, qq, &q);\n  mpz_clear(mrb, &x);\n  mpz_clear(mrb, &y);\n}\n",
    "target": 1,
    "idx": 1049845,
    "stack_trace": [
      {
        "function_name": "udiv",
        "function_body": "static void\nudiv(mrb_state *mrb, mpz_t *qq, mpz_t *rr, mpz_t *xx, mpz_t *yy)\n{\n  /* simple cases */\n  int cmp = ucmp(xx, yy);\n  if (cmp == 0) {\n    mpz_set_int(mrb, qq, 1);\n    zero(rr);\n    return;\n  }\n  else if (cmp < 0) {\n    zero(qq);\n    mpz_set(mrb, rr, xx);\n    return;\n  }\n\n  mpz_t q, x, y;\n  size_t i;\n\n  mrb_assert(!uzero(yy));       /* divided by zero */\n  mpz_init(mrb, &q);\n  mpz_init(mrb, &x);\n  mpz_init(mrb, &y);\n  mpz_realloc(mrb, &x, xx->sz+1);\n  size_t yd = digits(yy);\n  size_t ns = lzb(yy->p[yd-1]);\n  ulshift(mrb, &x, xx, ns);\n  ulshift(mrb, &y, yy, ns);\n  size_t xd = digits(&x);\n  mpz_realloc(mrb, &q, xd);\n  mp_dbl_limb z = y.p[yd-1];\n  if (xd>=yd) {\n    for (size_t j=xd-yd;; j--) {\n      mp_dbl_limb_signed b=0;\n      mp_dbl_limb qhat;\n\n      if (j+yd == xd)\n        qhat = x.p[j+yd-1] / z;\n      else\n        qhat = (((mp_dbl_limb)x.p[j+yd] << DIG_SIZE) + x.p[j+yd-1]) / z;\n      if (qhat) {\n        for (i=0; i<yd; i++) {\n          mp_dbl_limb zz = qhat * y.p[i];\n          mp_dbl_limb_signed u = LOW(b)+x.p[i+j]-LOW(zz);\n          x.p[i+j] = LOW(u);\n          b = HIGH(b) - HIGH(zz) + HIGH(u);\n        }\n        b += x.p[i+j];\n      }\n      for (; b!=0; qhat--) {\n        mp_dbl_limb c = 0;\n        for (i=0; i<yd; i++) {\n          c += (mp_dbl_limb)x.p[i+j] + (mp_dbl_limb)y.p[i];\n          x.p[i+j] = LOW(c);\n          c = HIGH(c);\n        }\n        b += c;\n      }\n      q.p[j] = (mp_limb)qhat;\n      if (j == 0) break;\n    }\n  }\n  x.sz = yy->sz;\n  urshift(mrb, rr, &x, ns);\n  trim(&q);\n  mpz_move(mrb, qq, &q);\n  mpz_clear(mrb, &x);\n  mpz_clear(mrb, &y);\n}",
        "file_path": "/src/mruby/mrbgems/mruby-bigint/core/bigint.c",
        "crashing_line": "      }",
        "crashing_line_number": 488
      },
      {
        "function_name": "mpz_mmod",
        "function_body": "static void\nmpz_mmod(mrb_state *mrb, mpz_t *r, mpz_t *x, mpz_t *y)\n{\n  mpz_t q;\n  short sn1 = x->sn, sn2 = y->sn, sn3;\n\n  mpz_init(mrb, &q);\n  if (sn1 == 0) {\n    zero(r);\n    return;\n  }\n  udiv(mrb, &q, r, x, y);\n  mpz_clear(mrb, &q);\n  if (uzero(r)) {\n    r->sn = 0;\n    return;\n  }\n  sn3 = sn1*sn2;\n  if (sn3 > 0)\n    r->sn = sn1;\n  else if (sn1 < 0 && sn2 > 0) {\n    r->sn = 1;\n    mpz_sub(mrb, r, y, r);\n  }\n  else {\n    r->sn = 1;\n    mpz_add(mrb, r, y, r);\n  }\n}",
        "file_path": "/src/mruby/mrbgems/mruby-bigint/core/bigint.c",
        "crashing_line": "    return;",
        "crashing_line_number": 531
      },
      {
        "function_name": "mrb_bint_mod",
        "function_body": "mrb_value\nmrb_bint_mod(mrb_state *mrb, mrb_value x, mrb_value y)\n{\n#ifndef MRB_NO_FLOAT\n  if (mrb_float_p(y)) {\n    mrb_float v1 = mrb_bint_as_float(mrb, x);\n    mrb_float v2 = mrb_float(y);\n    return mrb_float_value(mrb, fmod(v1, v2));\n  }\n#endif\n  if (mrb_integer_p(y) && mrb_integer(y) == 0) {\n    mrb_int_zerodiv(mrb);\n  }\n  y = mrb_as_bint(mrb, y);\n  struct RBigint *b = RBIGINT(x);\n  struct RBigint *b2 = RBIGINT(y);\n  struct RBigint *b3 = bint_new(mrb);\n  if (b2->mp.sn == 0 || uzero(&b2->mp)) {\n    mrb_int_zerodiv(mrb);\n  }\n  mpz_mmod(mrb, &b3->mp, &b->mp, &b2->mp);\n  return bint_norm(mrb, b3);\n}",
        "file_path": "/src/mruby/mrbgems/mruby-bigint/core/bigint.c",
        "crashing_line": "    mrb_int_zerodiv(mrb);",
        "crashing_line_number": 1241
      },
      {
        "function_name": "int_mod",
        "function_body": "static mrb_value\nint_mod(mrb_state *mrb, mrb_value x)\n{\n  mrb_value y = mrb_get_arg1(mrb);\n  mrb_int a, b;\n\n#ifdef MRB_USE_BIGINT\n  if (mrb_bigint_p(x)) {\n    return mrb_bint_mod(mrb, x, y);\n  }\n#endif\n  a = mrb_integer(x);\n  if (a == 0) return x;\n  if (mrb_integer_p(y)) {\n    b = mrb_integer(y);\n    if (b == 0) mrb_int_zerodiv(mrb);\n    if (a == MRB_INT_MIN && b == -1) return mrb_fixnum_value(0);\n    mrb_int mod = a % b;\n    if ((a < 0) != (b < 0) && mod != 0) {\n      mod += b;\n    }\n    return mrb_int_value(mrb, mod);\n  }\n#ifdef MRB_NO_FLOAT\n  mrb_raise(mrb, E_TYPE_ERROR, \"non integer modulo\");\n#else\n  mrb_float mod;\n\n  flodivmod(mrb, (mrb_float)a, mrb_as_float(mrb, y), NULL, &mod);\n  return mrb_float_value(mrb, mod);\n#endif\n}",
        "file_path": "/src/mruby/src/numeric.c",
        "crashing_line": "    return mrb_bint_mod(mrb, x, y);",
        "crashing_line_number": 1240
      },
      {
        "function_name": "mrb_vm_run",
        "function_body": "MRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}",
        "file_path": "/src/mruby/src/vm.c",
        "crashing_line": "  result = mrb_vm_exec(mrb, proc, irep->iseq);",
        "crashing_line_number": 1279
      },
      {
        "function_name": "FuzzRB",
        "function_body": "int FuzzRB(const uint8_t *Data, size_t size) {\n  mrb_value v;\n  mrb_state *mrb = mrb_open();\n  if (!mrb)\n    return 0;\n\n  char *code = (char *)malloc(size+1);\n  if (!code)\n    return 0;\n  memcpy(code, Data, size);\n  code[size] = '\\0';\n\n  if (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n    // With libFuzzer binary run this to generate an RB file x.rb:\n    // PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n    std::ofstream of(dump_path);\n    of.write(code, size);\n  }\n  std::cout << \"\\n\\n############\\n\" << code << \"\\n############\\n\\n\";\n  v = mrb_load_string(mrb, code);\n  mrb_close(mrb);\n\n  free(code);\n  return 0;\n}",
        "file_path": "/src/mruby/oss-fuzz/mruby_proto_fuzzer.cpp",
        "crashing_line": "  v = mrb_load_string(mrb, code);",
        "crashing_line_number": 34
      },
      {
        "function_name": "TestOneProtoInput",
        "function_body": "",
        "file_path": "/src/mruby/oss-fuzz/mruby_proto_fuzzer.cpp",
        "crashing_line": "",
        "crashing_line_number": 44
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "IM3CodePage  NewCodePage  (IM3Runtime i_runtime, u32 i_minNumLines)\n{\n    IM3CodePage page;\n\n    u32 pageSize = sizeof (M3CodePageHeader) + sizeof (code_t) * i_minNumLines;\n\n    pageSize = (pageSize + (d_m3CodePageAlignSize-1)) & ~(d_m3CodePageAlignSize-1); // align\n    page = (IM3CodePage)m3_Malloc (\"M3CodePage\", pageSize);\n\n    if (page)\n    {\n        page->info.sequence = ++i_runtime->newCodePageSequence;\n        page->info.numLines = (pageSize - sizeof (M3CodePageHeader)) / sizeof (code_t);\n\n#if d_m3RecordBacktraces\n        u32 pageSizeBt = sizeof (M3CodeMappingPage) + sizeof (M3CodeMapEntry) * page->info.numLines;\n        page->info.mapping = (M3CodeMappingPage *)m3_Malloc (\"M3CodeMappingPage\", pageSizeBt);\n\n        if (page->info.mapping)\n        {\n            page->info.mapping->size = 0;\n            page->info.mapping->capacity = page->info.numLines;\n        }\n        else\n        {\n            m3_Free (page);\n            return NULL;\n        }\n        page->info.mapping->basePC = GetPageStartPC(page);\n#endif // d_m3RecordBacktraces\n\n        m3log (runtime, \"new page: %p; seq: %d; bytes: %d; lines: %d\", GetPagePC (page), page->info.sequence, pageSize, page->info.numLines);\n    }\n\n    return page;\n}\nstatic inline\nvoid  TouchSlot  (IM3Compilation o, u16 i_slot)\n{\n    if (o->function)\n    {\n        // op_Entry uses this value to track and detect stack overflow\n        o->maxStackSlots = M3_MAX (o->maxStackSlots, i_slot + 1);\n    }\n}\nstatic\nM3Result  CompileElseBlock  (IM3Compilation o, pc_t * o_startPC, IM3FuncType i_blockType)\n{\n_try {\n\n    IM3CodePage elsePage;\n_   (AcquireCompilationCodePage (o, & elsePage));\n\n    * o_startPC = GetPagePC (elsePage);\n\n    IM3CodePage savedPage = o->page;\n    o->page = elsePage;\n\n_   (CompileBlock (o, i_blockType, c_waOp_else));\n\n_   (EmitOp (o, op_Branch));\n    EmitPointer (o, GetPagePC (savedPage));\n\n    ReleaseCompilationCodePage (o);\n\n    o->page = savedPage;\n\n} _catch:\n    return result;\n}\nM3Result  CompileBlock  (IM3Compilation o, IM3FuncType i_blockType, m3opcode_t i_blockOpcode)\n{\n                                                                                        d_m3Assert (not IsRegisterAllocated (o, 0));\n                                                                                        d_m3Assert (not IsRegisterAllocated (o, 1));\n    M3CompilationScope outerScope = o->block;\n    M3CompilationScope * block = & o->block;\n\n    block->outer            = & outerScope;\n    block->pc               = GetPagePC (o->page);\n    block->patches          = NULL;\n    block->type             = i_blockType;\n    block->depth            ++;\n    block->opcode           = i_blockOpcode;\n\n    /*\n     The block stack frame is a little strange but for good reasons.  Because blocks need to be restarted to\n     compile different pathways (if/else), the incoming params must be saved.  The parameters are popped\n     and validated.  But, then the stack top is readjusted so they aren't subsequently overwritten.\n     Next, the result are preallocated to find destination slots.  But again these are immediately popped\n     (deallocated) and the stack top is readjusted to keep these records in pace. This allows branch instructions\n     to find their result landing pads.  Finally, the params are copied from the \"dead\" records and pushed back\n     onto the stack as active stack items for the CompileBlockStatements () call.\n\n    [     block      ]\n    [     params     ]\n    ------------------\n    [     result     ]  <---- blockStackIndex\n    [      slots     ]\n    ------------------\n    [   saved param  ]\n    [     records    ]\n                        <----- exitStackIndex\n    */\n\n_try {\n    // validate and dealloc params ----------------------------\n\n    u16 stackIndex = o->stackIndex;\n\n    u16 numParams = GetFuncTypeNumParams (i_blockType);\n\n    if (i_blockOpcode != c_waOp_else)\n    {\n        for (u16 i = 0; i < numParams; ++i)\n        {\n            u8 type = GetFuncTypeParamType (i_blockType, numParams - 1 - i);\n_           (PopType (o, type));\n        }\n    }\n    else o->stackIndex -= numParams;\n\n    u16 paramIndex = o->stackIndex;\n    block->exitStackIndex = paramIndex; // consume the params at block exit\n\n    // keep copies of param slots in the stack\n    o->stackIndex = stackIndex;\n\n    // find slots for the results ----------------------------\n    PushBlockResults (o);\n\n    stackIndex = o->stackIndex;\n\n    // dealloc but keep record of the result slots in the stack\n    u16 numResults = GetFuncTypeNumResults (i_blockType);\n    while (numResults--)\n        Pop (o);\n\n    block->blockStackIndex = o->stackIndex = stackIndex;\n\n    // push the params back onto the stack -------------------\n    for (u16 i = 0; i < numParams; ++i)\n    {\n        u8 type = GetFuncTypeParamType (i_blockType, i);\n\n        u16 slot = GetSlotForStackIndex (o, paramIndex + i);\n        Push (o, type, slot);\n\n        if (slot >= o->slotFirstDynamicIndex)\n            MarkSlotsAllocatedByType (o, slot, type);\n    }\n\n    //--------------------------------------------------------\n\n_   (CompileBlockStatements (o));\n\n_   (ValidateBlockEnd (o));\n\n    if (o->function)    // skip for expressions\n    {\n        if (not IsStackPolymorphic (o))\n_           (ResolveBlockResults (o, & o->block, /* isBranch: */ false));\n\n_       (UnwindBlockStack (o))\n\n        if (not ((i_blockOpcode == c_waOp_if and numResults) or o->previousOpcode == c_waOp_else))\n        {\n            o->stackIndex = o->block.exitStackIndex;\n_           (PushBlockResults (o));\n        }\n    }\n\n    PatchBranches (o);\n\n    o->block = outerScope;\n\n}   _catch: return result;\n}\n",
    "target": 1,
    "idx": 1033457,
    "stack_trace": [
      {
        "function_name": "NewCodePage",
        "function_body": "IM3CodePage  NewCodePage  (IM3Runtime i_runtime, u32 i_minNumLines)\n{\n    IM3CodePage page;\n\n    // check multiplication overflow\n    if (i_minNumLines > UINT_MAX / sizeof (code_t)) {\n        return NULL;\n    }\n    u32 pageSize = sizeof (M3CodePageHeader) + sizeof (code_t) * i_minNumLines;\n\n    // check addition overflow\n    if (pageSize < sizeof (M3CodePageHeader)) {\n        return NULL;\n    }\n\n    pageSize = (pageSize + (d_m3CodePageAlignSize-1)) & ~(d_m3CodePageAlignSize-1); // align\n    // check alignment overflow\n    if (pageSize == 0) {\n        return NULL;\n    }\n\n    page = (IM3CodePage)m3_Malloc (\"M3CodePage\", pageSize);\n\n    if (page)\n    {\n        page->info.sequence = ++i_runtime->newCodePageSequence;\n        page->info.numLines = (pageSize - sizeof (M3CodePageHeader)) / sizeof (code_t);\n\n#if d_m3RecordBacktraces\n        u32 pageSizeBt = sizeof (M3CodeMappingPage) + sizeof (M3CodeMapEntry) * page->info.numLines;\n        page->info.mapping = (M3CodeMappingPage *)m3_Malloc (\"M3CodeMappingPage\", pageSizeBt);\n\n        if (page->info.mapping)\n        {\n            page->info.mapping->size = 0;\n            page->info.mapping->capacity = page->info.numLines;\n        }\n        else\n        {\n            m3_Free (page);\n            return NULL;\n        }\n        page->info.mapping->basePC = GetPageStartPC(page);\n#endif // d_m3RecordBacktraces\n\n        m3log (runtime, \"new page: %p; seq: %d; bytes: %d; lines: %d\", GetPagePC (page), page->info.sequence, pageSize, page->info.numLines);\n    }\n\n    return page;\n}",
        "file_path": "/src/wasm3/source/m3_code.c",
        "crashing_line": "    // check addition overflow",
        "crashing_line_number": 25
      },
      {
        "function_name": "AcquireCodePageWithCapacity",
        "function_body": "IM3CodePage  AcquireCodePageWithCapacity  (IM3Runtime i_runtime, u32 i_minLineCount)\n{\n    IM3CodePage page = RemoveCodePageOfCapacity (& i_runtime->pagesOpen, i_minLineCount);\n\n    if (not page)\n    {\n        page = Environment_AcquireCodePage (i_runtime->environment, i_minLineCount);\n\n        if (not page)\n            page = NewCodePage (i_runtime, i_minLineCount);\n\n        if (page)\n            i_runtime->numCodePages++;\n    }\n\n    if (page)\n    {                                                            m3log (emit, \"acquire page: %d\", page->info.sequence);\n        i_runtime->numActiveCodePages++;\n    }\n\n    return page;\n}",
        "file_path": "/src/wasm3/source/m3_env.c",
        "crashing_line": "            page = NewCodePage (i_runtime, i_minLineCount);",
        "crashing_line_number": 1059
      },
      {
        "function_name": "EnsureCodePageNumLines",
        "function_body": "static M3_NOINLINE\nM3Result  EnsureCodePageNumLines  (IM3Compilation o, u32 i_numLines)\n{\n    M3Result result = m3Err_none;\n\n    i_numLines += 2; // room for Bridge\n\n    if (NumFreeLines (o->page) < i_numLines)\n    {\n        IM3CodePage page = AcquireCodePageWithCapacity (o->runtime, i_numLines);\n\n        if (page)\n        {\n            m3log (emit, \"bridging new code page from: %d %p (free slots: %d) to: %d\", o->page->info.sequence, GetPC (o), NumFreeLines (o->page), page->info.sequence);\n            d_m3Assert (NumFreeLines (o->page) >= 2);\n\n            EmitWord (o->page, op_Branch);\n            EmitWord (o->page, GetPagePC (page));\n\n            ReleaseCodePage (o->runtime, o->page);\n\n            o->page = page;\n        }\n        else result = m3Err_mallocFailedCodePage;\n    }\n\n    return result;\n}",
        "file_path": "/src/wasm3/source/m3_compile.c",
        "crashing_line": "        IM3CodePage page = AcquireCodePageWithCapacity (o->runtime, i_numLines);",
        "crashing_line_number": 34
      },
      {
        "function_name": "Compile_BranchTable",
        "function_body": "static\nM3Result  Compile_BranchTable  (IM3Compilation o, m3opcode_t i_opcode)\n{\n_try {\n    u32 targetCount;\n_   (ReadLEB_u32 (& targetCount, & o->wasm, o->wasmEnd));\n\n_   (PreserveRegisterIfOccupied (o, c_m3Type_i64));         // move branch operand to a slot\n    u16 slot = GetStackTopSlotNumber (o);\n_   (Pop (o));\n\n    // OPTZ: according to spec: \"forward branches that target a control instruction with a non-empty\n    // result type consume matching operands first and push them back on the operand stack after unwinding\"\n    // So, this move-to-reg is only necessary if the target scopes have a type.\n\n    u32 numCodeLines = targetCount + 4; // 3 => IM3Operation + slot + target_count + default_target\n_   (EnsureCodePageNumLines (o, numCodeLines));\n\n_   (EmitOp (o, op_BranchTable));\n    EmitSlotOffset (o, slot);\n    EmitConstant32 (o, targetCount);\n\n    IM3CodePage continueOpPage = NULL;\n\n    ++targetCount; // include default\n    for (u32 i = 0; i < targetCount; ++i)\n    {\n        u32 target;\n_       (ReadLEB_u32 (& target, & o->wasm, o->wasmEnd));\n\n        IM3CompilationScope scope;\n_       (GetBlockScope (o, & scope, target));\n\n        // TODO: don't need codepage rigmarole for\n        // no-param forward-branch targets\n\n_       (AcquireCompilationCodePage (o, & continueOpPage));\n\n        pc_t startPC = GetPagePC (continueOpPage);\n        IM3CodePage savedPage = o->page;\n        o->page = continueOpPage;\n\n        if (scope->opcode == c_waOp_loop)\n        {\n_           (ResolveBlockResults (o, scope, true));\n\n_           (EmitOp (o, op_ContinueLoop));\n            EmitPointer (o, scope->pc);\n        }\n        else\n        {\n            // TODO: this could be fused with equivalent targets\n            if (not IsStackPolymorphic (o))\n            {\n                if (scope->depth == 0)\n                {\n_                   (ReturnValues (o, scope, true));\n_                   (EmitOp (o, op_Return));\n                }\n                else\n                {\n_                   (ResolveBlockResults (o, scope, true));\n\n_                   (EmitPatchingBranch (o, scope));\n                }\n            }\n        }\n\n        ReleaseCompilationCodePage (o);     // FIX: continueOpPage can get lost if thrown\n        o->page = savedPage;\n\n        EmitPointer (o, startPC);\n    }\n\n_   (SetStackPolymorphic (o));\n\n    }\n\n    _catch: return result;\n}",
        "file_path": "/src/wasm3/source/m3_compile.c",
        "crashing_line": "    EmitSlotOffset (o, slot);",
        "crashing_line_number": 1546
      },
      {
        "function_name": "CompileBlockStatements",
        "function_body": "M3Result  CompileBlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n    bool validEnd = false;\n\n    while (o->wasm < o->wasmEnd)\n    {\n# if d_m3EnableOpTracing\n        if (o->numEmits)\n        {\n            EmitOp          (o, op_DumpStack);\n            EmitConstant32  (o, o->numOpcodes);\n            EmitConstant32  (o, GetMaxUsedSlotPlusOne(o));\n            EmitPointer     (o, o->function);\n\n            o->numEmits = 0;\n        }\n# endif\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        // Restrict opcodes when evaluating expressions\n        if (not o->function) {\n            switch (opcode) {\n            case c_waOp_i32_const: case c_waOp_i64_const:\n            case c_waOp_f32_const: case c_waOp_f64_const:\n            case c_waOp_getGlobal: case c_waOp_end:\n                break;\n            default:\n                _throw(m3Err_restrictedOpcode);\n            }\n        }\n\n        IM3OpInfo opinfo = GetOpInfo (opcode);\n\n        if (opinfo == NULL)\n            _throw (ErrorCompile (m3Err_unknownOpcode, o, \"opcode '%x' not available\", opcode));\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;\n\n        if (opcode == c_waOp_else)\n        {\n            _throwif (m3Err_wasmMalformed, o->block.opcode != c_waOp_if);\n            validEnd = true;\n            break;\n        }\n        else if (opcode == c_waOp_end)\n        {\n            validEnd = true;\n            break;\n        }\n    }\n    _throwif(m3Err_wasmMalformed, !(validEnd));\n\n_catch:\n    return result;\n}",
        "file_path": "/src/wasm3/source/m3_compile.c",
        "crashing_line": "",
        "crashing_line_number": 2608
      },
      {
        "function_name": "CompileFunction",
        "function_body": "M3Result  CompileFunction  (IM3Function io_function)\n{\n    if (!io_function->wasm) return \"function body is missing\";\n\n    IM3FuncType funcType = io_function->funcType;                   m3log (compile, \"compiling: [%d] %s %s; wasm-size: %d\",\n                                                                        io_function->index, m3_GetFunctionName (io_function), SPrintFuncTypeSignature (funcType), (u32) (io_function->wasmEnd - io_function->wasm));\n    IM3Runtime runtime = io_function->module->runtime;\n\n    IM3Compilation o = & runtime->compilation;                      d_m3Assert (d_m3MaxFunctionSlots >= d_m3MaxFunctionStackHeight * (d_m3Use32BitSlots + 1))  // need twice as many slots in 32-bit mode\n    memset (o, 0x0, sizeof (M3Compilation));\n\n    o->runtime  = runtime;\n    o->module   = io_function->module;\n    o->function = io_function;\n    o->wasm     = io_function->wasm;\n    o->wasmEnd  = io_function->wasmEnd;\n    o->block.type = funcType;\n\n_try {\n    // skip over code size. the end was already calculated during parse phase\n    u32 size;\n_   (ReadLEB_u32 (& size, & o->wasm, o->wasmEnd));                  d_m3Assert (size == (o->wasmEnd - o->wasm))\n\n_   (AcquireCompilationCodePage (o, & o->page));\n\n    pc_t pc = GetPagePC (o->page);\n\n    u16 numRetSlots = GetFunctionNumReturns (o->function) * c_ioSlotCount;\n\n    for (u16 i = 0; i < numRetSlots; ++i)\n        MarkSlotAllocated (o, i);\n\n    o->function->numRetSlots = o->slotFirstDynamicIndex = numRetSlots;\n\n    u16 numArgs = GetFunctionNumArgs (o->function);\n\n    // push the arg types to the type stack\n    for (u16 i = 0; i < numArgs; ++i)\n    {\n        u8 type = GetFunctionArgType (o->function, i);\n_       (PushAllocatedSlot (o, type));\n\n        // prevent allocator fill-in\n        o->slotFirstDynamicIndex += c_ioSlotCount;\n    }\n\n    o->slotMaxAllocatedIndexPlusOne = o->function->numRetAndArgSlots = o->slotFirstLocalIndex = o->slotFirstDynamicIndex;\n\n_   (CompileLocals (o));\n\n    u16 maxSlot = GetMaxUsedSlotPlusOne (o);\n\n    o->function->numLocalBytes = (maxSlot - o->slotFirstLocalIndex) * sizeof (m3slot_t);\n\n    o->slotFirstConstIndex = o->slotMaxConstIndex = maxSlot;\n\n    // ReserveConstants initializes o->firstDynamicSlotNumber\n_   (ReserveConstants (o));\n\n    // start tracking the max stack used (Push() also updates this value) so that op_Entry can precisely detect stack overflow\n    o->maxStackSlots = o->slotMaxAllocatedIndexPlusOne = o->slotFirstDynamicIndex;\n\n    o->block.blockStackIndex = o->stackFirstDynamicIndex = o->stackIndex;                           m3log (compile, \"start stack index: %d\",\n                                                                                                          (u32) o->stackFirstDynamicIndex);\n_   (EmitOp (o, op_Entry));\n    EmitPointer (o, io_function);\n\n_   (CompileBlockStatements (o));\n\n    // TODO: validate opcode sequences\n    _throwif(m3Err_wasmMalformed, o->previousOpcode != c_waOp_end);\n\n    io_function->compiled = pc;\n    io_function->maxStackSlots = o->maxStackSlots;\n\n    u16 numConstantSlots = o->slotMaxConstIndex - o->slotFirstConstIndex;                           m3log (compile, \"unique constant slots: %d; unused slots: %d\",\n                                                                                                           numConstantSlots, o->slotFirstDynamicIndex - o->slotMaxConstIndex);\n    io_function->numConstantBytes = numConstantSlots * sizeof (m3slot_t);\n\n    if (numConstantSlots)\n    {\n        io_function->constants = m3_CopyMem (o->constants, io_function->numConstantBytes);\n        _throwifnull(io_function->constants);\n    }\n\n} _catch:\n\n    ReleaseCompilationCodePage (o);\n\n    return result;\n}",
        "file_path": "/src/wasm3/source/m3_compile.c",
        "crashing_line": "    EmitPointer (o, io_function);",
        "crashing_line_number": 2899
      },
      {
        "function_name": "m3_FindFunction",
        "function_body": "M3Result  m3_FindFunction  (IM3Function * o_function, IM3Runtime i_runtime, const char * const i_functionName)\n{\n    M3Result result = m3Err_none;                               d_m3Assert (o_function and i_runtime and i_functionName);\n\n    IM3Function function = NULL;\n\n    if (not i_runtime->modules) {\n        _throw (\"no modules loaded\");\n    }\n\n    function = (IM3Function) ForEachModule (i_runtime, (ModuleVisitor) v_FindFunction, (void *) i_functionName);\n\n    if (function)\n    {\n        if (not function->compiled)\n        {\n_           (CompileFunction (function))\n        }\n    }\n    else _throw (ErrorModule (m3Err_functionLookupFailed, i_runtime->modules, \"'%s'\", i_functionName));\n\n    _catch:\n    if (result)\n        function = NULL;\n\n    * o_function = function;\n\n    return result;\n}",
        "file_path": "/src/wasm3/source/m3_env.c",
        "crashing_line": "_           (CompileFunction (function))",
        "crashing_line_number": 730
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "  tt_size_reset( TT_Size  size,\n                 FT_Bool  only_height )\n  {\n    TT_Face           face;\n    FT_Size_Metrics*  metrics;\n\n\n    size->ttmetrics.valid = FALSE;\n\n    face = (TT_Face)size->root.face;\n\n    metrics = &size->metrics;\n\n    /* copy the result from base layer */\n    *metrics = size->root.metrics;\n\n    if ( metrics->x_ppem < 1 || metrics->y_ppem < 1 )\n      return FT_THROW( Invalid_PPem );\n\n    /* This bit flag, if set, indicates that the ppems must be       */\n    /* rounded to integers.  Nearly all TrueType fonts have this bit */\n    /* set, as hinting won't work really well otherwise.             */\n    /*                                                               */\n    if ( face->header.Flags & 8 )\n    {\n      metrics->ascender =\n        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );\n      metrics->descender =\n        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );\n      metrics->height =\n        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );\n    }\n\n    size->ttmetrics.valid = TRUE;\n\n    if ( only_height )\n      return FT_Err_Ok;\n\n    if ( face->header.Flags & 8 )\n    {\n      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,\n                                    face->root.units_per_EM );\n      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,\n                                    face->root.units_per_EM );\n\n      metrics->max_advance =\n        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,\n                                 metrics->x_scale ) );\n    }\n\n    /* compute new transformation */\n    if ( metrics->x_ppem >= metrics->y_ppem )\n    {\n      size->ttmetrics.scale   = metrics->x_scale;\n      size->ttmetrics.ppem    = metrics->x_ppem;\n      size->ttmetrics.x_ratio = 0x10000L;\n      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,\n                                           metrics->x_ppem );\n    }\n    else\n    {\n      size->ttmetrics.scale   = metrics->y_scale;\n      size->ttmetrics.ppem    = metrics->y_ppem;\n      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,\n                                           metrics->y_ppem );\n      size->ttmetrics.y_ratio = 0x10000L;\n    }\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    size->cvt_ready = -1;\n#endif /* TT_USE_BYTECODE_INTERPRETER */\n\n    return FT_Err_Ok;\n  }\n",
    "target": 1,
    "idx": 1000509,
    "stack_trace": [
      {
        "function_name": "tt_size_reset",
        "function_body": "  tt_size_reset( TT_Size  size,\n                 FT_Bool  only_height )\n  {\n    TT_Face           face;\n    FT_Size_Metrics*  metrics;\n\n\n    face = (TT_Face)size->root.face;\n\n    /* nothing to do for CFF2 */\n    if ( face->isCFF2 )\n      return FT_Err_Ok;\n\n    size->ttmetrics.valid = FALSE;\n\n    metrics = &size->metrics;\n\n    /* copy the result from base layer */\n    *metrics = size->root.metrics;\n\n    if ( metrics->x_ppem < 1 || metrics->y_ppem < 1 )\n      return FT_THROW( Invalid_PPem );\n\n    /* This bit flag, if set, indicates that the ppems must be       */\n    /* rounded to integers.  Nearly all TrueType fonts have this bit */\n    /* set, as hinting won't work really well otherwise.             */\n    /*                                                               */\n    if ( face->header.Flags & 8 )\n    {\n      metrics->ascender =\n        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );\n      metrics->descender =\n        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );\n      metrics->height =\n        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );\n    }\n\n    size->ttmetrics.valid = TRUE;\n\n    if ( only_height )\n      return FT_Err_Ok;\n\n    if ( face->header.Flags & 8 )\n    {\n      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,\n                                    face->root.units_per_EM );\n      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,\n                                    face->root.units_per_EM );\n\n      metrics->max_advance =\n        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,\n                                 metrics->x_scale ) );\n    }\n\n    /* compute new transformation */\n    if ( metrics->x_ppem >= metrics->y_ppem )\n    {\n      size->ttmetrics.scale   = metrics->x_scale;\n      size->ttmetrics.ppem    = metrics->x_ppem;\n      size->ttmetrics.x_ratio = 0x10000L;\n      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,\n                                           metrics->x_ppem );\n    }\n    else\n    {\n      size->ttmetrics.scale   = metrics->y_scale;\n      size->ttmetrics.ppem    = metrics->y_ppem;\n      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,\n                                           metrics->y_ppem );\n      size->ttmetrics.y_ratio = 0x10000L;\n    }\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    size->cvt_ready = -1;\n#endif /* TT_USE_BYTECODE_INTERPRETER */\n\n    return FT_Err_Ok;\n  }",
        "file_path": "/src/freetype2/src/truetype/ttobjs.c",
        "crashing_line": "    face = (TT_Face)size->root.face;",
        "crashing_line_number": 1215
      },
      {
        "function_name": "tt_size_reset_iterator",
        "function_body": "  static FT_Error\n  tt_size_reset_iterator( FT_ListNode  node,\n                          void*        user )\n  {\n    TT_Size  size = (TT_Size)node->data;\n\n    FT_UNUSED( user );\n\n\n    tt_size_reset( size, 1 );\n\n    return FT_Err_Ok;\n  }",
        "file_path": "/src/freetype2/src/truetype/ttgxvar.c",
        "crashing_line": "    tt_size_reset( size, 1 );",
        "crashing_line_number": 1192
      },
      {
        "function_name": "FT_List_Iterate",
        "function_body": "  FT_List_Iterate( FT_List           list,\n                   FT_List_Iterator  iterator,\n                   void*             user )\n  {\n    FT_ListNode  cur;\n    FT_Error     error = FT_Err_Ok;\n\n\n    if ( !list || !iterator )\n      return FT_THROW( Invalid_Argument );\n\n    cur = list->head;\n\n    while ( cur )\n    {\n      FT_ListNode  next = cur->next;\n\n\n      error = iterator( cur, user );\n      if ( error )\n        break;\n\n      cur = next;\n    }\n\n    return error;\n  }",
        "file_path": "/src/freetype2/src/base/ftutil.c",
        "crashing_line": "      error = iterator( cur, user );",
        "crashing_line_number": 397
      },
      {
        "function_name": "tt_apply_mvar",
        "function_body": "  tt_apply_mvar( TT_Face  face )\n  {\n    GX_Blend  blend = face->blend;\n    GX_Value  value, limit;\n\n\n    if ( !( face->variation_support & TT_FACE_FLAG_VAR_MVAR ) )\n      return;\n\n    value = blend->mvar_table->values;\n    limit = value + blend->mvar_table->valueCount;\n\n    for ( ; value < limit; value++ )\n    {\n      FT_Short*  p = ft_var_get_value_pointer( face, value->tag );\n      FT_Int     delta;\n\n\n      delta = ft_var_get_item_delta( face,\n                                     &blend->mvar_table->itemStore,\n                                     value->outerIndex,\n                                     value->innerIndex );\n\n      FT_TRACE5(( \"value %c%c%c%c (%d units) adjusted by %d units (MVAR)\\n\",\n                  (FT_Char)( value->tag >> 24 ),\n                  (FT_Char)( value->tag >> 16 ),\n                  (FT_Char)( value->tag >> 8 ),\n                  (FT_Char)( value->tag ),\n                  value->unmodified,\n                  delta ));\n\n      /* since we handle both signed and unsigned values as FT_Short, */\n      /* ensure proper overflow arithmetic                            */\n      *p = (FT_Short)( value->unmodified + (FT_Short)delta );\n    }\n\n    /* adjust all derived values */\n    {\n      FT_Face  root = &face->root;\n\n\n      if ( face->os2.version != 0xFFFFU )\n      {\n        if ( face->os2.sTypoAscender || face->os2.sTypoDescender )\n        {\n          root->ascender  = face->os2.sTypoAscender;\n          root->descender = face->os2.sTypoDescender;\n\n          root->height = root->ascender - root->descender +\n                         face->os2.sTypoLineGap;\n        }\n        else\n        {\n          root->ascender  =  (FT_Short)face->os2.usWinAscent;\n          root->descender = -(FT_Short)face->os2.usWinDescent;\n\n          root->height = root->ascender - root->descender;\n        }\n      }\n\n      root->underline_position  = face->postscript.underlinePosition -\n                                  face->postscript.underlineThickness / 2;\n      root->underline_thickness = face->postscript.underlineThickness;\n\n      /* iterate over all FT_Size objects and call `tt_size_reset' */\n      /* to propagate the metrics changes                          */\n      FT_List_Iterate( &root->sizes_list,\n                       tt_size_reset_iterator,\n                       NULL );\n    }\n  }",
        "file_path": "/src/freetype2/src/truetype/ttgxvar.c",
        "crashing_line": "      FT_List_Iterate( &root->sizes_list,",
        "crashing_line_number": 1276
      },
      {
        "function_name": "cff_metrics_adjust",
        "function_body": "  static void\n  cff_metrics_adjust( CFF_Face  face )\n  {\n    FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;\n\n\n    var->metrics_adjust( FT_FACE( face ) );\n  }",
        "file_path": "/src/freetype2/src/cff/cffdrivr.c",
        "crashing_line": "    var->metrics_adjust( FT_FACE( face ) );",
        "crashing_line_number": 1047
      },
      {
        "function_name": "FT_Set_Var_Design_Coordinates",
        "function_body": "  FT_Set_Var_Design_Coordinates( FT_Face    face,\n                                 FT_UInt    num_coords,\n                                 FT_Fixed*  coords )\n  {\n    FT_Error                      error;\n    FT_Service_MultiMasters       service_mm;\n    FT_Service_MetricsVariations  service_mvar;\n\n\n    /* check of `face' delayed to `ft_face_get_mm_service' */\n\n    if ( !coords )\n      return FT_THROW( Invalid_Argument );\n\n    error = ft_face_get_mm_service( face, &service_mm );\n    if ( !error )\n    {\n      error = FT_ERR( Invalid_Argument );\n      if ( service_mm->set_var_design )\n        error = service_mm->set_var_design( face, num_coords, coords );\n    }\n\n    if ( !error )\n      error = ft_face_get_mvar_service( face, &service_mvar );\n\n    if ( !error )\n    {\n      if ( service_mvar->metrics_adjust )\n        service_mvar->metrics_adjust( face );\n    }\n\n    /* enforce recomputation of auto-hinting data */\n    if ( !error && face->autohint.finalizer )\n    {\n      face->autohint.finalizer( face->autohint.data );\n      face->autohint.data = NULL;\n    }\n\n    return error;\n  }",
        "file_path": "/src/freetype2/src/base/ftmm.c",
        "crashing_line": "        service_mvar->metrics_adjust( face );",
        "crashing_line_number": 214
      },
      {
        "function_name": "setIntermediateAxis",
        "function_body": "  static void\n  setIntermediateAxis( FT_Face  face )\n  {\n    // only handle Multiple Masters and GX variation fonts\n    if ( !FT_HAS_MULTIPLE_MASTERS( face ) )\n      return;\n\n    // get variation data for current instance\n    FT_MM_Var*  variations_ptr = nullptr;\n    if ( FT_Get_MM_Var( face, &variations_ptr ) )\n      return;\n\n    unique_ptr<FT_MM_Var,\n               decltype ( free )*>  variations( variations_ptr, free );\n    vector<FT_Fixed>                coords( variations->num_axis );\n\n    // select an arbitrary instance\n    for ( unsigned int  i = 0; i < variations->num_axis; i++ )\n      coords[i] = ( variations->axis[i].minimum +\n                    variations->axis[i].def     ) / 2;\n\n    if ( FT_Set_Var_Design_Coordinates( face,\n                                        FT_UInt( coords.size() ),\n                                        coords.data() ) )\n      return;\n  }",
        "file_path": "/src/freetype2/./src/tools/ftfuzzer/ftfuzzer.cc",
        "crashing_line": "    if ( FT_Set_Var_Design_Coordinates( face,",
        "crashing_line_number": 231
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "Status SchemaManifest::Make(const SchemaDescriptor* schema,\n                            const std::shared_ptr<const KeyValueMetadata>& metadata,\n                            const ArrowReaderProperties& properties,\n                            SchemaManifest* manifest) {\n  RETURN_NOT_OK(\n      GetOriginSchema(metadata, &manifest->schema_metadata, &manifest->origin_schema));\n\n  SchemaTreeContext ctx;\n  ctx.manifest = manifest;\n  ctx.properties = properties;\n  ctx.schema = schema;\n  const GroupNode& schema_node = *schema->group_node();\n  manifest->descr = schema;\n  manifest->schema_fields.resize(schema_node.field_count());\n  for (int i = 0; i < static_cast<int>(schema_node.field_count()); ++i) {\n    SchemaField* out_field = &manifest->schema_fields[i];\n    RETURN_NOT_OK(NodeToSchemaField(*schema_node.field(i), LevelInfo(), &ctx,\n                                    /*parent=*/nullptr, out_field));\n\n    // TODO(wesm): as follow up to ARROW-3246, we should really pass the origin\n    // schema (if any) through all functions in the schema reconstruction, but\n    // I'm being lazy and just setting dictionary fields at the top level for\n    // now\n    if (manifest->origin_schema == nullptr) {\n      continue;\n    }\n    auto origin_field = manifest->origin_schema->field(i);\n    RETURN_NOT_OK(ApplyOriginalMetadata(*origin_field, out_field));\n  }\n  return Status::OK();\n}\nstd::shared_ptr<Page> SerializedPageReader::NextPage() {\n  // Loop here because there may be unhandled page types that we skip until\n  // finding a page that we do know what to do with\n\n  while (seen_num_rows_ < total_num_rows_) {\n    uint32_t header_size = 0;\n    uint32_t allowed_page_size = kDefaultPageHeaderSize;\n\n    // Page headers can be very large because of page statistics\n    // We try to deserialize a larger buffer progressively\n    // until a maximum allowed header limit\n    while (true) {\n      PARQUET_ASSIGN_OR_THROW(auto view, stream_->Peek(allowed_page_size));\n      if (view.size() == 0) {\n        return std::shared_ptr<Page>(nullptr);\n      }\n\n      // This gets used, then set by DeserializeThriftMsg\n      header_size = static_cast<uint32_t>(view.size());\n      try {\n        if (crypto_ctx_.meta_decryptor != nullptr) {\n          UpdateDecryption(crypto_ctx_.meta_decryptor, encryption::kDictionaryPageHeader,\n                           data_page_header_aad_);\n        }\n        DeserializeThriftMsg(reinterpret_cast<const uint8_t*>(view.data()), &header_size,\n                             &current_page_header_, crypto_ctx_.meta_decryptor);\n        break;\n      } catch (std::exception& e) {\n        // Failed to deserialize. Double the allowed page header size and try again\n        std::stringstream ss;\n        ss << e.what();\n        allowed_page_size *= 2;\n        if (allowed_page_size > max_page_header_size_) {\n          ss << \"Deserializing page header failed.\\n\";\n          throw ParquetException(ss.str());\n        }\n      }\n    }\n    // Advance the stream offset\n    PARQUET_THROW_NOT_OK(stream_->Advance(header_size));\n\n    int compressed_len = current_page_header_.compressed_page_size;\n    int uncompressed_len = current_page_header_.uncompressed_page_size;\n    if (crypto_ctx_.data_decryptor != nullptr) {\n      UpdateDecryption(crypto_ctx_.data_decryptor, encryption::kDictionaryPage,\n                       data_page_aad_);\n    }\n    // Read the compressed data page.\n    PARQUET_ASSIGN_OR_THROW(auto page_buffer, stream_->Read(compressed_len));\n    if (page_buffer->size() != compressed_len) {\n      std::stringstream ss;\n      ss << \"Page was smaller (\" << page_buffer->size() << \") than expected (\"\n         << compressed_len << \")\";\n      ParquetException::EofException(ss.str());\n    }\n\n    // Decrypt it if we need to\n    if (crypto_ctx_.data_decryptor != nullptr) {\n      PARQUET_THROW_NOT_OK(decryption_buffer_->Resize(\n          compressed_len - crypto_ctx_.data_decryptor->CiphertextSizeDelta(), false));\n      compressed_len = crypto_ctx_.data_decryptor->Decrypt(\n          page_buffer->data(), compressed_len, decryption_buffer_->mutable_data());\n\n      page_buffer = decryption_buffer_;\n    }\n    // Uncompress it if we need to\n    if (decompressor_ != nullptr) {\n      page_buffer = DecompressPage(compressed_len, uncompressed_len, page_buffer->data());\n    }\n\n    const PageType::type page_type = LoadEnumSafe(&current_page_header_.type);\n\n    if (page_type == PageType::DICTIONARY_PAGE) {\n      crypto_ctx_.start_decrypt_with_dictionary_page = false;\n      const format::DictionaryPageHeader& dict_header =\n          current_page_header_.dictionary_page_header;\n\n      bool is_sorted = dict_header.__isset.is_sorted ? dict_header.is_sorted : false;\n      if (dict_header.num_values < 0) {\n        throw ParquetException(\"Invalid page header (negative number of values)\");\n      }\n\n      return std::make_shared<DictionaryPage>(page_buffer, dict_header.num_values,\n                                              LoadEnumSafe(&dict_header.encoding),\n                                              is_sorted);\n    } else if (page_type == PageType::DATA_PAGE) {\n      ++page_ordinal_;\n      const format::DataPageHeader& header = current_page_header_.data_page_header;\n\n      if (header.num_values < 0) {\n        throw ParquetException(\"Invalid page header (negative number of values)\");\n      }\n      EncodedStatistics page_statistics = ExtractStatsFromHeader(header);\n      seen_num_rows_ += header.num_values;\n\n      return std::make_shared<DataPageV1>(page_buffer, header.num_values,\n                                          LoadEnumSafe(&header.encoding),\n                                          LoadEnumSafe(&header.definition_level_encoding),\n                                          LoadEnumSafe(&header.repetition_level_encoding),\n                                          uncompressed_len, page_statistics);\n    } else if (page_type == PageType::DATA_PAGE_V2) {\n      ++page_ordinal_;\n      const format::DataPageHeaderV2& header = current_page_header_.data_page_header_v2;\n\n      if (header.num_values < 0) {\n        throw ParquetException(\"Invalid page header (negative number of values)\");\n      }\n      if (header.definition_levels_byte_length < 0 ||\n          header.repetition_levels_byte_length < 0) {\n        throw ParquetException(\"Invalid page header (negative levels byte length)\");\n      }\n      bool is_compressed = header.__isset.is_compressed ? header.is_compressed : false;\n      EncodedStatistics page_statistics = ExtractStatsFromHeader(header);\n      seen_num_rows_ += header.num_values;\n\n      return std::make_shared<DataPageV2>(\n          page_buffer, header.num_values, header.num_nulls, header.num_rows,\n          LoadEnumSafe(&header.encoding), header.definition_levels_byte_length,\n          header.repetition_levels_byte_length, uncompressed_len, is_compressed,\n          page_statistics);\n    } else {\n      // We don't know what this page type is. We're allowed to skip non-data\n      // pages.\n      continue;\n    }\n  }\n  return std::shared_ptr<Page>(nullptr);\n}\nstd::shared_ptr<Buffer> SerializedPageReader::DecompressPage(int compressed_len,\n                                                             int uncompressed_len,\n                                                             const uint8_t* page_buffer) {\n  // Grow the uncompressed buffer if we need to.\n  if (uncompressed_len > static_cast<int>(decompression_buffer_->size())) {\n    PARQUET_THROW_NOT_OK(decompression_buffer_->Resize(uncompressed_len, false));\n  }\n\n  if (current_page_header_.type != format::PageType::DATA_PAGE_V2) {\n    PARQUET_THROW_NOT_OK(\n        decompressor_->Decompress(compressed_len, page_buffer, uncompressed_len,\n                                  decompression_buffer_->mutable_data()));\n  } else {\n    // The levels are not compressed in V2 format\n    const auto& header = current_page_header_.data_page_header_v2;\n    int32_t levels_length =\n        header.repetition_levels_byte_length + header.definition_levels_byte_length;\n    uint8_t* decompressed = decompression_buffer_->mutable_data();\n    memcpy(decompressed, page_buffer, levels_length);\n    decompressed += levels_length;\n    const uint8_t* compressed_values = page_buffer + levels_length;\n\n    // Decompress the values\n    PARQUET_THROW_NOT_OK(\n        decompressor_->Decompress(compressed_len - levels_length, compressed_values,\n                                  uncompressed_len - levels_length, decompressed));\n  }\n\n  return decompression_buffer_;\n}\nstd::unique_ptr<PageReader> PageReader::Open(std::shared_ptr<ArrowInputStream> stream,\n                                             int64_t total_num_rows,\n                                             Compression::type codec,\n                                             ::arrow::MemoryPool* pool,\n                                             const CryptoContext* ctx) {\n  return std::unique_ptr<PageReader>(\n      new SerializedPageReader(std::move(stream), total_num_rows, codec, pool, ctx));\n}\n",
    "target": 1,
    "idx": 1025957,
    "stack_trace": [
      {
        "function_name": "WriteRingBuffer",
        "function_body": "static BrotliDecoderErrorCode BROTLI_NOINLINE WriteRingBuffer(\n    BrotliDecoderState* s, size_t* available_out, uint8_t** next_out,\n    size_t* total_out, BROTLI_BOOL force) {\n  uint8_t* start =\n      s->ringbuffer + (s->partial_pos_out & (size_t)s->ringbuffer_mask);\n  size_t to_write = UnwrittenBytes(s, BROTLI_TRUE);\n  size_t num_written = *available_out;\n  if (num_written > to_write) {\n    num_written = to_write;\n  }\n  if (s->meta_block_remaining_len < 0) {\n    return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1);\n  }\n  if (next_out && !*next_out) {\n    *next_out = start;\n  } else {\n    if (next_out) {\n      memcpy(*next_out, start, num_written);\n      *next_out += num_written;\n    }\n  }\n  *available_out -= num_written;\n  BROTLI_LOG_UINT(to_write);\n  BROTLI_LOG_UINT(num_written);\n  s->partial_pos_out += num_written;\n  if (total_out) {\n    *total_out = s->partial_pos_out;\n  }\n  if (num_written < to_write) {\n    if (s->ringbuffer_size == (1 << s->window_bits) || force) {\n      return BROTLI_DECODER_NEEDS_MORE_OUTPUT;\n    } else {\n      return BROTLI_DECODER_SUCCESS;\n    }\n  }\n  /* Wrap ring buffer only if it has reached its maximal size. */\n  if (s->ringbuffer_size == (1 << s->window_bits) &&\n      s->pos >= s->ringbuffer_size) {\n    s->pos -= s->ringbuffer_size;\n    s->rb_roundtrips++;\n    s->should_wrap_ringbuffer = (size_t)s->pos != 0 ? 1 : 0;\n  }\n  return BROTLI_DECODER_SUCCESS;\n}",
        "file_path": "/work/brotli_ep-prefix/src/brotli_ep/c/dec/decode.c",
        "crashing_line": "      memcpy(*next_out, start, num_written);",
        "crashing_line_number": 1274
      },
      {
        "function_name": "BrotliDecoderDecompressStream",
        "function_body": "BrotliDecoderResult BrotliDecoderDecompressStream(\n    BrotliDecoderState* s, size_t* available_in, const uint8_t** next_in,\n    size_t* available_out, uint8_t** next_out, size_t* total_out) {\n  BrotliDecoderErrorCode result = BROTLI_DECODER_SUCCESS;\n  BrotliBitReader* br = &s->br;\n  /* Ensure that |total_out| is set, even if no data will ever be pushed out. */\n  if (total_out) {\n    *total_out = s->partial_pos_out;\n  }\n  /* Do not try to process further in a case of unrecoverable error. */\n  if ((int)s->error_code < 0) {\n    return BROTLI_DECODER_RESULT_ERROR;\n  }\n  if (*available_out && (!next_out || !*next_out)) {\n    return SaveErrorCode(\n        s, BROTLI_FAILURE(BROTLI_DECODER_ERROR_INVALID_ARGUMENTS));\n  }\n  if (!*available_out) next_out = 0;\n  if (s->buffer_length == 0) {  /* Just connect bit reader to input stream. */\n    br->avail_in = *available_in;\n    br->next_in = *next_in;\n  } else {\n    /* At least one byte of input is required. More than one byte of input may\n       be required to complete the transaction -> reading more data must be\n       done in a loop -> do it in a main loop. */\n    result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n    br->next_in = &s->buffer.u8[0];\n  }\n  /* State machine */\n  for (;;) {\n    if (result != BROTLI_DECODER_SUCCESS) {\n      /* Error, needs more input/output. */\n      if (result == BROTLI_DECODER_NEEDS_MORE_INPUT) {\n        if (s->ringbuffer != 0) {  /* Pro-actively push output. */\n          BrotliDecoderErrorCode intermediate_result = WriteRingBuffer(s,\n              available_out, next_out, total_out, BROTLI_TRUE);\n          /* WriteRingBuffer checks s->meta_block_remaining_len validity. */\n          if ((int)intermediate_result < 0) {\n            result = intermediate_result;\n            break;\n          }\n        }\n        if (s->buffer_length != 0) {  /* Used with internal buffer. */\n          if (br->avail_in == 0) {\n            /* Successfully finished read transaction.\n               Accumulator contains less than 8 bits, because internal buffer\n               is expanded byte-by-byte until it is enough to complete read. */\n            s->buffer_length = 0;\n            /* Switch to input stream and restart. */\n            result = BROTLI_DECODER_SUCCESS;\n            br->avail_in = *available_in;\n            br->next_in = *next_in;\n            continue;\n          } else if (*available_in != 0) {\n            /* Not enough data in buffer, but can take one more byte from\n               input stream. */\n            result = BROTLI_DECODER_SUCCESS;\n            s->buffer.u8[s->buffer_length] = **next_in;\n            s->buffer_length++;\n            br->avail_in = s->buffer_length;\n            (*next_in)++;\n            (*available_in)--;\n            /* Retry with more data in buffer. */\n            continue;\n          }\n          /* Can't finish reading and no more input. */\n          break;\n        } else {  /* Input stream doesn't contain enough input. */\n          /* Copy tail to internal buffer and return. */\n          *next_in = br->next_in;\n          *available_in = br->avail_in;\n          while (*available_in) {\n            s->buffer.u8[s->buffer_length] = **next_in;\n            s->buffer_length++;\n            (*next_in)++;\n            (*available_in)--;\n          }\n          break;\n        }\n        /* Unreachable. */\n      }\n\n      /* Fail or needs more output. */\n\n      if (s->buffer_length != 0) {\n        /* Just consumed the buffered input and produced some output. Otherwise\n           it would result in \"needs more input\". Reset internal buffer. */\n        s->buffer_length = 0;\n      } else {\n        /* Using input stream in last iteration. When decoder switches to input\n           stream it has less than 8 bits in accumulator, so it is safe to\n           return unused accumulator bits there. */\n        BrotliBitReaderUnload(br);\n        *available_in = br->avail_in;\n        *next_in = br->next_in;\n      }\n      break;\n    }\n    switch (s->state) {\n      case BROTLI_STATE_UNINITED:\n        /* Prepare to the first read. */\n        if (!BrotliWarmupBitReader(br)) {\n          result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n          break;\n        }\n        /* Decode window size. */\n        result = DecodeWindowBits(s, br);  /* Reads 1..8 bits. */\n        if (result != BROTLI_DECODER_SUCCESS) {\n          break;\n        }\n        if (s->large_window) {\n          s->state = BROTLI_STATE_LARGE_WINDOW_BITS;\n          break;\n        }\n        s->state = BROTLI_STATE_INITIALIZE;\n        break;\n\n      case BROTLI_STATE_LARGE_WINDOW_BITS:\n        if (!BrotliSafeReadBits(br, 6, &s->window_bits)) {\n          result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n          break;\n        }\n        if (s->window_bits < BROTLI_LARGE_MIN_WBITS ||\n            s->window_bits > BROTLI_LARGE_MAX_WBITS) {\n          result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS);\n          break;\n        }\n        s->state = BROTLI_STATE_INITIALIZE;\n      /* Fall through. */\n\n      case BROTLI_STATE_INITIALIZE:\n        BROTLI_LOG_UINT(s->window_bits);\n        /* Maximum distance, see section 9.1. of the spec. */\n        s->max_backward_distance = (1 << s->window_bits) - BROTLI_WINDOW_GAP;\n\n        /* Allocate memory for both block_type_trees and block_len_trees. */\n        s->block_type_trees = (HuffmanCode*)BROTLI_DECODER_ALLOC(s,\n            sizeof(HuffmanCode) * 3 *\n                (BROTLI_HUFFMAN_MAX_SIZE_258 + BROTLI_HUFFMAN_MAX_SIZE_26));\n        if (s->block_type_trees == 0) {\n          result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES);\n          break;\n        }\n        s->block_len_trees =\n            s->block_type_trees + 3 * BROTLI_HUFFMAN_MAX_SIZE_258;\n\n        s->state = BROTLI_STATE_METABLOCK_BEGIN;\n      /* Fall through. */\n\n      case BROTLI_STATE_METABLOCK_BEGIN:\n        BrotliDecoderStateMetablockBegin(s);\n        BROTLI_LOG_UINT(s->pos);\n        s->state = BROTLI_STATE_METABLOCK_HEADER;\n      /* Fall through. */\n\n      case BROTLI_STATE_METABLOCK_HEADER:\n        result = DecodeMetaBlockLength(s, br);  /* Reads 2 - 31 bits. */\n        if (result != BROTLI_DECODER_SUCCESS) {\n          break;\n        }\n        BROTLI_LOG_UINT(s->is_last_metablock);\n        BROTLI_LOG_UINT(s->meta_block_remaining_len);\n        BROTLI_LOG_UINT(s->is_metadata);\n        BROTLI_LOG_UINT(s->is_uncompressed);\n        if (s->is_metadata || s->is_uncompressed) {\n          if (!BrotliJumpToByteBoundary(br)) {\n            result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_PADDING_1);\n            break;\n          }\n        }\n        if (s->is_metadata) {\n          s->state = BROTLI_STATE_METADATA;\n          break;\n        }\n        if (s->meta_block_remaining_len == 0) {\n          s->state = BROTLI_STATE_METABLOCK_DONE;\n          break;\n        }\n        BrotliCalculateRingBufferSize(s);\n        if (s->is_uncompressed) {\n          s->state = BROTLI_STATE_UNCOMPRESSED;\n          break;\n        }\n        s->loop_counter = 0;\n        s->state = BROTLI_STATE_HUFFMAN_CODE_0;\n        break;\n\n      case BROTLI_STATE_UNCOMPRESSED: {\n        result = CopyUncompressedBlockToOutput(\n            available_out, next_out, total_out, s);\n        if (result != BROTLI_DECODER_SUCCESS) {\n          break;\n        }\n        s->state = BROTLI_STATE_METABLOCK_DONE;\n        break;\n      }\n\n      case BROTLI_STATE_METADATA:\n        for (; s->meta_block_remaining_len > 0; --s->meta_block_remaining_len) {\n          uint32_t bits;\n          /* Read one byte and ignore it. */\n          if (!BrotliSafeReadBits(br, 8, &bits)) {\n            result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n            break;\n          }\n        }\n        if (result == BROTLI_DECODER_SUCCESS) {\n          s->state = BROTLI_STATE_METABLOCK_DONE;\n        }\n        break;\n\n      case BROTLI_STATE_HUFFMAN_CODE_0:\n        if (s->loop_counter >= 3) {\n          s->state = BROTLI_STATE_METABLOCK_HEADER_2;\n          break;\n        }\n        /* Reads 1..11 bits. */\n        result = DecodeVarLenUint8(s, br, &s->num_block_types[s->loop_counter]);\n        if (result != BROTLI_DECODER_SUCCESS) {\n          break;\n        }\n        s->num_block_types[s->loop_counter]++;\n        BROTLI_LOG_UINT(s->num_block_types[s->loop_counter]);\n        if (s->num_block_types[s->loop_counter] < 2) {\n          s->loop_counter++;\n          break;\n        }\n        s->state = BROTLI_STATE_HUFFMAN_CODE_1;\n      /* Fall through. */\n\n      case BROTLI_STATE_HUFFMAN_CODE_1: {\n        uint32_t alphabet_size = s->num_block_types[s->loop_counter] + 2;\n        int tree_offset = s->loop_counter * BROTLI_HUFFMAN_MAX_SIZE_258;\n        result = ReadHuffmanCode(alphabet_size, alphabet_size,\n            &s->block_type_trees[tree_offset], NULL, s);\n        if (result != BROTLI_DECODER_SUCCESS) break;\n        s->state = BROTLI_STATE_HUFFMAN_CODE_2;\n      }\n      /* Fall through. */\n\n      case BROTLI_STATE_HUFFMAN_CODE_2: {\n        uint32_t alphabet_size = BROTLI_NUM_BLOCK_LEN_SYMBOLS;\n        int tree_offset = s->loop_counter * BROTLI_HUFFMAN_MAX_SIZE_26;\n        result = ReadHuffmanCode(alphabet_size, alphabet_size,\n            &s->block_len_trees[tree_offset], NULL, s);\n        if (result != BROTLI_DECODER_SUCCESS) break;\n        s->state = BROTLI_STATE_HUFFMAN_CODE_3;\n      }\n      /* Fall through. */\n\n      case BROTLI_STATE_HUFFMAN_CODE_3: {\n        int tree_offset = s->loop_counter * BROTLI_HUFFMAN_MAX_SIZE_26;\n        if (!SafeReadBlockLength(s, &s->block_length[s->loop_counter],\n            &s->block_len_trees[tree_offset], br)) {\n          result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n          break;\n        }\n        BROTLI_LOG_UINT(s->block_length[s->loop_counter]);\n        s->loop_counter++;\n        s->state = BROTLI_STATE_HUFFMAN_CODE_0;\n        break;\n      }\n\n      case BROTLI_STATE_METABLOCK_HEADER_2: {\n        uint32_t bits;\n        if (!BrotliSafeReadBits(br, 6, &bits)) {\n          result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n          break;\n        }\n        s->distance_postfix_bits = bits & BitMask(2);\n        bits >>= 2;\n        s->num_direct_distance_codes = BROTLI_NUM_DISTANCE_SHORT_CODES +\n            (bits << s->distance_postfix_bits);\n        BROTLI_LOG_UINT(s->num_direct_distance_codes);\n        BROTLI_LOG_UINT(s->distance_postfix_bits);\n        s->distance_postfix_mask = (int)BitMask(s->distance_postfix_bits);\n        s->context_modes =\n            (uint8_t*)BROTLI_DECODER_ALLOC(s, (size_t)s->num_block_types[0]);\n        if (s->context_modes == 0) {\n          result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES);\n          break;\n        }\n        s->loop_counter = 0;\n        s->state = BROTLI_STATE_CONTEXT_MODES;\n      }\n      /* Fall through. */\n\n      case BROTLI_STATE_CONTEXT_MODES:\n        result = ReadContextModes(s);\n        if (result != BROTLI_DECODER_SUCCESS) {\n          break;\n        }\n        s->state = BROTLI_STATE_CONTEXT_MAP_1;\n      /* Fall through. */\n\n      case BROTLI_STATE_CONTEXT_MAP_1:\n        result = DecodeContextMap(\n            s->num_block_types[0] << BROTLI_LITERAL_CONTEXT_BITS,\n            &s->num_literal_htrees, &s->context_map, s);\n        if (result != BROTLI_DECODER_SUCCESS) {\n          break;\n        }\n        DetectTrivialLiteralBlockTypes(s);\n        s->state = BROTLI_STATE_CONTEXT_MAP_2;\n      /* Fall through. */\n\n      case BROTLI_STATE_CONTEXT_MAP_2: {\n        uint32_t num_direct_codes =\n            s->num_direct_distance_codes - BROTLI_NUM_DISTANCE_SHORT_CODES;\n        uint32_t num_distance_codes = BROTLI_DISTANCE_ALPHABET_SIZE(\n            s->distance_postfix_bits, num_direct_codes,\n            (s->large_window ? BROTLI_LARGE_MAX_DISTANCE_BITS :\n                               BROTLI_MAX_DISTANCE_BITS));\n        uint32_t max_distance_symbol = (s->large_window ?\n            BrotliMaxDistanceSymbol(\n                num_direct_codes, s->distance_postfix_bits) :\n            num_distance_codes);\n        BROTLI_BOOL allocation_success = BROTLI_TRUE;\n        result = DecodeContextMap(\n            s->num_block_types[2] << BROTLI_DISTANCE_CONTEXT_BITS,\n            &s->num_dist_htrees, &s->dist_context_map, s);\n        if (result != BROTLI_DECODER_SUCCESS) {\n          break;\n        }\n        allocation_success &= BrotliDecoderHuffmanTreeGroupInit(\n            s, &s->literal_hgroup, BROTLI_NUM_LITERAL_SYMBOLS,\n            BROTLI_NUM_LITERAL_SYMBOLS, s->num_literal_htrees);\n        allocation_success &= BrotliDecoderHuffmanTreeGroupInit(\n            s, &s->insert_copy_hgroup, BROTLI_NUM_COMMAND_SYMBOLS,\n            BROTLI_NUM_COMMAND_SYMBOLS, s->num_block_types[1]);\n        allocation_success &= BrotliDecoderHuffmanTreeGroupInit(\n            s, &s->distance_hgroup, num_distance_codes,\n            max_distance_symbol, s->num_dist_htrees);\n        if (!allocation_success) {\n          return SaveErrorCode(s,\n              BROTLI_FAILURE(BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS));\n        }\n        s->loop_counter = 0;\n        s->state = BROTLI_STATE_TREE_GROUP;\n      }\n      /* Fall through. */\n\n      case BROTLI_STATE_TREE_GROUP: {\n        HuffmanTreeGroup* hgroup = NULL;\n        switch (s->loop_counter) {\n          case 0: hgroup = &s->literal_hgroup; break;\n          case 1: hgroup = &s->insert_copy_hgroup; break;\n          case 2: hgroup = &s->distance_hgroup; break;\n          default: return SaveErrorCode(s, BROTLI_FAILURE(\n              BROTLI_DECODER_ERROR_UNREACHABLE));\n        }\n        result = HuffmanTreeGroupDecode(hgroup, s);\n        if (result != BROTLI_DECODER_SUCCESS) break;\n        s->loop_counter++;\n        if (s->loop_counter >= 3) {\n          PrepareLiteralDecoding(s);\n          s->dist_context_map_slice = s->dist_context_map;\n          s->htree_command = s->insert_copy_hgroup.htrees[0];\n          if (!BrotliEnsureRingBuffer(s)) {\n            result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2);\n            break;\n          }\n          s->state = BROTLI_STATE_COMMAND_BEGIN;\n        }\n        break;\n      }\n\n      case BROTLI_STATE_COMMAND_BEGIN:\n      /* Fall through. */\n      case BROTLI_STATE_COMMAND_INNER:\n      /* Fall through. */\n      case BROTLI_STATE_COMMAND_POST_DECODE_LITERALS:\n      /* Fall through. */\n      case BROTLI_STATE_COMMAND_POST_WRAP_COPY:\n        result = ProcessCommands(s);\n        if (result == BROTLI_DECODER_NEEDS_MORE_INPUT) {\n          result = SafeProcessCommands(s);\n        }\n        break;\n\n      case BROTLI_STATE_COMMAND_INNER_WRITE:\n      /* Fall through. */\n      case BROTLI_STATE_COMMAND_POST_WRITE_1:\n      /* Fall through. */\n      case BROTLI_STATE_COMMAND_POST_WRITE_2:\n        result = WriteRingBuffer(\n            s, available_out, next_out, total_out, BROTLI_FALSE);\n        if (result != BROTLI_DECODER_SUCCESS) {\n          break;\n        }\n        WrapRingBuffer(s);\n        if (s->ringbuffer_size == 1 << s->window_bits) {\n          s->max_distance = s->max_backward_distance;\n        }\n        if (s->state == BROTLI_STATE_COMMAND_POST_WRITE_1) {\n          if (s->meta_block_remaining_len == 0) {\n            /* Next metablock, if any. */\n            s->state = BROTLI_STATE_METABLOCK_DONE;\n          } else {\n            s->state = BROTLI_STATE_COMMAND_BEGIN;\n          }\n          break;\n        } else if (s->state == BROTLI_STATE_COMMAND_POST_WRITE_2) {\n          s->state = BROTLI_STATE_COMMAND_POST_WRAP_COPY;\n        } else {  /* BROTLI_STATE_COMMAND_INNER_WRITE */\n          if (s->loop_counter == 0) {\n            if (s->meta_block_remaining_len == 0) {\n              s->state = BROTLI_STATE_METABLOCK_DONE;\n            } else {\n              s->state = BROTLI_STATE_COMMAND_POST_DECODE_LITERALS;\n            }\n            break;\n          }\n          s->state = BROTLI_STATE_COMMAND_INNER;\n        }\n        break;\n\n      case BROTLI_STATE_METABLOCK_DONE:\n        if (s->meta_block_remaining_len < 0) {\n          result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2);\n          break;\n        }\n        BrotliDecoderStateCleanupAfterMetablock(s);\n        if (!s->is_last_metablock) {\n          s->state = BROTLI_STATE_METABLOCK_BEGIN;\n          break;\n        }\n        if (!BrotliJumpToByteBoundary(br)) {\n          result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_PADDING_2);\n          break;\n        }\n        if (s->buffer_length == 0) {\n          BrotliBitReaderUnload(br);\n          *available_in = br->avail_in;\n          *next_in = br->next_in;\n        }\n        s->state = BROTLI_STATE_DONE;\n      /* Fall through. */\n\n      case BROTLI_STATE_DONE:\n        if (s->ringbuffer != 0) {\n          result = WriteRingBuffer(\n              s, available_out, next_out, total_out, BROTLI_TRUE);\n          if (result != BROTLI_DECODER_SUCCESS) {\n            break;\n          }\n        }\n        return SaveErrorCode(s, result);\n    }\n  }\n  return SaveErrorCode(s, result);\n}",
        "file_path": "/work/brotli_ep-prefix/src/brotli_ep/c/dec/decode.c",
        "crashing_line": "          BrotliDecoderErrorCode intermediate_result = WriteRingBuffer(s,",
        "crashing_line_number": 2021
      },
      {
        "function_name": "BrotliDecoderDecompress",
        "function_body": "BrotliDecoderResult BrotliDecoderDecompress(\n    size_t encoded_size, const uint8_t* encoded_buffer, size_t* decoded_size,\n    uint8_t* decoded_buffer) {\n  BrotliDecoderState s;\n  BrotliDecoderResult result;\n  size_t total_out = 0;\n  size_t available_in = encoded_size;\n  const uint8_t* next_in = encoded_buffer;\n  size_t available_out = *decoded_size;\n  uint8_t* next_out = decoded_buffer;\n  if (!BrotliDecoderStateInit(&s, 0, 0, 0)) {\n    return BROTLI_DECODER_RESULT_ERROR;\n  }\n  result = BrotliDecoderDecompressStream(\n      &s, &available_in, &next_in, &available_out, &next_out, &total_out);\n  *decoded_size = total_out;\n  BrotliDecoderStateCleanup(&s);\n  if (result != BROTLI_DECODER_RESULT_SUCCESS) {\n    result = BROTLI_DECODER_RESULT_ERROR;\n  }\n  return result;\n}",
        "file_path": "/work/brotli_ep-prefix/src/brotli_ep/c/dec/decode.c",
        "crashing_line": "  result = BrotliDecoderDecompressStream(",
        "crashing_line_number": 1966
      },
      {
        "function_name": "",
        "function_body": "  Result<EndResult> End(int64_t output_len, uint8_t* output) override {\n    size_t avail_in = 0;\n    const uint8_t* next_in = nullptr;\n    auto avail_out = static_cast<size_t>(output_len);\n    BROTLI_BOOL ret;\n\n    ret =\n        BrotliEncoderCompressStream(state_, BROTLI_OPERATION_FINISH, &avail_in, &next_in,\n                                    &avail_out, &output, nullptr /* total_out */);\n    if (!ret) {\n      return BrotliError(\"Brotli end failed\");\n    }\n    bool should_retry = !!BrotliEncoderHasMoreOutput(state_);\n    DCHECK_EQ(should_retry, !BrotliEncoderIsFinished(state_));\n    return EndResult{static_cast<int64_t>(output_len - avail_out), should_retry};\n  }",
        "file_path": "/src/arrow/cpp/src/arrow/util/compression_brotli.cc",
        "crashing_line": "",
        "crashing_line_number": 189
      },
      {
        "function_name": "DecompressPage",
        "function_body": "",
        "file_path": "/src/arrow/cpp/src/parquet/column_reader.cc",
        "crashing_line": "",
        "crashing_line_number": 450
      },
      {
        "function_name": "NextPage",
        "function_body": "std::shared_ptr<Page> SerializedPageReader::NextPage() {\n  // Loop here because there may be unhandled page types that we skip until\n  // finding a page that we do know what to do with\n\n  while (seen_num_rows_ < total_num_rows_) {\n    uint32_t header_size = 0;\n    uint32_t allowed_page_size = kDefaultPageHeaderSize;\n\n    // Page headers can be very large because of page statistics\n    // We try to deserialize a larger buffer progressively\n    // until a maximum allowed header limit\n    while (true) {\n      PARQUET_ASSIGN_OR_THROW(auto view, stream_->Peek(allowed_page_size));\n      if (view.size() == 0) {\n        return std::shared_ptr<Page>(nullptr);\n      }\n\n      // This gets used, then set by DeserializeThriftMsg\n      header_size = static_cast<uint32_t>(view.size());\n      try {\n        if (crypto_ctx_.meta_decryptor != nullptr) {\n          UpdateDecryption(crypto_ctx_.meta_decryptor, encryption::kDictionaryPageHeader,\n                           data_page_header_aad_);\n        }\n        DeserializeThriftMsg(reinterpret_cast<const uint8_t*>(view.data()), &header_size,\n                             &current_page_header_, crypto_ctx_.meta_decryptor);\n        break;\n      } catch (std::exception& e) {\n        // Failed to deserialize. Double the allowed page header size and try again\n        std::stringstream ss;\n        ss << e.what();\n        allowed_page_size *= 2;\n        if (allowed_page_size > max_page_header_size_) {\n          ss << \"Deserializing page header failed.\\n\";\n          throw ParquetException(ss.str());\n        }\n      }\n    }\n    // Advance the stream offset\n    PARQUET_THROW_NOT_OK(stream_->Advance(header_size));\n\n    int compressed_len = current_page_header_.compressed_page_size;\n    int uncompressed_len = current_page_header_.uncompressed_page_size;\n    if (compressed_len < 0 || uncompressed_len < 0) {\n      throw ParquetException(\"Invalid page header\");\n    }\n\n    if (crypto_ctx_.data_decryptor != nullptr) {\n      UpdateDecryption(crypto_ctx_.data_decryptor, encryption::kDictionaryPage,\n                       data_page_aad_);\n    }\n\n    // Read the compressed data page.\n    PARQUET_ASSIGN_OR_THROW(auto page_buffer, stream_->Read(compressed_len));\n    if (page_buffer->size() != compressed_len) {\n      std::stringstream ss;\n      ss << \"Page was smaller (\" << page_buffer->size() << \") than expected (\"\n         << compressed_len << \")\";\n      ParquetException::EofException(ss.str());\n    }\n\n    // Decrypt it if we need to\n    if (crypto_ctx_.data_decryptor != nullptr) {\n      PARQUET_THROW_NOT_OK(decryption_buffer_->Resize(\n          compressed_len - crypto_ctx_.data_decryptor->CiphertextSizeDelta(), false));\n      compressed_len = crypto_ctx_.data_decryptor->Decrypt(\n          page_buffer->data(), compressed_len, decryption_buffer_->mutable_data());\n\n      page_buffer = decryption_buffer_;\n    }\n\n    const PageType::type page_type = LoadEnumSafe(&current_page_header_.type);\n\n    if (page_type == PageType::DICTIONARY_PAGE) {\n      crypto_ctx_.start_decrypt_with_dictionary_page = false;\n      const format::DictionaryPageHeader& dict_header =\n          current_page_header_.dictionary_page_header;\n\n      bool is_sorted = dict_header.__isset.is_sorted ? dict_header.is_sorted : false;\n      if (dict_header.num_values < 0) {\n        throw ParquetException(\"Invalid page header (negative number of values)\");\n      }\n\n      // Uncompress if needed\n      page_buffer =\n          DecompressIfNeeded(std::move(page_buffer), compressed_len, uncompressed_len);\n\n      return std::make_shared<DictionaryPage>(page_buffer, dict_header.num_values,\n                                              LoadEnumSafe(&dict_header.encoding),\n                                              is_sorted);\n    } else if (page_type == PageType::DATA_PAGE) {\n      ++page_ordinal_;\n      const format::DataPageHeader& header = current_page_header_.data_page_header;\n\n      if (header.num_values < 0) {\n        throw ParquetException(\"Invalid page header (negative number of values)\");\n      }\n      EncodedStatistics page_statistics = ExtractStatsFromHeader(header);\n      seen_num_rows_ += header.num_values;\n\n      // Uncompress if needed\n      page_buffer =\n          DecompressIfNeeded(std::move(page_buffer), compressed_len, uncompressed_len);\n\n      return std::make_shared<DataPageV1>(page_buffer, header.num_values,\n                                          LoadEnumSafe(&header.encoding),\n                                          LoadEnumSafe(&header.definition_level_encoding),\n                                          LoadEnumSafe(&header.repetition_level_encoding),\n                                          uncompressed_len, page_statistics);\n    } else if (page_type == PageType::DATA_PAGE_V2) {\n      ++page_ordinal_;\n      const format::DataPageHeaderV2& header = current_page_header_.data_page_header_v2;\n\n      if (header.num_values < 0) {\n        throw ParquetException(\"Invalid page header (negative number of values)\");\n      }\n      if (header.definition_levels_byte_length < 0 ||\n          header.repetition_levels_byte_length < 0) {\n        throw ParquetException(\"Invalid page header (negative levels byte length)\");\n      }\n      bool is_compressed = header.__isset.is_compressed ? header.is_compressed : false;\n      EncodedStatistics page_statistics = ExtractStatsFromHeader(header);\n      seen_num_rows_ += header.num_values;\n\n      // Uncompress if needed\n      int levels_byte_len;\n      if (AddWithOverflow(header.definition_levels_byte_length,\n                          header.repetition_levels_byte_length, &levels_byte_len)) {\n        throw ParquetException(\"Levels size too large (corrupt file?)\");\n      }\n      page_buffer = DecompressIfNeeded(std::move(page_buffer), compressed_len,\n                                       uncompressed_len, levels_byte_len);\n\n      return std::make_shared<DataPageV2>(\n          page_buffer, header.num_values, header.num_nulls, header.num_rows,\n          LoadEnumSafe(&header.encoding), header.definition_levels_byte_length,\n          header.repetition_levels_byte_length, uncompressed_len, is_compressed,\n          page_statistics);\n    } else {\n      // We don't know what this page type is. We're allowed to skip non-data\n      // pages.\n      continue;\n    }\n  }\n  return std::shared_ptr<Page>(nullptr);\n}",
        "file_path": "/src/arrow/cpp/src/parquet/column_reader.cc",
        "crashing_line": "          page_buffer->data(), compressed_len, decryption_buffer_->mutable_data());",
        "crashing_line_number": 379
      },
      {
        "function_name": "PhysicalType<",
        "function_body": "",
        "file_path": "/src/arrow/cpp/src/parquet/column_reader.cc",
        "crashing_line": "",
        "crashing_line_number": 563
      },
      {
        "function_name": "HasNextInternal",
        "function_body": "  bool HasNextInternal() {\n    // Either there is no data page available yet, or the data page has been\n    // exhausted\n    if (num_buffered_values_ == 0 || num_decoded_values_ == num_buffered_values_) {\n      if (!ReadNewPage() || num_buffered_values_ == 0) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "file_path": "/src/arrow/cpp/src/parquet/column_reader.cc",
        "crashing_line": "",
        "crashing_line_number": 543
      },
      {
        "function_name": "PhysicalType<",
        "function_body": "",
        "file_path": "/src/arrow/cpp/src/parquet/column_reader.cc",
        "crashing_line": "",
        "crashing_line_number": 1105
      },
      {
        "function_name": "",
        "function_body": "  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }",
        "file_path": "/src/arrow/cpp/src/parquet/arrow/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 444
      },
      {
        "function_name": "NextBatch",
        "function_body": "  ::arrow::Status NextBatch(int64_t batch_size,\n                            std::shared_ptr<::arrow::ChunkedArray>* out) final {\n    RETURN_NOT_OK(LoadBatch(batch_size));\n    RETURN_NOT_OK(BuildArray(batch_size, out));\n    for (int x = 0; x < (*out)->num_chunks(); x++) {\n      RETURN_NOT_OK((*out)->chunk(x)->Validate());\n    }\n    return Status::OK();\n  }",
        "file_path": "/src/arrow/cpp/src/parquet/arrow/reader.cc",
        "crashing_line": "    RETURN_NOT_OK(LoadBatch(batch_size));",
        "crashing_line_number": 103
      },
      {
        "function_name": "",
        "function_body": "  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }",
        "file_path": "/src/arrow/cpp/src/parquet/arrow/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 268
      },
      {
        "function_name": "operator",
        "function_body": "",
        "file_path": "/src/arrow/cpp/src/parquet/arrow/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 936
      },
      {
        "function_name": "OptionalParallelFor<",
        "function_body": "Status OptionalParallelFor(bool use_threads, int num_tasks, FUNCTION&& func) {\n  if (use_threads) {\n    return ParallelFor(num_tasks, std::forward<FUNCTION>(func));\n  } else {\n    for (int i = 0; i < num_tasks; ++i) {\n      RETURN_NOT_OK(func(i));\n    }\n    return Status::OK();\n  }\n}",
        "file_path": "/src/arrow/cpp/src/arrow/util/parallel.h",
        "crashing_line": "      RETURN_NOT_OK(func(i));",
        "crashing_line_number": 57
      },
      {
        "function_name": "",
        "function_body": "  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }",
        "file_path": "/src/arrow/cpp/src/parquet/arrow/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 936
      },
      {
        "function_name": "",
        "function_body": "  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }",
        "file_path": "/src/arrow/cpp/src/parquet/arrow/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 298
      },
      {
        "function_name": "",
        "function_body": "  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }",
        "file_path": "/src/arrow/cpp/src/parquet/arrow/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 302
      },
      {
        "function_name": "FuzzReader",
        "function_body": "Status FuzzReader(const uint8_t* data, int64_t size) {\n  auto buffer = std::make_shared<::arrow::Buffer>(data, size);\n  auto file = std::make_shared<::arrow::io::BufferReader>(buffer);\n  FileReaderBuilder builder;\n  RETURN_NOT_OK(builder.Open(std::move(file)));\n\n  std::unique_ptr<FileReader> reader;\n  RETURN_NOT_OK(builder.Build(&reader));\n  return FuzzReader(std::move(reader));\n}",
        "file_path": "/src/arrow/cpp/src/parquet/arrow/reader.cc",
        "crashing_line": "",
        "crashing_line_number": 1032
      },
      {
        "function_name": "FuzzReader",
        "function_body": "Status FuzzReader(const uint8_t* data, int64_t size) {\n  auto buffer = std::make_shared<::arrow::Buffer>(data, size);\n  auto file = std::make_shared<::arrow::io::BufferReader>(buffer);\n  FileReaderBuilder builder;\n  RETURN_NOT_OK(builder.Open(std::move(file)));\n\n  std::unique_ptr<FileReader> reader;\n  RETURN_NOT_OK(builder.Build(&reader));\n  return FuzzReader(std::move(reader));\n}",
        "file_path": "/src/arrow/cpp/src/parquet/arrow/reader.cc",
        "crashing_line": "  return FuzzReader(std::move(reader));",
        "crashing_line_number": 1049
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 1,
    "idx": 1039056,
    "stack_trace": [
      {
        "function_name": "MqttClient_DecodePacket",
        "function_body": "static int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}",
        "file_path": "/src/wolfmqtt/src/mqtt_client.c",
        "crashing_line": "            p_publish->protocol_level = client->protocol_level;",
        "crashing_line_number": 355
      },
      {
        "function_name": "MqttClient_HandlePacket",
        "function_body": "static int MqttClient_HandlePacket(MqttClient* client,\n    MqttPacketType packet_type, void *packet_obj, int timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttQoS packet_qos = MQTT_QOS_0;\n    word16 packet_id = 0;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    switch (packet_type)\n    {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish *publish = (MqttPublish*)packet_obj;\n            MqttPacketType resp_type;\n\n            if (publish->stat == MQTT_MSG_BEGIN ||\n                publish->stat == MQTT_MSG_READ) {\n                rc = MqttClient_DecodePacket(client, client->rx_buf,\n                    client->packet.buf_len, packet_obj, &packet_type,\n                    &packet_qos, &packet_id);\n                if (rc <= 0) {\n                    return rc;\n                }\n            }\n            else {\n                /* packet ID and QoS were already established */\n                packet_id = client->msg.publish.packet_id;\n                packet_qos = client->msg.publish.qos;\n            }\n\n            rc = MqttClient_Publish_ReadPayload(client, publish, timeout_ms);\n            if (rc < 0) {\n                break;\n            }\n\n            /* Handle QoS */\n            if (packet_qos == MQTT_QOS_0) {\n                /* we are done, no QoS response */\n                break;\n            }\n\n            /* Determine packet type to write */\n            resp_type = (packet_qos == MQTT_QOS_1) ?\n                MQTT_PACKET_TYPE_PUBLISH_ACK :\n                MQTT_PACKET_TYPE_PUBLISH_REC;\n            publish->resp.packet_id = packet_id;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                resp_type, &publish->resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(resp_type), resp_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp pubRespObj, *publish_resp = &pubRespObj;\n            XMEMSET(publish_resp, 0, sizeof(MqttPublishResp));\n\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, publish_resp, &packet_type,\n                &packet_qos, &packet_id);\n            if (rc <= 0) {\n                return rc;\n            }\n\n            /* If publish Received or Release QoS then proceed */\n            if (packet_type != MQTT_PACKET_TYPE_PUBLISH_REC &&\n                packet_type != MQTT_PACKET_TYPE_PUBLISH_REL) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            publish_resp->packet_id = packet_id;\n            packet_type = (MqttPacketType)((int)packet_type+1); /* next ack */\n        #ifdef WOLFMQTT_V5\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"\\tPublish response: reason code %d, Type %s (%d),\"\n                        \" ID %d, QoS %d\",\n                        publish_resp->reason_code,\n                        MqttPacket_TypeDesc(packet_type),\n                        packet_type, packet_id, packet_qos);\n            #endif\n\n            /* return reason code to caller */\n            if (packet_obj != NULL) {\n                MqttPublishResp* caller_rsp = (MqttPublishResp*)packet_obj;\n                caller_rsp->reason_code = publish_resp->reason_code;\n            }\n\n            /* Publish QoS response needs success reason code,\n             * otherwise will cause disconnect at broker */\n            publish_resp->reason_code = MQTT_REASON_SUCCESS;\n        #endif\n\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                packet_type, publish_resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these types are only sent from client and should not be sent\n             * by broker */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n    } /* switch (packet_type) */\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    if (rc < 0) {\n        PRINTF(\"MqttClient_HandlePacket: Rc %d, Type %s (%d), QoS %d, ID %d\",\n            rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_qos,\n            packet_id);\n    }\n#endif\n\n    return rc;\n}",
        "file_path": "/src/wolfmqtt/src/mqtt_client.c",
        "crashing_line": "                rc = MqttClient_DecodePacket(client, client->rx_buf,",
        "crashing_line_number": 558
      },
      {
        "function_name": "MqttClient_WaitType",
        "function_body": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}",
        "file_path": "/src/wolfmqtt/src/mqtt_client.c",
        "crashing_line": "            /* Perform packet handling for publish callback and QoS */",
        "crashing_line_number": 943
      },
      {
        "function_name": "MqttClient_Unsubscribe",
        "function_body": "int MqttClient_Unsubscribe(MqttClient *client, MqttUnsubscribe *unsubscribe)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || unsubscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Use specified protocol version if set */\n    unsubscribe->protocol_level = client->protocol_level;\n#endif\n\n    if (unsubscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = MqttEncode_Unsubscribe(client->tx_buf, client->tx_buf_len,\n            unsubscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_UNSUBSCRIBE),\n            MQTT_PACKET_TYPE_UNSUBSCRIBE, unsubscribe->packet_id, 0);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK, unsubscribe->packet_id,\n                &unsubscribe->pendResp, &unsubscribe->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend); /* Error locking client */\n            return rc;\n        }\n    #endif\n\n        /* Send unsubscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        unsubscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for unsubscribe ack packet */\n    rc = MqttClient_WaitType(client, &unsubscribe->ack,\n        MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK, unsubscribe->packet_id,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n#ifdef WOLFMQTT_V5\n    if (unsubscribe->ack.props != NULL) {\n        /* Release the allocated properties */\n        MqttClient_PropsFree(unsubscribe->ack.props);\n    }\n#endif\n\n    /* reset state */\n    unsubscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}",
        "file_path": "/src/wolfmqtt/src/mqtt_client.c",
        "crashing_line": "    /* Wait for unsubscribe ack packet */",
        "crashing_line_number": 1854
      },
      {
        "function_name": "unsubscribe",
        "function_body": "bool wolfMQTTFuzzer::unsubscribe(void) {\n    MqttTopic* topicsArray = nullptr;\n    MqttUnsubscribe* unsubscribe = nullptr;\n\n    bool ret = false;\n\n    try {\n        Topics topics(ds);\n        CHECK_EQ(topics.Generate(), true);\n\n        unsubscribe = new MqttUnsubscribe;\n        memset(unsubscribe, 0, sizeof(*unsubscribe));\n\n        unsubscribe->packet_id = GetPacketId();\n        topicsArray = topics.ToArray();\n        unsubscribe->topic_count = topics.Size();\n        unsubscribe->topics = topicsArray;\n\n        CHECK_EQ(MqttClient_Unsubscribe(client, unsubscribe), MQTT_CODE_SUCCESS);\n\n        ret = true;\n    } catch ( ... ) { }\n\nend:\n    if ( topicsArray ) {\n        delete[] topicsArray;\n    }\n\n    if ( unsubscribe ) {\n        delete unsubscribe;\n    }\n\n    return ret;\n}",
        "file_path": "/src/wolfmqtt-fuzzers/fuzzer.cpp",
        "crashing_line": "        CHECK_EQ(MqttClient_Unsubscribe(client, unsubscribe), MQTT_CODE_SUCCESS);",
        "crashing_line_number": 284
      },
      {
        "function_name": "Run",
        "function_body": "void wolfMQTTFuzzer::Run(void) {\n    try {\n        const auto numActions = ds.Get<uint8_t>() % 20;\n\n        for (size_t i = 0; i < numActions; i++) {\n            switch ( ds.Get<uint8_t>() ) {\n                case    0:\n                    subscribe();\n                    break;\n                case    1:\n                    unsubscribe();\n                    break;\n                case    2:\n                    publish();\n                    break;\n                case    3:\n                    ping();\n                    break;\n                case    4:\n                    wait();\n                    break;\n            }\n        }\n\n        MqttClient_NetDisconnect(client);\n    } catch ( ... ) { }\n}",
        "file_path": "/src/wolfmqtt-fuzzers/fuzzer.cpp",
        "crashing_line": "                    unsubscribe();",
        "crashing_line_number": 480
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void fxGetNextTokenAux(txParser* parser)\n{\n\tint c;\n\ttxString p;\n\ttxString q;\n\ttxU4 t = 0;\n\tparser->crlf2 = 0;\n\tparser->escaped2 = 0;\n\tparser->bigint2.data = C_NULL;\n\tparser->bigint2.size = 0;\n\tparser->bigint2.sign = 0;\n\tparser->integer2 = 0;\n\tparser->modifierLength2 = 0;\n\tparser->modifier2 = parser->emptyString;\n\tparser->number2 = 0;\n\tparser->rawLength2 = 0;\n\tparser->raw2 = parser->emptyString;\n\tparser->stringLength2 = 0;\n\tparser->string2 = parser->emptyString;\n\tparser->symbol2 = C_NULL;\n\tparser->token2 = XS_NO_TOKEN;\n\twhile (parser->token2 == XS_NO_TOKEN) {\n\t\tswitch (parser->character) {\n\t\tcase C_EOF:\n\t\t\tparser->token2 = XS_TOKEN_EOF;\n\t\t\tbreak;\n\t\tcase 10:\t\n\t\tcase 0x2028: // <LS>\n\t\tcase 0x2029: // <PS>\t\n\t\t\tparser->line2++;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tparser->crlf2 = 1;\n\t\t\tbreak;\n\t\tcase 13:\t\n\t\t\tparser->line2++;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == 10)\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\tparser->crlf2 = 1;\n\t\t\tbreak;\n\t\t\t\n\t\tcase '\\t':\n\t\tcase 11:\n\t\tcase 12:\n \t\tcase ' ':\n\t\tcase 0x00A0:\n\t\tcase 0x1680:\n\t\tcase 0x2000:\n\t\tcase 0x2001:\n\t\tcase 0x2002:\n\t\tcase 0x2003:\n\t\tcase 0x2004:\n\t\tcase 0x2005:\n\t\tcase 0x2006:\n\t\tcase 0x2007:\n\t\tcase 0x2008:\n\t\tcase 0x2009:\n\t\tcase 0x200A:\n\t\tcase 0x202F:\n\t\tcase 0x205F:\n\t\tcase 0x3000:\n\t\tcase 0xFEFF:\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\n\t\t\t\n\t\tcase '0':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tc = parser->character;\n\t\t\tif (c == '.') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tc = parser->character;\n\t\t\t\tif ((('0' <= c) && (c <= '9')) || (c == 'e') || (c == 'E'))\n\t\t\t\t\tfxGetNextNumberE(parser, 1);\n\t\t\t\telse {\n\t\t\t\t\tparser->number2 = 0;\n\t\t\t\t\tparser->token2 = XS_TOKEN_NUMBER;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((c == 'b') || (c == 'B')) {\n\t\t\t\tfxGetNextNumberB(parser);\n\t\t\t}\n            else if ((c == 'e') || (c == 'E')) {\n                fxGetNextNumberE(parser, 0);\n            }\n            else if (c == 'n') {\n                fxGetNextNumberE(parser, 0);\n            }\n\t\t\telse if ((c == 'o') || (c == 'O')) {\n\t\t\t\tfxGetNextNumberO(parser, '0', 0);\n\t\t\t}\n\t\t\telse if ((c == 'x') || (c == 'X')) {\n\t\t\t\tfxGetNextNumberX(parser);\n\t\t\t}\n\t\t\telse if (('0' <= c) && (c <= '9')) {\n\t\t\t\tif ((parser->flags & mxStrictFlag))\n\t\t\t\t\tfxReportParserError(parser, parser->line, \"octal number (strict mode)\");\t\t\t\n\t\t\t\tfxGetNextNumberO(parser, c, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparser->integer2 = 0;\n\t\t\t\tparser->token2 = XS_TOKEN_INTEGER;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tfxGetNextNumberE(parser, 0);\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tc = parser->character;\n\t\t\tif (c == '.') {\t\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '.') {\t\n\t\t\t\t\tparser->token2 = XS_TOKEN_SPREAD;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfxReportParserError(parser, parser->line, \"invalid character %d\", parser->character);\n\t\t\t\t}\t\t\n\t\t\t}\t\t\n\t\t\telse if (('0' <= c) && (c <= '9'))\n\t\t\t\tfxGetNextNumberE(parser, 1);\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_DOT;\n\t\t\tbreak;\t\n\t\tcase ',':\n\t\t\tparser->token2 = XS_TOKEN_COMMA;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase ';':\n\t\t\tparser->token2 = XS_TOKEN_SEMICOLON;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase ':':\n\t\t\tparser->token2 = XS_TOKEN_COLON;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase '?':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '.') {\t\n\t\t\t\tif ((parser->lookahead < '0') || ('9' < parser->lookahead)) {\n\t\t\t\t\tparser->token2 = XS_TOKEN_CHAIN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_QUESTION_MARK;\n\t\t\t}\n\t\t\telse if (parser->character == '?') {\t\t\n\t\t\t\tparser->token2 = XS_TOKEN_COALESCE;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\t\n\t\t\t\t\tparser->token2 = XS_TOKEN_COALESCE_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t\n\t\t\t\tparser->token2 = XS_TOKEN_QUESTION_MARK;\n\t\t\tbreak;\t\n\t\tcase '(':\n\t\t\tparser->token2 = XS_TOKEN_LEFT_PARENTHESIS;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase ')':\n\t\t\tparser->token2 = XS_TOKEN_RIGHT_PARENTHESIS;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase '[':\n\t\t\tparser->token2 = XS_TOKEN_LEFT_BRACKET;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase ']':\n\t\t\tparser->token2 = XS_TOKEN_RIGHT_BRACKET;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase '{':\n\t\t\tparser->token2 = XS_TOKEN_LEFT_BRACE;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase '}':\n\t\t\tparser->token2 = XS_TOKEN_RIGHT_BRACE;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase '=':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\t\t\t\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\n\t\t\t\t\tparser->token2 = XS_TOKEN_STRICT_EQUAL;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_EQUAL;\n\t\t\t}\n\t\t\telse if (parser->character == '>') {\t\n\t\t\t\tparser->token2 = XS_TOKEN_ARROW;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\t\n\t\t\t\tparser->token2 = XS_TOKEN_ASSIGN;\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '<') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\n\t\t\t\t\tparser->token2 = XS_TOKEN_LEFT_SHIFT_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_LEFT_SHIFT;\n\t\t\t}\n\t\t\telse  if (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_LESS_EQUAL;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_LESS;\n\t\t\tbreak;\t\n\t\tcase '>':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '>') {\t\t\t\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '>') {\t\t\t\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\tif (parser->character == '=') {\n\t\t\t\t\t\tparser->token2 = XS_TOKEN_UNSIGNED_RIGHT_SHIFT_ASSIGN;\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tparser->token2 = XS_TOKEN_UNSIGNED_RIGHT_SHIFT;\n\t\t\t\t}\n\t\t\t\telse if (parser->character == '=') {\n\t\t\t\t\tparser->token2 = XS_TOKEN_SIGNED_RIGHT_SHIFT_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_SIGNED_RIGHT_SHIFT;\n\t\t\t}\n\t\t\telse if (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_MORE_EQUAL;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_MORE;\n\t\t\tbreak;\t\n\t\tcase '!':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\t\t\t\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\n\t\t\t\t\tparser->token2 = XS_TOKEN_STRICT_NOT_EQUAL;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_NOT_EQUAL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_NOT;\n\t\t\tbreak;\n\t\tcase '~':\n\t\t\tparser->token2 = XS_TOKEN_BIT_NOT;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\n\t\tcase '&':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\t\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_AND_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '&') {\n\t\t\t\tparser->token2 = XS_TOKEN_AND;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\t\n\t\t\t\t\tparser->token2 = XS_TOKEN_AND_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_AND;\n\t\t\tbreak;\n\t\tcase '|':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_OR_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '|') {\n\t\t\t\tparser->token2 = XS_TOKEN_OR;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\t\n\t\t\t\t\tparser->token2 = XS_TOKEN_OR_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_OR;\n\t\t\tbreak;\n\t\tcase '^':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_XOR_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_XOR;\n\t\t\tbreak;\n\t\tcase '+':\t\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_ADD_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '+') {\n\t\t\t\tparser->token2 = XS_TOKEN_INCREMENT;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_ADD;\n\t\t\tbreak;\n\t\tcase '-':\t\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_SUBTRACT_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '-') {\n\t\t\t\tparser->token2 = XS_TOKEN_DECREMENT;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_SUBTRACT;\n\t\t\tbreak;\n\t\tcase '*':\t\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_MULTIPLY_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '*') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\n\t\t\t\t\tparser->token2 = XS_TOKEN_EXPONENTIATION_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_EXPONENTIATION;\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_MULTIPLY;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '*') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (parser->character == (txU4)C_EOF) {\n\t\t\t\t\t\tfxReportParserError(parser, parser->line, \"end of file in comment\");\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((parser->character == 10) || (parser->character == 0x2028) || (parser->character == 0x2029)) {\n\t\t\t\t\t\tparser->line2++;\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t\tparser->crlf2 = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (parser->character == 13) {\n\t\t\t\t\t\tparser->line2++;\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t\tif (parser->character == 10)\n\t\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t\tparser->crlf2 = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (parser->character == '*') {\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t\tif (parser->character == '/') {\n\t\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (parser->character == '/') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tp = parser->buffer;\n\t\t\t\tq = p + parser->bufferSize - 1;\n\t\t\t\twhile ((parser->character != (txU4)C_EOF) && (parser->character != 10) && (parser->character != 13) && (parser->character != 0x2028) && (parser->character != 0x2029)) {\n\t\t\t\t\tif (p < q)\n\t\t\t\t\t\t*p++ = (char)parser->character;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\t\n\t\t\t\t*p = 0;\n\t\t\t\tp = parser->buffer;\n\t\t\t\tif ((*p == '#') || (*p == '@')) {\n\t\t\t\t\tif (!c_strncmp(p, \"@line \", 6)) {\n\t\t\t\t\t\tp += 6;\n\t\t\t\t\t\tt = 0;\n\t\t\t\t\t\tc = *p++;\n\t\t\t\t\t\twhile (('0' <= c) && (c <= '9')) {\n\t\t\t\t\t\t\tt = (t * 10) + (c - '0');\n\t\t\t\t\t\t\tc = *p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!t) goto bail;\n\t\t\t\t\t\tif (c == ' ') {\n\t\t\t\t\t\t\tc = *p++;\n\t\t\t\t\t\t\tif (c != '\"') goto bail;\n\t\t\t\t\t\t\tq = p;\n\t\t\t\t\t\t\tc = *q++;\n\t\t\t\t\t\t\twhile ((c != 0) && (c != 10) && (c != 13) && (c != '\"'))\n\t\t\t\t\t\t\t\tc = *q++;\n\t\t\t\t\t\t\tif (c != '\"') goto bail;\n\t\t\t\t\t\t\t*(--q) = 0;\n\t\t\t\t\t\t\tparser->path = fxNewParserSymbol(parser, p);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->line2 = t - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!c_strncmp(p, \"# sourceMappingURL=\", 19) || !c_strncmp(p, \"@ sourceMappingURL=\", 19)) {\n\t\t\t\t\t\tp += 19;\n\t\t\t\t\t\tq = p;\n\t\t\t\t\t\tc = *q++;\n\t\t\t\t\t\twhile ((c != 0) && (c != 10) && (c != 13))\n\t\t\t\t\t\t\tc = *q++;\n\t\t\t\t\t\t*q = 0;\n\t\t\t\t\t\tparser->name = fxNewParserString(parser, p, mxPtrDiff(q - p));\n\t\t\t\t\t}\n\t\t\t\t\telse if (!c_strncmp(p, \"# sourceURL=\", 12) || !c_strncmp(p, \"@ sourceURL=\", 12)) {\n\t\t\t\t\t\tp += 12;\n\t\t\t\t\t\tq = p;\n\t\t\t\t\t\tc = *q++;\n\t\t\t\t\t\twhile ((c != 0) && (c != 10) && (c != 13))\n\t\t\t\t\t\t\tc = *q++;\n\t\t\t\t\t\t*q = 0;\n\t\t\t\t\t\tparser->source = fxNewParserSymbol(parser, p);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tbail:\n\t\t\t\t;\n\t\t\t}\n\t\t\telse if (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_DIVIDE_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse \n\t\t\t\tparser->token2 = XS_TOKEN_DIVIDE;\n\t\t\tbreak;\n\t\tcase '%':\t\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_MODULO_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_MODULO;\n\t\t\tbreak;\n\t\t\n\t\tcase '\"':\n\t\tcase '\\'':\n\t\t\tc = parser->character;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tfxGetNextString(parser, c);\n\t\t\tparser->token2 = XS_TOKEN_STRING;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\n\t\t\t\n\t\tcase '`':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tfxGetNextString(parser, '`');\n\t\t\tif (parser->character == '{')\n\t\t\t\tparser->token2 = XS_TOKEN_TEMPLATE_HEAD;\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_TEMPLATE;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\n\t\t\t\n\t\tcase '@':\n\t\t\tif (parser->flags & mxCFlag)\n\t\t\t\tparser->token2 = XS_TOKEN_HOST;\n            else\n                fxReportParserError(parser, parser->line, \"invalid character @\");\n            fxGetNextCharacter(parser);\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tp = parser->buffer;\n\t\t\tq = p + parser->bufferSize - 1;\n\t\t\tif (parser->character == '#') {\n\t\t\t\t*p++ = '#';\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\tif (fxIsIdentifierFirst(parser->character)) {\n\t\t\t\tp = fxUTF8Buffer(parser, parser->character, p, q);\t\t\t\t\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '\\\\') {\n\t\t\t\tparser->escaped2 = 1;\n\t\t\t\tt = 0;\n\t\t\t\tif (fxGetNextIdentiferX(parser, &t) && fxIsIdentifierFirst(t))\n\t\t\t\t\tp = fxUTF8Buffer(parser, t, p, q);\t\t\t\t\n\t\t\t\telse\n\t\t\t\t\tp = C_NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tp = C_NULL;\n\t\t\tif (p) {\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (p == q) {\n\t\t\t\t\t\tfxReportMemoryError(parser, parser->line, \"identifier overflow\");\n\t\t\t\t\t}\n\t\t\t\t\tif (fxIsIdentifierNext(parser->character)) {\n\t\t\t\t\t\tp = fxUTF8Buffer(parser, parser->character, p, q);\t\t\t\t\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t}\n\t\t\t\t\telse if (parser->character == '\\\\') {\n\t\t\t\t\t\tparser->escaped2 = 1;\n\t\t\t\t\t\tt = 0;\n\t\t\t\t\t\tif (fxGetNextIdentiferX(parser, &t) && fxIsIdentifierNext(t))\n\t\t\t\t\t\t\tp = fxUTF8Buffer(parser, t, p, q);\t\t\t\t\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tp = C_NULL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (parser->buffer[0] == '#') {\n\t\t\t\t\t\t\tparser->symbol2 = fxNewParserSymbol(parser, parser->buffer);\n\t\t\t\t\t\t\tparser->token2 = XS_TOKEN_PRIVATE_IDENTIFIER;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfxGetNextKeyword(parser);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tfxReportParserError(parser, parser->line, \"invalid character %d\", parser->character);\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
    "target": 1,
    "idx": 1047443,
    "stack_trace": [
      {
        "function_name": "fxGetNextTokenAux",
        "function_body": "void fxGetNextTokenAux(txParser* parser)\n{\n\tint c;\n\ttxString p;\n\ttxString q;\n\ttxU4 t = 0;\n\tparser->crlf2 = 0;\n\tparser->escaped2 = 0;\n\tparser->bigint2.data = C_NULL;\n\tparser->bigint2.size = 0;\n\tparser->bigint2.sign = 0;\n\tparser->integer2 = 0;\n\tparser->modifierLength2 = 0;\n\tparser->modifier2 = parser->emptyString;\n\tparser->number2 = 0;\n\tparser->rawLength2 = 0;\n\tparser->raw2 = parser->emptyString;\n\tparser->stringLength2 = 0;\n\tparser->string2 = parser->emptyString;\n\tparser->symbol2 = C_NULL;\n\tparser->token2 = XS_NO_TOKEN;\n\twhile (parser->token2 == XS_NO_TOKEN) {\n\t\tswitch (parser->character) {\n\t\tcase C_EOF:\n\t\t\tparser->token2 = XS_TOKEN_EOF;\n\t\t\tbreak;\n\t\tcase 10:\t\n\t\tcase 0x2028: // <LS>\n\t\tcase 0x2029: // <PS>\t\n\t\t\tparser->line2++;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tparser->crlf2 = 1;\n\t\t\tbreak;\n\t\tcase 13:\t\n\t\t\tparser->line2++;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == 10)\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\tparser->crlf2 = 1;\n\t\t\tbreak;\n\t\t\t\n\t\tcase '\\t':\n\t\tcase 11:\n\t\tcase 12:\n \t\tcase ' ':\n\t\tcase 0x00A0:\n\t\tcase 0x1680:\n\t\tcase 0x2000:\n\t\tcase 0x2001:\n\t\tcase 0x2002:\n\t\tcase 0x2003:\n\t\tcase 0x2004:\n\t\tcase 0x2005:\n\t\tcase 0x2006:\n\t\tcase 0x2007:\n\t\tcase 0x2008:\n\t\tcase 0x2009:\n\t\tcase 0x200A:\n\t\tcase 0x202F:\n\t\tcase 0x205F:\n\t\tcase 0x3000:\n\t\tcase 0xFEFF:\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\n\t\t\t\n\t\tcase '0':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tc = parser->character;\n\t\t\tif (c == '.') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tc = parser->character;\n\t\t\t\tif ((('0' <= c) && (c <= '9')) || (c == 'e') || (c == 'E'))\n\t\t\t\t\tfxGetNextNumberE(parser, 1);\n\t\t\t\telse {\n\t\t\t\t\tparser->number2 = 0;\n\t\t\t\t\tparser->token2 = XS_TOKEN_NUMBER;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((c == 'b') || (c == 'B')) {\n\t\t\t\tfxGetNextNumberB(parser);\n\t\t\t}\n            else if ((c == 'e') || (c == 'E')) {\n                fxGetNextNumberE(parser, 0);\n            }\n            else if (c == 'n') {\n                fxGetNextNumberE(parser, 0);\n            }\n\t\t\telse if ((c == 'o') || (c == 'O')) {\n\t\t\t\tfxGetNextNumberO(parser, '0', 0);\n\t\t\t}\n\t\t\telse if ((c == 'x') || (c == 'X')) {\n\t\t\t\tfxGetNextNumberX(parser);\n\t\t\t}\n\t\t\telse if (('0' <= c) && (c <= '9')) {\n\t\t\t\tif ((parser->flags & mxStrictFlag))\n\t\t\t\t\tfxReportParserError(parser, parser->line, \"octal number (strict mode)\");\t\t\t\n\t\t\t\tfxGetNextNumberO(parser, c, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparser->integer2 = 0;\n\t\t\t\tparser->token2 = XS_TOKEN_INTEGER;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tfxGetNextNumberE(parser, 0);\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tc = parser->character;\n\t\t\tif (c == '.') {\t\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '.') {\t\n\t\t\t\t\tparser->token2 = XS_TOKEN_SPREAD;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfxReportParserError(parser, parser->line, \"invalid character %d\", parser->character);\n\t\t\t\t}\t\t\n\t\t\t}\t\t\n\t\t\telse if (('0' <= c) && (c <= '9'))\n\t\t\t\tfxGetNextNumberE(parser, 1);\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_DOT;\n\t\t\tbreak;\t\n\t\tcase ',':\n\t\t\tparser->token2 = XS_TOKEN_COMMA;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase ';':\n\t\t\tparser->token2 = XS_TOKEN_SEMICOLON;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase ':':\n\t\t\tparser->token2 = XS_TOKEN_COLON;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase '?':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '.') {\t\n\t\t\t\tif ((parser->lookahead < '0') || ('9' < parser->lookahead)) {\n\t\t\t\t\tparser->token2 = XS_TOKEN_CHAIN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_QUESTION_MARK;\n\t\t\t}\n\t\t\telse if (parser->character == '?') {\t\t\n\t\t\t\tparser->token2 = XS_TOKEN_COALESCE;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\t\n\t\t\t\t\tparser->token2 = XS_TOKEN_COALESCE_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t\n\t\t\t\tparser->token2 = XS_TOKEN_QUESTION_MARK;\n\t\t\tbreak;\t\n\t\tcase '(':\n\t\t\tparser->token2 = XS_TOKEN_LEFT_PARENTHESIS;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase ')':\n\t\t\tparser->token2 = XS_TOKEN_RIGHT_PARENTHESIS;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase '[':\n\t\t\tparser->token2 = XS_TOKEN_LEFT_BRACKET;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase ']':\n\t\t\tparser->token2 = XS_TOKEN_RIGHT_BRACKET;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase '{':\n\t\t\tparser->token2 = XS_TOKEN_LEFT_BRACE;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase '}':\n\t\t\tparser->token2 = XS_TOKEN_RIGHT_BRACE;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\t\n\t\tcase '=':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\t\t\t\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\n\t\t\t\t\tparser->token2 = XS_TOKEN_STRICT_EQUAL;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_EQUAL;\n\t\t\t}\n\t\t\telse if (parser->character == '>') {\t\n\t\t\t\tparser->token2 = XS_TOKEN_ARROW;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\t\n\t\t\t\tparser->token2 = XS_TOKEN_ASSIGN;\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '<') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\n\t\t\t\t\tparser->token2 = XS_TOKEN_LEFT_SHIFT_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_LEFT_SHIFT;\n\t\t\t}\n\t\t\telse  if (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_LESS_EQUAL;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_LESS;\n\t\t\tbreak;\t\n\t\tcase '>':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '>') {\t\t\t\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '>') {\t\t\t\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\tif (parser->character == '=') {\n\t\t\t\t\t\tparser->token2 = XS_TOKEN_UNSIGNED_RIGHT_SHIFT_ASSIGN;\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tparser->token2 = XS_TOKEN_UNSIGNED_RIGHT_SHIFT;\n\t\t\t\t}\n\t\t\t\telse if (parser->character == '=') {\n\t\t\t\t\tparser->token2 = XS_TOKEN_SIGNED_RIGHT_SHIFT_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_SIGNED_RIGHT_SHIFT;\n\t\t\t}\n\t\t\telse if (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_MORE_EQUAL;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_MORE;\n\t\t\tbreak;\t\n\t\tcase '!':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\t\t\t\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\n\t\t\t\t\tparser->token2 = XS_TOKEN_STRICT_NOT_EQUAL;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_NOT_EQUAL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_NOT;\n\t\t\tbreak;\n\t\tcase '~':\n\t\t\tparser->token2 = XS_TOKEN_BIT_NOT;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\n\t\tcase '&':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\t\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_AND_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '&') {\n\t\t\t\tparser->token2 = XS_TOKEN_AND;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\t\n\t\t\t\t\tparser->token2 = XS_TOKEN_AND_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_AND;\n\t\t\tbreak;\n\t\tcase '|':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_OR_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '|') {\n\t\t\t\tparser->token2 = XS_TOKEN_OR;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\t\n\t\t\t\t\tparser->token2 = XS_TOKEN_OR_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_OR;\n\t\t\tbreak;\n\t\tcase '^':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_XOR_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_BIT_XOR;\n\t\t\tbreak;\n\t\tcase '+':\t\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_ADD_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '+') {\n\t\t\t\tparser->token2 = XS_TOKEN_INCREMENT;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_ADD;\n\t\t\tbreak;\n\t\tcase '-':\t\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_SUBTRACT_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '-') {\n\t\t\t\tparser->token2 = XS_TOKEN_DECREMENT;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_SUBTRACT;\n\t\t\tbreak;\n\t\tcase '*':\t\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_MULTIPLY_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '*') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tif (parser->character == '=') {\n\t\t\t\t\tparser->token2 = XS_TOKEN_EXPONENTIATION_ASSIGN;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tparser->token2 = XS_TOKEN_EXPONENTIATION;\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_MULTIPLY;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '*') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (parser->character == (txU4)C_EOF) {\n\t\t\t\t\t\tfxReportParserError(parser, parser->line, \"end of file in comment\");\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((parser->character == 10) || (parser->character == 0x2028) || (parser->character == 0x2029)) {\n\t\t\t\t\t\tparser->line2++;\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t\tparser->crlf2 = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (parser->character == 13) {\n\t\t\t\t\t\tparser->line2++;\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t\tif (parser->character == 10)\n\t\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t\tparser->crlf2 = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (parser->character == '*') {\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t\tif (parser->character == '/') {\n\t\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (parser->character == '/') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\tp = parser->buffer;\n\t\t\t\tq = p + parser->bufferSize - 1;\n\t\t\t\twhile ((parser->character != (txU4)C_EOF) && (parser->character != 10) && (parser->character != 13) && (parser->character != 0x2028) && (parser->character != 0x2029)) {\n\t\t\t\t\tif (p < q)\n\t\t\t\t\t\t*p++ = (char)parser->character;\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\t\n\t\t\t\t*p = 0;\n\t\t\t\tp = parser->buffer;\n\t\t\t\tif ((*p == '#') || (*p == '@')) {\n\t\t\t\t\tif (!c_strncmp(p, \"@line \", 6)) {\n\t\t\t\t\t\tp += 6;\n\t\t\t\t\t\tt = 0;\n\t\t\t\t\t\tc = *p++;\n\t\t\t\t\t\twhile (('0' <= c) && (c <= '9')) {\n\t\t\t\t\t\t\tt = (t * 10) + (c - '0');\n\t\t\t\t\t\t\tc = *p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!t) goto bail;\n\t\t\t\t\t\tif (c == ' ') {\n\t\t\t\t\t\t\tc = *p++;\n\t\t\t\t\t\t\tif (c != '\"') goto bail;\n\t\t\t\t\t\t\tq = p;\n\t\t\t\t\t\t\tc = *q++;\n\t\t\t\t\t\t\twhile ((c != 0) && (c != 10) && (c != 13) && (c != '\"'))\n\t\t\t\t\t\t\t\tc = *q++;\n\t\t\t\t\t\t\tif (c != '\"') goto bail;\n\t\t\t\t\t\t\t*(--q) = 0;\n\t\t\t\t\t\t\tparser->path = fxNewParserSymbol(parser, p);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->line2 = t - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!c_strncmp(p, \"# sourceMappingURL=\", 19) || !c_strncmp(p, \"@ sourceMappingURL=\", 19)) {\n\t\t\t\t\t\tp += 19;\n\t\t\t\t\t\tq = p;\n\t\t\t\t\t\twhile (((c = *q)) && (c != 10) && (c != 13))\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t*q = 0;\n\t\t\t\t\t\tparser->name = fxNewParserString(parser, p, mxPtrDiff(q - p));\n\t\t\t\t\t}\n\t\t\t\t\telse if (!c_strncmp(p, \"# sourceURL=\", 12) || !c_strncmp(p, \"@ sourceURL=\", 12)) {\n\t\t\t\t\t\tp += 12;\n\t\t\t\t\t\tq = p;\n\t\t\t\t\t\twhile (((c = *q)) && (c != 10) && (c != 13))\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t*q = 0;\n\t\t\t\t\t\tparser->source = fxNewParserSymbol(parser, p);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tbail:\n\t\t\t\t;\n\t\t\t}\n\t\t\telse if (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_DIVIDE_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse \n\t\t\t\tparser->token2 = XS_TOKEN_DIVIDE;\n\t\t\tbreak;\n\t\tcase '%':\t\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '=') {\n\t\t\t\tparser->token2 = XS_TOKEN_MODULO_ASSIGN;\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_MODULO;\n\t\t\tbreak;\n\t\t\n\t\tcase '\"':\n\t\tcase '\\'':\n\t\t\tc = parser->character;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tfxGetNextString(parser, c);\n\t\t\tparser->token2 = XS_TOKEN_STRING;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\n\t\t\t\n\t\tcase '`':\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tfxGetNextString(parser, '`');\n\t\t\tif (parser->character == '{')\n\t\t\t\tparser->token2 = XS_TOKEN_TEMPLATE_HEAD;\n\t\t\telse\n\t\t\t\tparser->token2 = XS_TOKEN_TEMPLATE;\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tbreak;\n\t\t\t\n\t\tcase '@':\n\t\t\tif (parser->flags & mxCFlag)\n\t\t\t\tparser->token2 = XS_TOKEN_HOST;\n            else\n                fxReportParserError(parser, parser->line, \"invalid character @\");\n            fxGetNextCharacter(parser);\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tp = parser->buffer;\n\t\t\tq = p + parser->bufferSize - 1;\n\t\t\tif (parser->character == '#') {\n\t\t\t\t*p++ = '#';\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\tif (fxIsIdentifierFirst(parser->character)) {\n\t\t\t\tp = fxUTF8Buffer(parser, parser->character, p, q);\t\t\t\t\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\telse if (parser->character == '\\\\') {\n\t\t\t\tparser->escaped2 = 1;\n\t\t\t\tt = 0;\n\t\t\t\tif (fxGetNextIdentiferX(parser, &t) && fxIsIdentifierFirst(t))\n\t\t\t\t\tp = fxUTF8Buffer(parser, t, p, q);\t\t\t\t\n\t\t\t\telse\n\t\t\t\t\tp = C_NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tp = C_NULL;\n\t\t\tif (p) {\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (p == q) {\n\t\t\t\t\t\tfxReportMemoryError(parser, parser->line, \"identifier overflow\");\n\t\t\t\t\t}\n\t\t\t\t\tif (fxIsIdentifierNext(parser->character)) {\n\t\t\t\t\t\tp = fxUTF8Buffer(parser, parser->character, p, q);\t\t\t\t\n\t\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t\t}\n\t\t\t\t\telse if (parser->character == '\\\\') {\n\t\t\t\t\t\tparser->escaped2 = 1;\n\t\t\t\t\t\tt = 0;\n\t\t\t\t\t\tif (fxGetNextIdentiferX(parser, &t) && fxIsIdentifierNext(t))\n\t\t\t\t\t\t\tp = fxUTF8Buffer(parser, t, p, q);\t\t\t\t\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tp = C_NULL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (parser->buffer[0] == '#') {\n\t\t\t\t\t\t\tparser->symbol2 = fxNewParserSymbol(parser, parser->buffer);\n\t\t\t\t\t\t\tparser->token2 = XS_TOKEN_PRIVATE_IDENTIFIER;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfxGetNextKeyword(parser);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tfxReportParserError(parser, parser->line, \"invalid character %d\", parser->character);\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "file_path": "/src/moddable/xs/sources/xsLexical.c",
        "crashing_line": "\t\t\t\t\t}",
        "crashing_line_number": 1299
      },
      {
        "function_name": "fxGetNextToken",
        "function_body": "void fxGetNextToken(txParser* parser)\n{\n\tif (!parser->ahead)\n\t\tfxGetNextTokenAux(parser);\n\tparser->line = parser->line2;\n\tparser->crlf = parser->crlf2;\n\tparser->escaped = parser->escaped2;\n\tparser->bigint = parser->bigint2;\n\tparser->integer = parser->integer2;\n\tparser->modifierLength = parser->modifierLength2;\n\tparser->modifier = parser->modifier2;\n\tparser->number = parser->number2;\n\tparser->rawLength = parser->rawLength2;\n\tparser->raw = parser->raw2;\n\tparser->stringLength = parser->stringLength2;\n\tparser->string = parser->string2;\n\tparser->symbol = parser->symbol2;\n\tparser->token = parser->token2;\n\tparser->ahead = 0;\n}",
        "file_path": "/src/moddable/xs/sources/xsLexical.c",
        "crashing_line": "\t\tfxGetNextTokenAux(parser);",
        "crashing_line_number": 836
      },
      {
        "function_name": "fxParserTree",
        "function_body": "void fxParserTree(txParser* parser, void* theStream, txGetter theGetter, txUnsigned flags, txString* name)\n{\n\tmxTryParser(parser) {\n\t\tparser->stream = theStream;\n\t\tparser->getter = theGetter;\n\t\tparser->line = 1;\n\t\tparser->flags = flags;\n\t\tparser->modifier = parser->emptyString;\n\t\tparser->string = parser->emptyString;\n\t\tparser->line2 = 1;\n\t\tparser->modifier2 = parser->emptyString;\n\t\tparser->string2 = parser->emptyString;\n\t\n\t\tparser->root = NULL;\n\t\n\t\tparser->flags &= ~(mxEvalFlag | mxFunctionFlag | mxGeneratorFlag);\n\t\tif (!(parser->flags & mxProgramFlag))\n\t\t\tparser->flags |= mxStrictFlag | mxAsyncFlag;\n\t\tfxGetNextCharacter(parser);\n\t\tfxGetNextCharacter(parser);\n\t\tif (parser->character == '#') {\n\t\t\tfxGetNextCharacter(parser);\n\t\t\tif (parser->character == '!') {\n\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\twhile ((parser->character != (txU4)C_EOF) && (parser->character != 10) && (parser->character != 13) && (parser->character != 0x2028) && (parser->character != 0x2029)) {\n\t\t\t\t\tfxGetNextCharacter(parser);\n\t\t\t\t}\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tfxReportParserError(parser, parser->line, \"invalid character %d\", parser->character);\n\t\t}\n\t\tfxGetNextToken(parser);\n\t\tif (parser->flags & mxProgramFlag) {\n\t\t\tfxProgram(parser);\n\t\t\tif (flags & mxFunctionFlag)\n\t\t\t\tfxCheckFunction(parser);\n\t\t\telse if (flags & mxGeneratorFlag)\n\t\t\t\tfxCheckGenerator(parser);\n\t\t}\n\t\telse {\n\t\t\tfxModule(parser);\n\t\t}\n\t\tparser->flags &= ~mxEvalFlag;\n\t\n\t\tparser->flags |= flags & mxEvalFlag;\n\t\n\t#ifdef mxTreePrint\n\t\tfxTreePrint(parser, parser->root);\n\t#endif\n\t\tif ((parser->errorCount == 0) && name)\n\t\t\t*name = parser->name;\n\t}\n\tmxCatchParser(parser) {\n\t}\n}",
        "file_path": "/src/moddable/xs/sources/xsTree.c",
        "crashing_line": "\t\tfxGetNextToken(parser);",
        "crashing_line_number": 210
      },
      {
        "function_name": "fxParseScript",
        "function_body": "",
        "file_path": "/src/moddable/xs/sources/xsPlatforms.c",
        "crashing_line": "",
        "crashing_line_number": 286
      },
      {
        "function_name": "fuzz_oss",
        "function_body": "int fuzz_oss(const uint8_t *Data, size_t Size)\n{\n\txsCreation _creation = {\n\t\t16 * 1024 * 1024, \t/* initialChunkSize */\n\t\t16 * 1024 * 1024, \t/* incrementalChunkSize */\n\t\t1 * 1024 * 1024, \t/* initialHeapCount */\n\t\t1 * 1024 * 1024, \t/* incrementalHeapCount */\n\t\t256 * 1024, \t\t/* stackCount */\n\t\t256 * 1024, \t\t/* keyCount */\n\t\t1993, \t\t\t\t/* nameModulo */\n\t\t127, \t\t\t\t/* symbolModulo */\n\t\t64 * 1024,\t\t\t/* parserBufferSize */\n\t\t1993,\t\t\t\t/* parserTableModulo */\n\t};\n\tsize_t script_size = 0;\n\n\tchar* buffer = (char *)malloc(Size + 1);\n\tmemcpy(buffer, Data, Size);\n\tscript_size = Size;\n\n\tbuffer[script_size] = 0;\t// required when debugger active\n\n\txsCreation* creation = &_creation;\n\txsMachine* machine;\n\tfxInitializeSharedCluster();\n\tmachine = xsCreateMachine(creation, \"xst\", NULL);\n\n\txsBeginHost(machine);\n\t{\n\t\txsTry {\n\t\t\txsVars(1);\n\n\t\t\t// hardened javascript\n\t\t\txsResult = xsNewHostFunction(fx_harden, 1);\n\t\t\txsDefine(xsGlobal, xsID(\"harden\"), xsResult, xsDontEnum);\n\t\t\txsResult = xsNewHostFunction(fx_lockdown, 0);\n\t\t\txsDefine(xsGlobal, xsID(\"lockdown\"), xsResult, xsDontEnum);\n\t\t\txsResult = xsNewHostFunction(fx_petrify, 1);\n\t\t\txsDefine(xsGlobal, xsID(\"petrify\"), xsResult, xsDontEnum);\n\t\t\txsResult = xsNewHostFunction(fx_mutabilities, 1);\n\t\t\txsDefine(xsGlobal, xsID(\"mutabilities\"), xsResult, xsDontEnum);\n\n\t\t\txsResult = xsNewHostFunction(fx_gc, 0);\n\t\t\txsSet(xsGlobal, xsID(\"gc\"), xsResult);\n\t\t\txsResult = xsNewHostFunction(fx_print, 1);\n\t\t\txsSet(xsGlobal, xsID(\"print\"), xsResult);\n\n\t\t\ttxSlot* realm = mxProgram.value.reference->next->value.module.realm;\n\t\t\ttxStringCStream aStream;\n\t\t\taStream.buffer = buffer;\n\t\t\taStream.offset = 0;\n\t\t\taStream.size = script_size;\n\t\t\tfxRunScript(the, fxParseScript(the, &aStream, fxStringCGetter, mxProgramFlag | mxDebugFlag), mxRealmGlobal(realm), C_NULL, mxRealmClosures(realm)->value.reference, C_NULL, mxProgram.value.reference);\n\t\t\tmxPullSlot(mxResult);\n\t\t\tfxRunLoop(the);\n\t\t}\n\t\txsCatch {\n\t\t}\n\t}\n\txsEndHost(machine);\n\tfflush(stdout);\t\n\tfflush(stderr);\t\n\txsDeleteMachine(machine);\n\tfxTerminateSharedCluster();\n\tfree(buffer);\n\treturn 0;\n}",
        "file_path": "/src/moddable/xs/tools/xst.c",
        "crashing_line": "\t\t\tfxRunScript(the, fxParseScript(the, &aStream, fxStringCGetter, mxProgramFlag | mxDebugFlag), mxRealmGlobal(realm), C_NULL, mxRealmClosures(realm)->value.reference, C_NULL, mxProgram.value.reference);",
        "crashing_line_number": 1859
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "extern int\nonigenc_unicode_get_case_fold_codes_by_str(OnigEncoding enc,\n    OnigCaseFoldType flag, const OnigUChar* p, const OnigUChar* end,\n    OnigCaseFoldCodeItem items[])\n{\n  int n, m, i, j, k, len, lens[3];\n  int index;\n  int fn, ncs[3];\n  OnigCodePoint cs[3][4];\n  OnigCodePoint code, codes[3], orig_codes[3];\n  const struct ByUnfoldKey* buk1;\n\n  n = 0;\n\n  code = ONIGENC_MBC_TO_CODE(enc, p, end);\n  len = enclen(enc, p);\n\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n  if ((flag & ONIGENC_CASE_FOLD_TURKISH_AZERI) != 0) {\n    if (code == 0x0049) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0131;\n      return 1;\n    }\n    else if (code == 0x0130) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0069;\n      return 1;\n    }\n    else if (code == 0x0131) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0049;\n      return 1;\n    }\n    else if (code == 0x0069) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0130;\n      return 1;\n    }\n  }\n#endif\n\n  orig_codes[0] = code;\n  lens[0] = len;\n  p += len;\n\n  buk1 = onigenc_unicode_unfold_key(orig_codes[0]);\n  if (buk1 != 0 && buk1->fold_len == 1) {\n    codes[0] = *FOLDS1_FOLD(buk1->index);\n  }\n  else\n    codes[0] = orig_codes[0];\n\n  if ((flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) == 0)\n    goto fold1;\n\n  if (p < end) {\n    const struct ByUnfoldKey* buk;\n\n    code = ONIGENC_MBC_TO_CODE(enc, p, end);\n    orig_codes[1] = code;\n    len = enclen(enc, p);\n    lens[1] = lens[0] + len;\n    buk = onigenc_unicode_unfold_key(orig_codes[1]);\n    if (buk != 0 && buk->fold_len == 1) {\n      codes[1] = *FOLDS1_FOLD(buk->index);\n    }\n    else\n      codes[1] = orig_codes[1];\n\n    p += len;\n    if (p < end) {\n      code = ONIGENC_MBC_TO_CODE(enc, p, end);\n      orig_codes[2] = code;\n      len = enclen(enc, p);\n      lens[2] = lens[1] + len;\n      buk = onigenc_unicode_unfold_key(orig_codes[2]);\n      if (buk != 0 && buk->fold_len == 1) {\n        codes[2] = *FOLDS1_FOLD(buk->index);\n      }\n      else\n        codes[2] = orig_codes[2];\n\n      index = onigenc_unicode_fold3_key(codes);\n      if (index >= 0) {\n        m = FOLDS3_UNFOLDS_NUM(index);\n        for (i = 0; i < m; i++) {\n          items[n].byte_len = lens[2];\n          items[n].code_len = 1;\n          items[n].code[0]  = FOLDS3_UNFOLDS(index)[i];\n          n++;\n        }\n\n        for (fn = 0; fn < 3; fn++) {\n          int sindex;\n          cs[fn][0] = FOLDS3_FOLD(index)[fn];\n          ncs[fn] = 1;\n          sindex = onigenc_unicode_fold1_key(&cs[fn][0]);\n          if (sindex >= 0) {\n            int m = FOLDS1_UNFOLDS_NUM(sindex);\n            for (i = 0; i < m; i++) {\n              cs[fn][i+1] = FOLDS1_UNFOLDS(sindex)[i];\n            }\n            ncs[fn] += m;\n          }\n        }\n\n        for (i = 0; i < ncs[0]; i++) {\n          for (j = 0; j < ncs[1]; j++) {\n            for (k = 0; k < ncs[2]; k++) {\n              items[n].byte_len = lens[2];\n              items[n].code_len = 3;\n              items[n].code[0]  = cs[0][i];\n              items[n].code[1]  = cs[1][j];\n              items[n].code[2]  = cs[2][k];\n              if (items[n].code[0] == orig_codes[0] &&\n                  items[n].code[1] == orig_codes[1] &&\n                  items[n].code[2] == orig_codes[2])\n                continue;\n              n++;\n            }\n          }\n        }\n\n        return n;\n      }\n    }\n\n    index = onigenc_unicode_fold2_key(codes);\n    if (index >= 0) {\n      m = FOLDS2_UNFOLDS_NUM(index);\n      for (i = 0; i < m; i++) {\n        items[n].byte_len = lens[1];\n        items[n].code_len = 1;\n        items[n].code[0]  = FOLDS2_UNFOLDS(index)[i];\n        n++;\n      }\n\n      for (fn = 0; fn < 2; fn++) {\n        int sindex;\n        cs[fn][0] = FOLDS2_FOLD(index)[fn];\n        ncs[fn] = 1;\n        sindex = onigenc_unicode_fold1_key(&cs[fn][0]);\n        if (sindex >= 0) {\n          int m = FOLDS1_UNFOLDS_NUM(sindex);\n          for (i = 0; i < m; i++) {\n            cs[fn][i+1] = FOLDS1_UNFOLDS(sindex)[i];\n          }\n          ncs[fn] += m;\n        }\n      }\n\n      for (i = 0; i < ncs[0]; i++) {\n        for (j = 0; j < ncs[1]; j++) {\n          items[n].byte_len = lens[1];\n          items[n].code_len = 2;\n          items[n].code[0]  = cs[0][i];\n          items[n].code[1]  = cs[1][j];\n          if (items[n].code[0] == orig_codes[0] &&\n              items[n].code[1] == orig_codes[1])\n            continue;\n          n++;\n        }\n      }\n\n      return n;\n    }\n  }\n\n fold1:\n  if (buk1 != 0) {\n    if (buk1->fold_len == 1) {\n      int un;\n      items[0].byte_len = lens[0];\n      items[0].code_len = 1;\n      items[0].code[0]  = *FOLDS1_FOLD(buk1->index);\n      n++;\n\n      un = FOLDS1_UNFOLDS_NUM(buk1->index);\n      for (i = 0; i < un; i++) {\n        OnigCodePoint unfold = FOLDS1_UNFOLDS(buk1->index)[i];\n        if (unfold != orig_codes[0]) {\n          items[n].byte_len = lens[0];\n          items[n].code_len = 1;\n          items[n].code[0]  = unfold;\n          n++;\n        }\n      }\n    }\n    else if ((flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n      if (buk1->fold_len == 2) {\n        m = FOLDS2_UNFOLDS_NUM(buk1->index);\n        for (i = 0; i < m; i++) {\n          OnigCodePoint unfold = FOLDS2_UNFOLDS(buk1->index)[i];\n          if (unfold == orig_codes[0]) continue;\n\n          items[n].byte_len = lens[0];\n          items[n].code_len = 1;\n          items[n].code[0]  = unfold;\n          n++;\n        }\n\n        for (fn = 0; fn < 2; fn++) {\n          int index;\n          cs[fn][0] = FOLDS2_FOLD(buk1->index)[fn];\n          ncs[fn] = 1;\n          index = onigenc_unicode_fold1_key(&cs[fn][0]);\n          if (index >= 0) {\n            int m = FOLDS1_UNFOLDS_NUM(index);\n            for (i = 0; i < m; i++) {\n              cs[fn][i+1] = FOLDS1_UNFOLDS(index)[i];\n            }\n            ncs[fn] += m;\n          }\n        }\n\n        for (i = 0; i < ncs[0]; i++) {\n          for (j = 0; j < ncs[1]; j++) {\n            items[n].byte_len = lens[0];\n            items[n].code_len = 2;\n            items[n].code[0]  = cs[0][i];\n            items[n].code[1]  = cs[1][j];\n            n++;\n          }\n        }\n      }\n      else { /* fold_len == 3 */\n        m = FOLDS3_UNFOLDS_NUM(buk1->index);\n        for (i = 0; i < m; i++) {\n          OnigCodePoint unfold = FOLDS3_UNFOLDS(buk1->index)[i];\n          if (unfold == orig_codes[0]) continue;\n\n          items[n].byte_len = lens[0];\n          items[n].code_len = 1;\n          items[n].code[0]  = unfold;\n          n++;\n        }\n\n        for (fn = 0; fn < 3; fn++) {\n          int index;\n          cs[fn][0] = FOLDS3_FOLD(buk1->index)[fn];\n          ncs[fn] = 1;\n          index = onigenc_unicode_fold1_key(&cs[fn][0]);\n          if (index >= 0) {\n            int m = FOLDS1_UNFOLDS_NUM(index);\n            for (i = 0; i < m; i++) {\n              cs[fn][i+1] = FOLDS1_UNFOLDS(index)[i];\n            }\n            ncs[fn] += m;\n          }\n        }\n\n        for (i = 0; i < ncs[0]; i++) {\n          for (j = 0; j < ncs[1]; j++) {\n            for (k = 0; k < ncs[2]; k++) {\n              items[n].byte_len = lens[0];\n              items[n].code_len = 3;\n              items[n].code[0]  = cs[0][i];\n              items[n].code[1]  = cs[1][j];\n              items[n].code[2]  = cs[2][k];\n              n++;\n            }\n          }\n        }\n      }\n    }\n  }\n  else {\n    int index = onigenc_unicode_fold1_key(orig_codes);\n    if (index >= 0) {\n      int m = FOLDS1_UNFOLDS_NUM(index);\n      for (i = 0; i < m; i++) {\n        items[n].byte_len = lens[0];\n        items[n].code_len = 1;\n        items[n].code[0]  = FOLDS1_UNFOLDS(index)[i];\n        n++;\n      }\n    }\n  }\n\n  return n;\n}\n",
    "target": 1,
    "idx": 1025893,
    "stack_trace": [
      {
        "function_name": "onigenc_unicode_get_case_fold_codes_by_str",
        "function_body": "extern int\nonigenc_unicode_get_case_fold_codes_by_str(OnigEncoding enc,\n    OnigCaseFoldType flag, const OnigUChar* p, const OnigUChar* end,\n    OnigCaseFoldCodeItem items[])\n{\n  int n, m, i, j, k, len, lens[3];\n  int index;\n  int fn, ncs[3];\n  OnigCodePoint cs[3][4];\n  OnigCodePoint code, codes[3], orig_codes[3];\n  const struct ByUnfoldKey* buk1;\n\n  n = 0;\n\n  code = ONIGENC_MBC_TO_CODE(enc, p, end);\n  len = enclen(enc, p);\n\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n  if ((flag & ONIGENC_CASE_FOLD_TURKISH_AZERI) != 0) {\n    if (code == 0x0049) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0131;\n      return 1;\n    }\n    else if (code == 0x0130) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0069;\n      return 1;\n    }\n    else if (code == 0x0131) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0049;\n      return 1;\n    }\n    else if (code == 0x0069) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0130;\n      return 1;\n    }\n  }\n#endif\n\n  orig_codes[0] = code;\n  lens[0] = len;\n  p += len;\n\n  buk1 = onigenc_unicode_unfold_key(orig_codes[0]);\n  if (buk1 != 0 && buk1->fold_len == 1) {\n    codes[0] = *FOLDS1_FOLD(buk1->index);\n  }\n  else\n    codes[0] = orig_codes[0];\n\n  if ((flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) == 0)\n    goto fold1;\n\n  if (p < end) {\n    const struct ByUnfoldKey* buk;\n\n    code = ONIGENC_MBC_TO_CODE(enc, p, end);\n    orig_codes[1] = code;\n    len = enclen(enc, p);\n    lens[1] = lens[0] + len;\n    buk = onigenc_unicode_unfold_key(orig_codes[1]);\n    if (buk != 0 && buk->fold_len == 1) {\n      codes[1] = *FOLDS1_FOLD(buk->index);\n    }\n    else\n      codes[1] = orig_codes[1];\n\n    p += len;\n    if (p < end) {\n      code = ONIGENC_MBC_TO_CODE(enc, p, end);\n      orig_codes[2] = code;\n      len = enclen(enc, p);\n      lens[2] = lens[1] + len;\n      buk = onigenc_unicode_unfold_key(orig_codes[2]);\n      if (buk != 0 && buk->fold_len == 1) {\n        codes[2] = *FOLDS1_FOLD(buk->index);\n      }\n      else\n        codes[2] = orig_codes[2];\n\n      index = onigenc_unicode_fold3_key(codes);\n      if (index >= 0) {\n        m = FOLDS3_UNFOLDS_NUM(index);\n        for (i = 0; i < m; i++) {\n          items[n].byte_len = lens[2];\n          items[n].code_len = 1;\n          items[n].code[0]  = FOLDS3_UNFOLDS(index)[i];\n          n++;\n        }\n\n        for (fn = 0; fn < 3; fn++) {\n          int sindex;\n          cs[fn][0] = FOLDS3_FOLD(index)[fn];\n          ncs[fn] = 1;\n          sindex = onigenc_unicode_fold1_key(&cs[fn][0]);\n          if (sindex >= 0) {\n            int m = FOLDS1_UNFOLDS_NUM(sindex);\n            for (i = 0; i < m; i++) {\n              cs[fn][i+1] = FOLDS1_UNFOLDS(sindex)[i];\n            }\n            ncs[fn] += m;\n          }\n        }\n\n        for (i = 0; i < ncs[0]; i++) {\n          for (j = 0; j < ncs[1]; j++) {\n            for (k = 0; k < ncs[2]; k++) {\n              items[n].byte_len = lens[2];\n              items[n].code_len = 3;\n              items[n].code[0]  = cs[0][i];\n              items[n].code[1]  = cs[1][j];\n              items[n].code[2]  = cs[2][k];\n              if (items[n].code[0] == orig_codes[0] &&\n                  items[n].code[1] == orig_codes[1] &&\n                  items[n].code[2] == orig_codes[2])\n                continue;\n              n++;\n            }\n          }\n        }\n\n        return n;\n      }\n    }\n\n    index = onigenc_unicode_fold2_key(codes);\n    if (index >= 0) {\n      m = FOLDS2_UNFOLDS_NUM(index);\n      for (i = 0; i < m; i++) {\n        items[n].byte_len = lens[1];\n        items[n].code_len = 1;\n        items[n].code[0]  = FOLDS2_UNFOLDS(index)[i];\n        n++;\n      }\n\n      for (fn = 0; fn < 2; fn++) {\n        int sindex;\n        cs[fn][0] = FOLDS2_FOLD(index)[fn];\n        ncs[fn] = 1;\n        sindex = onigenc_unicode_fold1_key(&cs[fn][0]);\n        if (sindex >= 0) {\n          int m = FOLDS1_UNFOLDS_NUM(sindex);\n          for (i = 0; i < m; i++) {\n            cs[fn][i+1] = FOLDS1_UNFOLDS(sindex)[i];\n          }\n          ncs[fn] += m;\n        }\n      }\n\n      for (i = 0; i < ncs[0]; i++) {\n        for (j = 0; j < ncs[1]; j++) {\n          if (cs[0][i] == orig_codes[0] && cs[1][j] == orig_codes[1])\n            continue;\n          items[n].byte_len = lens[1];\n          items[n].code_len = 2;\n          items[n].code[0]  = cs[0][i];\n          items[n].code[1]  = cs[1][j];\n          n++;\n        }\n      }\n\n      return n;\n    }\n  }\n\n fold1:\n  if (buk1 != 0) {\n    if (buk1->fold_len == 1) {\n      int un;\n      items[0].byte_len = lens[0];\n      items[0].code_len = 1;\n      items[0].code[0]  = *FOLDS1_FOLD(buk1->index);\n      n++;\n\n      un = FOLDS1_UNFOLDS_NUM(buk1->index);\n      for (i = 0; i < un; i++) {\n        OnigCodePoint unfold = FOLDS1_UNFOLDS(buk1->index)[i];\n        if (unfold != orig_codes[0]) {\n          items[n].byte_len = lens[0];\n          items[n].code_len = 1;\n          items[n].code[0]  = unfold;\n          n++;\n        }\n      }\n    }\n    else if ((flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n      if (buk1->fold_len == 2) {\n        m = FOLDS2_UNFOLDS_NUM(buk1->index);\n        for (i = 0; i < m; i++) {\n          OnigCodePoint unfold = FOLDS2_UNFOLDS(buk1->index)[i];\n          if (unfold == orig_codes[0]) continue;\n\n          items[n].byte_len = lens[0];\n          items[n].code_len = 1;\n          items[n].code[0]  = unfold;\n          n++;\n        }\n\n        for (fn = 0; fn < 2; fn++) {\n          int index;\n          cs[fn][0] = FOLDS2_FOLD(buk1->index)[fn];\n          ncs[fn] = 1;\n          index = onigenc_unicode_fold1_key(&cs[fn][0]);\n          if (index >= 0) {\n            int m = FOLDS1_UNFOLDS_NUM(index);\n            for (i = 0; i < m; i++) {\n              cs[fn][i+1] = FOLDS1_UNFOLDS(index)[i];\n            }\n            ncs[fn] += m;\n          }\n        }\n\n        for (i = 0; i < ncs[0]; i++) {\n          for (j = 0; j < ncs[1]; j++) {\n            items[n].byte_len = lens[0];\n            items[n].code_len = 2;\n            items[n].code[0]  = cs[0][i];\n            items[n].code[1]  = cs[1][j];\n            n++;\n          }\n        }\n      }\n      else { /* fold_len == 3 */\n        m = FOLDS3_UNFOLDS_NUM(buk1->index);\n        for (i = 0; i < m; i++) {\n          OnigCodePoint unfold = FOLDS3_UNFOLDS(buk1->index)[i];\n          if (unfold == orig_codes[0]) continue;\n\n          items[n].byte_len = lens[0];\n          items[n].code_len = 1;\n          items[n].code[0]  = unfold;\n          n++;\n        }\n\n        for (fn = 0; fn < 3; fn++) {\n          int index;\n          cs[fn][0] = FOLDS3_FOLD(buk1->index)[fn];\n          ncs[fn] = 1;\n          index = onigenc_unicode_fold1_key(&cs[fn][0]);\n          if (index >= 0) {\n            int m = FOLDS1_UNFOLDS_NUM(index);\n            for (i = 0; i < m; i++) {\n              cs[fn][i+1] = FOLDS1_UNFOLDS(index)[i];\n            }\n            ncs[fn] += m;\n          }\n        }\n\n        for (i = 0; i < ncs[0]; i++) {\n          for (j = 0; j < ncs[1]; j++) {\n            for (k = 0; k < ncs[2]; k++) {\n              items[n].byte_len = lens[0];\n              items[n].code_len = 3;\n              items[n].code[0]  = cs[0][i];\n              items[n].code[1]  = cs[1][j];\n              items[n].code[2]  = cs[2][k];\n              n++;\n            }\n          }\n        }\n      }\n    }\n  }\n  else {\n    int index = onigenc_unicode_fold1_key(orig_codes);\n    if (index >= 0) {\n      int m = FOLDS1_UNFOLDS_NUM(index);\n      for (i = 0; i < m; i++) {\n        items[n].byte_len = lens[0];\n        items[n].code_len = 1;\n        items[n].code[0]  = FOLDS1_UNFOLDS(index)[i];\n        n++;\n      }\n    }\n  }\n\n  return n;\n}",
        "file_path": "/src/oniguruma/src/unicode.c",
        "crashing_line": "          if (cs[0][i] == orig_codes[0] && cs[1][j] == orig_codes[1])",
        "crashing_line_number": 434
      },
      {
        "function_name": "utf16be_get_case_fold_codes_by_str",
        "function_body": "static int\nutf16be_get_case_fold_codes_by_str(OnigCaseFoldType flag,\n    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])\n{\n  return onigenc_unicode_get_case_fold_codes_by_str(ONIG_ENCODING_UTF16_BE,\n                                                    flag, p, end, items);\n}",
        "file_path": "/src/oniguruma/src/utf16_be.c",
        "crashing_line": "  return onigenc_unicode_get_case_fold_codes_by_str(ONIG_ENCODING_UTF16_BE,",
        "crashing_line_number": 250
      },
      {
        "function_name": "unravel_case_fold_string",
        "function_body": "static int\nunravel_case_fold_string(Node* node, regex_t* reg, int state)\n{\n  int r, n, in_look_behind;\n  OnigLen min_len, max_len, one_len;\n  UChar *start, *end, *p, *q;\n  StrNode* snode;\n  Node *sn, *list;\n  OnigEncoding enc;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n\n  if (NODE_STRING_IS_CASE_EXPANDED(node)) return 0;\n\n  NODE_STATUS_REMOVE(node, IGNORECASE);\n  snode = STR_(node);\n  start = snode->s;\n  end   = snode->end;\n  if (start >= end) return 0;\n\n  in_look_behind = (state & IN_LOOK_BEHIND) != 0;\n  enc = reg->enc;\n\n  list = sn = NULL_NODE;\n  p = start;\n  while (p < end) {\n    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(enc, reg->case_fold_flag, p, end,\n                                           items);\n    if (n < 0) {\n      r = n;\n      goto err;\n    }\n\n    one_len = (OnigLen )enclen(enc, p);\n    if (n == 0) {\n      q = p + one_len;\n      if (q > end) q = end;\n      r = unravel_cf_string_add(&list, &sn, p, q, 0 /* flag */);\n      if (r != 0) goto err;\n    }\n    else {\n      if (in_look_behind != 0) {\n        q = p + one_len;\n        if (items[0].byte_len != one_len) {\n          r = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(enc, reg->case_fold_flag, p, q,\n                                                 items);\n          if (r < 0) goto err;\n          n = r;\n        }\n        r = unravel_cf_look_behind_add(&list, &sn, n, items, enc, p, one_len);\n        if (r != 0) goto err;\n      }\n      else {\n        get_min_max_byte_len_case_fold_items(n, items, &min_len, &max_len);\n        if (min_len != max_len) {\n          r = ONIGERR_PARSER_BUG;\n          goto err;\n        }\n\n        q = p + max_len;\n        r = unravel_cf_string_alt_or_cc_add(&list, n, items, enc,\n                                            reg->case_fold_flag, p, q);\n        if (r != 0) goto err;\n        sn = NULL_NODE;\n      }\n    }\n\n    p = q;\n  }\n\n  if (IS_NOT_NULL(list)) {\n    if (node_list_len(list) == 1) {\n      node_swap(node, NODE_CAR(list));\n    }\n    else {\n      node_swap(node, list);\n    }\n    onig_node_free(list);\n  }\n  else {\n    node_swap(node, sn);\n    onig_node_free(sn);\n  }\n  return 0;\n\n err:\n  if (IS_NOT_NULL(list))\n    onig_node_free(list);\n  else if (IS_NOT_NULL(sn))\n    onig_node_free(sn);\n\n  return r;\n}",
        "file_path": "/src/oniguruma/src/regcomp.c",
        "crashing_line": "    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(enc, reg->case_fold_flag, p, end,",
        "crashing_line_number": 5111
      },
      {
        "function_name": "tune_tree",
        "function_body": "static int\ntune_tree(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    {\n      Node* prev = NULL_NODE;\n      do {\n        r = tune_tree(NODE_CAR(node), reg, state, env);\n        if (IS_NOT_NULL(prev) && r == 0) {\n          r = tune_next(prev, NODE_CAR(node), reg);\n        }\n        prev = NODE_CAR(node);\n      } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n  case NODE_ALT:\n    do {\n      r = tune_tree(NODE_CAR(node), reg, (state | IN_ALT), env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_STRING:\n    if (NODE_IS_IGNORECASE(node) && ! NODE_STRING_IS_CRUDE(node)) {\n      r = unravel_case_fold_string(node, reg, state);\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      int i;\n      int* p;\n      BackRefNode* br = BACKREF_(node);\n      p = BACKREFS_P(br);\n      for (i = 0; i < br->back_num; i++) {\n        if (p[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;\n        MEM_STATUS_ON(env->backrefed_mem, p[i]);\n#if 0\n#ifdef USE_BACKREF_WITH_LEVEL\n        if (NODE_IS_NEST_LEVEL(node)) {\n          MEM_STATUS_ON(env->backtrack_mem, p[i]);\n        }\n#endif\n#else\n        /* More precisely, it should be checked whether alt/repeat exists before\n           the subject capture node, and then this backreference position\n           exists before (or in) the capture node. */\n        MEM_STATUS_ON(env->backtrack_mem, p[i]);\n#endif\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_OPTION:\n        {\n          OnigOptionType options = reg->options;\n          reg->options = BAG_(node)->o.options;\n          r = tune_tree(NODE_BODY(node), reg, state, env);\n          reg->options = options;\n        }\n        break;\n\n      case BAG_MEMORY:\n#ifdef USE_CALL\n        state |= en->m.called_state;\n#endif\n\n        if ((state & (IN_ALT | IN_NOT | IN_VAR_REPEAT | IN_MULTI_ENTRY)) != 0\n            || NODE_IS_RECURSION(node)) {\n          MEM_STATUS_ON(env->backtrack_mem, en->m.regnum);\n        }\n        r = tune_tree(NODE_BODY(node), reg, state, env);\n        break;\n\n      case BAG_STOP_BACKTRACK:\n        {\n          Node* target = NODE_BODY(node);\n          r = tune_tree(target, reg, state, env);\n          if (NODE_TYPE(target) == NODE_QUANT) {\n            QuantNode* tqn = QUANT_(target);\n            if (IS_INFINITE_REPEAT(tqn->upper) && tqn->lower <= 1 &&\n                tqn->greedy != 0) {  /* (?>a*), a*+ etc... */\n              if (is_strict_real_node(NODE_BODY(target)))\n                NODE_STATUS_ADD(node, STRICT_REAL_REPEAT);\n            }\n          }\n        }\n        break;\n\n      case BAG_IF_ELSE:\n        r = tune_tree(NODE_BODY(node), reg, (state | IN_ALT), env);\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = tune_tree(en->te.Then, reg, (state | IN_ALT), env);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          r = tune_tree(en->te.Else, reg, (state | IN_ALT), env);\n        break;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    r = tune_quant(node, reg, state, env);\n    break;\n\n  case NODE_ANCHOR:\n    r = tune_anchor(node, reg, state, env);\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n#endif\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return r;\n}",
        "file_path": "/src/oniguruma/src/regcomp.c",
        "crashing_line": "      r = unravel_case_fold_string(node, reg, state);",
        "crashing_line_number": 5829
      },
      {
        "function_name": "onig_compile",
        "function_body": "extern int\nonig_compile(regex_t* reg, const UChar* pattern, const UChar* pattern_end,\n             OnigErrorInfo* einfo)\n{\n  int r;\n  Node*  root;\n  ScanEnv  scan_env;\n#ifdef USE_CALL\n  UnsetAddrList  uslist = {0};\n#endif\n\n  root = 0;\n  if (IS_NOT_NULL(einfo)) {\n    einfo->enc = reg->enc;\n    einfo->par = (UChar* )NULL;\n  }\n\n#ifdef ONIG_DEBUG\n  fprintf(DBGFP, \"\\nPATTERN: /\");\n  print_enc_string(DBGFP, reg->enc, pattern, pattern_end);\n#endif\n\n  if (reg->ops_alloc == 0) {\n    r = ops_init(reg, OPS_INIT_SIZE);\n    if (r != 0) goto end;\n  }\n  else\n    reg->ops_used = 0;\n\n  r = onig_parse_tree(&root, pattern, pattern_end, reg, &scan_env);\n  if (r != 0) goto err;\n\n  r = reduce_string_list(root, reg->enc);\n  if (r != 0) goto err;\n\n  /* mixed use named group and no-named group */\n  if (scan_env.num_named > 0 &&\n      IS_SYNTAX_BV(scan_env.syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      ! OPTON_CAPTURE_GROUP(reg->options)) {\n    if (scan_env.num_named != scan_env.num_mem)\n      r = disable_noname_group_capture(&root, reg, &scan_env);\n    else\n      r = numbered_ref_check(root);\n\n    if (r != 0) goto err;\n  }\n\n  r = check_backrefs(root, &scan_env);\n  if (r != 0) goto err;\n\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    r = unset_addr_list_init(&uslist, scan_env.num_call);\n    if (r != 0) goto err;\n    scan_env.unset_addr_list = &uslist;\n    r = tune_call(root, &scan_env, 0);\n    if (r != 0) goto err_unset;\n    r = tune_call2(root);\n    if (r != 0) goto err_unset;\n    r = recursive_call_check_trav(root, &scan_env, 0);\n    if (r  < 0) goto err_unset;\n    r = infinite_recursive_call_check_trav(root, &scan_env);\n    if (r != 0) goto err_unset;\n\n    tune_called_state(root, 0);\n  }\n\n  reg->num_call = scan_env.num_call;\n#endif\n\n#ifdef ONIG_DEBUG_PARSE\n  fprintf(DBGFP, \"MAX PARSE DEPTH: %d\\n\", scan_env.max_parse_depth);\n  fprintf(DBGFP, \"TREE (parsed)\\n\");\n  print_tree(DBGFP, root);\n  fprintf(DBGFP, \"\\n\");\n#endif\n\n  r = tune_tree(root, reg, 0, &scan_env);\n  if (r != 0) goto err_unset;\n\n  if (scan_env.backref_num != 0) {\n    set_parent_node_trav(root, NULL_NODE);\n    r = set_empty_repeat_node_trav(root, NULL_NODE, &scan_env);\n    if (r != 0) goto err_unset;\n    set_empty_status_check_trav(root, &scan_env);\n  }\n\n#ifdef ONIG_DEBUG_PARSE\n  fprintf(DBGFP, \"TREE (after tune)\\n\");\n  print_tree(DBGFP, root);\n  fprintf(DBGFP, \"\\n\");\n#endif\n\n  reg->capture_history = scan_env.cap_history;\n  reg->push_mem_start  = scan_env.backtrack_mem | scan_env.cap_history;\n\n#ifdef USE_CALLOUT\n  if (IS_NOT_NULL(reg->extp) && reg->extp->callout_num != 0) {\n    reg->push_mem_end = reg->push_mem_start;\n  }\n  else {\n    if (MEM_STATUS_IS_ALL_ON(reg->push_mem_start))\n      reg->push_mem_end = scan_env.backrefed_mem | scan_env.cap_history;\n    else\n      reg->push_mem_end = reg->push_mem_start &\n                        (scan_env.backrefed_mem | scan_env.cap_history);\n  }\n#else\n  if (MEM_STATUS_IS_ALL_ON(reg->push_mem_start))\n    reg->push_mem_end = scan_env.backrefed_mem | scan_env.cap_history;\n  else\n    reg->push_mem_end = reg->push_mem_start &\n                      (scan_env.backrefed_mem | scan_env.cap_history);\n#endif\n\n  clear_optimize_info(reg);\n#ifndef ONIG_DONT_OPTIMIZE\n  r = set_optimize_info_from_tree(root, reg, &scan_env);\n  if (r != 0) goto err_unset;\n#endif\n\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic)) {\n    xfree(scan_env.mem_env_dynamic);\n    scan_env.mem_env_dynamic = (MemEnv* )NULL;\n  }\n\n  r = compile_tree(root, reg, &scan_env);\n  if (r == 0) {\n    if (scan_env.keep_num > 0) {\n      r = add_op(reg, OP_UPDATE_VAR);\n      if (r != 0) goto err;\n\n      COP(reg)->update_var.type = UPDATE_VAR_KEEP_FROM_STACK_LAST;\n      COP(reg)->update_var.id   = 0; /* not used */\n      COP(reg)->update_var.clear = FALSE;\n    }\n\n    r = add_op(reg, OP_END);\n    if (r != 0) goto err;\n\n#ifdef USE_CALL\n    if (scan_env.num_call > 0) {\n      r = fix_unset_addr_list(&uslist, reg);\n      unset_addr_list_end(&uslist);\n      if (r != 0) goto err;\n    }\n#endif\n\n    set_addr_in_repeat_range(reg);\n\n    if ((reg->push_mem_end != 0)\n#ifdef USE_REPEAT_AND_EMPTY_CHECK_LOCAL_VAR\n        || (reg->num_repeat      != 0)\n        || (reg->num_empty_check != 0)\n#endif\n#ifdef USE_CALLOUT\n        || (IS_NOT_NULL(reg->extp) && reg->extp->callout_num != 0)\n#endif\n#ifdef USE_CALL\n        || scan_env.num_call > 0\n#endif\n        )\n      reg->stack_pop_level = STACK_POP_LEVEL_ALL;\n    else {\n      if (reg->push_mem_start != 0)\n        reg->stack_pop_level = STACK_POP_LEVEL_MEM_START;\n      else\n        reg->stack_pop_level = STACK_POP_LEVEL_FREE;\n    }\n\n    r = ops_make_string_pool(reg);\n    if (r != 0) goto err;\n  }\n#ifdef USE_CALL\n  else if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n  onig_node_free(root);\n\n#ifdef ONIG_DEBUG_COMPILE\n  onig_print_names(DBGFP, reg);\n  onig_print_compiled_byte_code_list(DBGFP, reg);\n#endif\n\n#ifdef USE_DIRECT_THREADED_CODE\n  /* opcode -> opaddr */\n  onig_init_for_match_at(reg);\n#endif\n\n end:\n  return r;\n\n err_unset:\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n err:\n  if (IS_NOT_NULL(scan_env.error)) {\n    if (IS_NOT_NULL(einfo)) {\n      einfo->par     = scan_env.error;\n      einfo->par_end = scan_env.error_end;\n    }\n  }\n\n  onig_node_free(root);\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic))\n      xfree(scan_env.mem_env_dynamic);\n  return r;\n}",
        "file_path": "/src/oniguruma/src/regcomp.c",
        "crashing_line": "  r = tune_tree(root, reg, 0, &scan_env);",
        "crashing_line_number": 7328
      },
      {
        "function_name": "onig_new",
        "function_body": "extern int\nonig_new(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n         OnigOptionType option, OnigEncoding enc, OnigSyntaxType* syntax,\n         OnigErrorInfo* einfo)\n{\n  int r;\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) return ONIGERR_MEMORY;\n\n  r = onig_reg_init(*reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);\n  if (r != 0) {\n    xfree(*reg);\n    *reg = NULL;\n    return r;\n  }\n\n  r = onig_compile(*reg, pattern, pattern_end, einfo);\n  if (r != 0) {\n    onig_free(*reg);\n    *reg = NULL;\n  }\n  return r;\n}",
        "file_path": "/src/oniguruma/src/regcomp.c",
        "crashing_line": "  r = onig_compile(*reg, pattern, pattern_end, einfo);",
        "crashing_line_number": 7552
      },
      {
        "function_name": "exec",
        "function_body": "static int\nexec(OnigEncoding enc, OnigOptionType options, OnigSyntaxType* syntax,\n     char* apattern, char* apattern_end, char* astr, UChar* end, int backward,\n     int sl)\n{\n  int r;\n  regex_t* reg;\n  OnigErrorInfo einfo;\n  UChar* pattern = (UChar* )apattern;\n  UChar* str     = (UChar* )astr;\n  UChar* pattern_end = (UChar* )apattern_end;\n\n  EXEC_COUNT++;\n  EXEC_COUNT_INTERVAL++;\n\n  onig_initialize(&enc, 1);\n#ifdef PARSE_DEPTH_LIMIT\n  onig_set_parse_depth_limit(PARSE_DEPTH_LIMIT);\n#endif\n  onig_set_subexp_call_max_nest_level(CALL_MAX_NEST_LEVEL);\n\n  r = onig_new(&reg, pattern, pattern_end,\n               (options & OPTIONS_AT_COMPILE), enc, syntax, &einfo);\n  if (r != ONIG_NORMAL) {\n    char s[ONIG_MAX_ERROR_MESSAGE_LEN];\n    onig_error_code_to_str((UChar* )s, r, &einfo);\n#ifdef STANDALONE\n    fprintf(stdout, \"ERROR: %s\\n\", s);\n#endif\n    onig_end();\n\n    if (r == ONIGERR_PARSER_BUG ||\n        r == ONIGERR_STACK_BUG  ||\n        r == ONIGERR_UNDEFINED_BYTECODE ||\n        r == ONIGERR_UNEXPECTED_BYTECODE) {\n      return -2;\n    }\n    else\n      return -1;\n  }\n  REGEX_SUCCESS_COUNT++;\n\n  r = search(reg, pattern, pattern_end, options, backward, sl);\n  if (r == -2) return -2;\n\n  if (onigenc_is_valid_mbc_string(enc, str, end) != 0) {\n    VALID_STRING_COUNT++;\n    r = search(reg, str, end, options, backward, sl);\n    if (r == -2) return -2;\n  }\n\n  onig_free(reg);\n  onig_end();\n  return 0;\n}",
        "file_path": "/src/oniguruma/harnesses/base.c",
        "crashing_line": "  r = onig_new(&reg, pattern, pattern_end,",
        "crashing_line_number": 222
      },
      {
        "function_name": "alloc_exec",
        "function_body": "static int\nalloc_exec(OnigEncoding enc, OnigOptionType options, OnigSyntaxType* syntax,\n           int backward, int pattern_size, size_t rem_size, unsigned char *data)\n{\n  extern int onig_detect_can_be_slow_pattern(const UChar* pattern, const UChar* pattern_end, OnigOptionType option, OnigEncoding enc, OnigSyntaxType* syntax);\n\n  int r;\n  int sl;\n  unsigned char *pattern;\n  unsigned char *pattern_end;\n  unsigned char *str_null_end;\n\n  pattern = (unsigned char *)malloc(pattern_size != 0 ? pattern_size : 1);\n  memcpy(pattern, data, pattern_size);\n  pattern_end = pattern + pattern_size;\n  data += pattern_size;\n  rem_size -= pattern_size;\n\n  if (rem_size > MAX_REM_SIZE) rem_size = MAX_REM_SIZE;\n\n  sl = onig_detect_can_be_slow_pattern(pattern, pattern_end, options, enc, syntax);\n  if (sl > 0) {\n    if (rem_size > MAX_SLOW_REM_SIZE)\n      rem_size = MAX_SLOW_REM_SIZE;\n  }\n\n  ADJUST_LEN(enc, rem_size);\n#ifdef STANDALONE\n  fprintf(stdout, \"rem_size: %ld\\n\", rem_size);\n#endif\n\n  unsigned char *str = (unsigned char*)malloc(rem_size != 0 ? rem_size : 1);\n  memcpy(str, data, rem_size);\n  str_null_end = str + rem_size;\n\n  r = exec(enc, options, syntax,\n           (char *)pattern, (char *)pattern_end,\n           (char *)str, str_null_end, backward, sl);\n\n  free(pattern);\n  free(str);\n  return r;\n}",
        "file_path": "/src/oniguruma/harnesses/base.c",
        "crashing_line": "  r = exec(enc, options, syntax,",
        "crashing_line_number": 292
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "\n/* Read in the armap of an XCOFF archive.  */\n\nbfd_boolean\n_bfd_xcoff_slurp_armap (bfd *abfd)\n{\n  file_ptr off;\n  size_t namlen;\n  bfd_size_type sz;\n  bfd_byte *contents, *cend;\n  bfd_vma c, i;\n  carsym *arsym;\n  bfd_byte *p;\n\n  if (xcoff_ardata (abfd) == NULL)\n    {\n      abfd->has_armap = FALSE;\n      return TRUE;\n    }\n\n  if (! xcoff_big_format_p (abfd))\n    {\n      /* This is for the old format.  */\n      struct xcoff_ar_hdr hdr;\n\n      GET_VALUE_IN_FIELD (off, xcoff_ardata (abfd)->symoff, 10);\n      if (off == 0)\n\t{\n\t  abfd->has_armap = FALSE;\n\t  return TRUE;\n\t}\n\n      if (bfd_seek (abfd, off, SEEK_SET) != 0)\n\treturn FALSE;\n\n      /* The symbol table starts with a normal archive header.  */\n      if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)\n\t  != SIZEOF_AR_HDR)\n\treturn FALSE;\n\n      /* Skip the name (normally empty).  */\n      GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);\n      off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;\n      if (bfd_seek (abfd, off, SEEK_CUR) != 0)\n\treturn FALSE;\n\n      GET_VALUE_IN_FIELD (sz, hdr.size, 10);\n\n      /* Read in the entire symbol table.  */\n      contents = (bfd_byte *) bfd_alloc (abfd, sz);\n      if (contents == NULL)\n\treturn FALSE;\n      if (bfd_bread (contents, sz, abfd) != sz)\n\treturn FALSE;\n\n      /* The symbol table starts with a four byte count.  */\n      c = H_GET_32 (abfd, contents);\n\n      if (c * 4 >= sz)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return FALSE;\n\t}\n\n      bfd_ardata (abfd)->symdefs =\n\t((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));\n      if (bfd_ardata (abfd)->symdefs == NULL)\n\treturn FALSE;\n\n      /* After the count comes a list of four byte file offsets.  */\n      for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 4;\n\t   i < c;\n\t   ++i, ++arsym, p += 4)\n\tarsym->file_offset = H_GET_32 (abfd, p);\n    }\n  else\n    {\n      /* This is for the new format.  */\n      struct xcoff_ar_hdr_big hdr;\n\n      GET_VALUE_IN_FIELD (off, xcoff_ardata_big (abfd)->symoff, 10);\n      if (off == 0)\n\t{\n\t  abfd->has_armap = FALSE;\n\t  return TRUE;\n\t}\n\n      if (bfd_seek (abfd, off, SEEK_SET) != 0)\n\treturn FALSE;\n\n      /* The symbol table starts with a normal archive header.  */\n      if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)\n\t  != SIZEOF_AR_HDR_BIG)\n\treturn FALSE;\n\n      /* Skip the name (normally empty).  */\n      GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);\n      off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;\n      if (bfd_seek (abfd, off, SEEK_CUR) != 0)\n\treturn FALSE;\n\n      GET_VALUE_IN_FIELD (sz, hdr.size, 10);\n\n      /* Read in the entire symbol table.  */\n      contents = (bfd_byte *) bfd_alloc (abfd, sz);\n      if (contents == NULL)\n\treturn FALSE;\n      if (bfd_bread (contents, sz, abfd) != sz)\n\treturn FALSE;\n\n      /* The symbol table starts with an eight byte count.  */\n      c = H_GET_64 (abfd, contents);\n\n      if (c * 8 >= sz)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return FALSE;\n\t}\n\n      bfd_ardata (abfd)->symdefs =\n\t((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));\n      if (bfd_ardata (abfd)->symdefs == NULL)\n\treturn FALSE;\n\n      /* After the count comes a list of eight byte file offsets.  */\n      for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 8;\n\t   i < c;\n\t   ++i, ++arsym, p += 8)\n\tarsym->file_offset = H_GET_64 (abfd, p);\n    }\n\n  /* After the file offsets come null terminated symbol names.  */\n  cend = contents + sz;\n  for (i = 0, arsym = bfd_ardata (abfd)->symdefs;\n       i < c;\n       ++i, ++arsym, p += strlen ((char *) p) + 1)\n    {\n      if (p >= cend)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return FALSE;\n\t}\n      arsym->name = (char *) p;\n    }\n\n  bfd_ardata (abfd)->symdef_count = c;\n  abfd->has_armap = TRUE;\n\nstatic bfd_boolean\nxcoff64_slurp_armap (bfd *abfd)\n{\n  file_ptr off;\n  size_t namlen;\n  bfd_size_type sz, amt;\n  bfd_byte *contents, *cend;\n  bfd_vma c, i;\n  carsym *arsym;\n  bfd_byte *p;\n  file_ptr pos;\n\n  /* This is for the new format.  */\n  struct xcoff_ar_hdr_big hdr;\n\n  if (xcoff_ardata (abfd) == NULL)\n    {\n      abfd->has_armap = FALSE;\n      return TRUE;\n    }\n\n  off = bfd_scan_vma (xcoff_ardata_big (abfd)->symoff64,\n\t\t      (const char **) NULL, 10);\n  if (off == 0)\n    {\n      abfd->has_armap = FALSE;\n      return TRUE;\n    }\n\n  if (bfd_seek (abfd, off, SEEK_SET) != 0)\n    return FALSE;\n\n  /* The symbol table starts with a normal archive header.  */\n  if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)\n      != SIZEOF_AR_HDR_BIG)\n    return FALSE;\n\n  /* Skip the name (normally empty).  */\n  GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);\n  pos = ((namlen + 1) & ~(size_t) 1) + SXCOFFARFMAG;\n  if (bfd_seek (abfd, pos, SEEK_CUR) != 0)\n    return FALSE;\n\n  sz = bfd_scan_vma (hdr.size, (const char **) NULL, 10);\n\n  /* Read in the entire symbol table.  */\n  contents = (bfd_byte *) bfd_alloc (abfd, sz);\n  if (contents == NULL)\n    return FALSE;\n  if (bfd_bread (contents, sz, abfd) != sz)\n    return FALSE;\n\n  /* The symbol table starts with an eight byte count.  */\n  c = H_GET_64 (abfd, contents);\n\n  if (c * 8 >= sz)\n    {\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n  amt = c;\n  amt *= sizeof (carsym);\n  bfd_ardata (abfd)->symdefs = (carsym *) bfd_alloc (abfd, amt);\n  if (bfd_ardata (abfd)->symdefs == NULL)\n    return FALSE;\n\n  /* After the count comes a list of eight byte file offsets.  */\n  for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 8;\n       i < c;\n       ++i, ++arsym, p += 8)\n    arsym->file_offset = H_GET_64 (abfd, p);\n\n  /* After the file offsets come null terminated symbol names.  */\n  cend = contents + sz;\n  for (i = 0, arsym = bfd_ardata (abfd)->symdefs;\n       i < c;\n       ++i, ++arsym, p += strlen ((char *) p) + 1)\n    {\n      if (p >= cend)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return FALSE;\n\t}\n      arsym->name = (char *) p;\n    }\n\n  bfd_ardata (abfd)->symdef_count = c;\n  abfd->has_armap = TRUE;\n\n  return TRUE;\n",
    "target": 1,
    "idx": 1019573,
    "stack_trace": [
      {
        "function_name": "xcoff64_slurp_armap",
        "function_body": "\nstatic bfd_boolean\nxcoff64_slurp_armap (bfd *abfd)\n{\n  file_ptr off;\n  size_t namlen;\n  bfd_size_type sz, amt;\n  bfd_byte *contents, *cend;\n  bfd_vma c, i;\n  carsym *arsym;\n  bfd_byte *p;\n  file_ptr pos;\n\n  /* This is for the new format.  */\n  struct xcoff_ar_hdr_big hdr;\n\n  if (xcoff_ardata (abfd) == NULL)\n    {\n      abfd->has_armap = FALSE;\n      return TRUE;\n    }\n\n  off = bfd_scan_vma (xcoff_ardata_big (abfd)->symoff64,\n\t\t      (const char **) NULL, 10);\n  if (off == 0)\n    {\n      abfd->has_armap = FALSE;\n      return TRUE;\n    }\n\n  if (bfd_seek (abfd, off, SEEK_SET) != 0)\n    return FALSE;\n\n  /* The symbol table starts with a normal archive header.  */\n  if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)\n      != SIZEOF_AR_HDR_BIG)\n    return FALSE;\n\n  /* Skip the name (normally empty).  */\n  GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);\n  pos = ((namlen + 1) & ~(size_t) 1) + SXCOFFARFMAG;\n  if (bfd_seek (abfd, pos, SEEK_CUR) != 0)\n    return FALSE;\n\n  sz = bfd_scan_vma (hdr.size, (const char **) NULL, 10);\n  if (sz == (bfd_size_type) -1)\n    {\n      bfd_set_error (bfd_error_no_memory);\n      return FALSE;\n    }\n\n  /* Read in the entire symbol table.  */\n  contents = (bfd_byte *) bfd_alloc (abfd, sz + 1);\n  if (contents == NULL)\n    return FALSE;\n  if (bfd_bread (contents, sz, abfd) != sz)\n    return FALSE;\n\n  /* Ensure strings are NULL terminated so we don't wander off the end\n     of the buffer.  */\n  contents[sz] = 0;\n\n  /* The symbol table starts with an eight byte count.  */\n  c = H_GET_64 (abfd, contents);\n\n  if (c >= sz / 8)\n    {\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n  amt = c;\n  amt *= sizeof (carsym);\n  bfd_ardata (abfd)->symdefs = (carsym *) bfd_alloc (abfd, amt);\n  if (bfd_ardata (abfd)->symdefs == NULL)\n    return FALSE;\n\n  /* After the count comes a list of eight byte file offsets.  */\n  for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 8;\n       i < c;\n       ++i, ++arsym, p += 8)\n    arsym->file_offset = H_GET_64 (abfd, p);\n\n  /* After the file offsets come null terminated symbol names.  */\n  cend = contents + sz;\n  for (i = 0, arsym = bfd_ardata (abfd)->symdefs;\n       i < c;\n       ++i, ++arsym, p += strlen ((char *) p) + 1)\n    {\n      if (p >= cend)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return FALSE;\n\t}\n      arsym->name = (char *) p;\n    }\n\n  bfd_ardata (abfd)->symdef_count = c;\n  abfd->has_armap = TRUE;\n\n  return TRUE;",
        "file_path": "/src/binutils-gdb/bfd/coff64-rs6000.c",
        "crashing_line": "  amt = c;",
        "crashing_line_number": 1962
      },
      {
        "function_name": "xcoff64_archive_p",
        "function_body": "",
        "file_path": "/src/binutils-gdb/bfd/coff64-rs6000.c",
        "crashing_line": "",
        "crashing_line_number": 2045
      },
      {
        "function_name": "bfd_check_format_matches",
        "function_body": "bfd_boolean\nbfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n{\n  extern const bfd_target binary_vec;\n#if BFD_SUPPORTS_PLUGINS\n  extern const bfd_target plugin_vec;\n#endif\n  const bfd_target * const *target;\n  const bfd_target **matching_vector = NULL;\n  const bfd_target *save_targ, *right_targ, *ar_right_targ, *match_targ;\n  int match_count, best_count, best_match;\n  int ar_match_index;\n  unsigned int initial_section_id = _bfd_section_id;\n  struct bfd_preserve preserve;\n\n  if (matching != NULL)\n    *matching = NULL;\n\n  if (!bfd_read_p (abfd)\n      || (unsigned int) abfd->format >= (unsigned int) bfd_type_end)\n    {\n      bfd_set_error (bfd_error_invalid_operation);\n      return FALSE;\n    }\n\n  if (abfd->format != bfd_unknown)\n    return abfd->format == format;\n\n  if (matching != NULL || *bfd_associated_vector != NULL)\n    {\n      bfd_size_type amt;\n\n      amt = sizeof (*matching_vector) * 2 * _bfd_target_vector_entries;\n      matching_vector = (const bfd_target **) bfd_malloc (amt);\n      if (!matching_vector)\n\treturn FALSE;\n    }\n\n  /* Presume the answer is yes.  */\n  abfd->format = format;\n  save_targ = abfd->xvec;\n  preserve.marker = NULL;\n\n  /* If the target type was explicitly specified, just check that target.  */\n  if (!abfd->target_defaulted)\n    {\n      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)\t/* rewind! */\n\tgoto err_ret;\n\n      right_targ = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));\n\n      if (right_targ)\n\tgoto ok_ret;\n\n      /* For a long time the code has dropped through to check all\n\t targets if the specified target was wrong.  I don't know why,\n\t and I'm reluctant to change it.  However, in the case of an\n\t archive, it can cause problems.  If the specified target does\n\t not permit archives (e.g., the binary target), then we should\n\t not allow some other target to recognize it as an archive, but\n\t should instead allow the specified target to recognize it as an\n\t object.  When I first made this change, it broke the PE target,\n\t because the specified pei-i386 target did not recognize the\n\t actual pe-i386 archive.  Since there may be other problems of\n\t this sort, I changed this test to check only for the binary\n\t target.  */\n      if (format == bfd_archive && save_targ == &binary_vec)\n\tgoto err_unrecog;\n    }\n\n  /* Since the target type was defaulted, check them all in the hope\n     that one will be uniquely recognized.  */\n  right_targ = NULL;\n  ar_right_targ = NULL;\n  match_targ = NULL;\n  best_match = 256;\n  best_count = 0;\n  match_count = 0;\n  ar_match_index = _bfd_target_vector_entries;\n\n  for (target = bfd_target_vector; *target != NULL; target++)\n    {\n      const bfd_target *temp;\n\n      /* The binary target matches anything, so don't return it when\n\t searching.  Don't match the plugin target if we have another\n\t alternative since we want to properly set the input format\n\t before allowing a plugin to claim the file.  Also, don't\n\t check the default target twice.  */\n      if (*target == &binary_vec\n#if BFD_SUPPORTS_PLUGINS\n\t  || (match_count != 0 && *target == &plugin_vec)\n#endif\n\t  || (!abfd->target_defaulted && *target == save_targ))\n\tcontinue;\n\n      /* If we already tried a match, the bfd is modified and may\n\t have sections attached, which will confuse the next\n\t _bfd_check_format call.  */\n      bfd_reinit (abfd, initial_section_id);\n\n      /* Change BFD's target temporarily.  */\n      abfd->xvec = *target;\n\n      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)\n\tgoto err_ret;\n\n      /* If _bfd_check_format neglects to set bfd_error, assume\n\t bfd_error_wrong_format.  We didn't used to even pay any\n\t attention to bfd_error, so I suspect that some\n\t _bfd_check_format might have this problem.  */\n      bfd_set_error (bfd_error_wrong_format);\n\n      temp = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));\n      if (temp)\n\t{\n\t  int match_priority = temp->match_priority;\n#if BFD_SUPPORTS_PLUGINS\n\t  /* If this object can be handled by a plugin, give that the\n\t     lowest priority; objects both handled by a plugin and\n\t     with an underlying object format will be claimed\n\t     separately by the plugin.  */\n\t  if (*target == &plugin_vec)\n\t    match_priority = (*target)->match_priority;\n#endif\n\n\t  match_targ = temp;\n\t  if (preserve.marker != NULL)\n\t    bfd_preserve_finish (abfd, &preserve);\n\n\t  if (abfd->format != bfd_archive\n\t      || (bfd_has_map (abfd)\n\t\t  && bfd_get_error () != bfd_error_wrong_object_format))\n\t    {\n\t      /* If this is the default target, accept it, even if\n\t\t other targets might match.  People who want those\n\t\t other targets have to set the GNUTARGET variable.  */\n\t      if (temp == bfd_default_vector[0])\n\t\tgoto ok_ret;\n\n\t      if (matching_vector)\n\t\tmatching_vector[match_count] = temp;\n\t      match_count++;\n\n\t      if (match_priority < best_match)\n\t\t{\n\t\t  best_match = match_priority;\n\t\t  best_count = 0;\n\t\t}\n\t      if (match_priority <= best_match)\n\t\t{\n\t\t  /* This format checks out as ok!  */\n\t\t  right_targ = temp;\n\t\t  best_count++;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* An archive with no armap or objects of the wrong\n\t\t type.  We want this target to match if we get no\n\t\t better matches.  */\n\t      if (ar_right_targ != bfd_default_vector[0])\n\t\tar_right_targ = *target;\n\t      if (matching_vector)\n\t\tmatching_vector[ar_match_index] = *target;\n\t      ar_match_index++;\n\t    }\n\n\t  if (!bfd_preserve_save (abfd, &preserve))\n\t    goto err_ret;\n\t}\n      else if (bfd_get_error () != bfd_error_wrong_format)\n\tgoto err_ret;\n    }\n\n  if (best_count == 1)\n    match_count = 1;\n\n  if (match_count == 0)\n    {\n      /* Try partial matches.  */\n      right_targ = ar_right_targ;\n\n      if (right_targ == bfd_default_vector[0])\n\t{\n\t  match_count = 1;\n\t}\n      else\n\t{\n\t  match_count = ar_match_index - _bfd_target_vector_entries;\n\n\t  if (matching_vector && match_count > 1)\n\t    memcpy (matching_vector,\n\t\t    matching_vector + _bfd_target_vector_entries,\n\t\t    sizeof (*matching_vector) * match_count);\n\t}\n    }\n\n  /* We have more than one equally good match.  If any of the best\n     matches is a target in config.bfd targ_defvec or targ_selvecs,\n     choose it.  */\n  if (match_count > 1)\n    {\n      const bfd_target * const *assoc = bfd_associated_vector;\n\n      while ((right_targ = *assoc++) != NULL)\n\t{\n\t  int i = match_count;\n\n\t  while (--i >= 0)\n\t    if (matching_vector[i] == right_targ\n\t\t&& right_targ->match_priority <= best_match)\n\t      break;\n\n\t  if (i >= 0)\n\t    {\n\t      match_count = 1;\n\t      break;\n\t    }\n\t}\n    }\n\n  /* We still have more than one equally good match, and at least some\n     of the targets support match priority.  Choose the first of the\n     best matches.  */\n  if (matching_vector && match_count > 1 && best_count != match_count)\n    {\n      int i;\n\n      for (i = 0; i < match_count; i++)\n\t{\n\t  right_targ = matching_vector[i];\n\t  if (right_targ->match_priority <= best_match)\n\t    break;\n\t}\n      match_count = 1;\n    }\n\n  /* There is way too much undoing of half-known state here.  We\n     really shouldn't iterate on live bfd's.  Note that saving the\n     whole bfd and restoring it would be even worse; the first thing\n     you notice is that the cached bfd file position gets out of sync.  */\n  if (preserve.marker != NULL)\n    bfd_preserve_restore (abfd, &preserve);\n\n  if (match_count == 1)\n    {\n      abfd->xvec = right_targ;\n      /* If we come out of the loop knowing that the last target that\n\t matched is the one we want, then ABFD should still be in a usable\n\t state (except possibly for XVEC).  */\n      if (match_targ != right_targ)\n\t{\n\t  bfd_reinit (abfd, initial_section_id);\n\t  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)\n\t    goto err_ret;\n\t  match_targ = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));\n\t  BFD_ASSERT (match_targ != NULL);\n\t}\n\n    ok_ret:\n      /* If the file was opened for update, then `output_has_begun'\n\t some time ago when the file was created.  Do not recompute\n\t sections sizes or alignments in _bfd_set_section_contents.\n\t We can not set this flag until after checking the format,\n\t because it will interfere with creation of BFD sections.  */\n      if (abfd->direction == both_direction)\n\tabfd->output_has_begun = TRUE;\n\n      if (matching_vector)\n\tfree (matching_vector);\n\n      /* File position has moved, BTW.  */\n      return TRUE;\n    }\n\n  if (match_count == 0)\n    {\n    err_unrecog:\n      bfd_set_error (bfd_error_file_not_recognized);\n    err_ret:\n      abfd->xvec = save_targ;\n      abfd->format = bfd_unknown;\n      if (matching_vector)\n\tfree (matching_vector);\n      if (preserve.marker != NULL)\n\tbfd_preserve_restore (abfd, &preserve);\n      return FALSE;\n    }\n\n  /* Restore original target type and format.  */\n  abfd->xvec = save_targ;\n  abfd->format = bfd_unknown;\n  bfd_set_error (bfd_error_file_ambiguously_recognized);\n\n  if (matching)\n    {\n      *matching = (char **) matching_vector;\n      matching_vector[match_count] = NULL;\n      /* Return target names.  This is a little nasty.  Maybe we\n\t should do another bfd_malloc?  */\n      while (--match_count >= 0)\n\t{\n\t  const char *name = matching_vector[match_count]->name;\n\t  *(const char **) &matching_vector[match_count] = name;\n\t}\n    }\n  return FALSE;\n}",
        "file_path": "/src/binutils-gdb/bfd/format.c",
        "crashing_line": "      temp = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));",
        "crashing_line_number": 322
      },
      {
        "function_name": "ExecuteFilesOnyByOne",
        "function_body": "static int ExecuteFilesOnyByOne(int argc, char **argv) {\n  for (int i = 1; i < argc; i++) {\n    std::ifstream in(argv[i], std::ios::binary);\n    in.seekg(0, in.end);\n    size_t length = in.tellg();\n    in.seekg (0, in.beg);\n    std::cout << \"Reading \" << length << \" bytes from \" << argv[i] << std::endl;\n    // Allocate exactly length bytes so that we reliably catch buffer overflows.\n    std::vector<char> bytes(length);\n    in.read(bytes.data(), bytes.size());\n    assert(in);\n    LLVMFuzzerTestOneInput(reinterpret_cast<const uint8_t *>(bytes.data()),\n                           bytes.size());\n    std::cout << \"Execution successful\" << std::endl;\n  }\n  return 0;\n}",
        "file_path": "/src/libfuzzer/afl/afl_driver.cpp",
        "crashing_line": "    LLVMFuzzerTestOneInput(reinterpret_cast<const uint8_t *>(bytes.data()),",
        "crashing_line_number": 216
      },
      {
        "function_name": "main",
        "function_body": "int main(int argc, char **argv) {\n  Printf(\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for AFL-fuzz.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s < INPUT_FILE\\n\"\n      \"or\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before \"\n      \"re-spawning the process (default: 1000)\\n\"\n      \"======================================================\\n\",\n          argv[0], argv[0], argv[0]);\n\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize)\n    LLVMFuzzerInitialize(&argc, &argv);\n  // Do any other expensive one-time initialization here.\n\n  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n    __afl_manual_init();\n\n  int N = 1000;\n  if (argc == 2 && argv[1][0] == '-')\n      N = atoi(argv[1] + 1);\n  else if(argc == 2 && (N = atoi(argv[1])) > 0)\n      Printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n  else if (argc > 1)\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  assert(N > 0);\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  uint8_t dummy_input[1] = {0};\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n    ssize_t n_read = read(0, AflInputBuf, kMaxAflInputSize);\n    if (n_read > 0) {\n      // Copy AflInputBuf into a separate buffer to let asan find buffer\n      // overflows. Don't use unique_ptr/etc to avoid extra dependencies.\n      uint8_t *copy = new uint8_t[n_read];\n      memcpy(copy, AflInputBuf, n_read);\n      num_runs++;\n      LLVMFuzzerTestOneInput(copy, n_read);\n      delete[] copy;\n    }\n  }\n  Printf(\"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n}",
        "file_path": "/src/libfuzzer/afl/afl_driver.cpp",
        "crashing_line": "    return ExecuteFilesOnyByOne(argc, argv);",
        "crashing_line_number": 253
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "uint TY_(getNextErrorCode)( TidyIterator* iter )\n{\n    const tidyStringsKeyItem *item = NULL;\n    size_t itemIndex;\n    assert( iter != NULL );\n    \n    itemIndex = (size_t)*iter;\n    \n    if ( itemIndex > 0 && itemIndex <= tidyErrorCodeListSize() )\n    {\n        item = &tidyStringsKeys[itemIndex - 1];\n        itemIndex++;\n    }\n    \n    *iter = (TidyIterator)( itemIndex <= tidyErrorCodeListSize() ? itemIndex : (size_t)0 );\n    return item->value;\n}\nstatic void PPrintAttribute( TidyDocImpl* doc, uint indent,\n                             Node *node, AttVal *attr )\n{\n    TidyPrintImpl* pprint = &doc->pprint;\n    Bool xmlOut    = cfgBool( doc, TidyXmlOut );\n    Bool xhtmlOut  = cfgBool( doc, TidyXhtmlOut );\n    Bool wrapAttrs = cfgBool( doc, TidyWrapAttVals );\n    uint ucAttrs   = cfg( doc, TidyUpperCaseAttrs );\n    Bool indAttrs  = cfgBool( doc, TidyIndentAttributes );\n    uint xtra      = AttrIndent( doc, node, attr );\n    Bool first     = AttrNoIndentFirst( /*doc,*/ node, attr );\n    tmbstr name    = attr->attribute;\n    Bool wrappable = no;\n    tchar c;\n\n    /* fix for odd attribute indentation bug triggered by long values */\n    if (!indAttrs)\n      xtra = 0;\n\n    if ( indAttrs )\n    {\n        if ( TY_(nodeIsElement)(node) && !first )\n        {\n            indent += xtra;\n            PCondFlushLineSmart( doc, indent );\n        }\n        else\n          indAttrs = no;\n    }\n\n    CheckWrapIndent( doc, indent );\n\n    if ( !xmlOut && !xhtmlOut && attr->dict )\n    {\n        if ( TY_(IsScript)(doc, name) )\n            wrappable = cfgBool( doc, TidyWrapScriptlets );\n        else if (!(attrIsCONTENT(attr) || attrIsVALUE(attr) || attrIsALT(attr) || attrIsTITLE(attr)) && wrapAttrs )\n            wrappable = yes;\n    }\n\n    if ( !first && !SetWrap(doc, indent) )\n    {\n        TY_(PFlushLine)( doc, indent+xtra );  /* Put it on next line */\n    }\n    else if ( pprint->linelen > 0 )\n    {\n        AddChar( pprint, ' ' );\n    }\n\n    /* Attribute name */\n    while (*name)\n    {\n        c = (unsigned char)*name;\n\n        if (c > 0x7F)\n            name += TY_(GetUTF8)(name, &c);\n        else if (ucAttrs == TidyUppercaseYes)\n            c = TY_(ToUpper)(c);\n\n        AddChar(pprint, c);\n        ++name;\n    }\n\n    CheckWrapIndent( doc, indent );\n \n    if ( attr->value == NULL )\n    {\n        Bool isB = TY_(IsBoolAttribute)(attr);\n        Bool scriptAttr = TY_(attrIsEvent)(attr);\n\n        if ( xmlOut )\n            PPrintAttrValue( doc, indent, isB ? attr->attribute : NULLSTR,\n                             attr->delim, no, scriptAttr );\n\n        else if ( !isB && !TY_(IsNewNode)(node) )\n            PPrintAttrValue( doc, indent, \"\", attr->delim, yes, scriptAttr );\n\n        else \n            SetWrap( doc, indent );\n    }\n    else\n        PPrintAttrValue( doc, indent, attr->value, attr->delim, wrappable, no );\n}\n",
    "target": 1,
    "idx": 1036694,
    "stack_trace": [
      {
        "function_name": "prvTidygrowStack",
        "function_body": "",
        "file_path": "/src/tidy-html5/src/lexer.c",
        "crashing_line": "",
        "crashing_line_number": 4482
      },
      {
        "function_name": "prvTidypush",
        "function_body": "",
        "file_path": "/src/tidy-html5/src/lexer.c",
        "crashing_line": "",
        "crashing_line_number": 4514
      },
      {
        "function_name": "CleanSpaces",
        "function_body": "static void CleanSpaces(TidyDocImpl* doc, Node* node)\n{\n    Stack *stack = TY_(newStack)(doc, 16);\n    Node *next;\n    \n    while (node)\n    {\n        next = node->next;\n\n        if (TY_(nodeIsText)(node) && CleanLeadingWhitespace(doc, node))\n            while (node->start < node->end && TY_(IsWhite)(doc->lexer->lexbuf[node->start]))\n                ++(node->start);\n\n        if (TY_(nodeIsText)(node) && CleanTrailingWhitespace(doc, node))\n            while (node->end > node->start && TY_(IsWhite)(doc->lexer->lexbuf[node->end - 1]))\n                --(node->end);\n\n        if (TY_(nodeIsText)(node) && !(node->start < node->end))\n        {\n            TY_(RemoveNode)(node);\n            TY_(FreeNode)(doc, node);\n            node = next ? next : TY_(pop)(stack);\n            continue;\n        }\n\n        if (node->content)\n        {\n            TY_(push)(stack, next);\n            node = node->content;\n            continue;\n        }\n\n        node = next ? next : TY_(pop)(stack);\n    }\n    TY_(freeStack)(stack);\n}",
        "file_path": "/src/tidy-html5/src/parser.c",
        "crashing_line": "            TY_(push)(stack, next);",
        "crashing_line_number": 619
      },
      {
        "function_name": "prvTidyParseDocument",
        "function_body": "",
        "file_path": "/src/tidy-html5/src/parser.c",
        "crashing_line": "",
        "crashing_line_number": 6590
      },
      {
        "function_name": "prvTidyDocParseStream",
        "function_body": "",
        "file_path": "/src/tidy-html5/src/tidylib.c",
        "crashing_line": "",
        "crashing_line_number": 1509
      },
      {
        "function_name": "tidyDocParseString",
        "function_body": "int   tidyDocParseString( TidyDocImpl* doc, ctmbstr content )\n{\n    int status = -EINVAL;\n    TidyBuffer inbuf;\n    StreamIn* in = NULL;\n\n    if ( content )\n    {\n        tidyBufInitWithAllocator( &inbuf, doc->allocator );\n        tidyBufAttach( &inbuf, (byte*)content, TY_(tmbstrlen)(content)+1 );\n        in = TY_(BufferInput)( doc, &inbuf, cfg( doc, TidyInCharEncoding ));\n        status = TY_(DocParseStream)( doc, in );\n        tidyBufDetach( &inbuf );\n        TY_(freeStreamIn)(in);\n    }\n    return status;\n}",
        "file_path": "/src/tidy-html5/src/tidylib.c",
        "crashing_line": "        status = TY_(DocParseStream)( doc, in );",
        "crashing_line_number": 1220
      },
      {
        "function_name": "tidyParseString",
        "function_body": "int TIDY_CALL  tidyParseString( TidyDoc tdoc, ctmbstr content )\n{\n    TidyDocImpl* doc = tidyDocToImpl( tdoc );\n    return tidyDocParseString( doc, content );\n}",
        "file_path": "/src/tidy-html5/src/tidylib.c",
        "crashing_line": "    return tidyDocParseString( doc, content );",
        "crashing_line_number": 1117
      },
      {
        "function_name": "TidyXhtml",
        "function_body": "int TidyXhtml(const char* input, TidyBuffer* output, TidyBuffer* errbuf) {\n  TidyDoc tdoc = tidyCreate();\n  tidyOptSetBool( tdoc, TidyXhtmlOut, yes );\n  tidySetErrorBuffer(tdoc, errbuf);\n\n  tidyParseString(tdoc, input);\n\n  tidyCleanAndRepair(tdoc);\n  tidyRunDiagnostics(tdoc);\n  tidyOptSetBool(tdoc, TidyForceOutput, yes);\n  tidySaveBuffer(tdoc, output);\n  tidyRelease( tdoc );\n  return 0;\n}",
        "file_path": "/src/tidy_parse_string_fuzzer.c",
        "crashing_line": "  tidyParseString(tdoc, input);",
        "crashing_line_number": 29
      }
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static bool parse_headers(struct lwan_request_parser_helper *helper,\n                          char *buffer)\n{\n    char *buffer_end = helper->buffer->value + helper->buffer->len;\n    char **header_start = helper->header_start;\n    size_t n_headers = 0;\n    char *p;\n\n    for (p = buffer + 1;;) {\n        char *next_chr = p;\n        char *next_hdr = memchr(next_chr, '\\r', (size_t)(buffer_end - p));\n\n        if (!next_hdr)\n            break;\n\n        if (next_chr == next_hdr) {\n            if (buffer_end - next_chr > 2) {\n                STRING_SWITCH_SMALL (next_hdr) {\n                case MULTICHAR_CONSTANT_SMALL('\\r', '\\n'):\n                    helper->next_request = next_hdr + 2;\n                }\n            }\n            break;\n        }\n\n        header_start[n_headers++] = next_chr;\n        header_start[n_headers++] = next_hdr;\n\n        p = next_hdr + 2;\n\n        if (n_headers > N_HEADER_START || p >= buffer_end) {\n            helper->n_header_start = 0;\n            return false;\n        }\n    }\n\n    for (size_t i = 0; i < n_headers; i += 2) {\n        char *end = header_start[i + 1];\n\n        p = header_start[i];\n\n        STRING_SWITCH_L (p) {\n        case MULTICHAR_CONSTANT_L('A', 'c', 'c', 'e'):\n            p += HEADER_LENGTH(\"Accept\");\n\n            STRING_SWITCH_L (p) {\n            case MULTICHAR_CONSTANT_L('-', 'E', 'n', 'c'):\n                helper->accept_encoding = HEADER(\"-Encoding\");\n                break;\n            }\n            break;\n        case MULTICHAR_CONSTANT_L('A', 'u', 't', 'h'):\n            helper->authorization = HEADER(\"Authorization\");\n            break;\n        case MULTICHAR_CONSTANT_L('C', 'o', 'n', 'n'):\n            helper->connection = HEADER(\"Connection\");\n            break;\n        case MULTICHAR_CONSTANT_L('C', 'o', 'n', 't'):\n            p += HEADER_LENGTH(\"Content\");\n\n            STRING_SWITCH_L (p) {\n            case MULTICHAR_CONSTANT_L('-', 'T', 'y', 'p'):\n                helper->content_type = HEADER(\"-Type\");\n                break;\n            case MULTICHAR_CONSTANT_L('-', 'L', 'e', 'n'):\n                helper->content_length = HEADER(\"-Length\");\n                break;\n            }\n            break;\n        case MULTICHAR_CONSTANT_L('C', 'o', 'o', 'k'):\n            helper->cookie = HEADER(\"Cookie\");\n            break;\n        case MULTICHAR_CONSTANT_L('I', 'f', '-', 'M'):\n            helper->if_modified_since.raw = HEADER(\"If-Modified-Since\");\n            break;\n        case MULTICHAR_CONSTANT_L('R', 'a', 'n', 'g'):\n            helper->range.raw = HEADER(\"Range\");\n            break;\n        }\n    }\n\n    helper->n_header_start = n_headers;\n    return true;\n}\n",
    "target": 1,
    "idx": 1014529,
    "stack_trace": [
      {
        "function_name": "parse_headers",
        "function_body": "static bool parse_headers(struct lwan_request_parser_helper *helper,\n                          char *buffer)\n{\n    char *buffer_end = helper->buffer->value + helper->buffer->len;\n    char **header_start = helper->header_start;\n    size_t n_headers = 0;\n    char *p;\n\n    for (p = buffer + 1;;) {\n        char *next_chr = p;\n        char *next_hdr = memchr(next_chr, '\\r', (size_t)(buffer_end - p));\n\n        if (!next_hdr)\n            break;\n\n        if (next_chr == next_hdr) {\n            if (buffer_end - next_chr > 2) {\n                STRING_SWITCH_SMALL (next_hdr) {\n                case MULTICHAR_CONSTANT_SMALL('\\r', '\\n'):\n                    helper->next_request = next_hdr + 2;\n                }\n            }\n            break;\n        }\n\n        header_start[n_headers++] = next_chr;\n        header_start[n_headers++] = next_hdr;\n\n        p = next_hdr + 2;\n\n        if (n_headers >= N_HEADER_START || p >= buffer_end) {\n            helper->n_header_start = 0;\n            return false;\n        }\n    }\n\n    for (size_t i = 0; i < n_headers; i += 2) {\n        char *end = header_start[i + 1];\n\n        p = header_start[i];\n\n        STRING_SWITCH_L (p) {\n        case MULTICHAR_CONSTANT_L('A', 'c', 'c', 'e'):\n            p += HEADER_LENGTH(\"Accept\");\n\n            STRING_SWITCH_L (p) {\n            case MULTICHAR_CONSTANT_L('-', 'E', 'n', 'c'):\n                helper->accept_encoding = HEADER(\"-Encoding\");\n                break;\n            }\n            break;\n        case MULTICHAR_CONSTANT_L('A', 'u', 't', 'h'):\n            helper->authorization = HEADER(\"Authorization\");\n            break;\n        case MULTICHAR_CONSTANT_L('C', 'o', 'n', 'n'):\n            helper->connection = HEADER(\"Connection\");\n            break;\n        case MULTICHAR_CONSTANT_L('C', 'o', 'n', 't'):\n            p += HEADER_LENGTH(\"Content\");\n\n            STRING_SWITCH_L (p) {\n            case MULTICHAR_CONSTANT_L('-', 'T', 'y', 'p'):\n                helper->content_type = HEADER(\"-Type\");\n                break;\n            case MULTICHAR_CONSTANT_L('-', 'L', 'e', 'n'):\n                helper->content_length = HEADER(\"-Length\");\n                break;\n            }\n            break;\n        case MULTICHAR_CONSTANT_L('C', 'o', 'o', 'k'):\n            helper->cookie = HEADER(\"Cookie\");\n            break;\n        case MULTICHAR_CONSTANT_L('I', 'f', '-', 'M'):\n            helper->if_modified_since.raw = HEADER(\"If-Modified-Since\");\n            break;\n        case MULTICHAR_CONSTANT_L('R', 'a', 'n', 'g'):\n            helper->range.raw = HEADER(\"Range\");\n            break;\n        }\n    }\n\n    helper->n_header_start = n_headers;\n    return true;\n}",
        "file_path": "/src/lwan/src/lib/lwan-request.c",
        "crashing_line": "        header_start[n_headers++] = next_chr;",
        "crashing_line_number": 553
      },
      {
        "function_name": "parse_http_request",
        "function_body": "__attribute__((used)) int fuzz_parse_http_request(const uint8_t *data,\n                                                  size_t length)\n{\n    static struct coro_switcher switcher;\n    static struct coro *coro;\n    static char *header_start[N_HEADER_START];\n    static char data_copy[32767] = {0};\n\n    if (length > sizeof(data_copy))\n        length = sizeof(data_copy);\n    memcpy(data_copy, data, length);\n\n    if (!coro)\n        coro = coro_new(&switcher, useless_coro_for_fuzzing, NULL);\n\n    struct lwan_request_parser_helper helper = {\n        .buffer = &(struct lwan_value){.value = data_copy, .len = length},\n        .header_start = header_start,\n        .error_when_n_packets = 2,\n    };\n    struct lwan_connection conn = {.coro = coro};\n    struct lwan_proxy proxy = {};\n    struct lwan_request request = {\n        .helper = &helper,\n        .conn = &conn,\n        .flags = REQUEST_ALLOW_PROXY_REQS,\n        .proxy = &proxy,\n    };\n\n    /* If the finalizer isn't happy with a request, there's no point in\n     * going any further with parsing it. */\n    if (read_request_finalizer(length, sizeof(data_copy), &request, 1) !=\n        FINALIZER_DONE)\n        return 0;\n\n    if (parse_http_request(&request) == HTTP_OK) {\n        size_t gen = coro_deferred_get_generation(coro);\n\n        /* Only pointers were set in helper struct; actually parse them here. */\n        parse_post_data(&request);\n        parse_query_string(&request);\n        parse_cookies(&request);\n        parse_accept_encoding(&request);\n        parse_if_modified_since(&helper);\n        parse_range(&helper);\n\n        coro_deferred_run(coro, gen);\n    }\n\n    return 0;\n}",
        "file_path": "/src/lwan/src/lib/lwan-request.c",
        "crashing_line": "",
        "crashing_line_number": 1215
      },
      {
        "function_name": "fuzz_parse_http_request",
        "function_body": "__attribute__((used)) int fuzz_parse_http_request(const uint8_t *data,\n                                                  size_t length)\n{\n    static struct coro_switcher switcher;\n    static struct coro *coro;\n    static char *header_start[N_HEADER_START];\n    static char data_copy[32767] = {0};\n\n    if (length > sizeof(data_copy))\n        length = sizeof(data_copy);\n    memcpy(data_copy, data, length);\n\n    if (!coro)\n        coro = coro_new(&switcher, useless_coro_for_fuzzing, NULL);\n\n    struct lwan_request_parser_helper helper = {\n        .buffer = &(struct lwan_value){.value = data_copy, .len = length},\n        .header_start = header_start,\n        .error_when_n_packets = 2,\n    };\n    struct lwan_connection conn = {.coro = coro};\n    struct lwan_proxy proxy = {};\n    struct lwan_request request = {\n        .helper = &helper,\n        .conn = &conn,\n        .flags = REQUEST_ALLOW_PROXY_REQS,\n        .proxy = &proxy,\n    };\n\n    /* If the finalizer isn't happy with a request, there's no point in\n     * going any further with parsing it. */\n    if (read_request_finalizer(length, sizeof(data_copy), &request, 1) !=\n        FINALIZER_DONE)\n        return 0;\n\n    if (parse_http_request(&request) == HTTP_OK) {\n        size_t gen = coro_deferred_get_generation(coro);\n\n        /* Only pointers were set in helper struct; actually parse them here. */\n        parse_post_data(&request);\n        parse_query_string(&request);\n        parse_cookies(&request);\n        parse_accept_encoding(&request);\n        parse_if_modified_since(&helper);\n        parse_range(&helper);\n\n        coro_deferred_run(coro, gen);\n    }\n\n    return 0;\n}",
        "file_path": "/src/lwan/src/lib/lwan-request.c",
        "crashing_line": "    if (parse_http_request(&request) == HTTP_OK) {",
        "crashing_line_number": 1684
      }
    ]
  }
]