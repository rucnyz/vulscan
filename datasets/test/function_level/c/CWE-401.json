[
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_lrnhwnrj()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new TwoIntsClass[100];\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printIntLine(data[0].intOne);\n        printIntLine(data[0].intTwo);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        delete[] data;\n        break;\n    }\n}\n\n\nstatic void f_ycnbrkxu()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new TwoIntsClass[100];\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printIntLine(data[0].intOne);\n        printIntLine(data[0].intTwo);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        delete[] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_terllmos()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        TwoIntsClass dataBuffer[100];\n        data = dataBuffer;\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printIntLine(data[0].intOne);\n        printIntLine(data[0].intTwo);\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_wxrskdxc()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        TwoIntsClass dataBuffer[100];\n        data = dataBuffer;\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printIntLine(data[0].intOne);\n        printIntLine(data[0].intTwo);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_addwldut()\n{\n    f_lrnhwnrj();\n    f_ycnbrkxu();\n    f_terllmos();\n    f_wxrskdxc();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_addwldut();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400240,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_array_TwoIntsClass_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\nvoid f_ddiwkpki()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new TwoIntsClass[100];\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printIntLine(data[0].intOne);\n        printIntLine(data[0].intTwo);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ddiwkpki();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400241,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_array_TwoIntsClass_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_hhmrkdfm()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new TwoIntsClass;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printIntLine(data->intOne);\n        printIntLine(data->intTwo);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        delete data;\n        break;\n    }\n}\n\n\nstatic void f_ritxwwkb()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new TwoIntsClass;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printIntLine(data->intOne);\n        printIntLine(data->intTwo);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_htbfchme()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        TwoIntsClass dataBuffer;\n        data = &dataBuffer;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printIntLine(data->intOne);\n        printIntLine(data->intTwo);\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_beytuyyu()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        TwoIntsClass dataBuffer;\n        data = &dataBuffer;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printIntLine(data->intOne);\n        printIntLine(data->intTwo);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_rhlscpky()\n{\n    f_hhmrkdfm();\n    f_ritxwwkb();\n    f_htbfchme();\n    f_beytuyyu();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rhlscpky();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400242,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_TwoIntsClass_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\nvoid f_bjclrnsd()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new TwoIntsClass;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printIntLine(data->intOne);\n        printIntLine(data->intTwo);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bjclrnsd();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400243,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_TwoIntsClass_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_xkzqhxfb()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new twoIntsStruct;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printStructLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        delete data;\n        break;\n    }\n}\n\n\nstatic void f_vciepihn()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new twoIntsStruct;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printStructLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_qekqkizc()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        twoIntsStruct dataBuffer;\n        data = &dataBuffer;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printStructLine(data);\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ulxeaxbv()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        twoIntsStruct dataBuffer;\n        data = &dataBuffer;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printStructLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_droztdoe()\n{\n    f_xkzqhxfb();\n    f_vciepihn();\n    f_qekqkizc();\n    f_ulxeaxbv();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_droztdoe();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400244,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_twoIntsStruct_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\nvoid f_pncjdkcg()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new twoIntsStruct;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printStructLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pncjdkcg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400245,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_twoIntsStruct_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_agnwgtxk()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new struct _twoIntsStruct;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printStructLine((twoIntsStruct *)data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        delete data;\n        break;\n    }\n}\n\n\nstatic void f_yvkzofai()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new struct _twoIntsStruct;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printStructLine((twoIntsStruct *)data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_lsvoglpo()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        struct _twoIntsStruct dataBuffer;\n        data = &dataBuffer;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printStructLine((twoIntsStruct *)data);\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ubqxpjnt()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        struct _twoIntsStruct dataBuffer;\n        data = &dataBuffer;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printStructLine((twoIntsStruct *)data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_tojgrusu()\n{\n    f_agnwgtxk();\n    f_yvkzofai();\n    f_lsvoglpo();\n    f_ubqxpjnt();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tojgrusu();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400246,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_struct_twoIntsStruct_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\nvoid f_gxfaapgf()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new struct _twoIntsStruct;\n        \n        data->intOne = 0;\n        data->intTwo = 0;\n        printStructLine((twoIntsStruct *)data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gxfaapgf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400247,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_struct_twoIntsStruct_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_okvmrrlu()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new struct _twoIntsStruct[100];\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine((twoIntsStruct *)&data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        delete[] data;\n        break;\n    }\n}\n\n\nstatic void f_kryncvyf()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new struct _twoIntsStruct[100];\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine((twoIntsStruct *)&data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        delete[] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_qofmyqcn()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        struct _twoIntsStruct dataBuffer[100];\n        data = dataBuffer;\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine((twoIntsStruct *)&data[0]);\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_vrlfmfvc()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        struct _twoIntsStruct dataBuffer[100];\n        data = dataBuffer;\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine((twoIntsStruct *)&data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_jzlzxvjv()\n{\n    f_okvmrrlu();\n    f_kryncvyf();\n    f_qofmyqcn();\n    f_vrlfmfvc();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jzlzxvjv();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400248,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_array_struct_twoIntsStruct_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\nvoid f_wxxudvyt()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new struct _twoIntsStruct[100];\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine((twoIntsStruct *)&data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wxxudvyt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400249,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_array_struct_twoIntsStruct_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_jfigbnpf()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new twoIntsStruct[100];\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine(&data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        delete[] data;\n        break;\n    }\n}\n\n\nstatic void f_rhslwbsq()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new twoIntsStruct[100];\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine(&data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        delete[] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_jtplwwyj()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        twoIntsStruct dataBuffer[100];\n        data = dataBuffer;\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine(&data[0]);\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_fggupzoc()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        twoIntsStruct dataBuffer[100];\n        data = dataBuffer;\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine(&data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_cwhwwnkd()\n{\n    f_jfigbnpf();\n    f_rhslwbsq();\n    f_jtplwwyj();\n    f_fggupzoc();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cwhwwnkd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400250,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_array_twointsStruct_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\nvoid f_eaczqyjx()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new twoIntsStruct[100];\n        \n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine(&data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_eaczqyjx();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400251,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_array_twointsStruct_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_bjpzanaj()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new char[100];\n        \n        strcpy(data, \"A String\");\n        printLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        delete[] data;\n        break;\n    }\n}\n\n\nstatic void f_thkfaumr()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new char[100];\n        \n        strcpy(data, \"A String\");\n        printLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        delete[] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ydsbappt()\n{\n    char * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        char dataBuffer[100];\n        data = dataBuffer;\n        \n        strcpy(data, \"A String\");\n        printLine(data);\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_kmfbvmgs()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        char dataBuffer[100];\n        data = dataBuffer;\n        \n        strcpy(data, \"A String\");\n        printLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_lrreijea()\n{\n    f_bjpzanaj();\n    f_thkfaumr();\n    f_ydsbappt();\n    f_kmfbvmgs();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lrreijea();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400252,
    "original_file": "testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\nvoid f_aufusxaq()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new char[100];\n        \n        strcpy(data, \"A String\");\n        printLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_aufusxaq();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400253,
    "original_file": "testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_xfphmbny()\n{\n    wchar_t * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new wchar_t[100];\n        \n        wcscpy(data, L\"A String\");\n        printWLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        delete[] data;\n        break;\n    }\n}\n\n\nstatic void f_bjhfjmby()\n{\n    wchar_t * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new wchar_t[100];\n        \n        wcscpy(data, L\"A String\");\n        printWLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        delete[] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_qffmcpxm()\n{\n    wchar_t * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        wchar_t dataBuffer[100];\n        data = dataBuffer;\n        \n        wcscpy(data, L\"A String\");\n        printWLine(data);\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_nowiidjy()\n{\n    wchar_t * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        wchar_t dataBuffer[100];\n        data = dataBuffer;\n        \n        wcscpy(data, L\"A String\");\n        printWLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_crrwjkwn()\n{\n    f_xfphmbny();\n    f_bjhfjmby();\n    f_qffmcpxm();\n    f_nowiidjy();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_crrwjkwn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400254,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_array_wchar_t_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\nvoid f_weclqyox()\n{\n    wchar_t * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new wchar_t[100];\n        \n        wcscpy(data, L\"A String\");\n        printWLine(data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_weclqyox();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400255,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_array_wchar_t_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_wzbbjsmk()\n{\n    int * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new int[100];\n        \n        data[0] = 5;\n        printIntLine(data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        delete[] data;\n        break;\n    }\n}\n\n\nstatic void f_nprfcydj()\n{\n    int * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new int[100];\n        \n        data[0] = 5;\n        printIntLine(data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        delete[] data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_pletlese()\n{\n    int * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        int dataBuffer[100];\n        data = dataBuffer;\n        \n        data[0] = 5;\n        printIntLine(data[0]);\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_yxprmqyx()\n{\n    int * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        int dataBuffer[100];\n        data = dataBuffer;\n        \n        data[0] = 5;\n        printIntLine(data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_yxfsxmkt()\n{\n    f_wzbbjsmk();\n    f_nprfcydj();\n    f_pletlese();\n    f_yxprmqyx();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yxfsxmkt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400256,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_array_int_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\nvoid f_qazlhlyf()\n{\n    int * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new int[100];\n        \n        data[0] = 5;\n        printIntLine(data[0]);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qazlhlyf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400257,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_array_int_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_eqrljjmz()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new char;\n        \n        *data = 'A';\n        printHexCharLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        delete data;\n        break;\n    }\n}\n\n\nstatic void f_coutgjpr()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new char;\n        \n        *data = 'A';\n        printHexCharLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        delete data;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_fwwxwztn()\n{\n    char * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        char dataBuffer;\n        data = &dataBuffer;\n        \n        *data = 'A';\n        printHexCharLine(*data);\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_dexgksed()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        char dataBuffer;\n        data = &dataBuffer;\n        \n        *data = 'A';\n        printHexCharLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_zinjilht()\n{\n    f_eqrljjmz();\n    f_coutgjpr();\n    f_fwwxwztn();\n    f_dexgksed();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zinjilht();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400258,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_char_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _A_namespace\n{\n\n\nvoid f_pslbxztp()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        \n        data = new char;\n        \n        *data = 'A';\n        printHexCharLine(*data);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        \n        ; \n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pslbxztp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400259,
    "original_file": "testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__new_char_15.cpp",
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static void aiptek_irq(struct urb *urb)\n{\n\tstruct aiptek *aiptek = urb->context;\n\tunsigned char *data = aiptek->data;\n\tstruct input_dev *inputdev = aiptek->inputdev;\n\tstruct usb_interface *intf = aiptek->intf;\n\tint jitterable = 0;\n\tint retval, macro, x, y, z, left, right, middle, p, dv, tip, bs, pck;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t/* Success */\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* This urb is terminated, clean up */\n\t\tdev_dbg(&intf->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\n\tdefault:\n\t\tdev_dbg(&intf->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\tgoto exit;\n\t}\n\n\t/* See if we are in a delay loop -- throw out report if true.\n\t */\n\tif (aiptek->inDelay == 1 && time_after(aiptek->endDelay, jiffies)) {\n\t\tgoto exit;\n\t}\n\n\taiptek->inDelay = 0;\n\taiptek->eventCount++;\n\n\t/* Report 1 delivers relative coordinates with either a stylus\n\t * or the mouse. You do not know, however, which input\n\t * tool generated the event.\n\t */\n\tif (data[0] == 1) {\n\t\tif (aiptek->curSetting.coordinateMode ==\n\t\t    AIPTEK_COORDINATE_ABSOLUTE_MODE) {\n\t\t\taiptek->diagnostic =\n\t\t\t    AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE;\n\t\t} else {\n\t\t\tx = (signed char) data[2];\n\t\t\ty = (signed char) data[3];\n\n\t\t\t/* jitterable keeps track of whether any button has been pressed.\n\t\t\t * We're also using it to remap the physical mouse button mask\n\t\t\t * to pseudo-settings. (We don't specifically care about it's\n\t\t\t * value after moving/transposing mouse button bitmasks, except\n\t\t\t * that a non-zero value indicates that one or more\n\t\t\t * mouse button was pressed.)\n\t\t\t */\n\t\t\tjitterable = data[1] & 0x07;\n\n\t\t\tleft = (data[1] & aiptek->curSetting.mouseButtonLeft >> 2) != 0 ? 1 : 0;\n\t\t\tright = (data[1] & aiptek->curSetting.mouseButtonRight >> 2) != 0 ? 1 : 0;\n\t\t\tmiddle = (data[1] & aiptek->curSetting.mouseButtonMiddle >> 2) != 0 ? 1 : 0;\n\n\t\t\tinput_report_key(inputdev, BTN_LEFT, left);\n\t\t\tinput_report_key(inputdev, BTN_MIDDLE, middle);\n\t\t\tinput_report_key(inputdev, BTN_RIGHT, right);\n\n\t\t\tinput_report_abs(inputdev, ABS_MISC,\n\t\t\t\t\t 1 | AIPTEK_REPORT_TOOL_UNKNOWN);\n\t\t\tinput_report_rel(inputdev, REL_X, x);\n\t\t\tinput_report_rel(inputdev, REL_Y, y);\n\n\t\t\t/* Wheel support is in the form of a single-event\n\t\t\t * firing.\n\t\t\t */\n\t\t\tif (aiptek->curSetting.wheel != AIPTEK_WHEEL_DISABLE) {\n\t\t\t\tinput_report_rel(inputdev, REL_WHEEL,\n\t\t\t\t\t\t aiptek->curSetting.wheel);\n\t\t\t\taiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;\n\t\t\t}\n\t\t\tif (aiptek->lastMacro != -1) {\n\t\t\t        input_report_key(inputdev,\n\t\t\t\t\t\t macroKeyEvents[aiptek->lastMacro], 0);\n\t\t\t\taiptek->lastMacro = -1;\n\t\t\t}\n\t\t\tinput_sync(inputdev);\n\t\t}\n\t}\n\t/* Report 2 is delivered only by the stylus, and delivers\n\t * absolute coordinates.\n\t */\n\telse if (data[0] == 2) {\n\t\tif (aiptek->curSetting.coordinateMode == AIPTEK_COORDINATE_RELATIVE_MODE) {\n\t\t\taiptek->diagnostic = AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE;\n\t\t} else if (!AIPTEK_POINTER_ALLOW_STYLUS_MODE\n\t\t\t    (aiptek->curSetting.pointerMode)) {\n\t\t\t\taiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;\n\t\t} else {\n\t\t\tx = get_unaligned_le16(data + 1);\n\t\t\ty = get_unaligned_le16(data + 3);\n\t\t\tz = get_unaligned_le16(data + 6);\n\n\t\t\tdv = (data[5] & 0x01) != 0 ? 1 : 0;\n\t\t\tp = (data[5] & 0x02) != 0 ? 1 : 0;\n\t\t\ttip = (data[5] & 0x04) != 0 ? 1 : 0;\n\n\t\t\t/* Use jitterable to re-arrange button masks\n\t\t\t */\n\t\t\tjitterable = data[5] & 0x18;\n\n\t\t\tbs = (data[5] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;\n\t\t\tpck = (data[5] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;\n\n\t\t\t/* dv indicates 'data valid' (e.g., the tablet is in sync\n\t\t\t * and has delivered a \"correct\" report) We will ignore\n\t\t\t * all 'bad' reports...\n\t\t\t */\n\t\t\tif (dv != 0) {\n\t\t\t\t/* If the selected tool changed, reset the old\n\t\t\t\t * tool key, and set the new one.\n\t\t\t\t */\n\t\t\t\tif (aiptek->previousToolMode !=\n\t\t\t\t    aiptek->curSetting.toolMode) {\n\t\t\t\t        input_report_key(inputdev,\n\t\t\t\t\t\t\t aiptek->previousToolMode, 0);\n\t\t\t\t\tinput_report_key(inputdev,\n\t\t\t\t\t\t\t aiptek->curSetting.toolMode,\n\t\t\t\t\t\t\t 1);\n\t\t\t\t\taiptek->previousToolMode =\n\t\t\t\t\t          aiptek->curSetting.toolMode;\n\t\t\t\t}\n\n\t\t\t\tif (p != 0) {\n\t\t\t\t\tinput_report_abs(inputdev, ABS_X, x);\n\t\t\t\t\tinput_report_abs(inputdev, ABS_Y, y);\n\t\t\t\t\tinput_report_abs(inputdev, ABS_PRESSURE, z);\n\n\t\t\t\t\tinput_report_key(inputdev, BTN_TOUCH, tip);\n\t\t\t\t\tinput_report_key(inputdev, BTN_STYLUS, bs);\n\t\t\t\t\tinput_report_key(inputdev, BTN_STYLUS2, pck);\n\n\t\t\t\t\tif (aiptek->curSetting.xTilt !=\n\t\t\t\t\t    AIPTEK_TILT_DISABLE) {\n\t\t\t\t\t\tinput_report_abs(inputdev,\n\t\t\t\t\t\t\t\t ABS_TILT_X,\n\t\t\t\t\t\t\t\t aiptek->curSetting.xTilt);\n\t\t\t\t\t}\n\t\t\t\t\tif (aiptek->curSetting.yTilt != AIPTEK_TILT_DISABLE) {\n\t\t\t\t\t\tinput_report_abs(inputdev,\n\t\t\t\t\t\t\t\t ABS_TILT_Y,\n\t\t\t\t\t\t\t\t aiptek->curSetting.yTilt);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Wheel support is in the form of a single-event\n\t\t\t\t\t * firing.\n\t\t\t\t\t */\n\t\t\t\t\tif (aiptek->curSetting.wheel !=\n\t\t\t\t\t    AIPTEK_WHEEL_DISABLE) {\n\t\t\t\t\t\tinput_report_abs(inputdev,\n\t\t\t\t\t\t\t\t ABS_WHEEL,\n\t\t\t\t\t\t\t\t aiptek->curSetting.wheel);\n\t\t\t\t\t\taiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinput_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_STYLUS);\n\t\t\t\tif (aiptek->lastMacro != -1) {\n\t\t\t                input_report_key(inputdev,\n\t\t\t\t\t\t\t macroKeyEvents[aiptek->lastMacro], 0);\n\t\t\t\t\taiptek->lastMacro = -1;\n\t\t\t\t}\n\t\t\t\tinput_sync(inputdev);\n\t\t\t}\n\t\t}\n\t}\n\t/* Report 3's come from the mouse in absolute mode.\n\t */\n\telse if (data[0] == 3) {\n\t\tif (aiptek->curSetting.coordinateMode == AIPTEK_COORDINATE_RELATIVE_MODE) {\n\t\t\taiptek->diagnostic = AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE;\n\t\t} else if (!AIPTEK_POINTER_ALLOW_MOUSE_MODE\n\t\t\t(aiptek->curSetting.pointerMode)) {\n\t\t\taiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;\n\t\t} else {\n\t\t\tx = get_unaligned_le16(data + 1);\n\t\t\ty = get_unaligned_le16(data + 3);\n\n\t\t\tjitterable = data[5] & 0x1c;\n\n\t\t\tdv = (data[5] & 0x01) != 0 ? 1 : 0;\n\t\t\tp = (data[5] & 0x02) != 0 ? 1 : 0;\n\t\t\tleft = (data[5] & aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;\n\t\t\tright = (data[5] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;\n\t\t\tmiddle = (data[5] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;\n\n\t\t\tif (dv != 0) {\n\t\t\t\t/* If the selected tool changed, reset the old\n\t\t\t\t * tool key, and set the new one.\n\t\t\t\t */\n\t\t\t\tif (aiptek->previousToolMode !=\n\t\t\t\t    aiptek->curSetting.toolMode) {\n\t\t\t\t        input_report_key(inputdev,\n\t\t\t\t\t\t\t aiptek->previousToolMode, 0);\n\t\t\t\t\tinput_report_key(inputdev,\n\t\t\t\t\t\t\t aiptek->curSetting.toolMode,\n\t\t\t\t\t\t\t 1);\n\t\t\t\t\taiptek->previousToolMode =\n\t\t\t\t\t          aiptek->curSetting.toolMode;\n\t\t\t\t}\n\n\t\t\t\tif (p != 0) {\n\t\t\t\t\tinput_report_abs(inputdev, ABS_X, x);\n\t\t\t\t\tinput_report_abs(inputdev, ABS_Y, y);\n\n\t\t\t\t\tinput_report_key(inputdev, BTN_LEFT, left);\n\t\t\t\t\tinput_report_key(inputdev, BTN_MIDDLE, middle);\n\t\t\t\t\tinput_report_key(inputdev, BTN_RIGHT, right);\n\n\t\t\t\t\t/* Wheel support is in the form of a single-event\n\t\t\t\t\t * firing.\n\t\t\t\t\t */\n\t\t\t\t\tif (aiptek->curSetting.wheel != AIPTEK_WHEEL_DISABLE) {\n\t\t\t\t\t\tinput_report_abs(inputdev,\n\t\t\t\t\t\t\t\t ABS_WHEEL,\n\t\t\t\t\t\t\t\t aiptek->curSetting.wheel);\n\t\t\t\t\t\taiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinput_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_MOUSE);\n\t\t\t\tif (aiptek->lastMacro != -1) {\n\t\t\t                input_report_key(inputdev,\n\t\t\t\t\t\t\t macroKeyEvents[aiptek->lastMacro], 0);\n\t\t\t\t        aiptek->lastMacro = -1;\n\t\t\t\t}\n\t\t\t\tinput_sync(inputdev);\n\t\t\t}\n\t\t}\n\t}\n\t/* Report 4s come from the macro keys when pressed by stylus\n\t */\n\telse if (data[0] == 4) {\n\t\tjitterable = data[1] & 0x18;\n\n\t\tdv = (data[1] & 0x01) != 0 ? 1 : 0;\n\t\tp = (data[1] & 0x02) != 0 ? 1 : 0;\n\t\ttip = (data[1] & 0x04) != 0 ? 1 : 0;\n\t\tbs = (data[1] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;\n\t\tpck = (data[1] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;\n\n\t\tmacro = dv && p && tip && !(data[3] & 1) ? (data[3] >> 1) : -1;\n\t\tz = get_unaligned_le16(data + 4);\n\n\t\tif (dv) {\n\t\t        /* If the selected tool changed, reset the old\n\t\t\t * tool key, and set the new one.\n\t\t\t */\n\t\t        if (aiptek->previousToolMode !=\n\t\t\t    aiptek->curSetting.toolMode) {\n\t\t\t        input_report_key(inputdev,\n\t\t\t\t\t\t aiptek->previousToolMode, 0);\n\t\t\t\tinput_report_key(inputdev,\n\t\t\t\t\t\t aiptek->curSetting.toolMode,\n\t\t\t\t\t\t 1);\n\t\t\t\taiptek->previousToolMode =\n\t\t\t\t        aiptek->curSetting.toolMode;\n\t\t\t}\n\t\t}\n\n\t\tif (aiptek->lastMacro != -1 && aiptek->lastMacro != macro) {\n\t\t        input_report_key(inputdev, macroKeyEvents[aiptek->lastMacro], 0);\n\t\t\taiptek->lastMacro = -1;\n\t\t}\n\n\t\tif (macro != -1 && macro != aiptek->lastMacro) {\n\t\t\tinput_report_key(inputdev, macroKeyEvents[macro], 1);\n\t\t\taiptek->lastMacro = macro;\n\t\t}\n\t\tinput_report_abs(inputdev, ABS_MISC,\n\t\t\t\t p | AIPTEK_REPORT_TOOL_STYLUS);\n\t\tinput_sync(inputdev);\n\t}\n\t/* Report 5s come from the macro keys when pressed by mouse\n\t */\n\telse if (data[0] == 5) {\n\t\tjitterable = data[1] & 0x1c;\n\n\t\tdv = (data[1] & 0x01) != 0 ? 1 : 0;\n\t\tp = (data[1] & 0x02) != 0 ? 1 : 0;\n\t\tleft = (data[1]& aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;\n\t\tright = (data[1] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;\n\t\tmiddle = (data[1] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;\n\t\tmacro = dv && p && left && !(data[3] & 1) ? (data[3] >> 1) : 0;\n\n\t\tif (dv) {\n\t\t        /* If the selected tool changed, reset the old\n\t\t\t * tool key, and set the new one.\n\t\t\t */\n\t\t        if (aiptek->previousToolMode !=\n\t\t\t    aiptek->curSetting.toolMode) {\n\t\t                input_report_key(inputdev,\n\t\t\t\t\t\t aiptek->previousToolMode, 0);\n\t\t\t        input_report_key(inputdev,\n\t\t\t\t\t\t aiptek->curSetting.toolMode, 1);\n\t\t\t        aiptek->previousToolMode = aiptek->curSetting.toolMode;\n\t\t\t}\n\t\t}\n\n\t\tif (aiptek->lastMacro != -1 && aiptek->lastMacro != macro) {\n\t\t        input_report_key(inputdev, macroKeyEvents[aiptek->lastMacro], 0);\n\t\t\taiptek->lastMacro = -1;\n\t\t}\n\n\t\tif (macro != -1 && macro != aiptek->lastMacro) {\n\t\t\tinput_report_key(inputdev, macroKeyEvents[macro], 1);\n\t\t\taiptek->lastMacro = macro;\n\t\t}\n\n\t\tinput_report_abs(inputdev, ABS_MISC,\n\t\t\t\t p | AIPTEK_REPORT_TOOL_MOUSE);\n\t\tinput_sync(inputdev);\n\t}\n\t/* We have no idea which tool can generate a report 6. Theoretically,\n\t * neither need to, having been given reports 4 & 5 for such use.\n\t * However, report 6 is the 'official-looking' report for macroKeys;\n\t * reports 4 & 5 supposively are used to support unnamed, unknown\n\t * hat switches (which just so happen to be the macroKeys.)\n\t */\n\telse if (data[0] == 6) {\n\t\tmacro = get_unaligned_le16(data + 1);\n\t\tif (macro > 0) {\n\t\t\tinput_report_key(inputdev, macroKeyEvents[macro - 1],\n\t\t\t\t\t 0);\n\t\t}\n\t\tif (macro < 25) {\n\t\t\tinput_report_key(inputdev, macroKeyEvents[macro + 1],\n\t\t\t\t\t 0);\n\t\t}\n\n\t\t/* If the selected tool changed, reset the old\n\t\t   tool key, and set the new one.\n\t\t*/\n\t\tif (aiptek->previousToolMode !=\n\t\t    aiptek->curSetting.toolMode) {\n\t\t        input_report_key(inputdev,\n\t\t\t\t\t aiptek->previousToolMode, 0);\n\t\t\tinput_report_key(inputdev,\n\t\t\t\t\t aiptek->curSetting.toolMode,\n\t\t\t\t\t 1);\n\t\t\taiptek->previousToolMode =\n\t\t\t\taiptek->curSetting.toolMode;\n\t\t}\n\n\t\tinput_report_key(inputdev, macroKeyEvents[macro], 1);\n\t\tinput_report_abs(inputdev, ABS_MISC,\n\t\t\t\t 1 | AIPTEK_REPORT_TOOL_UNKNOWN);\n\t\tinput_sync(inputdev);\n\t} else {\n\t\tdev_dbg(&intf->dev, \"Unknown report %d\\n\", data[0]);\n\t}\n\n\t/* Jitter may occur when the user presses a button on the stlyus\n\t * or the mouse. What we do to prevent that is wait 'x' milliseconds\n\t * following a 'jitterable' event, which should give the hand some time\n\t * stabilize itself.\n\t *\n\t * We just introduced aiptek->previousJitterable to carry forth the\n\t * notion that jitter occurs when the button state changes from on to off:\n\t * a person drawing, holding a button down is not subject to jittering.\n\t * With that in mind, changing from upper button depressed to lower button\n\t * WILL transition through a jitter delay.\n\t */\n\n\tif (aiptek->previousJitterable != jitterable &&\n\t    aiptek->curSetting.jitterDelay != 0 && aiptek->inDelay != 1) {\n\t\taiptek->endDelay = jiffies +\n\t\t    ((aiptek->curSetting.jitterDelay * HZ) / 1000);\n\t\taiptek->inDelay = 1;\n\t}\n\taiptek->previousJitterable = jitterable;\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval != 0) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 16520,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static int aiptek_program_tablet(struct aiptek *aiptek)\n{\n\tint ret;\n\t/* Execute Resolution500LPI */\n\tif ((ret = aiptek_command(aiptek, 0x18, 0x04)) < 0)\n\t\treturn ret;\n\n\t/* Query getModelCode */\n\tif ((ret = aiptek_query(aiptek, 0x02, 0x00)) < 0)\n\t\treturn ret;\n\taiptek->features.modelCode = ret & 0xff;\n\n\t/* Query getODMCode */\n\tif ((ret = aiptek_query(aiptek, 0x03, 0x00)) < 0)\n\t\treturn ret;\n\taiptek->features.odmCode = ret;\n\n\t/* Query getFirmwareCode */\n\tif ((ret = aiptek_query(aiptek, 0x04, 0x00)) < 0)\n\t\treturn ret;\n\taiptek->features.firmwareCode = ret;\n\n\t/* Query getXextension */\n\tif ((ret = aiptek_query(aiptek, 0x01, 0x00)) < 0)\n\t\treturn ret;\n\tinput_set_abs_params(aiptek->inputdev, ABS_X, 0, ret - 1, 0, 0);\n\n\t/* Query getYextension */\n\tif ((ret = aiptek_query(aiptek, 0x01, 0x01)) < 0)\n\t\treturn ret;\n\tinput_set_abs_params(aiptek->inputdev, ABS_Y, 0, ret - 1, 0, 0);\n\n\t/* Query getPressureLevels */\n\tif ((ret = aiptek_query(aiptek, 0x08, 0x00)) < 0)\n\t\treturn ret;\n\tinput_set_abs_params(aiptek->inputdev, ABS_PRESSURE, 0, ret - 1, 0, 0);\n\n\t/* Depending on whether we are in absolute or relative mode, we will\n\t * do a switchToTablet(absolute) or switchToMouse(relative) command.\n\t */\n\tif (aiptek->curSetting.coordinateMode ==\n\t    AIPTEK_COORDINATE_ABSOLUTE_MODE) {\n\t\t/* Execute switchToTablet */\n\t\tif ((ret = aiptek_command(aiptek, 0x10, 0x01)) < 0) {\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t/* Execute switchToMouse */\n\t\tif ((ret = aiptek_command(aiptek, 0x10, 0x00)) < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Enable the macro keys */\n\tif ((ret = aiptek_command(aiptek, 0x11, 0x02)) < 0)\n\t\treturn ret;\n#if 0\n\t/* Execute FilterOn */\n\tif ((ret = aiptek_command(aiptek, 0x17, 0x00)) < 0)\n\t\treturn ret;\n#endif\n\n\t/* Execute AutoGainOn */\n\tif ((ret = aiptek_command(aiptek, 0x12, 0xff)) < 0)\n\t\treturn ret;\n\n\t/* Reset the eventCount, so we track events from last (re)programming\n\t */\n\taiptek->diagnostic = AIPTEK_DIAGNOSTIC_NA;\n\taiptek->eventCount = 0;\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 16521,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "store_tabletYtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint y;\n\n\tif (kstrtoint(buf, 10, &y)) {\n\t\tsize_t len = buf[count - 1] == '\\n' ? count - 1 : count;\n\n\t\tif (strncmp(buf, \"disable\", len))\n\t\t\treturn -EINVAL;\n\n\t\taiptek->newSetting.yTilt = AIPTEK_TILT_DISABLE;\n\t} else {\n\t\tif (y < AIPTEK_TILT_MIN || y > AIPTEK_TILT_MAX)\n\t\t\treturn -EINVAL;\n\n\t\taiptek->newSetting.yTilt = y;\n\t}\n\n\treturn count;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 16554,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "int ocfs2_add_inode_data(struct ocfs2_super *osb,\n\t\t\t struct inode *inode,\n\t\t\t u32 *logical_offset,\n\t\t\t u32 clusters_to_add,\n\t\t\t int mark_unwritten,\n\t\t\t struct buffer_head *fe_bh,\n\t\t\t handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t enum ocfs2_alloc_restarted *reason_ret)\n{\n\tint ret;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), fe_bh);\n\tret = ocfs2_add_clusters_in_btree(handle, &et, logical_offset,\n\t\t\t\t\t  clusters_to_add, mark_unwritten,\n\t\t\t\t\t  data_ac, meta_ac, reason_ret);\n\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 31162,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static int ocfs2_allocate_unwritten_extents(struct inode *inode,\n\t\t\t\t\t    u64 start, u64 len)\n{\n\tint ret;\n\tu32 cpos, phys_cpos, clusters, alloc_size;\n\tu64 end = start + len;\n\tstruct buffer_head *di_bh = NULL;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Nothing to do if the requested reservation range\n\t\t * fits within the inode.\n\t\t */\n\t\tif (ocfs2_size_fits_inline_data(di_bh, end))\n\t\t\tgoto out;\n\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We consider both start and len to be inclusive.\n\t */\n\tcpos = start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(inode->i_sb, start + len);\n\tclusters -= cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos,\n\t\t\t\t\t &alloc_size, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Hole or existing extent len can be arbitrary, so\n\t\t * cap it to our own allocation request.\n\t\t */\n\t\tif (alloc_size > clusters)\n\t\t\talloc_size = clusters;\n\n\t\tif (phys_cpos) {\n\t\t\t/*\n\t\t\t * We already have an allocation at this\n\t\t\t * region so we can safely skip it.\n\t\t\t */\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = __ocfs2_extend_allocation(inode, cpos, alloc_size, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\nnext:\n\t\tcpos += alloc_size;\n\t\tclusters -= alloc_size;\n\t}\n\n\tret = 0;\nout:\n\n\tbrelse(di_bh);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 31163,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "int ocfs2_change_file_space(struct file *file, unsigned int cmd,\n\t\t\t    struct ocfs2_space_resv *sr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret;\n\n\tif ((cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64) &&\n\t    !ocfs2_writes_unwritten_extents(osb))\n\t\treturn -ENOTTY;\n\telse if ((cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) &&\n\t\t !ocfs2_sparse_alloc(osb))\n\t\treturn -ENOTTY;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tret = __ocfs2_change_file_space(file, inode, file->f_pos, cmd, sr, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 31165,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "int ocfs2_check_range_for_refcount(struct inode *inode, loff_t pos,\n\t\t\t\t   size_t count)\n{\n\tint ret = 0;\n\tunsigned int extent_flags;\n\tu32 cpos, clusters, extent_len, phys_cpos;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)) ||\n\t    !ocfs2_is_refcount_inode(inode) ||\n\t    OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcpos = pos >> OCFS2_SB(sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(sb, pos + count) - cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &extent_len,\n\t\t\t\t\t &extent_flags);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (phys_cpos && (extent_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_len > clusters)\n\t\t\textent_len = clusters;\n\n\t\tclusters -= extent_len;\n\t\tcpos += extent_len;\n\t}\nout:\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 31166,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static int ocfs2_extend_file(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tBUG_ON(!di_bh);\n\n\t/* setattr sometimes calls us like this. */\n\tif (new_i_size == 0)\n\t\tgoto out;\n\n\tif (i_size_read(inode) == new_i_size)\n\t\tgoto out;\n\tBUG_ON(new_i_size < i_size_read(inode));\n\n\t/*\n\t * The alloc sem blocks people in read/write from reading our\n\t * allocation until we're done changing it. We depend on\n\t * i_mutex to block other extend/truncate calls while we're\n\t * here.  We even have to hold it for sparse files because there\n\t * might be some tail zeroing.\n\t */\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * We can optimize small extends by keeping the inodes\n\t\t * inline data.\n\t\t */\n\t\tif (ocfs2_size_fits_inline_data(di_bh, new_i_size)) {\n\t\t\tup_write(&oi->ip_alloc_sem);\n\t\t\tgoto out_update_size;\n\t\t}\n\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, di_bh);\n\t\tif (ret) {\n\t\t\tup_write(&oi->ip_alloc_sem);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\tret = ocfs2_zero_extend(inode, di_bh, new_i_size);\n\telse\n\t\tret = ocfs2_extend_no_holes(inode, di_bh, new_i_size,\n\t\t\t\t\t    new_i_size);\n\n\tup_write(&oi->ip_alloc_sem);\n\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_size:\n\tret = ocfs2_simple_size_update(inode, di_bh, new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 31169,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static loff_t ocfs2_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret = 0;\n\n\tinode_lock(inode);\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_END:\n\t\t/* SEEK_END requires the OCFS2 inode lock for the file\n\t\t * because it references the file's size.\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\toffset += i_size_read(inode);\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tif (offset == 0) {\n\t\t\toffset = file->f_pos;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += file->f_pos;\n\t\tbreak;\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\tret = ocfs2_seek_data_hole_offset(file, &offset, whence);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\nout:\n\tinode_unlock(inode);\n\tif (ret)\n\t\treturn ret;\n\treturn offset;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 31173,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static int ocfs2_file_release(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tspin_lock(&oi->ip_lock);\n\tif (!--oi->ip_open_count)\n\t\toi->ip_flags &= ~OCFS2_INODE_OPEN_DIRECT;\n\n\ttrace_ocfs2_file_release(inode, file, file->f_path.dentry,\n\t\t\t\t oi->ip_blkno,\n\t\t\t\t file->f_path.dentry->d_name.len,\n\t\t\t\t file->f_path.dentry->d_name.name,\n\t\t\t\t oi->ip_open_count);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_free_file_private(inode, file);\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 31176,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 325,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 367,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tstate->dev = dev;\n\tsd = &state->sd;\n\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\t/* FIXME - fix the formatting of dev->v4l2_dev.name and use it */\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\t/*\n\t\t * Ensure no interrupts arrive from '888 specific conditions,\n\t\t * since we ignore them in this driver to have commonality with\n\t\t * similar IR controller cores.\n\t\t */\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 633,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tunsigned int irqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n\tconn->cq.mcq.irqn       = irqn;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n\t\t     (unsigned long)conn);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 773,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "Status ImmutableExecutorState::Initialize(const Graph& graph) {\n  TF_RETURN_IF_ERROR(gview_.Initialize(&graph));\n\n  // Build the information about frames in this subgraph.\n  ControlFlowInfo cf_info;\n  TF_RETURN_IF_ERROR(BuildControlFlowInfo(&graph, &cf_info));\n\n  for (auto& it : cf_info.unique_frame_names) {\n    EnsureFrameInfo(it)->nodes =\n        absl::make_unique<std::vector<const NodeItem*>>();\n  }\n  root_frame_info_ = frame_info_[\"\"].get();\n\n  pending_ids_.resize(gview_.num_nodes());\n\n  // Preprocess every node in the graph to create an instance of op\n  // kernel for each node.\n  requires_control_flow_ = false;\n  for (const Node* n : graph.nodes()) {\n    if (IsSink(n)) continue;\n    if (IsSwitch(n) || IsMerge(n) || IsEnter(n) || IsExit(n)) {\n      requires_control_flow_ = true;\n    } else if (IsRecv(n)) {\n      // A Recv node from a different device may produce dead tensors from\n      // non-local control-flow nodes.\n      //\n      // TODO(mrry): Track whether control flow was present in the\n      // pre-partitioned graph, and enable the caller (e.g.\n      // `DirectSession`) to relax this constraint.\n      string send_device;\n      string recv_device;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"send_device\", &send_device));\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"recv_device\", &recv_device));\n      if (send_device != recv_device) {\n        requires_control_flow_ = true;\n      }\n    }\n\n    const int id = n->id();\n    const string& frame_name = cf_info.frame_names[id];\n    FrameInfo* frame_info = EnsureFrameInfo(frame_name);\n\n    NodeItem* item = gview_.node(id);\n    item->node_id = id;\n\n    item->input_start = frame_info->total_inputs;\n    frame_info->total_inputs += n->num_inputs();\n\n    Status s = params_.create_kernel(n->properties(), &item->kernel);\n    if (!s.ok()) {\n      params_.delete_kernel(item->kernel);\n      item->kernel = nullptr;\n      s = AttachDef(s, *n);\n      return s;\n    }\n    CHECK(item->kernel);\n    item->kernel_is_async = (item->kernel->AsAsync() != nullptr);\n    item->is_merge = IsMerge(n);\n    item->is_any_consumer_merge_or_control_trigger = false;\n    for (const Node* consumer : n->out_nodes()) {\n      if (IsMerge(consumer) || IsControlTrigger(consumer)) {\n        item->is_any_consumer_merge_or_control_trigger = true;\n        break;\n      }\n    }\n    const Tensor* const_tensor = item->kernel->const_tensor();\n    if (const_tensor) {\n      // Hold onto a shallow copy of the constant tensor in `*this` so that the\n      // reference count does not drop to 1. This prevents the constant tensor\n      // from being forwarded, and its buffer reused.\n      const_tensors_.emplace_back(*const_tensor);\n    }\n    item->const_tensor = const_tensor;\n    item->is_noop = (item->kernel->type_string_view() == \"NoOp\");\n    item->is_enter = IsEnter(n);\n    if (item->is_enter) {\n      bool is_constant_enter;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(n->attrs(), \"is_constant\", &is_constant_enter));\n      item->is_constant_enter = is_constant_enter;\n\n      string frame_name;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &frame_name));\n      FrameInfo* frame_info = frame_info_[frame_name].get();\n\n      int parallel_iterations;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(n->attrs(), \"parallel_iterations\", &parallel_iterations));\n\n      if (frame_info->parallel_iterations == -1) {\n        frame_info->parallel_iterations = parallel_iterations;\n      } else if (frame_info->parallel_iterations != parallel_iterations) {\n        LOG(WARNING) << \"Loop frame \\\"\" << frame_name\n                     << \"\\\" had two different values for parallel_iterations: \"\n                     << frame_info->parallel_iterations << \" vs. \"\n                     << parallel_iterations << \".\";\n      }\n\n      if (enter_frame_info_.size() <= id) {\n        enter_frame_info_.resize(id + 1);\n      }\n      enter_frame_info_[id] = frame_info;\n    } else {\n      item->is_constant_enter = false;\n    }\n    item->is_exit = IsExit(n);\n    item->is_control_trigger = IsControlTrigger(n);\n    item->is_source = IsSource(n);\n    item->is_enter_exit_or_next_iter =\n        (IsEnter(n) || IsExit(n) || IsNextIteration(n));\n    item->is_transfer_node = IsTransferNode(n);\n    item->is_initialization_op = IsInitializationOp(n);\n    item->is_recv_or_switch = IsRecv(n) || IsSwitch(n);\n    item->is_next_iteration = IsNextIteration(n);\n    item->is_distributed_communication = IsDistributedCommunication(n);\n\n    // Compute the maximum values we'll store for this node in the\n    // pending counts data structure, and allocate a handle in\n    // that frame's pending counts data structure that has enough\n    // space to store these maximal count values.\n    size_t max_pending, max_dead;\n    GetMaxPendingCounts(n, &max_pending, &max_dead);\n    pending_ids_[id] =\n        frame_info->pending_counts_layout.CreateHandle(max_pending, max_dead);\n\n    // See if this node is a root node, and if so, add item to root_nodes_.\n    if (n->in_edges().empty()) {\n      root_nodes_.push_back(item);\n    }\n\n    // Initialize static information about the frames in the graph.\n    frame_info->nodes->push_back(item);\n    if (item->is_enter) {\n      string enter_name;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &enter_name));\n      EnsureFrameInfo(enter_name)->input_count++;\n    }\n\n    // Record information about whether each output of the op is used.\n    std::unique_ptr<bool[]> outputs_required(new bool[n->num_outputs()]);\n    std::fill(&outputs_required[0], &outputs_required[n->num_outputs()], false);\n    int32_t unused_outputs = n->num_outputs();\n    for (const Edge* e : n->out_edges()) {\n      if (IsSink(e->dst())) continue;\n      if (e->src_output() >= 0) {\n        if (!outputs_required[e->src_output()]) {\n          --unused_outputs;\n          outputs_required[e->src_output()] = true;\n        }\n      }\n    }\n    if (unused_outputs > 0) {\n      for (int i = 0; i < n->num_outputs(); ++i) {\n        if (!outputs_required[i]) {\n          metrics::RecordUnusedOutput(n->type_string());\n        }\n      }\n      item->outputs_required = std::move(outputs_required);\n    }\n  }\n\n  // Rewrite each `EdgeInfo::input_slot` member to refer directly to the input\n  // location.\n  for (const Node* n : graph.nodes()) {\n    if (IsSink(n)) continue;\n    const int id = n->id();\n    NodeItem* item = gview_.node(id);\n\n    for (EdgeInfo& e : item->mutable_output_edges()) {\n      const int dst_id = e.dst_id;\n      NodeItem* dst_item = gview_.node(dst_id);\n      e.input_slot += dst_item->input_start;\n    }\n  }\n\n  // Initialize PendingCounts only after pending_ids_[node.id] is initialized\n  // for all nodes.\n  InitializePending(&graph, cf_info);\n  return gview_.SetAllocAttrs(&graph, params_.device);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 5,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "  void DecodePngV2(OpKernelContext* context, StringPiece input) {\n    int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n    png::DecodeContext decode;\n    OP_REQUIRES(\n        context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n        errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n\n    // If we reach this point, then there is data in `decode` which must be\n    // freed by the time we end execution in this function. We cannot call\n    // `png::CommonFreeDecode()` before an `OP_REQUIRES` because if\n    // `OP_REQUIRES` constraint is satisfied then the data would be freed\n    // prematurely. Instead, let's use a `Cleanup` object.\n    auto cleanup = gtl::MakeCleanup([&decode]() {\n      std::cerr << \"Cleanup called...\\n\";\n      png::CommonFreeDecode(&decode);\n    });\n\n    // Verify that width and height are not too large:\n    // - verify width and height don't overflow int.\n    // - width can later be multiplied by channels_ and sizeof(uint16), so\n    //   verify single dimension is not too large.\n    // - verify when width and height are multiplied together, there are a few\n    //   bits to spare as well.\n    const int width = static_cast<int>(decode.width);\n    const int height = static_cast<int>(decode.height);\n    const int64_t total_size =\n        static_cast<int64_t>(width) * static_cast<int64_t>(height);\n    if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n        width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n        height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"PNG size too large for int: \",\n                                          decode.width, \" by \", decode.height));\n    }\n\n    Tensor* output = nullptr;\n    // By the existing API, we support decoding PNG with `DecodeGif` op.\n    // We need to make sure to return 4-D shapes when using `DecodeGif`.\n    if (op_type_ == \"DecodeGif\") {\n      OP_REQUIRES_OK(\n          context,\n          context->allocate_output(\n              0, TensorShape({1, height, width, decode.channels}), &output));\n    } else {\n      OP_REQUIRES_OK(\n          context,\n          context->allocate_output(\n              0, TensorShape({height, width, decode.channels}), &output));\n    }\n\n    if (op_type_ == \"DecodeBmp\") {\n      // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here\n      // because currently `decode_(jpeg|png|gif)` ops can decode any one of\n      // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode\n      // anything but bmp formats. This behavior needs to be revisited. For more\n      // details, please refer to the bug.\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"Trying to decode PNG format using DecodeBmp op. Use \"\n                      \"`decode_png` or `decode_image` instead.\"));\n    } else if (op_type_ == \"DecodeAndCropJpeg\") {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                      \"detected PNG.\"));\n    }\n\n    if (data_type_ == DataType::DT_UINT8) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n              decode.channels * width * sizeof(uint8), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_UINT16) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n              decode.channels * width * sizeof(uint16), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_FLOAT) {\n      // `png::CommonFinishDecode` does not support `float`. First allocate\n      // uint16 buffer for the image and decode in uint16 (lossless). Wrap the\n      // buffer in `unique_ptr` so that we don't forget to delete the buffer.\n      std::unique_ptr<uint16[]> buffer(\n          new uint16[height * width * decode.channels]);\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                  decode.channels * width * sizeof(uint16),\n                                  &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n\n      // Convert uint16 image data to desired data type.\n      // Use eigen threadpooling to speed up the copy operation.\n      const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n      TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                  decode.channels);\n      float scale = 1. / std::numeric_limits<uint16>::max();\n      // Fill output tensor with desired dtype.\n      output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 21,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 326,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\tkfree(a);\n\t\treturn -EINVAL;\n\t}\n\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 368,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 488,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    start_position;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    bytes_per_line,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\n  unsigned int\n    blue,\n    green,\n    offset_bits,\n    red;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n  */\n  (void) memset(&bmp_info,0,sizeof(bmp_info));\n  bmp_info.ba_offset=0;\n  start_position=0;\n  offset_bits=0;\n  count=ReadBlob(image,2,magick);\n  if (count != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    LongPixelPacket\n      shift;\n\n    PixelPacket\n      quantum_bits;\n\n    /*\n      Verify BMP identifier.\n    */\n    if (bmp_info.ba_offset == 0)\n      start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n    while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count != 2) || ((LocaleNCompare((char *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\",2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"  File_size in header:  %u bytes\",bmp_info.file_size);\n\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n        bmp_info.size);\n    if (bmp_info.size == 12)\n      {\n        /*\n          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"BMP2\",MaxTextExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n        bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n          }\n      }\n    else\n      {\n        /*\n          Microsoft Windows BMP image file.\n        */\n        if (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\");\n        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n        bmp_info.image_size=ReadBlobLSBLong(image);\n        bmp_info.x_pixels=ReadBlobLSBLong(image);\n        bmp_info.y_pixels=ReadBlobLSBLong(image);\n        bmp_info.number_colors=ReadBlobLSBLong(image);\n        bmp_info.colors_important=ReadBlobLSBLong(image);\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n            switch (bmp_info.compression)\n            {\n              case BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RGB\");\n                break;\n              }\n              case BI_RLE4:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE8\");\n                break;\n              }\n              case BI_BITFIELDS:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_BITFIELDS\");\n                break;\n              }\n              case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_PNG\");\n                break;\n              }\n              case BI_JPEG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_JPEG\");\n                break;\n              }\n              default:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n              }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Number of colors: %u\",bmp_info.number_colors);\n          }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size > 40)\n          {\n            double\n              gamma;\n\n            /*\n              Read color management information.\n            */\n            bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n            */\n#           define BMP_DENOM ((double) 0x40000000)\n            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\n            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n              bmp_info.red_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.red_primary.x*=gamma;\n            bmp_info.red_primary.y*=gamma;\n            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n            image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n            gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.green_primary.x*=gamma;\n            bmp_info.green_primary.y*=gamma;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n              bmp_info.blue_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.blue_primary.x*=gamma;\n            bmp_info.blue_primary.y*=gamma;\n            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n            /*\n              Decode 16^16 fixed point formatted gamma_scales.\n            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n          (void) CopyMagickString(image->magick,\"BMP3\",MaxTextExtent);\n\n        if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\n            /*\n              Read BMP Version 5 color management information.\n            */\n            intent=ReadBlobLSBLong(image);\n            switch ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n              {\n                image->rendering_intent=SaturationIntent;\n                break;\n              }\n              case LCS_GM_GRAPHICS:\n              {\n                image->rendering_intent=RelativeIntent;\n                break;\n              }\n              case LCS_GM_IMAGES:\n              {\n                image->rendering_intent=PerceptualIntent;\n                break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n              {\n                image->rendering_intent=AbsoluteIntent;\n                break;\n              }\n            }\n            (void) ReadBlobLSBLong(image);  /* Profile data */\n            (void) ReadBlobLSBLong(image);  /* Profile size */\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n          }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedNumberOfColors\");\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    switch (bmp_info.compression)\n    {\n      case BI_RGB:\n        image->compression=NoCompression;\n        break;\n      case BI_RLE8:\n      case BI_RLE4:\n        image->compression=RLECompression;\n        break;\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n      case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->matte=((bmp_info.alpha_mask != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) ? MagickTrue : MagickFalse;\n    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n        one=1;\n        if (image->colors == 0)\n          image->colors=one << bmp_info.bits_per_pixel;\n      }\n    image->x_resolution=(double) bmp_info.x_pixels/100.0;\n    image->y_resolution=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        size_t\n          packet_size;\n\n        /*\n          Read BMP raster colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n          image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n        if (offset < 0)\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n        if (count != (ssize_t) (packet_size*image->colors))\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].blue=ScaleCharToQuantum(*p++);\n          image->colormap[i].green=ScaleCharToQuantum(*p++);\n          image->colormap[i].red=ScaleCharToQuantum(*p++);\n          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    /*\n      Read image data.\n    */\n    if (bmp_info.offset_bits == offset_bits)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    offset_bits=bmp_info.offset_bits;\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t) bytes_per_line*image->rows;\n    if (((MagickSizeType) length/8) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression == BI_BITFIELDS))\n      {\n        pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n          image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length encoded raster pixels.\n        */\n        pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n          image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        status=DecodeImage(image,bmp_info.compression,pixels,\n          image->columns*image->rows);\n        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\");\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        /*\n          We should ignore the alpha value in BMP3 files but there have been\n          reports about 32 bit files with alpha. We do a quick check to see if\n          the alpha channel contains a value that is not zero (default value).\n          If we find a non zero value we asume the program that wrote the file\n          wants to use the alpha channel.\n        */\n        if ((image->matte == MagickFalse) && (bmp_info.size == 40) &&\n            (bmp_info.bits_per_pixel == 32))\n          {\n            bytes_per_line=4*(image->columns);\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              p=pixels+(image->rows-y-1)*bytes_per_line;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (*(p+3) != 0)\n                  {\n                    image->matte=MagickTrue;\n                    y=-1;\n                    break;\n                  }\n                p+=4;\n              }\n            }\n          }\n        bmp_info.alpha_mask=image->matte != MagickFalse ? 0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n              RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n          }\n      }\n    (void) memset(&shift,0,sizeof(shift));\n    (void) memset(&quantum_bits,0,sizeof(quantum_bits));\n    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register size_t\n          sample;\n\n        /*\n          Get shift and quantum bits info from bitfield masks.\n        */\n        if (bmp_info.red_mask != 0)\n          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n          {\n            shift.red++;\n            if (shift.red > 32U)\n              break;\n          }\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)\n          {\n            shift.green++;\n            if (shift.green > 32U)\n              break;\n          }\n        if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)\n          {\n            shift.blue++;\n            if (shift.blue > 32U)\n              break;\n          }\n        if (bmp_info.alpha_mask != 0)\n          while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL) == 0)\n          {\n            shift.opacity++;\n            if (shift.opacity > 32U)\n              break;\n          }\n        sample=shift.red;\n        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample > 32U)\n            break;\n        }\n        quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);\n        sample=shift.green;\n        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample > 32U)\n            break;\n        }\n        quantum_bits.green=ClampToQuantum((MagickRealType) sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample > 32U)\n            break;\n        }\n        quantum_bits.blue=ClampToQuantum((MagickRealType) sample-shift.blue);\n        sample=shift.opacity;\n        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample > 32U)\n            break;\n        }\n        quantum_bits.opacity=ClampToQuantum((MagickRealType) sample-\n          shift.opacity);\n      }\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(indexes+x+bit,index);\n              q++;\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (image->columns % 8); bit++)\n              {\n                index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image);\n        break;\n      }\n      case 4:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0x0f),\n              &index,exception);\n            SetPixelIndex(indexes+x,index);\n            (void) IsValidColormapIndex(image,(ssize_t) (*p & 0x0f),&index,\n              exception);\n            SetPixelIndex(indexes+x+1,index);\n            p++;\n          }\n          if ((image->columns % 2) != 0)\n            {\n              (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0xf),\n                &index,exception);\n              SetPixelIndex(indexes+(x++),index);\n              p++;\n            }\n          if (x < (ssize_t) image->columns)\n            break;\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image);\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8) ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n            (void) IsValidColormapIndex(image,(ssize_t) *p,&index,exception);\n            SetPixelIndex(indexes,index);\n            indexes++;\n            p++;\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image);\n        break;\n      }\n      case 16:\n      {\n        unsigned int\n          alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded 16-bit PseudoColor scanline.\n        */\n        if (bmp_info.compression != BI_RGB &&\n            bmp_info.compression != BI_BITFIELDS)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n              red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n              red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n              green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n            SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n            SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n            SetPixelOpacity(q,OpaqueOpacity);\n            if (image->matte != MagickFalse)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;\n                if (quantum_bits.opacity <= 8)\n                  alpha|=((alpha & 0xff00) >> 8);\n                SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));\n              }\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          unsigned int\n            alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=((unsigned int) *p++ << 8);\n            pixel|=((unsigned int) *p++ << 16);\n            pixel|=((unsigned int) *p++ << 24);\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n              green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n            SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n            SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n            SetPixelAlpha(q,OpaqueOpacity);\n            if (image->matte != MagickFalse)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;\n                if (quantum_bits.opacity == 8)\n                  alpha|=(alpha >> 8);\n                SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));\n              }\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (y > 0)\n      break;\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (bmp_info.height < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n          Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n            ReplaceImageInList(&image, flipped_image);\n            image=flipped_image;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    *magick='\\0';\n    if (bmp_info.ba_offset != 0)\n      {\n        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    count=ReadBlob(image,2,magick);\n    if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n          Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 640,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  },
  {
    "CWE_ID": [
      "CWE-401"
    ],
    "code": "static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tunsigned int irqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n\tif (err) {\n\t\tkvfree(in);\n\t\tgoto err_cqwq;\n\t}\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n\tconn->cq.mcq.irqn       = irqn;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n\t\t     (unsigned long)conn);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 774,
    "RELATED_CWE": [
      "CWE-1333",
      "CWE-703",
      "CWE-404"
    ]
  }
]