[
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "static DH *get_server_static_dh_key(SESS_CERT *scert)\n{\n    DH *dh_srvr = NULL;\n    EVP_PKEY *spkey = NULL;\n    int idx = scert->peer_cert_type;\n\n    if (idx >= 0)\n        spkey = X509_get_pubkey(scert->peer_pkeys[idx].x509);\n    if (spkey) {\n        dh_srvr = EVP_PKEY_get1_DH(spkey);\n        EVP_PKEY_free(spkey);\n    }\n    if (dh_srvr == NULL)\n        SSLerr(SSL_F_GET_SERVER_STATIC_DH_KEY, ERR_R_INTERNAL_ERROR);\n    return dh_srvr;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 1413,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "static int ssl3_check_client_certificate(SSL *s)\n{\n    unsigned long alg_k;\n    if (!s->cert || !s->cert->key->x509 || !s->cert->key->privatekey)\n        return 0;\n    /* If no suitable signature algorithm can't use certificate */\n    if (SSL_USE_SIGALGS(s) && !s->cert->key->digest)\n        return 0;\n    /*\n     * If strict mode check suitability of chain before using it. This also\n     * adjusts suite B digest if necessary.\n     */\n    if (s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT &&\n        !tls1_check_chain(s, NULL, NULL, NULL, -2))\n        return 0;\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    /* See if we can use client certificate for fixed DH */\n    if (alg_k & (SSL_kDHr | SSL_kDHd)) {\n        SESS_CERT *scert = s->session->sess_cert;\n        int i = scert->peer_cert_type;\n        EVP_PKEY *clkey = NULL, *spkey = NULL;\n        clkey = s->cert->key->privatekey;\n        /* If client key not DH assume it can be used */\n        if (EVP_PKEY_id(clkey) != EVP_PKEY_DH)\n            return 1;\n        if (i >= 0)\n            spkey = X509_get_pubkey(scert->peer_pkeys[i].x509);\n        if (spkey) {\n            /* Compare server and client parameters */\n            i = EVP_PKEY_cmp_parameters(clkey, spkey);\n            EVP_PKEY_free(spkey);\n            if (i != 1)\n                return 0;\n        }\n        s->s3->flags |= TLS1_FLAGS_SKIP_CERT_VERIFY;\n    }\n    return 1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 1415,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "int ssl3_client_hello(SSL *s)\n{\n    unsigned char *buf;\n    unsigned char *p, *d;\n    int i;\n    unsigned long l;\n    int al = 0;\n#ifndef OPENSSL_NO_COMP\n    int j;\n    SSL_COMP *comp;\n#endif\n\n    buf = (unsigned char *)s->init_buf->data;\n    if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {\n        SSL_SESSION *sess = s->session;\n        if ((sess == NULL) || (sess->ssl_version != s->version) ||\n#ifdef OPENSSL_NO_TLSEXT\n            !sess->session_id_length ||\n#else\n            /*\n             * In the case of EAP-FAST, we can have a pre-shared\n             * \"ticket\" without a session ID.\n             */\n            (!sess->session_id_length && !sess->tlsext_tick) ||\n#endif\n            (sess->not_resumable)) {\n            if (!ssl_get_new_session(s, 0))\n                goto err;\n        }\n        if (s->method->version == DTLS_ANY_VERSION) {\n            /* Determine which DTLS version to use */\n            int options = s->options;\n            /* If DTLS 1.2 disabled correct the version number */\n            if (options & SSL_OP_NO_DTLSv1_2) {\n                if (tls1_suiteb(s)) {\n                    SSLerr(SSL_F_SSL3_CLIENT_HELLO,\n                           SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\n                    goto err;\n                }\n                /*\n                 * Disabling all versions is silly: return an error.\n                 */\n                if (options & SSL_OP_NO_DTLSv1) {\n                    SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_WRONG_SSL_VERSION);\n                    goto err;\n                }\n                /*\n                 * Update method so we don't use any DTLS 1.2 features.\n                 */\n                s->method = DTLSv1_client_method();\n                s->version = DTLS1_VERSION;\n            } else {\n                /*\n                 * We only support one version: update method\n                 */\n                if (options & SSL_OP_NO_DTLSv1)\n                    s->method = DTLSv1_2_client_method();\n                s->version = DTLS1_2_VERSION;\n            }\n            s->client_version = s->version;\n        }\n        /* else use the pre-loaded session */\n\n        p = s->s3->client_random;\n\n        /*\n         * for DTLS if client_random is initialized, reuse it, we are\n         * required to use same upon reply to HelloVerify\n         */\n        if (SSL_IS_DTLS(s)) {\n            size_t idx;\n            i = 1;\n            for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {\n                if (p[idx]) {\n                    i = 0;\n                    break;\n                }\n            }\n        } else\n            i = 1;\n\n        if (i && ssl_fill_hello_random(s, 0, p,\n                                       sizeof(s->s3->client_random)) <= 0)\n            goto err;\n\n        /* Do the message type and length last */\n        d = p = ssl_handshake_start(s);\n\n        /*-\n         * version indicates the negotiated version: for example from\n         * an SSLv2/v3 compatible client hello). The client_version\n         * field is the maximum version we permit and it is also\n         * used in RSA encrypted premaster secrets. Some servers can\n         * choke if we initially report a higher version then\n         * renegotiate to a lower one in the premaster secret. This\n         * didn't happen with TLS 1.0 as most servers supported it\n         * but it can with TLS 1.1 or later if the server only supports\n         * 1.0.\n         *\n         * Possible scenario with previous logic:\n         *      1. Client hello indicates TLS 1.2\n         *      2. Server hello says TLS 1.0\n         *      3. RSA encrypted premaster secret uses 1.2.\n         *      4. Handhaked proceeds using TLS 1.0.\n         *      5. Server sends hello request to renegotiate.\n         *      6. Client hello indicates TLS v1.0 as we now\n         *         know that is maximum server supports.\n         *      7. Server chokes on RSA encrypted premaster secret\n         *         containing version 1.0.\n         *\n         * For interoperability it should be OK to always use the\n         * maximum version we support in client hello and then rely\n         * on the checking of version to ensure the servers isn't\n         * being inconsistent: for example initially negotiating with\n         * TLS 1.0 and renegotiating with TLS 1.2. We do this by using\n         * client_version in client hello and not resetting it to\n         * the negotiated version.\n         */\n#if 0\n        *(p++) = s->version >> 8;\n        *(p++) = s->version & 0xff;\n        s->client_version = s->version;\n#else\n        *(p++) = s->client_version >> 8;\n        *(p++) = s->client_version & 0xff;\n#endif\n\n        /* Random stuff */\n        memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);\n        p += SSL3_RANDOM_SIZE;\n\n        /* Session ID */\n        if (s->new_session)\n            i = 0;\n        else\n            i = s->session->session_id_length;\n        *(p++) = i;\n        if (i != 0) {\n            if (i > (int)sizeof(s->session->session_id)) {\n                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            memcpy(p, s->session->session_id, i);\n            p += i;\n        }\n\n        /* cookie stuff for DTLS */\n        if (SSL_IS_DTLS(s)) {\n            if (s->d1->cookie_len > sizeof(s->d1->cookie)) {\n                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            *(p++) = s->d1->cookie_len;\n            memcpy(p, s->d1->cookie, s->d1->cookie_len);\n            p += s->d1->cookie_len;\n        }\n\n        /* Ciphers supported */\n        i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);\n            goto err;\n        }\n#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH\n        /*\n         * Some servers hang if client hello > 256 bytes as hack workaround\n         * chop number of supported ciphers to keep it well below this if we\n         * use TLS v1.2\n         */\n        if (TLS1_get_version(s) >= TLS1_2_VERSION\n            && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)\n            i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;\n#endif\n        s2n(i, p);\n        p += i;\n\n        /* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n        *(p++) = 1;\n#else\n\n        if ((s->options & SSL_OP_NO_COMPRESSION)\n            || !s->ctx->comp_methods)\n            j = 0;\n        else\n            j = sk_SSL_COMP_num(s->ctx->comp_methods);\n        *(p++) = 1 + j;\n        for (i = 0; i < j; i++) {\n            comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);\n            *(p++) = comp->id;\n        }\n#endif\n        *(p++) = 0;             /* Add the NULL method */\n\n#ifndef OPENSSL_NO_TLSEXT\n        /* TLS extensions */\n        if (ssl_prepare_clienthello_tlsext(s) <= 0) {\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n            goto err;\n        }\n        if ((p =\n             ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,\n                                        &al)) == NULL) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, al);\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n#endif\n\n        l = p - d;\n        ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l);\n        s->state = SSL3_ST_CW_CLNT_HELLO_B;\n    }\n\n    /* SSL3_ST_CW_CLNT_HELLO_B */\n    return ssl_do_write(s);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 1416,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "int ssl3_accept(SSL *s)\n{\n    BUF_MEM *buf;\n    unsigned long alg_k, Time = (unsigned long)time(NULL);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n    int ret = -1;\n    int new_state, state, skip = 0;\n\n    RAND_add(&Time, sizeof(Time), 0);\n    ERR_clear_error();\n    clear_sys_error();\n\n    if (s->info_callback != NULL)\n        cb = s->info_callback;\n    else if (s->ctx->info_callback != NULL)\n        cb = s->ctx->info_callback;\n\n    /* init things to blank */\n    s->in_handshake++;\n    if (!SSL_in_init(s) || SSL_in_before(s))\n        SSL_clear(s);\n\n    if (s->cert == NULL) {\n        SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_NO_CERTIFICATE_SET);\n        return (-1);\n    }\n#ifndef OPENSSL_NO_HEARTBEATS\n    /*\n     * If we're awaiting a HeartbeatResponse, pretend we already got and\n     * don't await it anymore, because Heartbeats don't make sense during\n     * handshakes anyway.\n     */\n    if (s->tlsext_hb_pending) {\n        s->tlsext_hb_pending = 0;\n        s->tlsext_hb_seq++;\n    }\n#endif\n\n    for (;;) {\n        state = s->state;\n\n        switch (s->state) {\n        case SSL_ST_RENEGOTIATE:\n            s->renegotiate = 1;\n            /* s->state=SSL_ST_ACCEPT; */\n\n        case SSL_ST_BEFORE:\n        case SSL_ST_ACCEPT:\n        case SSL_ST_BEFORE | SSL_ST_ACCEPT:\n        case SSL_ST_OK | SSL_ST_ACCEPT:\n\n            s->server = 1;\n            if (cb != NULL)\n                cb(s, SSL_CB_HANDSHAKE_START, 1);\n\n            if ((s->version >> 8) != 3) {\n                SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);\n                s->state = SSL_ST_ERR;\n                return -1;\n            }\n            s->type = SSL_ST_ACCEPT;\n\n            if (s->init_buf == NULL) {\n                if ((buf = BUF_MEM_new()) == NULL) {\n                    ret = -1;\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n                if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {\n                    BUF_MEM_free(buf);\n                    ret = -1;\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n                s->init_buf = buf;\n            }\n\n            if (!ssl3_setup_buffers(s)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            s->init_num = 0;\n            s->s3->flags &= ~TLS1_FLAGS_SKIP_CERT_VERIFY;\n            s->s3->flags &= ~SSL3_FLAGS_CCS_OK;\n            /*\n             * Should have been reset by ssl3_get_finished, too.\n             */\n            s->s3->change_cipher_spec = 0;\n\n            if (s->state != SSL_ST_RENEGOTIATE) {\n                /*\n                 * Ok, we now need to push on a buffering BIO so that the\n                 * output is sent in a way that TCP likes :-)\n                 */\n                if (!ssl_init_wbio_buffer(s, 1)) {\n                    ret = -1;\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n\n                ssl3_init_finished_mac(s);\n                s->state = SSL3_ST_SR_CLNT_HELLO_A;\n                s->ctx->stats.sess_accept++;\n            } else if (!s->s3->send_connection_binding &&\n                       !(s->options &\n                         SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n                /*\n                 * Server attempting to renegotiate with client that doesn't\n                 * support secure renegotiation.\n                 */\n                SSLerr(SSL_F_SSL3_ACCEPT,\n                       SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            } else {\n                /*\n                 * s->state == SSL_ST_RENEGOTIATE, we will just send a\n                 * HelloRequest\n                 */\n                s->ctx->stats.sess_accept_renegotiate++;\n                s->state = SSL3_ST_SW_HELLO_REQ_A;\n            }\n            break;\n\n        case SSL3_ST_SW_HELLO_REQ_A:\n        case SSL3_ST_SW_HELLO_REQ_B:\n\n            s->shutdown = 0;\n            ret = ssl3_send_hello_request(s);\n            if (ret <= 0)\n                goto end;\n            s->s3->tmp.next_state = SSL3_ST_SW_HELLO_REQ_C;\n            s->state = SSL3_ST_SW_FLUSH;\n            s->init_num = 0;\n\n            ssl3_init_finished_mac(s);\n            break;\n\n        case SSL3_ST_SW_HELLO_REQ_C:\n            s->state = SSL_ST_OK;\n            break;\n\n        case SSL3_ST_SR_CLNT_HELLO_A:\n        case SSL3_ST_SR_CLNT_HELLO_B:\n        case SSL3_ST_SR_CLNT_HELLO_C:\n\n            s->shutdown = 0;\n            ret = ssl3_get_client_hello(s);\n            if (ret <= 0)\n                goto end;\n#ifndef OPENSSL_NO_SRP\n            s->state = SSL3_ST_SR_CLNT_HELLO_D;\n        case SSL3_ST_SR_CLNT_HELLO_D:\n            {\n                int al;\n                if ((ret = ssl_check_srp_ext_ClientHello(s, &al)) < 0) {\n                    /*\n                     * callback indicates firther work to be done\n                     */\n                    s->rwstate = SSL_X509_LOOKUP;\n                    goto end;\n                }\n                if (ret != SSL_ERROR_NONE) {\n                    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n                    /*\n                     * This is not really an error but the only means to for\n                     * a client to detect whether srp is supported.\n                     */\n                    if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY)\n                        SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_CLIENTHELLO_TLSEXT);\n                    ret = SSL_TLSEXT_ERR_ALERT_FATAL;\n                    ret = -1;\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n            }\n#endif\n\n            s->renegotiate = 2;\n            s->state = SSL3_ST_SW_SRVR_HELLO_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_SW_SRVR_HELLO_A:\n        case SSL3_ST_SW_SRVR_HELLO_B:\n            ret = ssl3_send_server_hello(s);\n            if (ret <= 0)\n                goto end;\n#ifndef OPENSSL_NO_TLSEXT\n            if (s->hit) {\n                if (s->tlsext_ticket_expected)\n                    s->state = SSL3_ST_SW_SESSION_TICKET_A;\n                else\n                    s->state = SSL3_ST_SW_CHANGE_A;\n            }\n#else\n            if (s->hit)\n                s->state = SSL3_ST_SW_CHANGE_A;\n#endif\n            else\n                s->state = SSL3_ST_SW_CERT_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_SW_CERT_A:\n        case SSL3_ST_SW_CERT_B:\n            /* Check if it is anon DH or anon ECDH, */\n            /* normal PSK or KRB5 or SRP */\n            if (!\n                (s->s3->tmp.\n                 new_cipher->algorithm_auth & (SSL_aNULL | SSL_aKRB5 |\n                                               SSL_aSRP))\n&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {\n                ret = ssl3_send_server_certificate(s);\n                if (ret <= 0)\n                    goto end;\n#ifndef OPENSSL_NO_TLSEXT\n                if (s->tlsext_status_expected)\n                    s->state = SSL3_ST_SW_CERT_STATUS_A;\n                else\n                    s->state = SSL3_ST_SW_KEY_EXCH_A;\n            } else {\n                skip = 1;\n                s->state = SSL3_ST_SW_KEY_EXCH_A;\n            }\n#else\n            } else\n                skip = 1;\n\n            s->state = SSL3_ST_SW_KEY_EXCH_A;\n#endif\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_SW_KEY_EXCH_A:\n        case SSL3_ST_SW_KEY_EXCH_B:\n            alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n            /*\n             * clear this, it may get reset by\n             * send_server_key_exchange\n             */\n            s->s3->tmp.use_rsa_tmp = 0;\n\n            /*\n             * only send if a DH key exchange, fortezza or RSA but we have a\n             * sign only certificate PSK: may send PSK identity hints For\n             * ECC ciphersuites, we send a serverKeyExchange message only if\n             * the cipher suite is either ECDH-anon or ECDHE. In other cases,\n             * the server certificate contains the server's public key for\n             * key exchange.\n             */\n            if (0\n                /*\n                 * PSK: send ServerKeyExchange if PSK identity hint if\n                 * provided\n                 */\n#ifndef OPENSSL_NO_PSK\n                || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)\n#endif\n#ifndef OPENSSL_NO_SRP\n                /* SRP: send ServerKeyExchange */\n                || (alg_k & SSL_kSRP)\n#endif\n                || (alg_k & SSL_kEDH)\n                || (alg_k & SSL_kEECDH)\n                || ((alg_k & SSL_kRSA)\n                    && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n                        || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n                            && EVP_PKEY_size(s->cert->pkeys\n                                             [SSL_PKEY_RSA_ENC].privatekey) *\n                            8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n                        )\n                    )\n                )\n                ) {\n                ret = ssl3_send_server_key_exchange(s);\n                if (ret <= 0)\n                    goto end;\n            } else\n                skip = 1;\n\n            s->state = SSL3_ST_SW_CERT_REQ_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_SW_CERT_REQ_A:\n        case SSL3_ST_SW_CERT_REQ_B:\n            if (                /* don't request cert unless asked for it: */\n                   !(s->verify_mode & SSL_VERIFY_PEER) ||\n                   /*\n                    * if SSL_VERIFY_CLIENT_ONCE is set, don't request cert\n                    * during re-negotiation:\n                    */\n                   ((s->session->peer != NULL) &&\n                    (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n                   /*\n                    * never request cert in anonymous ciphersuites (see\n                    * section \"Certificate request\" in SSL 3 drafts and in\n                    * RFC 2246):\n                    */\n                   ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n                    /*\n                     * ... except when the application insists on\n                     * verification (against the specs, but s3_clnt.c accepts\n                     * this for SSL 3)\n                     */\n                    !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\n                   /*\n                    * never request cert in Kerberos ciphersuites\n                    */\n                   (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) ||\n                   /* don't request certificate for SRP auth */\n                   (s->s3->tmp.new_cipher->algorithm_auth & SSL_aSRP)\n                   /*\n                    * With normal PSK Certificates and Certificate Requests\n                    * are omitted\n                    */\n                   || (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {\n                /* no cert request */\n                skip = 1;\n                s->s3->tmp.cert_request = 0;\n                s->state = SSL3_ST_SW_SRVR_DONE_A;\n                if (s->s3->handshake_buffer) {\n                    if (!ssl3_digest_cached_records(s)) {\n                        s->state = SSL_ST_ERR;\n                        return -1;\n                    }\n                }\n            } else {\n                s->s3->tmp.cert_request = 1;\n                ret = ssl3_send_certificate_request(s);\n                if (ret <= 0)\n                    goto end;\n#ifndef NETSCAPE_HANG_BUG\n                s->state = SSL3_ST_SW_SRVR_DONE_A;\n#else\n                s->state = SSL3_ST_SW_FLUSH;\n                s->s3->tmp.next_state = SSL3_ST_SR_CERT_A;\n#endif\n                s->init_num = 0;\n            }\n            break;\n\n        case SSL3_ST_SW_SRVR_DONE_A:\n        case SSL3_ST_SW_SRVR_DONE_B:\n            ret = ssl3_send_server_done(s);\n            if (ret <= 0)\n                goto end;\n            s->s3->tmp.next_state = SSL3_ST_SR_CERT_A;\n            s->state = SSL3_ST_SW_FLUSH;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_SW_FLUSH:\n\n            /*\n             * This code originally checked to see if any data was pending\n             * using BIO_CTRL_INFO and then flushed. This caused problems as\n             * documented in PR#1939. The proposed fix doesn't completely\n             * resolve this issue as buggy implementations of\n             * BIO_CTRL_PENDING still exist. So instead we just flush\n             * unconditionally.\n             */\n\n            s->rwstate = SSL_WRITING;\n            if (BIO_flush(s->wbio) <= 0) {\n                ret = -1;\n                goto end;\n            }\n            s->rwstate = SSL_NOTHING;\n\n            s->state = s->s3->tmp.next_state;\n            break;\n\n        case SSL3_ST_SR_CERT_A:\n        case SSL3_ST_SR_CERT_B:\n            if (s->s3->tmp.cert_request) {\n                ret = ssl3_get_client_certificate(s);\n                if (ret <= 0)\n                    goto end;\n            }\n            s->init_num = 0;\n            s->state = SSL3_ST_SR_KEY_EXCH_A;\n            break;\n\n        case SSL3_ST_SR_KEY_EXCH_A:\n        case SSL3_ST_SR_KEY_EXCH_B:\n            ret = ssl3_get_client_key_exchange(s);\n            if (ret <= 0)\n                goto end;\n            if (ret == 2) {\n                /*\n                 * For the ECDH ciphersuites when the client sends its ECDH\n                 * pub key in a certificate, the CertificateVerify message is\n                 * not sent. Also for GOST ciphersuites when the client uses\n                 * its key from the certificate for key exchange.\n                 */\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n                s->state = SSL3_ST_SR_FINISHED_A;\n#else\n                if (s->s3->next_proto_neg_seen)\n                    s->state = SSL3_ST_SR_NEXT_PROTO_A;\n                else\n                    s->state = SSL3_ST_SR_FINISHED_A;\n#endif\n                s->init_num = 0;\n            } else if (SSL_USE_SIGALGS(s)) {\n                s->state = SSL3_ST_SR_CERT_VRFY_A;\n                s->init_num = 0;\n                if (!s->session->peer)\n                    break;\n                /*\n                 * For sigalgs freeze the handshake buffer at this point and\n                 * digest cached records.\n                 */\n                if (!s->s3->handshake_buffer) {\n                    SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);\n                    s->state = SSL_ST_ERR;\n                    return -1;\n                }\n                s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;\n                if (!ssl3_digest_cached_records(s)) {\n                    s->state = SSL_ST_ERR;\n                    return -1;\n                }\n            } else {\n                int offset = 0;\n                int dgst_num;\n\n                s->state = SSL3_ST_SR_CERT_VRFY_A;\n                s->init_num = 0;\n\n                /*\n                 * We need to get hashes here so if there is a client cert,\n                 * it can be verified FIXME - digest processing for\n                 * CertificateVerify should be generalized. But it is next\n                 * step\n                 */\n                if (s->s3->handshake_buffer) {\n                    if (!ssl3_digest_cached_records(s)) {\n                        s->state = SSL_ST_ERR;\n                        return -1;\n                    }\n                }\n                for (dgst_num = 0; dgst_num < SSL_MAX_DIGEST; dgst_num++)\n                    if (s->s3->handshake_dgst[dgst_num]) {\n                        int dgst_size;\n\n                        s->method->ssl3_enc->cert_verify_mac(s,\n                                                             EVP_MD_CTX_type\n                                                             (s->\n                                                              s3->handshake_dgst\n                                                              [dgst_num]),\n                                                             &(s->s3->\n                                                               tmp.cert_verify_md\n                                                               [offset]));\n                        dgst_size =\n                            EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);\n                        if (dgst_size < 0) {\n                            s->state = SSL_ST_ERR;\n                            ret = -1;\n                            goto end;\n                        }\n                        offset += dgst_size;\n                    }\n            }\n            break;\n\n        case SSL3_ST_SR_CERT_VRFY_A:\n        case SSL3_ST_SR_CERT_VRFY_B:\n            ret = ssl3_get_cert_verify(s);\n            if (ret <= 0)\n                goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n            s->state = SSL3_ST_SR_FINISHED_A;\n#else\n            if (s->s3->next_proto_neg_seen)\n                s->state = SSL3_ST_SR_NEXT_PROTO_A;\n            else\n                s->state = SSL3_ST_SR_FINISHED_A;\n#endif\n            s->init_num = 0;\n            break;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n        case SSL3_ST_SR_NEXT_PROTO_A:\n        case SSL3_ST_SR_NEXT_PROTO_B:\n            /*\n             * Enable CCS for NPN. Receiving a CCS clears the flag, so make\n             * sure not to re-enable it to ban duplicates. This *should* be the\n             * first time we have received one - but we check anyway to be\n             * cautious.\n             * s->s3->change_cipher_spec is set when a CCS is\n             * processed in s3_pkt.c, and remains set until\n             * the client's Finished message is read.\n             */\n            if (!s->s3->change_cipher_spec)\n                s->s3->flags |= SSL3_FLAGS_CCS_OK;\n\n            ret = ssl3_get_next_proto(s);\n            if (ret <= 0)\n                goto end;\n            s->init_num = 0;\n            s->state = SSL3_ST_SR_FINISHED_A;\n            break;\n#endif\n\n        case SSL3_ST_SR_FINISHED_A:\n        case SSL3_ST_SR_FINISHED_B:\n            /*\n             * Enable CCS for handshakes without NPN. In NPN the CCS flag has\n             * already been set. Receiving a CCS clears the flag, so make\n             * sure not to re-enable it to ban duplicates.\n             * s->s3->change_cipher_spec is set when a CCS is\n             * processed in s3_pkt.c, and remains set until\n             * the client's Finished message is read.\n             */\n            if (!s->s3->change_cipher_spec)\n                s->s3->flags |= SSL3_FLAGS_CCS_OK;\n            ret = ssl3_get_finished(s, SSL3_ST_SR_FINISHED_A,\n                                    SSL3_ST_SR_FINISHED_B);\n            if (ret <= 0)\n                goto end;\n            if (s->hit)\n                s->state = SSL_ST_OK;\n#ifndef OPENSSL_NO_TLSEXT\n            else if (s->tlsext_ticket_expected)\n                s->state = SSL3_ST_SW_SESSION_TICKET_A;\n#endif\n            else\n                s->state = SSL3_ST_SW_CHANGE_A;\n            s->init_num = 0;\n            break;\n\n#ifndef OPENSSL_NO_TLSEXT\n        case SSL3_ST_SW_SESSION_TICKET_A:\n        case SSL3_ST_SW_SESSION_TICKET_B:\n            ret = ssl3_send_newsession_ticket(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_SW_CHANGE_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_SW_CERT_STATUS_A:\n        case SSL3_ST_SW_CERT_STATUS_B:\n            ret = ssl3_send_cert_status(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_SW_KEY_EXCH_A;\n            s->init_num = 0;\n            break;\n\n#endif\n\n        case SSL3_ST_SW_CHANGE_A:\n        case SSL3_ST_SW_CHANGE_B:\n\n            s->session->cipher = s->s3->tmp.new_cipher;\n            if (!s->method->ssl3_enc->setup_key_block(s)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            ret = ssl3_send_change_cipher_spec(s,\n                                               SSL3_ST_SW_CHANGE_A,\n                                               SSL3_ST_SW_CHANGE_B);\n\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_SW_FINISHED_A;\n            s->init_num = 0;\n\n            if (!s->method->ssl3_enc->change_cipher_state(s,\n                                                          SSL3_CHANGE_CIPHER_SERVER_WRITE))\n            {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            break;\n\n        case SSL3_ST_SW_FINISHED_A:\n        case SSL3_ST_SW_FINISHED_B:\n            ret = ssl3_send_finished(s,\n                                     SSL3_ST_SW_FINISHED_A,\n                                     SSL3_ST_SW_FINISHED_B,\n                                     s->method->\n                                     ssl3_enc->server_finished_label,\n                                     s->method->\n                                     ssl3_enc->server_finished_label_len);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_SW_FLUSH;\n            if (s->hit) {\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n                s->s3->tmp.next_state = SSL3_ST_SR_FINISHED_A;\n#else\n                if (s->s3->next_proto_neg_seen) {\n                    s->s3->tmp.next_state = SSL3_ST_SR_NEXT_PROTO_A;\n                } else\n                    s->s3->tmp.next_state = SSL3_ST_SR_FINISHED_A;\n#endif\n            } else\n                s->s3->tmp.next_state = SSL_ST_OK;\n            s->init_num = 0;\n            break;\n\n        case SSL_ST_OK:\n            /* clean a few things up */\n            ssl3_cleanup_key_block(s);\n\n            BUF_MEM_free(s->init_buf);\n            s->init_buf = NULL;\n\n            /* remove buffering on output */\n            ssl_free_wbio_buffer(s);\n\n            s->init_num = 0;\n\n            if (s->renegotiate == 2) { /* skipped if we just sent a\n                                        * HelloRequest */\n                s->renegotiate = 0;\n                s->new_session = 0;\n\n                ssl_update_cache(s, SSL_SESS_CACHE_SERVER);\n\n                s->ctx->stats.sess_accept_good++;\n                /* s->server=1; */\n                s->handshake_func = ssl3_accept;\n\n                if (cb != NULL)\n                    cb(s, SSL_CB_HANDSHAKE_DONE, 1);\n            }\n\n            ret = 1;\n            goto end;\n            /* break; */\n\n        case SSL_ST_ERR:\n        default:\n            SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNKNOWN_STATE);\n            ret = -1;\n            goto end;\n            /* break; */\n        }\n\n        if (!s->s3->tmp.reuse_message && !skip) {\n            if (s->debug) {\n                if ((ret = BIO_flush(s->wbio)) <= 0)\n                    goto end;\n            }\n\n            if ((cb != NULL) && (s->state != state)) {\n                new_state = s->state;\n                s->state = state;\n                cb(s, SSL_CB_ACCEPT_LOOP, 1);\n                s->state = new_state;\n            }\n        }\n        skip = 0;\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 1420,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "int ssl3_get_cert_verify(SSL *s)\n{\n    EVP_PKEY *pkey = NULL;\n    unsigned char *p;\n    int al, ok, ret = 0;\n    long n;\n    int type = 0, i, j;\n    X509 *peer;\n    const EVP_MD *md = NULL;\n    EVP_MD_CTX mctx;\n    EVP_MD_CTX_init(&mctx);\n\n    /*\n     * We should only process a CertificateVerify message if we have received\n     * a Certificate from the client. If so then |s->session->peer| will be non\n     * NULL. In some instances a CertificateVerify message is not required even\n     * if the peer has sent a Certificate (e.g. such as in the case of static\n     * DH). In that case the ClientKeyExchange processing will skip the\n     * CertificateVerify state so we should not arrive here.\n     */\n    if (s->session->peer == NULL) {\n        ret = 1;\n        goto end;\n    }\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_SR_CERT_VRFY_A,\n                                   SSL3_ST_SR_CERT_VRFY_B,\n                                   SSL3_MT_CERTIFICATE_VERIFY,\n                                   SSL3_RT_MAX_PLAIN_LENGTH, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    peer = s->session->peer;\n    pkey = X509_get_pubkey(peer);\n    type = X509_certificate_type(peer, pkey);\n\n    if (!(type & EVP_PKT_SIGN)) {\n        SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n               SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        goto f_err;\n    }\n\n    /* we now have a signature that we need to verify */\n    p = (unsigned char *)s->init_msg;\n    /* Check for broken implementations of GOST ciphersuites */\n    /*\n     * If key is GOST and n is exactly 64, it is bare signature without\n     * length field\n     */\n    if (n == 64 && (pkey->type == NID_id_GostR3410_94 ||\n                    pkey->type == NID_id_GostR3410_2001)) {\n        i = 64;\n    } else {\n        if (SSL_USE_SIGALGS(s)) {\n            int rv = tls12_check_peer_sigalg(&md, s, p, pkey);\n            if (rv == -1) {\n                al = SSL_AD_INTERNAL_ERROR;\n                goto f_err;\n            } else if (rv == 0) {\n                al = SSL_AD_DECODE_ERROR;\n                goto f_err;\n            }\n#ifdef SSL_DEBUG\n            fprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n            p += 2;\n            n -= 2;\n        }\n        n2s(p, i);\n        n -= 2;\n        if (i > n) {\n            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_LENGTH_MISMATCH);\n            al = SSL_AD_DECODE_ERROR;\n            goto f_err;\n        }\n    }\n    j = EVP_PKEY_size(pkey);\n    if ((i > j) || (n > j) || (n <= 0)) {\n        SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_WRONG_SIGNATURE_SIZE);\n        al = SSL_AD_DECODE_ERROR;\n        goto f_err;\n    }\n\n    if (SSL_USE_SIGALGS(s)) {\n        long hdatalen = 0;\n        void *hdata;\n        hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n        if (hdatalen <= 0) {\n            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);\n            al = SSL_AD_INTERNAL_ERROR;\n            goto f_err;\n        }\n#ifdef SSL_DEBUG\n        fprintf(stderr, \"Using TLS 1.2 with client verify alg %s\\n\",\n                EVP_MD_name(md));\n#endif\n        if (!EVP_VerifyInit_ex(&mctx, md, NULL)\n            || !EVP_VerifyUpdate(&mctx, hdata, hdatalen)) {\n            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);\n            al = SSL_AD_INTERNAL_ERROR;\n            goto f_err;\n        }\n\n        if (EVP_VerifyFinal(&mctx, p, i, pkey) <= 0) {\n            al = SSL_AD_DECRYPT_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_SIGNATURE);\n            goto f_err;\n        }\n    } else\n#ifndef OPENSSL_NO_RSA\n    if (pkey->type == EVP_PKEY_RSA) {\n        i = RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,\n                       MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH, p, i,\n                       pkey->pkey.rsa);\n        if (i < 0) {\n            al = SSL_AD_DECRYPT_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_RSA_DECRYPT);\n            goto f_err;\n        }\n        if (i == 0) {\n            al = SSL_AD_DECRYPT_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_RSA_SIGNATURE);\n            goto f_err;\n        }\n    } else\n#endif\n#ifndef OPENSSL_NO_DSA\n    if (pkey->type == EVP_PKEY_DSA) {\n        j = DSA_verify(pkey->save_type,\n                       &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n                       SHA_DIGEST_LENGTH, p, i, pkey->pkey.dsa);\n        if (j <= 0) {\n            /* bad signature */\n            al = SSL_AD_DECRYPT_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_DSA_SIGNATURE);\n            goto f_err;\n        }\n    } else\n#endif\n#ifndef OPENSSL_NO_ECDSA\n    if (pkey->type == EVP_PKEY_EC) {\n        j = ECDSA_verify(pkey->save_type,\n                         &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n                         SHA_DIGEST_LENGTH, p, i, pkey->pkey.ec);\n        if (j <= 0) {\n            /* bad signature */\n            al = SSL_AD_DECRYPT_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_ECDSA_SIGNATURE);\n            goto f_err;\n        }\n    } else\n#endif\n    if (pkey->type == NID_id_GostR3410_94\n            || pkey->type == NID_id_GostR3410_2001) {\n        unsigned char signature[64];\n        int idx;\n        EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey, NULL);\n        EVP_PKEY_verify_init(pctx);\n        if (i != 64) {\n            fprintf(stderr, \"GOST signature length is %d\", i);\n        }\n        for (idx = 0; idx < 64; idx++) {\n            signature[63 - idx] = p[idx];\n        }\n        j = EVP_PKEY_verify(pctx, signature, 64, s->s3->tmp.cert_verify_md,\n                            32);\n        EVP_PKEY_CTX_free(pctx);\n        if (j <= 0) {\n            al = SSL_AD_DECRYPT_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_ECDSA_SIGNATURE);\n            goto f_err;\n        }\n    } else {\n        SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);\n        al = SSL_AD_UNSUPPORTED_CERTIFICATE;\n        goto f_err;\n    }\n\n    ret = 1;\n    if (0) {\n f_err:\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        s->state = SSL_ST_ERR;\n    }\n end:\n    if (s->s3->handshake_buffer) {\n        BIO_free(s->s3->handshake_buffer);\n        s->s3->handshake_buffer = NULL;\n        s->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;\n    }\n    EVP_MD_CTX_cleanup(&mctx);\n    EVP_PKEY_free(pkey);\n    return (ret);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 1421,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "int ssl3_get_client_hello(SSL *s)\n{\n    int i, j, ok, al = SSL_AD_INTERNAL_ERROR, ret = -1;\n    unsigned int cookie_len;\n    long n;\n    unsigned long id;\n    unsigned char *p, *d;\n    SSL_CIPHER *c;\n#ifndef OPENSSL_NO_COMP\n    unsigned char *q;\n    SSL_COMP *comp = NULL;\n#endif\n    STACK_OF(SSL_CIPHER) *ciphers = NULL;\n\n    if (s->state == SSL3_ST_SR_CLNT_HELLO_C && !s->first_packet)\n        goto retry_cert;\n\n    /*\n     * We do this so that we will respond with our native type. If we are\n     * TLSv1 and we get SSLv3, we will respond with TLSv1, This down\n     * switching should be handled by a different method. If we are SSLv3, we\n     * will respond with SSLv3, even if prompted with TLSv1.\n     */\n    if (s->state == SSL3_ST_SR_CLNT_HELLO_A) {\n        s->state = SSL3_ST_SR_CLNT_HELLO_B;\n    }\n    s->first_packet = 1;\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_SR_CLNT_HELLO_B,\n                                   SSL3_ST_SR_CLNT_HELLO_C,\n                                   SSL3_MT_CLIENT_HELLO,\n                                   SSL3_RT_MAX_PLAIN_LENGTH, &ok);\n\n    if (!ok)\n        return ((int)n);\n    s->first_packet = 0;\n    d = p = (unsigned char *)s->init_msg;\n\n    /*\n     * 2 bytes for client version, SSL3_RANDOM_SIZE bytes for random, 1 byte\n     * for session id length\n     */\n    if (n < 2 + SSL3_RANDOM_SIZE + 1) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);\n        goto f_err;\n    }\n\n    /*\n     * use version from inside client hello, not from record header (may\n     * differ: see RFC 2246, Appendix E, second paragraph)\n     */\n    s->client_version = (((int)p[0]) << 8) | (int)p[1];\n    p += 2;\n\n    if (SSL_IS_DTLS(s) ? (s->client_version > s->version &&\n                          s->method->version != DTLS_ANY_VERSION)\n        : (s->client_version < s->version)) {\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_WRONG_VERSION_NUMBER);\n        if ((s->client_version >> 8) == SSL3_VERSION_MAJOR &&\n            !s->enc_write_ctx && !s->write_hash) {\n            /*\n             * similar to ssl3_get_record, send alert using remote version\n             * number\n             */\n            s->version = s->client_version;\n        }\n        al = SSL_AD_PROTOCOL_VERSION;\n        goto f_err;\n    }\n\n    /*\n     * If we require cookies and this ClientHello doesn't contain one, just\n     * return since we do not want to allocate any memory yet. So check\n     * cookie length...\n     */\n    if (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) {\n        unsigned int session_length, cookie_length;\n\n        session_length = *(p + SSL3_RANDOM_SIZE);\n\n        if (p + SSL3_RANDOM_SIZE + session_length + 1 >= d + n) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        cookie_length = *(p + SSL3_RANDOM_SIZE + session_length + 1);\n\n        if (cookie_length == 0)\n            return 1;\n    }\n\n    /* load the client random */\n    memcpy(s->s3->client_random, p, SSL3_RANDOM_SIZE);\n    p += SSL3_RANDOM_SIZE;\n\n    /* get the session-id */\n    j = *(p++);\n\n    if (p + j > d + n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);\n        goto f_err;\n    }\n\n    s->hit = 0;\n    /*\n     * Versions before 0.9.7 always allow clients to resume sessions in\n     * renegotiation. 0.9.7 and later allow this by default, but optionally\n     * ignore resumption requests with flag\n     * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (it's a new flag rather\n     * than a change to default behavior so that applications relying on this\n     * for security won't even compile against older library versions).\n     * 1.0.1 and later also have a function SSL_renegotiate_abbreviated() to\n     * request renegotiation but not a new session (s->new_session remains\n     * unset): for servers, this essentially just means that the\n     * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION setting will be ignored.\n     */\n    if ((s->new_session\n         && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION))) {\n        if (!ssl_get_new_session(s, 1))\n            goto err;\n    } else {\n        i = ssl_get_prev_session(s, p, j, d + n);\n        /*\n         * Only resume if the session's version matches the negotiated\n         * version.\n         * RFC 5246 does not provide much useful advice on resumption\n         * with a different protocol version. It doesn't forbid it but\n         * the sanity of such behaviour would be questionable.\n         * In practice, clients do not accept a version mismatch and\n         * will abort the handshake with an error.\n         */\n        if (i == 1 && s->version == s->session->ssl_version) { /* previous\n                                                                * session */\n            s->hit = 1;\n        } else if (i == -1)\n            goto err;\n        else {                  /* i == 0 */\n\n            if (!ssl_get_new_session(s, 1))\n                goto err;\n        }\n    }\n\n    p += j;\n\n    if (SSL_IS_DTLS(s)) {\n        /* cookie stuff */\n        if (p + 1 > d + n) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        cookie_len = *(p++);\n\n        if (p + cookie_len > d + n) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n\n        /*\n         * The ClientHello may contain a cookie even if the\n         * HelloVerify message has not been sent--make sure that it\n         * does not cause an overflow.\n         */\n        if (cookie_len > sizeof(s->d1->rcvd_cookie)) {\n            /* too much data */\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);\n            goto f_err;\n        }\n\n        /* verify the cookie if appropriate option is set. */\n        if ((SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) && cookie_len > 0) {\n            memcpy(s->d1->rcvd_cookie, p, cookie_len);\n\n            if (s->ctx->app_verify_cookie_cb != NULL) {\n                if (s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,\n                                                 cookie_len) == 0) {\n                    al = SSL_AD_HANDSHAKE_FAILURE;\n                    SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                           SSL_R_COOKIE_MISMATCH);\n                    goto f_err;\n                }\n                /* else cookie verification succeeded */\n            }\n            /* default verification */\n            else if (memcmp(s->d1->rcvd_cookie, s->d1->cookie,\n                            s->d1->cookie_len) != 0) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);\n                goto f_err;\n            }\n            /* Set to -2 so if successful we return 2 */\n            ret = -2;\n        }\n\n        p += cookie_len;\n        if (s->method->version == DTLS_ANY_VERSION) {\n            /* Select version to use */\n            if (s->client_version <= DTLS1_2_VERSION &&\n                !(s->options & SSL_OP_NO_DTLSv1_2)) {\n                s->version = DTLS1_2_VERSION;\n                s->method = DTLSv1_2_server_method();\n            } else if (tls1_suiteb(s)) {\n                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                       SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\n                s->version = s->client_version;\n                al = SSL_AD_PROTOCOL_VERSION;\n                goto f_err;\n            } else if (s->client_version <= DTLS1_VERSION &&\n                       !(s->options & SSL_OP_NO_DTLSv1)) {\n                s->version = DTLS1_VERSION;\n                s->method = DTLSv1_server_method();\n            } else {\n                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                       SSL_R_WRONG_VERSION_NUMBER);\n                s->version = s->client_version;\n                al = SSL_AD_PROTOCOL_VERSION;\n                goto f_err;\n            }\n            s->session->ssl_version = s->version;\n        }\n    }\n\n    if (p + 2 > d + n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);\n        goto f_err;\n    }\n    n2s(p, i);\n\n    if (i == 0) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_CIPHERS_SPECIFIED);\n        goto f_err;\n    }\n\n    /* i bytes of cipher data + 1 byte for compression length later */\n    if ((p + i + 1) > (d + n)) {\n        /* not enough data */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if (ssl_bytes_to_cipher_list(s, p, i, &(ciphers)) == NULL) {\n        goto err;\n    }\n    p += i;\n\n    /* If it is a hit, check that the cipher is in the list */\n    if (s->hit) {\n        j = 0;\n        id = s->session->cipher->id;\n\n#ifdef CIPHER_DEBUG\n        fprintf(stderr, \"client sent %d ciphers\\n\",\n                sk_SSL_CIPHER_num(ciphers));\n#endif\n        for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {\n            c = sk_SSL_CIPHER_value(ciphers, i);\n#ifdef CIPHER_DEBUG\n            fprintf(stderr, \"client [%2d of %2d]:%s\\n\",\n                    i, sk_SSL_CIPHER_num(ciphers), SSL_CIPHER_get_name(c));\n#endif\n            if (c->id == id) {\n                j = 1;\n                break;\n            }\n        }\n        /*\n         * Disabled because it can be used in a ciphersuite downgrade attack:\n         * CVE-2010-4180.\n         */\n#if 0\n        if (j == 0 && (s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG)\n            && (sk_SSL_CIPHER_num(ciphers) == 1)) {\n            /*\n             * Special case as client bug workaround: the previously used\n             * cipher may not be in the current list, the client instead\n             * might be trying to continue using a cipher that before wasn't\n             * chosen due to server preferences.  We'll have to reject the\n             * connection if the cipher is not enabled, though.\n             */\n            c = sk_SSL_CIPHER_value(ciphers, 0);\n            if (sk_SSL_CIPHER_find(SSL_get_ciphers(s), c) >= 0) {\n                s->session->cipher = c;\n                j = 1;\n            }\n        }\n#endif\n        if (j == 0) {\n            /*\n             * we need to have the cipher in the cipher list if we are asked\n             * to reuse it\n             */\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                   SSL_R_REQUIRED_CIPHER_MISSING);\n            goto f_err;\n        }\n    }\n\n    /* compression */\n    i = *(p++);\n    if ((p + i) > (d + n)) {\n        /* not enough data */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n#ifndef OPENSSL_NO_COMP\n    q = p;\n#endif\n    for (j = 0; j < i; j++) {\n        if (p[j] == 0)\n            break;\n    }\n\n    p += i;\n    if (j >= i) {\n        /* no compress */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_COMPRESSION_SPECIFIED);\n        goto f_err;\n    }\n#ifndef OPENSSL_NO_TLSEXT\n    /* TLS extensions */\n    if (s->version >= SSL3_VERSION) {\n        if (!ssl_parse_clienthello_tlsext(s, &p, d, n)) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_PARSE_TLSEXT);\n            goto err;\n        }\n    }\n\n    /*\n     * Check if we want to use external pre-shared secret for this handshake\n     * for not reused session only. We need to generate server_random before\n     * calling tls_session_secret_cb in order to allow SessionTicket\n     * processing to use it in key derivation.\n     */\n    {\n        unsigned char *pos;\n        pos = s->s3->server_random;\n        if (ssl_fill_hello_random(s, 1, pos, SSL3_RANDOM_SIZE) <= 0) {\n            goto f_err;\n        }\n    }\n\n    if (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb) {\n        SSL_CIPHER *pref_cipher = NULL;\n\n        s->session->master_key_length = sizeof(s->session->master_key);\n        if (s->tls_session_secret_cb(s, s->session->master_key,\n                                     &s->session->master_key_length, ciphers,\n                                     &pref_cipher,\n                                     s->tls_session_secret_cb_arg)) {\n            s->hit = 1;\n            s->session->ciphers = ciphers;\n            s->session->verify_result = X509_V_OK;\n\n            ciphers = NULL;\n\n            /* check if some cipher was preferred by call back */\n            pref_cipher =\n                pref_cipher ? pref_cipher : ssl3_choose_cipher(s,\n                                                               s->\n                                                               session->ciphers,\n                                                               SSL_get_ciphers\n                                                               (s));\n            if (pref_cipher == NULL) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);\n                goto f_err;\n            }\n\n            s->session->cipher = pref_cipher;\n\n            if (s->cipher_list)\n                sk_SSL_CIPHER_free(s->cipher_list);\n\n            if (s->cipher_list_by_id)\n                sk_SSL_CIPHER_free(s->cipher_list_by_id);\n\n            s->cipher_list = sk_SSL_CIPHER_dup(s->session->ciphers);\n            s->cipher_list_by_id = sk_SSL_CIPHER_dup(s->session->ciphers);\n        }\n    }\n#endif\n\n    /*\n     * Worst case, we will use the NULL compression, but if we have other\n     * options, we will now look for them.  We have i-1 compression\n     * algorithms from the client, starting at q.\n     */\n    s->s3->tmp.new_compression = NULL;\n#ifndef OPENSSL_NO_COMP\n    /* This only happens if we have a cache hit */\n    if (s->session->compress_meth != 0) {\n        int m, comp_id = s->session->compress_meth;\n        /* Perform sanity checks on resumed compression algorithm */\n        /* Can't disable compression */\n        if (s->options & SSL_OP_NO_COMPRESSION) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                   SSL_R_INCONSISTENT_COMPRESSION);\n            goto f_err;\n        }\n        /* Look for resumed compression method */\n        for (m = 0; m < sk_SSL_COMP_num(s->ctx->comp_methods); m++) {\n            comp = sk_SSL_COMP_value(s->ctx->comp_methods, m);\n            if (comp_id == comp->id) {\n                s->s3->tmp.new_compression = comp;\n                break;\n            }\n        }\n        if (s->s3->tmp.new_compression == NULL) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                   SSL_R_INVALID_COMPRESSION_ALGORITHM);\n            goto f_err;\n        }\n        /* Look for resumed method in compression list */\n        for (m = 0; m < i; m++) {\n            if (q[m] == comp_id)\n                break;\n        }\n        if (m >= i) {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                   SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING);\n            goto f_err;\n        }\n    } else if (s->hit)\n        comp = NULL;\n    else if (!(s->options & SSL_OP_NO_COMPRESSION) && s->ctx->comp_methods) {\n        /* See if we have a match */\n        int m, nn, o, v, done = 0;\n\n        nn = sk_SSL_COMP_num(s->ctx->comp_methods);\n        for (m = 0; m < nn; m++) {\n            comp = sk_SSL_COMP_value(s->ctx->comp_methods, m);\n            v = comp->id;\n            for (o = 0; o < i; o++) {\n                if (v == q[o]) {\n                    done = 1;\n                    break;\n                }\n            }\n            if (done)\n                break;\n        }\n        if (done)\n            s->s3->tmp.new_compression = comp;\n        else\n            comp = NULL;\n    }\n#else\n    /*\n     * If compression is disabled we'd better not try to resume a session\n     * using compression.\n     */\n    if (s->session->compress_meth != 0) {\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_INCONSISTENT_COMPRESSION);\n        goto f_err;\n    }\n#endif\n\n    /*\n     * Given s->session->ciphers and SSL_get_ciphers, we must pick a cipher\n     */\n\n    if (!s->hit) {\n#ifdef OPENSSL_NO_COMP\n        s->session->compress_meth = 0;\n#else\n        s->session->compress_meth = (comp == NULL) ? 0 : comp->id;\n#endif\n        if (s->session->ciphers != NULL)\n            sk_SSL_CIPHER_free(s->session->ciphers);\n        s->session->ciphers = ciphers;\n        if (ciphers == NULL) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n            goto f_err;\n        }\n        ciphers = NULL;\n        if (!tls1_set_server_sigalgs(s)) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n            goto err;\n        }\n        /* Let cert callback update server certificates if required */\n retry_cert:\n        if (s->cert->cert_cb) {\n            int rv = s->cert->cert_cb(s, s->cert->cert_cb_arg);\n            if (rv == 0) {\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CERT_CB_ERROR);\n                goto f_err;\n            }\n            if (rv < 0) {\n                s->rwstate = SSL_X509_LOOKUP;\n                return -1;\n            }\n            s->rwstate = SSL_NOTHING;\n        }\n        c = ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));\n\n        if (c == NULL) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);\n            goto f_err;\n        }\n        s->s3->tmp.new_cipher = c;\n    } else {\n        /* Session-id reuse */\n#ifdef REUSE_CIPHER_BUG\n        STACK_OF(SSL_CIPHER) *sk;\n        SSL_CIPHER *nc = NULL;\n        SSL_CIPHER *ec = NULL;\n\n        if (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG) {\n            sk = s->session->ciphers;\n            for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {\n                c = sk_SSL_CIPHER_value(sk, i);\n                if (c->algorithm_enc & SSL_eNULL)\n                    nc = c;\n                if (SSL_C_IS_EXPORT(c))\n                    ec = c;\n            }\n            if (nc != NULL)\n                s->s3->tmp.new_cipher = nc;\n            else if (ec != NULL)\n                s->s3->tmp.new_cipher = ec;\n            else\n                s->s3->tmp.new_cipher = s->session->cipher;\n        } else\n#endif\n            s->s3->tmp.new_cipher = s->session->cipher;\n    }\n\n    if (!SSL_USE_SIGALGS(s) || !(s->verify_mode & SSL_VERIFY_PEER)) {\n        if (!ssl3_digest_cached_records(s))\n            goto f_err;\n    }\n\n    /*-\n    * we now have the following setup.\n     * client_random\n     * cipher_list          - our prefered list of ciphers\n     * ciphers              - the clients prefered list of ciphers\n     * compression          - basically ignored right now\n     * ssl version is set   - sslv3\n     * s->session           - The ssl session has been setup.\n     * s->hit               - session reuse flag\n     * s->tmp.new_cipher    - the new cipher to use.\n     */\n\n    /* Handles TLS extensions that we couldn't check earlier */\n    if (s->version >= SSL3_VERSION) {\n        if (ssl_check_clienthello_tlsext_late(s) <= 0) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n            goto err;\n        }\n    }\n\n    if (ret < 0)\n        ret = -ret;\n    if (0) {\n f_err:\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n        s->state = SSL_ST_ERR;\n    }\n\n    if (ciphers != NULL)\n        sk_SSL_CIPHER_free(ciphers);\n    return ret < 0 ? -1 : ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 1422,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "int ssl3_send_certificate_request(SSL *s)\n{\n    unsigned char *p, *d;\n    int i, j, nl, off, n;\n    STACK_OF(X509_NAME) *sk = NULL;\n    X509_NAME *name;\n    BUF_MEM *buf;\n\n    if (s->state == SSL3_ST_SW_CERT_REQ_A) {\n        buf = s->init_buf;\n\n        d = p = ssl_handshake_start(s);\n\n        /* get the list of acceptable cert types */\n        p++;\n        n = ssl3_get_req_cert_type(s, p);\n        d[0] = n;\n        p += n;\n        n++;\n\n        if (SSL_USE_SIGALGS(s)) {\n            const unsigned char *psigs;\n            nl = tls12_get_psigalgs(s, &psigs);\n            s2n(nl, p);\n            memcpy(p, psigs, nl);\n            p += nl;\n            n += nl + 2;\n        }\n\n        off = n;\n        p += 2;\n        n += 2;\n\n        sk = SSL_get_client_CA_list(s);\n        nl = 0;\n        if (sk != NULL) {\n            for (i = 0; i < sk_X509_NAME_num(sk); i++) {\n                name = sk_X509_NAME_value(sk, i);\n                j = i2d_X509_NAME(name, NULL);\n                if (!BUF_MEM_grow_clean\n                    (buf, SSL_HM_HEADER_LENGTH(s) + n + j + 2)) {\n                    SSLerr(SSL_F_SSL3_SEND_CERTIFICATE_REQUEST,\n                           ERR_R_BUF_LIB);\n                    goto err;\n                }\n                p = ssl_handshake_start(s) + n;\n                if (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG)) {\n                    s2n(j, p);\n                    i2d_X509_NAME(name, &p);\n                    n += 2 + j;\n                    nl += 2 + j;\n                } else {\n                    d = p;\n                    i2d_X509_NAME(name, &p);\n                    j -= 2;\n                    s2n(j, d);\n                    j += 2;\n                    n += j;\n                    nl += j;\n                }\n            }\n        }\n        /* else no CA names */\n        p = ssl_handshake_start(s) + off;\n        s2n(nl, p);\n\n        ssl_set_handshake_header(s, SSL3_MT_CERTIFICATE_REQUEST, n);\n\n#ifdef NETSCAPE_HANG_BUG\n        if (!SSL_IS_DTLS(s)) {\n            if (!BUF_MEM_grow_clean(buf, s->init_num + 4)) {\n                SSLerr(SSL_F_SSL3_SEND_CERTIFICATE_REQUEST, ERR_R_BUF_LIB);\n                goto err;\n            }\n            p = (unsigned char *)s->init_buf->data + s->init_num;\n            /* do the header */\n            *(p++) = SSL3_MT_SERVER_DONE;\n            *(p++) = 0;\n            *(p++) = 0;\n            *(p++) = 0;\n            s->init_num += 4;\n        }\n#endif\n\n        s->state = SSL3_ST_SW_CERT_REQ_B;\n    }\n\n    /* SSL3_ST_SW_CERT_REQ_B */\n    return ssl_do_write(s);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 1424,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "user_local_update_from_pwent (User          *user,\n                              struct passwd *pwent)\n{\n#ifdef HAVE_SHADOW_H\n        struct spwd *spent;\n#endif\n        gchar *real_name;\n        gboolean changed;\n        const gchar *passwd;\n        gboolean locked;\n        PasswordMode mode;\n\n        g_object_freeze_notify (G_OBJECT (user));\n\n        changed = FALSE;\n\n        if (pwent->pw_gecos && pwent->pw_gecos[0] != '\\0') {\n                gchar *first_comma = NULL;\n                gchar *valid_utf8_name = NULL;\n\n                if (g_utf8_validate (pwent->pw_gecos, -1, NULL)) {\n                        valid_utf8_name = pwent->pw_gecos;\n                        first_comma = g_utf8_strchr (valid_utf8_name, -1, ',');\n                }\n                else {\n                        g_warning (\"User %s has invalid UTF-8 in GECOS field. \"\n                                   \"It would be a good thing to check /etc/passwd.\",\n                                   pwent->pw_name ? pwent->pw_name : \"\");\n                }\n\n                if (first_comma) {\n                        real_name = g_strndup (valid_utf8_name,\n                                                  (first_comma - valid_utf8_name));\n                }\n                else if (valid_utf8_name) {\n                        real_name = g_strdup (valid_utf8_name);\n                }\n                else {\n                        real_name = NULL;\n                }\n\n                if (real_name && real_name[0] == '\\0') {\n                        g_free (real_name);\n                        real_name = NULL;\n                }\n        }\n        else {\n                real_name = NULL;\n        }\n        if (g_strcmp0 (real_name, user->real_name) != 0) {\n                g_free (user->real_name);\n                user->real_name = real_name;\n                changed = TRUE;\n                g_object_notify (G_OBJECT (user), \"real-name\");\n        }\n        else {\n                g_free (real_name);\n        }\n\n        /* UID */\n        if (pwent->pw_uid != user->uid) {\n                user->uid = pwent->pw_uid;\n                changed = TRUE;\n                g_object_notify (G_OBJECT (user), \"uid\");\n        }\n\n        /* GID */\n        user->gid = pwent->pw_gid;\n\n        user->account_type = account_type_from_pwent (pwent);\n\n        /* Username */\n        if (g_strcmp0 (user->user_name, pwent->pw_name) != 0) {\n                g_free (user->user_name);\n                user->user_name = g_strdup (pwent->pw_name);\n                changed = TRUE;\n                g_object_notify (G_OBJECT (user), \"user-name\");\n        }\n\n        /* Home Directory */\n        if (g_strcmp0 (user->home_dir, pwent->pw_dir) != 0) {\n                g_free (user->home_dir);\n                user->home_dir = g_strdup (pwent->pw_dir);\n                g_free (user->default_icon_file);\n                user->default_icon_file = g_build_filename (user->home_dir, \".face\", NULL);\n                changed = TRUE;\n                g_object_notify (G_OBJECT (user), \"home-directory\");\n        }\n\n        /* Shell */\n        if (g_strcmp0 (user->shell, pwent->pw_shell) != 0) {\n                g_free (user->shell);\n                user->shell = g_strdup (pwent->pw_shell);\n                changed = TRUE;\n                g_object_notify (G_OBJECT (user), \"shell\");\n        }\n\n        passwd = pwent->pw_passwd;\n#ifdef HAVE_SHADOW_H\n        spent = getspnam (pwent->pw_name);\n        if (spent)\n                passwd = spent->sp_pwdp;\n#endif\n\n        if (passwd && passwd[0] == '!') {\n                locked = TRUE;\n        }\n        else {\n                locked = FALSE;\n        }\n\n        if (user->locked != locked) {\n                user->locked = locked;\n                changed = TRUE;\n                g_object_notify (G_OBJECT (user), \"locked\");\n        }\n\n        if (passwd && passwd[0] != 0) {\n                mode = PASSWORD_MODE_REGULAR;\n        }\n        else {\n                mode = PASSWORD_MODE_NONE;\n        }\n\n#ifdef HAVE_SHADOW_H\n        if (spent) {\n                if (spent->sp_lstchg == 0) {\n                        mode = PASSWORD_MODE_SET_AT_LOGIN;\n                }\n        }\n#endif\n\n        if (user->password_mode != mode) {\n                user->password_mode = mode;\n                changed = TRUE;\n                g_object_notify (G_OBJECT (user), \"password-mode\");\n        }\n\n        user->system_account = daemon_local_user_is_excluded (user->daemon,\n                                                              user->user_name,\n                                                              pwent->pw_shell);\n\n        g_object_thaw_notify (G_OBJECT (user));\n\n        if (changed)\n                accounts_user_emit_changed (ACCOUNTS_USER (user));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 3393,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "spawn_with_login_uid (GDBusMethodInvocation  *context,\n                      const gchar            *argv[],\n                      GError                **error)\n{\n        GError *local_error;\n        gchar loginuid[20];\n        gchar *std_err;\n        gint status;\n\n        get_caller_loginuid (context, loginuid, 20);\n\n        local_error = NULL;\n        std_err = NULL;\n\n        if (!g_spawn_sync (NULL, (gchar**)argv, NULL, 0, setup_loginuid, loginuid, NULL, &std_err, &status, &local_error)) {\n                g_propagate_error (error, local_error);\n                g_free (std_err);\n                return FALSE;\n        }\n\n        if (WEXITSTATUS (status) != 0) {\n                g_set_error (error,\n                             G_SPAWN_ERROR,\n                             G_SPAWN_ERROR_FAILED,\n                             \"%s returned an error (%d): %s\",\n                             argv[0], WEXITSTATUS(status), std_err);\n                g_free (std_err);\n                return FALSE;\n        }\n\n        g_free (std_err);\n\n        return TRUE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 3398,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "sys_log (GDBusMethodInvocation *context,\n         const gchar           *format,\n                                ...)\n{\n        va_list args;\n        gchar *msg;\n\n        va_start (args, format);\n        msg = g_strdup_vprintf (format, args);\n        va_end (args);\n\n        if (context) {\n                PolkitSubject *subject;\n                gchar *cmdline;\n                gchar *id;\n                gint pid = 0;\n                gint uid = 0;\n                gchar *tmp;\n\n                subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));\n                id = polkit_subject_to_string (subject);\n                cmdline = _polkit_subject_get_cmdline (subject, &pid, &uid);\n\n                if (cmdline == NULL) {\n                        tmp = g_strdup_printf (\"request by %s: %s\", id, msg);\n                }\n                else {\n                        tmp = g_strdup_printf (\"request by %s [%s pid:%d uid:%d]: %s\", id, cmdline, pid, uid, msg);\n                }\n\n                g_free (msg);\n                msg = tmp;\n\n                g_free (id);\n                g_free (cmdline);\n                g_object_unref (subject);\n        }\n\n        syslog (LOG_NOTICE, \"%s\", msg);\n\n        g_free (msg);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 3399,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "int main(int argc, char **argv, char **envp)\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"b:h:k:p:q:w:z:xv\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\ttmate_settings->bind_addr = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\ttmate_settings->tmate_host = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\ttmate_settings->keys_dir = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttmate_settings->ssh_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\ttmate_settings->ssh_port_advertized = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttmate_settings->websocket_hostname = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\ttmate_settings->websocket_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\ttmate_settings->use_proxy_protocol = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\ttmate_settings->log_level++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tinit_logging(tmate_settings->log_level);\n\n\tsetup_locale();\n\n\tif (!tmate_settings->tmate_host)\n\t\ttmate_settings->tmate_host = get_full_hostname();\n\n\tcmdline = *argv;\n\tcmdline_end = *envp;\n\n\ttmate_preload_trace_lib();\n\ttmate_catch_sigsegv();\n\ttmate_init_rand();\n\n\tif ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0703) < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/jail\", 0700)     < 0 && errno != EEXIST))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\t/* The websocket server needs to access the /session dir to rename sockets */\n\tif ((chmod(TMATE_WORKDIR, 0701)             < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/sessions\", 0703) < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/jail\", 0700)     < 0))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\ttmate_ssh_server_main(tmate_session,\n\t\t\t      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 54,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {\n  auto it = idInfoMap.find(id);\n  if (it == idInfoMap.end()) {\n    STFATAL << \" Tried to read from an id that no longer exists\";\n  }\n  return it->second;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 537,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\n\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 599,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 765,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "int main(int argc, char **argv, char **envp)\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"b:h:k:p:q:w:z:xv\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\ttmate_settings->bind_addr = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\ttmate_settings->tmate_host = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\ttmate_settings->keys_dir = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttmate_settings->ssh_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\ttmate_settings->ssh_port_advertized = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttmate_settings->websocket_hostname = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\ttmate_settings->websocket_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\ttmate_settings->use_proxy_protocol = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\ttmate_settings->log_level++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tinit_logging(tmate_settings->log_level);\n\n\tsetup_locale();\n\n\tif (!tmate_settings->tmate_host)\n\t\ttmate_settings->tmate_host = get_full_hostname();\n\n\tcmdline = *argv;\n\tcmdline_end = *envp;\n\n\ttmate_preload_trace_lib();\n\ttmate_catch_sigsegv();\n\ttmate_init_rand();\n\n\tif ((mkdir(TMATE_WORKDIR, 0700)             < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0700) < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/jail\", 0700)     < 0 && errno != EEXIST))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\tif ((chmod(TMATE_WORKDIR, 0700)             < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/sessions\", 0700) < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/jail\", 0700)     < 0))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\tif (check_owned_directory_mode(TMATE_WORKDIR, 0700) ||\n\t    check_owned_directory_mode(TMATE_WORKDIR \"/sessions\", 0700) ||\n\t    check_owned_directory_mode(TMATE_WORKDIR \"/jail\", 0700))\n\t\ttmate_fatal(TMATE_WORKDIR \" and subdirectories has incorrect ownership/mode. \"\n\t\t\t    \"Try deleting \" TMATE_WORKDIR \" and try again\");\n\n\ttmate_ssh_server_main(tmate_session,\n\t\t\t      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 55,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n\n  // Hash all the settings that affect whether the server will allow/accept\n  // the client connection. This ensures that the client is always validated against\n  // the correct settings, even if session resumption across different listeners\n  // is enabled.\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  rc = EVP_DigestUpdate(md.get(), &verify_trusted_ca_, sizeof(verify_trusted_ca_));\n  RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n  if (config_ != nullptr) {\n    for (const auto& matcher : config_->subjectAltNameMatchers()) {\n      size_t hash = MessageUtil::hash(matcher);\n      rc = EVP_DigestUpdate(md.get(), &hash, sizeof(hash));\n      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    }\n\n    const std::string& crl = config_->certificateRevocationList();\n    if (!crl.empty()) {\n      rc = EVP_DigestUpdate(md.get(), crl.data(), crl.length());\n      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    }\n\n    bool allow_expired = config_->allowExpiredCertificate();\n    rc = EVP_DigestUpdate(md.get(), &allow_expired, sizeof(allow_expired));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n    auto trust_chain_verification = config_->trustChainVerification();\n    rc = EVP_DigestUpdate(md.get(), &trust_chain_verification, sizeof(trust_chain_verification));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n    auto only_leaf_crl = config_->onlyVerifyLeafCertificateCrl();\n    rc = EVP_DigestUpdate(md.get(), &only_leaf_crl, sizeof(only_leaf_crl));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 203,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tint err = 0;\n\tunsigned int saved_f_flags;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_format_t format;\n\tunsigned long width;\n\tsize_t size;\n\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tif (substream != NULL) {\n\t\truntime = substream->runtime;\n\t\tif (atomic_read(&substream->mmap_count))\n\t\t\tgoto __direct;\n\t\tatomic_inc(&runtime->oss.rw_ref);\n\t\tif (mutex_lock_interruptible(&runtime->oss.params_lock)) {\n\t\t\tatomic_dec(&runtime->oss.rw_ref);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\terr = snd_pcm_oss_make_ready_locked(substream);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t\tformat = snd_pcm_oss_format_from(runtime->oss.format);\n\t\twidth = snd_pcm_format_physical_width(format);\n\t\tif (runtime->oss.buffer_used > 0) {\n#ifdef OSS_DEBUG\n\t\t\tpcm_dbg(substream->pcm, \"sync: buffer_used\\n\");\n#endif\n\t\t\tsize = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / width;\n\t\t\tsnd_pcm_format_set_silence(format,\n\t\t\t\t\t\t   runtime->oss.buffer + runtime->oss.buffer_used,\n\t\t\t\t\t\t   size);\n\t\t\terr = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes);\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\t\t} else if (runtime->oss.period_ptr > 0) {\n#ifdef OSS_DEBUG\n\t\t\tpcm_dbg(substream->pcm, \"sync: period_ptr\\n\");\n#endif\n\t\t\tsize = runtime->oss.period_bytes - runtime->oss.period_ptr;\n\t\t\tsnd_pcm_format_set_silence(format,\n\t\t\t\t\t\t   runtime->oss.buffer,\n\t\t\t\t\t\t   size * 8 / width);\n\t\t\terr = snd_pcm_oss_sync1(substream, size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\t/*\n\t\t * The ALSA's period might be a bit large than OSS one.\n\t\t * Fill the remain portion of ALSA period with zeros.\n\t\t */\n\t\tsize = runtime->control->appl_ptr % runtime->period_size;\n\t\tif (size > 0) {\n\t\t\tsize = runtime->period_size - size;\n\t\t\tif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED)\n\t\t\t\tsnd_pcm_lib_write(substream, NULL, size);\n\t\t\telse if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n\t\t\t\tsnd_pcm_lib_writev(substream, NULL, size);\n\t\t}\nunlock:\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\tatomic_dec(&runtime->oss.rw_ref);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t/*\n\t\t * finish sync: drain the buffer\n\t\t */\n\t      __direct:\n\t\tsaved_f_flags = substream->f_flags;\n\t\tsubstream->f_flags &= ~O_NONBLOCK;\n\t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\n\t\tsubstream->f_flags = saved_f_flags;\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmutex_lock(&runtime->oss.params_lock);\n\t\truntime->oss.prepare = 1;\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t}\n\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n\tif (substream != NULL) {\n\t\terr = snd_pcm_oss_make_ready(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\truntime = substream->runtime;\n\t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmutex_lock(&runtime->oss.params_lock);\n\t\truntime->oss.buffer_used = 0;\n\t\truntime->oss.prepare = 1;\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 334,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {\n  lock_guard<recursive_mutex> guard(routerMutex);\n  auto it = idInfoMap.find(id);\n  if (it == idInfoMap.end()) {\n    STFATAL << \" Tried to read from an id that no longer exists\";\n  }\n  return it->second;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 538,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "set<int> PipeSocketHandler::listen(const SocketEndpoint& endpoint) {\n  lock_guard<std::recursive_mutex> guard(globalMutex);\n\n  string pipePath = endpoint.name();\n  if (pipeServerSockets.find(pipePath) != pipeServerSockets.end()) {\n    throw runtime_error(\"Tried to listen twice on the same path\");\n  }\n\n  sockaddr_un local;\n\n  int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n  FATAL_FAIL(fd);\n  initServerSocket(fd);\n  local.sun_family = AF_UNIX; /* local is declared before socket() ^ */\n  strncpy(local.sun_path, pipePath.c_str(), sizeof(local.sun_path));\n  unlink(local.sun_path);\n\n  FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un)));\n  ::listen(fd, 5);\n#ifndef WIN32\n  FATAL_FAIL(::chmod(local.sun_path, S_IRUSR | S_IWUSR | S_IXUSR));\n#endif\n\n  pipeServerSockets[pipePath] = set<int>({fd});\n  return pipeServerSockets[pipePath];\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 540,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((next_offset + req_size) > MAX_ACTIONS_BUFSIZE) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\n\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 600,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  },
  {
    "CWE_ID": [
      "CWE-362"
    ],
    "code": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    if (n < 6) {\n        /* need at least ticket_lifetime_hint + ticket length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    p = d = (unsigned char *)s->init_msg;\n\n    if (s->session->session_id_length > 0) {\n        int i = s->session_ctx->session_cache_mode;\n        SSL_SESSION *new_sess;\n        /*\n         * We reused an existing session, so we need to replace it with a new\n         * one\n         */\n        if (i & SSL_SESS_CACHE_CLIENT) {\n            /*\n             * Remove the old session from the cache\n             */\n            if (i & SSL_SESS_CACHE_NO_INTERNAL_STORE) {\n                if (s->session_ctx->remove_session_cb != NULL)\n                    s->session_ctx->remove_session_cb(s->session_ctx,\n                                                      s->session);\n            } else {\n                /* We carry on if this fails */\n                SSL_CTX_remove_session(s->session_ctx, s->session);\n            }\n        }\n\n        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        SSL_SESSION_free(s->session);\n        s->session = new_sess;\n    }\n\n    n2l(p, s->session->tlsext_tick_lifetime_hint);\n    n2s(p, ticklen);\n    /* ticket_lifetime_hint + ticket_length + ticket */\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if (s->session->tlsext_tick) {\n        OPENSSL_free(s->session->tlsext_tick);\n        s->session->tlsext_ticklen = 0;\n    }\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    /*\n     * There are two ways to detect a resumed ticket session. One is to set\n     * an appropriate session ID and then the server must return a match in\n     * ServerHello. This allows the normal client session ID matching to work\n     * and we know much earlier that the ticket has been accepted. The\n     * other way is to set zero length session ID when the ticket is\n     * presented and rely on the handshake to determine session resumption.\n     * We choose the former approach because this fits in with assumptions\n     * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is\n     * SHA256 is disabled) hash of the ticket.\n     */\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n# ifndef OPENSSL_NO_SHA256\n               EVP_sha256(), NULL);\n# else\n               EVP_sha1(), NULL);\n# endif\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 808,
    "RELATED_CWE": [
      "CWE-763",
      "CWE-404",
      "CWE-457"
    ]
  }
]