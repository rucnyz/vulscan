[
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\n\n\nstatic void f_yyxuhqex(int count)\n{\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nstatic void f_giwcshmz()\n{\n    int count;\n    void (*funcPtr) (int) = f_yyxuhqex;\n    \n    count = -1;\n    \n    count = 20;\n    funcPtr(count);\n}\n\n\nstatic void f_vejqlrvv(int count)\n{\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        \n        if (count > 0 && count <= 20)\n        {\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nstatic void f_uxdhgcoe()\n{\n    int count;\n    void (*funcPtr) (int) = f_vejqlrvv;\n    \n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    funcPtr(count);\n}\n\nvoid f_bewaqslo()\n{\n    f_giwcshmz();\n    f_uxdhgcoe();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bewaqslo();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401580,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_44.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\nstatic void f_dclfgdgw(int count)\n{\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid f_bfsesloc()\n{\n    int count;\n    \n    void (*funcPtr) (int) = f_dclfgdgw;\n    \n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(count);\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bfsesloc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401581,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_44.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\n\n\nstatic int f_lzmegydi(int count)\n{\n    \n    count = 20;\n    return count;\n}\n\nstatic void f_dzihrcwb()\n{\n    int count;\n    \n    count = -1;\n    count = f_lzmegydi(count);\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic int f_mjhutqwr(int count)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    return count;\n}\n\nstatic void f_ychydflb()\n{\n    int count;\n    \n    count = -1;\n    count = f_mjhutqwr(count);\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        \n        if (count > 0 && count <= 20)\n        {\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_iusbrsnd()\n{\n    f_ychydflb();\n    f_dzihrcwb();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iusbrsnd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401582,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_42.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\nstatic int f_qukdehfr(int count)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    return count;\n}\n\nvoid f_tfqtpcbn()\n{\n    int count;\n    \n    count = -1;\n    count = f_qukdehfr(count);\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tfqtpcbn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401583,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_42.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_nksomqoz()\n{\n    int count;\n    int &countRef = count;\n    \n    count = -1;\n    \n    count = 20;\n    {\n        int count = countRef;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_.txt\";\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            \n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n                {\n                    exit(1);\n                }\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_mvhszuke()\n{\n    int count;\n    int &countRef = count;\n    \n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        int count = countRef;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_.txt\";\n            \n            if (count > 0 && count <= 20)\n            {\n                pFile = fopen(filename, \"w+\");\n                if (pFile == NULL)\n                {\n                    exit(1);\n                }\n                for (i = 0; i < (size_t)count; i++)\n                {\n                    if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n                }\n                if (pFile)\n                {\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n}\n\nvoid f_mwaddmeb()\n{\n    f_nksomqoz();\n    f_mvhszuke();\n}\n\n\n} \n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mwaddmeb();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401584,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_33.cpp",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\nnamespace _A_namespace\n{\n\n\nvoid f_jrytasnb()\n{\n    int count;\n    int &countRef = count;\n    \n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        int count = countRef;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_.txt\";\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            \n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n                {\n                    exit(1);\n                }\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n} \n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jrytasnb();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401585,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_33.cpp",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\n\n\nstatic void f_csiejnbt(int count)\n{\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nstatic void f_wnihahbv()\n{\n    int count;\n    \n    count = -1;\n    \n    count = 20;\n    f_csiejnbt(count);\n}\n\n\nstatic void f_sgsxvwan(int count)\n{\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        \n        if (count > 0 && count <= 20)\n        {\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nstatic void f_ehnncqpf()\n{\n    int count;\n    \n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    f_sgsxvwan(count);\n}\n\nvoid f_iovpblww()\n{\n    f_ehnncqpf();\n    f_wnihahbv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iovpblww();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401586,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_41.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\nstatic void f_hzlbrixn(int count)\n{\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid f_ftrmztmd()\n{\n    int count;\n    \n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    f_hzlbrixn(count);\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ftrmztmd();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401587,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_41.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\n\n\nstatic void f_sbddlbej()\n{\n    int count;\n    \n    count = -1;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    goto sink;\nsink:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        \n        if (count > 0 && count <= 20)\n        {\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_qamgoeex()\n{\n    int count;\n    \n    count = -1;\n    goto source;\nsource:\n    \n    count = 20;\n    goto sink;\nsink:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid f_sfdkalie()\n{\n    f_sbddlbej();\n    f_qamgoeex();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sfdkalie();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401588,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_18.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\nvoid f_rtswklyi()\n{\n    int count;\n    \n    count = -1;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    goto sink;\nsink:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rtswklyi();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401589,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_18.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\n\n\nstatic void f_rbewqbed()\n{\n    int count;\n    \n    count = -1;\n    \n    count = 20;\n    {\n        int countCopy = count;\n        int count = countCopy;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_.txt\";\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            \n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n                {\n                    exit(1);\n                }\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_quknyhim()\n{\n    int count;\n    \n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        int countCopy = count;\n        int count = countCopy;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_.txt\";\n            \n            if (count > 0 && count <= 20)\n            {\n                pFile = fopen(filename, \"w+\");\n                if (pFile == NULL)\n                {\n                    exit(1);\n                }\n                for (i = 0; i < (size_t)count; i++)\n                {\n                    if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n                }\n                if (pFile)\n                {\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n}\n\nvoid f_inljomcq()\n{\n    f_rbewqbed();\n    f_quknyhim();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_inljomcq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401590,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_31.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\nvoid f_uaanuhtn()\n{\n    int count;\n    \n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        int countCopy = count;\n        int count = countCopy;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_.txt\";\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            \n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n                {\n                    exit(1);\n                }\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uaanuhtn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401591,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_31.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\n\n\nstatic void f_cjvleosw()\n{\n    int count;\n    \n    count = -1;\n    switch(6)\n    {\n    case 6:\n        \n        fscanf(stdin, \"%d\", &count);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        \n        if (count > 0 && count <= 20)\n        {\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n    break;\n    }\n}\n\n\nstatic void f_qorivgda()\n{\n    int count;\n    \n    count = -1;\n    switch(6)\n    {\n    case 6:\n        \n        fscanf(stdin, \"%d\", &count);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        \n        if (count > 0 && count <= 20)\n        {\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_vxpwsjjf()\n{\n    int count;\n    \n    count = -1;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        count = 20;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_svlwopsw()\n{\n    int count;\n    \n    count = -1;\n    switch(6)\n    {\n    case 6:\n        \n        count = 20;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_ecylkfio()\n{\n    f_cjvleosw();\n    f_qorivgda();\n    f_vxpwsjjf();\n    f_svlwopsw();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ecylkfio();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401592,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_15.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\nvoid f_mmersaat()\n{\n    int count;\n    \n    count = -1;\n    switch(6)\n    {\n    case 6:\n        \n        fscanf(stdin, \"%d\", &count);\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mmersaat();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401593,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_15.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\n\n\nstatic void f_wanqdvee()\n{\n    int count;\n    \n    count = -1;\n    switch(6)\n    {\n    case 6:\n        \n        count = RAND32();\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        \n        if (count > 0 && count <= 20)\n        {\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n    break;\n    }\n}\n\n\nstatic void f_eytxxvpy()\n{\n    int count;\n    \n    count = -1;\n    switch(6)\n    {\n    case 6:\n        \n        count = RAND32();\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        \n        if (count > 0 && count <= 20)\n        {\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_cbmhtgzn()\n{\n    int count;\n    \n    count = -1;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        count = 20;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_txkryolp()\n{\n    int count;\n    \n    count = -1;\n    switch(6)\n    {\n    case 6:\n        \n        count = 20;\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_gxqriwzf()\n{\n    f_wanqdvee();\n    f_eytxxvpy();\n    f_cbmhtgzn();\n    f_txkryolp();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gxqriwzf();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401594,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s02/CWE400_Resource_Exhaustion__rand_fwrite_15.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\nvoid f_iusyajri()\n{\n    int count;\n    \n    count = -1;\n    switch(6)\n    {\n    case 6:\n        \n        count = RAND32();\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iusyajri();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401595,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s02/CWE400_Resource_Exhaustion__rand_fwrite_15.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\n\n\nstatic void f_zpnmrhiu()\n{\n    int count;\n    \n    count = -1;\n    \n    count = 20;\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void f_zkrqnial()\n{\n    int count;\n    \n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        \n        if (count > 0 && count <= 20)\n        {\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_qpmgkrwr()\n{\n    f_zpnmrhiu();\n    f_zkrqnial();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qpmgkrwr();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401596,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_01.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\nvoid f_ielymcrk()\n{\n    int count;\n    \n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            inputBuffer[recvResult] = '\\0';\n            \n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        size_t i = 0;\n        FILE *pFile = NULL;\n        const char *filename = \"output_.txt\";\n        pFile = fopen(filename, \"w+\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        \n        for (i = 0; i < (size_t)count; i++)\n        {\n            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n            {\n                exit(1);\n            }\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ielymcrk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401597,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_01.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\n\n\nstatic void f_dqszllwr()\n{\n    int count;\n    int *countPtr1 = &count;\n    int *countPtr2 = &count;\n    \n    count = -1;\n    {\n        int count = *countPtr1;\n        \n        count = 20;\n        *countPtr1 = count;\n    }\n    {\n        int count = *countPtr2;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_.txt\";\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            \n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n                {\n                    exit(1);\n                }\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_dqtkntxx()\n{\n    int count;\n    int *countPtr1 = &count;\n    int *countPtr2 = &count;\n    \n    count = -1;\n    {\n        int count = *countPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                count = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *countPtr1 = count;\n    }\n    {\n        int count = *countPtr2;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_.txt\";\n            \n            if (count > 0 && count <= 20)\n            {\n                pFile = fopen(filename, \"w+\");\n                if (pFile == NULL)\n                {\n                    exit(1);\n                }\n                for (i = 0; i < (size_t)count; i++)\n                {\n                    if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n                }\n                if (pFile)\n                {\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n}\n\nvoid f_cgzhacfx()\n{\n    f_dqszllwr();\n    f_dqtkntxx();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cgzhacfx();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401598,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__connect_socket_fwrite_32.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-400"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\n\n#define SENTENCE \"This is the sentence we are printing to the file. \"\n\n\nvoid f_rdmhylwl()\n{\n    int count;\n    int *countPtr1 = &count;\n    int *countPtr2 = &count;\n    \n    count = -1;\n    {\n        int count = *countPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                inputBuffer[recvResult] = '\\0';\n                \n                count = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *countPtr1 = count;\n    }\n    {\n        int count = *countPtr2;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_.txt\";\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            \n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n                {\n                    exit(1);\n                }\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rdmhylwl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401599,
    "original_file": "testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__connect_socket_fwrite_32.c",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-787",
      "CWE-416"
    ]
  }
]