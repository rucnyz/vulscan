[
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy,\n          bool recursive, bool glob)\n{\n  ccon con;                     /* FTP connection */\n  uerr_t res;\n\n  *dt = 0;\n\n  xzero (con);\n\n  con.csock = -1;\n  con.st = ON_YOUR_OWN;\n  con.rs = ST_UNIX;\n  con.id = NULL;\n  con.proxy = proxy;\n\n  /* If the file name is empty, the user probably wants a directory\n     index.  We'll provide one, properly HTML-ized.  Unless\n     opt.htmlify is 0, of course.  :-) */\n  if (!*u->file && !recursive)\n    {\n      struct fileinfo *f;\n      res = ftp_get_listing (u, &con, &f);\n\n      if (res == RETROK)\n        {\n          if (opt.htmlify && !opt.spider)\n            {\n              char *filename = (opt.output_document\n                                ? xstrdup (opt.output_document)\n                                : (con.target ? xstrdup (con.target)\n                                   : url_file_name (u, NULL)));\n              res = ftp_index (filename, u, f);\n              if (res == FTPOK && opt.verbose)\n                {\n                  if (!opt.output_document)\n                    {\n                      struct_stat st;\n                      wgint sz;\n                      if (stat (filename, &st) == 0)\n                        sz = st.st_size;\n                      else\n                        sz = -1;\n                      logprintf (LOG_NOTQUIET,\n                                 _(\"Wrote HTML-ized index to %s [%s].\\n\"),\n                                 quote (filename), number_to_static_string (sz));\n                    }\n                  else\n                    logprintf (LOG_NOTQUIET,\n                               _(\"Wrote HTML-ized index to %s.\\n\"),\n                               quote (filename));\n                }\n              xfree (filename);\n            }\n          freefileinfo (f);\n        }\n    }\n  else\n    {\n      bool ispattern = false;\n      if (glob)\n        {\n          /* Treat the URL as a pattern if the file name part of the\n             URL path contains wildcards.  (Don't check for u->file\n             because it is unescaped and therefore doesn't leave users\n             the option to escape literal '*' as %2A.)  */\n          char *file_part = strrchr (u->path, '/');\n          if (!file_part)\n            file_part = u->path;\n          ispattern = has_wildcards_p (file_part);\n        }\n      if (ispattern || recursive || opt.timestamping || opt.preserve_perm)\n        {\n          /* ftp_retrieve_glob is a catch-all function that gets called\n             if we need globbing, time-stamping, recursion or preserve\n             permissions.  Its third argument is just what we really need.  */\n          res = ftp_retrieve_glob (u, &con,\n                                   ispattern ? GLOB_GLOBALL : GLOB_GETONE);\n        }\n      else\n        res = ftp_loop_internal (u, NULL, &con, local_file, false);\n    }\n  if (res == FTPOK)\n    res = RETROK;\n  if (res == RETROK)\n    *dt |= RETROKF;\n  /* If a connection was left, quench it.  */\n  if (con.csock != -1)\n    fd_close (con.csock);\n  xfree (con.id);\n  xfree (con.target);\n  return res;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 483,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "ftp_retrieve_glob (struct url *u, ccon *con, int action)\n{\n  struct fileinfo *f, *start;\n  uerr_t res;\n\n  con->cmd |= LEAVE_PENDING;\n\n  res = ftp_get_listing (u, con, &start);\n  if (res != RETROK)\n    return res;\n  /* First: weed out that do not conform the global rules given in\n     opt.accepts and opt.rejects.  */\n  if (opt.accepts || opt.rejects)\n    {\n      f = start;\n      while (f)\n        {\n          if (f->type != FT_DIRECTORY && !acceptable (f->name))\n            {\n              logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                         quote (f->name));\n              f = delelement (f, &start);\n            }\n          else\n            f = f->next;\n        }\n    }\n  /* Remove all files with possible harmful names or invalid entries. */\n  f = start;\n  while (f)\n    {\n      if (has_insecure_name_p (f->name) || is_invalid_entry (f))\n        {\n          logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                     quote (f->name));\n          f = delelement (f, &start);\n        }\n      else\n        f = f->next;\n    }\n  /* Now weed out the files that do not match our globbing pattern.\n     If we are dealing with a globbing pattern, that is.  */\n  if (*u->file)\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          int (*matcher) (const char *, const char *, int)\n            = opt.ignore_case ? fnmatch_nocase : fnmatch;\n          int matchres = 0;\n\n          f = start;\n          while (f)\n            {\n              matchres = matcher (u->file, f->name, 0);\n              if (matchres == -1)\n                {\n                  logprintf (LOG_NOTQUIET, _(\"Error matching %s against %s: %s\\n\"),\n                             u->file, quotearg_style (escape_quoting_style, f->name),\n                             strerror (errno));\n                  break;\n                }\n              if (matchres == FNM_NOMATCH)\n                f = delelement (f, &start); /* delete the element from the list */\n              else\n                f = f->next;        /* leave the element in the list */\n            }\n          if (matchres == -1)\n            {\n              freefileinfo (start);\n              return RETRBADPATTERN;\n            }\n        }\n      else if (action == GLOB_GETONE)\n        {\n#ifdef __VMS\n          /* 2009-09-09 SMS.\n           * Odd-ball compiler (\"HP C V7.3-009 on OpenVMS Alpha V7.3-2\")\n           * bug causes spurious %CC-E-BADCONDIT complaint with this\n           * \"?:\" statement.  (Different linkage attributes for strcmp()\n           * and strcasecmp().)  Converting to \"if\" changes the\n           * complaint to %CC-W-PTRMISMATCH on \"cmp = strcmp;\".  Adding\n           * the senseless type cast clears the complaint, and looks\n           * harmless.\n           */\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : (int (*)())strcmp;\n#else /* def __VMS */\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : strcmp;\n#endif /* def __VMS [else] */\n          f = start;\n          while (f)\n            {\n              if (0 != cmp(u->file, f->name))\n                f = delelement (f, &start);\n              else\n                f = f->next;\n            }\n        }\n    }\n  if (start)\n    {\n      /* Just get everything.  */\n      res = ftp_retrieve_list (u, start, con);\n    }\n  else\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          /* No luck.  */\n          /* #### This message SUCKS.  We should see what was the\n             reason that nothing was retrieved.  */\n          logprintf (LOG_VERBOSE, _(\"No matches on pattern %s.\\n\"),\n                     quote (u->file));\n        }\n      else if (action == GLOB_GETONE) /* GLOB_GETONE or GLOB_GETALL */\n        {\n          /* Let's try retrieving it anyway.  */\n          con->st |= ON_YOUR_OWN;\n          res = ftp_loop_internal (u, NULL, con, NULL, false);\n          return res;\n        }\n\n      /* If action == GLOB_GETALL, and the file list is empty, there's\n         no point in trying to download anything or in complaining about\n         it.  (An empty directory should not cause complaints.)\n      */\n    }\n  freefileinfo (start);\n  if (opt.quota && total_downloaded_bytes > opt.quota)\n    return QUOTEXC;\n  else\n    return res;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 486,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "print_length (wgint size, wgint start, bool authoritative)\n{\n  logprintf (LOG_VERBOSE, _(\"Length: %s\"), number_to_static_string (size));\n  if (size >= 1024)\n    logprintf (LOG_VERBOSE, \" (%s)\", human_readable (size, 10, 1));\n  if (start > 0)\n    {\n      if (size - start >= 1024)\n        logprintf (LOG_VERBOSE, _(\", %s (%s) remaining\"),\n                   number_to_static_string (size - start),\n                   human_readable (size - start, 10, 1));\n      else\n        logprintf (LOG_VERBOSE, _(\", %s remaining\"),\n                   number_to_static_string (size - start));\n    }\n  logputs (LOG_VERBOSE, !authoritative ? _(\" (unauthoritative)\\n\") : \"\\n\");\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 490,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_PUBLIC_ codepoint_t next_codepoint_handle(struct smb_iconv_handle *ic,\n\t\t\t\t\t   const char *str, size_t *size)\n{\n\t/*\n\t * We assume that no multi-byte character can take more than 5 bytes\n\t * thus avoiding walking all the way down a long string. This is OK as\n\t * Unicode codepoints only go up to (U+10ffff), which can always be\n\t * encoded in 4 bytes or less.\n\t */\n\treturn next_codepoint_handle_ext(ic, str, strnlen(str, 5), CH_UNIX,\n\t\t\t\t\t size);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 867,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_PUBLIC_ ssize_t push_codepoint_handle(struct smb_iconv_handle *ic,\n\t\t\t\tchar *str, codepoint_t c)\n{\n\tsmb_iconv_t descriptor;\n\tuint8_t buf[4];\n\tsize_t ilen, olen;\n\tconst char *inbuf;\n\n\tif (c < 128) {\n\t\t*str = c;\n\t\treturn 1;\n\t}\n\n\tdescriptor = get_conv_handle(ic,\n\t\t\t\t     CH_UTF16, CH_UNIX);\n\tif (descriptor == (smb_iconv_t)-1) {\n\t\treturn -1;\n\t}\n\n\tif (c < 0x10000) {\n\t\tilen = 2;\n\t\tolen = 5;\n\t\tinbuf = (char *)buf;\n\t\tSSVAL(buf, 0, c);\n\t\tsmb_iconv(descriptor, &inbuf, &ilen, &str, &olen);\n\t\tif (ilen != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 5 - olen;\n\t}\n\n\tc -= 0x10000;\n\n\tbuf[0] = (c>>10) & 0xFF;\n\tbuf[1] = (c>>18) | 0xd8;\n\tbuf[2] = c & 0xFF;\n\tbuf[3] = ((c>>8) & 0x3) | 0xdc;\n\n\tilen = 4;\n\tolen = 5;\n\tinbuf = (char *)buf;\n\n\tsmb_iconv(descriptor, &inbuf, &ilen, &str, &olen);\n\tif (ilen != 0) {\n\t\treturn -1;\n\t}\n\treturn 5 - olen;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 869,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_PUBLIC_ struct smb_iconv_handle *smb_iconv_handle_reinit(TALLOC_CTX *mem_ctx,\n\t\t\t\t\t\t\t\t    const char *dos_charset,\n\t\t\t\t\t\t\t\t    const char *unix_charset,\n\t\t\t\t\t\t\t\t    bool use_builtin_handlers,\n\t\t\t\t\t\t\t\t    struct smb_iconv_handle *old_ic)\n{\n\tstruct smb_iconv_handle *ret;\n\n\tif (old_ic != NULL) {\n\t\tret = old_ic;\n\t\tclose_iconv_handle(ret);\n\t\ttalloc_free(ret->child_ctx);\n\t\tZERO_STRUCTP(ret);\n\t} else {\n\t\tret = talloc_zero(mem_ctx, struct smb_iconv_handle);\n\t}\n\tif (ret == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* we use a child context to allow us to free all ptrs without\n\t   freeing the structure itself */\n\tret->child_ctx = talloc_new(ret);\n\tif (ret->child_ctx == NULL) {\n\t\treturn NULL;\n\t}\n\n\ttalloc_set_destructor(ret, close_iconv_handle);\n\n\tif (strcasecmp(dos_charset, \"UTF8\") == 0 || strcasecmp(dos_charset, \"UTF-8\") == 0) {\n\t\tDEBUG(0,(\"ERROR: invalid DOS charset: 'dos charset' must not be UTF8, using (default value) CP850 instead\\n\"));\n\t\tdos_charset = \"CP850\";\n\t}\n\n\tret->dos_charset = talloc_strdup(ret->child_ctx, dos_charset);\n\tret->unix_charset = talloc_strdup(ret->child_ctx, unix_charset);\n\tret->use_builtin_handlers = use_builtin_handlers;\n\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 870,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static bool push_ascii_string(void *dest, const char *src, size_t dest_len, int flags, size_t *converted_size)\n{\n\tsize_t src_len;\n\tbool ret;\n\n\tif (flags & STR_UPPER) {\n\t\tchar *tmpbuf = strupper_talloc(NULL, src);\n\t\tif (tmpbuf == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tret = push_ascii_string(dest, tmpbuf, dest_len, flags & ~STR_UPPER, converted_size);\n\t\ttalloc_free(tmpbuf);\n\t\treturn ret;\n\t}\n\n\tsrc_len = strlen(src);\n\n\tif (flags & (STR_TERMINATE | STR_TERMINATE_ASCII))\n\t\tsrc_len++;\n\n\treturn convert_string(CH_UNIX, CH_DOS, src, src_len, dest, dest_len, converted_size);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 881,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_PUBLIC_ ssize_t push_string(void *dest, const char *src, size_t dest_len, int flags)\n{\n\tif (flags & STR_ASCII) {\n\t\tsize_t size = 0;\n\t\tif (push_ascii_string(dest, src, dest_len, flags, &size)) {\n\t\t\treturn (ssize_t)size;\n\t\t} else {\n\t\t\treturn (ssize_t)-1;\n\t\t}\n\t} else if (flags & STR_UNICODE) {\n\t\treturn push_ucs2(dest, src, dest_len, flags);\n\t} else {\n\t\tsmb_panic(\"push_string requires either STR_ASCII or STR_UNICODE flag to be set\");\n\t\treturn -1;\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 882,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool ldb_dn_add_child(struct ldb_dn *dn, struct ldb_dn *child)\n{\n\tconst char *s;\n\tchar *t;\n\n\tif ( !child || child->invalid || !dn || dn->invalid) {\n\t\treturn false;\n\t}\n\n\tif (dn->components) {\n\t\tunsigned int n;\n\t\tunsigned int i, j;\n\n\t\tif (dn->comp_num == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ! ldb_dn_validate(child)) {\n\t\t\treturn false;\n\t\t}\n\n\t\ts = NULL;\n\t\tif (dn->valid_case) {\n\t\t\tif ( ! (s = ldb_dn_get_casefold(child))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tn = dn->comp_num + child->comp_num;\n\n\t\tdn->components = talloc_realloc(dn,\n\t\t\t\t\t\tdn->components,\n\t\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\t\tn);\n\t\tif ( ! dn->components) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = dn->comp_num - 1, j = n - 1; i != (unsigned int) -1;\n\t\t     i--, j--) {\n\t\t\tdn->components[j] = dn->components[i];\n\t\t}\n\n\t\tfor (i = 0; i < child->comp_num; i++) {\n\t\t\tdn->components[i] =\n\t\t\t\tldb_dn_copy_component(dn->components,\n\t\t\t\t\t\t\t&child->components[i]);\n\t\t\tif (dn->components[i].value.data == NULL) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tdn->comp_num = n;\n\n\t\tif (dn->casefold && s) {\n\t\t\tt = talloc_asprintf(dn, \"%s,%s\", s, dn->casefold);\n\t\t\tLDB_FREE(dn->casefold);\n\t\t\tdn->casefold = t;\n\t\t}\n\t}\n\n\tif (dn->linearized) {\n\t\tif (dn->linearized[0] == '\\0') {\n\t\t\treturn false;\n\t\t}\n\n\t\ts = ldb_dn_get_linearized(child);\n\t\tif ( ! s) {\n\t\t\treturn false;\n\t\t}\n\n\t\tt = talloc_asprintf(dn, \"%s,%s\", s, dn->linearized);\n\t\tif ( ! t) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t\tLDB_FREE(dn->linearized);\n\t\tdn->linearized = t;\n\t}\n\n\t/* Wipe the ext_linearized DN,\n\t * the GUID and SID are almost certainly no longer valid */\n\tLDB_FREE(dn->ext_linearized);\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\n\treturn true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 892,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool ldb_dn_add_child_fmt(struct ldb_dn *dn, const char *child_fmt, ...)\n{\n\tstruct ldb_dn *child;\n\tchar *child_str;\n\tva_list ap;\n\tbool ret;\n\n\tif ( !dn || dn->invalid) {\n\t\treturn false;\n\t}\n\n\tva_start(ap, child_fmt);\n\tchild_str = talloc_vasprintf(dn, child_fmt, ap);\n\tva_end(ap);\n\n\tif (child_str == NULL) {\n\t\treturn false;\n\t}\n\n\tchild = ldb_dn_new(child_str, dn->ldb, child_str);\n\n\tret = ldb_dn_add_child(dn, child);\n\n\ttalloc_free(child_str);\n\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 893,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\r\n                                       const UBaseType_t uxItemSize,\r\n                                       const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n        size_t xQueueSizeInBytes;\r\n        uint8_t * pucQueueStorage;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* Allocate enough space to hold the maximum number of items that\r\n         * can be in the queue at any time.  It is valid for uxItemSize to be\r\n         * zero in the case the queue is used as a semaphore. */\r\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\r\n\r\n        /* Check for multiplication overflow. */\r\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\r\n\r\n        /* Check for addition overflow. */\r\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\r\n\r\n        /* Allocate the queue and storage area.  Justification for MISRA\r\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\r\n         * blocks are aligned per the requirements of the MCU stack.  In this case\r\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\r\n         * alignment requirements of the Queue_t structure - which in this case\r\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\r\n         * are greater than or equal to the pointer to char requirements the cast\r\n         * is safe.  In other cases alignment requirements are not strict (one or\r\n         * two bytes). */\r\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* Jump past the queue structure to find the location of the queue\r\n             * storage area. */\r\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\r\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n\r\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be created either statically or dynamically, so\r\n                     * note this task was created dynamically in case it is later\r\n                     * deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\r\n                }\r\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 133,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\n\ttmp = xmalloc(len);\n\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\n\tif (crypto_memneq(md, tmp, len))\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 163,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n\n    /* RPSI uses pt==RTCP_PSFB and FMT==3 */\n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 3)\n\treturn PJ_ENOTFOUND;\n\n    if (hdr->rtcp_common.length < 3) {    \n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n                      \"Failed parsing FB RPSI, invalid header length\"));\n\treturn PJ_ETOOSMALL;\n    }\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->rtcp_common.length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n\n    if (padlen >= 32) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOBIG,\n                      \"Failed parsing FB RPSI, invalid RPSI padding len\"));\n\treturn PJ_ETOOBIG;\n    }\n\n    if ((rpsi_len * 8) < (unsigned)(16 + padlen)) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n                      \"Failed parsing FB RPSI, invalid RPSI bit len\"));\n\treturn PJ_ETOOSMALL;\n    }\n\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 233,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\n\tpasswd2_sum = passwd1_sum + hash_len;\n\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, key, keylen))\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))\n\t\t\tret = 1;\n\t}\n\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 290,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tusb_put_dev(udev);\n\tkfree(priv);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 356,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tstruct tipc_uaddr *ua = (struct tipc_uaddr *)m->msg_name;\n\tlong timeout = sock_sndtimeo(sk, m->msg_flags & MSG_DONTWAIT);\n\tstruct list_head *clinks = &tsk->cong_links;\n\tbool syn = !tipc_sk_type_connectionless(sk);\n\tstruct tipc_group *grp = tsk->group;\n\tstruct tipc_msg *hdr = &tsk->phdr;\n\tstruct tipc_socket_addr skaddr;\n\tstruct sk_buff_head pkts;\n\tint atype, mtu, rc;\n\n\tif (unlikely(dlen > TIPC_MAX_USER_MSG_SIZE))\n\t\treturn -EMSGSIZE;\n\n\tif (ua) {\n\t\tif (!tipc_uaddr_valid(ua, m->msg_namelen))\n\t\t\treturn -EINVAL;\n\t\tatype = ua->addrtype;\n\t}\n\n\t/* If socket belongs to a communication group follow other paths */\n\tif (grp) {\n\t\tif (!ua)\n\t\t\treturn tipc_send_group_bcast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SERVICE_ADDR)\n\t\t\treturn tipc_send_group_anycast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SOCKET_ADDR)\n\t\t\treturn tipc_send_group_unicast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SERVICE_RANGE)\n\t\t\treturn tipc_send_group_mcast(sock, m, dlen, timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ua) {\n\t\tua = (struct tipc_uaddr *)&tsk->peer;\n\t\tif (!syn && ua->family != AF_TIPC)\n\t\t\treturn -EDESTADDRREQ;\n\t\tatype = ua->addrtype;\n\t}\n\n\tif (unlikely(syn)) {\n\t\tif (sk->sk_state == TIPC_LISTEN)\n\t\t\treturn -EPIPE;\n\t\tif (sk->sk_state != TIPC_OPEN)\n\t\t\treturn -EISCONN;\n\t\tif (tsk->published)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (atype == TIPC_SERVICE_ADDR)\n\t\t\ttsk->conn_addrtype = atype;\n\t\tmsg_set_syn(hdr, 1);\n\t}\n\n\tmemset(&skaddr, 0, sizeof(skaddr));\n\n\t/* Determine destination */\n\tif (atype == TIPC_SERVICE_RANGE) {\n\t\treturn tipc_sendmcast(sock, ua, m, dlen, timeout);\n\t} else if (atype == TIPC_SERVICE_ADDR) {\n\t\tskaddr.node = ua->lookup_node;\n\t\tua->scope = tipc_node2scope(skaddr.node);\n\t\tif (!tipc_nametbl_lookup_anycast(net, ua, &skaddr))\n\t\t\treturn -EHOSTUNREACH;\n\t} else if (atype == TIPC_SOCKET_ADDR) {\n\t\tskaddr = ua->sk;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Block or return if destination link is congested */\n\trc = tipc_wait_for_cond(sock, &timeout,\n\t\t\t\t!tipc_dest_find(clinks, skaddr.node, 0));\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\t/* Finally build message header */\n\tmsg_set_destnode(hdr, skaddr.node);\n\tmsg_set_destport(hdr, skaddr.ref);\n\tif (atype == TIPC_SERVICE_ADDR) {\n\t\tmsg_set_type(hdr, TIPC_NAMED_MSG);\n\t\tmsg_set_hdr_sz(hdr, NAMED_H_SIZE);\n\t\tmsg_set_nametype(hdr, ua->sa.type);\n\t\tmsg_set_nameinst(hdr, ua->sa.instance);\n\t\tmsg_set_lookup_scope(hdr, ua->scope);\n\t} else { /* TIPC_SOCKET_ADDR */\n\t\tmsg_set_type(hdr, TIPC_DIRECT_MSG);\n\t\tmsg_set_lookup_scope(hdr, 0);\n\t\tmsg_set_hdr_sz(hdr, BASIC_H_SIZE);\n\t}\n\n\t/* Add message body */\n\t__skb_queue_head_init(&pkts);\n\tmtu = tipc_node_get_mtu(net, skaddr.node, tsk->portid, true);\n\trc = tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts);\n\tif (unlikely(rc != dlen))\n\t\treturn rc;\n\tif (unlikely(syn && !tipc_msg_skb_clone(&pkts, &sk->sk_write_queue))) {\n\t\t__skb_queue_purge(&pkts);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Send message */\n\ttrace_tipc_sk_sendmsg(sk, skb_peek(&pkts), TIPC_DUMP_SK_SNDQ, \" \");\n\trc = tipc_node_xmit(net, &pkts, skaddr.node, tsk->portid);\n\tif (unlikely(rc == -ELINKCONG)) {\n\t\ttipc_dest_push(clinks, skaddr.node, 0);\n\t\ttsk->cong_link_cnt++;\n\t\trc = 0;\n\t}\n\n\tif (unlikely(syn && !rc)) {\n\t\ttipc_set_sk_state(sk, TIPC_CONNECTING);\n\t\tif (dlen && timeout) {\n\t\t\ttimeout = msecs_to_jiffies(timeout);\n\t\t\ttipc_wait_for_connect(sock, &timeout);\n\t\t}\n\t}\n\n\treturn rc ? rc : dlen;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 358,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_3 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 438,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_3 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 440,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tint bytes = 0, dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 442,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\n\tdown_read(&namespace_sem);\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\tgoto invalid;\n\n\tif (!check_mnt(old_mnt))\n\t\tgoto invalid;\n\n\tif (has_locked_children(old_mnt, path->dentry))\n\t\tgoto invalid;\n\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tup_read(&namespace_sem);\n\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\n\t/* Longterm mount to be removed by kern_unmount*() */\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\n\treturn &new_mnt->mnt;\n\ninvalid:\n\tup_read(&namespace_sem);\n\treturn ERR_PTR(-EINVAL);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 478,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "PHP_FUNCTION(openssl_decrypt)\n{\n\tzend_bool raw_input = 0;\n\tchar *data, *method, *password, *iv = \"\";\n\tint data_len, method_len, password_len, iv_len = 0;\n\tconst EVP_CIPHER *cipher_type;\n\tEVP_CIPHER_CTX cipher_ctx;\n\tint i, outlen, keylen;\n\tunsigned char *outbuf, *key;\n\tint base64_str_len;\n\tchar *base64_str = NULL;\n\tzend_bool free_iv;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sss|bs\", &data, &data_len, &method, &method_len, &password, &password_len, &raw_input, &iv, &iv_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!method_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcipher_type = EVP_get_cipherbyname(method);\n\tif (!cipher_type) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!raw_input) {\n\t\tbase64_str = (char*)php_base64_decode((unsigned char*)data, data_len, &base64_str_len);\n\t\tdata_len = base64_str_len;\n\t\tdata = base64_str;\n\t}\n\n\tkeylen = EVP_CIPHER_key_length(cipher_type);\n\tif (keylen > password_len) {\n\t\tkey = emalloc(keylen);\n\t\tmemset(key, 0, keylen);\n\t\tmemcpy(key, password, password_len);\n\t} else {\n\t\tkey = (unsigned char*)password;\n\t}\n\n\tfree_iv = php_openssl_validate_iv(&iv, &iv_len, EVP_CIPHER_iv_length(cipher_type) TSRMLS_CC);\n\n\toutlen = data_len + EVP_CIPHER_block_size(cipher_type);\n\toutbuf = emalloc(outlen + 1);\n\n\tEVP_DecryptInit(&cipher_ctx, cipher_type, NULL, NULL);\n\tif (password_len > keylen) {\n\t\tEVP_CIPHER_CTX_set_key_length(&cipher_ctx, password_len);\n\t}\n\tEVP_DecryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv);\n\tEVP_DecryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);\n\toutlen = i;\n\tif (EVP_DecryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) {\n\t\toutlen += i;\n\t\toutbuf[outlen] = '\\0';\n\t\tRETVAL_STRINGL((char *)outbuf, outlen, 0);\n\t} else {\n\t\tefree(outbuf);\n\t\tRETVAL_FALSE;\n\t}\n\tif (key != (unsigned char*)password) {\n\t\tefree(key);\n\t}\n\tif (free_iv) {\n\t\tefree(iv);\n\t}\n\tif (base64_str) {\n\t\tefree(base64_str);\n\t}\n \tEVP_CIPHER_CTX_cleanup(&cipher_ctx);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 548,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tthis_cpu_add(net_rand_state.s1, fast_pool->pool[cycles & 3]);\n\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\n\t/*\n\t * If we have architectural seed generator, produce a seed and\n\t * add it to the pool.  For the sake of paranoia don't let the\n\t * architectural seed generator dominate the input from the\n\t * interrupt noise.\n\t */\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\n\tfast_pool->count = 0;\n\n\t/* award one bit for the contents of the fast pool */\n\tcredit_entropy_bits(r, credit + 1);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 552,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n\n\t/* The current CPU might make use of net randoms without receiving IRQs\n\t * to renew them often enough. Let's update the net_rand_state from a\n\t * non-constant value that's not affine to the number of calls to make\n\t * sure it's updated when there's some activity (we don't care in idle).\n\t */\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 554,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'B','M','R',\t\t\t/* bind,move,rbind */\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t/* label,uuid,source */\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\t/* only few options are allowed for non-root users */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\t/*\n\t\t * We have external (context independent) fstab instance, let's\n\t\t * make a connection between the fstab and the canonicalization\n\t\t * cache.\n\t\t */\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\n\tif (all) {\n\t\t/*\n\t\t * A) Mount all\n\t\t */\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\t/*\n\t\t * B) mount -L|-U|--source|--target\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\n\t} else if (argc == 1) {\n\t\t/*\n\t\t * C) mount [-L|-U|--source] <target>\n\t\t *    mount <source|target>\n\t\t *\n\t\t * non-root may specify source *or* target, but not both\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\n\t\tmnt_context_set_target(cxt, argv[0]);\n\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\t/*\n\t\t * D) mount <source> <target>\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\n\t} else\n\t\tusage(stderr);\n\n\tif (mnt_context_is_restricted(cxt))\n\t\tsanitize_paths(cxt);\n\n\tif (oper) {\n\t\t/* MS_PROPAGATION operations, let's set the mount flags */\n\t\tmnt_context_set_mflags(cxt, oper);\n\n\t\t/* For -make* or --bind is fstab unnecessary */\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 562,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "win_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif ((bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n#endif\n\t\t    || bufIsChanged(wp->w_buffer)\n\t\t    || wp->w_buffer->b_p_ro)\n\t\t&& len < MAXPATHL - 1)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n\t    len += (int)STRLEN(p + len);\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 660,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  }
]