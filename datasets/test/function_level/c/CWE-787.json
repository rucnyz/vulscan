[
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149958,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        ReadReason(client);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149959,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n{\n    uint32_t w, h;\n    uint32_t shift;\n    uint32_t leftbyte;\n    uint8_t *ss;\n    uint8_t *dd;\n    uint8_t leftmask, rightmask;\n    int early = x >= 0;\n    int late;\n    uint32_t bytewidth;\n    uint32_t syoffset = 0;\n\n    if (src == NULL)\n        return 0;\n\n    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */\n\n    /* Data is packed msb first within a byte, so with bits numbered: 01234567.\n     * Second byte is: 89abcdef. So to combine into a run, we use:\n     *       (s[0]<<8) | s[1] == 0123456789abcdef.\n     * To read from src into dst at offset 3, we need to read:\n     *    read:      0123456789abcdef...\n     *    write:  0123456798abcdef...\n     * In general, to read from src and write into dst at offset x, we need to shift\n     * down by (x&7) bits to allow for bit alignment. So shift = x&7.\n     * So the 'central' part of our runs will see us doing:\n     *   *d++ op= ((s[0]<<8)|s[1])>>shift;\n     * with special cases on the left and right edges of the run to mask.\n     * With the left hand edge, we have to be careful not to 'underread' the start of\n     * the src image; this is what the early flag is about. Similarly we have to be\n     * careful not to read off the right hand edge; this is what the late flag is for.\n     */\n\n    /* clip */\n    w = src->width;\n    h = src->height;\n    shift = (x & 7);\n    ss = src->data - early;\n\n    if (x < 0) {\n        if (w < (uint32_t) -x)\n            w = 0;\n        else\n            w += x;\n        ss += (-x-1)>>3;\n        x = 0;\n    }\n    if (y < 0) {\n        if (h < (uint32_t) -y)\n            h = 0;\n        else\n            h += y;\n        syoffset = -y * src->stride;\n        y = 0;\n    }\n    if ((uint32_t)x + w > dst->width)\n    {\n        if (dst->width < (uint32_t)x)\n            w = 0;\n        else\n            w = dst->width - x;\n    }\n    if ((uint32_t)y + h > dst->height)\n    {\n        if (dst->height < (uint32_t)y)\n            h = 0;\n        else\n            h = dst->height - y;\n    }\n#ifdef JBIG2_DEBUG\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);\n#endif\n\n    /* check for zero clipping region */\n    if ((w <= 0) || (h <= 0)) {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");\n#endif\n        return 0;\n    }\n\n    leftbyte = (uint32_t) x >> 3;\n    dd = dst->data + y * dst->stride + leftbyte;\n    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;\n    leftmask = 255>>(x&7);\n    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));\n    if (bytewidth == 1)\n        leftmask &= rightmask;\n    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));\n    ss += syoffset;\n\n    switch(op)\n    {\n    case JBIG2_COMPOSE_OR:\n        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_AND:\n        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XOR:\n        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    }\n\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149960,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n{\n    uint32_t w, h;\n    uint32_t shift;\n    uint32_t leftbyte;\n    uint8_t *ss;\n    uint8_t *dd;\n    uint8_t leftmask, rightmask;\n    int early = x >= 0;\n    int late;\n    uint32_t bytewidth;\n    uint32_t syoffset = 0;\n\n    if (src == NULL)\n        return 0;\n\n    if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||\n        (UINT32_MAX - src->height < (y > 0 ? y : -y)))\n    {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"overflow in compose_image\");\n#endif\n        return 0;\n    }\n\n    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */\n\n    /* Data is packed msb first within a byte, so with bits numbered: 01234567.\n     * Second byte is: 89abcdef. So to combine into a run, we use:\n     *       (s[0]<<8) | s[1] == 0123456789abcdef.\n     * To read from src into dst at offset 3, we need to read:\n     *    read:      0123456789abcdef...\n     *    write:  0123456798abcdef...\n     * In general, to read from src and write into dst at offset x, we need to shift\n     * down by (x&7) bits to allow for bit alignment. So shift = x&7.\n     * So the 'central' part of our runs will see us doing:\n     *   *d++ op= ((s[0]<<8)|s[1])>>shift;\n     * with special cases on the left and right edges of the run to mask.\n     * With the left hand edge, we have to be careful not to 'underread' the start of\n     * the src image; this is what the early flag is about. Similarly we have to be\n     * careful not to read off the right hand edge; this is what the late flag is for.\n     */\n\n    /* clip */\n    w = src->width;\n    h = src->height;\n    shift = (x & 7);\n    ss = src->data - early;\n\n    if (x < 0) {\n        if (w < (uint32_t) -x)\n            w = 0;\n        else\n            w += x;\n        ss += (-x-1)>>3;\n        x = 0;\n    }\n    if (y < 0) {\n        if (h < (uint32_t) -y)\n            h = 0;\n        else\n            h += y;\n        syoffset = -y * src->stride;\n        y = 0;\n    }\n    if ((uint32_t)x + w > dst->width)\n    {\n        if (dst->width < (uint32_t)x)\n            w = 0;\n        else\n            w = dst->width - x;\n    }\n    if ((uint32_t)y + h > dst->height)\n    {\n        if (dst->height < (uint32_t)y)\n            h = 0;\n        else\n            h = dst->height - y;\n    }\n#ifdef JBIG2_DEBUG\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);\n#endif\n\n    /* check for zero clipping region */\n    if ((w <= 0) || (h <= 0)) {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");\n#endif\n        return 0;\n    }\n\n    leftbyte = (uint32_t) x >> 3;\n    dd = dst->data + y * dst->stride + leftbyte;\n    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;\n    leftmask = 255>>(x&7);\n    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));\n    if (bytewidth == 1)\n        leftmask &= rightmask;\n    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));\n    ss += syoffset;\n\n    switch(op)\n    {\n    case JBIG2_COMPOSE_OR:\n        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_AND:\n        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XOR:\n        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    }\n\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149961,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149962,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n\n  if (*state != CCS_START)\n    *state = CCS_VALUE;\n\n  *type  = CCV_CLASS;\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149963,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\n\tif (flags)\n\t\t*flags++ = '\\0';\t/* terminate mode string */\n\n\tif (nodelist) {\n\t\t/* NUL-terminate mode or flags string */\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * Insist on a nodelist of one node only\n\t\t */\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\t/*\n\t\t * Default to online nodes with memory if no nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\t/*\n\t\t * Don't allow a nodelist;  mpol_new() checks flags\n\t\t */\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\t/*\n\t\t * Insist on a empty nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\t/*\n\t\t * Insist on a nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\n\tmode_flags = 0;\n\tif (flags) {\n\t\t/*\n\t\t * Currently, we only support two mutually exclusive\n\t\t * mode flags.\n\t\t */\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\n\t/*\n\t * Save nodes for mpol_to_str() to show the tmpfs mount options\n\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.\n\t */\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\n\t/*\n\t * Save nodes for contextualization: this will be used to \"clone\"\n\t * the mempolicy in a specific context [cpuset] at a later time.\n\t */\n\tnew->w.user_nodemask = nodes;\n\n\terr = 0;\n\nout:\n\t/* Restore string for error message */\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149964,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\n\tif (flags)\n\t\t*flags++ = '\\0';\t/* terminate mode string */\n\n\tif (nodelist) {\n\t\t/* NUL-terminate mode or flags string */\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * Insist on a nodelist of one node only, although later\n\t\t * we use first_node(nodes) to grab a single node, so here\n\t\t * nodelist (or nodes) cannot be empty.\n\t\t */\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t\tif (nodes_empty(nodes))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\t/*\n\t\t * Default to online nodes with memory if no nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\t/*\n\t\t * Don't allow a nodelist;  mpol_new() checks flags\n\t\t */\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\t/*\n\t\t * Insist on a empty nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\t/*\n\t\t * Insist on a nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\n\tmode_flags = 0;\n\tif (flags) {\n\t\t/*\n\t\t * Currently, we only support two mutually exclusive\n\t\t * mode flags.\n\t\t */\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\n\t/*\n\t * Save nodes for mpol_to_str() to show the tmpfs mount options\n\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.\n\t */\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\n\t/*\n\t * Save nodes for contextualization: this will be used to \"clone\"\n\t * the mempolicy in a specific context [cpuset] at a later time.\n\t */\n\tnew->w.user_nodemask = nodes;\n\n\terr = 0;\n\nout:\n\t/* Restore string for error message */\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149965,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "keycompare_mb (const struct line *a, const struct line *b)\n{\n  struct keyfield *key = keylist;\n\n  /* For the first iteration only, the key positions have been\n     precomputed for us. */\n  char *texta = a->keybeg;\n  char *textb = b->keybeg;\n  char *lima = a->keylim;\n  char *limb = b->keylim;\n\n  size_t mblength_a, mblength_b;\n  wchar_t wc_a, wc_b;\n  mbstate_t state_a, state_b;\n\n  int diff = 0;\n\n  memset (&state_a, '\\0', sizeof(mbstate_t));\n  memset (&state_b, '\\0', sizeof(mbstate_t));\n  /* Ignore keys with start after end.  */\n  if (a->keybeg - a->keylim > 0)\n    return 0;\n\n\n              /* Ignore and/or translate chars before comparing.  */\n# define IGNORE_CHARS(NEW_LEN, LEN, TEXT, COPY, WC, MBLENGTH, STATE)        \\\n  do                                                                        \\\n    {                                                                        \\\n      wchar_t uwc;                                                        \\\n      char mbc[MB_LEN_MAX];                                                \\\n      mbstate_t state_wc;                                                \\\n                                                                        \\\n      for (NEW_LEN = i = 0; i < LEN;)                                        \\\n        {                                                                \\\n          mbstate_t state_bak;                                                \\\n                                                                        \\\n          state_bak = STATE;                                                \\\n          MBLENGTH = mbrtowc (&WC, TEXT + i, LEN - i, &STATE);                \\\n                                                                        \\\n          if (MBLENGTH == (size_t)-2 || MBLENGTH == (size_t)-1                \\\n              || MBLENGTH == 0)                                                \\\n            {                                                                \\\n              if (MBLENGTH == (size_t)-2 || MBLENGTH == (size_t)-1)        \\\n                STATE = state_bak;                                        \\\n              if (!ignore)                                                \\\n                COPY[NEW_LEN++] = TEXT[i];                                \\\n              i++;                                                         \\\n              continue;                                                        \\\n            }                                                                \\\n                                                                        \\\n          if (ignore)                                                        \\\n            {                                                                \\\n              if ((ignore == nonprinting && !iswprint (WC))                \\\n                   || (ignore == nondictionary                                \\\n                       && !iswalnum (WC) && !iswblank (WC)))                \\\n                {                                                        \\\n                  i += MBLENGTH;                                        \\\n                  continue;                                                \\\n                }                                                        \\\n            }                                                                \\\n                                                                        \\\n          if (translate)                                                \\\n            {                                                                \\\n                                                                        \\\n              uwc = towupper(WC);                                        \\\n              if (WC == uwc)                                                \\\n                {                                                        \\\n                  memcpy (mbc, TEXT + i, MBLENGTH);                        \\\n                  i += MBLENGTH;                                        \\\n                }                                                        \\\n              else                                                        \\\n                {                                                        \\\n                  i += MBLENGTH;                                        \\\n                  WC = uwc;                                                \\\n                  memset (&state_wc, '\\0', sizeof (mbstate_t));                \\\n                                                                        \\\n                  MBLENGTH = wcrtomb (mbc, WC, &state_wc);                \\\n                  assert (MBLENGTH != (size_t)-1 && MBLENGTH != 0);        \\\n                }                                                        \\\n                                                                        \\\n              for (j = 0; j < MBLENGTH; j++)                                \\\n                COPY[NEW_LEN++] = mbc[j];                                \\\n            }                                                                \\\n          else                                                                \\\n            for (j = 0; j < MBLENGTH; j++)                                \\\n              COPY[NEW_LEN++] = TEXT[i++];                                \\\n        }                                                                \\\n      COPY[NEW_LEN] = '\\0';                                                \\\n    }                                                                        \\\n  while (0)\n\n      /* Actually compare the fields. */\n\n  for (;;)\n    {\n      /* Find the lengths. */\n      size_t lena = lima <= texta ? 0 : lima - texta;\n      size_t lenb = limb <= textb ? 0 : limb - textb;\n\n      char enda IF_LINT (= 0);\n      char endb IF_LINT (= 0);\n\n      char const *translate = key->translate;\n      bool const *ignore = key->ignore;\n\n      if (ignore || translate)\n        {\n          char *copy_a = (char *) xmalloc (lena + 1 + lenb + 1);\n          char *copy_b = copy_a + lena + 1;\n          size_t new_len_a, new_len_b;\n          size_t i, j;\n\n          IGNORE_CHARS (new_len_a, lena, texta, copy_a,\n                        wc_a, mblength_a, state_a);\n          IGNORE_CHARS (new_len_b, lenb, textb, copy_b,\n                        wc_b, mblength_b, state_b);\n          texta = copy_a; textb = copy_b;\n          lena = new_len_a; lenb = new_len_b;\n        }\n      else\n        {\n          /* Use the keys in-place, temporarily null-terminated.  */\n          enda = texta[lena]; texta[lena] = '\\0';\n          endb = textb[lenb]; textb[lenb] = '\\0';\n        }\n\n      if (key->random)\n        diff = compare_random (texta, lena, textb, lenb);\n      else if (key->numeric | key->general_numeric | key->human_numeric)\n        {\n          char savea = *lima, saveb = *limb;\n\n          *lima = *limb = '\\0';\n          diff = (key->numeric ? numcompare (texta, textb)\n                  : key->general_numeric ? general_numcompare (texta, textb)\n                  : human_numcompare (texta, textb));\n          *lima = savea, *limb = saveb;\n        }\n      else if (key->version)\n        diff = filevercmp (texta, textb);\n      else if (key->month)\n        diff = getmonth (texta, lena, NULL) - getmonth (textb, lenb, NULL);\n      else if (lena == 0)\n        diff = - NONZERO (lenb);\n      else if (lenb == 0)\n        diff = 1;\n      else if (hard_LC_COLLATE && !folding)\n        {\n          diff = xmemcoll0 (texta, lena + 1, textb, lenb + 1);\n        }\n      else\n        {\n          diff = memcmp (texta, textb, MIN (lena, lenb));\n          if (diff == 0)\n            diff = lena < lenb ? -1 : lena != lenb;\n        }\n\n      if (ignore || translate)\n        free (texta);\n      else\n        {\n          texta[lena] = enda;\n          textb[lenb] = endb;\n        }\n\n      if (diff)\n        goto not_equal;\n\n      key = key->next;\n      if (! key)\n        break;\n\n      /* Find the beginning and limit of the next field.  */\n      if (key->eword != -1)\n        lima = limfield (a, key), limb = limfield (b, key);\n      else\n        lima = a->text + a->length - 1, limb = b->text + b->length - 1;\n\n      if (key->sword != -1)\n        texta = begfield (a, key), textb = begfield (b, key);\n      else\n        {\n          texta = a->text, textb = b->text;\n          if (key->skipsblanks)\n            {\n              while (texta < lima && ismbblank (texta, lima - texta, &mblength_a))\n                texta += mblength_a;\n              while (textb < limb && ismbblank (textb, limb - textb, &mblength_b))\n                textb += mblength_b;\n            }\n        }\n    }\n\nnot_equal:\n  if (key && key->reverse)\n    return -diff;\n  else\n    return diff;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149966,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "keycompare_mb (const struct line *a, const struct line *b)\n{\n  struct keyfield *key = keylist;\n\n  /* For the first iteration only, the key positions have been\n     precomputed for us. */\n  char *texta = a->keybeg;\n  char *textb = b->keybeg;\n  char *lima = a->keylim;\n  char *limb = b->keylim;\n\n  size_t mblength_a, mblength_b;\n  wchar_t wc_a, wc_b;\n  mbstate_t state_a, state_b;\n\n  int diff = 0;\n\n  memset (&state_a, '\\0', sizeof(mbstate_t));\n  memset (&state_b, '\\0', sizeof(mbstate_t));\n  /* Ignore keys with start after end.  */\n  if (a->keybeg - a->keylim > 0)\n    return 0;\n\n\n              /* Ignore and/or translate chars before comparing.  */\n# define IGNORE_CHARS(NEW_LEN, LEN, TEXT, COPY, WC, MBLENGTH, STATE)        \\\n  do                                                                        \\\n    {                                                                        \\\n      wchar_t uwc;                                                        \\\n      char mbc[MB_LEN_MAX];                                                \\\n      mbstate_t state_wc;                                                \\\n                                                                        \\\n      for (NEW_LEN = i = 0; i < LEN;)                                        \\\n        {                                                                \\\n          mbstate_t state_bak;                                                \\\n                                                                        \\\n          state_bak = STATE;                                                \\\n          MBLENGTH = mbrtowc (&WC, TEXT + i, LEN - i, &STATE);                \\\n                                                                        \\\n          if (MBLENGTH == (size_t)-2 || MBLENGTH == (size_t)-1                \\\n              || MBLENGTH == 0)                                                \\\n            {                                                                \\\n              if (MBLENGTH == (size_t)-2 || MBLENGTH == (size_t)-1)        \\\n                STATE = state_bak;                                        \\\n              if (!ignore)                                                \\\n                COPY[NEW_LEN++] = TEXT[i];                                \\\n              i++;                                                         \\\n              continue;                                                        \\\n            }                                                                \\\n                                                                        \\\n          if (ignore)                                                        \\\n            {                                                                \\\n              if ((ignore == nonprinting && !iswprint (WC))                \\\n                   || (ignore == nondictionary                                \\\n                       && !iswalnum (WC) && !iswblank (WC)))                \\\n                {                                                        \\\n                  i += MBLENGTH;                                        \\\n                  continue;                                                \\\n                }                                                        \\\n            }                                                                \\\n                                                                        \\\n          if (translate)                                                \\\n            {                                                                \\\n                                                                        \\\n              uwc = towupper(WC);                                        \\\n              if (WC == uwc)                                                \\\n                {                                                        \\\n                  memcpy (mbc, TEXT + i, MBLENGTH);                        \\\n                  i += MBLENGTH;                                        \\\n                }                                                        \\\n              else                                                        \\\n                {                                                        \\\n                  i += MBLENGTH;                                        \\\n                  WC = uwc;                                                \\\n                  memset (&state_wc, '\\0', sizeof (mbstate_t));                \\\n                                                                        \\\n                  MBLENGTH = wcrtomb (mbc, WC, &state_wc);                \\\n                  assert (MBLENGTH != (size_t)-1 && MBLENGTH != 0);        \\\n                }                                                        \\\n                                                                        \\\n              for (j = 0; j < MBLENGTH; j++)                                \\\n                COPY[NEW_LEN++] = mbc[j];                                \\\n            }                                                                \\\n          else                                                                \\\n            for (j = 0; j < MBLENGTH; j++)                                \\\n              COPY[NEW_LEN++] = TEXT[i++];                                \\\n        }                                                                \\\n      COPY[NEW_LEN] = '\\0';                                                \\\n    }                                                                        \\\n  while (0)\n\n      /* Actually compare the fields. */\n\n  for (;;)\n    {\n      /* Find the lengths. */\n      size_t lena = lima <= texta ? 0 : lima - texta;\n      size_t lenb = limb <= textb ? 0 : limb - textb;\n\n      char enda IF_LINT (= 0);\n      char endb IF_LINT (= 0);\n\n      char const *translate = key->translate;\n      bool const *ignore = key->ignore;\n\n      if (ignore || translate)\n        {\n          if (SIZE_MAX - lenb - 2 < lena)\n            xalloc_die ();\n          char *copy_a = (char *) xnmalloc (lena + lenb + 2, MB_CUR_MAX);\n          char *copy_b = copy_a + lena * MB_CUR_MAX + 1;\n          size_t new_len_a, new_len_b;\n          size_t i, j;\n\n          IGNORE_CHARS (new_len_a, lena, texta, copy_a,\n                        wc_a, mblength_a, state_a);\n          IGNORE_CHARS (new_len_b, lenb, textb, copy_b,\n                        wc_b, mblength_b, state_b);\n          texta = copy_a; textb = copy_b;\n          lena = new_len_a; lenb = new_len_b;\n        }\n      else\n        {\n          /* Use the keys in-place, temporarily null-terminated.  */\n          enda = texta[lena]; texta[lena] = '\\0';\n          endb = textb[lenb]; textb[lenb] = '\\0';\n        }\n\n      if (key->random)\n        diff = compare_random (texta, lena, textb, lenb);\n      else if (key->numeric | key->general_numeric | key->human_numeric)\n        {\n          char savea = *lima, saveb = *limb;\n\n          *lima = *limb = '\\0';\n          diff = (key->numeric ? numcompare (texta, textb)\n                  : key->general_numeric ? general_numcompare (texta, textb)\n                  : human_numcompare (texta, textb));\n          *lima = savea, *limb = saveb;\n        }\n      else if (key->version)\n        diff = filevercmp (texta, textb);\n      else if (key->month)\n        diff = getmonth (texta, lena, NULL) - getmonth (textb, lenb, NULL);\n      else if (lena == 0)\n        diff = - NONZERO (lenb);\n      else if (lenb == 0)\n        diff = 1;\n      else if (hard_LC_COLLATE && !folding)\n        {\n          diff = xmemcoll0 (texta, lena + 1, textb, lenb + 1);\n        }\n      else\n        {\n          diff = memcmp (texta, textb, MIN (lena, lenb));\n          if (diff == 0)\n            diff = lena < lenb ? -1 : lena != lenb;\n        }\n\n      if (ignore || translate)\n        free (texta);\n      else\n        {\n          texta[lena] = enda;\n          textb[lenb] = endb;\n        }\n\n      if (diff)\n        goto not_equal;\n\n      key = key->next;\n      if (! key)\n        break;\n\n      /* Find the beginning and limit of the next field.  */\n      if (key->eword != -1)\n        lima = limfield (a, key), limb = limfield (b, key);\n      else\n        lima = a->text + a->length - 1, limb = b->text + b->length - 1;\n\n      if (key->sword != -1)\n        texta = begfield (a, key), textb = begfield (b, key);\n      else\n        {\n          texta = a->text, textb = b->text;\n          if (key->skipsblanks)\n            {\n              while (texta < lima && ismbblank (texta, lima - texta, &mblength_a))\n                texta += mblength_a;\n              while (textb < limb && ismbblank (textb, limb - textb, &mblength_b))\n                textb += mblength_b;\n            }\n        }\n    }\n\nnot_equal:\n  if (key && key->reverse)\n    return -diff;\n  else\n    return diff;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149967,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n\n  default:\n    break;\n  }\n\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149968,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      if (*vs > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n\n  default:\n    break;\n  }\n\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149969,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,\n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149970,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,\n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            if (length > end - start)\n                return AVERROR_INVALIDDATA;\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149971,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,\n                               int linesize_align[AV_NUM_DATA_POINTERS])\n{\n    int i;\n    int w_align = 1;\n    int h_align = 1;\n    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);\n\n    if (desc) {\n        w_align = 1 << desc->log2_chroma_w;\n        h_align = 1 << desc->log2_chroma_h;\n    }\n\n    switch (s->pix_fmt) {\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUYV422:\n    case AV_PIX_FMT_YVYU422:\n    case AV_PIX_FMT_UYVY422:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_GBRP:\n    case AV_PIX_FMT_GBRAP:\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_GRAY16BE:\n    case AV_PIX_FMT_GRAY16LE:\n    case AV_PIX_FMT_YUVJ420P:\n    case AV_PIX_FMT_YUVJ422P:\n    case AV_PIX_FMT_YUVJ440P:\n    case AV_PIX_FMT_YUVJ444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9LE:\n    case AV_PIX_FMT_YUV420P9BE:\n    case AV_PIX_FMT_YUV420P10LE:\n    case AV_PIX_FMT_YUV420P10BE:\n    case AV_PIX_FMT_YUV420P12LE:\n    case AV_PIX_FMT_YUV420P12BE:\n    case AV_PIX_FMT_YUV420P14LE:\n    case AV_PIX_FMT_YUV420P14BE:\n    case AV_PIX_FMT_YUV420P16LE:\n    case AV_PIX_FMT_YUV420P16BE:\n    case AV_PIX_FMT_YUVA420P9LE:\n    case AV_PIX_FMT_YUVA420P9BE:\n    case AV_PIX_FMT_YUVA420P10LE:\n    case AV_PIX_FMT_YUVA420P10BE:\n    case AV_PIX_FMT_YUVA420P16LE:\n    case AV_PIX_FMT_YUVA420P16BE:\n    case AV_PIX_FMT_YUV422P9LE:\n    case AV_PIX_FMT_YUV422P9BE:\n    case AV_PIX_FMT_YUV422P10LE:\n    case AV_PIX_FMT_YUV422P10BE:\n    case AV_PIX_FMT_YUV422P12LE:\n    case AV_PIX_FMT_YUV422P12BE:\n    case AV_PIX_FMT_YUV422P14LE:\n    case AV_PIX_FMT_YUV422P14BE:\n    case AV_PIX_FMT_YUV422P16LE:\n    case AV_PIX_FMT_YUV422P16BE:\n    case AV_PIX_FMT_YUVA422P9LE:\n    case AV_PIX_FMT_YUVA422P9BE:\n    case AV_PIX_FMT_YUVA422P10LE:\n    case AV_PIX_FMT_YUVA422P10BE:\n    case AV_PIX_FMT_YUVA422P16LE:\n    case AV_PIX_FMT_YUVA422P16BE:\n    case AV_PIX_FMT_YUV440P10LE:\n    case AV_PIX_FMT_YUV440P10BE:\n    case AV_PIX_FMT_YUV440P12LE:\n    case AV_PIX_FMT_YUV440P12BE:\n    case AV_PIX_FMT_YUV444P9LE:\n    case AV_PIX_FMT_YUV444P9BE:\n    case AV_PIX_FMT_YUV444P10LE:\n    case AV_PIX_FMT_YUV444P10BE:\n    case AV_PIX_FMT_YUV444P12LE:\n    case AV_PIX_FMT_YUV444P12BE:\n    case AV_PIX_FMT_YUV444P14LE:\n    case AV_PIX_FMT_YUV444P14BE:\n    case AV_PIX_FMT_YUV444P16LE:\n    case AV_PIX_FMT_YUV444P16BE:\n    case AV_PIX_FMT_YUVA444P9LE:\n    case AV_PIX_FMT_YUVA444P9BE:\n    case AV_PIX_FMT_YUVA444P10LE:\n    case AV_PIX_FMT_YUVA444P10BE:\n    case AV_PIX_FMT_YUVA444P16LE:\n    case AV_PIX_FMT_YUVA444P16BE:\n    case AV_PIX_FMT_GBRP9LE:\n    case AV_PIX_FMT_GBRP9BE:\n    case AV_PIX_FMT_GBRP10LE:\n    case AV_PIX_FMT_GBRP10BE:\n    case AV_PIX_FMT_GBRP12LE:\n    case AV_PIX_FMT_GBRP12BE:\n    case AV_PIX_FMT_GBRP14LE:\n    case AV_PIX_FMT_GBRP14BE:\n    case AV_PIX_FMT_GBRP16LE:\n    case AV_PIX_FMT_GBRP16BE:\n    case AV_PIX_FMT_GBRAP12LE:\n    case AV_PIX_FMT_GBRAP12BE:\n    case AV_PIX_FMT_GBRAP16LE:\n    case AV_PIX_FMT_GBRAP16BE:\n        w_align = 16; //FIXME assume 16 pixel per macroblock\n        h_align = 16 * 2; // interlaced needs 2 macroblocks height\n        break;\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUVJ411P:\n    case AV_PIX_FMT_UYYVYY411:\n        w_align = 32;\n        h_align = 16 * 2;\n        break;\n    case AV_PIX_FMT_YUV410P:\n        if (s->codec_id == AV_CODEC_ID_SVQ1) {\n            w_align = 64;\n            h_align = 64;\n        }\n        break;\n    case AV_PIX_FMT_RGB555:\n        if (s->codec_id == AV_CODEC_ID_RPZA) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    case AV_PIX_FMT_PAL8:\n    case AV_PIX_FMT_BGR8:\n    case AV_PIX_FMT_RGB8:\n        if (s->codec_id == AV_CODEC_ID_SMC ||\n            s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        if (s->codec_id == AV_CODEC_ID_JV) {\n            w_align = 8;\n            h_align = 8;\n        }\n        break;\n    case AV_PIX_FMT_BGR24:\n        if ((s->codec_id == AV_CODEC_ID_MSZH) ||\n            (s->codec_id == AV_CODEC_ID_ZLIB)) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    case AV_PIX_FMT_RGB24:\n        if (s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {\n        w_align = FFMAX(w_align, 8);\n    }\n\n    *width  = FFALIGN(*width, w_align);\n    *height = FFALIGN(*height, h_align);\n    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {\n        // some of the optimized chroma MC reads one line too much\n        // which is also done in mpeg decoders with lowres > 0\n        *height += 2;\n\n        // H.264 uses edge emulation for out of frame motion vectors, for this\n        // it requires a temporary area large enough to hold a 21x21 block,\n        // increasing witdth ensure that the temporary area is large enough,\n        // the next rounded up width is 32\n        *width = FFMAX(*width, 32);\n    }\n\n    for (i = 0; i < 4; i++)\n        linesize_align[i] = STRIDE_ALIGN;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149972,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,\n                               int linesize_align[AV_NUM_DATA_POINTERS])\n{\n    int i;\n    int w_align = 1;\n    int h_align = 1;\n    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);\n\n    if (desc) {\n        w_align = 1 << desc->log2_chroma_w;\n        h_align = 1 << desc->log2_chroma_h;\n    }\n\n    switch (s->pix_fmt) {\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUYV422:\n    case AV_PIX_FMT_YVYU422:\n    case AV_PIX_FMT_UYVY422:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_GBRP:\n    case AV_PIX_FMT_GBRAP:\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_GRAY16BE:\n    case AV_PIX_FMT_GRAY16LE:\n    case AV_PIX_FMT_YUVJ420P:\n    case AV_PIX_FMT_YUVJ422P:\n    case AV_PIX_FMT_YUVJ440P:\n    case AV_PIX_FMT_YUVJ444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9LE:\n    case AV_PIX_FMT_YUV420P9BE:\n    case AV_PIX_FMT_YUV420P10LE:\n    case AV_PIX_FMT_YUV420P10BE:\n    case AV_PIX_FMT_YUV420P12LE:\n    case AV_PIX_FMT_YUV420P12BE:\n    case AV_PIX_FMT_YUV420P14LE:\n    case AV_PIX_FMT_YUV420P14BE:\n    case AV_PIX_FMT_YUV420P16LE:\n    case AV_PIX_FMT_YUV420P16BE:\n    case AV_PIX_FMT_YUVA420P9LE:\n    case AV_PIX_FMT_YUVA420P9BE:\n    case AV_PIX_FMT_YUVA420P10LE:\n    case AV_PIX_FMT_YUVA420P10BE:\n    case AV_PIX_FMT_YUVA420P16LE:\n    case AV_PIX_FMT_YUVA420P16BE:\n    case AV_PIX_FMT_YUV422P9LE:\n    case AV_PIX_FMT_YUV422P9BE:\n    case AV_PIX_FMT_YUV422P10LE:\n    case AV_PIX_FMT_YUV422P10BE:\n    case AV_PIX_FMT_YUV422P12LE:\n    case AV_PIX_FMT_YUV422P12BE:\n    case AV_PIX_FMT_YUV422P14LE:\n    case AV_PIX_FMT_YUV422P14BE:\n    case AV_PIX_FMT_YUV422P16LE:\n    case AV_PIX_FMT_YUV422P16BE:\n    case AV_PIX_FMT_YUVA422P9LE:\n    case AV_PIX_FMT_YUVA422P9BE:\n    case AV_PIX_FMT_YUVA422P10LE:\n    case AV_PIX_FMT_YUVA422P10BE:\n    case AV_PIX_FMT_YUVA422P16LE:\n    case AV_PIX_FMT_YUVA422P16BE:\n    case AV_PIX_FMT_YUV440P10LE:\n    case AV_PIX_FMT_YUV440P10BE:\n    case AV_PIX_FMT_YUV440P12LE:\n    case AV_PIX_FMT_YUV440P12BE:\n    case AV_PIX_FMT_YUV444P9LE:\n    case AV_PIX_FMT_YUV444P9BE:\n    case AV_PIX_FMT_YUV444P10LE:\n    case AV_PIX_FMT_YUV444P10BE:\n    case AV_PIX_FMT_YUV444P12LE:\n    case AV_PIX_FMT_YUV444P12BE:\n    case AV_PIX_FMT_YUV444P14LE:\n    case AV_PIX_FMT_YUV444P14BE:\n    case AV_PIX_FMT_YUV444P16LE:\n    case AV_PIX_FMT_YUV444P16BE:\n    case AV_PIX_FMT_YUVA444P9LE:\n    case AV_PIX_FMT_YUVA444P9BE:\n    case AV_PIX_FMT_YUVA444P10LE:\n    case AV_PIX_FMT_YUVA444P10BE:\n    case AV_PIX_FMT_YUVA444P16LE:\n    case AV_PIX_FMT_YUVA444P16BE:\n    case AV_PIX_FMT_GBRP9LE:\n    case AV_PIX_FMT_GBRP9BE:\n    case AV_PIX_FMT_GBRP10LE:\n    case AV_PIX_FMT_GBRP10BE:\n    case AV_PIX_FMT_GBRP12LE:\n    case AV_PIX_FMT_GBRP12BE:\n    case AV_PIX_FMT_GBRP14LE:\n    case AV_PIX_FMT_GBRP14BE:\n    case AV_PIX_FMT_GBRP16LE:\n    case AV_PIX_FMT_GBRP16BE:\n    case AV_PIX_FMT_GBRAP12LE:\n    case AV_PIX_FMT_GBRAP12BE:\n    case AV_PIX_FMT_GBRAP16LE:\n    case AV_PIX_FMT_GBRAP16BE:\n        w_align = 16; //FIXME assume 16 pixel per macroblock\n        h_align = 16 * 2; // interlaced needs 2 macroblocks height\n        break;\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUVJ411P:\n    case AV_PIX_FMT_UYYVYY411:\n        w_align = 32;\n        h_align = 16 * 2;\n        break;\n    case AV_PIX_FMT_YUV410P:\n        if (s->codec_id == AV_CODEC_ID_SVQ1) {\n            w_align = 64;\n            h_align = 64;\n        }\n        break;\n    case AV_PIX_FMT_RGB555:\n        if (s->codec_id == AV_CODEC_ID_RPZA) {\n            w_align = 4;\n            h_align = 4;\n        }\n        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n            w_align = 8;\n            h_align = 8;\n        }\n        break;\n    case AV_PIX_FMT_PAL8:\n    case AV_PIX_FMT_BGR8:\n    case AV_PIX_FMT_RGB8:\n        if (s->codec_id == AV_CODEC_ID_SMC ||\n            s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        if (s->codec_id == AV_CODEC_ID_JV ||\n            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {\n            w_align = 8;\n            h_align = 8;\n        }\n        break;\n    case AV_PIX_FMT_BGR24:\n        if ((s->codec_id == AV_CODEC_ID_MSZH) ||\n            (s->codec_id == AV_CODEC_ID_ZLIB)) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    case AV_PIX_FMT_RGB24:\n        if (s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {\n        w_align = FFMAX(w_align, 8);\n    }\n\n    *width  = FFALIGN(*width, w_align);\n    *height = FFALIGN(*height, h_align);\n    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {\n        // some of the optimized chroma MC reads one line too much\n        // which is also done in mpeg decoders with lowres > 0\n        *height += 2;\n\n        // H.264 uses edge emulation for out of frame motion vectors, for this\n        // it requires a temporary area large enough to hold a 21x21 block,\n        // increasing witdth ensure that the temporary area is large enough,\n        // the next rounded up width is 32\n        *width = FFMAX(*width, 32);\n    }\n\n    for (i = 0; i < 4; i++)\n        linesize_align[i] = STRIDE_ALIGN;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149973,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n\n      free(output_u8);\n    }\n\n  return rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149976,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      size_t len = strlen ((char *) output_u8);\n\n      if (len > 63)\n        {\n\t  free (output_u8);\n\t  return IDN2_TOO_BIG_DOMAIN;\n        }\n\n      if (output)\n\tstrcpy (output, (char *) output_u8);\n\n      free (output_u8);\n    }\n\n  return rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149977,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  tt_check_single_notdef( FT_Face  ttface )\n  {\n    FT_Bool   result = FALSE;\n\n    TT_Face   face = (TT_Face)ttface;\n    FT_UInt   asize;\n    FT_ULong  i;\n    FT_ULong  glyph_index = 0;\n    FT_UInt   count       = 0;\n\n\n    for( i = 0; i < face->num_locations; i++ )\n    {\n      tt_face_get_location( face, i, &asize );\n      if ( asize > 0 )\n      {\n        count += 1;\n        if ( count > 1 )\n          break;\n        glyph_index = i;\n      }\n    }\n\n    /* Only have a single outline. */\n    if ( count == 1 )\n    {\n      if ( glyph_index == 0 )\n        result = TRUE;\n      else\n      {\n        /* FIXME: Need to test glyphname == .notdef ? */\n        FT_Error error;\n        char buf[8];\n\n\n        error = FT_Get_Glyph_Name( ttface, glyph_index, buf, 8 );\n        if ( !error                                            &&\n             buf[0] == '.' && !ft_strncmp( buf, \".notdef\", 8 ) )\n          result = TRUE;\n      }\n    }\n\n    return result;\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 2548,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  tt_check_trickyness_family( FT_String*  name )\n  {\n\n#define TRICK_NAMES_MAX_CHARACTERS  19\n#define TRICK_NAMES_COUNT            9\n\n    static const char trick_names[TRICK_NAMES_COUNT]\n                                 [TRICK_NAMES_MAX_CHARACTERS + 1] =\n    {\n      \"DFKaiSho-SB\",        /* dfkaisb.ttf */\n      \"DFKaiShu\",\n      \"DFKai-SB\",           /* kaiu.ttf */\n      \"HuaTianKaiTi?\",      /* htkt2.ttf */\n      \"HuaTianSongTi?\",     /* htst3.ttf */\n      \"Ming(for ISO10646)\", /* hkscsiic.ttf & iicore.ttf */\n      \"MingLiU\",            /* mingliu.ttf & mingliu.ttc */\n      \"PMingLiU\",           /* mingliu.ttc */\n      \"MingLi43\",           /* mingli.ttf */\n    };\n\n    int  nn;\n\n\n    for ( nn = 0; nn < TRICK_NAMES_COUNT; nn++ )\n      if ( ft_strstr( name, trick_names[nn] ) )\n        return TRUE;\n\n    return FALSE;\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 2549,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  tt_driver_init( FT_Module  ttdriver )     /* TT_Driver */\n  {\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n\n    TT_Driver  driver = (TT_Driver)ttdriver;\n\n    driver->interpreter_version = TT_INTERPRETER_VERSION_35;\n#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n    driver->interpreter_version = TT_INTERPRETER_VERSION_38;\n#endif\n#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n    driver->interpreter_version = TT_INTERPRETER_VERSION_40;\n#endif\n\n#else /* !TT_USE_BYTECODE_INTERPRETER */\n\n    FT_UNUSED( ttdriver );\n\n#endif /* !TT_USE_BYTECODE_INTERPRETER */\n\n    return FT_Err_Ok;\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 2551,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  tt_face_done( FT_Face  ttface )           /* TT_Face */\n  {\n    TT_Face       face = (TT_Face)ttface;\n    FT_Memory     memory;\n    FT_Stream     stream;\n    SFNT_Service  sfnt;\n\n\n    if ( !face )\n      return;\n\n    memory = ttface->memory;\n    stream = ttface->stream;\n    sfnt   = (SFNT_Service)face->sfnt;\n\n    /* for `extended TrueType formats' (i.e. compressed versions) */\n    if ( face->extra.finalizer )\n      face->extra.finalizer( face->extra.data );\n\n    if ( sfnt )\n      sfnt->done_face( face );\n\n    /* freeing the locations table */\n    tt_face_done_loca( face );\n\n    tt_face_free_hdmx( face );\n\n    /* freeing the CVT */\n    FT_FREE( face->cvt );\n    face->cvt_size = 0;\n\n    /* freeing the programs */\n    FT_FRAME_RELEASE( face->font_program );\n    FT_FRAME_RELEASE( face->cvt_program );\n    face->font_program_size = 0;\n    face->cvt_program_size  = 0;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    tt_done_blend( face );\n    face->blend = NULL;\n#endif\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 2552,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  tt_size_done_bytecode( FT_Size  ftsize )\n  {\n    TT_Size    size   = (TT_Size)ftsize;\n    TT_Face    face   = (TT_Face)ftsize->face;\n    FT_Memory  memory = face->root.memory;\n\n    if ( size->context )\n    {\n      TT_Done_Context( size->context );\n      size->context = NULL;\n    }\n\n    FT_FREE( size->cvt );\n    size->cvt_size = 0;\n\n    /* free storage area */\n    FT_FREE( size->storage );\n    size->storage_size = 0;\n\n    /* twilight zone */\n    tt_glyphzone_done( &size->twilight );\n\n    FT_FREE( size->function_defs );\n    FT_FREE( size->instruction_defs );\n\n    size->num_function_defs    = 0;\n    size->max_function_defs    = 0;\n    size->num_instruction_defs = 0;\n    size->max_instruction_defs = 0;\n\n    size->max_func = 0;\n    size->max_ins  = 0;\n\n    size->bytecode_ready = -1;\n    size->cvt_ready      = -1;\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 2558,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  tt_size_init_bytecode( FT_Size  ftsize,\n                         FT_Bool  pedantic )\n  {\n    FT_Error   error;\n    TT_Size    size = (TT_Size)ftsize;\n    TT_Face    face = (TT_Face)ftsize->face;\n    FT_Memory  memory = face->root.memory;\n\n    FT_UShort       n_twilight;\n    TT_MaxProfile*  maxp = &face->max_profile;\n\n\n    /* clean up bytecode related data */\n    FT_FREE( size->function_defs );\n    FT_FREE( size->instruction_defs );\n    FT_FREE( size->cvt );\n    FT_FREE( size->storage );\n\n    if ( size->context )\n      TT_Done_Context( size->context );\n    tt_glyphzone_done( &size->twilight );\n\n    size->bytecode_ready = -1;\n    size->cvt_ready      = -1;\n\n    size->context = TT_New_Context( (TT_Driver)face->root.driver );\n\n    size->max_function_defs    = maxp->maxFunctionDefs;\n    size->max_instruction_defs = maxp->maxInstructionDefs;\n\n    size->num_function_defs    = 0;\n    size->num_instruction_defs = 0;\n\n    size->max_func = 0;\n    size->max_ins  = 0;\n\n    size->cvt_size     = face->cvt_size;\n    size->storage_size = maxp->maxStorage;\n\n    /* Set default metrics */\n    {\n      TT_Size_Metrics*  metrics = &size->ttmetrics;\n\n\n      metrics->rotated   = FALSE;\n      metrics->stretched = FALSE;\n\n      /* set default engine compensation */\n      metrics->compensations[0] = 0;   /* gray     */\n      metrics->compensations[1] = 0;   /* black    */\n      metrics->compensations[2] = 0;   /* white    */\n      metrics->compensations[3] = 0;   /* reserved */\n    }\n\n    /* allocate function defs, instruction defs, cvt, and storage area */\n    if ( FT_NEW_ARRAY( size->function_defs,    size->max_function_defs    ) ||\n         FT_NEW_ARRAY( size->instruction_defs, size->max_instruction_defs ) ||\n         FT_NEW_ARRAY( size->cvt,              size->cvt_size             ) ||\n         FT_NEW_ARRAY( size->storage,          size->storage_size         ) )\n      goto Exit;\n\n    /* reserve twilight zone */\n    n_twilight = maxp->maxTwilightPoints;\n\n    /* there are 4 phantom points (do we need this?) */\n    n_twilight += 4;\n\n    error = tt_glyphzone_new( memory, n_twilight, 0, &size->twilight );\n    if ( error )\n      goto Exit;\n\n    size->twilight.n_points = n_twilight;\n\n    size->GS = tt_default_graphics_state;\n\n    /* set `face->interpreter' according to the debug hook present */\n    {\n      FT_Library  library = face->root.driver->root.library;\n\n\n      face->interpreter = (TT_Interpreter)\n                            library->debug_hooks[FT_DEBUG_HOOK_TRUETYPE];\n      if ( !face->interpreter )\n        face->interpreter = (TT_Interpreter)TT_RunIns;\n    }\n\n    /* Fine, now run the font program! */\n\n    /* In case of an error while executing `fpgm', we intentionally don't */\n    /* clean up immediately \u2013 bugs in the `fpgm' are so fundamental that  */\n    /* all following hinting calls should fail.  Additionally, `fpgm' is  */\n    /* to be executed just once; calling it again is completely useless   */\n    /* and might even lead to extremely slow behaviour if it is malformed */\n    /* (containing an infinite loop, for example).                        */\n    error = tt_size_run_fpgm( size, pedantic );\n    return error;\n\n  Exit:\n    if ( error )\n      tt_size_done_bytecode( ftsize );\n\n    return error;\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 2560,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  tt_synth_sfnt_checksum( FT_Stream  stream,\n                          FT_ULong   length )\n  {\n    FT_Error   error;\n    FT_UInt32  checksum = 0;\n    FT_UInt    i;\n\n\n    if ( FT_FRAME_ENTER( length ) )\n      return 0;\n\n    for ( ; length > 3; length -= 4 )\n      checksum += (FT_UInt32)FT_GET_ULONG();\n\n    for ( i = 3; length > 0; length--, i-- )\n      checksum += (FT_UInt32)FT_GET_BYTE() << ( i * 8 );\n\n    FT_FRAME_EXIT();\n\n    return checksum;\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 2564,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  sfnt_load_face( FT_Stream      stream,\n                  TT_Face        face,\n                  FT_Int         face_instance_index,\n                  FT_Int         num_params,\n                  FT_Parameter*  params )\n  {\n    FT_Error      error;\n#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES\n    FT_Error      psnames_error;\n#endif\n    FT_Bool       has_outline;\n    FT_Bool       is_apple_sbit;\n    FT_Bool       is_apple_sbix;\n    FT_Bool       ignore_typographic_family    = FALSE;\n    FT_Bool       ignore_typographic_subfamily = FALSE;\n\n    SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n\n    FT_UNUSED( face_instance_index );\n\n\n    /* Check parameters */\n\n    {\n      FT_Int  i;\n\n\n      for ( i = 0; i < num_params; i++ )\n      {\n        if ( params[i].tag == FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_FAMILY )\n          ignore_typographic_family = TRUE;\n        else if ( params[i].tag == FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_SUBFAMILY )\n          ignore_typographic_subfamily = TRUE;\n      }\n    }\n\n    /* Load tables */\n\n    /* We now support two SFNT-based bitmapped font formats.  They */\n    /* are recognized easily as they do not include a `glyf'       */\n    /* table.                                                      */\n    /*                                                             */\n    /* The first format comes from Apple, and uses a table named   */\n    /* `bhed' instead of `head' to store the font header (using    */\n    /* the same format).  It also doesn't include horizontal and   */\n    /* vertical metrics tables (i.e. `hhea' and `vhea' tables are  */\n    /* missing).                                                   */\n    /*                                                             */\n    /* The other format comes from Microsoft, and is used with     */\n    /* WinCE/PocketPC.  It looks like a standard TTF, except that  */\n    /* it doesn't contain outlines.                                */\n    /*                                                             */\n\n    FT_TRACE2(( \"sfnt_load_face: %08p\\n\\n\", face ));\n\n    /* do we have outlines in there? */\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n    has_outline = FT_BOOL( face->root.internal->incremental_interface ||\n                           tt_face_lookup_table( face, TTAG_glyf )    ||\n                           tt_face_lookup_table( face, TTAG_CFF )     ||\n                           tt_face_lookup_table( face, TTAG_CFF2 )    );\n#else\n    has_outline = FT_BOOL( tt_face_lookup_table( face, TTAG_glyf ) ||\n                           tt_face_lookup_table( face, TTAG_CFF )  ||\n                           tt_face_lookup_table( face, TTAG_CFF2 ) );\n#endif\n\n    is_apple_sbit = 0;\n    is_apple_sbix = !face->goto_table( face, TTAG_sbix, stream, 0 );\n\n    /* Apple 'sbix' color bitmaps are rendered scaled and then the 'glyf'\n     * outline rendered on top.  We don't support that yet, so just ignore\n     * the 'glyf' outline and advertise it as a bitmap-only font. */\n    if ( is_apple_sbix )\n      has_outline = FALSE;\n\n    /* if this font doesn't contain outlines, we try to load */\n    /* a `bhed' table                                        */\n    if ( !has_outline && sfnt->load_bhed )\n    {\n      LOAD_( bhed );\n      is_apple_sbit = FT_BOOL( !error );\n    }\n\n    /* load the font header (`head' table) if this isn't an Apple */\n    /* sbit font file                                             */\n    if ( !is_apple_sbit || is_apple_sbix )\n    {\n      LOAD_( head );\n      if ( error )\n        goto Exit;\n    }\n\n    if ( face->header.Units_Per_EM == 0 )\n    {\n      error = FT_THROW( Invalid_Table );\n\n      goto Exit;\n    }\n\n    /* the following tables are often not present in embedded TrueType */\n    /* fonts within PDF documents, so don't check for them.            */\n    LOAD_( maxp );\n    LOAD_( cmap );\n\n    /* the following tables are optional in PCL fonts -- */\n    /* don't check for errors                            */\n    LOAD_( name );\n    LOAD_( post );\n\n#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES\n    psnames_error = error;\n#endif\n\n    /* do not load the metrics headers and tables if this is an Apple */\n    /* sbit font file                                                 */\n    if ( !is_apple_sbit )\n    {\n      /* load the `hhea' and `hmtx' tables */\n      LOADM_( hhea, 0 );\n      if ( !error )\n      {\n        LOADM_( hmtx, 0 );\n        if ( FT_ERR_EQ( error, Table_Missing ) )\n        {\n          error = FT_THROW( Hmtx_Table_Missing );\n\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n          /* If this is an incrementally loaded font and there are */\n          /* overriding metrics, tolerate a missing `hmtx' table.  */\n          if ( face->root.internal->incremental_interface          &&\n               face->root.internal->incremental_interface->funcs->\n                 get_glyph_metrics                                 )\n          {\n            face->horizontal.number_Of_HMetrics = 0;\n            error                               = FT_Err_Ok;\n          }\n#endif\n        }\n      }\n      else if ( FT_ERR_EQ( error, Table_Missing ) )\n      {\n        /* No `hhea' table necessary for SFNT Mac fonts. */\n        if ( face->format_tag == TTAG_true )\n        {\n          FT_TRACE2(( \"This is an SFNT Mac font.\\n\" ));\n\n          has_outline = 0;\n          error       = FT_Err_Ok;\n        }\n        else\n        {\n          error = FT_THROW( Horiz_Header_Missing );\n\n#ifdef FT_CONFIG_OPTION_INCREMENTAL\n          /* If this is an incrementally loaded font and there are */\n          /* overriding metrics, tolerate a missing `hhea' table.  */\n          if ( face->root.internal->incremental_interface          &&\n               face->root.internal->incremental_interface->funcs->\n                 get_glyph_metrics                                 )\n          {\n            face->horizontal.number_Of_HMetrics = 0;\n            error                               = FT_Err_Ok;\n          }\n#endif\n\n        }\n      }\n\n      if ( error )\n        goto Exit;\n\n      /* try to load the `vhea' and `vmtx' tables */\n      LOADM_( hhea, 1 );\n      if ( !error )\n      {\n        LOADM_( hmtx, 1 );\n        if ( !error )\n          face->vertical_info = 1;\n      }\n\n      if ( error && FT_ERR_NEQ( error, Table_Missing ) )\n        goto Exit;\n\n      LOAD_( os2 );\n      if ( error )\n      {\n        /* we treat the table as missing if there are any errors */\n        face->os2.version = 0xFFFFU;\n      }\n    }\n\n    /* the optional tables */\n\n    /* embedded bitmap support */\n    if ( sfnt->load_eblc )\n      LOAD_( eblc );\n\n    /* consider the pclt, kerning, and gasp tables as optional */\n    LOAD_( pclt );\n    LOAD_( gasp );\n    LOAD_( kern );\n\n    face->root.num_glyphs = face->max_profile.numGlyphs;\n\n    /* Bit 8 of the `fsSelection' field in the `OS/2' table denotes  */\n    /* a WWS-only font face.  `WWS' stands for `weight', width', and */\n    /* `slope', a term used by Microsoft's Windows Presentation      */\n    /* Foundation (WPF).  This flag has been introduced in version   */\n    /* 1.5 of the OpenType specification (May 2008).                 */\n\n    face->root.family_name = NULL;\n    face->root.style_name  = NULL;\n    if ( face->os2.version != 0xFFFFU && face->os2.fsSelection & 256 )\n    {\n      if ( !ignore_typographic_family )\n        GET_NAME( TYPOGRAPHIC_FAMILY, &face->root.family_name );\n      if ( !face->root.family_name )\n        GET_NAME( FONT_FAMILY, &face->root.family_name );\n\n      if ( !ignore_typographic_subfamily )\n        GET_NAME( TYPOGRAPHIC_SUBFAMILY, &face->root.style_name );\n      if ( !face->root.style_name )\n        GET_NAME( FONT_SUBFAMILY, &face->root.style_name );\n    }\n    else\n    {\n      GET_NAME( WWS_FAMILY, &face->root.family_name );\n      if ( !face->root.family_name && !ignore_typographic_family )\n        GET_NAME( TYPOGRAPHIC_FAMILY, &face->root.family_name );\n      if ( !face->root.family_name )\n        GET_NAME( FONT_FAMILY, &face->root.family_name );\n\n      GET_NAME( WWS_SUBFAMILY, &face->root.style_name );\n      if ( !face->root.style_name && !ignore_typographic_subfamily )\n        GET_NAME( TYPOGRAPHIC_SUBFAMILY, &face->root.style_name );\n      if ( !face->root.style_name )\n        GET_NAME( FONT_SUBFAMILY, &face->root.style_name );\n    }\n\n    /* now set up root fields */\n    {\n      FT_Face  root  = &face->root;\n      FT_Long  flags = root->face_flags;\n\n\n      /*********************************************************************/\n      /*                                                                   */\n      /* Compute face flags.                                               */\n      /*                                                                   */\n      if ( face->sbit_table_type == TT_SBIT_TABLE_TYPE_CBLC ||\n           face->sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX )\n        flags |= FT_FACE_FLAG_COLOR;      /* color glyphs */\n\n      if ( has_outline == TRUE )\n        flags |= FT_FACE_FLAG_SCALABLE;   /* scalable outlines */\n\n      /* The sfnt driver only supports bitmap fonts natively, thus we */\n      /* don't set FT_FACE_FLAG_HINTER.                               */\n      flags |= FT_FACE_FLAG_SFNT       |  /* SFNT file format  */\n               FT_FACE_FLAG_HORIZONTAL;   /* horizontal data   */\n\n#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES\n      if ( !psnames_error                             &&\n           face->postscript.FormatType != 0x00030000L )\n        flags |= FT_FACE_FLAG_GLYPH_NAMES;\n#endif\n\n      /* fixed width font? */\n      if ( face->postscript.isFixedPitch )\n        flags |= FT_FACE_FLAG_FIXED_WIDTH;\n\n      /* vertical information? */\n      if ( face->vertical_info )\n        flags |= FT_FACE_FLAG_VERTICAL;\n\n      /* kerning available ? */\n      if ( TT_FACE_HAS_KERNING( face ) )\n        flags |= FT_FACE_FLAG_KERNING;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n      /* Don't bother to load the tables unless somebody asks for them. */\n      /* No need to do work which will (probably) not be used.          */\n      if ( face->variation_support & TT_FACE_FLAG_VAR_FVAR )\n      {\n        if ( tt_face_lookup_table( face, TTAG_glyf ) != 0 &&\n             tt_face_lookup_table( face, TTAG_gvar ) != 0 )\n          flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;\n        if ( tt_face_lookup_table( face, TTAG_CFF2 ) != 0 )\n          flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;\n      }\n#endif\n\n      root->face_flags = flags;\n\n      /*********************************************************************/\n      /*                                                                   */\n      /* Compute style flags.                                              */\n      /*                                                                   */\n\n      flags = 0;\n      if ( has_outline == TRUE && face->os2.version != 0xFFFFU )\n      {\n        /* We have an OS/2 table; use the `fsSelection' field.  Bit 9 */\n        /* indicates an oblique font face.  This flag has been        */\n        /* introduced in version 1.5 of the OpenType specification.   */\n\n        if ( face->os2.fsSelection & 512 )       /* bit 9 */\n          flags |= FT_STYLE_FLAG_ITALIC;\n        else if ( face->os2.fsSelection & 1 )    /* bit 0 */\n          flags |= FT_STYLE_FLAG_ITALIC;\n\n        if ( face->os2.fsSelection & 32 )        /* bit 5 */\n          flags |= FT_STYLE_FLAG_BOLD;\n      }\n      else\n      {\n        /* this is an old Mac font, use the header field */\n\n        if ( face->header.Mac_Style & 1 )\n          flags |= FT_STYLE_FLAG_BOLD;\n\n        if ( face->header.Mac_Style & 2 )\n          flags |= FT_STYLE_FLAG_ITALIC;\n      }\n\n      root->style_flags |= flags;\n\n      /*********************************************************************/\n      /*                                                                   */\n      /* Polish the charmaps.                                              */\n      /*                                                                   */\n      /*   Try to set the charmap encoding according to the platform &     */\n      /*   encoding ID of each charmap.                                    */\n      /*                                                                   */\n\n      tt_face_build_cmaps( face );  /* ignore errors */\n\n\n      /* set the encoding fields */\n      {\n        FT_Int  m;\n\n\n        for ( m = 0; m < root->num_charmaps; m++ )\n        {\n          FT_CharMap  charmap = root->charmaps[m];\n\n\n          charmap->encoding = sfnt_find_encoding( charmap->platform_id,\n                                                  charmap->encoding_id );\n\n#if 0\n          if ( !root->charmap                           &&\n               charmap->encoding == FT_ENCODING_UNICODE )\n          {\n            /* set 'root->charmap' to the first Unicode encoding we find */\n            root->charmap = charmap;\n          }\n#endif\n        }\n      }\n\n#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS\n\n      /*\n       *  Now allocate the root array of FT_Bitmap_Size records and\n       *  populate them.  Unfortunately, it isn't possible to indicate bit\n       *  depths in the FT_Bitmap_Size record.  This is a design error.\n       */\n      {\n        FT_UInt  count;\n\n\n        count = face->sbit_num_strikes;\n\n        if ( count > 0 )\n        {\n          FT_Memory        memory   = face->root.stream->memory;\n          FT_UShort        em_size  = face->header.Units_Per_EM;\n          FT_Short         avgwidth = face->os2.xAvgCharWidth;\n          FT_Size_Metrics  metrics;\n\n          FT_UInt*  sbit_strike_map = NULL;\n          FT_UInt   strike_idx, bsize_idx;\n\n\n          if ( em_size == 0 || face->os2.version == 0xFFFFU )\n          {\n            avgwidth = 1;\n            em_size = 1;\n          }\n\n          /* to avoid invalid strike data in the `available_sizes' field */\n          /* of `FT_Face', we map `available_sizes' indices to strike    */\n          /* indices                                                     */\n          if ( FT_NEW_ARRAY( root->available_sizes, count ) ||\n               FT_NEW_ARRAY( sbit_strike_map, count ) )\n            goto Exit;\n\n          bsize_idx = 0;\n          for ( strike_idx = 0; strike_idx < count; strike_idx++ )\n          {\n            FT_Bitmap_Size*  bsize = root->available_sizes + bsize_idx;\n\n\n            error = sfnt->load_strike_metrics( face, strike_idx, &metrics );\n            if ( error )\n              continue;\n\n            bsize->height = (FT_Short)( metrics.height >> 6 );\n            bsize->width  = (FT_Short)(\n              ( avgwidth * metrics.x_ppem + em_size / 2 ) / em_size );\n\n            bsize->x_ppem = metrics.x_ppem << 6;\n            bsize->y_ppem = metrics.y_ppem << 6;\n\n            /* assume 72dpi */\n            bsize->size   = metrics.y_ppem << 6;\n\n            /* only use strikes with valid PPEM values */\n            if ( bsize->x_ppem && bsize->y_ppem )\n              sbit_strike_map[bsize_idx++] = strike_idx;\n          }\n\n          /* reduce array size to the actually used elements */\n          (void)FT_RENEW_ARRAY( sbit_strike_map, count, bsize_idx );\n\n          /* from now on, all strike indices are mapped */\n          /* using `sbit_strike_map'                    */\n          if ( bsize_idx )\n          {\n            face->sbit_strike_map = sbit_strike_map;\n\n            root->face_flags     |= FT_FACE_FLAG_FIXED_SIZES;\n            root->num_fixed_sizes = (FT_Int)bsize_idx;\n          }\n        }\n      }\n\n#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */\n\n      /* a font with no bitmaps and no outlines is scalable; */\n      /* it has only empty glyphs then                       */\n      if ( !FT_HAS_FIXED_SIZES( root ) && !FT_IS_SCALABLE( root ) )\n        root->face_flags |= FT_FACE_FLAG_SCALABLE;\n\n\n      /*********************************************************************/\n      /*                                                                   */\n      /*  Set up metrics.                                                  */\n      /*                                                                   */\n      if ( FT_IS_SCALABLE( root ) )\n      {\n        /* XXX What about if outline header is missing */\n        /*     (e.g. sfnt wrapped bitmap)?             */\n        root->bbox.xMin    = face->header.xMin;\n        root->bbox.yMin    = face->header.yMin;\n        root->bbox.xMax    = face->header.xMax;\n        root->bbox.yMax    = face->header.yMax;\n        root->units_per_EM = face->header.Units_Per_EM;\n\n\n        /* XXX: Computing the ascender/descender/height is very different */\n        /*      from what the specification tells you.  Apparently, we    */\n        /*      must be careful because                                   */\n        /*                                                                */\n        /*      - not all fonts have an OS/2 table; in this case, we take */\n        /*        the values in the horizontal header.  However, these    */\n        /*        values very often are not reliable.                     */\n        /*                                                                */\n        /*      - otherwise, the correct typographic values are in the    */\n        /*        sTypoAscender, sTypoDescender & sTypoLineGap fields.    */\n        /*                                                                */\n        /*        However, certain fonts have these fields set to 0.      */\n        /*        Rather, they have usWinAscent & usWinDescent correctly  */\n        /*        set (but with different values).                        */\n        /*                                                                */\n        /*      As an example, Arial Narrow is implemented through four   */\n        /*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF & ARIALNBI.TTF */\n        /*                                                                */\n        /*      Strangely, all fonts have the same values in their        */\n        /*      sTypoXXX fields, except ARIALNB which sets them to 0.     */\n        /*                                                                */\n        /*      On the other hand, they all have different                */\n        /*      usWinAscent/Descent values -- as a conclusion, the OS/2   */\n        /*      table cannot be used to compute the text height reliably! */\n        /*                                                                */\n\n        /* The ascender and descender are taken from the `hhea' table. */\n        /* If zero, they are taken from the `OS/2' table.              */\n\n        root->ascender  = face->horizontal.Ascender;\n        root->descender = face->horizontal.Descender;\n\n        root->height = root->ascender - root->descender +\n                       face->horizontal.Line_Gap;\n\n        if ( !( root->ascender || root->descender ) )\n        {\n          if ( face->os2.version != 0xFFFFU )\n          {\n            if ( face->os2.sTypoAscender || face->os2.sTypoDescender )\n            {\n              root->ascender  = face->os2.sTypoAscender;\n              root->descender = face->os2.sTypoDescender;\n\n              root->height = root->ascender - root->descender +\n                             face->os2.sTypoLineGap;\n            }\n            else\n            {\n              root->ascender  =  (FT_Short)face->os2.usWinAscent;\n              root->descender = -(FT_Short)face->os2.usWinDescent;\n\n              root->height = root->ascender - root->descender;\n            }\n          }\n        }\n\n        root->max_advance_width  =\n          (FT_Short)face->horizontal.advance_Width_Max;\n        root->max_advance_height =\n          (FT_Short)( face->vertical_info ? face->vertical.advance_Height_Max\n                                          : root->height );\n\n        /* See http://www.microsoft.com/OpenType/OTSpec/post.htm -- */\n        /* Adjust underline position from top edge to centre of     */\n        /* stroke to convert TrueType meaning to FreeType meaning.  */\n        root->underline_position  = face->postscript.underlinePosition -\n                                    face->postscript.underlineThickness / 2;\n        root->underline_thickness = face->postscript.underlineThickness;\n      }\n\n    }\n\n  Exit:\n    FT_TRACE2(( \"sfnt_load_face: done\\n\" ));\n\n    return error;\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 2566,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  sfnt_open_font( FT_Stream  stream,\n                  TT_Face    face )\n  {\n    FT_Memory  memory = stream->memory;\n    FT_Error   error;\n    FT_ULong   tag, offset;\n\n    static const FT_Frame_Field  ttc_header_fields[] =\n    {\n#undef  FT_STRUCTURE\n#define FT_STRUCTURE  TTC_HeaderRec\n\n      FT_FRAME_START( 8 ),\n        FT_FRAME_LONG( version ),\n        FT_FRAME_LONG( count   ),  /* this is ULong in the specs */\n      FT_FRAME_END\n    };\n\n\n    face->ttc_header.tag     = 0;\n    face->ttc_header.version = 0;\n    face->ttc_header.count   = 0;\n\n  retry:\n    offset = FT_STREAM_POS();\n\n    if ( FT_READ_ULONG( tag ) )\n      return error;\n\n    if ( tag == TTAG_wOFF )\n    {\n      FT_TRACE2(( \"sfnt_open_font: file is a WOFF; synthesizing SFNT\\n\" ));\n\n      if ( FT_STREAM_SEEK( offset ) )\n        return error;\n\n      error = woff_open_font( stream, face );\n      if ( error )\n        return error;\n\n      /* Swap out stream and retry! */\n      stream = face->root.stream;\n      goto retry;\n    }\n\n    if ( tag != 0x00010000UL &&\n         tag != TTAG_ttcf    &&\n         tag != TTAG_OTTO    &&\n         tag != TTAG_true    &&\n         tag != TTAG_typ1    &&\n         tag != 0x00020000UL )\n    {\n      FT_TRACE2(( \"  not a font using the SFNT container format\\n\" ));\n      return FT_THROW( Unknown_File_Format );\n    }\n\n    face->ttc_header.tag = TTAG_ttcf;\n\n    if ( tag == TTAG_ttcf )\n    {\n      FT_Int  n;\n\n\n      FT_TRACE3(( \"sfnt_open_font: file is a collection\\n\" ));\n\n      if ( FT_STREAM_READ_FIELDS( ttc_header_fields, &face->ttc_header ) )\n        return error;\n\n      FT_TRACE3(( \"                with %ld subfonts\\n\",\n                  face->ttc_header.count ));\n\n      if ( face->ttc_header.count == 0 )\n        return FT_THROW( Invalid_Table );\n\n      /* a rough size estimate: let's conservatively assume that there   */\n      /* is just a single table info in each subfont header (12 + 16*1 = */\n      /* 28 bytes), thus we have (at least) `12 + 4*count' bytes for the */\n      /* size of the TTC header plus `28*count' bytes for all subfont    */\n      /* headers                                                         */\n      if ( (FT_ULong)face->ttc_header.count > stream->size / ( 28 + 4 ) )\n        return FT_THROW( Array_Too_Large );\n\n      /* now read the offsets of each font in the file */\n      if ( FT_NEW_ARRAY( face->ttc_header.offsets, face->ttc_header.count ) )\n        return error;\n\n      if ( FT_FRAME_ENTER( face->ttc_header.count * 4L ) )\n        return error;\n\n      for ( n = 0; n < face->ttc_header.count; n++ )\n        face->ttc_header.offsets[n] = FT_GET_ULONG();\n\n      FT_FRAME_EXIT();\n    }\n    else\n    {\n      FT_TRACE3(( \"sfnt_open_font: synthesize TTC\\n\" ));\n\n      face->ttc_header.version = 1 << 16;\n      face->ttc_header.count   = 1;\n\n      if ( FT_NEW( face->ttc_header.offsets ) )\n        return error;\n\n      face->ttc_header.offsets[0] = offset;\n    }\n\n    return error;\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 2567,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static void pop_end(stroke_msg_t *msg, const char* label, stroke_end_t *end)\n{\n\tpop_string(msg, &end->address);\n\tpop_string(msg, &end->subnets);\n\tpop_string(msg, &end->sourceip);\n\tpop_string(msg, &end->dns);\n\tpop_string(msg, &end->auth);\n\tpop_string(msg, &end->auth2);\n\tpop_string(msg, &end->id);\n\tpop_string(msg, &end->id2);\n\tpop_string(msg, &end->rsakey);\n\tpop_string(msg, &end->cert);\n\tpop_string(msg, &end->cert2);\n\tpop_string(msg, &end->ca);\n\tpop_string(msg, &end->ca2);\n\tpop_string(msg, &end->groups);\n\tpop_string(msg, &end->groups2);\n\tpop_string(msg, &end->cert_policy);\n\tpop_string(msg, &end->updown);\n\n\tDBG_OPT(\"  %s=%s\", label, end->address);\n\tDBG_OPT(\"  %ssubnet=%s\", label, end->subnets);\n\tDBG_OPT(\"  %ssourceip=%s\", label, end->sourceip);\n\tDBG_OPT(\"  %sdns=%s\", label, end->dns);\n\tDBG_OPT(\"  %sauth=%s\", label, end->auth);\n\tDBG_OPT(\"  %sauth2=%s\", label, end->auth2);\n\tDBG_OPT(\"  %sid=%s\", label, end->id);\n\tDBG_OPT(\"  %sid2=%s\", label, end->id2);\n\tDBG_OPT(\"  %srsakey=%s\", label, end->rsakey);\n\tDBG_OPT(\"  %scert=%s\", label, end->cert);\n\tDBG_OPT(\"  %scert2=%s\", label, end->cert2);\n\tDBG_OPT(\"  %sca=%s\", label, end->ca);\n\tDBG_OPT(\"  %sca2=%s\", label, end->ca2);\n\tDBG_OPT(\"  %sgroups=%s\", label, end->groups);\n\tDBG_OPT(\"  %sgroups2=%s\", label, end->groups2);\n\tDBG_OPT(\"  %supdown=%s\", label, end->updown);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_nopair",
    "idx": 3657,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& indices = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& shape = context->input(2);\n    const Tensor& weights = context->input(3);\n    bool use_weights = weights.NumElements() > 0;\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices must be a 2-dimensional tensor. Got: \",\n                    indices.shape().DebugString()));\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n\n    OP_REQUIRES(context, shape.NumElements() != 0,\n                errors::InvalidArgument(\n                    \"The shape argument requires at least one element.\"));\n\n    bool is_1d = shape.NumElements() == 1;\n    auto shape_vector = shape.flat<int64_t>();\n    int num_batches = is_1d ? 1 : shape_vector(0);\n    int num_values = values.NumElements();\n\n    for (int b = 0; b < shape_vector.size(); b++) {\n      OP_REQUIRES(context, shape_vector(b) >= 0,\n                  errors::InvalidArgument(\n                      \"Elements in dense_shape must be >= 0. Instead got:\",\n                      shape.DebugString()));\n    }\n\n    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"Number of values must match first dimension of indices.\",\n                    \"Got \", num_values,\n                    \" values, indices shape: \", indices.shape().DebugString()));\n\n    const auto indices_values = indices.matrix<int64_t>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n\n    T max_value = 0;\n\n    OP_REQUIRES(context, num_values <= indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"The first dimension of indices must be equal to or \"\n                    \"greather than number of values. ( \",\n                    indices.shape().dim_size(0), \" vs. \", num_values, \" )\"));\n    OP_REQUIRES(context, indices.shape().dim_size(1) > 0,\n                errors::InvalidArgument(\"The second dimension of indices must \"\n                                        \"be greater than 0. Received: \",\n                                        indices.shape().dim_size(1)));\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      if (batch >= num_batches) {\n        OP_REQUIRES(context, batch < num_batches,\n                    errors::InvalidArgument(\n                        \"Indices value along the first dimension must be \",\n                        \"lower than the first index of the shape.\", \"Got \",\n                        batch, \" as batch and \", num_batches,\n                        \" as the first dimension of the shape.\"));\n      }\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 30,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 122,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n\t\t\t       const pj_uint8_t *pkt, const pj_uint8_t *start,\n\t\t\t       const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    p = (start + name_part_len);\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 154,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length = dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }\n    }\n\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n\n    p = &src[0];\n\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n\n\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n\n    return NJS_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 222,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "void HierarchicalBitmapRequester::PrepareForDecoding(void)\n{\n#if ACCUSOFT_CODE\n\n  UBYTE i;\n\n  BuildCommon();\n\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n\n    for(i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n\n      if (sx > 1 || sy > 1) {\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n      }\n    }\n  }\n\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForDecoding();\n#endif\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 246,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n        break;\n      }\n      \n      // Step 1\n      if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key)))) {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"sig\"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n          } else {\n            message = msprintf(\"attStmt map element %d key is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n            json_array_append_new(j_error, json_string(message));\n            o_free(message);\n            break;\n          }\n        } else {\n          message = msprintf(\"attStmt map element %d key is not a string\", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'x5c' invalid format\"));\n        break;\n      }\n      att_cert = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n        break;\n      }\n      if (json_object_get(j_params, \"root-ca-list\") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) {\n        json_array_append_new(j_error, json_string(\"Unrecognized certificate authority\"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {\n          message = msprintf(\"Unrecognized certificate autohority: %.*s\", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - %s\", message);\n          o_free(message);\n          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)\");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n        break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n      \n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n      \n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n      data_signed_offset+=cert_x_len;\n      \n      memcpy(data_signed+data_signed_offset, cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n        \n      // Let's verify sig over data_signed\n      data.data = data_signed;\n      data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&att_cert);\n    }\n    \n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 248,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\t/* Convert PORT command's argument to IP address + port */\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n\n\t/* Check IPv4 address using inet_aton(), throw away converted result */\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 299,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, \n\t\t\t\t      pjstun_msg *msg)\n{\n    pj_uint16_t msg_type, msg_len;\n    char *p_attr;\n\n    PJ_CHECK_STACK();\n\n    msg->hdr = (pjstun_msg_hdr*)buf;\n    msg_type = pj_ntohs(msg->hdr->type);\n\n    switch (msg_type) {\n    case PJSTUN_BINDING_REQUEST:\n    case PJSTUN_BINDING_RESPONSE:\n    case PJSTUN_BINDING_ERROR_RESPONSE:\n    case PJSTUN_SHARED_SECRET_REQUEST:\n    case PJSTUN_SHARED_SECRET_RESPONSE:\n    case PJSTUN_SHARED_SECRET_ERROR_RESPONSE:\n\tbreak;\n    default:\n\tPJ_LOG(4,(THIS_FILE, \"Error: unknown msg type %d\", msg_type));\n\treturn PJLIB_UTIL_ESTUNINMSGTYPE;\n    }\n\n    msg_len = pj_ntohs(msg->hdr->length);\n    if (msg_len != buf_len - sizeof(pjstun_msg_hdr)) {\n\tPJ_LOG(4,(THIS_FILE, \"Error: invalid msg_len %d (expecting %d)\", \n\t\t\t     msg_len, buf_len - sizeof(pjstun_msg_hdr)));\n\treturn PJLIB_UTIL_ESTUNINMSGLEN;\n    }\n\n    msg->attr_count = 0;\n    p_attr = (char*)buf + sizeof(pjstun_msg_hdr);\n\n    while (msg_len > 0) {\n\tpjstun_attr_hdr **attr = &msg->attr[msg->attr_count];\n\tpj_uint32_t len;\n\tpj_uint16_t attr_type;\n\n\t*attr = (pjstun_attr_hdr*)p_attr;\n\tlen = pj_ntohs((pj_uint16_t) ((*attr)->length)) + sizeof(pjstun_attr_hdr);\n\tlen = (len + 3) & ~3;\n\n\tif (msg_len < len) {\n\t    PJ_LOG(4,(THIS_FILE, \"Error: length mismatch in attr %d\", \n\t\t\t\t msg->attr_count));\n\t    return PJLIB_UTIL_ESTUNINATTRLEN;\n\t}\n\n\tattr_type = pj_ntohs((*attr)->type);\n\tif (attr_type > PJSTUN_ATTR_REFLECTED_FROM &&\n\t    attr_type != PJSTUN_ATTR_XOR_MAPPED_ADDR)\n\t{\n\t    PJ_LOG(5,(THIS_FILE, \"Warning: unknown attr type %x in attr %d. \"\n\t\t\t\t \"Attribute was ignored.\",\n\t\t\t\t attr_type, msg->attr_count));\n\t}\n\n\tmsg_len = (pj_uint16_t)(msg_len - len);\n\tp_attr += len;\n\t++msg->attr_count;\n    }\n\n    return PJ_SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 303,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n\n    msgmore((long)count);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 319,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree, try changes at each node.\n    // \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\" the word we are trying to match with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t// When there are postponed prefixes we need to use these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    // The loop may take an indefinite amount of time. Break out after some\n    // time.\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round we either:\n    // - For the current state try one operation, advance \"ts_curi\",\n    //   increase \"depth\".\n    // - When a state is done go to the next, set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx = sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t    // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word() works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t// eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length of the NULs in the prefix.  If there are\n\t\t// none this must be the first try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t    // change in this word (it was correct) add the first word\n\t\t    // as a suggestion.  If this word was corrected too, we\n\t\t    // need to check if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this word.  If this\n\t\t    // word does not support compounding then give up\n\t\t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not allowed.  But it may still be\n\t\t\t    // possible if we add another (short) word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper case in preword.\n\t    // If there is a word from a previous split, append.\n\t    // For the soundfold tree don't change the case, simply append.\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t// word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    // upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the next word is valid.\n\t\t// 2. The badword does end, but it was due to a change (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//    following word is valid.\n\t\t// 3. The badword and the word in the tree end.  It may still\n\t\t//    be possible to compound another (short) word.\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t// valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\t// If we're going to split need to check that the\n\t\t\t// words so far are valid for compounding.  If there\n\t\t\t// is only one word it must not have the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the badword has a non-word character at this\n\t\t\t// position skip it.  That means replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\t// character when the word ends.  But only when the\n\t\t\t// good word can end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t// may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\" is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust the score.  But don't even try\n\t\t// when the byte was already changed.  And don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte characters are a bit complicated to\n\t\t\t// handle: They differ when any of the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance over the character in fword[].  Give a bonus to the\n\t\t// score if the same character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node, go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    // - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was the same, thus doubling a\n\t\t    // character, give a bonus to the score.  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Don't swap if the first character is not a word character.\n\t    // SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical, swap won't do anything.\n\t    // Also get here if the second char is not a word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical: \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here when the third character is not a word character.\n\t    // Second character may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate.  First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here, it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items and we are not in the soundfold trie\n\t    // - the score is going to be too high anyway\n\t    // - already applied a REP item or swapped here\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Use the first byte to quickly find the first entry that may\n\t    // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items from the .aff file.  For each match\n\t    // replace the characters and check if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    // Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all possible states at this level, go up one level.\n\t    --depth;\n\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 363,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\t*p++ = ' ';\n\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\tp += m->desc.fmt[i].slen;\n    }\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 377,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "_inplace_src_spans (void *abstract_renderer, int y, int h,\n\t\t    const cairo_half_open_span_t *spans,\n\t\t    unsigned num_spans)\n{\n    cairo_image_span_renderer_t *r = abstract_renderer;\n    uint8_t *m;\n    int x0;\n\n    if (num_spans == 0)\n\treturn CAIRO_STATUS_SUCCESS;\n\n    x0 = spans[0].x;\n    m = r->_buf;\n    do {\n\tint len = spans[1].x - spans[0].x;\n\tif (len >= r->u.composite.run_length && spans[0].coverage == 0xff) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\n\t    pixman_image_composite32 (PIXMAN_OP_SRC,\n\t\t\t\t      r->src, NULL, r->u.composite.dst,\n\t\t\t\t      spans[0].x + r->u.composite.src_x,\n\t\t\t\t      y + r->u.composite.src_y,\n\t\t\t\t      0, 0,\n\t\t\t\t      spans[0].x, y,\n\t\t\t\t      spans[1].x - spans[0].x, h);\n\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else if (spans[0].coverage == 0x0) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else {\n\t    *m++ = spans[0].coverage;\n\t    if (len > 1) {\n\t\tmemset (m, spans[0].coverage, --len);\n\t\tm += len;\n\t    }\n\t}\n\tspans++;\n    } while (--num_spans > 1);\n\n    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#else\n\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#endif\n    }\n\n    return CAIRO_STATUS_SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 399,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "block_insert(\n    oparg_T\t\t*oap,\n    char_u\t\t*s,\n    int\t\t\tb_insert,\n    struct block_def\t*bdp)\n{\n    int\t\tts_val;\n    int\t\tcount = 0;\t// extra spaces to replace a cut TAB\n    int\t\tspaces = 0;\t// non-zero if cutting a TAB\n    colnr_T\toffset;\t\t// pointer along new line\n    colnr_T\tstartcol;\t// column where insert starts\n    unsigned\ts_len;\t\t// STRLEN(s)\n    char_u\t*newp, *oldp;\t// new, old lines\n    linenr_T\tlnum;\t\t// loop var\n    int\t\toldstate = State;\n\n    State = INSERT;\t\t// don't want REPLACE for State\n    s_len = (unsigned)STRLEN(s);\n\n    for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n    {\n\tblock_prep(oap, bdp, lnum, TRUE);\n\tif (bdp->is_short && b_insert)\n\t    continue;\t// OP_INSERT, line ends before block start\n\n\toldp = ml_get(lnum);\n\n\tif (b_insert)\n\t{\n\t    ts_val = bdp->start_char_vcols;\n\t    spaces = bdp->startspaces;\n\t    if (spaces != 0)\n\t\tcount = ts_val - 1; // we're cutting a TAB\n\t    offset = bdp->textcol;\n\t}\n\telse // append\n\t{\n\t    ts_val = bdp->end_char_vcols;\n\t    if (!bdp->is_short) // spaces = padding after block\n\t    {\n\t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n\t\tif (spaces != 0)\n\t\t    count = ts_val - 1; // we're cutting a TAB\n\t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n\t    }\n\t    else // spaces = padding to block edge\n\t    {\n\t\t// if $ used, just append to EOL (ie spaces==0)\n\t\tif (!bdp->is_MAX)\n\t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n\t\tcount = spaces;\n\t\toffset = bdp->textcol + bdp->textlen;\n\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t{\n\t    int off;\n\n\t    // Avoid starting halfway a multi-byte character.\n\t    if (b_insert)\n\t    {\n\t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\t\tspaces -= off;\n\t\tcount -= off;\n\t    }\n\t    else\n\t    {\n\t\t// spaces fill the gap, the character that's at the edge moves\n\t\t// right\n\t\toff = (*mb_head_off)(oldp, oldp + offset);\n\t\toffset -= off;\n\t    }\n\t}\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\t// Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t// insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t// we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t// We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t// Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties\n\t    inserted_bytes(lnum, startcol, s_len);\n\n\tif (lnum == oap->end.lnum)\n\t{\n\t    // Set \"']\" mark to the end of the block instead of the end of\n\t    // the insert in the first line.\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = offset;\n\t}\n    } // for all lnum\n\n    changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\n    State = oldstate;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 403,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n\t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n\tint err = 0;\n\n\tdo {\n\t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n\n\t\tself->rpc_tid = sw.tid;\n\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n\t\t\t\t\t\tself, fw.val,\n\t\t\t\t\t\tsw.tid == fw.tid,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_hw_err_from_flags(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\tif (fw.len == 0xFFFFU) {\n\t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n\n\tif (rpc) {\n\t\tif (fw.len) {\n\t\t\terr =\n\t\t\thw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t      self->rpc_addr,\n\t\t\t\t\t\t      (u32 *)(void *)\n\t\t\t\t\t\t      &self->rpc,\n\t\t\t\t\t\t      (fw.len + sizeof(u32) -\n\t\t\t\t\t\t       sizeof(u8)) /\n\t\t\t\t\t\t      sizeof(u32));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\n\t\t*rpc = &self->rpc;\n\t}\n\nerr_exit:\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 445,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n{\n\tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n\tu32 len, pg_off;\n\tstruct bpf_ringbuf_hdr *hdr;\n\n\tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n\t\treturn NULL;\n\n\tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\n\tif (in_nmi()) {\n\t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n\t\t\treturn NULL;\n\t} else {\n\t\tspin_lock_irqsave(&rb->spinlock, flags);\n\t}\n\n\tprod_pos = rb->producer_pos;\n\tnew_prod_pos = prod_pos + len;\n\n\t/* check for out of ringbuf space by ensuring producer position\n\t * doesn't advance more than (ringbuf_size - 1) ahead\n\t */\n\tif (new_prod_pos - cons_pos > rb->mask) {\n\t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\t\treturn NULL;\n\t}\n\n\thdr = (void *)rb->data + (prod_pos & rb->mask);\n\tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n\thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n\thdr->pg_off = pg_off;\n\n\t/* pairs with consumer's smp_load_acquire() */\n\tsmp_store_release(&rb->producer_pos, new_prod_pos);\n\n\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\n\treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 461,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "parse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers. The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break;  // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"mods'<,'>+\n\t\tmch_memmove(orig_cmd, cmd_start, len);\n\t\tSTRCPY(orig_cmd + len, \"'<,'>+\");\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -= 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t    // No modifiers, move the pointer back.\n\t    // Special case: change empty command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\";\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\teap->cmd = (char_u *)\"+\";\n\n    return OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 495,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n\n  fd = fopen(filename, \"rb\");\n\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n\n  if (!ReadOK(fd, buffer, 12))////\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n          \n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\t/* BI_ALPHABITFIELDS, etc. */\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    /* enhanced Windows format with bit masks */\n\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       /* 36 */\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       /* 3A */\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       /* 3E */\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       /* 42 */\n\n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    /* BMP Version 4 or 5 */\n\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n\n    Maps = 4;\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* biHeight may be negative, but -2147483648 is dangerous because:\n\t -2147483648 == -(-2147483648) */\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* protect against integer overflows caused by malicious BMPs */\n  /* use divisions in comparisons to avoid type overflows */\n\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n   \n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  /* Get the Colormap */\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 533,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\n\t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing\n\t// which will need this info can quickly look it up.\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 535,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "bracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n{\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n    int\t\tidx = 0;\n    char_u\t*end = find_termcode((char_u *)\"PE\");\n    int\t\tret_char = -1;\n    int\t\tsave_allow_keys = allow_keys;\n    int\t\tsave_paste = p_paste;\n\n    // If the end code is too long we can't detect it, read everything.\n    if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n\tend = NULL;\n    ++no_mapping;\n    allow_keys = 0;\n    if (!p_paste)\n\t// Also have the side effects of setting 'paste' to make it work much\n\t// faster.\n\tset_option_value((char_u *)\"paste\", TRUE, NULL, 0);\n\n    for (;;)\n    {\n\t// When the end is not defined read everything there is.\n\tif (end == NULL && vpeekc() == NUL)\n\t    break;\n\tdo\n\t    c = vgetc();\n\twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n\t    // When CTRL-C was encountered the typeahead will be flushed and we\n\t    // won't get the end sequence.  Except when using \":normal\".\n\t    break;\n\n\tif (has_mbyte)\n\t    idx += (*mb_char2bytes)(c, buf + idx);\n\telse\n\t    buf[idx++] = c;\n\tbuf[idx] = NUL;\n\tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n\t{\n\t    if (end[idx] == NUL)\n\t\tbreak; // Found the end of paste code.\n\t    continue;\n\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    if (gap != NULL && ga_grow(gap, idx) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {\n\t\t\tc = buf[0];\n\t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n\t\t\t    ins_eol(c);\n\t\t\telse\n\t\t\t{\n\t\t\t    ins_char_bytes(buf, idx);\n\t\t\t    AppendToRedobuffLit(buf, idx);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_ONE_CHAR:\n\t\t    if (ret_char == -1)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    ret_char = (*mb_ptr2char)(buf);\n\t\t\telse\n\t\t\t    ret_char = buf[0];\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n\tidx = 0;\n    }\n\n    --no_mapping;\n    allow_keys = save_allow_keys;\n    if (!save_paste)\n\tset_option_value((char_u *)\"paste\", FALSE, NULL, 0);\n\n    return ret_char;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 563,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tsize_t i, o4, nelements, j, slen, left;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *,\n\t    cdf_offset(sst->sst_tab, offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\n\tif (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)\n\t\tgoto out;\n\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tinp = cdf_grow_info(info, maxcount, sh.sh_properties);\n\tif (inp == NULL)\n\t\tgoto out;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));\n\te = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));\n\tif (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tif ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)\n\t\t\tgoto out;\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tleft = CAST(size_t, e - q);\n\t\tif (left < sizeof(uint32_t)) {\n\t\t\tDPRINTF((\"short info (no type)_\\n\"));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%#x type=%#x offs=%#tx,%#x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tif (left < sizeof(uint32_t) * 2) {\n\t\t\t\tDPRINTF((\"missing CDF_VECTOR length\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tslen = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\tslen = 1;\n\t\t}\n\t\to4 = slen * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\tcase CDF_FLOAT:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\tcase CDF_UNSIGNED64:\n\t\tcase CDF_DOUBLE:\n\t\tcase CDF_FILETIME:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tinp = cdf_grow_info(info, maxcount, nelements);\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tinp += nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l;\n\n\t\t\t\tif (o4 + sizeof(uint32_t) > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tl = CDF_GETUINT32(q, slen);\n\t\t\t\to4 += sizeof(uint32_t);\n\t\t\t\tif (o4 + l > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = CAST(const char *,\n\t\t\t\t    CAST(const void *, &q[o4]));\n\n\t\t\t\tDPRINTF((\"o=%\" SIZE_T_FORMAT \"u l=%d(%\"\n\t\t\t\t    SIZE_T_FORMAT \"u), t=%\" SIZE_T_FORMAT\n\t\t\t\t    \"u s=%s\\n\", o4, l, CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    left, inp[i].pi_str.s_buf));\n\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\n\t\t\t\tslen += l >> 1;\n\t\t\t\to4 = slen * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tmemset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));\n\t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\t*info = NULL;\n\t*count = 0;\n\t*maxcount = 0;\n\terrno = EFTYPE;\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 595,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MagickPathExtent];\n\n  CINInfo\n    cin;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4],\n    *pixels;\n\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n    sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n  (void) memset(cin.origination.serial,0, \n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const unsigned char *) NULL,\n        cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) SetImageBackgroundColor(image,exception);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,MagickFalse);\n  quantum_type=RGBQuantum;\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  status=SetQuantumPad(image,quantum_info,0);\n  pixels=GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const void\n      *stream;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    stream=ReadBlobStream(image,length,pixels,&count);\n    if ((size_t) count != length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,(unsigned char *) stream,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 603,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "sug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n\n    // We use si_foldroot for the soundfolded trie.\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n\n    // let tree_add_word() know we're adding to the soundfolded tree\n    spin->si_sugtree = TRUE;\n\n    /*\n     * Go through the whole case-folded tree, soundfold each word and put it\n     * in the trie.\n     */\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// Sound-fold the word.\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\n\t\t// We use the \"flags\" field for the MSB of the wordnr,\n\t\t// \"region\" for the LSB of the wordnr.\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\n\t\t++words_done;\n\t\t++wordcount[depth];\n\n\t\t// Reset the block count each time to avoid compression\n\t\t// kicking in.\n\t\tspin->si_blocks_cnt = 0;\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).  But don't go over the end.\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper.\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n\n    smsg(_(\"Total number of words: %d\"), words_done);\n\n    return OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 605,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {\n\tRzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tut32 total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos += n_slide_infos[i];\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut32 sio;\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 slide_infos_offset = sio;\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRzDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree(infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree(infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);\n\t\t\tfree(infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree(result);\n\treturn NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 677,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 697,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define MaxPixelChannels  32\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n    interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\");\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\");\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG) &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\");\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void) FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n              extra_samples-3,0);\n            if (image->matte != MagickFalse)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n                if (image->matte != MagickFalse)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                      extra_samples-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));\n            q++;\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*(samples_per_pixel+1)*TIFFStripSize(tiff);\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n         if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n          TIFFTileSize(tiff));\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n                0,i);\n              if (tiff_status == -1)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                PixelPacket\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (PixelPacket *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n  return(GetFirstImageInList(image));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 699,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n    rfbRREHeader hdr;\n    int i;\n    CARDBPP pix;\n    uint8_t *ptr;\n    int x, y, w, h;\n\n    if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))\n\treturn FALSE;\n\n    hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);\n\n    if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))\n\treturn FALSE;\n\n    client->GotFillRect(client, rx, ry, rw, rh, pix);\n\n    if (hdr.nSubrects * (4 + (BPP / 8)) > RFB_BUFFER_SIZE || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))\n\treturn FALSE;\n\n    ptr = (uint8_t *)client->buffer;\n\n    for (i = 0; i < hdr.nSubrects; i++) {\n\tpix = *(CARDBPP *)ptr;\n\tptr += BPP/8;\n\tx = *ptr++;\n\ty = *ptr++;\n\tw = *ptr++;\n\th = *ptr++;\n\n\tclient->GotFillRect(client, rx+x, ry+y, w, h, pix);\n    }\n\n    return TRUE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 753,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\n\t/*\n\t * r4 contains the guest physical address of the RTAS args\n\t * Mask off the top 4 bits since this is a guest real address\n\t */\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\n\t/*\n\t * args->rets is a pointer into args->args. Now that we've\n\t * copied args we need to fix it up to point into our copy,\n\t * not the guest args. We also need to save the original\n\t * value so we can restore it on the way out.\n\t */\n\torig_rets = args.rets;\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn rc;\n\nfail:\n\t/*\n\t * We only get here if the guest has called RTAS with a bogus\n\t * args pointer. That means we can't get to the args, and so we\n\t * can't fail the RTAS call. So fail right out to userspace,\n\t * which should kill the guest.\n\t */\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 767,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "compileRule(FileInfo *file, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable, const MacroList **inScopeMacros) {\n\tCharsString token;\n\tTranslationTableOpcode opcode;\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tCharsString cells;\n\tCharsString scratchPad;\n\tCharsString emphClass;\n\tTranslationTableCharacterAttributes after = 0;\n\tTranslationTableCharacterAttributes before = 0;\n\tint noback, nofor, nocross;\n\tnoback = nofor = nocross = 0;\ndoOpcode:\n\tif (!getToken(file, &token, NULL)) return 1;\t\t\t\t  /* blank line */\n\tif (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */\n\tif (file->lineNumber == 1 &&\n\t\t\t(eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||\n\t\t\t\t\teqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {\n\t\tif (table)\n\t\t\tcompileHyphenation(file, &token, table);\n\t\telse\n\t\t\t/* ignore the whole file */\n\t\t\twhile (_lou_getALine(file))\n\t\t\t\t;\n\t\treturn 1;\n\t}\n\topcode = getOpcode(file, &token);\n\tswitch (opcode) {\n\tcase CTO_Macro: {\n\t\tconst Macro *macro;\n#ifdef ENABLE_MACROS\n\t\tif (!inScopeMacros) {\n\t\t\tcompileError(file, \"Defining macros only allowed in table files.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (compileMacro(file, &macro)) {\n\t\t\t*inScopeMacros = cons_macro(macro, *inScopeMacros);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n#else\n\t\tcompileError(file, \"Macro feature is disabled.\");\n\t\treturn 0;\n#endif\n\t}\n\tcase CTO_IncludeFile: {\n\t\tCharsString includedFile;\n\t\tif (!getToken(file, &token, \"include file name\")) return 0;\n\t\tif (!parseChars(file, &includedFile, &token)) return 0;\n\t\treturn includeFile(file, &includedFile, table, displayTable);\n\t}\n\tcase CTO_NoBack:\n\t\tif (nofor) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));\n\t\t\treturn 0;\n\t\t}\n\t\tnoback = 1;\n\t\tgoto doOpcode;\n\tcase CTO_NoFor:\n\t\tif (noback) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));\n\t\t\treturn 0;\n\t\t}\n\t\tnofor = 1;\n\t\tgoto doOpcode;\n\tcase CTO_Space:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Space, noback, nofor, table, displayTable);\n\tcase CTO_Digit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Digit, noback, nofor, table, displayTable);\n\tcase CTO_LitDigit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LitDigit, noback, nofor, table, displayTable);\n\tcase CTO_Punctuation:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Punctuation, noback, nofor, table, displayTable);\n\tcase CTO_Math:\n\t\treturn compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);\n\tcase CTO_Sign:\n\t\treturn compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);\n\tcase CTO_Letter:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Letter, noback, nofor, table, displayTable);\n\tcase CTO_UpperCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_UpperCase, noback, nofor, table, displayTable);\n\tcase CTO_LowerCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LowerCase, noback, nofor, table, displayTable);\n\tcase CTO_Grouping:\n\t\treturn compileGrouping(file, noback, nofor, table, displayTable);\n\tcase CTO_Display:\n\t\tif (!displayTable) return 1;  // ignore\n\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\tif (ruleChars.length != 1 || ruleDots.length != 1) {\n\t\t\tcompileError(file, \"Exactly one character and one cell are required.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn putCharDotsMapping(\n\t\t\t\tfile, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n\tcase CTO_UpLow:\n\tcase CTO_None: {\n\t\t// check if token is a macro name\n\t\tif (inScopeMacros) {\n\t\t\tconst MacroList *macros = *inScopeMacros;\n\t\t\twhile (macros) {\n\t\t\t\tconst Macro *m = macros->head;\n\t\t\t\tif (token.length == strlen(m->name) &&\n\t\t\t\t\t\teqasc2uni((unsigned char *)m->name, token.chars, token.length)) {\n\t\t\t\t\tif (!inScopeMacros) {\n\t\t\t\t\t\tcompileError(file, \"Calling macros only allowed in table files.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tFileInfo tmpFile;\n\t\t\t\t\tmemset(&tmpFile, 0, sizeof(tmpFile));\n\t\t\t\t\ttmpFile.fileName = file->fileName;\n\t\t\t\t\ttmpFile.sourceFile = file->sourceFile;\n\t\t\t\t\ttmpFile.lineNumber = file->lineNumber;\n\t\t\t\t\ttmpFile.encoding = noEncoding;\n\t\t\t\t\ttmpFile.status = 0;\n\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\tint argument_count = 0;\n\t\t\t\t\tCharsString *arguments =\n\t\t\t\t\t\t\tmalloc(m->argument_count * sizeof(CharsString));\n\t\t\t\t\twhile (argument_count < m->argument_count) {\n\t\t\t\t\t\tif (getToken(file, &token, \"macro argument\"))\n\t\t\t\t\t\t\targuments[argument_count++] = token;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (argument_count < m->argument_count) {\n\t\t\t\t\t\tcompileError(file, \"Expected %d arguments\", m->argument_count);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint subst = 0;\n\t\t\t\t\tint next = subst < m->substitution_count ? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t : m->definition_length;\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\twhile (i < next) {\n\t\t\t\t\t\t\twidechar c = m->definition[i++];\n\t\t\t\t\t\t\tif (c == '\\n') {\n\t\t\t\t\t\t\t\tif (!compileRule(&tmpFile, table, displayTable,\n\t\t\t\t\t\t\t\t\t\t\tinScopeMacros)) {\n\t\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\t\t\t} else if (tmpFile.linelen >= MAXSTRING) {\n\t\t\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\t\t\"Line exceeds %d characters (post macro \"\n\t\t\t\t\t\t\t\t\t\t\"expansion)\",\n\t\t\t\t\t\t\t\t\t\tMAXSTRING);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (subst < m->substitution_count) {\n\t\t\t\t\t\t\tCharsString arg =\n\t\t\t\t\t\t\t\t\targuments[m->substitutions[2 * subst + 1] - 1];\n\t\t\t\t\t\t\tfor (int j = 0; j < arg.length; j++)\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = arg.chars[j];\n\t\t\t\t\t\t\tsubst++;\n\t\t\t\t\t\t\tnext = subst < m->substitution_count\n\t\t\t\t\t\t\t\t\t? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t: m->definition_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!compileRule(\n\t\t\t\t\t\t\t\t\t\t&tmpFile, table, displayTable, inScopeMacros)) {\n\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tmacros = macros->tail;\n\t\t\t}\n\t\t}\n\t\tif (opcode == CTO_UpLow) {\n\t\t\tcompileError(file, \"The uplow opcode is deprecated.\");\n\t\t\treturn 0;\n\t\t}\n\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\treturn 0;\n\t}\n\n\t/* now only opcodes follow that don't modify the display table */\n\tdefault:\n\t\tif (!table) return 1;\n\t\tswitch (opcode) {\n\t\tcase CTO_Locale:\n\t\t\tcompileWarning(file,\n\t\t\t\t\t\"The locale opcode is not implemented. Use the locale meta data \"\n\t\t\t\t\t\"instead.\");\n\t\t\treturn 1;\n\t\tcase CTO_Undefined: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->undefined;\n\t\t\tif (!compileBrailleIndicator(file, \"undefined character opcode\",\n\t\t\t\t\t\tCTO_Undefined, &ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->undefined = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Match: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternsOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnoback = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\t&rule, noback, nofor, table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternsOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternsOffset;\n\t\t\tok = 1;\n\t\tCTO_Match_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_BackMatch: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnofor = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternOffset;\n\t\t\tok = 1;\n\t\tCTO_BackMatch_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_CapsLetter:\n\t\tcase CTO_BegCapsWord:\n\t\tcase CTO_EndCapsWord:\n\t\tcase CTO_BegCaps:\n\t\tcase CTO_EndCaps:\n\t\tcase CTO_BegCapsPhrase:\n\t\tcase CTO_EndCapsPhrase:\n\t\tcase CTO_LenCapsPhrase:\n\t\t/* these 8 general purpose opcodes are compiled further down to more specific\n\t\t * internal opcodes:\n\t\t * - modeletter\n\t\t * - begmodeword\n\t\t * - endmodeword\n\t\t * - begmode\n\t\t * - endmode\n\t\t * - begmodephrase\n\t\t * - endmodephrase\n\t\t * - lenmodephrase\n\t\t */\n\t\tcase CTO_ModeLetter:\n\t\tcase CTO_BegModeWord:\n\t\tcase CTO_EndModeWord:\n\t\tcase CTO_BegMode:\n\t\tcase CTO_EndMode:\n\t\tcase CTO_BegModePhrase:\n\t\tcase CTO_EndModePhrase:\n\t\tcase CTO_LenModePhrase: {\n\t\t\tTranslationTableCharacterAttributes mode;\n\t\t\tint i;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_CapsLetter:\n\t\t\tcase CTO_BegCapsWord:\n\t\t\tcase CTO_EndCapsWord:\n\t\t\tcase CTO_BegCaps:\n\t\t\tcase CTO_EndCaps:\n\t\t\tcase CTO_BegCapsPhrase:\n\t\t\tcase CTO_EndCapsPhrase:\n\t\t\tcase CTO_LenCapsPhrase:\n\t\t\t\tmode = CTC_UpperCase;\n\t\t\t\ti = 0;\n\t\t\t\topcode += (CTO_ModeLetter - CTO_CapsLetter);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tconst CharacterClass *characterClass = findCharacterClass(&token, *table);\n\t\t\t\tif (!characterClass) {\n\t\t\t\t\tcharacterClass =\n\t\t\t\t\t\t\taddCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\t\tif (!characterClass) return 0;\n\t\t\t\t}\n\t\t\t\tmode = characterClass->attribute;\n\t\t\t\tif (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&\n\t\t\t\t\t\tmode <= CTC_LitDigit) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"mode must be \\\"uppercase\\\", \\\"digit\\\", or a custom \"\n\t\t\t\t\t\t\t\"attribute name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* check if this mode is already defined and if the number of modes does\n\t\t\t\t * not exceed the maximal number */\n\t\t\t\tif (mode == CTC_UpperCase)\n\t\t\t\t\ti = 0;\n\t\t\t\telse {\n\t\t\t\t\tfor (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {\n\t\t\t\t\t\tif ((*table)->modes[i].mode == mode) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == MAX_MODES) {\n\t\t\t\t\t\tcompileError(file, \"Max number of modes (%i) reached\", MAX_MODES);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(*table)->modes[i].value)\n\t\t\t\t(*table)->modes[i] = (EmphasisClass){ plain_text, mode,\n\t\t\t\t\t0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_BegModePhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModePhrase: {\n\t\t\t\tTranslationTableOffset ruleOffset;\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1:\t // before\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign after last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign before last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tcase 2:\t // after\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t   [endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign before last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign after last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,\n\t\t\t\t\t\t\t\tnofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcase CTO_BegMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter capital sign\",\n\t\t\t\t\t\t\tCTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_ModeLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter capital sign\",\n\t\t\t\t\t\t\tCTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_BegModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word\",\n\t\t\t\t\t\t\tCTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word stop\",\n\t\t\t\t\t\t\tCTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_LenModePhrase:\n\t\t\t\treturn (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] =\n\t\t\t\t\t\t\t   compileNumber(file);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* these 8 general purpose emphasis opcodes are compiled further down to more\n\t\t * specific internal opcodes:\n\t\t * - emphletter\n\t\t * - begemphword\n\t\t * - endemphword\n\t\t * - begemph\n\t\t * - endemph\n\t\t * - begemphphrase\n\t\t * - endemphphrase\n\t\t * - lenemphphrase\n\t\t */\n\t\tcase CTO_EmphClass:\n\t\t\tif (!getToken(file, &emphClass, \"emphasis class\")) {\n\t\t\t\tcompileError(file, \"emphclass must be followed by a valid class name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint k, i;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Duplicate emphasis class: %s\", s);\n\t\t\t\t\twarningCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\tif (i == MAX_EMPH_CLASSES) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\"Max number of emphasis classes (%i) reached\", MAX_EMPH_CLASSES);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\t/* For backwards compatibility (i.e. because programs will assume\n\t\t\t * the first 3 typeform bits are `italic', `underline' and `bold')\n\t\t\t * we require that the first 3 emphclass definitions are (in that\n\t\t\t * order):\n\t\t\t *\n\t\t\t *   emphclass italic\n\t\t\t *   emphclass underline\n\t\t\t *   emphclass bold\n\t\t\t *\n\t\t\t * While it would be possible to use the emphclass opcode only for\n\t\t\t * defining _additional_ classes (not allowing for them to be called\n\t\t\t * italic, underline or bold), thereby reducing the amount of\n\t\t\t * boilerplate, we deliberately choose not to do that in order to\n\t\t\t * not give italic, underline and bold any special status. The\n\t\t\t * hope is that eventually all programs will use liblouis for\n\t\t\t * emphasis the recommended way (i.e. by looking up the supported\n\t\t\t * typeforms in the documentation or API) so that we can drop this\n\t\t\t * restriction.\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t\tif (strcmp(s, \"italic\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"First emphasis class must be \\\"italic\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (strcmp(s, \"underline\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Second emphasis class must be \\\"underline\\\" but \"\n\t\t\t\t\t\t\t\"got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (strcmp(s, \"bold\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Third emphasis class must be \\\"bold\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*table)->emphClassNames[i] = s;\n\t\t\t(*table)->emphClasses[i] = (EmphasisClass){ emph_1\n\t\t\t\t\t\t<< i, /* relies on the order of typeforms emph_1..emph_10 */\n\t\t\t\t0, 0x1 << i, i };\n\t\t\treturn 1;\n\t\tcase CTO_EmphLetter:\n\t\tcase CTO_BegEmphWord:\n\t\tcase CTO_EndEmphWord:\n\t\tcase CTO_BegEmph:\n\t\tcase CTO_EndEmph:\n\t\tcase CTO_BegEmphPhrase:\n\t\tcase CTO_EndEmphPhrase:\n\t\tcase CTO_LenEmphPhrase:\n\t\tcase CTO_EmphModeChars:\n\t\tcase CTO_NoEmphChars: {\n\t\t\tif (!getToken(file, &token, \"emphasis class\")) return 0;\n\t\t\tif (!parseChars(file, &emphClass, &token)) return 0;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tint k, i;\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) break;\n\t\t\tif (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Emphasis class %s not declared\", s);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint ok = 0;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_EmphLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][letterOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word stop\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmph: {\n\t\t\t\t/* fail if both begemph and any of begemphphrase or begemphword are\n\t\t\t\t * defined */\n\t\t\t\tif ((*table)->emphRules[i][begWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both begemph and \"\n\t\t\t\t\t\t\t\"begemphword or begemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmph: {\n\t\t\t\tif ((*table)->emphRules[i][endWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both endemph and \"\n\t\t\t\t\t\t\t\"endemphword or endemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphPhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begPhraseOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphPhrase:\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1: {  // before\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word after already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word before\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {  // after\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word before already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word after\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CTO_LenEmphPhrase:\n\t\t\t\tif (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))\n\t\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\tcase CTO_EmphModeChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *emphmodechars = (*table)->emphModeChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > EMPHMODECHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", EMPHMODECHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Emphasis mode character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\temphmodechars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_NoEmphChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *noemphchars = (*table)->noEmphChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > NOEMPHCHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", NOEMPHCHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnoemphchars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn ok;\n\t\t}\n\t\tcase CTO_LetterSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->letterSign;\n\t\t\tif (!compileBrailleIndicator(file, \"letter sign\", CTO_LetterRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->letterSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoLetsignBefore:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNBEFORESIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsign:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsignAfter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNAFTERSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NumberSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->numberSign;\n\t\t\tif (!compileBrailleIndicator(file, \"number sign\", CTO_NumberRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->numberSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\n\t\tcase CTO_NumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric mode character undefined: %s\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_MidEndNumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Midendnumeric mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_MidEndNumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NumericNoContractChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric no contraction character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericNoContract;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NoContractSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->noContractSign;\n\t\t\tif (!compileBrailleIndicator(file, \"no contractions sign\", CTO_NoContractRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->noContractSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_SeqDelimiter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence delimiter character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqDelimiter;\n\t\t\t\t(*table)->usesSequences = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqBeforeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence before character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqBefore;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence after character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqAfter;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterPattern:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];\n\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterExpression:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor ((*table)->seqAfterExpressionLength = 0;\n\t\t\t\t\t(*table)->seqAfterExpressionLength < ruleChars.length;\n\t\t\t\t\t(*table)->seqAfterExpressionLength++)\n\t\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] =\n\t\t\t\t\t\truleChars.chars[(*table)->seqAfterExpressionLength];\n\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_CapsModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Capital mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_CapsMode;\n\t\t\t\t(*table)->hasCapsModeChars = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_BegComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->begComp;\n\t\t\tif (!compileBrailleIndicator(file, \"begin computer braille\", CTO_BegCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->begComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_EndComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->endComp;\n\t\t\tif (!compileBrailleIndicator(file, \"end computer braslle\", CTO_EndCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->endComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoCross:\n\t\t\tif (nocross) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"%s already specified.\", _lou_findOpcodeName(CTO_NoCross));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnocross = 1;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_Syllable:\n\t\t\t(*table)->syllables = 1;\n\t\tcase CTO_Always:\n\t\tcase CTO_LargeSign:\n\t\tcase CTO_WholeWord:\n\t\tcase CTO_PartWord:\n\t\tcase CTO_JoinNum:\n\t\tcase CTO_JoinableWord:\n\t\tcase CTO_LowWord:\n\t\tcase CTO_SuffixableWord:\n\t\tcase CTO_PrefixableWord:\n\t\tcase CTO_BegWord:\n\t\tcase CTO_BegMidWord:\n\t\tcase CTO_MidWord:\n\t\tcase CTO_MidEndWord:\n\t\tcase CTO_EndWord:\n\t\tcase CTO_PrePunc:\n\t\tcase CTO_PostPunc:\n\t\tcase CTO_BegNum:\n\t\tcase CTO_MidNum:\n\t\tcase CTO_EndNum:\n\t\tcase CTO_Repeated:\n\t\tcase CTO_RepWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleDots.length == 0)\n\t\t\t\t// check that all characters in a rule with `=` as second operand are\n\t\t\t\t// defined (or based on another character)\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\tgetChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tTranslationTableRule *r;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\tif (nocross) r->nocross = 1;\n\t\t\treturn 1;\n\t\t\t// if (opcode == CTO_MidNum)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c = getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tcase CTO_RepEndWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tCharsString dots;\n\t\t\tif (!getToken(file, &dots, \"dots,dots operand\")) return 0;\n\t\t\tint len = dots.length;\n\t\t\tfor (int k = 0; k < len - 1; k++) {\n\t\t\t\tif (dots.chars[k] == ',') {\n\t\t\t\t\tdots.length = k;\n\t\t\t\t\tif (!parseDots(file, &ruleDots, &dots)) return 0;\n\t\t\t\t\truleDots.chars[ruleDots.length++] = ',';\n\t\t\t\t\tk++;\n\t\t\t\t\tif (k == len - 1 && dots.chars[k] == '=') {\n\t\t\t\t\t\t// check that all characters are defined (or based on another\n\t\t\t\t\t\t// character)\n\t\t\t\t\t\tfor (int l = 0; l < ruleChars.length; l++) {\n\t\t\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\t\t\tgetChar(ruleChars.chars[l], *table, NULL);\n\t\t\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[l], 1, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tCharsString x, y;\n\t\t\t\t\t\tx.length = 0;\n\t\t\t\t\t\twhile (k < len) x.chars[x.length++] = dots.chars[k++];\n\t\t\t\t\t\tif (parseDots(file, &y, &x))\n\t\t\t\t\t\t\tfor (int l = 0; l < y.length; l++)\n\t\t\t\t\t\t\t\truleDots.chars[ruleDots.length++] = y.chars[l];\n\t\t\t\t\t}\n\t\t\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before,\n\t\t\t\t\t\t\tNULL, NULL, noback, nofor, table);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase CTO_CompDots:\n\t\tcase CTO_Comp6: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.length != 1) {\n\t\t\t\tcompileError(file, \"first operand must be 1 character\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed on comp6 rules\");\n\t\t\t}\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\tNULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_ExactDots:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.chars[0] != '@') {\n\t\t\t\tcompileError(file, \"The operand must begin with an at sign (@)\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 1; k < ruleChars.length; k++)\n\t\t\t\tscratchPad.chars[k - 1] = ruleChars.chars[k];\n\t\t\tscratchPad.length = ruleChars.length - 1;\n\t\t\tif (!parseDots(file, &ruleDots, &scratchPad)) return 0;\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_CapsNoCont: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\truleChars.length = 1;\n\t\t\truleChars.chars[0] = 'a';\n\t\t\tif (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,\n\t\t\t\t\t\t&ruleOffset, NULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->capsNoCont = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Replace:\n\t\t\tif (getRuleCharsText(file, &ruleChars)) {\n\t\t\t\tif (atEndOfLine(file))\n\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\telse {\n\t\t\t\t\tgetRuleDotsText(file, &ruleDots);\n\t\t\t\t\tif (ruleDots.chars[0] == '#')\n\t\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\t\telse if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')\n\t\t\t\t\t\tmemmove(&ruleDots.chars[0], &ruleDots.chars[1],\n\t\t\t\t\t\t\t\truleDots.length-- * CHARSIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\tputChar(file, ruleChars.chars[k], table, NULL);\n\t\t\tfor (int k = 0; k < ruleDots.length; k++)\n\t\t\t\tputChar(file, ruleDots.chars[k], table, NULL);\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_Correct:\n\t\t\t(*table)->corrections = 1;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass2:\n\t\t\tif ((*table)->numPasses < 2) (*table)->numPasses = 2;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass3:\n\t\t\tif ((*table)->numPasses < 3) (*table)->numPasses = 3;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass4:\n\t\t\tif ((*table)->numPasses < 4) (*table)->numPasses = 4;\n\t\tdoPass:\n\t\tcase CTO_Context:\n\t\t\tif (!(nofor || noback)) {\n\t\t\t\tcompileError(file, \"%s or %s must be specified.\",\n\t\t\t\t\t\t_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn compilePassOpcode(file, opcode, noback, nofor, table);\n\t\tcase CTO_Contraction:\n\t\tcase CTO_NoCont:\n\t\tcase CTO_CompBrl:\n\t\tcase CTO_Literal:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\t// check that all characters in a compbrl, contraction,\n\t\t\t// nocont or literal rule are defined (or based on another\n\t\t\t// character)\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_MultInd: {\n\t\t\truleChars.length = 0;\n\t\t\tif (!getToken(file, &token, \"multiple braille indicators\") ||\n\t\t\t\t\t!parseDots(file, &cells, &token))\n\t\t\t\treturn 0;\n\t\t\twhile (getToken(file, &token, \"multind opcodes\")) {\n\t\t\t\topcode = getOpcode(file, &token);\n\t\t\t\tif (opcode == CTO_None) {\n\t\t\t\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {\n\t\t\t\t\tcompileError(file, \"Not a braille indicator opcode.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\truleChars.chars[ruleChars.length++] = (widechar)opcode;\n\t\t\t\tif (atEndOfLine(file)) break;\n\t\t\t}\n\t\t\treturn addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,\n\t\t\t\t\tNULL, noback, nofor, table);\n\t\t}\n\n\t\tcase CTO_Class:\n\t\t\tcompileWarning(file, \"class is deprecated, use attribute instead\");\n\t\tcase CTO_Attribute: {\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(\n\t\t\t\t\t\tfile, \"nofor and noback not allowed before class/attribute\");\n\t\t\t}\n\t\t\tif ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||\n\t\t\t\t\t(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"attribute and class rules must not be both present in a table\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (opcode == CTO_Class)\n\t\t\t\t(*table)->usesAttributeOrClass = 2;\n\t\t\telse\n\t\t\t\t(*table)->usesAttributeOrClass = 1;\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(file, \"Expected %s\", \"attribute name\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tTranslationTableCharacterAttributes attribute = 0;\n\t\t\t{\n\t\t\t\tint attrNumber = -1;\n\t\t\t\tswitch (token.chars[0]) {\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tattrNumber = token.chars[0] - '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attrNumber >= 0) {\n\t\t\t\t\tif (opcode == CTO_Class) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid class name: may not contain digits, use \"\n\t\t\t\t\t\t\t\t\"attribute instead of class\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (token.length > 1 || attrNumber > 7) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid attribute name: must be a digit between 0 and 7 \"\n\t\t\t\t\t\t\t\t\"or a word containing only letters\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(*table)->numberedAttributes[attrNumber])\n\t\t\t\t\t\t// attribute not used before yet: assign it a value\n\t\t\t\t\t\t(*table)->numberedAttributes[attrNumber] =\n\t\t\t\t\t\t\t\tgetNextNumberedAttribute(*table);\n\t\t\t\t\tattribute = (*table)->numberedAttributes[attrNumber];\n\t\t\t\t} else {\n\t\t\t\t\tconst CharacterClass *namedAttr = findCharacterClass(&token, *table);\n\t\t\t\t\tif (!namedAttr) {\n\t\t\t\t\t\t// no class with that name: create one\n\t\t\t\t\t\tnamedAttr = addCharacterClass(\n\t\t\t\t\t\t\t\tfile, &token.chars[0], token.length, *table, 1);\n\t\t\t\t\t\tif (!namedAttr) return 0;\n\t\t\t\t\t}\n\t\t\t\t\t// there is a class with that name or a new class was successfully\n\t\t\t\t\t// created\n\t\t\t\t\tattribute = namedAttr->attribute;\n\t\t\t\t\tif (attribute == CTC_UpperCase || attribute == CTC_LowerCase)\n\t\t\t\t\t\tattribute |= CTC_Letter;\n\t\t\t\t}\n\t\t\t}\n\t\t\tCharsString characters;\n\t\t\tif (!getCharacters(file, &characters)) return 0;\n\t\t\tfor (int i = 0; i < characters.length; i++) {\n\t\t\t\t// get the character from the table, or if it is not defined yet,\n\t\t\t\t// define it\n\t\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t\tputChar(file, characters.chars[i], table, NULL);\n\t\t\t\t// set the attribute\n\t\t\t\tcharacter->attributes |= attribute;\n\t\t\t\t// also set the attribute on the associated dots (if any)\n\t\t\t\tif (character->basechar)\n\t\t\t\t\tcharacter = (TranslationTableCharacter *)&(*table)\n\t\t\t\t\t\t\t\t\t\t->ruleArea[character->basechar];\n\t\t\t\tif (character->definitionRule) {\n\t\t\t\t\tTranslationTableRule *defRule =\n\t\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t\tif (defRule->dotslen == 1) {\n\t\t\t\t\t\tTranslationTableCharacter *dots =\n\t\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], *table);\n\t\t\t\t\t\tif (dots) dots->attributes |= attribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\t\t{\n\t\t\t\tTranslationTableCharacterAttributes *attributes;\n\t\t\t\tconst CharacterClass *class;\n\t\t\tcase CTO_After:\n\t\t\t\tattributes = &after;\n\t\t\t\tgoto doBeforeAfter;\n\t\t\tcase CTO_Before:\n\t\t\t\tattributes = &before;\n\t\t\tdoBeforeAfter:\n\t\t\t\tif (!(*table)->characterClasses) {\n\t\t\t\t\tif (!allocateCharacterClasses(*table)) return 0;\n\t\t\t\t}\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(class = findCharacterClass(&token, *table))) {\n\t\t\t\t\tcompileError(file, \"attribute not defined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*attributes |= class->attribute;\n\t\t\t\tgoto doOpcode;\n\t\t\t}\n\t\tcase CTO_Base:\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed before base\");\n\t\t\t}\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"base opcode must be followed by a valid attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst CharacterClass *mode = findCharacterClass(&token, *table);\n\t\t\tif (!mode) {\n\t\t\t\tmode = addCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\tif (!mode) return 0;\n\t\t\t}\n\t\t\tif (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&\n\t\t\t\t\tmode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"base opcode must be followed by \\\"uppercase\\\", \\\"digit\\\", or a \"\n\t\t\t\t\t\t\"custom attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"Exactly one character followed by one base character is \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tTranslationTableOffset characterOffset;\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\tputChar(file, token.chars[0], table, &characterOffset);\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file, \"Exactly one base character is required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (character->definitionRule) {\n\t\t\t\tTranslationTableRule *prevRule =\n\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: Character already defined (%s). The base rule will take \"\n\t\t\t\t\t\t\"precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n\t\t\t\tcharacter->definitionRule = 0;\n\t\t\t}\n\t\t\tTranslationTableOffset basechar;\n\t\t\tputChar(file, token.chars[0], table, &basechar);\n\t\t\t// putChar may have moved table, so make sure character is still valid\n\t\t\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset];\n\t\t\tif (character->basechar) {\n\t\t\t\tif (character->basechar == basechar &&\n\t\t\t\t\t\tcharacter->mode == mode->attribute) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"%s:%d: Duplicate base rule.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber);\n\t\t\t\t} else {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\t\"%s:%d: A different base rule already exists for this \"\n\t\t\t\t\t\t\t\"character (%s). The new rule will take precedence.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\t\tprintSource(\n\t\t\t\t\t\t\t\t\tfile, character->sourceFile, character->sourceLine));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharacter->basechar = basechar;\n\t\t\tcharacter->mode = mode->attribute;\n\t\t\tcharacter->sourceFile = file->sourceFile;\n\t\t\tcharacter->sourceLine = file->lineNumber;\n\t\t\t/* some other processing is done at the end of the compilation, in\n\t\t\t * finalizeTable() */\n\t\t\treturn 1;\n\t\tcase CTO_EmpMatchBefore:\n\t\t\tbefore |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_EmpMatchAfter:\n\t\t\tafter |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\n\t\tcase CTO_SwapCc:\n\t\tcase CTO_SwapCd:\n\t\tcase CTO_SwapDd:\n\t\t\treturn compileSwap(file, opcode, noback, nofor, table);\n\t\tcase CTO_Hyphen:\n\t\tcase CTO_DecPoint:\n\t\t\t//\tcase CTO_Apostrophe:\n\t\t\t//\tcase CTO_Initial:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleChars.length != 1 || ruleDots.length < 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"One Unicode character and at least one cell are \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\t\t// if (opcode == CTO_DecPoint)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c =\n\t\t\t//   getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tdefault:\n\t\t\tcompileError(file, \"unimplemented opcode.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 777,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 787,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& splits = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& weights = context->input(2);\n    bool use_weights = weights.NumElements() > 0;\n    bool is_1d = false;\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n\n    const auto splits_values = splits.flat<int64_t>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int num_batches = splits.NumElements() - 1;\n    int num_values = values.NumElements();\n\n    OP_REQUIRES(\n        context, num_batches > 0,\n        errors::InvalidArgument(\n            \"Must provide at least 2 elements for the splits argument\"));\n    OP_REQUIRES(context, splits_values(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits_values(0)));\n    OP_REQUIRES(context, splits_values(num_batches) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits_values(num_batches), \" instead of \", num_values));\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n    T max_value = 0;\n    int batch_idx = 0;\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits_values(batch_idx)) {\n        batch_idx++;\n      }\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch_idx - 1][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch_idx - 1][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch_idx - 1][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 31,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"SetUnknownShape: Missing context\");\n    }\n    if (output_port < 0 || output_port >= ctx->num_outputs()) {\n      return errors::InvalidArgument(\n          \"SetUnknownShape: output_port must be in [0, \", ctx->num_outputs(),\n          \") but was \", output_port);\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 61,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n\n        /* Iterate over all segments in given topic */\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n\n            /* It is very important to disallow wildcards when publishing.\n             * We will not catch EVERY misuse this lazy way, but enough to hinder\n             * explosive recursion.\n             * Terminating wildcards MAY still get triggered along the way, if for\n             * instace the error is found late while iterating the topic segments. */\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n\n            /* Do we have a terminating wildcard child? */\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n\n                /* Add this topic to triggered */\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    /* If we already have 64 triggered topics make sure to drain it here */\n                    if (numTriggeredTopics == 64) {\n                        drain();\n                    }\n\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n\n            /* Do we have a wildcard child? */\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                /* Stop trying to match by exact string */\n                return;\n            }\n\n            iterator = it->second;\n        }\n\n        /* If we went all the way we matched exactly */\n        iterator->messages[messageId] = message;\n\n        /* Add this topic to triggered */\n        if (!iterator->triggered) {\n            /* If we already have 64 triggered topics make sure to drain it here */\n            if (numTriggeredTopics == 64) {\n                drain();\n            }\n\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 79,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n\t\t\t       const pj_uint8_t *pkt, const pj_uint8_t *start,\n\t\t\t       const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p + 4 > max)\n    \treturn PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 155,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor* hypothesis_indices;\n    const Tensor* hypothesis_values;\n    const Tensor* hypothesis_shape;\n    const Tensor* truth_indices;\n    const Tensor* truth_values;\n    const Tensor* truth_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_indices\", &hypothesis_indices));\n    OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_values\", &hypothesis_values));\n    OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_shape\", &hypothesis_shape));\n    OP_REQUIRES_OK(ctx, ctx->input(\"truth_indices\", &truth_indices));\n    OP_REQUIRES_OK(ctx, ctx->input(\"truth_values\", &truth_values));\n    OP_REQUIRES_OK(ctx, ctx->input(\"truth_shape\", &truth_shape));\n\n    OP_REQUIRES_OK(\n        ctx, ValidateShapes(ctx, *hypothesis_indices, *hypothesis_values,\n                            *hypothesis_shape, *truth_indices, *truth_values,\n                            *truth_shape));\n\n    TensorShape hypothesis_st_shape;\n    OP_REQUIRES_OK(ctx,\n                   TensorShapeUtils::MakeShape(\n                       hypothesis_shape->vec<int64_t>().data(),\n                       hypothesis_shape->NumElements(), &hypothesis_st_shape));\n    TensorShape truth_st_shape;\n    OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n                            truth_shape->vec<int64_t>().data(),\n                            truth_shape->NumElements(), &truth_st_shape));\n\n    // Assume indices are sorted in row-major order.\n    std::vector<int64_t> sorted_order(truth_st_shape.dims());\n    std::iota(sorted_order.begin(), sorted_order.end(), 0);\n\n    sparse::SparseTensor hypothesis;\n    OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create(\n                            *hypothesis_indices, *hypothesis_values,\n                            hypothesis_st_shape, sorted_order, &hypothesis));\n\n    sparse::SparseTensor truth;\n    OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create(\n                            *truth_indices, *truth_values, truth_st_shape,\n                            sorted_order, &truth));\n\n    // Group dims 0, 1, ..., RANK - 1.  The very last dim is assumed\n    // to store the variable length sequences.\n    std::vector<int64_t> group_dims(truth_st_shape.dims() - 1);\n    std::iota(group_dims.begin(), group_dims.end(), 0);\n\n    TensorShape output_shape;\n    for (int d = 0; d < static_cast<int>(group_dims.size()); ++d) {\n      output_shape.AddDim(std::max(hypothesis_st_shape.dim_size(d),\n                                   truth_st_shape.dim_size(d)));\n    }\n    const auto output_elements = output_shape.num_elements();\n    OP_REQUIRES(\n        ctx, output_elements > 0,\n        errors::InvalidArgument(\"Got output shape \", output_shape.DebugString(),\n                                \" which has 0 elements\"));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"output\", output_shape, &output));\n    auto output_t = output->flat<float>();\n    output_t.setZero();\n\n    std::vector<int64_t> output_strides(output_shape.dims());\n    output_strides[output_shape.dims() - 1] = 1;\n    for (int d = output_shape.dims() - 2; d >= 0; --d) {\n      output_strides[d] = output_strides[d + 1] * output_shape.dim_size(d + 1);\n    }\n\n    auto hypothesis_grouper = hypothesis.group(group_dims);\n    auto truth_grouper = truth.group(group_dims);\n\n    auto hypothesis_iter = hypothesis_grouper.begin();\n    auto truth_iter = truth_grouper.begin();\n\n    auto cmp = std::equal_to<T>();\n\n    while (hypothesis_iter != hypothesis_grouper.end() &&\n           truth_iter != truth_grouper.end()) {\n      sparse::Group truth_i = *truth_iter;\n      sparse::Group hypothesis_j = *hypothesis_iter;\n      std::vector<int64_t> g_truth = truth_i.group();\n      std::vector<int64_t> g_hypothesis = hypothesis_j.group();\n      auto truth_seq = truth_i.values<T>();\n      auto hypothesis_seq = hypothesis_j.values<T>();\n\n      if (g_truth == g_hypothesis) {\n        auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                      output_strides.begin(), int64_t{0});\n        OP_REQUIRES(\n            ctx, 0 <= loc && loc < output_elements,\n            errors::Internal(\"Got an inner product \", loc,\n                             \" which would require writing to outside of \"\n                             \"the buffer for the output tensor (max elements \",\n                             output_elements, \")\"));\n        output_t(loc) =\n            gtl::LevenshteinDistance<T>(truth_seq, hypothesis_seq, cmp);\n        if (normalize_) output_t(loc) /= truth_seq.size();\n\n        ++hypothesis_iter;\n        ++truth_iter;\n      } else if (g_truth > g_hypothesis) {  // zero-length truth\n        auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),\n                                      output_strides.begin(), int64_t{0});\n        OP_REQUIRES(\n            ctx, 0 <= loc && loc < output_elements,\n            errors::Internal(\"Got an inner product \", loc,\n                             \" which would require writing to outside of \"\n                             \"the buffer for the output tensor (max elements \",\n                             output_elements, \")\"));\n        output_t(loc) = hypothesis_seq.size();\n        if (normalize_ && output_t(loc) != 0.0f) {\n          output_t(loc) = std::numeric_limits<float>::infinity();\n        }\n        ++hypothesis_iter;\n      } else {  // zero-length hypothesis\n        auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                      output_strides.begin(), int64_t{0});\n        OP_REQUIRES(\n            ctx, 0 <= loc && loc < output_elements,\n            errors::Internal(\"Got an inner product \", loc,\n                             \" which would require writing to outside of \"\n                             \"the buffer for the output tensor (max elements \",\n                             output_elements, \")\"));\n        output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();\n        ++truth_iter;\n      }\n    }\n    while (hypothesis_iter != hypothesis_grouper.end()) {  // zero-length truths\n      sparse::Group hypothesis_j = *hypothesis_iter;\n      std::vector<int64_t> g_hypothesis = hypothesis_j.group();\n      auto hypothesis_seq = hypothesis_j.values<T>();\n      auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),\n                                    output_strides.begin(), int64_t{0});\n      OP_REQUIRES(\n          ctx, 0 <= loc && loc < output_elements,\n          errors::Internal(\"Got an inner product \", loc,\n                           \" which would require writing to outside of the \"\n                           \"buffer for the output tensor (max elements \",\n                           output_elements, \")\"));\n      output_t(loc) = hypothesis_seq.size();\n      if (normalize_ && output_t(loc) != 0.0f) {\n        output_t(loc) = std::numeric_limits<float>::infinity();\n      }\n      ++hypothesis_iter;\n    }\n    while (truth_iter != truth_grouper.end()) {  // missing hypotheses\n      sparse::Group truth_i = *truth_iter;\n      std::vector<int64_t> g_truth = truth_i.group();\n      auto truth_seq = truth_i.values<T>();\n      auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                    output_strides.begin(), int64_t{0});\n      OP_REQUIRES(\n          ctx, 0 <= loc && loc < output_elements,\n          errors::Internal(\"Got an inner product \", loc,\n                           \" which would require writing to outside of the \"\n                           \"buffer for the output tensor (max elements \",\n                           output_elements, \")\"));\n      output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();\n      ++truth_iter;\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 157,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n\n  if (h && mt_del(mrb, h, mid)) {\n    mrb_mc_clear_by_class(mrb, c);\n    return;\n  }\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 173,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 197,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length += dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }\n    }\n\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n\n    p = &src[0];\n\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n\n\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n\n    return NJS_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 223,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "void HierarchicalBitmapRequester::PrepareForEncoding(void)\n{\n#if ACCUSOFT_CODE\n  \n  BuildCommon();\n\n  if (m_ppEncodingMCU == NULL) {\n    m_ppEncodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount *8);\n    memset(m_ppEncodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n  \n  if (m_ppDownsampler == NULL) {\n    m_ppDownsampler = (class DownsamplerBase **)m_pEnviron->AllocMem(sizeof(class DownsamplerBase *) * m_ucCount);\n    memset(m_ppDownsampler,0,sizeof(class DownsamplerBase *) * m_ucCount);\n    \n    for(UBYTE i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n\n      if (sx > 1 || sy > 1) {\n        m_ppDownsampler[i] = DownsamplerBase::CreateDownsampler(m_pEnviron,sx,sy,\n                                                                m_ulPixelWidth,m_ulPixelHeight,\n                                                                m_pFrame->TablesOf()->\n                                                                isDownsamplingInterpolated());\n        m_bSubsampling     = true;\n      }\n    }\n  }\n\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForEncoding();\n#endif\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 247,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char * data_signed = NULL, client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n\n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n        break;\n      }\n\n      // Step 1\n      if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key)))) {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"sig\"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n          } else {\n            message = msprintf(\"attStmt map element %d key is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n            json_array_append_new(j_error, json_string(message));\n            o_free(message);\n            break;\n          }\n        } else {\n          message = msprintf(\"attStmt map element %d key is not a string\", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'x5c' invalid format\"));\n        break;\n      }\n      att_cert = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n        break;\n      }\n      if (json_object_get(j_params, \"root-ca-list\") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) {\n        json_array_append_new(j_error, json_string(\"Unrecognized certificate authority\"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {\n          message = msprintf(\"Unrecognized certificate autohority: %.*s\", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - %s\", message);\n          o_free(message);\n          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)\");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n        break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n\n      if ((data_signed = o_malloc(rpid_hash_len+client_data_hash_len+credential_id_len+cert_x_len+cert_y_len+2)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error allocating data_signed\");\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        break;\n      }\n\n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n\n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n\n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n\n      memcpy(data_signed+data_signed_offset, credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n\n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n\n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n      data_signed_offset+=cert_x_len;\n\n      memcpy(data_signed+data_signed_offset, cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n\n      // Let's verify sig over data_signed\n      data.data = data_signed;\n      data.size = data_signed_offset;\n\n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n\n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n\n    } while (0);\n    o_free(data_signed);\n\n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&att_cert);\n    }\n\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 249,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 253,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\t/* Convert PORT command's argument to IP address + port */\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsnprintf(addr, sizeof(addr), \"%d.%d.%d.%d\", a, b, c, d);\n\n\t/* Check IPv4 address using inet_aton(), throw away converted result */\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 300,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, \n\t\t\t\t      pjstun_msg *msg)\n{\n    pj_uint16_t msg_type, msg_len;\n    char *p_attr;\n    int attr_max_cnt = PJ_ARRAY_SIZE(msg->attr);\n\n    PJ_CHECK_STACK();\n\n    msg->hdr = (pjstun_msg_hdr*)buf;\n    msg_type = pj_ntohs(msg->hdr->type);\n\n    switch (msg_type) {\n    case PJSTUN_BINDING_REQUEST:\n    case PJSTUN_BINDING_RESPONSE:\n    case PJSTUN_BINDING_ERROR_RESPONSE:\n    case PJSTUN_SHARED_SECRET_REQUEST:\n    case PJSTUN_SHARED_SECRET_RESPONSE:\n    case PJSTUN_SHARED_SECRET_ERROR_RESPONSE:\n\tbreak;\n    default:\n\tPJ_LOG(4,(THIS_FILE, \"Error: unknown msg type %d\", msg_type));\n\treturn PJLIB_UTIL_ESTUNINMSGTYPE;\n    }\n\n    msg_len = pj_ntohs(msg->hdr->length);\n    if (msg_len != buf_len - sizeof(pjstun_msg_hdr)) {\n\tPJ_LOG(4,(THIS_FILE, \"Error: invalid msg_len %d (expecting %d)\", \n\t\t\t     msg_len, buf_len - sizeof(pjstun_msg_hdr)));\n\treturn PJLIB_UTIL_ESTUNINMSGLEN;\n    }\n\n    msg->attr_count = 0;\n    p_attr = (char*)buf + sizeof(pjstun_msg_hdr);\n\n    while (msg_len > 0 && msg->attr_count < attr_max_cnt) {\n\tpjstun_attr_hdr **attr = &msg->attr[msg->attr_count];\n\tpj_uint32_t len;\n\tpj_uint16_t attr_type;\n\n\t*attr = (pjstun_attr_hdr*)p_attr;\n\tlen = pj_ntohs((pj_uint16_t) ((*attr)->length)) + sizeof(pjstun_attr_hdr);\n\tlen = (len + 3) & ~3;\n\n\tif (msg_len < len) {\n\t    PJ_LOG(4,(THIS_FILE, \"Error: length mismatch in attr %d\", \n\t\t\t\t msg->attr_count));\n\t    return PJLIB_UTIL_ESTUNINATTRLEN;\n\t}\n\n\tattr_type = pj_ntohs((*attr)->type);\n\tif (attr_type > PJSTUN_ATTR_REFLECTED_FROM &&\n\t    attr_type != PJSTUN_ATTR_XOR_MAPPED_ADDR)\n\t{\n\t    PJ_LOG(5,(THIS_FILE, \"Warning: unknown attr type %x in attr %d. \"\n\t\t\t\t \"Attribute was ignored.\",\n\t\t\t\t attr_type, msg->attr_count));\n\t}\n\n\tmsg_len = (pj_uint16_t)(msg_len - len);\n\tp_attr += len;\n\t++msg->attr_count;\n    }\n    if (msg->attr_count == attr_max_cnt) {\n\tPJ_LOG(4, (THIS_FILE, \"Warning: max number attribute %d reached.\",\n\t\t   attr_max_cnt));\n    }\n\n    return PJ_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 304,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tuint\taddr, length;\n\tuint\talen;\n\tuint\tj, nbytes, linebytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\t/* We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip   = i2c_dp_last_chip;\n\taddr   = i2c_dp_last_addr;\n\talen   = i2c_dp_last_alen;\n\tlength = i2c_dp_last_length;\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\tif ((flag & CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.\n\t\t */\n\n\t\t/*\n\t\t * I2C chip address\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * I2C data address within the chip.  This can be 1 or\n\t\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen > 3)\n\t\t\treturn CMD_RET_USAGE;\n\n\t\t/*\n\t\t * If another parameter, it is the length to display.\n\t\t * Length is the number of objects, not number of bytes.\n\t\t */\n\t\tif (argc > 3)\n\t\t\tlength = hextoul(argv[3], NULL);\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\n\t/*\n\t * Print the lines.\n\t *\n\t * We buffer all read data, so we can make sure data is read only\n\t * once.\n\t */\n\tnbytes = length;\n\tdo {\n\t\tunsigned char\tlinebuf[DISP_LINE_LEN];\n\t\tunsigned char\t*cp;\n\n\t\tlinebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, linebuf, linebytes);\n#else\n\t\tret = i2c_read(chip, addr, alen, linebuf, linebytes);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\t\telse {\n\t\t\tprintf(\"%04x:\", addr);\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tprintf(\" %02x\", *cp++);\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tputs (\"    \");\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tif ((*cp < 0x20) || (*cp > 0x7e))\n\t\t\t\t\tputs (\".\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%c\", *cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tputc ('\\n');\n\t\t}\n\t\tnbytes -= linebytes;\n\t} while (nbytes > 0);\n\n\ti2c_dp_last_chip   = chip;\n\ti2c_dp_last_addr   = addr;\n\ti2c_dp_last_alen   = alen;\n\ti2c_dp_last_length = length;\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 314,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; /* insert, delete */\n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; /* left, right */\n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 318,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n\n    msgmore((long)count);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 320,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\n\t// this will make code much easier to read\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\n\t// we're already out of memory here\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\t\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t// no ST3 module\n\t\n\tf.readByte(); // skip something\n\tf.readByte(); // skip something\n\t\n\theader->ordnum = f.readWord(); // number of positions in order list (songlength)\n\t\n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\theader->insnum = f.readWord(); // number of instruments\n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); // number of patterns\n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\t\n\tmp_sint32 flags = f.readWord(); // st3 flags\t\n\n\tmp_sint32 Cvt = f.readWord();\n\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\t\t\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\t\n\t/*mp_uword Ffi = */f.readWord();\n\t\n\tf.read(header->sig,1,4);\n\t\n\theader->mainvol = module->vol64to255(f.readByte()); // initial main volume\n\t\n\theader->tempo = f.readByte(); // tempo\n\t\n\theader->speed = f.readByte(); // speed\n\t\n\tf.readByte(); // global volume? skipped...\n\t\n\tf.readByte(); // ignore GUS click removal\n\t\n\t/*mp_ubyte dp = */f.readByte();\n\t\n\tf.readDword();\t// skip something\n\tf.readDword();\t// skip something\n\tf.readWord();\t// skip some more...\n\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\t\n\tmp_sint32 numChannels = 0;\n\t\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\t\n\theader->channum = numChannels; // number of channels\n\t\n\tf.read(orders,1,header->ordnum);\n\t\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\t\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\t\n\theader->ordnum = j; // final songlength\n\t\n\tdelete[] orders;\n\t\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\t\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\tf.readWords(insParaPtrs,header->insnum);\n\t\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\t\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\t\n\tf.readWords(patParaPtrs,header->patnum);\n\t\n\t//for (i = 0; i < header->insnum; i++)\n\t//{\n\t//\tprintf(\"%x\\n\",insParaPtrs[i]*16);\n\t//}\n\t\t\n\t//////////////////////\n\t// read instruments //\n\t//////////////////////\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\t\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\t\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\n\t\t\t// We can only read that if it's a sample\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\t\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t// read dos filename\n\t\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\t\n\t\t\t\t// stupid fileoffsets\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\t\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\t\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\t\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\t\n\t\t\t\tf.readByte(); // skip something\n\t\t\t\t\n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; // packing\n\t\t\t\t\n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\t\n\t\t\t\t// looping\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 16 bit sample\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\t\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\n\t\t\t\tf.readDword(); // skip something\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip two internal words\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip internal dword\n\n\t\t\t\tf.read(instr[i].name,1,28); // instrument name\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip signature\n\t\t\t\t\n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t// read dos filename\n\t\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\t\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); // skip something\n\t\t\t\tf.readByte(); // skip packing\n\t\t\t\t\n\t\t\t\tf.readByte();\n\t\t\t\t\n\t\t\t\tf.readDword();\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip something\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip two internal words\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip internal dword\n\n\t\t\t\tf.read(instr[i].name,1,28); // instrument name\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip signature\t\t\t\t\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\t\n\t//////////////////////\n\t// read patterns\t//\n\t//////////////////////\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\t\n\tmp_uint32 songMaxChannels = 1;\n\t\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\t\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\t\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\t\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\t\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\t\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\t\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\t\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\t\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\t// one more safety net for incorrectly saved pattern sizes\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\t\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\t\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmaxChannels++;\n\t\t\t\t\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\t\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\t\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t\t\n\t\t}\n\t\t\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t\t\n\t\t\n\t}\n\t\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\t\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\t\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\t\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\tif (adpcm)\n\t\t\t\t// no longer needed\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\t\t\t\t\t\n\t\t\ts++;\n\t\t\t\n\t\t}\n\n\t}\n\t\n\tdelete[] samplePtrs;\n\t\n\theader->smpnum = s;\n\t\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\t\n\tmodule->setDefaultPanning();\n\t\n\tmodule->postProcessSamples();\n\t\n\treturn MP_OK;\t\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 324,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "ex_retab(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tgot_tab = FALSE;\n    long\tnum_spaces = 0;\n    long\tnum_tabs;\n    long\tlen;\n    long\tcol;\n    long\tvcol;\n    long\tstart_col = 0;\t\t// For start of white-space string\n    long\tstart_vcol = 0;\t\t// For start of white-space string\n    long\told_len;\n    char_u\t*ptr;\n    char_u\t*new_line = (char_u *)1; // init to non-NULL\n    int\t\tdid_undo;\t\t// called u_save for current line\n#ifdef FEAT_VARTABS\n    int\t\t*new_vts_array = NULL;\n    char_u\t*new_ts_str;\t\t// string value of tab argument\n#else\n    int\t\ttemp;\n    int\t\tnew_ts;\n#endif\n    int\t\tsave_list;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line = 0;\t\t// last changed line\n\n    save_list = curwin->w_p_list;\n    curwin->w_p_list = 0;\t    // don't want list mode here\n\n#ifdef FEAT_VARTABS\n    new_ts_str = eap->arg;\n    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)\n\treturn;\n    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n\t++(eap->arg);\n\n    // This ensures that either new_vts_array and new_ts_str are freshly\n    // allocated, or new_vts_array points to an existing array and new_ts_str\n    // is null.\n    if (new_vts_array == NULL)\n    {\n\tnew_vts_array = curbuf->b_p_vts_array;\n\tnew_ts_str = NULL;\n    }\n    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    ptr = eap->arg;\n    new_ts = getdigits(&ptr);\n    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > TABSTOP_MAX)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);\n\tcol = 0;\n\tvcol = 0;\n\tdid_undo = FALSE;\n\tfor (;;)\n\t{\n\t    if (VIM_ISWHITE(ptr[col]))\n\t    {\n\t\tif (!got_tab && num_spaces == 0)\n\t\t{\n\t\t    // First consecutive white-space\n\t\t    start_vcol = vcol;\n\t\t    start_col = col;\n\t\t}\n\t\tif (ptr[col] == ' ')\n\t\t    num_spaces++;\n\t\telse\n\t\t    got_tab = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (got_tab || (eap->forceit && num_spaces > 1))\n\t\t{\n\t\t    // Retabulate this string of white-space\n\n\t\t    // len is virtual length of white string\n\t\t    len = num_spaces = vcol - start_vcol;\n\t\t    num_tabs = 0;\n\t\t    if (!curbuf->b_p_et)\n\t\t    {\n#ifdef FEAT_VARTABS\n\t\t\tint t, s;\n\n\t\t\ttabstop_fromto(start_vcol, vcol,\n\t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n\t\t\tnum_tabs = t;\n\t\t\tnum_spaces = s;\n#else\n\t\t\ttemp = new_ts - (start_vcol % new_ts);\n\t\t\tif (num_spaces >= temp)\n\t\t\t{\n\t\t\t    num_spaces -= temp;\n\t\t\t    num_tabs++;\n\t\t\t}\n\t\t\tnum_tabs += num_spaces / new_ts;\n\t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n#endif\n\t\t    }\n\t\t    if (curbuf->b_p_et || got_tab ||\n\t\t\t\t\t(num_spaces + num_tabs < len))\n\t\t    {\n\t\t\tif (did_undo == FALSE)\n\t\t\t{\n\t\t\t    did_undo = TRUE;\n\t\t\t    if (u_save((linenr_T)(lnum - 1),\n\t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n\t\t\t    {\n\t\t\t\tnew_line = NULL;\t// flag out-of-memory\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// len is actual number of white characters used\n\t\t\tlen = num_spaces + num_tabs;\n\t\t\told_len = (long)STRLEN(ptr);\n\t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n\t\t\tif (new_line == NULL)\n\t\t\t    break;\n\t\t\tif (start_col > 0)\n\t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n\t\t\tmch_memmove(new_line + start_col + len,\n\t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n\t\t\tptr = new_line + start_col;\n\t\t\tfor (col = 0; col < len; col++)\n\t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n\t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n\t\t\t    // \"new_line\" may have been copied\n\t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n\t\t\tif (first_line == 0)\n\t\t\t    first_line = lnum;\n\t\t\tlast_line = lnum;\n\t\t\tptr = new_line;\n\t\t\tcol = start_col + len;\n\t\t    }\n\t\t}\n\t\tgot_tab = FALSE;\n\t\tnum_spaces = 0;\n\t    }\n\t    if (ptr[col] == NUL)\n\t\tbreak;\n\t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n\t    if (vcol >= MAXCOL)\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    else\n\t\t++col;\n\t}\n\tif (new_line == NULL)\t\t    // out of memory\n\t    break;\n\tline_breakcheck();\n    }\n    if (got_int)\n\temsg(_(e_interrupted));\n\n#ifdef FEAT_VARTABS\n    // If a single value was given then it can be considered equal to\n    // either the value of 'tabstop' or the value of 'vartabstop'.\n    if (tabstop_count(curbuf->b_p_vts_array) == 0\n\t&& tabstop_count(new_vts_array) == 1\n\t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n\t; // not changed\n    else if (tabstop_count(curbuf->b_p_vts_array) > 0\n        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n\t; // not changed\n    else\n\tredraw_curbuf_later(NOT_VALID);\n#else\n    if (curbuf->b_p_ts != new_ts)\n\tredraw_curbuf_later(NOT_VALID);\n#endif\n    if (first_line != 0)\n\tchanged_lines(first_line, 0, last_line + 1, 0L);\n\n    curwin->w_p_list = save_list;\t// restore 'list'\n\n#ifdef FEAT_VARTABS\n    if (new_ts_str != NULL)\t\t// set the new tabstop\n    {\n\t// If 'vartabstop' is in use or if the value given to retab has more\n\t// than one tabstop then update 'vartabstop'.\n\tint *old_vts_ary = curbuf->b_p_vts_array;\n\n\tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n\t{\n\t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n\t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n\t    curbuf->b_p_vts_array = new_vts_array;\n\t    vim_free(old_vts_ary);\n\t}\n\telse\n\t{\n\t    // 'vartabstop' wasn't in use and a single value was given to\n\t    // retab then update 'tabstop'.\n\t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n\t    vim_free(new_vts_array);\n\t}\n\tvim_free(new_ts_str);\n    }\n#else\n    curbuf->b_p_ts = new_ts;\n#endif\n    coladvance(curwin->w_curswant);\n\n    u_clearline();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 348,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "mp_sint32 LoaderXM::load(XMFileBase& f, XModule* module)\n{\n\tmp_ubyte insData[230];\t\t\n\tmp_sint32 smpReloc[MP_MAXINSSAMPS];\n\tmp_ubyte nbu[MP_MAXINSSAMPS];\n\tmp_uint32 fileSize = 0;\n\t\t\t\n\tmodule->cleanUp();\n\n\t// this will make code much easier to read\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\n\t// we're already out of memory here\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\tfileSize = f.sizeWithBaseOffset();\n\t\n\tf.read(&header->sig,1,17);\n\tf.read(&header->name,1,20);\n\tf.read(&header->whythis1a,1,1);\n\theader->whythis1a=0;\n\tf.read(&header->tracker,1,20);\n\tf.readWords(&header->ver,1);\n\t\n\tif (header->ver != 0x102 && \n\t\theader->ver != 0x103 && // untested\n\t\theader->ver != 0x104)\n\t\treturn MP_LOADER_FAILED;\n\t\n\tf.readDwords(&header->hdrsize,1);\n\t\n\theader->hdrsize-=4;\n\t\n\tmp_uint32 hdrSize = 0x110;\n\tif (header->hdrsize > hdrSize)\n\t\thdrSize = header->hdrsize;\n\t\t\t\t\n\tmp_ubyte* hdrBuff = new mp_ubyte[hdrSize];\n\tmemset(hdrBuff, 0, hdrSize);\n\t\n\tf.read(hdrBuff, 1, header->hdrsize);\n\t\n\theader->ordnum = LittleEndian::GET_WORD(hdrBuff);\n\theader->restart = LittleEndian::GET_WORD(hdrBuff+2);\n\theader->channum = LittleEndian::GET_WORD(hdrBuff+4);\n\theader->patnum = LittleEndian::GET_WORD(hdrBuff+6);\n\theader->insnum = LittleEndian::GET_WORD(hdrBuff+8);\n\theader->freqtab = LittleEndian::GET_WORD(hdrBuff+10);\n\theader->tempo = LittleEndian::GET_WORD(hdrBuff+12);\n\theader->speed = LittleEndian::GET_WORD(hdrBuff+14);\n\tmemcpy(header->ord, hdrBuff+16, 256);\n\tif(header->ordnum > MP_MAXORDERS)\n\t\theader->ordnum = MP_MAXORDERS;\n\tif(header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\n\tdelete[] hdrBuff;\n\t\n\theader->mainvol=255;\n\theader->flags = XModule::MODULE_XMNOTECLIPPING | \n\t\tXModule::MODULE_XMARPEGGIO | \n\t\tXModule::MODULE_XMPORTANOTEBUFFER | \n\t\tXModule::MODULE_XMVOLCOLUMNVIBRATO;\n\n\theader->uppernotebound = 119;\n\t\n\tmp_sint32 i,y,sc;\n\tfor (i=0;i<32;i++) header->pan[i]=0x80;\n\t\n\t// old version?\n\tif (header->ver == 0x102 || header->ver == 0x103)\n\t{\n\t\tmp_sint32 s = 0;\n\t\tmp_sint32 e = 0;\n\t\tfor (y=0;y<header->insnum;y++) {\n\t\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\tf.read(&instr[y].name,1,22);\t\t\n\t\t\tf.read(&instr[y].type,1,1);\n\t\t\tmp_uword numSamples = 0;\n\t\t\tf.readWords(&numSamples,1);\n\t\t\tif(numSamples > MP_MAXINSSAMPS)\n\t\t\t\treturn MP_LOADER_FAILED;\n\t\t\tinstr[y].samp = numSamples;\n\n\t\t\tif (instr[y].size == 29)\n\t\t\t{\n#ifdef MILKYTRACKER\n\t\t\t\ts+=16;\n#endif\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf.readDwords(&instr[y].shsize,1);\n\n\t\t\tmemset(insData, 0, 230);\n\t\t\t\n\t\t\tif (instr[y].size - 33 > 230)\n\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\n\t\t\tf.read(insData, 1, instr[y].size - 33);\n\t\t\t\t\t\t\n\t\t\tif (instr[y].samp) {\n\t\t\t\tmp_ubyte* insDataPtr = insData;\n\t\t\t\t\n\t\t\t\tmemcpy(nbu, insDataPtr, MP_MAXINSSAMPS);\n\t\t\t\tinsDataPtr+=MP_MAXINSSAMPS;\n\t\t\t\t\n\t\t\t\tTEnvelope venv;\n\t\t\t\tTEnvelope penv;\n\t\t\t\tmemset(&venv,0,sizeof(venv));\n\t\t\t\tmemset(&penv,0,sizeof(penv));\n\t\t\t\t\n\t\t\t\tmp_sint32 k;\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tvenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tvenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tpenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tpenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvenv.num = *insDataPtr++;\t\n\t\t\t\tif (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tpenv.num = *insDataPtr++;\t\n\t\t\t\tif (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tvenv.sustain = *insDataPtr++;\n\t\t\t\tvenv.loops = *insDataPtr++;\n\t\t\t\tvenv.loope = *insDataPtr++;\n\t\t\t\tpenv.sustain = *insDataPtr++;\n\t\t\t\tpenv.loops = *insDataPtr++;\n\t\t\t\tpenv.loope = *insDataPtr++;\n\t\t\t\tvenv.type = *insDataPtr++;\n\t\t\t\tpenv.type = *insDataPtr++;\t\t\t\t\n\t\t\t\t\n\t\t\t\tmp_ubyte vibtype, vibsweep, vibdepth, vibrate;\n\t\t\t\tmp_uword volfade;\n\t\t\t\t\n\t\t\t\tvibtype = *insDataPtr++;\n\t\t\t\tvibsweep = *insDataPtr++;\n\t\t\t\tvibdepth = *insDataPtr++;\n\t\t\t\tvibrate = *insDataPtr++;\n\t\t\t\t\n\t\t\t\tvibdepth<<=1;\n\t\t\t\t\n\t\t\t\tvolfade = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\tvolfade<<=1;\n\t\t\t\t\n\t\t\t\t//instr[y].res = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\t\n\t\t\t\tfor (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) {\n\t\t\t\t\tvenv.env[l][1]<<=2;\n\t\t\t\t\tpenv.env[l][1]<<=2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!module->addVolumeEnvelope(venv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\tif (!module->addPanningEnvelope(penv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t\n\t\t\t\tmp_sint32 g=0, sc;\n\t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].flags=3;\n\t\t\t\t\tsmp[g+s].venvnum=e+1;\n\t\t\t\t\tsmp[g+s].penvnum=e+1;\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].vibtype=vibtype;\n\t\t\t\t\tsmp[g+s].vibsweep=vibsweep;\n\t\t\t\t\tsmp[g+s].vibdepth=vibdepth;\n\t\t\t\t\tsmp[g+s].vibrate=vibrate;\n\t\t\t\t\tsmp[g+s].volfade=volfade;\n\t\t\t\t\t\n\t\t\t\t\t// not sure why I did that, actually doesn't make sense\n\t\t\t\t\t//if (!(venv.type&1)) smp[g+s].volfade=0;\n\t\t\t\t\t\n\t\t\t\t\tf.readDwords(&smp[g+s].samplen,1);\n\t\t\t\t\tf.readDwords(&smp[g+s].loopstart,1);\n\t\t\t\t\tf.readDwords(&smp[g+s].looplen,1);\n\t\t\t\t\tsmp[g+s].vol=XModule::vol64to255(f.readByte());\n\t\t\t\t\t//f.read(&smp[g+s].vol,1,1);\n\t\t\t\t\tf.read(&smp[g+s].finetune,1,1);\n\t\t\t\t\tf.read(&smp[g+s].type,1,1);\n#ifdef VERBOSE\n\t\t\t\t\tprintf(\"Before: %i, After: %i\\n\", smp[g+s].type, smp[g+s].type & (3+16));\n#endif\n\t\t\t\t\tf.read(&smp[g+s].pan,1,1);\n\t\t\t\t\tf.read(&smp[g+s].relnote,1,1);\n\t\t\t\t\tf.read(&smp[g+s].res,1,1);\n\t\t\t\t\tf.read(&smp[g+s].name,1,22);\n\t\t\t\t\t\n\t\t\t\t\tchar line[30];\n\t\t\t\t\tmemset(line, 0, sizeof(line));\n\t\t\t\t\tXModule::convertStr(line, smp[g+s].name, 23, false);\t\t\t\t\t\n\t\t\t\t\tif (line[0])\n\t\t\t\t\t\tmodule->addSongMessageLine(line);\n\t\t\t\t\t\n\t\t\t\t\t// ignore empty samples\n#ifndef MILKYTRACKER\n\t\t\t\t\t// ignore empty samples when not being a tracker\n\t\t\t\t\tif (smp[g+s].samplen) {\n\t\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\t\tg++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsmpReloc[sc] = -1;\n#else\n\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\tg++;\n#endif\n\t\t\t\t}\n\n\t\t\t\tinstr[y].samp = g;\n\n\t\t\t\tfor (sc = 0; sc < MP_MAXINSSAMPS; sc++) {\n\t\t\t\t\tif (smpReloc[nbu[sc]] == -1)\n\t\t\t\t\t\tinstr[y].snum[sc] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tinstr[y].snum[sc] = smpReloc[nbu[sc]]+s;\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\te++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t}\n\n#ifdef MILKYTRACKER\n\t\t\ts+=16;\n#else\n\t\t\ts+=instr[y].samp;\n#endif\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\theader->smpnum=s;\n\t\theader->volenvnum=e;\n\t\theader->panenvnum=e;\n\t}\n\t\n\tfor (y=0;y<header->patnum;y++) {\n\t\t\n\t\tif (header->ver == 0x104 || header->ver == 0x103)\n\t\t{\n\t\t\tf.readDwords(&phead[y].len,1);\n\t\t\tf.read(&phead[y].ptype,1,1);\n\t\t\tf.readWords(&phead[y].rows,1);\n\t\t\tf.readWords(&phead[y].patdata,1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf.readDwords(&phead[y].len,1);\n\t\t\tf.read(&phead[y].ptype,1,1);\n\t\t\tphead[y].rows = (mp_uword)f.readByte()+1;\n\t\t\tf.readWords(&phead[y].patdata,1);\t\t\t\n\t\t}\n\t\t\n\t\tphead[y].effnum=2;\n\t\tphead[y].channum=(mp_ubyte)header->channum;\n\t\t\n\t\tphead[y].patternData = new mp_ubyte[phead[y].rows*header->channum*6];\n\t\t\n\t\t// out of memory?\n\t\tif (phead[y].patternData == NULL)\n\t\t{\n\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t}\n\t\t\n\t\tmemset(phead[y].patternData,0,phead[y].rows*header->channum*6);\n\t\t\n\t\tif (phead[y].patdata) {\n\t\t\tmp_ubyte *buffer = new mp_ubyte[phead[y].patdata];\n\t\t\t\n\t\t\t// out of memory?\n\t\t\tif (buffer == NULL)\n\t\t\t{\n\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tf.read(buffer,1,phead[y].patdata);\n\t\t\t\n\t\t\t//printf(\"%i\\n\", phead[y].patdata);\n\t\t\t\n\t\t\tmp_sint32 pc = 0, bc = 0;\n\t\t\tfor (mp_sint32 r=0;r<phead[y].rows;r++) {\n\t\t\t\tfor (mp_sint32 c=0;c<header->channum;c++) {\n\t\t\t\t\t\n\t\t\t\t\tmp_ubyte slot[5];\n\t\t\t\t\tmemset(slot,0,5);\n\t\t\t\t\t\n\t\t\t\t\tif ((buffer[pc]&128)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tmp_ubyte pb = buffer[pc];\n\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ((pb&1)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc]=buffer[pc];\n\t\t\t\t\t\t\tslot[0]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&2)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+1]=buffer[pc];\n\t\t\t\t\t\t\tslot[1]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&4)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+2]=buffer[pc];\n\t\t\t\t\t\t\tslot[2]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&8)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+3]=buffer[pc];\n\t\t\t\t\t\t\tslot[3]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&16)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+4]=buffer[pc];\n\t\t\t\t\t\t\tslot[4]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//memcpy(phead[y].patternData+bc,buffer+pc,5);\n\t\t\t\t\t\tmemcpy(slot,buffer+pc,5);\n\t\t\t\t\t\tpc+=5;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tchar gl=0;\n\t\t\t\t\tfor (mp_sint32 i=0;i<XModule::numValidXMEffects;i++)\n\t\t\t\t\t\tif (slot[3]==XModule::validXMEffects[i]) gl=1;\n\t\t\t\t\t\n\t\t\t\t\tif (!gl) slot[3]=slot[4]=0;\n\t\t\t\t\t\n\t\t\t\t\tif ((slot[3]==0xC)||(slot[3]==0x10)) {\n\t\t\t\t\t\tslot[4] = XModule::vol64to255(slot[4]);\n\t\t\t\t\t\t/*mp_sint32 bl = slot[4];\n\t\t\t\t\t\tif (bl>64) bl=64;\n\t\t\t\t\t\tslot[4]=(bl*261120)>>16;*/\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((!slot[3])&&(slot[4])) slot[3]=0x20;\n\t\t\t\t\t\n\t\t\t\t\tif (slot[3]==0xE) {\n\t\t\t\t\t\tslot[3]=(slot[4]>>4)+0x30;\n\t\t\t\t\t\tslot[4]=slot[4]&0xf;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (slot[3]==0x21) {\n\t\t\t\t\t\tslot[3]=(slot[4]>>4)+0x40;\n\t\t\t\t\t\tslot[4]=slot[4]&0xf;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (slot[0]==97) slot[0]=XModule::NOTE_OFF;\n\t\t\t\t\t\n\t\t\t\t\tphead[y].patternData[bc]=slot[0];\n\t\t\t\t\tphead[y].patternData[bc+1]=slot[1];\n\t\t\t\t\t\n\t\t\t\t\tXModule::convertXMVolumeEffects(slot[2], phead[y].patternData[bc+2], phead[y].patternData[bc+3]);\n\n\t\t\t\t\tphead[y].patternData[bc+4]=slot[3];\n\t\t\t\t\tphead[y].patternData[bc+5]=slot[4];\n\t\t\t\t\t\n\t\t\t\t\t/*if ((y==3)&&(c==2)) {\n\t\t\t\t\t\tfor (mp_sint32 bl=0;bl<6;bl++) cprintf(\"%x \",phead[y].patternData[bc+bl]);\n\t\t\t\t\tcprintf(\"\\r\\n\");\n\t\t\t\t\tgetch();\n\t\t\t\t\t};*/\n\t\t\t\t\t\n\t\t\t\t\t/*printf(\"Note : %i\\r\\n\",phead[y].patternData[bc]);\n\t\t\t\t\tprintf(\"Ins  : %i\\r\\n\",phead[y].patternData[bc+1]);\n\t\t\t\t\tprintf(\"Vol  : %i\\r\\n\",phead[y].patternData[bc+2]);\n\t\t\t\t\tprintf(\"Eff  : %i\\r\\n\",phead[y].patternData[bc+3]);\n\t\t\t\t\tprintf(\"Effop: %i\\r\\n\",phead[y].patternData[bc+4]);\n\t\t\t\t\tgetch();*/\n\t\t\t\t\t\n\t\t\t\t\tbc+=6;\n\t\t\t\t} // for c\n\t\t\t\t\t\n\t\t\t} // for r\n\t\t\t\t\n\t\t\tdelete[] buffer;\n\t\t}\n\t\t\t\n\t}\n\t\t\n\tif (header->ver == 0x104)\n\t{\n\t\tmp_sint32 s = 0;\n\t\tmp_sint32 e = 0;\n\t\tfor (y=0;y<header->insnum;y++) {\n\n\t\t\t// fixes MOOH.XM loading problems\n\t\t\t// seems to store more instruments in the header than in the actual file\n\t\t\tif (f.posWithBaseOffset() >= fileSize)\n\t\t\t\tbreak;\n\t\t\n\t\t\t//TXMInstrument* ins = &instr[y];\n\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\t\n\t\t\tif (instr[y].size >= 4 && instr[y].size < 29)\n\t\t\t{\n\t\t\t\tmp_ubyte buffer[29];\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tf.read(buffer, 1, instr[y].size - 4);\n\t\t\t\tmemcpy(instr[y].name, buffer, 22);\n\t\t\t\tinstr[y].type = buffer[22];\n\t\t\t\tinstr[y].samp = LittleEndian::GET_WORD(buffer + 23);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tf.read(&instr[y].name,1,22);\t\t\n\t\t\t\tf.read(&instr[y].type,1,1);\n\t\t\t\tf.readWords(&instr[y].samp,1);\n\t\t\t}\n\t\t\tif (instr[y].samp > MP_MAXINSSAMPS)\n\t\t\t\treturn MP_LOADER_FAILED;\n\n\t\t\t//printf(\"%i, %i\\n\", instr[y].size, instr[y].samp);\n\n\t\t\tif (instr[y].size <= 29)\n\t\t\t{\n#ifdef MILKYTRACKER\n\t\t\t\ts+=16;\n#endif\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf.readDwords(&instr[y].shsize,1);\n#ifdef VERBOSE\n\t\t\tprintf(\"%i/%i: %i, %i, %i, %s\\n\",y,header->insnum-1,instr[y].size,instr[y].shsize,instr[y].samp,instr[y].name);\t\t\t\n#endif\n\t\t\tmemset(insData, 0, 230);\n\t\t\t\n\t\t\tif (instr[y].size - 33 > 230)\n\t\t\t{\n\t\t\t\t//return -7;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tf.read(insData, 1, instr[y].size - 33);\n\t\t\t\n\t\t\t/*printf(\"%i\\r\\n\",instr[y].size);\n\t\t\tprintf(\"%s\\r\\n\",instr[y].name);\n\t\t\tprintf(\"%i\\r\\n\",instr[y].type);\n\t\t\tprintf(\"%i\\r\\n\",instr[y].samp);\n\t\t\tprintf(\"%i\\r\\n\",instr[y].shsize);*/\n\t\t\t//getch();\n\t\t\t\t\t\n\t\t\tmemset(smpReloc, 0, sizeof(smpReloc));\n\t\t\t\n\t\t\tif (instr[y].samp) {\n\t\t\t\tmp_ubyte* insDataPtr = insData;\n\t\t\t\t\n\t\t\t\t//f.read(&nbu,1,96);\n\t\t\t\t\n\t\t\t\tmemcpy(nbu, insDataPtr, MP_MAXINSSAMPS);\n\t\t\t\tinsDataPtr+=MP_MAXINSSAMPS;\n\t\t\t\t\n\t\t\t\tTEnvelope venv;\n\t\t\t\tTEnvelope penv;\n\t\t\t\tmemset(&venv,0,sizeof(venv));\n\t\t\t\tmemset(&penv,0,sizeof(penv));\n\t\t\t\t\n\t\t\t\tmp_sint32 k;\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tvenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tvenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tpenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tpenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvenv.num = *insDataPtr++;\t\n\t\t\t\tif (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tpenv.num = *insDataPtr++;\t\t\t\t\t\n\t\t\t\tif (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tvenv.sustain = *insDataPtr++;\n\t\t\t\tvenv.loops = *insDataPtr++;\n\t\t\t\tvenv.loope = *insDataPtr++;\n\t\t\t\tpenv.sustain = *insDataPtr++;\n\t\t\t\tpenv.loops = *insDataPtr++;\n\t\t\t\tpenv.loope = *insDataPtr++;\n\t\t\t\tvenv.type = *insDataPtr++;\n\t\t\t\tpenv.type = *insDataPtr++;\t\t\t\t\n\t\t\t\t\n\t\t\t\tmp_ubyte vibtype, vibsweep, vibdepth, vibrate;\n\t\t\t\tmp_uword volfade;\n\t\t\t\t\n\t\t\t\tvibtype = *insDataPtr++;\n\t\t\t\tvibsweep = *insDataPtr++;\n\t\t\t\tvibdepth = *insDataPtr++;\n\t\t\t\tvibrate = *insDataPtr++;\n\t\t\t\t\n\t\t\t\tvibdepth<<=1;\n\t\t\t\t\n\t\t\t\t//f.readWords(&volfade,1);\n\t\t\t\tvolfade = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\tvolfade<<=1;\n\t\t\t\t\n\t\t\t\t//instr[y].res = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\t\n\t\t\t\tfor (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) {\n\t\t\t\t\tvenv.env[l][1]<<=2;\n\t\t\t\t\tpenv.env[l][1]<<=2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!module->addVolumeEnvelope(venv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\tif (!module->addPanningEnvelope(penv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t\n\t\t\t\tmp_sint32 g=0, sc;\n\t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\t\t\t\t\t//TXMSample* smpl = &smp[g+s];\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].flags=3;\n\t\t\t\t\tsmp[g+s].venvnum=e+1;\n\t\t\t\t\tsmp[g+s].penvnum=e+1;\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].vibtype=vibtype;\n\t\t\t\t\tsmp[g+s].vibsweep=vibsweep;\n\t\t\t\t\tsmp[g+s].vibdepth=vibdepth;\n\t\t\t\t\tsmp[g+s].vibrate=vibrate;\n\t\t\t\t\tsmp[g+s].volfade=volfade;\n\t\t\t\t\t\n\t\t\t\t\t// not sure why I did that, actually doesn't make sense\n\t\t\t\t\t//if (!(venv.type&1)) smp[g+s].volfade=0;\n\t\t\t\t\t\n\t\t\t\t\tf.readDwords(&smp[g+s].samplen,1);\n\t\t\t\t\t\n\t\t\t\t\tf.readDwords(&smp[g+s].loopstart,1);\n\t\t\t\t\tf.readDwords(&smp[g+s].looplen,1);\n\t\t\t\t\tsmp[g+s].vol=XModule::vol64to255(f.readByte());\n\t\t\t\t\t//f.read(&smp[g+s].vol,1,1);\n\t\t\t\t\tf.read(&smp[g+s].finetune,1,1);\n\t\t\t\t\tf.read(&smp[g+s].type,1,1);\n#ifdef VERBOSE\n\t\t\t\t\tprintf(\"Before: %i, After: %i\\n\", smp[g+s].type, smp[g+s].type & (3+16));\n#endif\n\t\t\t\t\tf.read(&smp[g+s].pan,1,1);\n\t\t\t\t\tf.read(&smp[g+s].relnote,1,1);\n\t\t\t\t\tf.read(&smp[g+s].res,1,1);\n\t\t\t\t\tf.read(&smp[g+s].name,1,22);\n\n\t\t\t\t\tchar line[30];\n\t\t\t\t\tmemset(line, 0, sizeof(line));\n\t\t\t\t\tXModule::convertStr(line, smp[g+s].name, 23, false);\t\t\t\t\t\n\t\t\t\t\tif (line[0])\n\t\t\t\t\t\tmodule->addSongMessageLine(line);\n\t\t\t\t\t\n#ifndef MILKYTRACKER\n\t\t\t\t\t// ignore empty samples when not being a tracker\n\t\t\t\t\tif (smp[g+s].samplen) {\n\t\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\t\tg++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsmpReloc[sc] = -1;\n#else\n\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\tg++;\n#endif\n\t\t\t\t}\n\n\t\t\t\tinstr[y].samp = g;\n\n\t\t\t\tfor (sc = 0; sc < MP_MAXINSSAMPS; sc++) {\t\t\t\t\t\n\t\t\t\t\tif (smpReloc[nbu[sc]] == -1)\n\t\t\t\t\t\tinstr[y].snum[sc] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tinstr[y].snum[sc] = smpReloc[nbu[sc]]+s;\n\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\t\t\t\t\n\t\t\t\t\tif (smp[s].samplen)\n\t\t\t\t\t{\n\t\t\t\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\t\t\t\n\t\t\t\t\t\tmp_uint32 oldSize = smp[s].samplen;\n\t\t\t\t\t\tif (smp[s].type&16) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t\t\t\t adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_DELTA, \n\t\t\t\t\t\t\t\t\t\t\t\t\t adpcm ? (XModule::ST_PACKING_ADPCM | XModule::ST_16BIT) : (XModule::ST_DELTA | XModule::ST_16BIT), \n\t\t\t\t\t\t\t\t\t\t\t\t\t oldSize);\n\t\t\t\t\t\tif (result != MP_OK)\n\t\t\t\t\t\t\treturn result;\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (adpcm)\n\t\t\t\t\t\t\tsmp[s].res = 0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ts++;\n\t\t\t\t\t\n\t\t\t\t\tif (s>=MP_MAXSAMPLES)\n\t\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\te++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t}\n\n#ifdef MILKYTRACKER\n\t\t\ts+=16 - instr[y].samp;\n#endif\t\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\theader->smpnum=s;\n\t\theader->volenvnum=e;\n\t\theader->panenvnum=e;\t\t\n\t\t\n\t}\n\telse\n\t{\n\t\tmp_sint32 s = 0;\n\t\tfor (y=0;y<header->insnum;y++) {\n\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\n\t\t\t\tif (smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tmp_uint32 oldSize = smp[s].samplen;\n\t\t\t\t\tif (smp[s].type&16) \n\t\t\t\t\t{\n\t\t\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmp_sint32 result = module->loadModuleSample(f, s, XModule::ST_DELTA, XModule::ST_DELTA | XModule::ST_16BIT, oldSize);\n\t\t\t\t\tif (result != MP_OK)\n\t\t\t\t\t\treturn result;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ts++;\n\t\t\t\t\n\t\t\t\tif (s>=MP_MAXSAMPLES)\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t}\n\t\t\t\n#ifdef MILKYTRACKER\n\t\t\ts+=16 - instr[y].samp;\n#endif\n\t\t\t\n\t\t}\t\t\n\t}\n\t\n\t// convert modplug stereo samples\n\tfor (mp_sint32 s = 0; s < header->smpnum; s++)\n\t{\n\t\tif (smp[s].type & 32)\n\t\t{\t\t\n\t\t\t// that's what's allowed, stupid modplug tracker\n\t\t\tsmp[s].type &= 3+16;\t\t\t\t\t\n\n\t\t\tif (smp[s].sample == NULL)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (!(smp[s].type&16)) {\t\t\t\n\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\n\t\t\t\tmp_sbyte* sample = (mp_sbyte*)smp[s].sample;\n\t\t\t\tmp_sint32 samplen = smp[s].samplen;\n\t\t\t\tfor (mp_sint32 i = 0; i < samplen; i++)\n\t\t\t\t{\n\t\t\t\t\tmp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1;\n\t\t\t\t\tif (s < -128) s = -128;\n\t\t\t\t\tif (s > 127) s = 127;\n\t\t\t\t\tsample[i] = (mp_sbyte)s;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\n\t\t\t\tmp_sword* sample = (mp_sword*)smp[s].sample;\n\t\t\t\tmp_sint32 samplen = smp[s].samplen;\n\t\t\t\tfor (mp_sint32 i = 0; i < samplen; i++)\n\t\t\t\t{\n\t\t\t\t\tmp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1;\n\t\t\t\t\tif (s < -32768) s = -32768;\n\t\t\t\t\tif (s > 32767) s = 32767;\n\t\t\t\t\tsample[i] = (mp_sword)s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// correct loop type 0x03 (undefined)\n\t\t// will become ping pong loop\n\t\t// note that FT2 will refuse to load XM files with such a loop type\n\t\tif ((smp[s].type & 0x3) == 0x3)\n\t\t\tsmp[s].type&=~1;\t\t\n\t}\n\n\t// correct number of patterns if necessary, otherwise the post processing will remove\n\t// the \"invalid\" patterns from the order list\n\tbool addPatterns = false;\n\tfor (i = 0; i < header->ordnum; i++)\n\t\tif (header->ord[i]+1 > header->patnum)\n\t\t{\n\t\t\theader->patnum = header->ord[i]+1;\t\n\t\t\taddPatterns = true;\n\t\t}\n\t\n\t// if the pattern number has been adjusted, add some empty patterns\n\tif (addPatterns)\n\t{\n\t\tfor (i = 0; i < header->patnum; i++)\n\t\t\tif (phead[i].patternData == NULL)\n\t\t\t{\n\t\t\t\tphead[i].rows = 64;\n\t\t\t\tphead[i].effnum = 2;\n\t\t\t\tphead[i].channum = (mp_ubyte)header->channum;\n\n\t\t\t\tphead[i].patternData = new mp_ubyte[phead[i].rows*header->channum*6];\n\t\t\t\n\t\t\t\t// out of memory?\n\t\t\t\tif (phead[i].patternData == NULL)\n\t\t\t\t{\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t\n\t\t\t\tmemset(phead[i].patternData,0,phead[i].rows*header->channum*6);\n\t\t\t}\n\t}\n\t\n\t// check for MODPLUG extensions\n\tif (f.posWithBaseOffset() + 8 <= fileSize)\n\t{\n\t\tchar buffer[4];\n\t\tf.read(buffer, 1, 4);\n\t\tif (memcmp(buffer, \"text\", 4) == 0)\n\t\t{\n\t\t\tmp_uint32 len = f.readDword();\n\t\t\tmodule->allocateSongMessage(len+1);\n\t\t\t\n\t\t\tmemset(module->message, 0, len+1);\n\t\t\t\n\t\t\tf.read(module->message, 1, len);\n\t\t}\n\t}\n\t\n\tmodule->postProcessSamples();\n\t\n\treturn MP_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 350,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotated_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  status=MagickTrue;\n  while (EOFBlob(image) == MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return(DestroyImageList(image));\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    if ((image->columns == 0) || (image->rows == 0))\n      return(DestroyImageList(image));\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        if(HDR.imagf==1) ldblk *= 2;\n        SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);\n        if ((image->columns == 0) || (image->rows == 0))\n          return(image->previous == (Image *) NULL ? DestroyImageList(image)\n            : image);\n        goto skip_reading_current;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,GRAYColorspace,exception);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return(DestroyImageList(image));\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    rotated_image=RotateImage(image,90.0,exception);\n    if (rotated_image != (Image *) NULL)\n      {\n        rotated_image->page.x=0;\n        rotated_image->page.y=0;\n        rotated_image->colors = image->colors;\n        DestroyBlob(rotated_image);\n        rotated_image->blob=ReferenceBlob(image->blob);\n        AppendImageToList(&image,rotated_image);\n        DeleteImageFromList(&image);\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\nskip_reading_current:\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 354,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "pcx_write_rle(const byte * from, const byte * end, int step, gp_file * file)\n{\t\t\t\t/*\n                                 * The PCX format theoretically allows encoding runs of 63\n                                 * identical bytes, but some readers can't handle repetition\n                                 * counts greater than 15.\n                                 */\n#define MAX_RUN_COUNT 15\n    int max_run = step * MAX_RUN_COUNT;\n\n    while (from < end) {\n        byte data = *from;\n\n        from += step;\n        if (from >= end || data != *from) {\n            if (data >= 0xc0)\n                gp_fputc(0xc1, file);\n        } else {\n            const byte *start = from;\n\n            while ((from < end) && (*from == data))\n                from += step;\n            /* Now (from - start) / step + 1 is the run length. */\n            while (from - start >= max_run) {\n                gp_fputc(0xc0 + MAX_RUN_COUNT, file);\n                gp_fputc(data, file);\n                start += max_run;\n            }\n            if (from > start || data >= 0xc0)\n                gp_fputc((from - start) / step + 0xc1, file);\n        }\n        gp_fputc(data, file);\n    }\n#undef MAX_RUN_COUNT\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 360,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree, try changes at each node.\n    // \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\" the word we are trying to match with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t// When there are postponed prefixes we need to use these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    // The loop may take an indefinite amount of time. Break out after some\n    // time.\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round we either:\n    // - For the current state try one operation, advance \"ts_curi\",\n    //   increase \"depth\".\n    // - When a state is done go to the next, set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx = sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t    // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word() works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t// eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length of the NULs in the prefix.  If there are\n\t\t// none this must be the first try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t    // change in this word (it was correct) add the first word\n\t\t    // as a suggestion.  If this word was corrected too, we\n\t\t    // need to check if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this word.  If this\n\t\t    // word does not support compounding then give up\n\t\t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not allowed.  But it may still be\n\t\t\t    // possible if we add another (short) word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper case in preword.\n\t    // If there is a word from a previous split, append.\n\t    // For the soundfold tree don't change the case, simply append.\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t// word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    // upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the next word is valid.\n\t\t// 2. The badword does end, but it was due to a change (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//    following word is valid.\n\t\t// 3. The badword and the word in the tree end.  It may still\n\t\t//    be possible to compound another (short) word.\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t// valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\t// If we're going to split need to check that the\n\t\t\t// words so far are valid for compounding.  If there\n\t\t\t// is only one word it must not have the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the badword has a non-word character at this\n\t\t\t// position skip it.  That means replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\t// character when the word ends.  But only when the\n\t\t\t// good word can end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t// may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\" is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust the score.  But don't even try\n\t\t// when the byte was already changed.  And don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte characters are a bit complicated to\n\t\t\t// handle: They differ when any of the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t\t\t    && sp->ts_fidx > 0)\n\t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance over the character in fword[].  Give a bonus to the\n\t\t// score if the same character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node, go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    // - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was the same, thus doubling a\n\t\t    // character, give a bonus to the score.  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Don't swap if the first character is not a word character.\n\t    // SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical, swap won't do anything.\n\t    // Also get here if the second char is not a word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical: \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here when the third character is not a word character.\n\t    // Second character may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate.  First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here, it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items and we are not in the soundfold trie\n\t    // - the score is going to be too high anyway\n\t    // - already applied a REP item or swapped here\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Use the first byte to quickly find the first entry that may\n\t    // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items from the .aff file.  For each match\n\t    // replace the characters and check if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    // Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all possible states at this level, go up one level.\n\t    --depth;\n\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 364,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "cvtchar(register const char *sp)\n/* convert a character to a terminfo push */\n{\n    unsigned char c = 0;\n    int len;\n\n    switch (*sp) {\n    case '\\\\':\n\tswitch (*++sp) {\n\tcase '\\'':\n\tcase '$':\n\tcase '\\\\':\n\tcase '%':\n\t    c = UChar(*sp);\n\t    len = 2;\n\t    break;\n\tcase '\\0':\n\t    c = '\\\\';\n\t    len = 1;\n\t    break;\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\t    len = 1;\n\t    while (isdigit(UChar(*sp))) {\n\t\tc = UChar(8 * c + (*sp++ - '0'));\n\t\tlen++;\n\t    }\n\t    break;\n\tdefault:\n\t    c = UChar(*sp);\n\t    len = (c != '\\0') ? 2 : 1;\n\t    break;\n\t}\n\tbreak;\n    case '^':\n\tlen = 2;\n\tc = UChar(*++sp);\n\tif (c == '?') {\n\t    c = 127;\n\t} else if (c == '\\0') {\n\t    len = 1;\n\t} else {\n\t    c &= 0x1f;\n\t}\n\tbreak;\n    default:\n\tc = UChar(*sp);\n\tlen = (c != '\\0') ? 1 : 0;\n    }\n    if (isgraph(c) && c != ',' && c != '\\'' && c != '\\\\' && c != ':') {\n\tdp = save_string(dp, \"%\\'\");\n\tdp = save_char(dp, c);\n\tdp = save_char(dp, '\\'');\n    } else if (c != '\\0') {\n\tdp = save_string(dp, \"%{\");\n\tif (c > 99)\n\t    dp = save_char(dp, c / 100 + '0');\n\tif (c > 9)\n\t    dp = save_char(dp, ((int) (c / 10)) % 10 + '0');\n\tdp = save_char(dp, c % 10 + '0');\n\tdp = save_char(dp, '}');\n    }\n    return len;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 370,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "get_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t// Correct the length to include all bytes of the last\n\t\t// character.\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t// Do not include a trailing NUL.\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 376,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\tif (end-p > m->desc.fmt[i].slen) {\n\t    *p++ = ' ';\n\t    pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\t    p += m->desc.fmt[i].slen;\n\t} else {\n\t    return -1;\n\t}\n    }\n\n    if (end-p >= 2) {\n\t*p++ = '\\r';\n\t*p++ = '\\n';\n    } else {\n\treturn -1;\n    }\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 378,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "drill_parse_T_code(gerb_file_t *fd, drill_state_t *state,\n\t\t\tgerbv_image_t *image, ssize_t file_line)\n{\n    int tool_num;\n    gboolean done = FALSE;\n    int temp;\n    double size;\n    gerbv_drill_stats_t *stats = image->drill_stats;\n    gerbv_aperture_t *apert;\n    gchar *tmps;\n    gchar *string;\n\n    dprintf(\"---> entering %s()...\\n\", __FUNCTION__);\n\n    /* Sneak a peek at what's hiding after the 'T'. Ugly fix for\n       broken headers from Orcad, which is crap */\n    temp = gerb_fgetc(fd);\n    dprintf(\"  Found a char '%s' (0x%02x) after the T\\n\",\n\t    gerbv_escape_char(temp), temp);\n    \n    /* might be a tool tool change stop switch on/off*/\n    if((temp == 'C') && ((fd->ptr + 2) < fd->datalen)){\n    \tif(gerb_fgetc(fd) == 'S'){\n    \t    if (gerb_fgetc(fd) == 'T' ){\n    \t  \tfd->ptr -= 4;\n    \t  \ttmps = get_line(fd++);\n    \t  \tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_NOTE, -1,\n\t\t\t_(\"Tool change stop switch found \\\"%s\\\" \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\ttmps, file_line, fd->filename);\n\t  \tg_free (tmps);\n\n\t  \treturn -1;\n\t    }\n\t    gerb_ungetc(fd);\n\t}\n\tgerb_ungetc(fd);\n    }\n\n    if( !(isdigit(temp) != 0 || temp == '+' || temp =='-') ) {\n\tif(temp != EOF) {\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t   _(\"OrCAD bug: Junk text found in place of tool definition\"));\n\t    tmps = get_line(fd);\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t    _(\"Junk text \\\"%s\\\" \"\n\t\t\t\"at line %ld in file \\\"%s\\\"\"),\n\t\t    tmps, file_line, fd->filename);\n\t    g_free (tmps);\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t\t  _(\"Ignoring junk text\"));\n\t}\n\treturn -1;\n    }\n    gerb_ungetc(fd);\n\n    tool_num = (int) gerb_fgetint(fd, NULL);\n    dprintf (\"  Handling tool T%d at line %ld\\n\", tool_num, file_line);\n\n    if (tool_num == 0) \n\treturn tool_num; /* T00 is a command to unload the drill */\n\n    if (tool_num < TOOL_MIN || tool_num >= TOOL_MAX) {\n\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t_(\"Out of bounds drill number %d \"\n\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\ttool_num, file_line, fd->filename);\n\treturn -1;\n    }\n\n    /* Set the current tool to the correct one */\n    state->current_tool = tool_num;\n    apert = image->aperture[tool_num];\n\n    /* Check for a size definition */\n    temp = gerb_fgetc(fd);\n\n    /* This bit of code looks for a tool definition by scanning for strings\n     * of form TxxC, TxxF, TxxS.  */\n    while (!done) {\n\tswitch((char)temp) {\n\tcase 'C':\n\t    size = read_double(fd, state->header_number_format, GERBV_OMIT_ZEROS_TRAILING, state->decimals);\n\t    dprintf (\"  Read a size of %g\\n\", size);\n\n\t    if (state->unit == GERBV_UNIT_MM) {\n\t\tsize /= 25.4;\n\t    } else if(size >= 4.0) {\n\t\t/* If the drill size is >= 4 inches, assume that this\n\t\t   must be wrong and that the units are mils.\n\t\t   The limit being 4 inches is because the smallest drill\n\t\t   I've ever seen used is 0,3mm(about 12mil). Half of that\n\t\t   seemed a bit too small a margin, so a third it is */\n\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Read a drill of diameter %g inches \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\t    size, file_line, fd->filename);\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t_(\"Assuming units are mils\"));\n\t\tsize /= 1000.0;\n\t    }\n\n\t    if (size <= 0. || size >= 10000.) {\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Unreasonable drill size %g found for drill %d \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\t    size, tool_num, file_line, fd->filename);\n\t    } else {\n\t\tif (apert != NULL) {\n\t\t    /* allow a redefine of a tool only if the new definition is exactly the same.\n\t\t     * This avoid lots of spurious complaints with the output of some cad\n\t\t     * tools while keeping complaints if there is a true problem\n\t\t     */\n\t\t    if (apert->parameter[0] != size\n\t\t    ||  apert->type != GERBV_APTYPE_CIRCLE\n\t\t    ||  apert->nuf_parameters != 1\n\t\t    ||  apert->unit != GERBV_UNIT_INCH) {\n\n\t\t\tgerbv_stats_printf(stats->error_list,\n\t\t\t\tGERBV_MESSAGE_ERROR, -1,\n\t\t\t\t_(\"Found redefinition of drill %d \"\n\t\t\t\t\"at line %ld in file \\\"%s\\\"\"),\n\t\t\t\ttool_num, file_line, fd->filename);\n\t\t    }\n\t\t} else {\n\t\t    apert = image->aperture[tool_num] =\n\t\t\t\t\t\tg_new0(gerbv_aperture_t, 1);\n\t\t    if (apert == NULL)\n\t\t\tGERB_FATAL_ERROR(\"malloc tool failed in %s()\",\n\t\t\t\t\t__FUNCTION__);\n\n\t\t    /* There's really no way of knowing what unit the tools\n\t\t       are defined in without sneaking a peek in the rest of\n\t\t       the file first. That's done in drill_guess_format() */\n\t\t    apert->parameter[0] = size;\n\t\t    apert->type = GERBV_APTYPE_CIRCLE;\n\t\t    apert->nuf_parameters = 1;\n\t\t    apert->unit = GERBV_UNIT_INCH;\n\t\t}\n\t    }\n\t    \n\t    /* Add the tool whose definition we just found into the list\n\t     * of tools for this layer used to generate statistics. */\n\t    stats = image->drill_stats;\n\t    string = g_strdup_printf(\"%s\", (state->unit == GERBV_UNIT_MM ? _(\"mm\") : _(\"inch\")));\n\t    drill_stats_add_to_drill_list(stats->drill_list, \n\t\t\t\t\t  tool_num, \n\t\t\t\t\t  state->unit == GERBV_UNIT_MM ? size*25.4 : size, \n\t\t\t\t\t  string);\n\t    g_free(string);\n\t    break;\n\n\tcase 'F':\n\tcase 'S' :\n\t    /* Silently ignored. They're not important. */\n\t    gerb_fgetint(fd, NULL);\n\t    break;\n\n\tdefault:\n\t    /* Stop when finding anything but what's expected\n\t       (and put it back) */\n\t    gerb_ungetc(fd);\n\t    done = TRUE;\n\t    break;\n\t}  /* switch((char)temp) */\n\n\ttemp = gerb_fgetc(fd);\n\tif (EOF == temp) {\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t    _(\"Unexpected EOF encountered in header of \"\n\t\t\t\"drill file \\\"%s\\\"\"), fd->filename);\n\n\t/* Restore new line character for processing */\n\tif ('\\n' == temp || '\\r' == temp)\n\t    gerb_ungetc(fd);\n\t}\n    }   /* while(!done) */  /* Done looking at tool definitions */\n\n    /* Catch the tools that aren't defined.\n       This isn't strictly a good thing, but at least something is shown */\n    if (apert == NULL) {\n        double dia;\n\n\tapert = image->aperture[tool_num] = g_new0(gerbv_aperture_t, 1);\n\tif (apert == NULL)\n\t    GERB_FATAL_ERROR(\"malloc tool failed in %s()\", __FUNCTION__);\n\n        /* See if we have the tool table */\n        dia = gerbv_get_tool_diameter(tool_num);\n        if (dia <= 0) {\n            /*\n             * There is no tool. So go out and make some.\n             * This size calculation is, of course, totally bogus.\n             */\n            dia = (double)(16 + 8 * tool_num) / 1000;\n            /*\n             * Oooh, this is sooo ugly. But some CAD systems seem to always\n             * use T00 at the end of the file while others that don't have\n             * tool definitions inside the file never seem to use T00 at all.\n             */\n            if (tool_num != 0) {\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Tool %02d used without being defined \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\ttool_num, file_line, fd->filename);\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t_(\"Setting a default size of %g\\\"\"), dia);\n            }\n\t}\n\n\tapert->type = GERBV_APTYPE_CIRCLE;\n\tapert->nuf_parameters = 1;\n\tapert->parameter[0] = dia;\n\n\t/* Add the tool whose definition we just found into the list\n\t * of tools for this layer used to generate statistics. */\n\tif (tool_num != 0) {  /* Only add non-zero tool nums.  \n\t\t\t       * Zero = unload command. */\n\t    stats = image->drill_stats;\n\t    string = g_strdup_printf(\"%s\", \n\t\t\t\t     (state->unit == GERBV_UNIT_MM ? _(\"mm\") : _(\"inch\")));\n\t    drill_stats_add_to_drill_list(stats->drill_list, \n\t\t\t\t\t  tool_num, \n\t\t\t\t\t  state->unit == GERBV_UNIT_MM ? dia*25.4 : dia,\n\t\t\t\t\t  string);\n\t    g_free(string);\n\t}\n    } /* if(image->aperture[tool_num] == NULL) */\t\n    \n    dprintf(\"<----  ...leaving %s()\\n\", __FUNCTION__);\n\n    return tool_num;\n} /* drill_parse_T_code() */",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 384,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "ga_concat_shorten_esc(garray_T *gap, char_u *str)\n{\n    char_u  *p;\n    char_u  *s;\n    int\t    c;\n    int\t    clen;\n    char_u  buf[NUMBUFLEN];\n    int\t    same_len;\n\n    if (str == NULL)\n    {\n\tga_concat(gap, (char_u *)\"NULL\");\n\treturn;\n    }\n\n    for (p = str; *p != NUL; ++p)\n    {\n\tsame_len = 1;\n\ts = p;\n\tc = mb_cptr2char_adv(&s);\n\tclen = s - p;\n\twhile (*s != NUL && c == mb_ptr2char(s))\n\t{\n\t    ++same_len;\n\t    s += clen;\n\t}\n\tif (same_len > 20)\n\t{\n\t    ga_concat(gap, (char_u *)\"\\\\[\");\n\t    ga_concat_esc(gap, p, clen);\n\t    ga_concat(gap, (char_u *)\" occurs \");\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%d\", same_len);\n\t    ga_concat(gap, buf);\n\t    ga_concat(gap, (char_u *)\" times]\");\n\t    p = s - 1;\n\t}\n\telse\n\t    ga_concat_esc(gap, p, clen);\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 386,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MaxTextExtent];\n\n  CINInfo\n    cin;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  PixelPacket\n    *q;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  if (cin.file.image_offset < 712)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n     sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property);\n  (void) memset(cin.origination.serial,0,\n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,\n        sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const void *) NULL,cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  (void) SetImageBackgroundColor(image);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,MagickFalse);\n  quantum_type=RGBQuantum;\n  extent=GetQuantumExtent(image,quantum_info,quantum_type);\n  (void) extent;\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  status=SetQuantumPad(image,quantum_info,0);\n  pixels=GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const void\n      *stream;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    stream=ReadBlobStream(image,length,pixels,&count);\n    if (count != (ssize_t) length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,(unsigned char *) stream,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 388,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "do_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, padd with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    // Skip mark_adjust when adding lines after the last one, there\n\t    // can't be marks there. But still needed in diff mode.\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 396,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n\n    Q_D(QPaintEngineEx);\n\n    if (path.isEmpty())\n        return;\n\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        // Check to avoid generating unwieldy amount of dashes that will not be visible anyway\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (qFuzzyIsNull(extent) || extent / patternLength > 10000) {\n            // approximate stream of tiny dashes with semi-transparent solid line\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n\n    if (!d->activeStroker) {\n        return;\n    }\n\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n\n    const qreal *lastPoint = points + (pointCount<<1);\n\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n\n    // Some engines might decide to optimize for the non-shape hint later on...\n    uint flags = QVectorPath::WindingFill;\n\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n\n    // ### Perspective Xforms are currently not supported...\n    if (!pen.isCosmetic()) {\n        // We include cosmetic pens in this case to avoid having to\n        // change the current transform. Normal transformed,\n        // non-cosmetic pens will be transformed as part of fill\n        // later, so they are also covered here..\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n\n        if (!d->strokeHandler->types.size()) // an empty path...\n            return;\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        // For cosmetic pens we need a bit of trickery... We to process xform the input points\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n\n        fill(strokePath, brush);\n\n        state()->matrix = xform;\n        transformChanged();\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 402,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "block_insert(\n    oparg_T\t\t*oap,\n    char_u\t\t*s,\n    int\t\t\tb_insert,\n    struct block_def\t*bdp)\n{\n    int\t\tts_val;\n    int\t\tcount = 0;\t// extra spaces to replace a cut TAB\n    int\t\tspaces = 0;\t// non-zero if cutting a TAB\n    colnr_T\toffset;\t\t// pointer along new line\n    colnr_T\tstartcol;\t// column where insert starts\n    unsigned\ts_len;\t\t// STRLEN(s)\n    char_u\t*newp, *oldp;\t// new, old lines\n    linenr_T\tlnum;\t\t// loop var\n    int\t\toldstate = State;\n\n    State = INSERT;\t\t// don't want REPLACE for State\n    s_len = (unsigned)STRLEN(s);\n\n    for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n    {\n\tblock_prep(oap, bdp, lnum, TRUE);\n\tif (bdp->is_short && b_insert)\n\t    continue;\t// OP_INSERT, line ends before block start\n\n\toldp = ml_get(lnum);\n\n\tif (b_insert)\n\t{\n\t    ts_val = bdp->start_char_vcols;\n\t    spaces = bdp->startspaces;\n\t    if (spaces != 0)\n\t\tcount = ts_val - 1; // we're cutting a TAB\n\t    offset = bdp->textcol;\n\t}\n\telse // append\n\t{\n\t    ts_val = bdp->end_char_vcols;\n\t    if (!bdp->is_short) // spaces = padding after block\n\t    {\n\t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n\t\tif (spaces != 0)\n\t\t    count = ts_val - 1; // we're cutting a TAB\n\t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n\t    }\n\t    else // spaces = padding to block edge\n\t    {\n\t\t// if $ used, just append to EOL (ie spaces==0)\n\t\tif (!bdp->is_MAX)\n\t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n\t\tcount = spaces;\n\t\toffset = bdp->textcol + bdp->textlen;\n\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t    // avoid copying part of a multi-byte character\n\t    offset -= (*mb_head_off)(oldp, oldp + offset);\n\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\t// Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t// insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t// we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t// We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t// Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties\n\t    inserted_bytes(lnum, startcol, s_len);\n\n\tif (lnum == oap->end.lnum)\n\t{\n\t    // Set \"']\" mark to the end of the block instead of the end of\n\t    // the insert in the first line.\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = offset;\n\t}\n    } // for all lnum\n\n    changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\n    State = oldstate;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 404,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "lprn_is_black(gx_device_printer * pdev, int r, int h, int bx)\n{\n    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;\n\n    int bh = lprn->nBh;\n    int bpl = gdev_mem_bytes_per_scan_line(pdev);\n    int x, y, y0;\n    byte *p;\n    int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;\n\n    y0 = (r + h - bh) % maxY;\n    for (y = 0; y < bh; y++) {\n        p = &lprn->ImageBuf[(y0 + y) * bpl + bx * lprn->nBw];\n        for (x = 0; x < lprn->nBw; x++) {\n            /* bpl isn't necessarily a multiple of lprn->nBw, so\n            we need to explicitly stop after the last byte in this\n            line to avoid accessing either the next line's data or\n            going off the end of our buffer completely. This avoids\n            https://bugs.ghostscript.com/show_bug.cgi?id=701785. */\n            if (bx * lprn->nBw + x >= bpl)  break;\n            if (p[x] != 0)\n                return 1;\n        }\n    }\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 414,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t/* can't match */\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    /* No match */\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\t\t\t\t/* match */\n    op->tas.rsize = size;\t\t\t\t/* match */\n    push(2);\n    op[-1] = *op1;\t\t\t\t\t/* pre */\n    op[-3].value.bytes = ptr + size;\t\t\t/* post */\n    if (forward) {\n        op[-1].tas.rsize = ptr - op[-1].value.bytes;\t/* pre */\n        op[-3].tas.rsize = count;\t\t\t/* post */\n    } else {\n        op[-1].tas.rsize = count;\t\t\t/* pre */\n        op[-3].tas.rsize -= count + size;\t\t/* post */\n    }\n    make_true(op);\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 424,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "int esp_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\n\t/* this is non-NULL only with TCP/UDP Encapsulation */\n\tif (x->encap) {\n\t\tint err = esp_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 426,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 428,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci)) {  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n    setobjs2s(L, L->top - 2, L->top - 1);  /* remove 'msg' from the stack */\n    L->top--;\n  }\n  luaG_errormsg(L);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 432,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n\t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n\tint err = 0;\n\n\tdo {\n\t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n\n\t\tself->rpc_tid = sw.tid;\n\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n\t\t\t\t\t\tself, fw.val,\n\t\t\t\t\t\tsw.tid == fw.tid,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_hw_err_from_flags(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\tif (fw.len == 0xFFFFU) {\n\t\t\tif (sw.len > sizeof(self->rpc)) {\n\t\t\t\tprintk(KERN_INFO \"Invalid sw len: %x\\n\", sw.len);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n\n\tif (rpc) {\n\t\tif (fw.len) {\n\t\t\tif (fw.len > sizeof(self->rpc)) {\n\t\t\t\tprintk(KERN_INFO \"Invalid fw len: %x\\n\", fw.len);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\terr =\n\t\t\thw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t      self->rpc_addr,\n\t\t\t\t\t\t      (u32 *)(void *)\n\t\t\t\t\t\t      &self->rpc,\n\t\t\t\t\t\t      (fw.len + sizeof(u32) -\n\t\t\t\t\t\t       sizeof(u8)) /\n\t\t\t\t\t\t      sizeof(u32));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\n\t\t*rpc = &self->rpc;\n\t}\n\nerr_exit:\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 446,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "eval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n    static\tint recurse = 0;\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, in_vim9script()) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000 we run out of stack\n    // and crash.\n    if (recurse == 1000)\n    {\n\tsemsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (in_vim9script())\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval7_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 456,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n{\n\tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n\tu32 len, pg_off;\n\tstruct bpf_ringbuf_hdr *hdr;\n\n\tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n\t\treturn NULL;\n\n\tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\tif (len > rb->mask + 1)\n\t\treturn NULL;\n\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\n\tif (in_nmi()) {\n\t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n\t\t\treturn NULL;\n\t} else {\n\t\tspin_lock_irqsave(&rb->spinlock, flags);\n\t}\n\n\tprod_pos = rb->producer_pos;\n\tnew_prod_pos = prod_pos + len;\n\n\t/* check for out of ringbuf space by ensuring producer position\n\t * doesn't advance more than (ringbuf_size - 1) ahead\n\t */\n\tif (new_prod_pos - cons_pos > rb->mask) {\n\t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\t\treturn NULL;\n\t}\n\n\thdr = (void *)rb->data + (prod_pos & rb->mask);\n\tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n\thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n\thdr->pg_off = pg_off;\n\n\t/* pairs with consumer's smp_load_acquire() */\n\tsmp_store_release(&rb->producer_pos, new_prod_pos);\n\n\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\n\treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 462,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tif (rz_buf_read(buffer, s1, n1) != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else {\n\t\tn2 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n2, 1)) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tif (rz_buf_read(buffer, s2, n2) != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 482,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "parse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers. The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break;  // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"mods *+\n\t\t//  Use \"*\" instead of \"'<,'>\" to avoid the command getting\n\t\t//  longer, in case is was allocated.\n\t\tmch_memmove(orig_cmd, cmd_start, len);\n\t\tSTRCPY(orig_cmd + len, \" *+\");\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -= 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t    // No modifiers, move the pointer back.\n\t    // Special case: change empty command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\";\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\teap->cmd = (char_u *)\"+\";\n\n    return OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 496,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "ins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol && curwin->w_cursor.col > 0\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 500,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer,\n                                       raptor_xml_element* element,\n                                       int auto_empty)\n{\n  raptor_iostream* iostr = xml_writer->iostr;\n  raptor_namespace_stack *nstack = xml_writer->nstack;\n  int depth = xml_writer->depth;\n  int auto_indent = XML_WRITER_AUTO_INDENT(xml_writer);\n  struct nsd *nspace_declarations = NULL;\n  size_t nspace_declarations_count = 0;  \n  unsigned int i;\n\n  if(nstack) {\n    int nspace_max_count = element->attribute_count * 2; /* attr and value */\n    if(element->name->nspace)\n      nspace_max_count++;\n    if(element->declared_nspaces)\n      nspace_max_count += raptor_sequence_size(element->declared_nspaces);\n    if(element->xml_language)\n      nspace_max_count++;\n\n    nspace_declarations = RAPTOR_CALLOC(struct nsd*, nspace_max_count,\n                                        sizeof(struct nsd));\n    if(!nspace_declarations)\n      return 1;\n  }\n\n  if(element->name->nspace) {\n    if(nstack && !raptor_namespaces_namespace_in_scope(nstack, element->name->nspace)) {\n      nspace_declarations[0].declaration=\n        raptor_namespace_format_as_xml(element->name->nspace,\n                                       &nspace_declarations[0].length);\n      if(!nspace_declarations[0].declaration)\n        goto error;\n      nspace_declarations[0].nspace = element->name->nspace;\n      nspace_declarations_count++;\n    }\n  }\n\n  if(nstack && element->attributes) {\n    for(i = 0; i < element->attribute_count; i++) {\n      /* qname */\n      if(element->attributes[i]->nspace) {\n        /* Check if we need a namespace declaration attribute */\n        if(nstack && \n           !raptor_namespaces_namespace_in_scope(nstack, element->attributes[i]->nspace) && element->attributes[i]->nspace != element->name->nspace) {\n          /* not in scope and not same as element (so already going to be declared)*/\n          unsigned int j;\n          int declare_me = 1;\n          \n          /* check it wasn't an earlier declaration too */\n          for(j = 0; j < nspace_declarations_count; j++)\n            if(nspace_declarations[j].nspace == element->attributes[j]->nspace) {\n              declare_me = 0;\n              break;\n            }\n            \n          if(declare_me) {\n            nspace_declarations[nspace_declarations_count].declaration=\n              raptor_namespace_format_as_xml(element->attributes[i]->nspace,\n                                             &nspace_declarations[nspace_declarations_count].length);\n            if(!nspace_declarations[nspace_declarations_count].declaration)\n              goto error;\n            nspace_declarations[nspace_declarations_count].nspace = element->attributes[i]->nspace;\n            nspace_declarations_count++;\n          }\n        }\n      }\n\n      /* Add the attribute's value */\n      nspace_declarations[nspace_declarations_count].declaration=\n        raptor_qname_format_as_xml(element->attributes[i],\n                                   &nspace_declarations[nspace_declarations_count].length);\n      if(!nspace_declarations[nspace_declarations_count].declaration)\n        goto error;\n      nspace_declarations[nspace_declarations_count].nspace = NULL;\n      nspace_declarations_count++;\n\n    }\n  }\n\n  if(nstack && element->declared_nspaces &&\n     raptor_sequence_size(element->declared_nspaces) > 0) {\n    for(i = 0; i< (unsigned int)raptor_sequence_size(element->declared_nspaces); i++) {\n      raptor_namespace* nspace = (raptor_namespace*)raptor_sequence_get_at(element->declared_nspaces, i);\n      unsigned int j;\n      int declare_me = 1;\n      \n      /* check it wasn't an earlier declaration too */\n      for(j = 0; j < nspace_declarations_count; j++)\n        if(nspace_declarations[j].nspace == nspace) {\n          declare_me = 0;\n          break;\n        }\n      \n      if(declare_me) {\n        nspace_declarations[nspace_declarations_count].declaration=\n          raptor_namespace_format_as_xml(nspace,\n                                         &nspace_declarations[nspace_declarations_count].length);\n        if(!nspace_declarations[nspace_declarations_count].declaration)\n          goto error;\n        nspace_declarations[nspace_declarations_count].nspace = nspace;\n        nspace_declarations_count++;\n      }\n\n    }\n  }\n\n  if(nstack && element->xml_language) {\n    size_t lang_len = strlen(RAPTOR_GOOD_CAST(char*, element->xml_language));\n#define XML_LANG_PREFIX_LEN 10\n    size_t buf_length = XML_LANG_PREFIX_LEN + lang_len + 1;\n    unsigned char* buffer = RAPTOR_MALLOC(unsigned char*, buf_length + 1);\n    const char quote = '\\\"';\n    unsigned char* p;\n\n    memcpy(buffer, \"xml:lang=\\\"\", XML_LANG_PREFIX_LEN);\n    p = buffer + XML_LANG_PREFIX_LEN;\n    p += raptor_xml_escape_string(xml_writer->world,\n                                  element->xml_language, lang_len,\n                                  p, buf_length, quote);\n    *p++ = quote;\n    *p = '\\0';\n\n    nspace_declarations[nspace_declarations_count].declaration = buffer;\n    nspace_declarations[nspace_declarations_count].length = buf_length;\n    nspace_declarations[nspace_declarations_count].nspace = NULL;\n    nspace_declarations_count++;\n  }\n  \n\n  raptor_iostream_write_byte('<', iostr);\n\n  if(element->name->nspace && element->name->nspace->prefix_length > 0) {\n    raptor_iostream_counted_string_write((const char*)element->name->nspace->prefix, \n                                         element->name->nspace->prefix_length,\n                                         iostr);\n    raptor_iostream_write_byte(':', iostr);\n  }\n  raptor_iostream_counted_string_write((const char*)element->name->local_name,\n                                       element->name->local_name_length,\n                                       iostr);\n\n  /* declare namespaces and attributes */\n  if(nspace_declarations_count) {\n    int need_indent = 0;\n    \n    /* sort them into the canonical order */\n    qsort((void*)nspace_declarations, \n          nspace_declarations_count, sizeof(struct nsd),\n          raptor_xml_writer_nsd_compare);\n\n    /* declare namespaces first */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(!nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n      need_indent = 1;\n      \n      if(raptor_namespace_stack_start_namespace(nstack,\n                                                (raptor_namespace*)nspace_declarations[i].nspace,\n                                                depth))\n        goto error;\n    }\n\n    /* declare attributes */\n    for(i = 0; i < nspace_declarations_count; i++) {\n      if(nspace_declarations[i].nspace)\n        continue;\n\n      if(auto_indent && need_indent) {\n        /* indent attributes */\n        raptor_xml_writer_newline(xml_writer);\n        xml_writer->depth++;\n        raptor_xml_writer_indent(xml_writer);\n        xml_writer->depth--;\n      }\n      raptor_iostream_write_byte(' ', iostr);\n      raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,\n                                           nspace_declarations[i].length,\n                                           iostr);\n      need_indent = 1;\n\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n      nspace_declarations[i].declaration = NULL;\n    }\n  }\n\n  if(!auto_empty)\n    raptor_iostream_write_byte('>', iostr);\n\n  if(nstack)\n    RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 0;\n\n  /* Clean up nspace_declarations on error */\n  error:\n\n  for(i = 0; i < nspace_declarations_count; i++) {\n    if(nspace_declarations[i].declaration)\n      RAPTOR_FREE(char*, nspace_declarations[i].declaration);\n  }\n\n  RAPTOR_FREE(stringarray, nspace_declarations);\n\n  return 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 506,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[128];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n\n  fd = fopen(filename, \"rb\");\n\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n\n  if (!ReadOK(fd, buffer, 12))////\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n          \n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\t/* BI_ALPHABITFIELDS, etc. */\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    /* enhanced Windows format with bit masks */\n\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       /* 36 */\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       /* 3A */\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       /* 3E */\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       /* 42 */\n\n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    /* BMP Version 4 or 5 */\n\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n\n    Maps = 4;\n\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* biHeight may be negative, but -2147483648 is dangerous because:\n\t -2147483648 == -(-2147483648) */\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* protect against integer overflows caused by malicious BMPs */\n  /* use divisions in comparisons to avoid type overflows */\n\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n   \n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  /* Get the Colormap */\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 534,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tif (abbrev->count) {\n\t\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\n\t\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\n\t\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\t\tcomp_dir = attribute->string.content;\n\t\t\t}\n\t\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdie->count++;\n\t\t}\n\t}\n\n\t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing\n\t// which will need this info can quickly look it up.\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 536,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "display_dollar(colnr_T col_arg)\n{\n    colnr_T col = col_arg < 0 ? 0 : col_arg;\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 542,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "bracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n{\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n    int\t\tidx = 0;\n    char_u\t*end = find_termcode((char_u *)\"PE\");\n    int\t\tret_char = -1;\n    int\t\tsave_allow_keys = allow_keys;\n    int\t\tsave_paste = p_paste;\n\n    // If the end code is too long we can't detect it, read everything.\n    if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n\tend = NULL;\n    ++no_mapping;\n    allow_keys = 0;\n    if (!p_paste)\n\t// Also have the side effects of setting 'paste' to make it work much\n\t// faster.\n\tset_option_value((char_u *)\"paste\", TRUE, NULL, 0);\n\n    for (;;)\n    {\n\t// When the end is not defined read everything there is.\n\tif (end == NULL && vpeekc() == NUL)\n\t    break;\n\tdo\n\t    c = vgetc();\n\twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n\t    // When CTRL-C was encountered the typeahead will be flushed and we\n\t    // won't get the end sequence.  Except when using \":normal\".\n\t    break;\n\n\tif (has_mbyte)\n\t    idx += (*mb_char2bytes)(c, buf + idx);\n\telse\n\t    buf[idx++] = c;\n\tbuf[idx] = NUL;\n\tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n\t{\n\t    if (end[idx] == NUL)\n\t\tbreak; // Found the end of paste code.\n\t    continue;\n\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    // add one for the NUL that is going to be appended\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {\n\t\t\tc = buf[0];\n\t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n\t\t\t    ins_eol(c);\n\t\t\telse\n\t\t\t{\n\t\t\t    ins_char_bytes(buf, idx);\n\t\t\t    AppendToRedobuffLit(buf, idx);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_ONE_CHAR:\n\t\t    if (ret_char == -1)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    ret_char = (*mb_ptr2char)(buf);\n\t\t\telse\n\t\t\t    ret_char = buf[0];\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n\tidx = 0;\n    }\n\n    --no_mapping;\n    allow_keys = save_allow_keys;\n    if (!save_paste)\n\tset_option_value((char_u *)\"paste\", FALSE, NULL, 0);\n\n    return ret_char;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 564,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "check_termcode(\n    int\t\tmax_offset,\n    char_u\t*buf,\n    int\t\tbufsize,\n    int\t\t*buflen)\n{\n    char_u\t*tp;\n    char_u\t*p;\n    int\t\tslen = 0;\t// init for GCC\n    int\t\tmodslen;\n    int\t\tlen;\n    int\t\tretval = 0;\n    int\t\toffset;\n    char_u\tkey_name[2];\n    int\t\tmodifiers;\n    char_u\t*modifiers_start = NULL;\n    int\t\tkey;\n    int\t\tnew_slen;   // Length of what will replace the termcode\n    char_u\tstring[MAX_KEY_CODE_LEN + 1];\n    int\t\ti, j;\n    int\t\tidx = 0;\n    int\t\tcpo_koffset;\n\n    cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);\n\n    /*\n     * Speed up the checks for terminal codes by gathering all first bytes\n     * used in termleader[].  Often this is just a single <Esc>.\n     */\n    if (need_gather)\n\tgather_termleader();\n\n    /*\n     * Check at several positions in typebuf.tb_buf[], to catch something like\n     * \"x<Up>\" that can be mapped. Stop at max_offset, because characters\n     * after that cannot be used for mapping, and with @r commands\n     * typebuf.tb_buf[] can become very long.\n     * This is used often, KEEP IT FAST!\n     */\n    for (offset = 0; offset < max_offset; ++offset)\n    {\n\tif (buf == NULL)\n\t{\n\t    if (offset >= typebuf.tb_len)\n\t\tbreak;\n\t    tp = typebuf.tb_buf + typebuf.tb_off + offset;\n\t    len = typebuf.tb_len - offset;\t// length of the input\n\t}\n\telse\n\t{\n\t    if (offset >= *buflen)\n\t\tbreak;\n\t    tp = buf + offset;\n\t    len = *buflen - offset;\n\t}\n\n\t/*\n\t * Don't check characters after K_SPECIAL, those are already\n\t * translated terminal chars (avoid translating ~@^Hx).\n\t */\n\tif (*tp == K_SPECIAL)\n\t{\n\t    offset += 2;\t// there are always 2 extra characters\n\t    continue;\n\t}\n\n\t/*\n\t * Skip this position if the character does not appear as the first\n\t * character in term_strings. This speeds up a lot, since most\n\t * termcodes start with the same character (ESC or CSI).\n\t */\n\ti = *tp;\n\tfor (p = termleader; *p && *p != i; ++p)\n\t    ;\n\tif (*p == NUL)\n\t    continue;\n\n\t/*\n\t * Skip this position if p_ek is not set and tp[0] is an ESC and we\n\t * are in Insert mode.\n\t */\n\tif (*tp == ESC && !p_ek && (State & MODE_INSERT))\n\t    continue;\n\n\ttp[len] = NUL;\n\tkey_name[0] = NUL;\t// no key name found yet\n\tkey_name[1] = NUL;\t// no key name found yet\n\tmodifiers = 0;\t\t// no modifiers yet\n\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    /*\n\t     * GUI special key codes are all of the form [CSI xx].\n\t     */\n\t    if (*tp == CSI)\t    // Special key from GUI\n\t    {\n\t\tif (len < 3)\n\t\t    return -1;\t    // Shouldn't happen\n\t\tslen = 3;\n\t\tkey_name[0] = tp[1];\n\t\tkey_name[1] = tp[2];\n\t    }\n\t}\n\telse\n#endif // FEAT_GUI\n\t{\n\t    int  mouse_index_found = -1;\n\n\t    for (idx = 0; idx < tc_len; ++idx)\n\t    {\n\t\t/*\n\t\t * Ignore the entry if we are not at the start of\n\t\t * typebuf.tb_buf[]\n\t\t * and there are not enough characters to make a match.\n\t\t * But only when the 'K' flag is in 'cpoptions'.\n\t\t */\n\t\tslen = termcodes[idx].len;\n\t\tmodifiers_start = NULL;\n\t\tif (cpo_koffset && offset && len < slen)\n\t\t    continue;\n\t\tif (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t     (size_t)(slen > len ? len : slen)) == 0)\n\t\t{\n\t\t    int\t    looks_like_mouse_start = FALSE;\n\n\t\t    if (len < slen)\t\t// got a partial sequence\n\t\t\treturn -1;\t\t// need to get more chars\n\n\t\t    /*\n\t\t     * When found a keypad key, check if there is another key\n\t\t     * that matches and use that one.  This makes <Home> to be\n\t\t     * found instead of <kHome> when they produce the same\n\t\t     * key code.\n\t\t     */\n\t\t    if (termcodes[idx].name[0] == 'K'\n\t\t\t\t       && VIM_ISDIGIT(termcodes[idx].name[1]))\n\t\t    {\n\t\t\tfor (j = idx + 1; j < tc_len; ++j)\n\t\t\t    if (termcodes[j].len == slen &&\n\t\t\t\t    STRNCMP(termcodes[idx].code,\n\t\t\t\t\t    termcodes[j].code, slen) == 0)\n\t\t\t    {\n\t\t\t\tidx = j;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    }\n\n\t\t    if (slen == 2 && len > 2\n\t\t\t    && termcodes[idx].code[0] == ESC\n\t\t\t    && termcodes[idx].code[1] == '[')\n\t\t    {\n\t\t\t// The mouse termcode \"ESC [\" is also the prefix of\n\t\t\t// \"ESC [ I\" (focus gained) and other keys.  Check some\n\t\t\t// more bytes to find out.\n\t\t\tif (!isdigit(tp[2]))\n\t\t\t{\n\t\t\t    // ESC [ without number following: Only use it when\n\t\t\t    // there is no other match.\n\t\t\t    looks_like_mouse_start = TRUE;\n\t\t\t}\n\t\t\telse if (termcodes[idx].name[0] == KS_DEC_MOUSE)\n\t\t\t{\n\t\t\t    char_u  *nr = tp + 2;\n\t\t\t    int\t    count = 0;\n\n\t\t\t    // If a digit is following it could be a key with\n\t\t\t    // modifier, e.g., ESC [ 1;2P.  Can be confused\n\t\t\t    // with DEC_MOUSE, which requires four numbers\n\t\t\t    // following.  If not then it can't be a DEC_MOUSE\n\t\t\t    // code.\n\t\t\t    for (;;)\n\t\t\t    {\n\t\t\t\t++count;\n\t\t\t\t(void)getdigits(&nr);\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t\tif (*nr != ';')\n\t\t\t\t    break;\n\t\t\t\t++nr;\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t    }\n\t\t\t    if (count < 4)\n\t\t\t\tcontinue;\t// no match\n\t\t\t}\n\t\t    }\n\t\t    if (looks_like_mouse_start)\n\t\t    {\n\t\t\t// Only use it when there is no other match.\n\t\t\tif (mouse_index_found < 0)\n\t\t\t    mouse_index_found = idx;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Check for code with modifier, like xterm uses:\n\t\t * <Esc>[123;*X  (modslen == slen - 3)\n\t\t * <Esc>[@;*X    (matches <Esc>[X and <Esc>[1;9X )\n\t\t * Also <Esc>O*X and <M-O>*X (modslen == slen - 2).\n\t\t * When there is a modifier the * matches a number.\n\t\t * When there is no modifier the ;* or * is omitted.\n\t\t */\n\t\tif (termcodes[idx].modlen > 0 && mouse_index_found < 0)\n\t\t{\n\t\t    int at_code;\n\n\t\t    modslen = termcodes[idx].modlen;\n\t\t    if (cpo_koffset && offset && len < modslen)\n\t\t\tcontinue;\n\t\t    at_code = termcodes[idx].code[modslen] == '@';\n\t\t    if (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t(size_t)(modslen > len ? len : modslen)) == 0)\n\t\t    {\n\t\t\tint\t    n;\n\n\t\t\tif (len <= modslen)\t// got a partial sequence\n\t\t\t    return -1;\t\t// need to get more chars\n\n\t\t\tif (tp[modslen] == termcodes[idx].code[slen - 1])\n\t\t\t    // no modifiers\n\t\t\t    slen = modslen + 1;\n\t\t\telse if (tp[modslen] != ';' && modslen == slen - 3)\n\t\t\t    // no match for \"code;*X\" with \"code;\"\n\t\t\t    continue;\n\t\t\telse if (at_code && tp[modslen] != '1')\n\t\t\t    // no match for \"<Esc>[@\" with \"<Esc>[1\"\n\t\t\t    continue;\n\t\t\telse\n\t\t\t{\n\t\t\t    // Skip over the digits, the final char must\n\t\t\t    // follow. URXVT can use a negative value, thus\n\t\t\t    // also accept '-'.\n\t\t\t    for (j = slen - 2; j < len && (isdigit(tp[j])\n\t\t\t\t       || tp[j] == '-' || tp[j] == ';'); ++j)\n\t\t\t\t;\n\t\t\t    ++j;\n\t\t\t    if (len < j)\t// got a partial sequence\n\t\t\t\treturn -1;\t// need to get more chars\n\t\t\t    if (tp[j - 1] != termcodes[idx].code[slen - 1])\n\t\t\t\tcontinue;\t// no match\n\n\t\t\t    modifiers_start = tp + slen - 2;\n\n\t\t\t    // Match!  Convert modifier bits.\n\t\t\t    n = atoi((char *)modifiers_start);\n\t\t\t    modifiers |= decode_modifiers(n);\n\n\t\t\t    slen = j;\n\t\t\t}\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (idx == tc_len && mouse_index_found >= 0)\n\t    {\n\t\tkey_name[0] = termcodes[mouse_index_found].name[0];\n\t\tkey_name[1] = termcodes[mouse_index_found].name[1];\n\t    }\n\t}\n\n#ifdef FEAT_TERMRESPONSE\n\tif (key_name[0] == NUL\n\t    // Mouse codes of DEC and pterm start with <ESC>[.  When\n\t    // detecting the start of these mouse codes they might as well be\n\t    // another key code or terminal response.\n# ifdef FEAT_MOUSE_DEC\n\t    || key_name[0] == KS_DEC_MOUSE\n# endif\n# ifdef FEAT_MOUSE_PTERM\n\t    || key_name[0] == KS_PTERM_MOUSE\n# endif\n\t   )\n\t{\n\t    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;\n\n\t    /*\n\t     * Check for responses from the terminal starting with {lead}:\n\t     * \"<Esc>[\" or CSI followed by [0-9>?]\n\t     *\n\t     * - Xterm version string: {lead}>{x};{vers};{y}c\n\t     *   Also eat other possible responses to t_RV, rxvt returns\n\t     *   \"{lead}?1;2c\".\n\t     *\n\t     * - Cursor position report: {lead}{row};{col}R\n\t     *   The final byte must be 'R'. It is used for checking the\n\t     *   ambiguous-width character state.\n\t     *\n\t     * - window position reply: {lead}3;{x};{y}t\n\t     *\n\t     * - key with modifiers when modifyOtherKeys is enabled:\n\t     *\t    {lead}27;{modifier};{key}~\n\t     *\t    {lead}{key};{modifier}u\n\t     */\n\t    if (((tp[0] == ESC && len >= 3 && tp[1] == '[')\n\t\t\t    || (tp[0] == CSI && len >= 2))\n\t\t    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))\n\t    {\n\t\tint resp = handle_csi(tp, len, argp, offset, buf,\n\t\t\t\t\t     bufsize, buflen, key_name, &slen);\n\t\tif (resp != 0)\n\t\t{\n# ifdef DEBUG_TERMRESPONSE\n\t\t    if (resp == -1)\n\t\t\tLOG_TR((\"Not enough characters for CSI sequence\"));\n# endif\n\t\t    return resp;\n\t\t}\n\t    }\n\n\t    // Check for fore/background color response from the terminal,\n\t    // starting} with <Esc>] or OSC\n\t    else if ((*T_RBG != NUL || *T_RFG != NUL)\n\t\t\t&& ((tp[0] == ESC && len >= 2 && tp[1] == ']')\n\t\t\t    || tp[0] == OSC))\n\t    {\n\t\tif (handle_osc(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\n\t    // Check for key code response from xterm,\n\t    // starting with <Esc>P or DCS\n\t    else if ((check_for_codes || rcs_status.tr_progress == STATUS_SENT)\n\t\t    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')\n\t\t\t|| tp[0] == DCS))\n\t    {\n\t\tif (handle_dcs(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\t}\n#endif\n\n\tif (key_name[0] == NUL)\n\t    continue;\t    // No match at this position, try next one\n\n\t// We only get here when we have a complete termcode match\n\n#ifdef FEAT_GUI\n\t/*\n\t * Only in the GUI: Fetch the pointer coordinates of the scroll event\n\t * so that we know which window to scroll later.\n\t */\n\tif (gui.in_use\n\t\t&& key_name[0] == (int)KS_EXTRA\n\t\t&& (key_name[1] == (int)KE_X1MOUSE\n\t\t    || key_name[1] == (int)KE_X2MOUSE\n\t\t    || key_name[1] == (int)KE_MOUSEMOVE_XY\n\t\t    || key_name[1] == (int)KE_MOUSELEFT\n\t\t    || key_name[1] == (int)KE_MOUSERIGHT\n\t\t    || key_name[1] == (int)KE_MOUSEDOWN\n\t\t    || key_name[1] == (int)KE_MOUSEUP))\n\t{\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 4);\n\n\t    if (num_bytes == -1)\t// not enough coordinates\n\t\treturn -1;\n\t    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;\n\t    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;\n\t    slen += num_bytes;\n\t    // equal to K_MOUSEMOVE\n\t    if (key_name[1] == (int)KE_MOUSEMOVE_XY)\n\t\tkey_name[1] = (int)KE_MOUSEMOVE;\n\t}\n\telse\n#endif\n\t/*\n\t * If it is a mouse click, get the coordinates.\n\t */\n\tif (key_name[0] == KS_MOUSE\n#ifdef FEAT_MOUSE_GPM\n\t\t|| key_name[0] == KS_GPM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_JSB\n\t\t|| key_name[0] == KS_JSBTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_NET\n\t\t|| key_name[0] == KS_NETTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_DEC\n\t\t|| key_name[0] == KS_DEC_MOUSE\n#endif\n#ifdef FEAT_MOUSE_PTERM\n\t\t|| key_name[0] == KS_PTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_URXVT\n\t\t|| key_name[0] == KS_URXVT_MOUSE\n#endif\n\t\t|| key_name[0] == KS_SGR_MOUSE\n\t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t{\n\t    if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx,\n\t\t\t\t\t\t\t     &modifiers) == -1)\n\t\treturn -1;\n\t}\n\n#ifdef FEAT_GUI\n\t/*\n\t * If using the GUI, then we get menu and scrollbar events.\n\t *\n\t * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by\n\t * four bytes which are to be taken as a pointer to the vimmenu_T\n\t * structure.\n\t *\n\t * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where \"nr\"\n\t * is one byte with the tab index.\n\t *\n\t * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed\n\t * by one byte representing the scrollbar number, and then four bytes\n\t * representing a long_u which is the new value of the scrollbar.\n\t *\n\t * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,\n\t * KE_FILLER followed by four bytes representing a long_u which is the\n\t * new value of the scrollbar.\n\t */\n# ifdef FEAT_MENU\n\telse if (key_name[0] == (int)KS_MENU)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes = get_long_from_buf(tp + slen, &val);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_menu = (vimmenu_T *)val;\n\t    slen += num_bytes;\n\n\t    // The menu may have been deleted right after it was used, check\n\t    // for that.\n\t    if (check_menu_pointer(root_menu, current_menu) == FAIL)\n\t    {\n\t\tkey_name[0] = KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n# endif\n# ifdef FEAT_GUI_TABLINE\n\telse if (key_name[0] == (int)KS_TABLINE)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 1);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    if (current_tab == 255)\t// -1 in a byte gives 255\n\t\tcurrent_tab = -1;\n\t    slen += num_bytes;\n\t}\n\telse if (key_name[0] == (int)KS_TABMENU)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 2);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    current_tabmenu = (int)bytes[1];\n\t    slen += num_bytes;\n\t}\n# endif\n# ifndef USE_ON_FLY_SCROLL\n\telse if (key_name[0] == (int)KS_VER_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes;\n\n\t    // Get the last scrollbar event in the queue of the same type\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_bytes_from_buf(tp + j, bytes, 1);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tif (i == 0)\n\t\t    current_scrollbar = (int)bytes[0];\n\t\telse if (current_scrollbar != (int)bytes[0])\n\t\t    break;\n\t\tj += num_bytes;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n\telse if (key_name[0] == (int)KS_HOR_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes;\n\n\t    // Get the last horiz. scrollbar event in the queue\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n# endif // !USE_ON_FLY_SCROLL\n#endif // FEAT_GUI\n\n#if (defined(UNIX) || defined(VMS))\n\t/*\n\t * Handle FocusIn/FocusOut event sequences reported by XTerm.\n\t * (CSI I/CSI O)\n\t */\n\tif (key_name[0] == KS_EXTRA\n# ifdef FEAT_GUI\n\t\t&& !gui.in_use\n# endif\n\t    )\n\t{\n\t    if (key_name[1] == KE_FOCUSGAINED)\n\t    {\n\t\tif (!focus_state)\n\t\t{\n\t\t    ui_focus_change(TRUE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = TRUE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t    else if (key_name[1] == KE_FOCUSLOST)\n\t    {\n\t\tif (focus_state)\n\t\t{\n\t\t    ui_focus_change(FALSE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = FALSE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Change <xHome> to <Home>, <xUp> to <Up>, etc.\n\t */\n\tkey = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));\n\n\t/*\n\t * Add any modifier codes to our string.\n\t */\n\tnew_slen = modifiers2keycode(modifiers, &key, string);\n\n\t// Finally, add the special key code to our string\n\tkey_name[0] = KEY2TERMCAP0(key);\n\tkey_name[1] = KEY2TERMCAP1(key);\n\tif (key_name[0] == KS_KEY)\n\t{\n\t    // from \":set <M-b>=xx\"\n\t    if (has_mbyte)\n\t\tnew_slen += (*mb_char2bytes)(key_name[1], string + new_slen);\n\t    else\n\t\tstring[new_slen++] = key_name[1];\n\t}\n\telse if (new_slen == 0 && key_name[0] == KS_EXTRA\n\t\t\t\t\t\t  && key_name[1] == KE_IGNORE)\n\t{\n\t    // Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED\n\t    // to indicate what happened.\n\t    retval = KEYLEN_REMOVED;\n\t}\n\telse\n\t{\n\t    string[new_slen++] = K_SPECIAL;\n\t    string[new_slen++] = key_name[0];\n\t    string[new_slen++] = key_name[1];\n\t}\n\tif (put_string_in_typebuf(offset, slen, string, new_slen,\n\t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n\t    return -1;\n\treturn retval == 0 ? (len + new_slen - slen + offset) : retval;\n    }\n\n#ifdef FEAT_TERMRESPONSE\n    LOG_TR((\"normal character\"));\n#endif\n\n    return 0;\t\t\t    // no match found\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 566,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n    int\t\tsave_new_cmdpos = new_cmdpos;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    new_cmdpos = save_new_cmdpos;\n\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 572,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tsize_t i, o4, nelements, j, slen, left;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *,\n\t    cdf_offset(sst->sst_tab, offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\n\tif (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)\n\t\tgoto out;\n\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tinp = cdf_grow_info(info, maxcount, sh.sh_properties);\n\tif (inp == NULL)\n\t\tgoto out;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));\n\te = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));\n\tif (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tif ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)\n\t\t\tgoto out;\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tleft = CAST(size_t, e - q);\n\t\tif (left < sizeof(uint32_t)) {\n\t\t\tDPRINTF((\"short info (no type)_\\n\"));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%#x type=%#x offs=%#tx,%#x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tif (left < sizeof(uint32_t) * 2) {\n\t\t\t\tDPRINTF((\"missing CDF_VECTOR length\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements > CDF_ELEMENT_LIMIT || nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == %\"\n\t\t\t\t    SIZE_T_FORMAT \"u\\n\", nelements));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tslen = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\tslen = 1;\n\t\t}\n\t\to4 = slen * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\tcase CDF_FLOAT:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\tcase CDF_UNSIGNED64:\n\t\tcase CDF_DOUBLE:\n\t\tcase CDF_FILETIME:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tinp = cdf_grow_info(info, maxcount, nelements);\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tinp += nelem;\n\t\t\t}\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l;\n\n\t\t\t\tif (o4 + sizeof(uint32_t) > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tl = CDF_GETUINT32(q, slen);\n\t\t\t\to4 += sizeof(uint32_t);\n\t\t\t\tif (o4 + l > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = CAST(const char *,\n\t\t\t\t    CAST(const void *, &q[o4]));\n\n\t\t\t\tDPRINTF((\"o=%\" SIZE_T_FORMAT \"u l=%d(%\"\n\t\t\t\t    SIZE_T_FORMAT \"u), t=%\" SIZE_T_FORMAT\n\t\t\t\t    \"u s=%s\\n\", o4, l, CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    left, inp[i].pi_str.s_buf));\n\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\n\t\t\t\tslen += l >> 1;\n\t\t\t\to4 = slen * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tmemset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));\n\t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\t*info = NULL;\n\t*count = 0;\n\t*maxcount = 0;\n\terrno = EFTYPE;\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 596,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static void *seq_buf_alloc(unsigned long size)\n{\n\tif (unlikely(size > MAX_RW_COUNT))\n\t\treturn NULL;\n\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 598,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MagickPathExtent];\n\n  CINInfo\n    cin;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4],\n    *pixels;\n\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  if (cin.file.image_offset < 712)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n    sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n  (void) memset(cin.origination.serial,0, \n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const unsigned char *) NULL,\n        cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) SetImageBackgroundColor(image,exception);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,MagickFalse);\n  quantum_type=RGBQuantum;\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  status=SetQuantumPad(image,quantum_info,0);\n  pixels=GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const void\n      *stream;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    stream=ReadBlobStream(image,length,pixels,&count);\n    if ((size_t) count != length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,(unsigned char *) stream,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 604,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t// after the list of sections, there's a bunch of unknown\n\t// data, brobably dwords, and then the same section list again\n\t// this function aims to parse it.\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\t// eprintf (\"Dragon's magic:\\n\");\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\t// hack for C22F7494\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 632,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tstatic const char module[] = \"LZWDecodeCompat\";\n\tLZWCodecState *sp = DecoderState(tif);\n\tchar *op = (char*) op0;\n\tlong occ = (long) occ0;\n\tchar *tp;\n\tunsigned char *bp;\n\tint code, nbits;\n\tint len;\n\tlong nextbits, nextdata, nbitsmask;\n\tcode_t *codep, *free_entp, *maxcodep, *oldcodep;\n\n\t(void) s;\n\tassert(sp != NULL);\n\n\t/*\n\t  Fail if value does not fit in long.\n\t*/\n\tif ((tmsize_t) occ != occ0)\n\t        return (0);\n\n\t/*\n\t * Restart interrupted output operation.\n\t */\n\tif (sp->dec_restart) {\n\t\tlong residue;\n\n\t\tcodep = sp->dec_codep;\n\t\tresidue = codep->length - sp->dec_restart;\n\t\tif (residue > occ) {\n\t\t\t/*\n\t\t\t * Residue from previous decode is sufficient\n\t\t\t * to satisfy decode request.  Skip to the\n\t\t\t * start of the decoded string, place decoded\n\t\t\t * values in the output buffer, and return.\n\t\t\t */\n\t\t\tsp->dec_restart += occ;\n\t\t\tdo {\n\t\t\t\tcodep = codep->next;\n\t\t\t} while (--residue > occ);\n\t\t\ttp = op + occ;\n\t\t\tdo {\n\t\t\t\t*--tp = codep->value;\n\t\t\t\tcodep = codep->next;\n\t\t\t} while (--occ);\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Residue satisfies only part of the decode request.\n\t\t */\n\t\top += residue;\n\t\tocc -= residue;\n\t\ttp = op;\n\t\tdo {\n\t\t\t*--tp = codep->value;\n\t\t\tcodep = codep->next;\n\t\t} while (--residue);\n\t\tsp->dec_restart = 0;\n\t}\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n#ifdef LZW_CHECKEOS\n\tsp->dec_bitsleft = (((uint64)tif->tif_rawcc) << 3);\n#endif\n\tnbits = sp->lzw_nbits;\n\tnextdata = sp->lzw_nextdata;\n\tnextbits = sp->lzw_nextbits;\n\tnbitsmask = sp->dec_nbitsmask;\n\toldcodep = sp->dec_oldcodep;\n\tfree_entp = sp->dec_free_entp;\n\tmaxcodep = sp->dec_maxcodep;\n\n\twhile (occ > 0) {\n\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\n\t\tif (code == CODE_EOI)\n\t\t\tbreak;\n\t\tif (code == CODE_CLEAR) {\n\t\t\tdo {\n\t\t\t\tfree_entp = sp->dec_codetab + CODE_FIRST;\n\t\t\t\t_TIFFmemset(free_entp, 0,\n\t\t\t\t\t    (CSIZE - CODE_FIRST) * sizeof (code_t));\n\t\t\t\tnbits = BITS_MIN;\n\t\t\t\tnbitsmask = MAXCODE(BITS_MIN);\n\t\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\n\t\t\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\n\t\t\t} while (code == CODE_CLEAR);\t/* consecutive CODE_CLEAR codes */\n\t\t\tif (code == CODE_EOI)\n\t\t\t\tbreak;\n\t\t\tif (code > CODE_CLEAR) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\"LZWDecode: Corrupted LZW table at scanline %d\",\n\t\t\t\t\t     tif->tif_row);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t*op++ = (char)code;\n\t\t\tocc--;\n\t\t\toldcodep = sp->dec_codetab + code;\n\t\t\tcontinue;\n\t\t}\n\t\tcodep = sp->dec_codetab + code;\n\n\t\t/*\n\t\t * Add the new entry to the code table.\n\t\t */\n\t\tif (free_entp < &sp->dec_codetab[0] ||\n\t\t    free_entp >= &sp->dec_codetab[CSIZE]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Corrupted LZW table at scanline %d\", tif->tif_row);\n\t\t\treturn (0);\n\t\t}\n\n\t\tfree_entp->next = oldcodep;\n\t\tif (free_entp->next < &sp->dec_codetab[0] ||\n\t\t    free_entp->next >= &sp->dec_codetab[CSIZE]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Corrupted LZW table at scanline %d\", tif->tif_row);\n\t\t\treturn (0);\n\t\t}\n\t\tfree_entp->firstchar = free_entp->next->firstchar;\n\t\tfree_entp->length = free_entp->next->length+1;\n\t\tfree_entp->value = (codep < free_entp) ?\n\t\t    codep->firstchar : free_entp->firstchar;\n\t\tif (++free_entp > maxcodep) {\n\t\t\tif (++nbits > BITS_MAX)\t\t/* should not happen */\n\t\t\t\tnbits = BITS_MAX;\n\t\t\tnbitsmask = MAXCODE(nbits);\n\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\n\t\t}\n\t\toldcodep = codep;\n\t\tif (code >= 256) {\n\t\t\t/*\n\t\t\t * Code maps to a string, copy string\n\t\t\t * value to output (written in reverse).\n\t\t\t */\n\t\t\tif(codep->length == 0) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Wrong length of decoded \"\n\t\t\t\t    \"string: data probably corrupted at scanline %d\",\n\t\t\t\t    tif->tif_row);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (codep->length > occ) {\n\t\t\t\t/*\n\t\t\t\t * String is too long for decode buffer,\n\t\t\t\t * locate portion that will fit, copy to\n\t\t\t\t * the decode buffer, and setup restart\n\t\t\t\t * logic for the next decoding call.\n\t\t\t\t */\n\t\t\t\tsp->dec_codep = codep;\n\t\t\t\tdo {\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t} while (codep->length > occ);\n\t\t\t\tsp->dec_restart = occ;\n\t\t\t\ttp = op + occ;\n\t\t\t\tdo  {\n\t\t\t\t\t*--tp = codep->value;\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t}  while (--occ);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = codep->length;\n\t\t\ttp = op + len;\n\t\t\tdo {\n\t\t\t\tint t;\n\t\t\t\t--tp;\n\t\t\t\tt = codep->value;\n\t\t\t\tcodep = codep->next;\n\t\t\t\t*tp = (char)t;\n\t\t\t} while (codep && tp > op);\n\t\t\tassert(occ >= len);\n\t\t\top += len;\n\t\t\tocc -= len;\n\t\t} else {\n\t\t\t*op++ = (char)code;\n\t\t\tocc--;\n\t\t}\n\t}\n\n\ttif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp );\n\ttif->tif_rawcp = (uint8*) bp;\n\tsp->lzw_nbits = (unsigned short)nbits;\n\tsp->lzw_nextdata = nextdata;\n\tsp->lzw_nextbits = nextbits;\n\tsp->dec_nbitsmask = nbitsmask;\n\tsp->dec_oldcodep = oldcodep;\n\tsp->dec_free_entp = free_entp;\n\tsp->dec_maxcodep = maxcodep;\n\n\tif (occ > 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at scanline %d (short %I64d bytes)\",\n\t\t\t     tif->tif_row, (unsigned __int64) occ);\n#else\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at scanline %d (short %llu bytes)\",\n\t\t\t     tif->tif_row, (unsigned long long) occ);\n#endif\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 672,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {\n\tRzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tsize_t total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tut32 total = total_slide_infos + n_slide_infos[i];\n\t\t\tif (total < total_slide_infos) {\n\t\t\t\t// overflow\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos = total;\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut32 sio;\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 slide_infos_offset = sio;\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRzDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree(infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree(infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);\n\t\t\tfree(infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree(result);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 678,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "int ZEXPORT inflate(strm, flush)\nz_streamp strm;\nint flush;\n{\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next output */\n    unsigned have, left;        /* available input and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    unsigned in, out;           /* save starting available input and output */\n    unsigned copy;              /* number of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to copy match bytes from */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int ret;                    /* return code */\n#ifdef GUNZIP\n    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n#endif\n    static const unsigned short order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n        (strm->next_in == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n                if (state->wbits == 0)\n                    state->wbits = 15;\n                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check, hold);\n                INITBITS();\n                state->mode = FLAGS;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->done = -1;\n            if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n#else\n            if (\n#endif\n                ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg = (char *)\"incorrect header check\";\n                state->mode = BAD;\n                break;\n            }\n            if (BITS(4) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits == 0)\n                state->wbits = len;\n            if (len > 15 || len > state->wbits) {\n                strm->msg = (char *)\"invalid window size\";\n                state->mode = BAD;\n                break;\n            }\n            state->dmax = 1U << len;\n            state->flags = 0;               /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n            state->flags = (int)(hold);\n            if ((state->flags & 0xff) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->flags & 0xe000) {\n                strm->msg = (char *)\"unknown header flags set\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = TIME;\n                /* fallthrough */\n        case TIME:\n            NEEDBITS(32);\n            if (state->head != Z_NULL)\n                state->head->time = hold;\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check, hold);\n            INITBITS();\n            state->mode = OS;\n                /* fallthrough */\n        case OS:\n            NEEDBITS(16);\n            if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = EXLEN;\n                /* fallthrough */\n        case EXLEN:\n            if (state->flags & 0x0400) {\n                NEEDBITS(16);\n                state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n                    state->head->extra_len = (unsigned)hold;\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check, hold);\n                INITBITS();\n            }\n            else if (state->head != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode = EXTRA;\n                /* fallthrough */\n        case EXTRA:\n            if (state->flags & 0x0400) {\n                copy = state->length;\n                if (copy > have) copy = have;\n                if (copy) {\n                    len = state->head->extra_len - state->length;\n                    if (state->head != Z_NULL &&\n                        state->head->extra != Z_NULL &&\n                        len < state->head->extra_max) {\n                        zmemcpy(state->head->extra + len, next,\n                                len + copy > state->head->extra_max ?\n                                state->head->extra_max - len : copy);\n                    }\n                    if ((state->flags & 0x0200) && (state->wrap & 4))\n                        state->check = crc32(state->check, next, copy);\n                    have -= copy;\n                    next += copy;\n                    state->length -= copy;\n                }\n                if (state->length) goto inf_leave;\n            }\n            state->length = 0;\n            state->mode = NAME;\n                /* fallthrough */\n        case NAME:\n            if (state->flags & 0x0800) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->name != Z_NULL &&\n                            state->length < state->head->name_max)\n                        state->head->name[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n            state->length = 0;\n            state->mode = COMMENT;\n                /* fallthrough */\n        case COMMENT:\n            if (state->flags & 0x1000) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->comment != Z_NULL &&\n                            state->length < state->head->comm_max)\n                        state->head->comment[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->comment = Z_NULL;\n            state->mode = HCRC;\n                /* fallthrough */\n        case HCRC:\n            if (state->flags & 0x0200) {\n                NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {\n                    strm->msg = (char *)\"header crc mismatch\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n            }\n            if (state->head != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9) & 1);\n                state->head->done = 1;\n            }\n            strm->adler = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n            break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n            strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n            state->mode = DICT;\n                /* fallthrough */\n        case DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n                return Z_NEED_DICT;\n            }\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n                /* fallthrough */\n        case TYPE:\n            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n                state->mode = CHECK;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                fixedtables(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = LEN_;             /* decode codes */\n                if (flush == Z_TREES) {\n                    DROPBITS(2);\n                    goto inf_leave;\n                }\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (char *)\"invalid block type\";\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n        case STORED:\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n                break;\n            }\n            state->length = (unsigned)hold & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\",\n                    state->length));\n            INITBITS();\n            state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case COPY_:\n            state->mode = COPY;\n                /* fallthrough */\n        case COPY:\n            copy = state->length;\n            if (copy) {\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n                break;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many length or distance symbols\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode = LENLENS;\n                /* fallthrough */\n        case LENLENS:\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid code lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n            state->have = 0;\n            state->mode = CODELENS;\n                /* fallthrough */\n        case CODELENS:\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                }\n                else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            strm->msg = (char *)\"invalid bit length repeat\";\n                            state->mode = BAD;\n                            break;\n                        }\n                        len = state->lens[state->have - 1];\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (char *)\"invalid bit length repeat\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                strm->msg = (char *)\"invalid code -- missing end-of-block\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 9;\n            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->distcode = (const code FAR *)(state->next);\n            state->distbits = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid distances set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case LEN_:\n            state->mode = LEN;\n                /* fallthrough */\n        case LEN:\n            if (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm, out);\n                LOAD();\n                if (state->mode == TYPE)\n                    state->back = -1;\n                break;\n            }\n            state->back = 0;\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            state->length = (unsigned)here.val;\n            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                state->mode = LIT;\n                break;\n            }\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->back = -1;\n                state->mode = TYPE;\n                break;\n            }\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid literal/length code\";\n                state->mode = BAD;\n                break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = LENEXT;\n                /* fallthrough */\n        case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n            state->was = state->length;\n            state->mode = DIST;\n                /* fallthrough */\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = DISTEXT;\n                /* fallthrough */\n        case DISTEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n            if (state->offset > state->dmax) {\n                strm->msg = (char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n            state->mode = MATCH;\n                /* fallthrough */\n        case MATCH:\n            if (left == 0) goto inf_leave;\n            copy = out - left;\n            if (state->offset > copy) {         /* copy from window */\n                copy = state->offset - copy;\n                if (copy > state->whave) {\n                    if (state->sane) {\n                        strm->msg = (char *)\"invalid distance too far back\";\n                        state->mode = BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    Trace((stderr, \"inflate.c too far\\n\"));\n                    copy -= state->whave;\n                    if (copy > state->length) copy = state->length;\n                    if (copy > left) copy = left;\n                    left -= copy;\n                    state->length -= copy;\n                    do {\n                        *put++ = 0;\n                    } while (--copy);\n                    if (state->length == 0) state->mode = LEN;\n                    break;\n#endif\n                }\n                if (copy > state->wnext) {\n                    copy -= state->wnext;\n                    from = state->window + (state->wsize - copy);\n                }\n                else\n                    from = state->window + (state->wnext - copy);\n                if (copy > state->length) copy = state->length;\n            }\n            else {                              /* copy from output */\n                from = put - state->offset;\n                copy = state->length;\n            }\n            if (copy > left) copy = left;\n            left -= copy;\n            state->length -= copy;\n            do {\n                *put++ = *from++;\n            } while (--copy);\n            if (state->length == 0) state->mode = LEN;\n            break;\n        case LIT:\n            if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n            left--;\n            state->mode = LEN;\n            break;\n        case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n                out -= left;\n                strm->total_out += out;\n                state->total += out;\n                if ((state->wrap & 4) && out)\n                    strm->adler = state->check =\n                        UPDATE_CHECK(state->check, put - out, out);\n                out = left;\n                if ((state->wrap & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n                     ZSWAP32(hold)) != state->check) {\n                    strm->msg = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n                /* fallthrough */\n        case LENGTH:\n            if (state->wrap && state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {\n                    strm->msg = (char *)\"incorrect length check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n            }\n#endif\n            state->mode = DONE;\n                /* fallthrough */\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n                /* fallthrough */\n        default:\n            return Z_STREAM_ERROR;\n        }\n\n    /*\n       Return from inflate(), updating the total counts and the check value.\n       If there was no progress during the inflate() call, return a buffer\n       error.  Call updatewindow() to create and/or update the window state.\n       Note: a memory error from inflate() is non-recoverable.\n     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&\n            (state->mode < CHECK || flush != Z_FINISH)))\n        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n            state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n    strm->total_out += out;\n    state->total += out;\n    if ((state->wrap & 4) && out)\n        strm->adler = state->check =\n            UPDATE_CHECK(state->check, strm->next_out - out, out);\n    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n        ret = Z_BUF_ERROR;\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 684,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    if (ptr[new_cursor_col] == NUL)\n\t\tbreak;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 698,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define MaxPixelChannels  32\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n    interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\");\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\");\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG) &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\");\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void) FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n              extra_samples-3,0);\n            if (image->matte != MagickFalse)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n                if (image->matte != MagickFalse)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n                      extra_samples-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));\n            q++;\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff);\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n         if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n          TIFFTileSize(tiff));\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n                0,i);\n              if (tiff_status == -1)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                PixelPacket\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (PixelPacket *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n  return(GetFirstImageInList(image));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 700,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "disable_priv_mode ()\n{\n  int e;\n\n#if HAVE_DECL_SETRESUID\n  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n#else\n  if (setuid (current_user.uid) < 0)\n#endif\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n#if HAVE_DECL_SETRESGID\n  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n#else\n  if (setgid (current_user.gid) < 0)\n#endif\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 712,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu64 elem_size = sizeof(struct stack_map_bucket) +\n\t\t\t(u64)smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 722,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs)\n{\n    uint count = min(max_data,\n                     pcs->status.write_pos - pcs->status.read_pos);\n\n    if (count)\n        memcpy(data, pcs->status.buffer + pcs->status.read_pos, count);\n    pcs->status.read_pos += count;\n    if (pcs->status.read_pos == pcs->status.write_pos) {\n        gs_free_object(pcs->memory, pcs->status.buffer, \"status buffer\");\n        pcs->status.buffer = NULL;\n        pcs->status.write_pos = pcs->status.read_pos = 0;\n    }\n    return count;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 726,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' '%s' '%s' '%s'\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(title,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(description,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(feed_title,\"'\", \"%27\"));\n\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 734,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "spell_suggest(int count)\n{\n    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n    char_u\twcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n    suginfo_T\tsug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\tneed_cap;\n    int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen = 0;\n    int\t\tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\tend_visual_mode();\n\t// make sure we don't include the NUL at the end of the line\n\tline = ml_get_curline();\n\tif (badlen > STRLEN(line) - curwin->w_cursor.col)\n\t    badlen = STRLEN(line) - curwin->w_cursor.col;\n    }\n    // Find the start of the badly spelled word.\n    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    || curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor = prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p, curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len == 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\tif (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t// When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now the rabbit from the high hat: Avoid showing the\n\t    // untranslated message rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    // The suggested word may replace only part of the bad word, add\n\t    // the not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t    if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score, stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p, line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t    ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum, c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\nskip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 748,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n    rfbRREHeader hdr;\n    int i;\n    CARDBPP pix;\n    uint8_t *ptr;\n    int x, y, w, h;\n\n    if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))\n\treturn FALSE;\n\n    hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);\n\n    if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))\n\treturn FALSE;\n\n    client->GotFillRect(client, rx, ry, rw, rh, pix);\n\n    if (hdr.nSubrects > RFB_BUFFER_SIZE / (4 + (BPP / 8)) || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))\n\treturn FALSE;\n\n    ptr = (uint8_t *)client->buffer;\n\n    for (i = 0; i < hdr.nSubrects; i++) {\n\tpix = *(CARDBPP *)ptr;\n\tptr += BPP/8;\n\tx = *ptr++;\n\ty = *ptr++;\n\tw = *ptr++;\n\th = *ptr++;\n\n\tclient->GotFillRect(client, rx+x, ry+y, w, h, pix);\n    }\n\n    return TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 754,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (buf_offset + offset + 8 > sz) {\n\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\treturn NULL;\n\t}\n\tif (attr == NULL) {\n\t\t// TODO eprintf\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (buf_offset + offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tfree (icattr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_inner_classes_attr_summary(attr);\n\treturn attr;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 762,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\n\t/*\n\t * r4 contains the guest physical address of the RTAS args\n\t * Mask off the top 4 bits since this is a guest real address\n\t */\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\n\t/*\n\t * args->rets is a pointer into args->args. Now that we've\n\t * copied args we need to fix it up to point into our copy,\n\t * not the guest args. We also need to save the original\n\t * value so we can restore it on the way out.\n\t */\n\torig_rets = args.rets;\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\t/*\n\t\t * Don't overflow our args array: ensure there is room for\n\t\t * at least rets[0] (even if the call specifies 0 nret).\n\t\t *\n\t\t * Each handler must then check for the correct nargs and nret\n\t\t * values, but they may always return failure in rets[0].\n\t\t */\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn rc;\n\nfail:\n\t/*\n\t * We only get here if the guest has called RTAS with a bogus\n\t * args pointer or nargs/nret values that would overflow the\n\t * array. That means we can't get to the args, and so we can't\n\t * fail the RTAS call. So fail right out to userspace, which\n\t * should kill the guest.\n\t *\n\t * SLOF should actually pass the hcall return value from the\n\t * rtas handler call in r3, so enter_rtas could be modified to\n\t * return a failure indication in r3 and we could return such\n\t * errors to the guest rather than failing to host userspace.\n\t * However old guests that don't test for failure could then\n\t * continue silently after errors, so for now we won't do this.\n\t */\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 768,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "compileRule(FileInfo *file, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable, const MacroList **inScopeMacros) {\n\tCharsString token;\n\tTranslationTableOpcode opcode;\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tCharsString cells;\n\tCharsString scratchPad;\n\tCharsString emphClass;\n\tTranslationTableCharacterAttributes after = 0;\n\tTranslationTableCharacterAttributes before = 0;\n\tint noback, nofor, nocross;\n\tnoback = nofor = nocross = 0;\ndoOpcode:\n\tif (!getToken(file, &token, NULL)) return 1;\t\t\t\t  /* blank line */\n\tif (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */\n\tif (file->lineNumber == 1 &&\n\t\t\t(eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||\n\t\t\t\t\teqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {\n\t\tif (table)\n\t\t\tcompileHyphenation(file, &token, table);\n\t\telse\n\t\t\t/* ignore the whole file */\n\t\t\twhile (_lou_getALine(file))\n\t\t\t\t;\n\t\treturn 1;\n\t}\n\topcode = getOpcode(file, &token);\n\tswitch (opcode) {\n\tcase CTO_Macro: {\n\t\tconst Macro *macro;\n#ifdef ENABLE_MACROS\n\t\tif (!inScopeMacros) {\n\t\t\tcompileError(file, \"Defining macros only allowed in table files.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (compileMacro(file, &macro)) {\n\t\t\t*inScopeMacros = cons_macro(macro, *inScopeMacros);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n#else\n\t\tcompileError(file, \"Macro feature is disabled.\");\n\t\treturn 0;\n#endif\n\t}\n\tcase CTO_IncludeFile: {\n\t\tCharsString includedFile;\n\t\tif (!getToken(file, &token, \"include file name\")) return 0;\n\t\tif (!parseChars(file, &includedFile, &token)) return 0;\n\t\treturn includeFile(file, &includedFile, table, displayTable);\n\t}\n\tcase CTO_NoBack:\n\t\tif (nofor) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));\n\t\t\treturn 0;\n\t\t}\n\t\tnoback = 1;\n\t\tgoto doOpcode;\n\tcase CTO_NoFor:\n\t\tif (noback) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));\n\t\t\treturn 0;\n\t\t}\n\t\tnofor = 1;\n\t\tgoto doOpcode;\n\tcase CTO_Space:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Space, noback, nofor, table, displayTable);\n\tcase CTO_Digit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Digit, noback, nofor, table, displayTable);\n\tcase CTO_LitDigit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LitDigit, noback, nofor, table, displayTable);\n\tcase CTO_Punctuation:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Punctuation, noback, nofor, table, displayTable);\n\tcase CTO_Math:\n\t\treturn compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);\n\tcase CTO_Sign:\n\t\treturn compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);\n\tcase CTO_Letter:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Letter, noback, nofor, table, displayTable);\n\tcase CTO_UpperCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_UpperCase, noback, nofor, table, displayTable);\n\tcase CTO_LowerCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LowerCase, noback, nofor, table, displayTable);\n\tcase CTO_Grouping:\n\t\treturn compileGrouping(file, noback, nofor, table, displayTable);\n\tcase CTO_Display:\n\t\tif (!displayTable) return 1;  // ignore\n\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\tif (ruleChars.length != 1 || ruleDots.length != 1) {\n\t\t\tcompileError(file, \"Exactly one character and one cell are required.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn putCharDotsMapping(\n\t\t\t\tfile, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n\tcase CTO_UpLow:\n\tcase CTO_None: {\n\t\t// check if token is a macro name\n\t\tif (inScopeMacros) {\n\t\t\tconst MacroList *macros = *inScopeMacros;\n\t\t\twhile (macros) {\n\t\t\t\tconst Macro *m = macros->head;\n\t\t\t\tif (token.length == strlen(m->name) &&\n\t\t\t\t\t\teqasc2uni((unsigned char *)m->name, token.chars, token.length)) {\n\t\t\t\t\tif (!inScopeMacros) {\n\t\t\t\t\t\tcompileError(file, \"Calling macros only allowed in table files.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tFileInfo tmpFile;\n\t\t\t\t\tmemset(&tmpFile, 0, sizeof(tmpFile));\n\t\t\t\t\ttmpFile.fileName = file->fileName;\n\t\t\t\t\ttmpFile.sourceFile = file->sourceFile;\n\t\t\t\t\ttmpFile.lineNumber = file->lineNumber;\n\t\t\t\t\ttmpFile.encoding = noEncoding;\n\t\t\t\t\ttmpFile.status = 0;\n\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\tint argument_count = 0;\n\t\t\t\t\tCharsString *arguments =\n\t\t\t\t\t\t\tmalloc(m->argument_count * sizeof(CharsString));\n\t\t\t\t\twhile (argument_count < m->argument_count) {\n\t\t\t\t\t\tif (getToken(file, &token, \"macro argument\"))\n\t\t\t\t\t\t\targuments[argument_count++] = token;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (argument_count < m->argument_count) {\n\t\t\t\t\t\tcompileError(file, \"Expected %d arguments\", m->argument_count);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint subst = 0;\n\t\t\t\t\tint next = subst < m->substitution_count ? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t : m->definition_length;\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\twhile (i < next) {\n\t\t\t\t\t\t\twidechar c = m->definition[i++];\n\t\t\t\t\t\t\tif (c == '\\n') {\n\t\t\t\t\t\t\t\tif (!compileRule(&tmpFile, table, displayTable,\n\t\t\t\t\t\t\t\t\t\t\tinScopeMacros)) {\n\t\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\t\t\t} else if (tmpFile.linelen >= MAXSTRING) {\n\t\t\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\t\t\"Line exceeds %d characters (post macro \"\n\t\t\t\t\t\t\t\t\t\t\"expansion)\",\n\t\t\t\t\t\t\t\t\t\tMAXSTRING);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (subst < m->substitution_count) {\n\t\t\t\t\t\t\tCharsString arg =\n\t\t\t\t\t\t\t\t\targuments[m->substitutions[2 * subst + 1] - 1];\n\t\t\t\t\t\t\tfor (int j = 0; j < arg.length; j++)\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = arg.chars[j];\n\t\t\t\t\t\t\tsubst++;\n\t\t\t\t\t\t\tnext = subst < m->substitution_count\n\t\t\t\t\t\t\t\t\t? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t: m->definition_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!compileRule(\n\t\t\t\t\t\t\t\t\t\t&tmpFile, table, displayTable, inScopeMacros)) {\n\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tmacros = macros->tail;\n\t\t\t}\n\t\t}\n\t\tif (opcode == CTO_UpLow) {\n\t\t\tcompileError(file, \"The uplow opcode is deprecated.\");\n\t\t\treturn 0;\n\t\t}\n\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\treturn 0;\n\t}\n\n\t/* now only opcodes follow that don't modify the display table */\n\tdefault:\n\t\tif (!table) return 1;\n\t\tswitch (opcode) {\n\t\tcase CTO_Locale:\n\t\t\tcompileWarning(file,\n\t\t\t\t\t\"The locale opcode is not implemented. Use the locale meta data \"\n\t\t\t\t\t\"instead.\");\n\t\t\treturn 1;\n\t\tcase CTO_Undefined: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->undefined;\n\t\t\tif (!compileBrailleIndicator(file, \"undefined character opcode\",\n\t\t\t\t\t\tCTO_Undefined, &ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->undefined = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Match: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternsOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnoback = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\t&rule, noback, nofor, table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternsOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternsOffset;\n\t\t\tok = 1;\n\t\tCTO_Match_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_BackMatch: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnofor = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternOffset;\n\t\t\tok = 1;\n\t\tCTO_BackMatch_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_CapsLetter:\n\t\tcase CTO_BegCapsWord:\n\t\tcase CTO_EndCapsWord:\n\t\tcase CTO_BegCaps:\n\t\tcase CTO_EndCaps:\n\t\tcase CTO_BegCapsPhrase:\n\t\tcase CTO_EndCapsPhrase:\n\t\tcase CTO_LenCapsPhrase:\n\t\t/* these 8 general purpose opcodes are compiled further down to more specific\n\t\t * internal opcodes:\n\t\t * - modeletter\n\t\t * - begmodeword\n\t\t * - endmodeword\n\t\t * - begmode\n\t\t * - endmode\n\t\t * - begmodephrase\n\t\t * - endmodephrase\n\t\t * - lenmodephrase\n\t\t */\n\t\tcase CTO_ModeLetter:\n\t\tcase CTO_BegModeWord:\n\t\tcase CTO_EndModeWord:\n\t\tcase CTO_BegMode:\n\t\tcase CTO_EndMode:\n\t\tcase CTO_BegModePhrase:\n\t\tcase CTO_EndModePhrase:\n\t\tcase CTO_LenModePhrase: {\n\t\t\tTranslationTableCharacterAttributes mode;\n\t\t\tint i;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_CapsLetter:\n\t\t\tcase CTO_BegCapsWord:\n\t\t\tcase CTO_EndCapsWord:\n\t\t\tcase CTO_BegCaps:\n\t\t\tcase CTO_EndCaps:\n\t\t\tcase CTO_BegCapsPhrase:\n\t\t\tcase CTO_EndCapsPhrase:\n\t\t\tcase CTO_LenCapsPhrase:\n\t\t\t\tmode = CTC_UpperCase;\n\t\t\t\ti = 0;\n\t\t\t\topcode += (CTO_ModeLetter - CTO_CapsLetter);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tconst CharacterClass *characterClass = findCharacterClass(&token, *table);\n\t\t\t\tif (!characterClass) {\n\t\t\t\t\tcharacterClass =\n\t\t\t\t\t\t\taddCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\t\tif (!characterClass) return 0;\n\t\t\t\t}\n\t\t\t\tmode = characterClass->attribute;\n\t\t\t\tif (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&\n\t\t\t\t\t\tmode <= CTC_LitDigit) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"mode must be \\\"uppercase\\\", \\\"digit\\\", or a custom \"\n\t\t\t\t\t\t\t\"attribute name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* check if this mode is already defined and if the number of modes does\n\t\t\t\t * not exceed the maximal number */\n\t\t\t\tif (mode == CTC_UpperCase)\n\t\t\t\t\ti = 0;\n\t\t\t\telse {\n\t\t\t\t\tfor (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {\n\t\t\t\t\t\tif ((*table)->modes[i].mode == mode) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == MAX_MODES) {\n\t\t\t\t\t\tcompileError(file, \"Max number of modes (%i) reached\", MAX_MODES);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(*table)->modes[i].value)\n\t\t\t\t(*table)->modes[i] = (EmphasisClass){ plain_text, mode,\n\t\t\t\t\t0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_BegModePhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModePhrase: {\n\t\t\t\tTranslationTableOffset ruleOffset;\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1:\t // before\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign after last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign before last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tcase 2:\t // after\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t   [endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign before last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign after last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,\n\t\t\t\t\t\t\t\tnofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcase CTO_BegMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter capital sign\",\n\t\t\t\t\t\t\tCTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_ModeLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter capital sign\",\n\t\t\t\t\t\t\tCTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_BegModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word\",\n\t\t\t\t\t\t\tCTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word stop\",\n\t\t\t\t\t\t\tCTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_LenModePhrase:\n\t\t\t\treturn (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] =\n\t\t\t\t\t\t\t   compileNumber(file);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* these 8 general purpose emphasis opcodes are compiled further down to more\n\t\t * specific internal opcodes:\n\t\t * - emphletter\n\t\t * - begemphword\n\t\t * - endemphword\n\t\t * - begemph\n\t\t * - endemph\n\t\t * - begemphphrase\n\t\t * - endemphphrase\n\t\t * - lenemphphrase\n\t\t */\n\t\tcase CTO_EmphClass:\n\t\t\tif (!getToken(file, &emphClass, \"emphasis class\")) {\n\t\t\t\tcompileError(file, \"emphclass must be followed by a valid class name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint k, i;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Duplicate emphasis class: %s\", s);\n\t\t\t\t\twarningCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\tif (i == MAX_EMPH_CLASSES) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\"Max number of emphasis classes (%i) reached\", MAX_EMPH_CLASSES);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\t/* For backwards compatibility (i.e. because programs will assume\n\t\t\t * the first 3 typeform bits are `italic', `underline' and `bold')\n\t\t\t * we require that the first 3 emphclass definitions are (in that\n\t\t\t * order):\n\t\t\t *\n\t\t\t *   emphclass italic\n\t\t\t *   emphclass underline\n\t\t\t *   emphclass bold\n\t\t\t *\n\t\t\t * While it would be possible to use the emphclass opcode only for\n\t\t\t * defining _additional_ classes (not allowing for them to be called\n\t\t\t * italic, underline or bold), thereby reducing the amount of\n\t\t\t * boilerplate, we deliberately choose not to do that in order to\n\t\t\t * not give italic, underline and bold any special status. The\n\t\t\t * hope is that eventually all programs will use liblouis for\n\t\t\t * emphasis the recommended way (i.e. by looking up the supported\n\t\t\t * typeforms in the documentation or API) so that we can drop this\n\t\t\t * restriction.\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t\tif (strcmp(s, \"italic\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"First emphasis class must be \\\"italic\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (strcmp(s, \"underline\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Second emphasis class must be \\\"underline\\\" but \"\n\t\t\t\t\t\t\t\"got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (strcmp(s, \"bold\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Third emphasis class must be \\\"bold\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*table)->emphClassNames[i] = s;\n\t\t\t(*table)->emphClasses[i] = (EmphasisClass){ emph_1\n\t\t\t\t\t\t<< i, /* relies on the order of typeforms emph_1..emph_10 */\n\t\t\t\t0, 0x1 << i, i };\n\t\t\treturn 1;\n\t\tcase CTO_EmphLetter:\n\t\tcase CTO_BegEmphWord:\n\t\tcase CTO_EndEmphWord:\n\t\tcase CTO_BegEmph:\n\t\tcase CTO_EndEmph:\n\t\tcase CTO_BegEmphPhrase:\n\t\tcase CTO_EndEmphPhrase:\n\t\tcase CTO_LenEmphPhrase:\n\t\tcase CTO_EmphModeChars:\n\t\tcase CTO_NoEmphChars: {\n\t\t\tif (!getToken(file, &token, \"emphasis class\")) return 0;\n\t\t\tif (!parseChars(file, &emphClass, &token)) return 0;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tint k, i;\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) break;\n\t\t\tif (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Emphasis class %s not declared\", s);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint ok = 0;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_EmphLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][letterOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word stop\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmph: {\n\t\t\t\t/* fail if both begemph and any of begemphphrase or begemphword are\n\t\t\t\t * defined */\n\t\t\t\tif ((*table)->emphRules[i][begWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both begemph and \"\n\t\t\t\t\t\t\t\"begemphword or begemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmph: {\n\t\t\t\tif ((*table)->emphRules[i][endWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both endemph and \"\n\t\t\t\t\t\t\t\"endemphword or endemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphPhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begPhraseOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphPhrase:\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1: {  // before\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word after already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word before\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {  // after\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word before already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word after\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CTO_LenEmphPhrase:\n\t\t\t\tif (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))\n\t\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\tcase CTO_EmphModeChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *emphmodechars = (*table)->emphModeChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > EMPHMODECHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", EMPHMODECHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Emphasis mode character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\temphmodechars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_NoEmphChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *noemphchars = (*table)->noEmphChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > NOEMPHCHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", NOEMPHCHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnoemphchars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn ok;\n\t\t}\n\t\tcase CTO_LetterSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->letterSign;\n\t\t\tif (!compileBrailleIndicator(file, \"letter sign\", CTO_LetterRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->letterSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoLetsignBefore:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNBEFORESIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsign:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsignAfter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNAFTERSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NumberSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->numberSign;\n\t\t\tif (!compileBrailleIndicator(file, \"number sign\", CTO_NumberRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->numberSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\n\t\tcase CTO_NumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric mode character undefined: %s\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_MidEndNumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Midendnumeric mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_MidEndNumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NumericNoContractChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric no contraction character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericNoContract;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NoContractSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->noContractSign;\n\t\t\tif (!compileBrailleIndicator(file, \"no contractions sign\", CTO_NoContractRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->noContractSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_SeqDelimiter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence delimiter character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqDelimiter;\n\t\t\t\t(*table)->usesSequences = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqBeforeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence before character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqBefore;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence after character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqAfter;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterPattern:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];\n\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterExpression:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif ((ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqAfterExpression[k] = ruleChars.chars[k];\n\t\t\t(*table)->seqAfterExpression[ruleChars.length] = 0;\n\t\t\t(*table)->seqAfterExpressionLength = ruleChars.length;\n\t\t\treturn 1;\n\n\t\tcase CTO_CapsModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Capital mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_CapsMode;\n\t\t\t\t(*table)->hasCapsModeChars = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_BegComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->begComp;\n\t\t\tif (!compileBrailleIndicator(file, \"begin computer braille\", CTO_BegCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->begComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_EndComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->endComp;\n\t\t\tif (!compileBrailleIndicator(file, \"end computer braslle\", CTO_EndCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->endComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoCross:\n\t\t\tif (nocross) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"%s already specified.\", _lou_findOpcodeName(CTO_NoCross));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnocross = 1;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_Syllable:\n\t\t\t(*table)->syllables = 1;\n\t\tcase CTO_Always:\n\t\tcase CTO_LargeSign:\n\t\tcase CTO_WholeWord:\n\t\tcase CTO_PartWord:\n\t\tcase CTO_JoinNum:\n\t\tcase CTO_JoinableWord:\n\t\tcase CTO_LowWord:\n\t\tcase CTO_SuffixableWord:\n\t\tcase CTO_PrefixableWord:\n\t\tcase CTO_BegWord:\n\t\tcase CTO_BegMidWord:\n\t\tcase CTO_MidWord:\n\t\tcase CTO_MidEndWord:\n\t\tcase CTO_EndWord:\n\t\tcase CTO_PrePunc:\n\t\tcase CTO_PostPunc:\n\t\tcase CTO_BegNum:\n\t\tcase CTO_MidNum:\n\t\tcase CTO_EndNum:\n\t\tcase CTO_Repeated:\n\t\tcase CTO_RepWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleDots.length == 0)\n\t\t\t\t// check that all characters in a rule with `=` as second operand are\n\t\t\t\t// defined (or based on another character)\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\tgetChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tTranslationTableRule *r;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\tif (nocross) r->nocross = 1;\n\t\t\treturn 1;\n\t\t\t// if (opcode == CTO_MidNum)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c = getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tcase CTO_RepEndWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tCharsString dots;\n\t\t\tif (!getToken(file, &dots, \"dots,dots operand\")) return 0;\n\t\t\tint len = dots.length;\n\t\t\tfor (int k = 0; k < len - 1; k++) {\n\t\t\t\tif (dots.chars[k] == ',') {\n\t\t\t\t\tdots.length = k;\n\t\t\t\t\tif (!parseDots(file, &ruleDots, &dots)) return 0;\n\t\t\t\t\truleDots.chars[ruleDots.length++] = ',';\n\t\t\t\t\tk++;\n\t\t\t\t\tif (k == len - 1 && dots.chars[k] == '=') {\n\t\t\t\t\t\t// check that all characters are defined (or based on another\n\t\t\t\t\t\t// character)\n\t\t\t\t\t\tfor (int l = 0; l < ruleChars.length; l++) {\n\t\t\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\t\t\tgetChar(ruleChars.chars[l], *table, NULL);\n\t\t\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[l], 1, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tCharsString x, y;\n\t\t\t\t\t\tx.length = 0;\n\t\t\t\t\t\twhile (k < len) x.chars[x.length++] = dots.chars[k++];\n\t\t\t\t\t\tif (parseDots(file, &y, &x))\n\t\t\t\t\t\t\tfor (int l = 0; l < y.length; l++)\n\t\t\t\t\t\t\t\truleDots.chars[ruleDots.length++] = y.chars[l];\n\t\t\t\t\t}\n\t\t\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before,\n\t\t\t\t\t\t\tNULL, NULL, noback, nofor, table);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase CTO_CompDots:\n\t\tcase CTO_Comp6: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.length != 1) {\n\t\t\t\tcompileError(file, \"first operand must be 1 character\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed on comp6 rules\");\n\t\t\t}\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\tNULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_ExactDots:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.chars[0] != '@') {\n\t\t\t\tcompileError(file, \"The operand must begin with an at sign (@)\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 1; k < ruleChars.length; k++)\n\t\t\t\tscratchPad.chars[k - 1] = ruleChars.chars[k];\n\t\t\tscratchPad.length = ruleChars.length - 1;\n\t\t\tif (!parseDots(file, &ruleDots, &scratchPad)) return 0;\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_CapsNoCont: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\truleChars.length = 1;\n\t\t\truleChars.chars[0] = 'a';\n\t\t\tif (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,\n\t\t\t\t\t\t&ruleOffset, NULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->capsNoCont = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Replace:\n\t\t\tif (getRuleCharsText(file, &ruleChars)) {\n\t\t\t\tif (atEndOfLine(file))\n\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\telse {\n\t\t\t\t\tgetRuleDotsText(file, &ruleDots);\n\t\t\t\t\tif (ruleDots.chars[0] == '#')\n\t\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\t\telse if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')\n\t\t\t\t\t\tmemmove(&ruleDots.chars[0], &ruleDots.chars[1],\n\t\t\t\t\t\t\t\truleDots.length-- * CHARSIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\tputChar(file, ruleChars.chars[k], table, NULL);\n\t\t\tfor (int k = 0; k < ruleDots.length; k++)\n\t\t\t\tputChar(file, ruleDots.chars[k], table, NULL);\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_Correct:\n\t\t\t(*table)->corrections = 1;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass2:\n\t\t\tif ((*table)->numPasses < 2) (*table)->numPasses = 2;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass3:\n\t\t\tif ((*table)->numPasses < 3) (*table)->numPasses = 3;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass4:\n\t\t\tif ((*table)->numPasses < 4) (*table)->numPasses = 4;\n\t\tdoPass:\n\t\tcase CTO_Context:\n\t\t\tif (!(nofor || noback)) {\n\t\t\t\tcompileError(file, \"%s or %s must be specified.\",\n\t\t\t\t\t\t_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn compilePassOpcode(file, opcode, noback, nofor, table);\n\t\tcase CTO_Contraction:\n\t\tcase CTO_NoCont:\n\t\tcase CTO_CompBrl:\n\t\tcase CTO_Literal:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\t// check that all characters in a compbrl, contraction,\n\t\t\t// nocont or literal rule are defined (or based on another\n\t\t\t// character)\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_MultInd: {\n\t\t\truleChars.length = 0;\n\t\t\tif (!getToken(file, &token, \"multiple braille indicators\") ||\n\t\t\t\t\t!parseDots(file, &cells, &token))\n\t\t\t\treturn 0;\n\t\t\twhile (getToken(file, &token, \"multind opcodes\")) {\n\t\t\t\topcode = getOpcode(file, &token);\n\t\t\t\tif (opcode == CTO_None) {\n\t\t\t\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {\n\t\t\t\t\tcompileError(file, \"Not a braille indicator opcode.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\truleChars.chars[ruleChars.length++] = (widechar)opcode;\n\t\t\t\tif (atEndOfLine(file)) break;\n\t\t\t}\n\t\t\treturn addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,\n\t\t\t\t\tNULL, noback, nofor, table);\n\t\t}\n\n\t\tcase CTO_Class:\n\t\t\tcompileWarning(file, \"class is deprecated, use attribute instead\");\n\t\tcase CTO_Attribute: {\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(\n\t\t\t\t\t\tfile, \"nofor and noback not allowed before class/attribute\");\n\t\t\t}\n\t\t\tif ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||\n\t\t\t\t\t(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"attribute and class rules must not be both present in a table\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (opcode == CTO_Class)\n\t\t\t\t(*table)->usesAttributeOrClass = 2;\n\t\t\telse\n\t\t\t\t(*table)->usesAttributeOrClass = 1;\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(file, \"Expected %s\", \"attribute name\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tTranslationTableCharacterAttributes attribute = 0;\n\t\t\t{\n\t\t\t\tint attrNumber = -1;\n\t\t\t\tswitch (token.chars[0]) {\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tattrNumber = token.chars[0] - '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attrNumber >= 0) {\n\t\t\t\t\tif (opcode == CTO_Class) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid class name: may not contain digits, use \"\n\t\t\t\t\t\t\t\t\"attribute instead of class\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (token.length > 1 || attrNumber > 7) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid attribute name: must be a digit between 0 and 7 \"\n\t\t\t\t\t\t\t\t\"or a word containing only letters\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(*table)->numberedAttributes[attrNumber])\n\t\t\t\t\t\t// attribute not used before yet: assign it a value\n\t\t\t\t\t\t(*table)->numberedAttributes[attrNumber] =\n\t\t\t\t\t\t\t\tgetNextNumberedAttribute(*table);\n\t\t\t\t\tattribute = (*table)->numberedAttributes[attrNumber];\n\t\t\t\t} else {\n\t\t\t\t\tconst CharacterClass *namedAttr = findCharacterClass(&token, *table);\n\t\t\t\t\tif (!namedAttr) {\n\t\t\t\t\t\t// no class with that name: create one\n\t\t\t\t\t\tnamedAttr = addCharacterClass(\n\t\t\t\t\t\t\t\tfile, &token.chars[0], token.length, *table, 1);\n\t\t\t\t\t\tif (!namedAttr) return 0;\n\t\t\t\t\t}\n\t\t\t\t\t// there is a class with that name or a new class was successfully\n\t\t\t\t\t// created\n\t\t\t\t\tattribute = namedAttr->attribute;\n\t\t\t\t\tif (attribute == CTC_UpperCase || attribute == CTC_LowerCase)\n\t\t\t\t\t\tattribute |= CTC_Letter;\n\t\t\t\t}\n\t\t\t}\n\t\t\tCharsString characters;\n\t\t\tif (!getCharacters(file, &characters)) return 0;\n\t\t\tfor (int i = 0; i < characters.length; i++) {\n\t\t\t\t// get the character from the table, or if it is not defined yet,\n\t\t\t\t// define it\n\t\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t\tputChar(file, characters.chars[i], table, NULL);\n\t\t\t\t// set the attribute\n\t\t\t\tcharacter->attributes |= attribute;\n\t\t\t\t// also set the attribute on the associated dots (if any)\n\t\t\t\tif (character->basechar)\n\t\t\t\t\tcharacter = (TranslationTableCharacter *)&(*table)\n\t\t\t\t\t\t\t\t\t\t->ruleArea[character->basechar];\n\t\t\t\tif (character->definitionRule) {\n\t\t\t\t\tTranslationTableRule *defRule =\n\t\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t\tif (defRule->dotslen == 1) {\n\t\t\t\t\t\tTranslationTableCharacter *dots =\n\t\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], *table);\n\t\t\t\t\t\tif (dots) dots->attributes |= attribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\t\t{\n\t\t\t\tTranslationTableCharacterAttributes *attributes;\n\t\t\t\tconst CharacterClass *class;\n\t\t\tcase CTO_After:\n\t\t\t\tattributes = &after;\n\t\t\t\tgoto doBeforeAfter;\n\t\t\tcase CTO_Before:\n\t\t\t\tattributes = &before;\n\t\t\tdoBeforeAfter:\n\t\t\t\tif (!(*table)->characterClasses) {\n\t\t\t\t\tif (!allocateCharacterClasses(*table)) return 0;\n\t\t\t\t}\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(class = findCharacterClass(&token, *table))) {\n\t\t\t\t\tcompileError(file, \"attribute not defined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*attributes |= class->attribute;\n\t\t\t\tgoto doOpcode;\n\t\t\t}\n\t\tcase CTO_Base:\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed before base\");\n\t\t\t}\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"base opcode must be followed by a valid attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst CharacterClass *mode = findCharacterClass(&token, *table);\n\t\t\tif (!mode) {\n\t\t\t\tmode = addCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\tif (!mode) return 0;\n\t\t\t}\n\t\t\tif (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&\n\t\t\t\t\tmode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"base opcode must be followed by \\\"uppercase\\\", \\\"digit\\\", or a \"\n\t\t\t\t\t\t\"custom attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"Exactly one character followed by one base character is \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tTranslationTableOffset characterOffset;\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\tputChar(file, token.chars[0], table, &characterOffset);\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file, \"Exactly one base character is required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (character->definitionRule) {\n\t\t\t\tTranslationTableRule *prevRule =\n\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: Character already defined (%s). The base rule will take \"\n\t\t\t\t\t\t\"precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n\t\t\t\tcharacter->definitionRule = 0;\n\t\t\t}\n\t\t\tTranslationTableOffset basechar;\n\t\t\tputChar(file, token.chars[0], table, &basechar);\n\t\t\t// putChar may have moved table, so make sure character is still valid\n\t\t\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset];\n\t\t\tif (character->basechar) {\n\t\t\t\tif (character->basechar == basechar &&\n\t\t\t\t\t\tcharacter->mode == mode->attribute) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"%s:%d: Duplicate base rule.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber);\n\t\t\t\t} else {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\t\"%s:%d: A different base rule already exists for this \"\n\t\t\t\t\t\t\t\"character (%s). The new rule will take precedence.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\t\tprintSource(\n\t\t\t\t\t\t\t\t\tfile, character->sourceFile, character->sourceLine));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharacter->basechar = basechar;\n\t\t\tcharacter->mode = mode->attribute;\n\t\t\tcharacter->sourceFile = file->sourceFile;\n\t\t\tcharacter->sourceLine = file->lineNumber;\n\t\t\t/* some other processing is done at the end of the compilation, in\n\t\t\t * finalizeTable() */\n\t\t\treturn 1;\n\t\tcase CTO_EmpMatchBefore:\n\t\t\tbefore |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_EmpMatchAfter:\n\t\t\tafter |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\n\t\tcase CTO_SwapCc:\n\t\tcase CTO_SwapCd:\n\t\tcase CTO_SwapDd:\n\t\t\treturn compileSwap(file, opcode, noback, nofor, table);\n\t\tcase CTO_Hyphen:\n\t\tcase CTO_DecPoint:\n\t\t\t//\tcase CTO_Apostrophe:\n\t\t\t//\tcase CTO_Initial:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleChars.length != 1 || ruleDots.length < 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"One Unicode character and at least one cell are \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\t\t// if (opcode == CTO_DecPoint)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c =\n\t\t\t//   getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tdefault:\n\t\t\tcompileError(file, \"unimplemented opcode.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 778,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if ( (buf->offset < aoffset) || (buf->offset + len > buf->maxlen) ) {\n            debug_print(\"%s\", \"Beyond start/end of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 788,
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ]
  }
]