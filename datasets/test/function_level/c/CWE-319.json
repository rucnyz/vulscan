[
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic wchar_t * G2BSource(wchar_t * password)\n{\n    \n    wcscpy(password, L\"Password1234!\");\n    return password;\n}\n\nstatic void f_uefsujur()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    password = G2BSource(password);\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic wchar_t * B2GSource(wchar_t * password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    return password;\n}\n\nstatic void f_dyqgwdli()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    password = B2GSource(password);\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_wmmknpfi()\n{\n    f_dyqgwdli();\n    f_uefsujur();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wmmknpfi();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400936,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_42.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic wchar_t * Source(wchar_t * password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    return password;\n}\n\nvoid f_hyiowfnl()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    password = Source(password);\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hyiowfnl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400937,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_42.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic char * G2BSource(char * password)\n{\n    \n    strcpy(password, \"Password1234!\");\n    return password;\n}\n\nstatic void f_htwfmerx()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    password = G2BSource(password);\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic char * B2GSource(char * password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    return password;\n}\n\nstatic void f_dzngheio()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    password = B2GSource(password);\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_qxpsoshy()\n{\n    f_dzngheio();\n    f_htwfmerx();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qxpsoshy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400938,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_42.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic char * Source(char * password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    return password;\n}\n\nvoid f_rrfmsnpu()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    password = Source(password);\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rrfmsnpu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400939,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_42.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_gdyjwaxy()\n{\n    char * password;\n    char * &passwordRef = password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    {\n        char * password = passwordRef;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_tcxfphwx()\n{\n    char * password;\n    char * &passwordRef = password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * password = passwordRef;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_vzqugltx()\n{\n    f_gdyjwaxy();\n    f_tcxfphwx();\n}\n\n\n} \n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vzqugltx();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400940,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_33.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\nvoid f_rzdwxtks()\n{\n    char * password;\n    char * &passwordRef = password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * password = passwordRef;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n} \n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rzdwxtks();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400941,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_33.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_todtsqcb()\n{\n    wchar_t * password;\n    wchar_t * &passwordRef = password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    {\n        wchar_t * password = passwordRef;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_vfssdobu()\n{\n    wchar_t * password;\n    wchar_t * &passwordRef = password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        wchar_t * password = passwordRef;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ddfvyvdn()\n{\n    f_todtsqcb();\n    f_vfssdobu();\n}\n\n\n} \n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ddfvyvdn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400942,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_33.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\nvoid f_fbdzkeuf()\n{\n    wchar_t * password;\n    wchar_t * &passwordRef = password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        wchar_t * password = passwordRef;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n} \n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fbdzkeuf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400943,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_33.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_pyxqdamy(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_sysrdeiz()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    f_pyxqdamy(password);\n}\n\n\nstatic void f_hmlxjijj(wchar_t * password)\n{\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_fjnhxzqp()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    f_hmlxjijj(password);\n}\n\nvoid f_nusiipci()\n{\n    f_fjnhxzqp();\n    f_sysrdeiz();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nusiipci();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400944,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_41.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic void f_elqyllsm(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_quuoxklq()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    f_elqyllsm(password);\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_quuoxklq();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400945,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_41.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_hqayzify(char * password)\n{\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_ixkyqeqm()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    f_hqayzify(password);\n}\n\n\nstatic void f_twleveym(char * password)\n{\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_icukhdkx()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    f_twleveym(password);\n}\n\nvoid f_omvfdojl()\n{\n    f_icukhdkx();\n    f_ixkyqeqm();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_omvfdojl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400946,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_41.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic void f_zfkjavfv(char * password)\n{\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_lragbknp()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    f_zfkjavfv(password);\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lragbknp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400947,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_41.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_zprexdzf()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    goto sink;\nsink:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic void f_evjzkzeb()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    \n    strcpy(password, \"Password1234!\");\n    goto sink;\nsink:\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_ausowsig()\n{\n    f_zprexdzf();\n    f_evjzkzeb();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ausowsig();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400948,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_18.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_fdvkwwry()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    goto sink;\nsink:\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fdvkwwry();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400949,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_18.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_rtqsmxky()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    goto sink;\nsink:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic void f_dpofmbfj()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    \n    wcscpy(password, L\"Password1234!\");\n    goto sink;\nsink:\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_acrqqbkx()\n{\n    f_rtqsmxky();\n    f_dpofmbfj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_acrqqbkx();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400950,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_18.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_ghtdjwpw()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    goto sink;\nsink:\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ghtdjwpw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400951,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_18.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_ucjzfswd()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    {\n        wchar_t * passwordCopy = password;\n        wchar_t * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_kpelbszm()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        wchar_t * passwordCopy = password;\n        wchar_t * password = passwordCopy;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_cdtbfxdq()\n{\n    f_ucjzfswd();\n    f_kpelbszm();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cdtbfxdq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400952,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_31.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_jlghilte()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        wchar_t * passwordCopy = password;\n        wchar_t * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jlghilte();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400953,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_31.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_abkczfhj()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    {\n        char * passwordCopy = password;\n        char * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_bhmmxmch()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * passwordCopy = password;\n        char * password = passwordCopy;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_qtdccthf()\n{\n    f_abkczfhj();\n    f_bhmmxmch();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qtdccthf();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400954,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_31.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_dfdbpsmf()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * passwordCopy = password;\n        char * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dfdbpsmf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400955,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_31.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  }
]